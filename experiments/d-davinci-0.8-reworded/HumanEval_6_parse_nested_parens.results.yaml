language: d
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tauto result\
    \ = new long[](0);\n\tforeach(paren_string_group; paren_string.split(\" \"))\n\
    \t{\n\t\t//Stack to keep track of the level of nested parentheses\n\t\tauto depth_stack\
    \ = new Stack!long();\n\t\tlong depth = 0;\n\t\tlong max_depth = 0;\n\t\t//Iterate\
    \ through each of the character in the string,\n\t\t//get the depth and then pop\
    \ the stack.\n\t\t//Keep doing that until the end of the string.\n\t\tforeach(paren;\
    \ paren_string_group)\n\t\t{\n\t\t\tif(paren == '(')\n\t\t\t{\n\t\t\t\tdepth +=\
    \ 1;\n\t\t\t\tdepth_stack.push(depth);\n\t\t\t}\n\t\t\telse if(paren == ')')\n\
    \t\t\t{\n\t\t\t\tdepth = depth_stack.pop;\n\t\t\t}\n\t\t\t//Get the maximum value\
    \ of the depth\n\t\t\tmax_depth = max(max_depth, depth);\n\t\t}\n\t\tresult ~=\
    \ max_depth;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuhqv3n3e.d(15): Error: no property `split` for type `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuhqv3n3e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // tokenize\n\
    \    string[] tokens = split(paren_string, ' ');\n    // container for the result\n\
    \    long[] counter = new long[tokens.length];\n    // iterate over each token\n\
    \    foreach (i, token; tokens) \n    {\n        // calculate the depth of nesting\n\
    \        int depth = 0;\n        int maxDepth = 0;\n        foreach (c; token)\
    \ \n        {\n            switch (c) \n            {\n                case '(':\n\
    \                    depth++;\n                    maxDepth = max(maxDepth, depth);\n\
    \                    break;\n                case ')':\n                    depth--;\n\
    \                    break;\n            }\n        }\n        counter[i] = maxDepth;\n\
    \    }\n    return counter;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpukhnfx29.d(15): Error: undefined identifier `split`\n/tmp/tmpukhnfx29.d(30):
    Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpukhnfx29.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Tokenize\
    \ the input string using space as the delimiter\n    string[] tokens = paren_string.split(\"\
    \ \");\n    long[] results = new long[tokens.length];\n    foreach (i, token;\
    \ tokens) \n    {\n        import std.range;\n        auto r = filter!(a => a\
    \ == '(' || a == ')')(token);\n        import std.algorithm.comparison : max;\n\
    \        results[i] = max(count_parens(r), 0L);\n    }\n    return results;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqj477h5n.d(15): Error: no property `split` for type `string`\n/tmp/tmpqj477h5n.d(20):
    Error: template instance `filter!((a) => a == \''(\'' || a == \'')\'')` template
    `filter` is not defined\n/tmp/tmpqj477h5n.d(22): Error: undefined identifier `count_parens`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqj477h5n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nesting_level;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw2_bncg2.d(15): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw2_bncg2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ input_list = split(paren_string, \" \");\n    long[] output_list;\n    long\
    \ deep = 0L;\n    foreach(paren_group; input_list) \n    {\n        foreach(symbol;\
    \ paren_group) \n        {\n            if(symbol == '(') \n            {\n  \
    \              deep += 1L;\n            } \n            else if(symbol == ')')\
    \ \n            {\n                deep -= 1L;\n            }\n        }\n   \
    \     output_list ~= deep;\n        deep = 0L;\n    }\n    return output_list;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdrnn9sct.d(14): Error: undefined identifier `split`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdrnn9sct.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ token_stream = paren_string.split(\" \");\n    auto paren_groups = token_stream.map!(g\
    \ => g.strip);\n    return paren_groups.map!(\n        (group) => \n        {\n\
    \            long count = 0;\n            long last_max = 0;\n            foreach(paren;\
    \ group)\n            {\n                if(paren == '(')\n                {\n\
    \                    count++;\n                }\n                else if(paren\
    \ == ')')\n                {\n                    count--;\n                }\n\
    \                last_max = max(last_max, count);\n            }\n           \
    \ return last_max;\n        }).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn582f2nm.d(14): Error: no property `split` for type `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn582f2nm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n    in \n \
    \   {\n        assert(paren_string != null);\n    }\n    body\n    {\n       \
    \ bool[] paren_stack = new bool[](paren_string.length);\n        long[] ans =\
    \ new long[](paren_string.length / 2);\n        int curr_index = 0;\n        int\
    \ curr_ans_index = 0;\n        foreach (char c; paren_string)\n        {\n   \
    \         if (c == '(')\n            {\n                paren_stack[curr_index]\
    \ = true;\n                curr_index++;\n            }\n            else if (c\
    \ == ')')\n            {\n                if (curr_index > 0)\n              \
    \  {\n                    curr_index--;\n                    paren_stack[curr_index]\
    \ = false;\n                }\n                else\n                {\n     \
    \               curr_ans_index++;\n                }\n            }\n        \
    \    else if (c == ' ')\n            {\n                ans[curr_ans_index] =\
    \ curr_index;\n                curr_index = 0;\n            }\n        }\n   \
    \     ans[curr_ans_index] = curr_index;\n        return ans[0..curr_ans_index\
    \ + 1];\n    }\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjahuzjx4.d(51): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpjahuzjx4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int accum = 0;\n    foreach(j; 0 .. paren_string.length)\n\
    \    {\n        if(paren_string[j] == '(')\n        {\n            accum++;\n\
    \        }\n        else if(paren_string[j] == ')')\n        {\n            accum--;\n\
    \        }\n        else\n        {\n            result ~= cast(long)max(0, accum);\n\
    \            accum = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2voy01q4.d(29): Error: undefined identifier `max`, did you mean
    function `fmax`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2voy01q4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // 0:\
    \ no open paren\n    // 1: open paren, no opening paren in the middle\n    //\
    \ 2: open paren, opening paren in the middle\n    int state = 0;\n    size_t max_nest\
    \ = 0;\n    size_t cur_nest = 0;\n    long[] res;\n    for (size_t i = 0; i <\
    \ paren_string.length; i++) \n    {\n        if (paren_string[i] == '(') \n  \
    \      {\n            if (state == 0)\n            {\n                state =\
    \ 1;\n            }\n            else\n            {\n                state =\
    \ 2;\n            }\n            cur_nest++;\n            max_nest = max(max_nest,\
    \ cur_nest);\n        }\n        else if (paren_string[i] == ')') \n        {\n\
    \            cur_nest--;\n            if (state == 2)\n            {\n       \
    \         state = 1;\n            }\n            else\n            {\n       \
    \         state = 0;\n            }\n        }\n        else if (paren_string[i]\
    \ == ' ') \n        {\n            if (state == 0)\n            {\n          \
    \      res ~= max_nest;\n                max_nest = 0;\n            }\n      \
    \  }\n    }\n    if (max_nest != 0) \n    {\n        res ~= max_nest;\n    }\n\
    \    return res;\n}\n \n/*\nTakes in an array of arrays of integers, and outputs\
    \ the smallest size of \n    these arrays, with all its elements summed up.\n\
    \    E.g.\n        Input: [[1,2], [2, 3, 4], [5, 6, 7, 8]]\n        Output: [6L,\
    \ 15L]\n    \n    >>> min_sum([[1,2], [2, 3, 4], [5, 6, 7, 8]])\n    [6L, 15L]\n\
    */\nlong[] min_sum(long[][] matrix) \n{\n    size_t min_size = std.algorithm.minElement!(a\
    \ => a.length)(matrix).length;\n    long[]\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkdl5jek9.d(78): Error: no identifier for declarator `long[]`\n/tmp/tmpkdl5jek9.d(78):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpkdl5jek9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    auto\
    \ nParens = 0; // nParens is current nesting level \n    auto maxParens = 1; //\
    \ maxParens is max depth of nesting found so far \n    // parens.init(0, size(paren_string));\n\
    \    long[] parens;\n    for (size_t i = 0; i < size(paren_string); i++) \n  \
    \  { \n        if (paren_string[i] == '(') \n        { \n            nParens +=\
    \ 1; \n            if (nParens > maxParens) \n            { \n               \
    \ maxParens = nParens; \n            } \n        } \n        else if (paren_string[i]\
    \ == ')') \n        { \n            nParens -= 1; \n        } \n        else if\
    \ (paren_string[i] == ' ') \n        { \n            parens ~= maxParens; \n \
    \           maxParens = 1; \n            nParens = 0; \n        } \n    } \n \
    \   return parens; \n} \n/*\n\tfor example, this two lists should be summed, (3\
    \ + 2) + (2 + 4) = 7\n*/\nT[] sumArray(T)(T[] list1, T[] list2)\n{\n\tassert(list1.length\
    \ == list2.length);\n\tT[] list = new T[list1.length];\n\tforeach(i, element;\
    \ list1)\n\t{\n\t\tlist[i] = list1[i] + list2[i];\n\t}\n\treturn list;\n}\nstring[]\
    \ invertParens(string[] parens)\n{\n\tstring[] invert = new string[parens.length];\n\
    \tforeach(i, s; parens)\n\t{\n\t\tinvert[i] = \"(\" ~ s ~ \")\";\n\t}\n\treturn\
    \ invert;\n}\nstring genString(string[] parens)\n{\n\tstring s = \"\";\n\tforeach(i,\
    \ ss; parens)\n\t{\n\t\ts ~=\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph6pz8owf.d(69): Error: expression expected, not `unittest`\n/tmp/tmph6pz8owf.d(70):
    Error: found `{` when expecting `;` following statement\n/tmp/tmph6pz8owf.d(77):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6pz8owf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    const\
    \ long max_level = 99;\n    long[][] open_parens_at_level = new long[][](paren_string.length,\
    \ max_level);\n    long[][] close_parens_at_level = new long[][](paren_string.length,\
    \ max_level);\n    long open_idx = 0;\n    long close_idx = 0;\n    long current_level\
    \ = 0;\n    foreach (paren_idx, paren_char; paren_string) \n    {\n        if\
    \ (paren_char == '(') \n        {\n            open_parens_at_level[open_idx][current_level]\
    \ = paren_idx;\n            open_idx++;\n            current_level++;\n      \
    \  }\n        else if (paren_char == ')') \n        {\n            current_level--;\n\
    \            close_parens_at_level[close_idx][current_level] = paren_idx;\n  \
    \          close_idx++;\n        }\n    }\n    long[] max_level_per_group = new\
    \ long[paren_string.length];\n    for (long i = 0; i < open_idx; i++) \n    {\n\
    \        for (long j = 0; j < max_level; j++) \n        {\n            if (open_parens_at_level[i][j]\
    \ == 0 && close_parens_at_level[i][j] == 0) \n            {\n                max_level_per_group[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return max_level_per_group;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpflxiwjg2.d(53): unittest failure\n----------------\n??:?
    _d_unittestp [0x429281]\n??:? void tmpflxiwjg2.__unittest_L49_C1() [0x4282d9]\n??:?
    void tmpflxiwjg2.__modtest() [0x42846c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e07f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f5e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ad25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42adb4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42acb1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428f35]\n??:? runModuleUnitTests [0x42de55]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429744]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4296cb]\n??:? _d_run_main [0x429636]\n??:? main [0x42847f]\n??:?
    __libc_start_main [0xfb6ea554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ index = 0;\n    auto result = new long[];\n    int cnt = 0;\n    int max_cnt\
    \ = 0;\n    int state = 0;\n    foreach(c; paren_string) \n    {\n        if (c\
    \ == '(') \n        {\n            cnt++;\n            if (state == 0) \n    \
    \        {\n                state = 1;\n            }\n        }\n        else\
    \ if (c == ')') \n        {\n            cnt--;\n            if (state == 1) \n\
    \            {\n                max_cnt = max(max_cnt, cnt);\n            }\n\
    \        }\n        else if (c == ' ') \n        {\n            if (state == 1)\
    \ \n            {\n                state = 0;\n                result ~= max_cnt;\n\
    \                max_cnt = 0;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqlh8jiob.d(15): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpqlh8jiob.d(34): Error: undefined
    identifier `max`, did you mean function `fmax`?\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpqlh8jiob.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.range;\n    import std.typecons;\n    import std.string;\n    import std.algorithm;\n\
    \    import std.stdio;\n    import std.container;\n    auto paren_array = [] {\n\
    \        long[] result;\n        foreach(paren_substr; paren_string.split()) {\n\
    \            long stack_len = 0;\n            long max_len = 0;\n            foreach(paren_char;\
    \ paren_substr) {\n                stack_len += (paren_char == '(') ? 1 : -1;\n\
    \                max_len = max(max_len, stack_len);\n            }\n         \
    \   result ~= max_len;\n        }\n        return result;\n    }();\n    return\
    \ paren_array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprw6u3ho9.d(20): Error: semicolon expected following auto declaration,
    not `{`\n/tmp/tmprw6u3ho9.d(32): Error: expression expected, not `)`\n/tmp/tmprw6u3ho9.d(32):
    Error: found `;` when expecting `)`\n/tmp/tmprw6u3ho9.d(33): Error: found `return`
    when expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmprw6u3ho9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm.comparison : max;\n    import std.algorithm.iteration : filter,\
    \ map;\n    import std.array : array;\n    import std.range : startsWith;\n  \
    \  import std.string : split;\n    static int maxLevel(int[] stack) \n    {\n\
    \        return stack.length - stack.filter!((int x) => x == 0).length;\n    }\n\
    \    auto parenGroups = paren_string.split(\" \");\n    return parenGroups.map!(group\
    \ => \n    {\n        int[] stack;\n        foreach (c; group) \n        {\n \
    \           if (c == '(') \n            {\n                stack ~= 1;\n     \
    \       } \n            else if (c == ')') \n            {\n                stack\
    \ ~= 0;\n            }\n        }\n        return maxLevel(stack);\n    }).array;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb3swjzx0.d(17): Error: module `std.range` import `startsWith`
    not found\n/tmp/tmpb3swjzx0.d(21): Error: no property `length` for type `FilterResult!(function
    (int x) => x == 0, int[])`\n/tmp/tmpb3swjzx0.d(39): Error: cannot implicitly convert
    expression `array(map(parenGroups))` of type `int delegate() pure nothrow @safe[]`
    to `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb3swjzx0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  // TODO:\
    \ implement\n  return [0L];\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpx0evqpvk.d(21): unittest failure\n----------------\n??:?
    _d_unittestp [0x4282c5]\n??:? void tmpx0evqpvk.__unittest_L17_C1() [0x427eb1]\n??:?
    void tmpx0evqpvk.__modtest() [0x428044]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c2af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b142]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4302d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430784]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430261]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b119]\n??:? runModuleUnitTests [0x42c085]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428714]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42869b]\n??:? _d_run_main [0x428606]\n??:? main [0x428057]\n??:?
    __libc_start_main [0x8d8da554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long res = 0L;\n    long max = 0L;\n    bool is_open = false;\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      res += 1L;\n            if(!is_open)\n            {\n                is_open\
    \ = true;\n            }\n        }\n        else if(c == ')')\n        {\n  \
    \          res -= 1L;\n            if(res < 0L)\n            {\n             \
    \   res = 0L;\n            }\n        }\n        else if(c == ' ')\n        {\n\
    \            if(is_open)\n            {\n                result ~= res;\n    \
    \            max = max(max, res);\n                res = 0L;\n               \
    \ is_open = false;\n            }\n        }\n    }\n    if(is_open)\n    {\n\
    \        result ~= res;\n        max = max(max, res);\n    }\n    writeln(result);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4mt25rh.d(41): Error: function expected before `()`, not `max`
    of type `long`\n/tmp/tmpd4mt25rh.d(50): Error: function expected before `()`,
    not `max` of type `long`\n/tmp/tmpd4mt25rh.d(52): Error: `writeln` is not defined,
    perhaps `import std.stdio;` is needed?\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpd4mt25rh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res = new long[];\n    auto current_level = 0L;\n    auto max_level = 0L;\n\
    \    foreach (paren; paren_string)\n    {\n        if (paren == '(')\n       \
    \ {\n            current_level += 1L;\n            max_level = max(max_level,\
    \ current_level);\n        }\n        else if (paren == ')')\n        {\n    \
    \        current_level -= 1L;\n        }\n        else if (paren == ' ')\n   \
    \     {\n            res ~= max_level;\n            max_level = 0L;\n        \
    \    current_level = 0L;\n        }\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpml7ylwph.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpml7ylwph.d(22): Error: undefined
    identifier `max`, did you mean function `fmax`?\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpml7ylwph.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // parens\
    \ will contain all parenthesis groups\n    auto parens = split(paren_string, \"\
    \ \");\n    long[] result;\n    // For each paren group\n    foreach(paren; parens)\
    \ \n    {\n        size_t level = 0;\n        size_t max_level = 0;\n        //\
    \ Iterate over each character\n        foreach(c; paren) \n        {\n       \
    \     if(c == '(') \n            {\n                // Start of a new level\n\
    \                ++level;\n                // Update max level\n             \
    \   max_level = max(max_level, level);\n            } \n            else if(c\
    \ == ')') \n            {\n                // End of current level\n         \
    \       --level;\n            }\n        }\n        // Add the max_level to result\n\
    \        result ~= max_level;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmporq8h6cz.d(15): Error: undefined identifier `split`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmporq8h6cz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    enum\
    \ ParenType { paren_open, paren_close }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4p1vvcjp.d(15): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4p1vvcjp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  auto left_parens\
    \ = paren_string.count!(\"(\");\n  auto right_parens = paren_string.count!(\"\
    )\");\n  if (left_parens != right_parens)\n  {\n    return null;\n  }\n  long[]\
    \ result;\n  import std.algorithm;\n  import std.range;\n  // Split groups of\
    \ nested parentheses using space\n  foreach (paren_group; paren_string.split)\n\
    \  {\n    // Remove the outside parentheses\n    // E.g. (()()) -> ()()\n    auto\
    \ paren_group_no_outer_parens = paren_group[1..$-1];\n    // Split inside parentheses\
    \ using the outside parentheses\n    // E.g. ()() -> [\"\", \"\", \"\", \"\"]\n\
    \    auto paren_group_split = paren_group_no_outer_parens.split(\"\");\n    //\
    \ Calculate the number of nested parentheses.\n    //\n    // This could be done\
    \ by counting the number of left parentheses \n    // in a group and deducting\
    \ the count of the left parens from \n    // the immediately following groups.\n\
    \    // e.g. for (()())\n    //      count the left paren for the first group,\
    \ it is 2\n    //      count the left paren for the second group, it is 1\n  \
    \  //      count the left paren for the third group, it is 0\n    //      The\
    \ number of nested parentheses should be 2 - 0 = 2\n    //      So there are two\
    \ levels of nesting in this group\n    auto number_of_nested_parens = paren_group_split.filter!(x\
    \ => x == \"(\").count;\n    if (number_of_nested_parens == 0)\n    {\n      //\
    \ For groups that contains no parens, return 1\n      // e.g. ()\n      result\
    \ ~= 1;\n    }\n    else\n    {\n      // For group with left parens, return the\
    \ count\n      // e.g. (()())\n      result ~= number_of_nested_parens;\n    }\n\
    \  }\n  return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph7yi6zp_.d(14): Error: no property `count` for type `string`\n/tmp/tmph7yi6zp_.d(15):
    Error: no property `count` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmph7yi6zp_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ groups = paren_string.split(' ');\n    return groups.map!((gs) => reduce!((a,\
    \ b) => max(a, b))(gs.count('('), gs.count(')')));\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb_q37xl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels;\n    size_t level = 0;\n    size_t start = 0;\n    for (size_t p = 0;\
    \ p < paren_string.length; p++) \n    {\n        if (paren_string[p] == '(') \n\
    \        {\n            if (level == 0) \n            {\n                start\
    \ = p;\n            }\n            level++;\n        }\n        else if (paren_string[p]\
    \ == ')') \n        {\n            if (level == 1) \n            {\n         \
    \       levels ~= p - start + 1;\n            }\n            level--;\n      \
    \  }\n    }\n    return levels;\n}\n/*\n    >>> parse_parens_to_tree(\"(()())\
    \ ((())) () ((())()())\")\n    [[\"()()\"], [\"(())\"], [\"()\"], [\"((()))\"\
    , \"()()\"]]\n*/\nstring[][] parse_parens_to_tree(string paren_string) \n{\n \
    \   alias Leaf = tuple(size_t start, size_t end);\n    Leaf[][] leaves;\n    size_t\
    \ level = 0;\n    size_t start = 0;\n    for (size_t p = 0; p < paren_string.length;\
    \ p++) \n    {\n        if (paren_string[p] == '(') \n        {\n            if\
    \ (level == 0) \n            {\n                start = p;\n            }\n  \
    \          level++;\n        }\n        else if (paren_string[p] == ')') \n  \
    \      {\n            if (level == 1) \n            {\n                leaves\
    \ ~= [tuple(start, p)];\n            }\n            level--;\n        }\n    }\n\
    \    string[][] tree;\n    while (leaves.length > 0) \n    {\n        Leaf[][]\
    \ next_leaves;\n        string[] sub_tree;\n        size_t end = 0;\n        for\
    \ (Leaf[] sub_leaves : leaves) \n        {\n            sub_tree ~= paren_string[sub_leaves[0].start..sub_leaves[0].end\
    \ + 1];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqc1a3x9x.d(44): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmpqc1a3x9x.d(73):
    Error: found \''sub_leaves\'' when expecting \'';\'' following statement\n/tmp/tmpqc1a3x9x.d(73):
    Error: expression expected, not \'':\''\n/tmp/tmpqc1a3x9x.d(73): Error: found
    \''leaves\'' when expecting \'';\'' following for condition\n/tmp/tmpqc1a3x9x.d(76):
    Error: found \''unittest\'' instead of statement\n/tmp/tmpqc1a3x9x.d(84): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpqc1a3x9x.d(84):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqc1a3x9x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    return\
    \ to!(long[])(split(paren_string, \" \").map!(paren_string => \n    {\n      \
    \  long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_string) \n        {\n            if(paren == '(') \n            {\n  \
    \              current_depth++;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else \n            {\n                current_depth--;\n\
    \            }\n        }\n        return max_depth;\n    }));\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpah5y3nt5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    immutable long counter;\n    immutable long tmp_counter;\n    immutable\
    \ long start_index;\n    immutable long end_index;\n    immutable long len_paren_string;\n\
    \    immutable long i;\n    immutable long j;\n    immutable long k;\n    immutable\
    \ long idx;\n    immutable long idx_empty;\n    immutable long max_counter;\n\
    \    immutable long no_of_parens;\n    immutable long start_of_paren;\n    immutable\
    \ long end_of_paren;\n    immutable long no_of_empty_parens;\n    immutable long\
    \ element_index;\n    immutable string tmp_string;\n    immutable string[] splitted_paren_string;\n\
    \    immutable string[] elements;\n    immutable string[] empty_paren_array;\n\
    \    immutable tuple[long] group_idx;\n    immutable tuple[long] tuple_of_idx;\n\
    \    immutable tuple[long] empty_tuple_of_idx;\n    immutable tuple[long] begin_tuple_of_idx;\n\
    \    immutable tuple[long] end_tuple_of_idx;\n    immutable tuple[long] max_tuple_of_idx;\n\
    \    immutable tuple[long] element_tuple_of_idx;\n    immutable tuple[long] tmp_tuple_of_idx;\n\
    \    immutable tuple[long] no_of_empty_parens_tuple_of_idx;\n    immutable tuple[long]\
    \ max_counter_tuple_of_idx;\n    immutable tuple[long] tuple_of_tuple_of_idx;\n\
    \    immutable tuple[long] tuple_of_tuple_of_tuple_of_idx;\n    immutable tuple[long]\
    \ tuple_of_tuple_of_tuple_of_tuple_of_idx;\n    immutable tuple[long] tuple_of_tuple_of_tuple_of_tuple_of_tuple_of_idx;\n\
    \    immutable tuple[long] tuple_of_tuple_of_tuple_of_tuple_of_tuple_of_tuple_of_idx;\n\
    \    immutable tuple[long] tuple_of_tuple_of_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb8fo2tot.d(51): Error: semicolon expected, not \''unittest\''\n/tmp/tmpb8fo2tot.d(51):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpb8fo2tot.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parens = \n        paren_string.split.filter!(ch=>ch=='('||ch==')')().map!(ch=>ch=='('\
    \ ? 1L:-1L).\n        array();\n    long[] max = new long[parens.length];\n  \
    \  long[] min = new long[parens.length];\n    max[0] = parens[0];\n    min[0]\
    \ = parens[0];\n    foreach(i,e; parens[1..$])\n    {\n        auto new_max =\
    \ max(max[i-1] + e, e);\n        auto new_min = min(min[i-1] + e, e);\n      \
    \  max[i] = new_max;\n        min[i] = new_min;\n    }\n    return max;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6gnwwuxs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    const\
    \ open = '(';\n    const close = ')';\n    auto num_parens = paren_string.length;\n\
    \    auto paren_list = paren_string.toSlice();\n    auto max_levels = new long[];\n\
    \    int level = 0;\n    bool going_up = true;\n    for (int i = 0; i < num_parens;\
    \ i++) \n    {\n        if (paren_list[i] == open) \n        {\n            if\
    \ (going_up)\n                level++;\n            else \n            {\n   \
    \             max_levels ~= level;\n                level = 1;\n             \
    \   going_up = true;\n            }\n        }\n        else \n        {\n   \
    \         if (going_up) \n            {\n                max_levels ~= level;\n\
    \                level = 1;\n                going_up = false;\n            }\n\
    \            else\n                level++;\n        }\n    }\n    return max_levels;\n\
    }\n/*\n    Given a two vectors of equal length, A, and B.\n    The task is to\
    \ group the elements of the two vectors such that all pairs have the minimum difference\
    \ between them.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplqv80yzm.d(48): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmplqv80yzm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    immutable\
    \ long[] res = [];\n    immutable long[] tmp = [];\n    foreach(paren_seq; paren_string.split)\n\
    \    {\n        // puts(paren_seq);\n        tmp = [];\n        foreach(c; paren_seq)\n\
    \        {\n            if(c == '(')\n            {\n                tmp ~= 1;\n\
    \            }\n            else if(c == ')')\n            {\n               \
    \ res ~= max(tmp);\n                tmp = [];\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4fhs40mz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_vect = split(paren_string);\n    long[] result;\n    foreach(paren_group;\
    \ paren_vect)\n    {\n        long max_depth = 0;\n        long depth = 0;\n \
    \       foreach(ch; paren_group)\n        {\n            if(ch == '(')\n     \
    \       {\n                depth++;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if(ch == ')')\n            {\n    \
    \            depth--;\n            }\n        }\n        if(depth != 0)\n    \
    \    {\n            throw new Exception(\"Error\");\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6dqol02g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ level;\n    int max_level = 0;\n    int cur_level = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        switch(c) \n        {\n            case '(':\n            \
    \    cur_level++;\n                break;\n            case ')':\n           \
    \     cur_level--;\n                break;\n            case ' ':\n          \
    \      level ~= cur_level;\n                cur_level = 0;\n                break;\n\
    \        }\n        max_level = max(max_level, cur_level);\n    }\n    return\
    \ level;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpghcbyqt4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.conv;\n\
    \    auto parens = filter!(x => x.length).split(paren_string);\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt8uypagv.d(19): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt8uypagv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  //var\
    \ paren_list=new long[];\n  long[] paren_list;\n  int len=paren_string.length;\n\
    \  int beg_idx=0;\n  int i=0;\n  int paren_count=0;\n  long max_paren_count=0;\n\
    \  while(i<len)\n  {\n    while(paren_string[i]==' ') i++;\n    beg_idx=i;\n \
    \   paren_count=0;\n    max_paren_count=0;\n    while(i<len)\n    {\n      if(paren_string[i]=='(')\
    \ paren_count++;\n      else if(paren_string[i]==')') paren_count--;\n      else\
    \ if(paren_string[i]==' ')\n      {\n        i++;\n        break;\n      }\n \
    \     if(paren_count>max_paren_count) max_paren_count=paren_count;\n      i++;\n\
    \    }\n    if(i-beg_idx>0) paren_list~=max_paren_count;\n  }\n  return paren_list;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppzp7z_h3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ paren_string.split(' ').map!(parens => parens.length - parens.replaceAll(\"\
    [()]\", \"\").length);\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdugo0h2v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    import std.typecons : Tuple;\n    size_t pos;\n    foreach (paren_group;\
    \ paren_string.split(\" \"))\n    {\n        if (paren_group.empty)\n        \
    \    continue;\n        long max_depth = 0;\n        long depth = 0;\n       \
    \ for (pos = 0; pos < paren_group.length; pos++)\n        {\n            if (paren_group[pos]\
    \ == '(')\n                depth++;\n            else if (paren_group[pos] ==\
    \ ')')\n                depth--;\n            else\n                throw new\
    \ Exception(\"Invalid character in paren group.\");\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        if (depth != 0)\n            throw new Exception(\"\
    Mismatched parenthesis.\");\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm45dmsu8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    auto\
    \ tokens = split(paren_string); \n    long[] nest_array; \n    foreach(token;\
    \ tokens) \n    { \n        long nest_depth = 0L; \n        long curr_max = 0L;\
    \ \n        foreach(ch; token) \n        { \n            if(ch == '(') \n    \
    \        { \n                nest_depth++; \n                curr_max = max(curr_max,\
    \ nest_depth); \n            } \n            else if(ch == ')') \n           \
    \ { \n                nest_depth--; \n            } \n        } \n        nest_array\
    \ ~= curr_max; \n    } \n    return nest_array; \n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp95p4_t4n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    auto parsed_parens = map!(to!int(a.front.idup))(paren_string.split);\n\
    \    return map!(a => a.array.tupleof[0] - a.array.tupleof[1])(zip(parsed_parens,\
    \ parsed_parens.front));\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi68vs500.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parts = split(paren_string, \" \");\n    long[] depth;\n    foreach(group; parts)\
    \ \n    {\n        depth ~= group.count('(') - group.count(')');\n    }\n    return\
    \ depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq40zgcr0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ result = [];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpugbfmnru.d(15): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpugbfmnru.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_depth_array;\n    string[] paren_group_array;\n    Stack!(int)[] paren_group_stack_array;\n\
    \    int[] paren_depth_array_ptr;\n    int[int] paren_depth_array_len;\n    int\
    \ i, j;\n    int num_paren_groups;\n    int max_paren_depth;\n    paren_group_array\
    \ = paren_string.split(' ');\n    num_paren_groups = paren_group_array.length;\n\
    \    paren_depth_array_ptr = new int[num_paren_groups];\n    paren_depth_array_len\
    \ = new int[num_paren_groups];\n    paren_depth_array = new long[num_paren_groups];\n\
    \    foreach (i, paren_group; paren_group_array) \n    {\n        paren_group_stack_array[i]\
    \ = new Stack!(int)();\n        max_paren_depth = 0;\n        foreach (j, paren;\
    \ paren_group) \n        {\n            if (paren == '(') \n            {\n  \
    \              paren_group_stack_array[i].push(1);\n                paren_depth_array_ptr[i]++;\n\
    \            }\n            else if (paren == ')') \n            {\n         \
    \       paren_group_stack_array[i].pop();\n                paren_depth_array_ptr[i]--;\n\
    \            }\n            if (paren_depth_array_ptr[i] > max_paren_depth) \n\
    \            {\n                max_paren_depth = paren_depth_array_ptr[i];\n\
    \            }\n        }\n        paren_depth_array_len[i] = max_paren_depth;\n\
    \    }\n    foreach (i, paren_group; paren_group_array) \n    {\n        paren_depth_array[i]\
    \ = paren_depth_array_len[i];\n    }\n    return paren_depth_array;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_z0w7m85.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nesting = new long[];\n    foreach(paren_stack; split(paren_string))\n \
    \   {\n        long max_nest = 0;\n        long current_nest = 0;\n        foreach(paren;\
    \ paren_stack)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_nest += 1;\n                max_nest = max(max_nest, current_nest);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_nest -= 1;\n            }\n        }\n        max_nesting ~= max_nest;\n\
    \    }\n    return max_nesting;\n}\nstatic assert(parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7me1o4ca.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    import std.algorithm;\n    import std.array;\n    import std.conv;\n\
    \    import std.range;\n    import std.regex;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwjs2ki7n.d(79): Error: Identifier expected following import\n/tmp/tmpwjs2ki7n.d(79):
    Error: \'';\'' expected\n/tmp/tmpwjs2ki7n.d(87): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpwjs2ki7n.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.conv;\n    import std.array;\n    import std.range;\n\
    \    import std.range.primitives;\n    import std.exception;\n    import std.stdio;\n\
    \    import std.format;\n    import std.range.primitives;\n    import std.conv;\n\
    \    import std.string;\n    import std.format;\n    import std.stdio;\n    import\
    \ std.exception;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.datetime;\n    import std.file;\n    import std.range.primitives;\n\
    \    import std.getopt;\n    import std.math;\n    import std.typecons;\n    \n\
    \    return paren_string.\n        split.\n        filter!(p => p!=\"\" && p !=\
    \ \" \").\n        map!(p => new int[p.length]).\n        map!(pp => {\n     \
    \               int sum = 0;\n                    int max_sum = 0;\n         \
    \           for (int i = 0; i < pp.length; i++)\n                    {\n     \
    \                   if (paren_string[i] == '(')\n                        {\n \
    \                           sum += 1;\n                            max_sum = max(max_sum,\
    \ sum);\n                        }\n                        else if (paren_string[i]\
    \ == ')')\n                        {\n                            sum -= 1;\n\
    \                        }\n                    }\n                    return\
    \ max_sum;\n                }).\n        map!(to!long).\n        array;\n}\nlong[]\
    \ parse_nested_parens_slow(string paren_string)\n{\n    import std.algorithm;\n\
    \    import std.conv;\n    import std.array;\n    import std.range;\n    import\
    \ std.range.primitives;\n    import std.exception;\n    import std.stdio;\n  \
    \  import std.format;\n    import std.range.primitives;\n    import std.conv;\n\
    \    import std.string;\n    import std.format;\n    import std.stdio;\n    import\
    \ std.exception;\n    import std.range;\n    import std.algorithm\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzucaez31.d(80): Error: \'';\'' expected\n/tmp/tmpzucaez31.d(88):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzucaez31.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_list;\n    import std.algorithm : map;\n    import std.conv;\n    import\
    \ std.range;\n    import std.range : dropOne, takeWhile;\n    import std.stdio;\n\
    \    import std.typecons;\n    import std.regex;\n    import std.algorithm : reduce;\n\
    \    auto rx_paren = regex(@\"\\((.*?)\\)\");\n    foreach(paren_match; rx_paren.matchAll(paren_string))\n\
    \    {\n        long max_nesting = paren_match.group(1).reduce!((a, b) => a.count(\"\
    (\") == b.count(\"(\") ? b : a).count(\"(\");\n        writeln(max_nesting);\n\
    \    }\n    return paren_list;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3wzunpoi.d(23): Error: expression expected, not \''@\''\n/tmp/tmp3wzunpoi.d(23):
    Error: undefined escape sequence \\(\n/tmp/tmp3wzunpoi.d(23): Error: undefined
    escape sequence \\)\n/tmp/tmp3wzunpoi.d(23): Error: found \''"(((.*?)))"\'' when
    expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3wzunpoi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ result = long[];\n    int deep = 0;\n    for (auto paren: paren_string) \n \
    \   {\n        deep += (paren == '(' ? 1 : -1);\n        if (paren == ' ') \n\
    \        {\n            result ~= deep;\n            deep = 0;\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplrsihpmo.d(14): Error: found \''[\'' when expecting \''.\''
    following long\n/tmp/tmplrsihpmo.d(14): Error: found \'']\'' when expecting identifier
    following \''long.\''\n/tmp/tmplrsihpmo.d(16): Error: no identifier for declarator
    paren\n/tmp/tmplrsihpmo.d(16): Error: expression expected, not \'':\''\n/tmp/tmplrsihpmo.d(16):
    Error: found \''paren_string\'' when expecting \'';\'' following for condition\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrsihpmo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014259
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  // <your\
    \ code here>\n  size_t open_count = 0;\n  size_t[] open_counts;\n  size_t[] result;\n\
    \  immutable size_t paren_string_length = paren_string.length;\n  foreach(immutable\
    \ char current_character; paren_string) \n  {\n    if(current_character == '(')\n\
    \    {\n      open_count++;\n    }\n    else if(current_character == ')')\n  \
    \  {\n      open_counts ~= open_count;\n      open_count--;\n    }\n    else if(current_character\
    \ == ' ')\n    {\n      open_counts ~= 0;\n    }\n  }\n  foreach(immutable size_t\
    \ current_open_count; open_counts)\n  {\n    if(current_open_count != 0)\n   \
    \ {\n      result ~= current_open_count;\n    }\n  }\n  return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xvdctsj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int[][]\
    \ cur_nest_levels = paren_string.split.map!(sub_string =>\n    {\n        int\
    \ nest_level = 0;\n        int max_nest_level = 0;\n        sub_string.chars.each!(paren_char\
    \ =>\n        {\n            if (paren_char == '(')\n            {\n         \
    \       nest_level++;\n                max_nest_level = max(max_nest_level, nest_level);\n\
    \            }\n            else if (paren_char == ')')\n            {\n     \
    \           nest_level--;\n            }\n        });\n        return [nest_level,\
    \ max_nest_level];\n    });\n    return cur_nest_levels.map!(tuple => tuple[1]).array;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3vfq_owh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ counts;\n    long current_max = 0;\n    int len = paren_string.length;\n   \
    \ int spaces = 0;\n    int c = 0;\n    int i = 0;\n    // to count the number\
    \ of group in paren_string\n    for (i = 0; i < len; i++) \n    {\n        if\
    \ (paren_string[i] == ' ')\n            spaces += 1;\n    }\n    counts = new\
    \ long[spaces + 1];\n    i = 0;\n    // to count maximum nesting of each group\n\
    \    foreach (paren; paren_string) \n    {\n        if (paren == '(') \n     \
    \   {\n            current_max += 1;\n            if (current_max > counts[c])\n\
    \                counts[c] = current_max;\n        } \n        else if (paren\
    \ == ')') \n        {\n            current_max -= 1;\n        } \n        else\
    \ if (paren == ' ') \n        {\n            c += 1;\n        }\n    }\n    return\
    \ counts;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpabf7qx4l.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.typecons;\n    import\
    \ std.range;\n    import std.conv;\n    import std.math;\n    import std.meta;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.range;\n    import std.conv;\n    import std.math;\n    import\
    \ std.meta;\n    long[] paren = paren_string.map!(c => c == '(' ? 1L : -1L);\n\
    \    long running_depth = 0;\n    long max_depth = 0;\n    return paren.grouped(500).map!(a\
    \ => \n    {\n        (a.reduce!((x, y) => \n        {\n            running_depth\
    \ += y;\n            max_depth = max(max_depth, running_depth);\n            return\
    \ running_depth;\n        }))[];\n        return max_depth;\n    }).array;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm05i5hvk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Initialize\
    \ a stack to store the count of nested parentheses\n    Stack!int paren_counts\
    \ = new Stack!int();\n    // We do not have to handle the empty string because\
    \ the constraint (1 <= len(paren_string) <= 15) takes care of it.\n    foreach\
    \ (paren; paren_string) \n    {\n        if (paren == '(') \n        {\n     \
    \       // If a '(' is encountered then we increment the count of nested parentheses\
    \ by one.\n            paren_counts.push(paren_counts.empty || paren_counts.top\
    \ == 0 ? 1 : paren_counts.top + 1);\n        }\n        else if (paren == ')')\
    \ \n        {\n            // If a ')' is encountered then we pop the stack for\
    \ the current group and add it to the results.\n            assert(!paren_counts.empty,\
    \ \"Invalid input. Stack should not be empty.\");\n            long current_paren_count\
    \ = paren_counts.pop;\n            paren_counts.push(paren_counts.empty ? 0 :\
    \ paren_counts.top);\n        }\n        else if (paren == ' ') \n        {\n\
    \            // If a space is encountered then we pop the stack for the current\
    \ group and add it to the results.\n            assert(!paren_counts.empty, \"\
    Invalid input. Stack should not be empty.\");\n            long current_paren_count\
    \ = paren_counts.pop;\n            paren_counts.push(paren_counts.empty ? 0 :\
    \ paren_counts.top);\n        }\n        else \n        {\n            assert(false,\
    \ \"Invalid input.\");\n        }\n    }\n    assert(paren_counts.empty, \"Invalid\
    \ input. Stack should be empty.\");\n    return paren_counts.data;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsidhxo8a.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm : map;\n    // TODO: split by ' '(space)\n    long[] a = paren_string.split.map!(x\
    \ => paren_count(x)).array;\n    return a;\n}\n/*\n    Count the levels of nesting\
    \ in a given parentheses string\n*/\nlong paren_count(string parens)\n{\n    long\
    \ count=0, result=0;\n    foreach(x; parens) {\n        if(x == '(') {\n     \
    \       count++;\n            result = max(result, count);\n        }\n      \
    \  else {\n            count--;\n        }\n    }\n    return result;\n}\n// ----------------------------------------------------------------------------------------\n\
    /*\n    Given a 2D array with nulls, write a function that takes a position (x,\
    \ y) and outputs the \n    number of ways you can go from that position to the\
    \ bottom right corner of the array.\n    E.g.\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwrejr57o.d(37): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpwrejr57o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    \n \
    \   \n    long[] results;\n    auto groups = split(paren_string,\" \");\n    //Tuple!(long,long)\
    \ tuple;\n    long max_nesting_level = 0;\n    long nesting_level = 0;\n    foreach(group;\
    \ groups) {\n        foreach(paren; group) {\n            if(paren == '(') {\n\
    \                nesting_level++;\n            }\n            else if(paren ==\
    \ ')') {\n                nesting_level--;\n            }\n        }\n       \
    \ max_nesting_level = max(max_nesting_level, nesting_level);\n        results\
    \ ~= max_nesting_level;\n        max_nesting_level = 0;\n        nesting_level\
    \ = 0;\n    }\n    return results;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3x36d7xp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ lines = paren_string.splitLines();\n    long[] paren_nest_counts;\n    foreach(line;\
    \ lines)\n    {\n        int paren_count = 0;\n        int max_paren_count = 0;\n\
    \        foreach(c; line)\n        {\n            if(c == '(')\n            {\n\
    \                paren_count++;\n                if(paren_count > max_paren_count)\n\
    \                {\n                    max_paren_count = paren_count;\n     \
    \           }\n            }\n            else if(c == ')')\n            {\n \
    \               paren_count--;\n            }\n        }\n        paren_nest_counts\
    \ ~= max_paren_count;\n    }\n    return paren_nest_counts;\n}\n//Z_PARSE_NESTED_PARENS_STUDENT_CODE_END\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkksyrqdr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    auto toks = split(paren_string);\n    foreach(tok; toks) \n   \
    \ {\n        auto cur = tok.filter!(ch => ch == '(' || ch == ')').join;\n    \
    \    long level = 0;\n        long result_level = 0;\n        foreach(ch; cur)\
    \ \n        {\n            if(ch == '(') level++;\n            else level--;\n\
    \            result_level = max(result_level, level);\n        }\n        result\
    \ ~= result_level;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeny73veu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res = new long[];\n    string[] paren_groups = paren_string.split;\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long idx = 0;\n        long max = 0;\n       \
    \ foreach(c; paren_group)\n        {\n            switch(c)\n            {\n \
    \               case '(':\n                    idx += 1;\n                   \
    \ break;\n                case ')':\n                    idx -= 1;\n         \
    \           break;\n            }\n            max = max(max, idx);\n        }\n\
    \        res ~= max;\n    }\n    return res;\n}\n \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2fvp9hwo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ l = new long[0];\n    return l;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkwz9wmmc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Algorithm:\n\
    \    //   - split the paren string by spaces, this gives us a sequence of groups\n\
    \    //   - we will use a stack to keep track of the parens:\n    //       - if\
    \ we encounter an open paren, push the depth of the paren\n    //       - if we\
    \ encounter a close paren, pop from the stack and update the max depth\n    //\
    \   - at the end of each group, get the max depth from the stack\n    //   - push\
    \ back the max depth of each group into a result array\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4dnngq19.d(21): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4dnngq19.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    import std.algorithm : map;\n    import std.math : max;\n  \
    \  import std.regex : findAll, split;\n    import std.string : repeat;\n    import\
    \ std.range : takeWhile, count;\n    import std.typecons : tuple;\n    /*\n  \
    \  This function takes a string and returns the maximum number of nested parentheses.\n\
    \    Time complexity: O(n)\n    Space complexity: O(n) for the stack, O(n) for\
    \ the output array\n    */\n    long max_nested_parens(string group) {\n     \
    \   import std.array : array;\n        long[] stack = new long[](group.length);\n\
    \        long[] output = new long[](group.length);\n        long top = 0;\n  \
    \      long max_level = 0;\n        long level = 0;\n        foreach (index, ch;\
    \ group) {\n            if (ch == '(') {\n                top++;\n           \
    \     level++;\n                max_level = max(max_level, level);\n         \
    \       stack[top] = max_level;\n            } else if (ch == ')') {\n       \
    \         output[index] = stack[top];\n                top--;\n              \
    \  level--;\n            }\n        }\n        return max_level;\n    }\n    return\
    \ paren_string.split(' ').map!max_nested_parens.array;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6y1p8t37.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ ret = new long[](paren_string.length);\n    bool is_word = false;\n    size_t\
    \ i = 0;\n    size_t j = 0;\n    long max_nesting = 0;\n    long paren_count =\
    \ 0;\n    foreach(c; paren_string)\n    {\n        if(c == ' ')\n        {\n \
    \           if(!is_word)\n            {\n                ret[j] = max_nesting;\n\
    \                j++;\n                max_nesting = 0;\n                paren_count\
    \ = 0;\n                i = 0;\n            }\n            is_word = true;\n \
    \       }\n        else\n        {\n            is_word = false;\n           \
    \ paren_count += c == '(' ? 1 : -1;\n            max_nesting = max(max_nesting,\
    \ paren_count);\n            i++;\n        }\n    }\n    ret[j] = max_nesting;\n\
    \    return ret[0..j+1];\n}\n/*\n    Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    For each of\
    \ the group, output the deepest level of nesting of parentheses.\n    E.g. (()())\
    \ has maximum two levels of nesting while ((())) has three.\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps59macgb.d(45): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmps59macgb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_depth = new long[];\n    long nesting_depth = 0;\n    string temp = paren_string;\n\
    \    int max = 0;\n    foreach(c; paren_string)\n    {\n        max_depth ~= 0;\n\
    \    }\n    foreach(c; paren_string)\n    {\n        // writeln(c);\n        if(c\
    \ == \"(\")\n        {\n            nesting_depth++;\n            if(nesting_depth\
    \ > max)\n            {\n                max = nesting_depth;\n            }\n\
    \        }\n        else if(c == \")\")\n        {\n            if(nesting_depth\
    \ > 0)\n            {\n                nesting_depth--;\n            }\n     \
    \   }\n        else if(c == \" \")\n        {\n            max_depth[0] = max;\n\
    \            nesting_depth = 0;\n            max = 0;\n            temp = temp[1..$];\n\
    \            int k = 0;\n            foreach(i; temp)\n            {\n       \
    \         k++;\n                if(i == \" \")\n                {\n          \
    \          break;\n                }\n            }\n            max_depth ~=\
    \ 0;\n            temp = temp[k..$];\n        }\n    }\n    max_depth[0] = max;\n\
    \    // writeln(max_depth);\n    return max_depth;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3p8e22y1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// take\
    \ care of input\n\tlong[] output;\n\tif (paren_string == \"\") \n\t{\n\t\treturn\
    \ output;\n\t}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpegg0eg3o.d(20): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpegg0eg3o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Use\
    \ a stack to keep track of the parentheses\n    auto stack = new Stack!int();\n\
    \    auto paren_counts = new long[];\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        long max_count = 0;\n        foreach (paren; paren_group)\
    \ \n        {\n            if (paren == '(') \n            {\n               \
    \ stack.push(1);\n            } \n            else if (paren == ')') \n      \
    \      {\n                if (stack.empty) \n                {\n             \
    \       max_count = 0;\n                    break;\n                } \n     \
    \           else \n                {\n                    stack.pop();\n     \
    \               max_count = max(max_count, stack.length);\n                }\n\
    \            }\n        }\n        paren_counts ~= max_count;\n    }\n    return\
    \ paren_counts;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpclc614wz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.range.primitives : isInputRange;\n    import std.range.isRandomAccessRange;\n\
    \    import std.range.isInfinite;\n    import std.range : chunkBy, chunks, empty,\
    \ dropOne, ElementType, zip, zipPairs, ElementTypeTuple, elementTypeTuple, iota,\
    \ cycle, only, take, takeExactly, takeOne, chomp, count, countUntil, cycle, drop,\
    \ dropExactly, dropOne, empty, all, indexOf, indexOfSlice, front, empty, front,\
    \ isInfinite, isInputRange, isRandomAccessRange, join, joiner, popFront, popFrontN,\
    \ pushFront, retro, retroN, save, scan, scan!\"a + b\"(\"\", 1, 2, 3, 4), scanRight,\
    \ scanRight!\"a + b\"(\"\", 1, 2, 3, 4), splitter, startsWith, startsWith!\"abc\"\
    , split, split!\"abc\", splitUntil, splitUntil!\"abc\", take, takeExactly, takeWhile,\
    \ takeWhile!\"a < 3\", takeExactlyWhile, takeExactlyWhile!\"a < 3\", retro, retroN,\
    \ save, popFront, popFrontN, pushFront, startsWith, startsWith!\"abc\", endsWith,\
    \ endsWith!\"abc\", find, find!\"a < 3\", findAfter, findAfter!\"a < 3\", findUntil,\
    \ findUntil!\"a < 3\", splitter, split, split!\"abc\", splitUntil, splitUntil!\"\
    abc\", startsWith, startsWith!\"abc\", startsWithAfter, startsWithAfter!\"abc\"\
    , startsWithUntil, startsWithUntil!\"abc\", endsWith, endsWith!\"abc\", endsWithAfter,\
    \ endsWithAfter!\"abc\", endsWithUntil, endsWithUntil!\"abc\", chunkBy, chunks,\
    \ map, map!\"a.idup\", map!\"x + 1\", filter, filter!\"a % 2 == 0\", filter!\"\
    a % 2 == 1\", filter!\"a.length > 1\", map!\"a.idup\", map!\"x + 1\", each, each!\"\
    a.idup\", each!\"x + 1\", each!\"writeln(a)\", fold, fold!\"a + b\", fold!\"a\
    \ + b\", fold!\"a + b\", reduce, reduce!\"a + b\", reduce!\"a + b\", zip, zipPairs,\
    \ zipShortest, zipShort\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6844larp.d(17): Error: \'';\'' expected\n/tmp/tmp6844larp.d(18):
    Error: found \''unittest\'' when expecting \'';\'' following statement\n/tmp/tmp6844larp.d(26):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6844larp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    ulong\
    \ acc = 0;\n    long[] max_depth = new long[];\n    for (int i = 0; i < paren_string.length;\
    \ i++) \n    {\n        auto c = paren_string[i];\n        if (c == '(') \n  \
    \      {\n            acc++;\n        } \n        else if (c == ')') \n      \
    \  {\n            acc--;\n        } \n        else if (c == ' ') \n        {\n\
    \            max_depth ~= acc;\n            acc = 0;\n        }\n    }\n    return\
    \ max_depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ynfoz4h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  long[]\
    \ cur_paren_levels = new long[0];\n  paren_string.split_splitter(new RedBlackTree.CharSplitter('\
    \ ')).foreach!(group => {\n    long max_paren_level = 0;\n    long paren_level\
    \ = 0;\n    group.foreach!(c => {\n      if (c == '(')\n        paren_level++;\n\
    \      else\n        paren_level--;\n      max_paren_level = max(max_paren_level,\
    \ paren_level);\n    });\n    cur_paren_levels ~= max_paren_level;\n  });\n  return\
    \ cur_paren_levels;\n}\n \n// This can be tested by running code.dlang.org\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk92hcbsg.d(15): Error: identifier expected following \''.\'',
    not \''foreach\''\n/tmp/tmpk92hcbsg.d(15): Error: found \''!\'' when expecting
    \'';\'' following statement\n/tmp/tmpk92hcbsg.d(18): Error: identifier expected
    following \''.\'', not \''foreach\''\n/tmp/tmpk92hcbsg.d(18): Error: found \''!\''
    when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpk92hcbsg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ output;\n    // start by separating the parens into groups\n    string[] paren_groups\
    \ = split(paren_string);\n    auto max_depth = 0;\n    for (long i = 0; i < paren_groups.length;\
    \ i++) \n    {\n        max_depth = 0;\n        long[] paren_depth;\n        //\
    \ find the depth of each parenthesis in the group\n        paren_depth = paren_depth_helper(paren_groups[i]);\n\
    \        // grab the largest depth\n        for (long depth = 0; depth < paren_depth.length;\
    \ depth++) \n        {\n            if (paren_depth[depth] > max_depth)\n    \
    \        {\n                max_depth = paren_depth[depth];\n            }\n \
    \       }\n        // append the largest depth to the output list\n        output\
    \ ~= max_depth;\n    }\n    return output;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkli4eci6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tassert(paren_string.length);\n\
    \t\n\tlong[] parsed_data;\n\t\n\tstring[] substrings;\n\tif(paren_string.find(\"\
    \ \") == -1)\n\t{\n\t\tsubstrings ~= paren_string;\n\t}\n\telse\n\t{\n\t\tsubstrings\
    \ = paren_string.split(\" \");\n\t}\n\t\n\tforeach(substring; substrings)\n\t\
    {\n\t\tTuple!(long, long) parsed_substring = parse_nested_parens_helper(substring);\n\
    \t\tparsed_data ~= parsed_substring[0];\n\t}\n\t\n\treturn parsed_data;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdbzsjbd5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result = new long[];\n\tlong max_paren_depth;\n\tforeach(paren_string; paren_group;\n\
    \t{\n\t\t//clear result\n\t\tmax_paren_depth = 0L;\n\t\t//iterate through paren\
    \ group\n\t\tforeach(paren_group; paren;\n\t\t{\n\t\t\t//get depth of parenthesis\n\
    \t\t\tlong depth = paren == '(' ? 1L : -1L;\n\t\t\tmax_paren_depth += depth;\n\
    \t\t});\n\t\t//store max depth\n\t\tresult ~= max_paren_depth;\n\t});\n\t//return\
    \ result\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3m4n6mx0.d(16): Error: found \'';\'' when expecting \'')\''\n/tmp/tmp3m4n6mx0.d(21):
    Error: found \'';\'' when expecting \'')\''\n/tmp/tmp3m4n6mx0.d(26): Error: found
    \'')\'' instead of statement\n/tmp/tmp3m4n6mx0.d(29): Error: found \'')\'' instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3m4n6mx0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n    // We are\
    \ going to use a tuple to represent the character in the string and its nesting\
    \ depth.\n    // The first element is the character and the second element is\
    \ its nesting depth.\n    // The nesting depth starts from 0 and increased by\
    \ 1 when an opening paren is encountered and decreased by 1\n    // when a closing\
    \ paren is encountered.\n    pure @safe nothrow @nogc @nogcinit\n{\n    // Some\
    \ sanity checks for an empty string\n    if (paren_string.empty)\n        return\
    \ [];\n    \n    // accumulator to save the results, initialized to an empty array\n\
    \    auto groups = [](long[])();\n    \n    // initializing the current nesting\
    \ level to 0\n    auto current_level = 0L;\n    \n    // we are going to keep\
    \ looping through the string and update the nesting level every time\n    // we\
    \ encounter an opening or closing paren.\n    // Also, we are going to keep track\
    \ of the maximum nesting level encountered so far.\n    auto max_level = 0L;\n\
    \    \n    // Running through the string and checking for opening and closing\
    \ paren\n    for (auto c : paren_string)\n    {\n        if (c == '(')\n     \
    \   {\n            current_level++;\n            max_level = max(max_level, current_level);\n\
    \        }\n        else if (c == ')')\n        {\n            current_level--;\n\
    \        }\n        else\n        {\n            // if it is a space, we are going\
    \ to save the max nesting level for the current group and\n            // reset\
    \ max_level to 0.\n            if (c == ' ')\n            {\n                groups\
    \ ~= max_level;\n                max_level = 0;\n            }\n        }\n  \
    \  }\n    return groups;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo82q2kmt.d(17): Error: user defined attributes cannot appear
    as postfixes\n/tmp/tmpo82q2kmt.d(17): Error: semicolon expected following function
    declaration\n/tmp/tmpo82q2kmt.d(18): Error: no identifier for declarator nogcinit\n/tmp/tmpo82q2kmt.d(18):
    Error: Declaration expected, not \''{\''\n/tmp/tmpo82q2kmt.d(24): Error: found
    \''[\'' when expecting \''.\'' following long\n/tmp/tmpo82q2kmt.d(24): Error:
    found \'']\'' when expecting identifier following \''long.\''\n/tmp/tmpo82q2kmt.d(35):
    Error: Declaration expected, not \''for\''\n/tmp/tmpo82q2kmt.d(40): Error: no
    identifier for declarator max_level\n/tmp/tmpo82q2kmt.d(40): Error: Declaration
    expected, not \''=\''\n/tmp/tmpo82q2kmt.d(41): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo82q2kmt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ rtn;\n    foreach(immutable p; paren_string.split(\" \"))\n    {\n        if(p\
    \ == \"\")\n            continue;\n        immutable c = p.count(\"(\");\n   \
    \     auto level = new S[1];\n        int count = 0;\n        for(immutable i\
    \ = 0; i < p.length; i++)\n        {\n            if(p[i] == '(')\n          \
    \  {\n                level.insertFront('(');\n                count++;\n    \
    \        }\n            else if(p[i] == ')')\n            {\n                level.removeFront();\n\
    \                count--;\n            }\n            if(count == 0)\n       \
    \         rtn ~= level.length;\n        }\n    }\n    return rtn;\n}\n \n \n \n\
    \ \n/*\n    Given a file containing a 2D grid of integers\n    find the largest\
    \ total for any path from one corner to the opposite.\n    Paths can only move\
    \ down or right.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprhw5hfuu.d(44): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprhw5hfuu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ depth_levels = [0, 1L];\n    auto stack = new std.typecons.Stack!(long)(depth_levels);\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpes99t5t4.d(16): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpes99t5t4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    immutable\
    \ parens = paren_string.split;\n    long[] results;\n    long depth = 0;\n   \
    \ foreach(paren; parens)\n    {\n        immutable parenthesis = to!string(paren);\n\
    \        immutable inside = parenthesis[1..$-1];\n        foreach(ch; inside)\n\
    \        {\n            if(ch == '(')\n                depth++;\n            else\n\
    \                depth--;\n        }\n        results ~= depth;\n        depth\
    \ = 0;\n    }\n    return results;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4olptjze.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    bool[][]\
    \ paren_matrix = \n        paren_string.split(\" \")\n            .map!(paren_string\
    \ => paren_string.byElement.map!(paren_char => paren_char == '(').array)\n   \
    \         .array;\n    long[] max_nesting_per_paren_group = \n        paren_matrix.map!(paren_group\
    \ => {\n            if (paren_group.length == 0) return 0L;\n            long[]\
    \ nesting_depth = new long[paren_group.length];\n            long max_depth =\
    \ 0L;\n            for (size_t i = 0; i < paren_group.length; i++) {\n       \
    \         if (paren_group[i]) {\n                    nesting_depth[i] = (i ==\
    \ 0 ? 1L : nesting_depth[i - 1] + 1L);\n                    max_depth = max(max_depth,\
    \ nesting_depth[i]);\n                } else {\n                    nesting_depth[i]\
    \ = (i == 0 ? 0L : nesting_depth[i - 1] - 1L);\n                }\n          \
    \  }\n            return max_depth;\n        }).array;\n    return max_nesting_per_paren_group;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpltobyl_u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    auto paren_groups = split(paren_string);\n    foreach(paren_group;\
    \ paren_groups) \n    {\n        static if(is(typeof(paren_group) == string))\
    \ \n        {\n            auto begin = paren_group.indexOf(\"(\");\n        \
    \    auto end = paren_group.indexOf(\")\");\n            if(begin != -1 && end\
    \ != -1) \n            {\n                paren_group = paren_group[begin .. end\
    \ + 1];\n            }\n        }\n        res ~= get_paren_level(paren_group);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptw6lfcmi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(string group; paren_string.split(\" \")) \n    {\n    \
    \    long cur_depth = 0;\n        long max_depth = 0;\n        foreach(c; group)\
    \ \n        {\n            if(c == '(')\n                cur_depth++;\n      \
    \      else if(c == ')')\n                cur_depth--;\n            if(cur_depth\
    \ > max_depth)\n                max_depth = cur_depth;\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4dga8ji2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t/*\n\t\
    Only uses one stack for tracking parenthesis nesting\n\t*/\n\tstring[] groups\
    \ = paren_string.split;\n\tlong[] counts = groups.map!(paren_group => \n\t{\n\t\
    \tint max_nesting = 0;\n\t\tint current_nesting = 0;\n\t\tforeach(paren; paren_group)\n\
    \t\t{\n\t\t\tif(paren == '(')\n\t\t\t{\n\t\t\t\t++current_nesting;\n\t\t\t\tmax_nesting\
    \ = max(max_nesting, current_nesting);\n\t\t\t}\n\t\t\telse if(paren == ')')\n\
    \t\t\t{\n\t\t\t\t--current_nesting;\n\t\t\t}\n\t\t}\n\t\tassert(current_nesting\
    \ == 0);\n\t\treturn max_nesting;\n\t}).array;\n\treturn counts;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcloh3ygb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    string[] input_groups = split(paren_string, \" \");\n    foreach(string\
    \ inp; input_groups) \n    {\n        long depth = 0;\n        long max_depth\
    \ = 0;\n        foreach(dchar ch; inp) \n        {\n            if(ch == '(')\
    \ \n            {\n                depth += 1;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if(ch == ')') \n            {\n   \
    \             depth -= 1;\n            }\n        }\n        res ~= max_depth;\n\
    \    }\n    return res;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz51cn3l6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.stdio;\n    size_t max_depth = 0;\n    long[] res;\n    for (string paren_substring\
    \ = paren_string.split(\" \"); paren_substring.length > 0; paren_substring = paren_substring[1\
    \ .. $])\n    {\n        max_depth = 0;\n        immutable current_string = paren_substring[0];\n\
    \        import std.algorithm :\n            count;\n        foreach (size_t depth;\
    \ count(\"(\" ~ paren_substring[0] ~ \")\", \"(\") ~ count(\"(\" ~ paren_substring[0]\
    \ ~ \")\", \")\"))\n        {\n            max_depth = max(max_depth, depth);\n\
    \        }\n        res ~= max_depth;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvgajqccz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ parse_nested_parens(string paren_string) \n    {\n        auto r = paren_string.by_token(space);\n\
    \        auto ret = [];\n        foreach(i, s; r)\n        {\n            int\
    \ depth = 0;\n            int max_depth = 0;\n            foreach(c; s)\n    \
    \        {\n                switch(c)\n                {\n                   \
    \ case '(':\n                        depth++;\n                        max_depth\
    \ = max(max_depth, depth);\n                        break;\n                 \
    \   case ')':\n                        depth--;\n                        break;\n\
    \                }\n            }\n            ret ~= max_depth;\n        }\n\
    \        return ret;\n    }\n    return [2L, 3L, 1L, 3L];\n}\nunittest\n{\n  \
    \  alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk1tm7a0h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // split\
    \ the string by spaces\n    string[] groups = paren_string.split(\" \");\n   \
    \ // allocate a dynamic array to store the result\n    long[] result = new long[0];\n\
    \    // for each group, calculate the depth and add it to the result array\n \
    \   foreach(int i, string group; groups)\n    {\n        enum depth = 0;\n   \
    \     long[] temp = new long[1];\n        foreach(char c; group)\n        {\n\
    \            if(c == '(')\n            {\n                depth++;\n         \
    \   }\n            else if(c == ')')\n            {\n                depth--;\n\
    \            }\n            temp[0] = depth;\n        }\n        result ~= temp[0];\n\
    \    }\n    return result;\n}\n// test the function\nassert(parse_nested_parens(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n// test the function\nassert(parse_nested_parens(\"\
    ()()(())\") == [1L, 1L, 2L]);\n \n \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\
    // 27.  Write a function to flatten an arbitrary-depth list of numbers.\n// Input:\
    \ [1, 2, 3, [4, 5, [6, 7, 8]], 9, 10]\n// Output: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10]\n// Hint: Use std.typecons.Tuple to store the input list. \n \nimport std.algorithm.iteration\
    \ : map;\nimport std.range : take;\nimport std.typecons : Tuple;\n/*\n Input to\
    \ this function is a nested list.\n    Output is a flatten list.\n    E.g. [1,\
    \ 2, 3, [4, 5, [6, 7, 8]], 9, 10] => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Hint:\
    \ Use std.typecons.Tuple to store the input list. \n*/\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiz93a51_.d(40): Error: Declaration expected, not \''assert\''\n/tmp/tmpiz93a51_.d(42):
    Error: Declaration expected, not \''assert\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpiz93a51_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm.iteration : iter, unaryFun;\n    import std.algorithm.comparison\
    \ : max;\n    import std.conv : text;\n    import std.string : find;\n    return\
    \ paren_string.split(\" \").map!((string s)\n        {\n            long max_nesting\
    \ = 1;\n            string paren_group = s;\n            long open_parens = 0;\n\
    \            long close_parens = 0;\n            size_t paren_idx = 0;\n     \
    \       for (size_t i = 0; i < paren_group.length; i++) \n            {\n    \
    \            if (paren_group[i] == '(') \n                {\n                \
    \    open_parens++;\n                    long paren_nesting = open_parens - close_parens;\n\
    \                    max_nesting = max(max_nesting, paren_nesting);\n        \
    \        } \n                else if (paren_group[i] == ')') \n              \
    \  {\n                    close_parens++;\n                }\n            }\n\
    \            return max_nesting;\n        }).array;\n}\n@safe unittest\n{\n  \
    \  assert(parse_nested_parens(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L,\
    \ 3L]);\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa90mbdey.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = paren_string.split;\n    long[] depths;\n    long max_depth;\n\
    \    long depth;\n    // For each of the group, output the deepest level of nesting\
    \ of parentheses.\n    foreach(paren_group; paren_groups) \n    {\n        depth\
    \ = 0;\n        max_depth = 0;\n        foreach(paren; paren_group) \n       \
    \ {\n            if(paren == '(') \n            {\n                depth++;\n\
    \            }\n            else if(paren == ')') \n            {\n          \
    \      depth--;\n            }\n            max_depth = max(max_depth, depth);\n\
    \        }\n        depths ~= max_depth;\n    }\n    return depths;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp935ftjlz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ result = new long[](0);\n    auto tokenizer = split(paren_string, \" \");\n\
    \    foreach(paren_string; tokenizer) \n    {\n        long level = 0L;\n    \
    \    long max_level = 0L;\n        foreach(c; paren_string) \n        {\n    \
    \        if(c == '(')\n                level++;\n            else\n          \
    \      level--;\n            max_level = max(max_level, level);\n        }\n \
    \       result ~= max_level;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzk45k7xu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    string[] split_string = paren_string.split(\" \");\n    foreach(string\
    \ s; split_string)\n    {\n        long num_open_parens = 0;\n        long max_parens\
    \ = 0;\n        long s_size = s.length;\n        for(int i = 0; i < s_size; i++)\n\
    \        {\n            if(s[i] == '(')\n            {\n                num_open_parens++;\n\
    \                max_parens = max(max_parens, num_open_parens);\n            }\n\
    \            else if(s[i] == ')')\n            {\n                num_open_parens--;\n\
    \            }\n        }\n        result ~= max_parens;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp52ttor_d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ output;\n    int cur_max = 0; // current max\n    int max = 0;\n    foreach\
    \ (paren; paren_string) \n    {\n        if (paren == \"(\") \n        {\n   \
    \         cur_max += 1;\n            if (cur_max > max) \n            {\n    \
    \            max = cur_max;\n            }\n        } \n        else if (paren\
    \ == \")\") \n        {\n            if (cur_max > 0) \n            {\n      \
    \          cur_max -= 1;\n            } \n            else \n            {\n \
    \               return [];\n            }\n        } \n        else if (paren\
    \ == \" \") \n        {\n            output ~= max;\n            max = 0;\n  \
    \          cur_max = 0;\n        }\n    }\n    output ~= max;\n    return output;\n\
    }\nlong[] parse_nested_parens_solution(string paren_string) \n{\n    long[] result;\n\
    \    // Process the string, replacing each space with a ')'\n    // With each\
    \ '(' increment the count, with each ')' decrement it.\n    // The max count is\
    \ the deepest level of nesting.\n    string modified = replace(paren_string, \"\
    \ \", \")\");\n    long count = 0;\n    long max = 0;\n    foreach (c; modified)\
    \ \n    {\n        if (c == '(') \n        {\n            count++;\n         \
    \   if (count > max) \n            {\n                max = count;\n         \
    \   }\n        } \n        else if (c == ')') \n        {\n            count--;\n\
    \            if (count < 0) \n            {\n                return result;\n\
    \            }\n        } \n        else \n        {\n            result ~= max;\n\
    \            max = 0;\n        }\n    }\n    result ~= max;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpex_62xrd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \     * append an extra closing parenthesis so that we don't have to check\n \
    \    * for end of string\n     */\n    paren_string ~= \")\";\n    /*\n     *\
    \ set to long(0) so that we can use it as an array index\n     */\n    int last_paren_level\
    \ = 0;\n    /*\n     * use a unique type for the stack so that we can index to\
    \ the\n     * last character in the string\n     */\n    auto LStack = new Tuple!(long[],\
    \ long);\n    auto stack = LStack(long[], 0);\n    /*\n     * use int for the\
    \ loop variable\n     */\n    for (int i = 0; i < paren_string.length; i++)\n\
    \    {\n        switch (paren_string[i])\n        {\n            case '(':\n \
    \               /*\n                 * add an element to the stack\n         \
    \        */\n                stack.length++;\n                stack[0][stack.length\
    \ - 1] = last_paren_level + 1;\n                break;\n            case ')':\n\
    \                /*\n                 * pop the last element\n               \
    \  */\n                last_paren_level = stack[0][stack.length - 1];\n      \
    \          stack.length--;\n                break;\n        }\n    }\n    return\
    \ last_paren_level.dup;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9712vb5y.d(28): Error: found \''[\'' when expecting \''.\''
    following long\n/tmp/tmp9712vb5y.d(28): Error: found \'']\'' when expecting identifier
    following \''long.\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9712vb5y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ longest_chain = (TextGroup[] groups)\n    {\n        long[] results;\n     \
    \   long max = 0;\n        foreach(g; groups)\n        {\n            long len\
    \ = g.span.length;\n            if(len > max)\n            {\n               \
    \ max = len;\n            }\n        }\n        foreach(g; groups)\n        {\n\
    \            if(g.span.length == max)\n            {\n                results\
    \ ~= max;\n            }\n        }\n        return results;\n    };\n    auto\
    \ groups = parse(paren_string, r\"([(]+)\");\n    return longest_chain(groups);\n\
    }\n \n//unittest\nassert(parse_nested_parens(\"(()()) ((())) () ((())()())\")\
    \ == [2L, 3L, 1L, 3L]);\n \nassert(parse_nested_parens(\"((()((()))))\") == [4L]);\n\
    \ \nassert(parse_nested_parens(\"((()((())))) (((())))\") == [4L, 3L]);\n \nassert(parse_nested_parens(\"\
    (((())())) (((())))\") == [4L, 3L]);\n \nassert(parse_nested_parens(\"(((())()))\
    \ (((())))\") == [4L, 3L]);\n \nassert(parse_nested_parens(\"(((())())) (((())))\"\
    ) == [4L, 3L]);\n \nassert(parse_nested_parens(\"()()()()()()\") == [1L, 1L, 1L,\
    \ 1L, 1L, 1L]);\n \nassert(parse_nested_parens(\"(())()()()()()\") == [1L, 1L,\
    \ 1L, 1L, 1L, 1L]);\n \nassert(parse_nested_parens(\"(()())()()()()\") == [2L,\
    \ 1L, 1L, 1L, 1L]);\n \nassert(parse_nested_parens(\"((()))()()()()\") == [3L,\
    \ 1L, 1L, 1L]);\n \nassert(parse_nested_parens\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsceezxf4.d(40): Error: Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(42):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(44): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(46): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpsceezxf4.d(48): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpsceezxf4.d(50): Error: Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(52):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(54): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(56): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpsceezxf4.d(58): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpsceezxf4.d(60): Error: Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(65):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(66): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpsceezxf4.d(67): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpsceezxf4.d(68): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsceezxf4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_levels = [];\n    string[] paren_groups = paren_string.split();\n    for\
    \ (string paren_group; paren_group = paren_groups.popFront()) \n    {\n      \
    \  long level = 0;\n        long max_level = 0;\n        for (long i = 0; i <\
    \ paren_group.length; i++) \n        {\n            switch (paren_group[i]) \n\
    \            {\n                case '(':\n                    level++;\n    \
    \                break;\n                case ')':\n                    level--;\n\
    \                    break;\n            }\n            max_level = max(max_level,\
    \ level);\n        }\n        paren_levels ~= max_level;\n    }\n    return paren_levels;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy0lzs_pq.d(16): Error: found \'')\'' when expecting \'';\''
    following for condition\n/tmp/tmpy0lzs_pq.d(35): Error: found \''return\'' when
    expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy0lzs_pq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong result;\n\
    \timport std.stdio;\n\tauto paren_list = paren_string.split(\" \");\n\tforeach(paren;\
    \ paren_list)\n\t{\n\t\twriteln(paren);\n\t}\n\treturn [];\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyvd0a69q.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ lines = paren_string.split;\n    long[] res;\n    foreach(line; lines)\n   \
    \ {\n        long max = 0;\n        long nested = 0;\n        foreach(c; line)\n\
    \        {\n            if(c == '(')\n            {\n                nested++;\n\
    \                if(nested > max)\n                    max = nested;\n       \
    \     }\n            else if(c == ')')\n            {\n                nested--;\n\
    \            }\n        }\n        res ~= max;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbg59b2un.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_counts;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvjd2jubl.d(15): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvjd2jubl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ length = paren_string.length;\n    //parse_nested_parens\n    long[] res = new\
    \ long[];\n    int i = 0;\n    while(i < length) \n    {\n        if(paren_string[i]\
    \ == '(') \n        {\n            int j = i + 1;\n            long max_depth\
    \ = 0;\n            long depth = 0;\n            while(j < length) \n        \
    \    {\n                if(paren_string[j] == '(') \n                {\n     \
    \               depth++;\n                    max_depth = max(max_depth, depth);\n\
    \                } \n                else if(paren_string[j] == ')') \n      \
    \          {\n                    depth--;\n                }\n              \
    \  else if(paren_string[j] == ' ') \n                {\n                    break;\n\
    \                }\n                j++;\n            }\n            res ~= max_depth;\n\
    \            i = j;\n        }\n        else \n        {\n            i++;\n \
    \       }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjejfbukt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    long\
    \ level = 0L;\n    long[] res = new long[];\n    foreach(w; paren_string.split)\
    \ \n    {\n        if(w.length > 1)\n        {\n            foreach(c; w)\n  \
    \          {\n                if(c == '(')\n                    level += 1L;\n\
    \                else\n                    level -= 1L;\n            }\n     \
    \       res ~= level;\n        }\n    }\n    return res;\n}\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2_cw33o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \    A generalized solution.\n    */\n    auto it = paren_string.splitter;\n \
    \   auto parens = paren_string.splitter;\n    long[] retval;\n    foreach(paren;\
    \ it)\n    {\n        int level = 0;\n        foreach(c; paren)\n        {\n \
    \           if(c == '(') level++;\n            else if(c == ')') level--;\n  \
    \      }\n        retval ~= level;\n    }\n    return retval;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxb10_a84.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \     * We do this by using a stack. A depth stack is used to keep track of depths\n\
    \     * for each '(' and ')' pair. \n     *\n     * (()()((()))) -> [0, 1, 2,\
    \ 1, 0, 1, 2, 3, 2, 1, 0]\n     *\n     * This list is then processed to determine\
    \ the max depth at each level.\n     *\n     * [0, 1, 2, 1, 0, 1, 2, 3, 2, 1,\
    \ 0] -> [2, 3]\n     *\n     * Iterating through the stack:\n     * \n     * \
    \ '(': depth += 1\n     *  ')': depth -= 1, and the depth is the max depth at\
    \ this level\n     *\n     *  For example:\n     *  \n     *  (()) -> [0, 1, 2,\
    \ 1]\n     *  \n     *  or\n     *\n     *  ((())) -> [0, 1, 2, 3, 2, 1, 0]\n\
    \     *\n     *  and so on.\n     *\n     *  The 'depth' vector is then processed\
    \ to determine the max depth at each\n     *  level, which is the solution.\n\
    \     */\n    long[] depth = new long[paren_string.length];\n    long[] max_depth\
    \ = new long[paren_string.length];\n    long[] result = new long[];\n    auto\
    \ current_depth = 0L;\n    auto current_index = 0L;\n    immutable auto total_depth\
    \ = 0L;\n    immutable auto result_index = 0L;\n    immutable auto max_depth_index\
    \ = 0L;\n    /*\n     * Iterate through the paren_string and extract the number\
    \ of parenthesis.\n     *\n     * There is a little bug here if you have an empty\
    \ string. It will return a depth\n     * of one for an empty string, instead of\
    \ zero.\n     */\n    foreach (paren; paren_string) \n    {\n        //println(paren);\n\
    \        if (paren == '(') \n        {\n            current_depth += 1;\n    \
    \        depth[current_index] = current_depth;\n            current_index += 1\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkmrzxcwm.d(64): Error: found \''unittest\'' when expecting \'';\''
    following statement\n/tmp/tmpkmrzxcwm.d(72): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmpkmrzxcwm.d(72): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpkmrzxcwm.d(72): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpkmrzxcwm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.typecons;\n    import\
    \ std.array;\n    import std.typecons;\n    // TODO check for invalid string such\
    \ as \"(()((()\"\n    // TODO check for wrong usage of brackets such as ()(())()\
    \ and ()())()\n    // TODO check for missing input string\n    long[] res = new\
    \ long[paren_string.count(\" \") + 1];\n    int idx = 0;\n    for (int i = 0;\
    \ i < paren_string.length; i++)\n    {\n        if (paren_string[i] == ' ')\n\
    \        {\n            idx++;\n            continue;\n        }\n        res[idx]\
    \ = max(res[idx], recursive_paren_check(paren_string[i .. $]));\n    }\n    return\
    \ res;\n}\nlong recursive_paren_check(string str)\n{\n    if (str.front() != '(')\
    \ return 0;\n    if (str.back() != ')') return 0;\n    import std.range;\n   \
    \ auto str_2 = str[1 .. $ - 1];\n    long num_open = 0;\n    long num_close =\
    \ 0;\n    foreach (idx, c; str_2)\n    {\n        if (c == '(') num_open++;\n\
    \        if (c == ')') num_close++;\n        if (num_open == num_close) return\
    \ 1 + recursive_paren_check(str_2[idx + 1 .. $]);\n    }\n    return 1;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0iytgwya.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ get_nested_parens = () {\n        size_t max_level = 0;\n        long[] paren_levels;\n\
    \        foreach (level; paren_levels) {\n            max_level = max(max_level,\
    \ level);\n        }\n        return max_level;\n    };\n    return paren_string.split(\"\
    \ \").map!(a => (a.chunks(1)).map!(b => get_nested_parens()));\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqhrhzcyj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    \n \
    \   \n    import std.string;\n    auto parts = split(paren_string);\n    auto\
    \ output = new long[];\n    foreach(part; parts)\n    {\n        long part_len\
    \ = part.length;\n        long longest_len = 0;\n        long current_longest_len\
    \ = 0;\n        long current_paren_count = 0;\n        for(long i = 0; i < part_len;\
    \ i++)\n        {\n            if(part[i] == '(')\n            {\n           \
    \     current_paren_count++;\n                current_longest_len++;\n       \
    \     }\n            else if(part[i] == ')')\n            {\n                current_paren_count--;\n\
    \                if(current_paren_count == 0)\n                {\n           \
    \         longest_len = max(longest_len, current_longest_len);\n             \
    \       current_longest_len = 0;\n                }\n            }\n        }\n\
    \        output ~= longest_len;\n    }\n    return output;\n}\n \n/*\n Given a\
    \ list of strings representing stock trade data,\n    determine the maximum profit\
    \ that could have been made buying and selling the stocks.\n    Assume you can\
    \ only buy and sell once (You can't buy and sell several times and use the proceeds\
    \ from one trade on another).\n    E.g. the list [\"7 1 5 3 6 4\"] would return\
    \ 5, since you can buy for 1 and sell for 6.\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6ffii3e8.d(47): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp6ffii3e8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    paren_string\
    \ = paren_string.replace(\" \", \"\");\n    int length = paren_string.length;\n\
    \    long[] levels = new long[length];\n    int[] current_level = new int[length];\n\
    \    int open_parens = 0;\n    foreach (int i, char c; paren_string)\n    {\n\
    \        if (c == '(')\n        {\n            open_parens++;\n            current_level[i]\
    \ = open_parens;\n        }\n        else if (c == ')')\n        {\n         \
    \   levels[i] = current_level[i];\n            current_level[i] = 0;\n       \
    \     open_parens--;\n        }\n    }\n    return levels;\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprnc7etc4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.regex;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7uj_2ubm.d(15): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7uj_2ubm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \    Pseudo code:\n    split the string by space\n    for each group of parenthese:\n\
    \        use stack to keep track of the order and level of nesting, empty the\
    \ stack when encounter ')'\n        for each character in the string:\n      \
    \      if ch == '(':\n                stack.push(1);\n            else:\n    \
    \            if stack.length == 0:\n                    continue;\n          \
    \      else:\n                    stack.pop();\n        push the length of stack\
    \ to the output list\n    */\n    long[] output;\n    output.length = 0;\n   \
    \ long[] stack;\n    stack.length = 0;\n    auto paren_groups = paren_string.split(\"\
    \ \");\n    foreach(auto paren_group; paren_groups)\n    {\n        foreach(auto\
    \ ch; paren_group)\n        {\n            if (ch == '(')\n            {\n   \
    \             stack ~= 1;\n            }\n            else\n            {\n  \
    \              if (stack.length == 0)\n                {\n                   \
    \ continue;\n                }\n                else\n                {\n    \
    \                stack.pop();\n                }\n            }\n        }\n \
    \       output ~= stack.length;\n        stack.length = 0;\n    }\n    return\
    \ output;\n}\nimport std.range;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpni3ky44e.d(34): Error: basic type expected, not auto\n/tmp/tmpni3ky44e.d(34):
    Error: no identifier for declarator int\n/tmp/tmpni3ky44e.d(34): Error: found
    \''auto\'' when expecting \'';\''\n/tmp/tmpni3ky44e.d(34): Error: found \'';\''
    when expecting \'')\''\n/tmp/tmpni3ky44e.d(34): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpni3ky44e.d(36): Error: basic type expected,
    not auto\n/tmp/tmpni3ky44e.d(36): Error: no identifier for declarator int\n/tmp/tmpni3ky44e.d(36):
    Error: found \''auto\'' when expecting \'';\''\n/tmp/tmpni3ky44e.d(36): Error:
    found \'';\'' when expecting \'')\''\n/tmp/tmpni3ky44e.d(36): Error: found \'')\''
    when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpni3ky44e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    auto result = new long[](paren_string.count('('));\n    size_t\
    \ index = 0;\n    size_t i = 0;\n    while (i < paren_string.length)\n    {\n\
    \        if (paren_string[i] == '(')\n        {\n            long left_count =\
    \ 1;\n            long right_count = 0;\n            auto inner_result = new long[];\n\
    \            i += 1;\n            for (;i < paren_string.length; i++)\n      \
    \      {\n                if (paren_string[i] == '(')\n                {\n   \
    \                 left_count += 1;\n                }\n                else if\
    \ (paren_string[i] == ')')\n                {\n                    right_count\
    \ += 1;\n                }\n                if (left_count == right_count)\n \
    \               {\n                    i += 1;\n                    result[index]\
    \ = left_count;\n                    index += 1;\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      i += 1;\n        }\n    }\n    return result[0..index];\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvly_rn4z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ out = new long[];\n    // the accumulator for nested level\n    long nest =\
    \ 0;\n    // the maximum of the `nest`\n    long max_nest = 0;\n    // the tokenizer\
    \ \n    auto toks = split(paren_string, \" \");\n    // for each token\n    foreach(token;\
    \ toks)\n    {\n        // for each char\n        foreach(ch; token)\n       \
    \ {\n            if(ch == '(')\n            {\n                // increase the\
    \ depth of nesting\n                nest += 1;\n                // keep track\
    \ of the maximum\n                max_nest = max(max_nest, nest);\n          \
    \  }\n            else if(ch == ')')\n            {\n                // decrease\
    \ the depth of nesting\n                nest -= 1;\n            }\n        }\n\
    \        // add max_nest to the out\n        out ~= max_nest;\n        // reset\
    \ both counters to 0\n        nest = 0;\n        max_nest = 0;\n    }\n    return\
    \ out;\n}\n \n/*\n Given a 2D matrix (vector of vectors) where each row represents\
    \ a string, find the longest common prefix for all the rows in the given matrix.\n\
    \ \n >>> longest_common_prefix([\"etw\", \"ets\", \"etwo\"])\n \"et\"\n \n >>>\
    \ longest_common_prefix([\"flower\", \"flow\", \"flight\"])\n \"fl\"\n*/\nstring\
    \ longest_common_prefix(string[] strings)\n{\n    // Base case\n    if(strings.length\
    \ == 0)\n    {\n        return \"\";\n    }\n    // initialize the shortest string\
    \ and its length\n    string shortest = strings[0];\n    long len = $shortest;\n\
    \    // find the shortest\n    foreach(s; strings)\n    {\n        if($s < len)\n\
    \        {\n            shortest = s;\n            len = $s;\n        }\n    }\n\
    \    // iterate over each char\n    foreach(i; 0..len)\n    {\n        foreach(s;\
    \ strings)\n        {\n            // if there is a string that doesn't match\
    \ the shortest string\n            if(s[i] != shortest[\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk47nx1nx.d(14): Error: no identifier for declarator long[]\n/tmp/tmpk47nx1nx.d(14):
    Error: found \''out\'' instead of statement\n/tmp/tmpk47nx1nx.d(41): Error: found
    \''out\'' instead of statement\n/tmp/tmpk47nx1nx.d(46): Error: expression expected,
    not \''out\''\n/tmp/tmpk47nx1nx.d(67): Error: \''$\'' is valid only inside []
    of index or slice\n/tmp/tmpk47nx1nx.d(67): Error: semicolon expected, not \''shortest\''\n/tmp/tmpk47nx1nx.d(71):
    Error: \''$\'' is valid only inside [] of index or slice\n/tmp/tmpk47nx1nx.d(71):
    Error: found \''s\'' when expecting \'')\''\n/tmp/tmpk47nx1nx.d(71): Error: found
    \''<\'' instead of statement\n/tmp/tmpk47nx1nx.d(74): Error: \''$\'' is valid
    only inside [] of index or slice\n/tmp/tmpk47nx1nx.d(74): Error: found \''s\''
    when expecting \'';\'' following statement\n/tmp/tmpk47nx1nx.d(78): Error: Declaration
    expected, not \''foreach\''\n/tmp/tmpk47nx1nx.d(78): Error: Declaration expected,
    not \''0\''\n/tmp/tmpk47nx1nx.d(80): Error: no identifier for declarator strings\n/tmp/tmpk47nx1nx.d(80):
    Error: Declaration expected, not \'')\''\n/tmp/tmpk47nx1nx.d(88): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpk47nx1nx.d(89): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpk47nx1nx.d(90): Error: Declaration expected, not \''assert\''\n/tmp/tmpk47nx1nx.d(91):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk47nx1nx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ split_strs = split(paren_string, \" \");\n    long[] result = new long[split_strs.length];\n\
    \    long i = 0;\n    foreach(string parens; split_strs)\n    {\n        long\
    \ level = 0;\n        long max_level = 0;\n        for(char c : parens)\n    \
    \    {\n            if(c == '(')\n            {\n                level++;\n  \
    \              max_level = max(max_level, level);\n            }\n           \
    \ else if(c == ')')\n            {\n                level--;\n            }\n\
    \        }\n        result[i] = max_level;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpup0l7e88.d(21): Error: semicolon expected, not \'':\''\n/tmp/tmpup0l7e88.d(21):
    Error: expression expected, not \'':\''\n/tmp/tmpup0l7e88.d(21): Error: found
    \''parens\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpup0l7e88.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ max_level = 0;\n    int level = 0;\n    long[] paren_levels;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c=='(')\n        {\n            level++;\n\
    \            max_level = max(max_level, level);\n        }\n        else if(c==')')\n\
    \        {\n            level--;\n        }\n        else if(c==' ')\n       \
    \ {\n            paren_levels ~= max_level;\n            max_level = 0;\n    \
    \        level = 0;\n        }\n    }\n    return paren_levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrobhsbb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.typecons;\n    auto nested_parens = paren_string.split(\" \");\n    long[]\
    \ output;\n    foreach(paren_group; nested_parens) \n    {\n        output ~=\
    \ countUntil!(paren_group.array, \n                            (char c) => c ==\
    \ '(', \n                            (char c) => c == ')');\n    }\n    return\
    \ output;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmgeq__zw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n    in (paren_string)\
    \ out (result)\n{\n    size_t paren_string_len = paren_string.length;\n    long[]\
    \ result;\n    static if (paren_string_len >= 2)\n    {\n        string[] split_paren_string\
    \ = paren_string.split;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6_fudu9l.d(13): Error: statement expected to be { }, not (\n/tmp/tmp6_fudu9l.d(13):
    Error: found \''out\'' when expecting \'';\'' following statement\n/tmp/tmp6_fudu9l.d(13):
    Error: Declaration expected, not \''(\''\n/tmp/tmp6_fudu9l.d(28): Error: matching
    \''}\'' expected, not EOF\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6_fudu9l.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Use\
    \ a stack to track the nesting level\n    auto stack = new Stack!(long)();\n \
    \   long level = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptnnkxyfn.d(17): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptnnkxyfn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    long max_level = 0;\n    long level = 0;\n    long depth = 0;\n  \
    \  while (depth < paren_string.length)\n    {\n        char paren = paren_string[depth];\n\
    \        if (paren == '(')\n        {\n            level++;\n            if (level\
    \ > max_level)\n            {\n                max_level = level;\n          \
    \  }\n        }\n        else if (paren == ')')\n        {\n            level--;\n\
    \        }\n        else if (paren == ' ')\n        {\n            res ~= max_level;\n\
    \            max_level = 0;\n            level = 0;\n        }\n        depth++;\n\
    \    }\n    return res;\n}\n/*\n    Given a two dimensional array, each row and\
    \ column is sorted, find if a given integer is in the array.\n    >>> int_search([[0,\
    \ 1, 5, 8],\n                    [2, 6, 8, 9],\n                    [3, 7, 9,\
    \ 10],\n                    [4, 8, 10, 11]])\n    [[1, true], [3, true], [5, true],\
    \ [8, true], [0, false], [2, false], [9, false], [11, false]]\n*/\nTuple!(long,\
    \ bool)[] int_search(long[][] A) \n{\n    long row = 0;\n    long col = A[0].length\
    \ - 1;\n    long n = A.length;\n    long m = A[0].length;\n    Tuple!(long, bool)[]\
    \ res;\n    long[] test_data = [1, 3, 5, 8, 0, 2, 9, 11];\n    foreach (data;\
    \ test_data)\n    {\n        bool found = false;\n        while (row < n && col\
    \ >= 0)\n        {\n            if (A[row][col] == data)\n            {\n    \
    \            found = true;\n                break;\n            }\n          \
    \  else if (A[row][col] > data)\n            {\n                col--;\n     \
    \       }\n            else\n            {\n                row++;\n         \
    \   }\n        }\n        res ~= tuple(\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpda8q8unz.d(79): Error: expression expected, not \''unittest\''\n/tmp/tmpda8q8unz.d(80):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpda8q8unz.d(81): Error: expression
    expected, not \''alias\''\n/tmp/tmpda8q8unz.d(81): Error: found \''candidate\''
    when expecting \'',\''\n/tmp/tmpda8q8unz.d(81): Error: expression expected, not
    \''=\''\n/tmp/tmpda8q8unz.d(81): Error: found \''parse_nested_parens\'' when expecting
    \'',\''\n/tmp/tmpda8q8unz.d(81): Error: expression expected, not \'';\''\n/tmp/tmpda8q8unz.d(83):
    Error: found \''assert\'' when expecting \'',\''\n/tmp/tmpda8q8unz.d(83): Error:
    found \'';\'' when expecting \'',\''\n/tmp/tmpda8q8unz.d(84): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmpda8q8unz.d(85): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpda8q8unz.d(86): Error: expression expected, not \''}\''\n/tmp/tmpda8q8unz.d(87):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmpda8q8unz.d(87): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmpda8q8unz.d(87): Error: expression
    expected, not \''}\''\n/tmp/tmpda8q8unz.d(87): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmpda8q8unz.d(87): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpda8q8unz.d(87):
    Error: found \''EOF\'' when expecting \'';\'' following statement\n/tmp/tmpda8q8unz.d(87):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpda8q8unz.d(87):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpda8q8unz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tbool is_paren_open\
    \ = false;\n\tlong paren_count = 0;\n\tlong[] result = [];\n\tstring current_group\
    \ = \"\";\n\tforeach(c; paren_string)\n\t{\n\t\tif(c == ' ')\n\t\t{\n\t\t\tif(is_paren_open)\n\
    \t\t\t{\n\t\t\t\tresult ~= paren_count;\n\t\t\t\tis_paren_open = false;\n\t\t\t\
    \tparen_count = 0;\n\t\t\t\tcurrent_group = \"\";\n\t\t\t}\n\t\t}\n\t\telse\n\t\
    \t{\n\t\t\tcurrent_group ~= c;\n\t\t\tis_paren_open = true;\n\t\t\tif(c == '(')\n\
    \t\t\t{\n\t\t\t\tparen_count += 1;\n\t\t\t}\n\t\t\telse if(c == ')')\n\t\t\t{\n\
    \t\t\t\tparen_count -= 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(is_paren_open)\n\t{\n\t\t\
    result ~= paren_count;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgdyfbhk_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    while (i < paren_string.length)\n    {\n      \
    \  auto paren_count = 0;\n        while (paren_string[i] != ' ' && i < paren_string.length)\n\
    \        {\n            if (paren_string[i] == '(') \n                paren_count++;\n\
    \            i++;\n        }\n        result ~= paren_count;\n        while (paren_string[i]\
    \ == ' ' && i < paren_string.length) \n            i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvbfq3emq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpldar5n8z.d(15): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldar5n8z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tTuple!(uint,uint)[]\
    \ result = new Tuple!(uint,uint)[];\n\tforeach(paren_string.split(\" \"), sub_string\
    \ => \n\t{\n\t\tuint max_level = 0;\n\t\tuint level = 0;\n\t\tforeach(sub_string,\
    \ ch =>\n\t\t{\n\t\t\tif(ch == '(')\n\t\t\t{\n\t\t\t\tlevel += 1;\n\t\t\t\tmax_level\
    \ = max(max_level, level);\n\t\t\t}\n\t\t\telse if(ch == ')')\n\t\t\t{\n\t\t\t\
    \tlevel -= 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Exception(\"Invalid\
    \ input string. Only '(' and ')' allowed\");\n\t\t\t}\n\t\t});\n\t\tresult ~=\
    \ tuple(max_level, level);\n\t});\n\treturn result.map!(a => a[0]);\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpncwvge1e.d(15): Error: unexpected ( in declarator\n/tmp/tmpncwvge1e.d(15):
    Error: basic type expected, not " "\n/tmp/tmpncwvge1e.d(15): Error: found \''"
    "\'' when expecting \'')\''\n/tmp/tmpncwvge1e.d(15): Error: no identifier for
    declarator paren_string.split(int)\n/tmp/tmpncwvge1e.d(15): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpncwvge1e.d(15): Error: expression expected, not
    \'',\''\n/tmp/tmpncwvge1e.d(15): Error: found \''sub_string\'' when expecting
    \'')\''\n/tmp/tmpncwvge1e.d(15): Error: found \''=>\'' instead of statement\n/tmp/tmpncwvge1e.d(19):
    Error: no identifier for declarator ch\n/tmp/tmpncwvge1e.d(19): Error: found \''=>\''
    when expecting \'';\''\n/tmp/tmpncwvge1e.d(34): Error: use \''{ }\'' for an empty
    statement, not a \'';\''\n/tmp/tmpncwvge1e.d(36): Error: Declaration expected,
    not \'')\''\n/tmp/tmpncwvge1e.d(37): Error: Declaration expected, not \''return\''\n/tmp/tmpncwvge1e.d(38):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpncwvge1e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    paren_string=paren_string.replace(\"\
    (\", \" ( \");\n    paren_string=paren_string.replace(\")\", \" ) \");\n    auto\
    \ tokens=paren_string.split;\n    long[] op_parens_indices=typeof(tokens).init;\n\
    \    long[] cl_parens_indices=typeof(tokens).init;\n    foreach(idx, token; tokens)\n\
    \    {\n        if(token==\"(\")\n        {\n            op_parens_indices~=idx;\n\
    \        }\n        else if(token==\")\")\n        {\n            cl_parens_indices~=idx;\n\
    \        }\n    }\n    long[] levels=typeof(op_parens_indices).init;\n    foreach(idx,\
    \ op_paren_idx; op_parens_indices)\n    {\n        long cl_paren_idx=cl_parens_indices[idx];\n\
    \        long nesting_level=1;\n        foreach(cl_paren_idx_2; cl_parens_indices[idx+1..$])\n\
    \        {\n            if(cl_paren_idx_2<cl_paren_idx)\n            {\n     \
    \           nesting_level++;\n            }\n        }\n        levels~=nesting_level;\n\
    \    }\n    return levels;\n}\n/*\n    Given a list of words, output a list of\
    \ words such that each word is at most two positions away from the previous word.\n\
    \    If it is not possible to achieve this without breaking the list, return null.\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgv5i0h1l.d(46): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpgv5i0h1l.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \    Input:\n        paren_string :: string -- Input string\n    Output:\n   \
    \     max_list :: long[]  -- List of longs representing the max depth of parentheses\
    \ for each group.\n    */\n    long[] max_list;\n    int count = 0;\n    long\
    \ max = 0;\n    foreach(char p; paren_string) \n    {\n        if(p == '(') \n\
    \        {\n            count++;\n            max = max(max, count);\n       \
    \ }\n        else if(p == ')') \n        {\n            count--;\n        }\n\
    \        else if(p == ' ') \n        {\n            max_list ~= max;\n       \
    \     max = 0;\n            count = 0;\n        }\n    }\n    max_list ~= max;\n\
    \    return max_list;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8w36mjgd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ n = paren_string.length;\n    int[long] max_depth;\n    string[long] groups;\n\
    \    long[] max_depths;\n    long s = 0;\n    long e = 0;\n    long i = 0;\n \
    \   int idx = 0;\n    int cur_depth = 0;\n    bool in_group = false;\n    long\
    \ max_depth_for_group = 0;\n    while (i < n) \n    {\n        if (paren_string[i]\
    \ == '(') \n        {\n            if (!in_group) \n            {\n          \
    \      s = i;\n                in_group = true;\n            }\n            cur_depth++;\n\
    \            max_depth_for_group = max(max_depth_for_group, cur_depth);\n    \
    \    } \n        else if (paren_string[i] == ')') \n        {\n            cur_depth--;\n\
    \        } \n        else if (paren_string[i] == ' ') \n        {\n          \
    \  if (in_group) \n            {\n                e = i;\n                groups[idx]\
    \ = paren_string[s..e];\n                max_depth[idx] = max_depth_for_group;\n\
    \                idx++;\n                max_depth_for_group = 0;\n          \
    \      in_group = false;\n            }\n        }\n        i++;\n    }\n    if\
    \ (in_group) \n    {\n        e = i;\n        groups[idx] = paren_string[s..e];\n\
    \        max_depth[idx] = max_depth_for_group;\n        idx++;\n    }\n    return\
    \ max_depth.values;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe7jaas2u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    import std.algorithm;\n    import std.conv;\n    import std.range;\n\
    \    import std.string;\n    import std.typecons;\n    import std.regex;\n   \
    \ // version 1\n    //long[] levels = paren_string.split(\" \").map!((group) =>\
    \ {return to!long(group.count(\"(\")) - to!long(group.count(\")\"));}).array;\n\
    \    //long[] levels = paren_string.split(\" \").map!((group) => {return group.count(\"\
    (\") - group.count(\")\");}).array;\n    long[] levels = paren_string.split(\"\
    \ \").map!((group) => \n    {\n        //return group.filter!(unaryFun!((x) =>\
    \ x == '(' || x == ')')).array.count(\"(\");\n        return group.filter!(unaryFun!((x)\
    \ => x == '(' || x == ')')).array.filter!(unaryFun!((x) => x == '(')).array.length;\n\
    \    }).array;\n    //static if (false)\n    {\n        //auto levels = paren_string.split(\"\
    \ \").map!((group) => \n        //{\n        //    return group.filter!(unaryFun!((x)\
    \ => x == '(' || x == ')')).array.filter!(unaryFun!((x) => x == '(')).array.length;\n\
    \        //}).array;\n    }\n    return levels;\n}\nlong[] parse_nested_parens_v2(string\
    \ paren_string) \n{\n    import std.array;\n    import std.algorithm;\n    import\
    \ std.conv;\n    import std.range;\n    import std.string;\n    import std.typecons;\n\
    \    import std.regex;\n    // version 2\n    long[] levels = paren_string.split(\"\
    \ \").map!((group) => {return group.count(\"(\") - group.count(\")\");}).array;\n\
    \    //return levels;\n    //static if (false)\n    {\n        auto levels = p\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2u5nc_y2.d(53): Error: semicolon expected following auto declaration,
    not \''unittest\''\n/tmp/tmp2u5nc_y2.d(53): Error: found \''unittest\'' instead
    of statement\n/tmp/tmp2u5nc_y2.d(61): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2u5nc_y2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  immutable\
    \ res = [];\n  immutable stack = [];\n  immutable max_count = 0;\n  foreach(const\
    \ curr_char; paren_string) \n  {\n    if(curr_char == '(') \n    {\n      stack\
    \ ~= curr_char;\n      max_count = max(max_count, stack.length);\n    } \n   \
    \ else if(curr_char == ')') \n    {\n      if(stack.length == 0) \n      {\n \
    \       throw new Exception(\"Parenthsis string is not balanced\");\n      }\n\
    \      stack.pop();\n    } \n    else if(curr_char == ' ') \n    {\n      res\
    \ ~= max_count;\n      max_count = 0;\n    }\n  }\n  return res;\n}\n \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpofdd2tjh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ temp_array = explode(paren_string);\n    auto array_list = map!(paren_string\
    \ => to!long(paren_string), temp_array);\n    auto max_list = map!(paren_string\
    \ => count_nesting(paren_string), temp_array);\n    return max_list;\n}\n// This\
    \ function is used to count the nesting level of parentheses.\nlong count_nesting(string\
    \ paren_string)\n{\n    long nested_level = 0;\n    long max_level = 0;\n    foreach(letter;\
    \ paren_string)\n    {\n        if(letter == '(')\n        {\n            nested_level\
    \ += 1;\n            if(nested_level > max_level)\n            {\n           \
    \     max_level = nested_level;\n            }\n        }\n        else if(letter\
    \ == ')')\n        {\n            nested_level -= 1;\n        }\n    }\n    return\
    \ max_level;\n}\n// --------> python code <----------\n// def parse_nested_parens(paren_string):\n\
    //     paren_array = paren_string.split(' ')\n//     return map(count_nesting,\
    \ paren_array)\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpykhl5zj2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren; paren_string.split)\n    {\n      \
    \  long max = 0L;\n        long cur = 0L;\n        foreach(c; paren)\n       \
    \ {\n            if(c == '(')\n            {\n                cur += 1L;\n   \
    \             max = max(max, cur);\n            }\n            else if(c == ')')\n\
    \            {\n                cur -= 1L;\n            }\n        }\n       \
    \ result ~= max;\n    }\n    return result;\n}\n// Uncomment to test.\nunittest\
    \ \n{\n    assert(parse_nested_parens(\"(()()) ((())) () ((())()())\") == [2L,\
    \ 3L, 1L, 3L]);\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5euccpc_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    immutable\
    \ long[] arr;\n    foreach(paren_stack; split(paren_string))\n    {\n        long[]\
    \ stack;\n        foreach(c; paren_stack)\n        {\n            switch(c)\n\
    \            {\n                case '(':\n                    stack ~= 1;\n \
    \                   break;\n                case ')':\n                    assert(stack.length\
    \ > 0);\n                    stack.length -= 1;\n                    break;\n\
    \                default:\n                    assert(0);\n            }\n   \
    \     }\n        assert(stack.length == 0);\n        arr ~= paren_stack.length\
    \ - 1;\n    }\n    return arr;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgd6kfdst.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    char[] current_group;\n    foreach(current_group; paren_string.split)\n\
    \    {\n        long depth = 0;\n        long max_depth = 0;\n        foreach(char\
    \ c; current_group)\n        {\n            if(c == '(')\n            {\n    \
    \            depth += 1;\n                max_depth = max(max_depth, depth);\n\
    \            }\n            else if(c == ')')\n            {\n               \
    \ depth -= 1;\n            }\n        }\n        if(depth != 0)\n        {\n \
    \           writeln(\"Error: ill-formed paren-string\");\n            return res;\n\
    \        }\n        res ~= max_depth;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoxk5n3px.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tauto groups\
    \ = paren_string.split;\n\tlong[] result;\n\tfor (auto g; groups) \n\t{\n\t\t\
    long count = 0L;\n\t\tlong max = 0L;\n\t\tfor (auto c; g) \n\t\t{\n\t\t\tswitch\
    \ (c) \n\t\t\t{\n\t\t\t\tcase '(': count++; break;\n\t\t\t\tcase ')': count--;\
    \ max = max(max, count); break;\n\t\t\t}\n\t\t}\n\t\tresult ~= max;\n\t}\n\treturn\
    \ result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt3pr82kg.d(16): Error: no identifier for declarator g\n/tmp/tmpt3pr82kg.d(20):
    Error: no identifier for declarator c\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpt3pr82kg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    auto\
    \ parens = split(paren_string, \" \");\n    long[] res;\n    for (; !parens.empty;\
    \ parens.popFront)\n    {\n        // This one counts the parentheses in a single\
    \ group.\n        long counter = 0L;\n        long ans = 0L;\n        for (; !parens.front.empty;\
    \ parens.front.popFront)\n        {\n            if (parens.front.front == '(')\n\
    \            {\n                ++counter;\n                ans = max(ans, counter);\n\
    \            }\n            else if (parens.front.front == ')')\n            {\n\
    \                --counter;\n            }\n        }\n        res ~= ans;\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0mwnnqfw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ paren_count = [];\n\tlong c = 0L;\n\t//char[] parsed = paren_string.toCharArray();\n\
    \tfor (long i = 0L; i < paren_string.length; i++) \n\t{\n\t\tif (paren_string[i]\
    \ == '(') \n\t\t{\n\t\t\tc++;\n\t\t}\n\t\telse if (paren_string[i] == ')') \n\t\
    \t{\n\t\t\tc--;\n\t\t}\n\t\telse if (paren_string[i] == ' ') \n\t\t{\n\t\t\tparen_count\
    \ ~= c;\n\t\t\tc = 0L;\n\t\t}\n\t}\n\treturn paren_count;\n}\n/*\n * Function\
    \ to reverse the order of elements in the linked list.\n * >>> reverse_linked_list(toLinkedList([1,\
    \ 2, 3, 4, 5]))\n * LinkedList!(int)(5, 4, 3, 2, 1)\n */\nLinkedList!(T) reverse_linked_list(LinkedList!(T)\
    \ list) \n{\n\tLinkedList!(T) rev_list = null;\n\tfor (T element; !list.empty;\
    \ list.popFront()) \n\t{\n\t\telement = list.front;\n\t\trev_list.pushFront(element);\n\
    \t}\n\treturn rev_list;\n}\n/*\n * Function to return the greatest common divisor\
    \ of two integers.\n * >>> greatest_common_divisor(9, 12)\n * 3\n */\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_76tpx80.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // TODO:\
    \ add your code here\n    long[] result;\n    string[] paren_strings = split(paren_string,\
    \ \" \");\n    int length = paren_strings.length;\n    for (int i = 0; i < length;\
    \ i++)\n    {\n        string paren_string = paren_strings[i];\n        int level\
    \ = 0;\n        int max = 0;\n        int index = 0;\n        while (index < paren_string.length)\n\
    \        {\n            if (paren_string[index] == '(')\n            {\n     \
    \           level++;\n                if (level > max)\n                {\n  \
    \                  max = level;\n                }\n            }\n          \
    \  else if (paren_string[index] == ')')\n            {\n                level--;\n\
    \            }\n            index++;\n        }\n        result ~= max;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmiruf8nc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[0];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1s0q_2w8.d(15): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1s0q_2w8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ deepest = new long[paren_string.countSpaces() + 1];\n    string t = replace(paren_string,\
    \ \" \", \"\");\n    foreach (c; t) \n    {\n        static if (c == '(') \n \
    \       {\n            static int i = 0;\n            static int level = 0;\n\
    \            level++;\n            if (level > deepest[i])\n                deepest[i]\
    \ = level;\n        }\n        else if (c == ')') \n        {\n            level--;\n\
    \            if (level == 0)\n                i++;\n        }\n    }\n    return\
    \ deepest;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps6ib1375.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// Convert\
    \ string to char array\n\tauto paren_char = paren_string.array;\n\t// Initialize\
    \ deque\n\tauto parse_parens = deque!long();\n\t// Initialize current nested parenthesis\
    \ level\n\tlong curr_level = 0;\n\t// Iterate over char array\n\tforeach(ch; paren_char)\n\
    \t{\n\t\t// switch statement to do the following:\n\t\t// \t1. if we encounter\
    \ (, increment the current level by 1\n\t\t// \t2. if we encounter ), decrease\
    \ the current level by 1\n\t\t// \t3. if we encounter space, store the value of\
    \ current level and reset the current level to 0\n\t\tswitch(ch)\n\t\t{\n\t\t\t\
    case '(':\n\t\t\t\tcurr_level++;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tcurr_level--;\n\
    \t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tparse_parens.insertBack(curr_level);\n\
    \t\t\t\tcurr_level = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t// return tuple of the\
    \ deque\n\treturn tuple(parse_parens);\n}\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwt2os7wp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  // Use\
    \ assert to make sure the input string is valid\n  assert(paren_string.filter!((c)\
    \ => c == '(' || c == ')').empty);\n  \n  // Split the string by space and get\
    \ a list of groups\n  auto groups = paren_string.split;\n  \n  // Iterate over\
    \ each group\n  return groups.map!((string group) => {\n      // Initialize max_level\
    \ to zero\n      long max_level = 0L;\n      // Initialize current_level to zero\n\
    \      long current_level = 0L;\n      // Iterate over the characters in the group\n\
    \      foreach (char ch; group) \n      {\n          // If the character is an\
    \ open paren, increment the current_level by 1\n          if (ch == '(') \n  \
    \        {\n              current_level++;\n          }\n          // If the character\
    \ is a close paren, decrement the current_level by 1\n          else if (ch ==\
    \ ')') \n          {\n              current_level--;\n          }\n          //\
    \ Make sure current_level doesn't go below zero\n          assert(current_level\
    \ >= 0L);\n          // Update max_level if needed\n          max_level = max(max_level,\
    \ current_level);\n      }\n      // Make sure all parens are closed for the group\n\
    \      assert(current_level == 0L);\n      // Return the max_level for the group\n\
    \      return max_level;\n  }).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkvbm2aa3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tenum NestedParentheses\
    \ { left, right, other }\n\tenum ParenthesesGroupType { empty, paren }\n\t\n\t\
    // Peek at the iterator, but don't advance it\n\tchar peek(R)(R r)\n\t{\n\t\t\
    auto c = r.front;\n\t\treturn c;\n\t}\n\t\n\t// Advance iterator and return the\
    \ peeked at character\n\tchar adv(R)(ref R r)\n\t{\n\t\tauto c = r.front;\n\t\t\
    r.popFront();\n\t\treturn c;\n\t}\n\t\n\t// Get the next parentheses group\n\t\
    template getNextParenthesesGroup(R)\n\t{\n\t\tstatic if (is(ElementType!R == dchar))\n\
    \t\t{\n\t\t\tParenthesesGroupType getNextParenthesesGroup(R)(ref R r)\n\t\t\t\
    {\n\t\t\t\tauto n = 0;\n\t\t\t\twhile (!r.empty)\n\t\t\t\t{\n\t\t\t\t\tconst c\
    \ = adv(r);\n\t\t\t\t\tstatic if (is(NestedParentheses.other : c))\n\t\t\t\t\t\
    {\n\t\t\t\t\t\tif (c == '(')\n\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\telse if (c == ')')\n\
    \t\t\t\t\t\t\tn--;\n\t\t\t\t\t}\n\t\t\t\t\tif (c == ' ' || n < 0)\n\t\t\t\t\t\t\
    break;\n\t\t\t\t}\n\t\t\t\treturn n == 0 ? ParenthesesGroupType.empty :\n\t\t\t\
    \t\tn > 0 ? ParenthesesGroupType.paren : ParenthesesGroupType.empty;\n\t\t\t}\n\
    \t\t}\n\t\telse static if (is(ElementType!R == char))\n\t\t{\n\t\t\tParenthesesGroupType\
    \ getNextParenthesesGroup(R)(ref R r)\n\t\t\t{\n\t\t\t\tauto n = 0;\n\t\t\t\t\
    while (!r.empty)\n\t\t\t\t{\n\t\t\t\t\tconst c = adv(r);\n\t\t\t\t\tstatic if\
    \ (is(NestedParentheses.other : c))\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsvu8o_s2.d(66): Error: found \''unittest\'' instead of statement\n/tmp/tmpsvu8o_s2.d(74):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpsvu8o_s2.d(74):
    Error: matching \''}\'' expected, not EOF\n/tmp/tmpsvu8o_s2.d(74): Error: template
    member expected\n/tmp/tmpsvu8o_s2.d(74): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpsvu8o_s2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[];\n    paren_string.split(\" \").each!(input =>\n       \
    \ levels ~= deep_nesting_level(input)\n    );\n    return levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptrzjt20m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ ret = [];\n    for (i, part; paren_string.splitWhitespace.indexOf(part, i))\n\
    \    {\n        assert(part.startsWith(\"(\") && part.endsWith(\")\"));\n    \
    \    int count = 0;\n        int max = 0;\n        for (ch; part)\n        {\n\
    \            if (ch == '(')\n                count++;\n            else\n    \
    \            count--;\n            max = max(max, count);\n        }\n       \
    \ ret ~= max;\n    }\n    return ret;\n}\n// https://www.hackerrank.com/challenges/ctci-ransom-note/problem\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7qff8_92.d(15): Error: found \'')\'' when expecting \'';\''
    following for condition\n/tmp/tmp7qff8_92.d(20): Error: found \'')\'' when expecting
    \'';\'' following for condition\n/tmp/tmp7qff8_92.d(28): Error: found \''ret\''
    when expecting \'')\''\n/tmp/tmp7qff8_92.d(28): Error: found \''~=\'' instead
    of statement\n/tmp/tmp7qff8_92.d(30): Error: found \''return\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7qff8_92.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ result = new long[](paren_string.count(\" \")+1);\n    auto i = 0L;\n    auto\
    \ token = \"\";\n    foreach(token; split(paren_string, \" \"))\n    {\n     \
    \   auto max_depth = 0L;\n        auto depth = 0L;\n        foreach(c; token)\n\
    \        {\n            if(c == '(')\n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(c == ')')\n            {\n                depth--;\n            }\n\
    \        }\n        result[i++] = max_depth;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp07msm6uc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\treturn\
    \ paren_string.\n\t\tsplit().\n\t\tmap!(p => \n\t\t{\n\t\t\tlong nest_level =\
    \ 0L;\n\t\t\tforeach(char c; p)\n\t\t\t{\n\t\t\t\tnest_level += (c == '(') ? 1L\
    \ : -1L;\n\t\t\t}\n\t\t\treturn nest_level;\n\t\t}\n\t).array;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmmllbs5k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ nesting_count;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3z4c4tyd.d(15): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3z4c4tyd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_stack;\n    long[] paren_levels;\n    long max_level;\n    paren_stack\
    \ = [];\n    paren_levels = [];\n    max_level = 0L;\n    foreach (c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            paren_stack ~= 1L;\n\
    \            max_level += 1L;\n        }\n        else if (c == ')') \n      \
    \  {\n            max_level -= 1L;\n            paren_stack ~= 0L;\n        }\n\
    \        else if (c == ' ') \n        {\n            paren_levels ~= max_level;\n\
    \            paren_stack = [];\n            max_level = 0L;\n        }\n    }\n\
    \    paren_levels ~= max_level;\n    paren_stack = [];\n    max_level = 0L;\n\
    \    return paren_levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpujg27wyd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpldar5n8z.d(15): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldar5n8z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_list;\n    foreach(paren_group; paren_string.split())\n    {\n       \
    \ int previous_depth = 0;\n        int current_depth = 0;\n        foreach(c;\
    \ paren_group)\n        {\n            if(c == '(')\n            {\n         \
    \       ++current_depth;\n            }\n            else if(c == ')')\n     \
    \       {\n                --current_depth;\n            }\n            previous_depth\
    \ = max(previous_depth, current_depth);\n        }\n        paren_list ~= previous_depth;\n\
    \    }\n    return paren_list;\n}\nimport std.algorithm : map;\nassert([\"2\"\
    , \"3\", \"1\", \"3\"] ==\n    parse_nested_parens(\"(()()) ((())) () ((())()())\"\
    ).map!(to!string));\n \n/*\n    Given two numbers A and B, output 1 if bitwise\
    \ and of A and B is greater than bitwise or of A and B, else 0.\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5txxu8ek.d(36): Error: Declaration expected, not \''assert\''\n/tmp/tmp5txxu8ek.d(39):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5txxu8ek.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ stack = Stack!char(16);\n    long[] output;\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        stack.clear();\n        size_t max_stack_size = 0;\n \
    \       foreach (paren; paren_group) \n        {\n            if (paren == '(')\
    \ \n            {\n                stack.push(paren);\n                if (stack.length\
    \ > max_stack_size)\n                    max_stack_size = stack.length;\n    \
    \        }\n            else if (paren == ')') \n            {\n             \
    \   if (stack.length > 0)\n                    stack.pop();\n            }\n \
    \       }\n        output ~= max_stack_size;\n    }\n    return output;\n}\n//\
    \ import std.stdio;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18t2sk3j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    size_t[int]\
    \ stack = new size_t[int];\n    long[] depth = new long[];\n    stack.length =\
    \ paren_string.length;\n    stack.length = 0;\n    char[] chars = paren_string.dup;\n\
    \    foreach (size_t i, char ch; chars) \n    {\n        if (ch == '(') \n   \
    \     {\n            stack ~= i;\n        }\n        else if (ch == ')') \n  \
    \      {\n            size_t idx = stack.pop;\n            if (stack.length ==\
    \ 0) \n            {\n                depth ~= i - idx + 1;\n            }\n \
    \       }\n    }\n    return depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw1anu1_5.d(14): Error: need size of rightmost array, not type
    int\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw1anu1_5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ paren_string.split.map!((s) => s.filter!(ch => ch == '(').length - s.filter!(ch\
    \ => ch == ')').length).filter!(p => p == 0).map!(m => {auto v = m.to!(ulong);return\
    \ ulong.max(v, 0L);});\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_0bbm8u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Starting\
    \ and ending indices of the substrings within paren_string that do not contain\
    \ ' '.\n    // These substrings contain the groups to be parsed.\n    int[] sub_paren_ranges\
    \ = [0];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwsrr3g_p.d(17): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwsrr3g_p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parens = paren_string.split(\" \");\n    return parens.map!((string p) =>\n\
    \    {\n        long max_level = 0;\n        long current_level = 0;\n       \
    \ foreach(ch; p)\n        {\n            switch(ch)\n            {\n         \
    \       case '(':\n                    ++current_level;\n                    max_level\
    \ = max(max_level, current_level);\n                    break;\n             \
    \   case ')':\n                    --current_level;\n                    break;\n\
    \            }\n        }\n        return max_level;\n    }).array;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbozkqib2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i, previous_ending_brace;\n    int paren_idx;\n    uint paren_string_size;\n\
    \    // We will store the position of the left parentheses and of the ending brace\n\
    \    //   in two arrays.\n    // The size of the second array is one more than\
    \ the first one to handle the special case\n    //   when the last parenthesis\
    \ doesn't have a closing brace (no closing brace).\n    uint[] start_paren_idx_array;\n\
    \    uint[] end_paren_idx_array;\n    bool is_previous_parenthesis_open;\n   \
    \ int previous_open_paren_idx;\n    uint start_paren_idx_array_size;\n    uint[]\
    \ start_paren_idx_array_temp;\n    uint[] end_paren_idx_array_temp;\n    uint\
    \ level;\n    uint[] level_array;\n    uint[] level_array_temp;\n    bool is_paren_string_empty;\n\
    \    // Check if the string is empty.\n    is_paren_string_empty = true;\n   \
    \ i = 0;\n    while(i < paren_string.length) \n    {\n        if(paren_string[i]\
    \ != ' ') \n        {\n            is_paren_string_empty = false;\n          \
    \  break;\n        }\n        i += 1;\n    }\n    if(is_paren_string_empty) \n\
    \    {\n        return [];\n    }\n    // Allocate memory for the two arrays\n\
    \    start_paren_idx_array = new uint[paren_string.length];\n    end_paren_idx_array\
    \ = new uint[paren_string.length + 1L];\n    //\n    //   Go through the string\
    \ and store the position of the left parentheses and of the ending brace\n   \
    \ //   in two arrays.\n    //\n    //   Note that we assume there is at least\
    \ one parenthesis in the string.\n    start_paren_idx_array_size = 0UL;\n    is_previous_parenthesis_open\
    \ = false;\n    previous_open_paren_idx = -1;\n    i = 0;\n    while(i < paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5yj02532.d(62): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp5yj02532.d(70):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5yj02532.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nesting_levels = new long[];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqtb9rbdo.d(15): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtb9rbdo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels;\n    int n = 0;\n    int parenthesis_depth = 0;\n    int parenthesis_start\
    \ = 0;\n    int parenthesis_end = 0;\n    long paren_count = 0;\n    foreach(i,\
    \ char c; paren_string) \n    {\n        if (c == '(') \n        {\n         \
    \   parenthesis_depth++;\n            paren_count++;\n            if (parenthesis_depth\
    \ == 1) \n            {\n                parenthesis_start = i;\n            }\n\
    \        } \n        else if (c == ')') \n        {\n            parenthesis_depth--;\n\
    \            if (parenthesis_depth == 0) \n            {\n                levels\
    \ ~= count_nested_parens(paren_string[parenthesis_start..i]);\n            }\n\
    \        }\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcy49x3mp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ paren_string.split(' ').map!(g => \n                                       \
    \     g.filter!(p => p == '(' || p == ')')\n                                 \
    \            .to!string()\n                                             .length);\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp69flhfds.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_levels = new long[];\n    long level = 0;\n    foreach(ch; paren_string)\n\
    \    {\n        if(ch == '(')\n        {\n            level++;\n        }\n  \
    \      else if(ch == ')')\n        {\n            paren_levels ~= level;\n   \
    \         level--;\n        }\n    }\n    return paren_levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xaquaps.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // define\
    \ a template that contains the information needed to parse the parens\n    struct\
    \ Parens\n    {\n        string paren_string;\n        int position;\n       \
    \ int depth;\n        long[] groups;\n    }\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph5ritpir.d(22): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph5ritpir.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ map!(paren_string, (s) => paren_string.length);\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3950imq0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Find\
    \ first open bracket\n    int i = 0;\n    while (paren_string[i] != '(')\n   \
    \ {\n        i++;\n    }\n    // Create tuple\n    Tuple!(long, long) longest\
    \ = Tuple!(long, long)(1, 0);\n    long level = 1;\n    bool open = true;\n  \
    \  long last_i = i;\n    // Read until end of string\n    while (i < paren_string.length)\n\
    \    {\n        if (paren_string[i] == '(')\n        {\n            if (open)\n\
    \            {\n                level++;\n            }\n            else\n  \
    \          {\n                level = 1;\n                open = true;\n     \
    \       }\n        }\n        else if (paren_string[i] == ')')\n        {\n  \
    \          if (open)\n            {\n                open = false;\n         \
    \       if (level > longest[0])\n                {\n                    longest\
    \ = Tuple!(long, long)(level, last_i);\n                }\n            }\n   \
    \         else\n            {\n                level--;\n            }\n     \
    \   }\n        else if (paren_string[i] == ' ')\n        {\n            // Recursive\
    \ call\n            if (!open)\n            {\n                return parse_nested_parens(paren_string[last_i\
    \ .. i]);\n            }\n        }\n        i++;\n    }\n    // Return tuple\n\
    \    return longest;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxpr1n338.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ max_nesting = 0;\n    int curr_nesting = 0;\n    auto result = Appender!(long[])();\n\
    \    foreach(ch; paren_string)\n    {\n        if(ch == '(')\n        {\n    \
    \        curr_nesting++;\n            max_nesting = max(max_nesting, curr_nesting);\n\
    \        }\n        else if(ch == ')')\n        {\n            if(curr_nesting\
    \ > 0)\n            {\n                curr_nesting--;\n            }\n      \
    \      else\n            {\n                result.put(0L);\n                curr_nesting\
    \ = 0;\n                max_nesting = 0;\n            }\n        }\n        else\
    \ if(ch == ' ')\n        {\n            result.put(max_nesting);\n           \
    \ curr_nesting = 0;\n            max_nesting = 0;\n        }\n    }\n    if(curr_nesting\
    \ == 0)\n    {\n        result.put(max_nesting);\n    }\n    else\n    {\n   \
    \     result.put(0L);\n    }\n    return result.data;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqjpy45xh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.format;\n    import std.array;\n    import std.typecons;\n    import std.conv;\n\
    \    import std.algorithm;\n    import std.range;\n    import std.range.primitives;\n\
    \    import std.string;\n    import std.functional;\n    import std.typecons;\n\
    \    import std.stdio;\n    import std.bigint;\n    import std.math;\n    import\
    \ std.range;\n    import std.exception;\n    import std.digest.sha;\n    import\
    \ std.digest.crc;\n    import std.digest.hmac;\n    import std.digest.md;\n  \
    \  import std.digest.blake2;\n    import std.digest.whirlpool;\n    import std.digest.tiger;\n\
    \    import std.digest.sha2;\n    import std.digest.md5;\n    import std.array;\n\
    \    import std.algorithm;\n    import std.datetime;\n    import std.string;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2oniiiwc.d(80): Error: identifier expected following package\n/tmp/tmp2oniiiwc.d(80):
    Error: \'';\'' expected\n/tmp/tmp2oniiiwc.d(88): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp2oniiiwc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result = new long[];\n\tstring[] groups = paren_string.split(\" \");\n\tforeach(string\
    \ group; groups)\n\t{\n\t\tlong current_depth = 0L;\n\t\tlong max_depth = 0L;\n\
    \t\tforeach(char ch; group)\n\t\t{\n\t\t\tcurrent_depth += ch == '(' ? 1L : -1L;\n\
    \t\t\tmax_depth = max(max_depth, current_depth);\n\t\t}\n\t\tresult ~= max_depth;\n\
    \t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkmhpnyro.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ split = paren_string.split;\n    return split.map!(p => {\n        return p.count(c\
    \ => c == '(') + 1L;\n    }).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzn0q7yv1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return(paren_string.split().map!(s\
    \ => s.strip(\"()\").count(\"()\") + 1).array);\n}\n \n/*\n Write a function that\
    \ takes a string of words separated by spaces and returns a new string\n with\
    \ each word reversed. For example, `reverse_words(\"Hello world!\")` should return\
    \ `\"olleH !dlrow\"`.\n \n*/\nstring reverse_words(string words) \n{\n    return(words.split().map!(s\
    \ => s.reverse).join(\" \"));\n}\n/*\nThis function takes as input a string of\
    \ words separated by spaces.\n    The function returns true if the sentence is\
    \ a palindrome, false otherwise.\n    A palindrome is a sequence of characters\
    \ which is the same when read backwards.\n    All punctuation should be ignored\
    \ when determining whether a sentence is a palindrome.\n    Example:\n    >>>\
    \ is_palindrome(\"Are we not drawn onward, we few, drawn onward to new era?\"\
    )\n    true\n    >>> is_palindrome(\"Sore was I ere I saw Eros.\")\n    true\n\
    \    >>> is_palindrome(\"Never odd or even.\")\n    true\n    >>> is_palindrome(\"\
    Hello world!\")\n    false\n*/\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwxy5iyok.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Split\
    \ the input string by space and get a list of string\n    immutable(string[])\
    \ paren_splits = paren_string.split();\n    auto paren_levels = paren_splits.map!(paren_level)();\n\
    \    // Get the deepest level of nesting of parentheses for each string\n    return\
    \ paren_levels.array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnxml1nh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Split\
    \ into groups\n    string[] groups = paren_string.split();\n    long n_groups\
    \ = groups.length;\n    // Create a tuple of max depth and its corresponding indices\
    \ in the original string\n    auto[] max_depths = new Tuple!(long,string[])();\n\
    \    foreach(string group; groups)\n    {\n        long max_depth = 0L;\n    \
    \    string[] idx_depth = new string[2];\n        ulong len = group.length;\n\
    \        // Keep count of the number of parens encountered\n        long stack_counter\
    \ = 0L;\n        // Keep track of the indices of parens of max depth\n       \
    \ string[] max_idx = [];\n        for(ulong i = 0; i < len; i++)\n        {\n\
    \            if(group[i] == '(')\n            {\n                stack_counter++;\n\
    \                if(stack_counter > max_depth)\n                {\n          \
    \          max_depth = stack_counter;\n                    max_idx = [];\n   \
    \                 max_idx ~= to!string(i);\n                }\n              \
    \  else if(stack_counter == max_depth)\n                {\n                  \
    \  max_idx ~= to!string(i);\n                }\n            }\n            else\
    \ if(group[i] == ')')\n            {\n                stack_counter--;\n     \
    \       }\n        }\n        idx_depth[0] = to!string(max_depth);\n        idx_depth[1]\
    \ = join(max_idx,\",\");\n        max_depths ~= tuple(max_depth,max_idx);\n  \
    \  }\n    return max_depths.tupleof[0];\n}\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcwl1ouyw.d(18): Error: basic type expected, not [\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpcwl1ouyw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ zip(\"(\"~paren_string~\")\").map!((x) {return maxElement(scan!(\"(\" ~ c.retreat\
    \ ~ \")\")(\"(\"~x~\")\"));}).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl499fggq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  auto parens\
    \ = split(paren_string, \" \");\n  auto result = new long[parens.length];\n  foreach\
    \ (i, paren; parens) \n  {\n    long max_paren_depth = 0;\n    long paren_depth\
    \ = 0;\n    foreach (c; paren) \n    {\n      switch (c) \n      {\n        case\
    \ '(': \n          ++paren_depth;\n          max_paren_depth = max(max_paren_depth,\
    \ paren_depth);\n          break;\n        case ')':\n          --paren_depth;\n\
    \          break;\n      }\n    }\n    assert(paren_depth == 0);\n    result[i]\
    \ = max_paren_depth;\n  }\n  return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwcl0syq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parens = paren_string.split(\" \");\n    return parens.map!(paren => paren.walkLength).array;\n\
    }\n \n/*\n Define a function that takes a list of nested parentheses and ouputs\
    \ the deepest level of nesting\n    >>> parse_parens(\"(()()) ((())) () ((())()())\"\
    )\n    3L\n*/\nlong parse_parens(string paren_string)\n{\n    return max(parse_nested_parens(paren_string));\n\
    }\n \n/*\n Define a function that takes a list of nested parentheses and ouputs\
    \ the number of groups with maximum nesting level\n    >>> parse_parens(\"(()())\
    \ ((())) () ((())()())\")\n    3L\n*/\nlong count_parens(string paren_string)\n\
    {\n    return count(parse_nested_parens(paren_string), max(parse_nested_parens(paren_string)));\n\
    }\n \n/*\n Define a function that takes a list of nested parentheses and ouputs\
    \ the index (indexed from 1) \n    of the group with maximum nesting level\n \
    \   >>> parse_parens(\"(()()) ((())) () ((())()())\")\n    2L\n*/\nlong count_parens(string\
    \ paren_string)\n{\n    return count(parse_nested_parens(paren_string), max(parse_nested_parens(paren_string)));\n\
    }\n \n/*\n Define a function that takes a list of nested parentheses and ouputs\
    \ the index (indexed from 1) \n    of the group with maximum nesting level\n \
    \   >>> parse_parens(\"(()()) ((())) () ((())()())\")\n    2L\n*/\nlong find_parens(string\
    \ paren_string)\n{\n    auto parens = paren_string.split(\" \");\n    auto paren_array\
    \ = parens.map!(paren => paren.walkLength).array;\n    return find(paren_array,\
    \ max(paren_array)) + 1;\n}\n \n/*\n Define a function that takes a list of nested\
    \ parentheses and ouputs the index (indexed from 1) \n   \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk2yt7m9j.d(62): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpk2yt7m9j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm : map;\n    import std.algorithm : reduce;\n    import std.functional\
    \ : max;\n    import std.range : iota;\n    import std.range : zip;\n    import\
    \ std.stdio : writeln;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    string[] s = paren_string.split(\" \");\n    return s.map!(x =>\
    \ \n        x.zip(iota(0)).map!(p => p[0] == '(' ? p[1] : -p[1])\n           \
    \ .reduce!max(0)).array;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp9e59ddm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    static\
    \ int __f = '(';\n    static int __b = ')';\n    static int __s = ' ';\n    long[]\
    \ result;\n    int i = 0;\n    int count = 0;\n    int max = 0;\n    int check\
    \ = 0;\n    for (; i < paren_string.length; ++i) \n    {\n        if (paren_string[i]\
    \ == __f) \n        {\n            ++count;\n            if (count > max) \n \
    \           {\n                max = count;\n            }\n        }\n      \
    \  else if (paren_string[i] == __b) \n        {\n            --count;\n      \
    \  }\n        else if (paren_string[i] == __s) \n        {\n            result\
    \ ~= max;\n            max = 0;\n            count = 0;\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq3bsdos7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ groups = paren_string.split;\n    long[] ans;\n    foreach( auto g; groups )\n\
    \    {\n        int count = 0;\n        int max_count = 0;\n        foreach( auto\
    \ c; g )\n        {\n            if( c == '(' )\n                count += 1;\n\
    \            else if( c == ')' )\n                count -= 1;\n            if(\
    \ count > max_count )\n                max_count = count;\n        }\n       \
    \ ans ~= max_count;\n    }\n    return ans;\n}\n/*\n Parses the given string which\
    \ should contain a set of integers separated by spaces.\n    >>> parse_integers(\"\
    1 2 1 0 0 2\")\n    [1L, 2L, 1L, 0L, 0L, 2L]\n    \n*/\nlong[] parse_integers(string\
    \ input) \n{\n    long[] ans;\n    auto ints = input.split;\n    foreach( auto\
    \ i; ints )\n        ans ~= i.to!long;\n    return ans;\n}\n/*\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5xp0m40n.d(16): Error: basic type expected, not auto\n/tmp/tmp5xp0m40n.d(16):
    Error: no identifier for declarator int\n/tmp/tmp5xp0m40n.d(16): Error: found
    \''auto\'' when expecting \'';\''\n/tmp/tmp5xp0m40n.d(16): Error: found \'';\''
    when expecting \'')\''\n/tmp/tmp5xp0m40n.d(16): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmp5xp0m40n.d(20): Error: basic type expected,
    not auto\n/tmp/tmp5xp0m40n.d(20): Error: no identifier for declarator int\n/tmp/tmp5xp0m40n.d(20):
    Error: found \''auto\'' when expecting \'';\''\n/tmp/tmp5xp0m40n.d(20): Error:
    found \'';\'' when expecting \'')\''\n/tmp/tmp5xp0m40n.d(20): Error: found \'')\''
    when expecting \'';\'' following statement\n/tmp/tmp5xp0m40n.d(43): Error: basic
    type expected, not auto\n/tmp/tmp5xp0m40n.d(43): Error: no identifier for declarator
    int\n/tmp/tmp5xp0m40n.d(43): Error: found \''auto\'' when expecting \'';\''\n/tmp/tmp5xp0m40n.d(43):
    Error: found \'';\'' when expecting \'')\''\n/tmp/tmp5xp0m40n.d(43): Error: found
    \'')\'' when expecting \'';\'' following statement\n/tmp/tmp5xp0m40n.d(47): Error:
    unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xp0m40n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ tokens = paren_string.split;\n    long[] max_depth = new long[tokens.length];\n\
    \    int i = 0;\n    foreach(token; tokens) \n    {\n        long depth = 0L;\n\
    \        max_depth[i] = 0L;\n        foreach(char c; token) \n        {\n    \
    \        if(c == '(')\n                depth++;\n            else if(c == ')')\n\
    \                depth--;\n            max_depth[i] = max(max_depth[i], depth);\n\
    \        }\n        i++;\n    }\n    return max_depth;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv5yr_ad1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.conv;\n    import std.regex;\n    auto matches\
    \ = paren_string.match(regex(r\"\\((.*?)\\)\"));\n    auto counts = matches.map!((Match!(string)\
    \ m) => \n    {\n        size_t max_count = 0;\n        size_t count = 0;\n  \
    \      foreach(c; m.matched())\n        {\n            if(c == '(')\n        \
    \        count++;\n            else if(c == ')')\n                count--;\n \
    \           max_count = max(max_count, count);\n        }\n        return max_count;\n\
    \    });\n    return counts.array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpct_tx5ih.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /* Stack\
    \ for keeping a track of the maximum number of\n       nested parentheses seen\
    \ so far\n    */\n    Stack!(long[]) max_depth_stack;\n    /* Stack for keeping\
    \ a track of the current nesting\n       depth in each of the groups.\n    */\n\
    \    Stack!(long[]) depth_stack;\n    foreach (index, elem; paren_string.split)\
    \ \n    {\n        // Open bracket found\n        if (elem == '(') \n        {\n\
    \            depth_stack.push(1);\n            if (max_depth_stack.empty) \n \
    \           {\n                max_depth_stack.push(1);\n            } \n    \
    \        else \n            {\n                auto max_depth = max_depth_stack.pop;\n\
    \                max_depth_stack.push(max_depth);\n                max_depth_stack.push(max_depth\
    \ + 1);\n            }\n        } \n        else if (elem == ')') \n        {\n\
    \            auto depth = depth_stack.pop;\n            if (depth_stack.empty)\
    \ \n            {\n                max_depth_stack.push(depth);\n            }\
    \ \n            else \n            {\n                auto max_depth = max_depth_stack.pop;\n\
    \                max_depth_stack.push(max_depth);\n                depth_stack.push(depth\
    \ + 1);\n            }\n        }\n    }\n    return max_depth_stack.pop;\n}\n\
    /*\n  Computes the standard deviation of the given data, following the standard\
    \ deviation formula on wikipedia.\n*/\ndouble standard_deviation(const double[]\
    \ data) \n{\n    /*\n        Computing the mean of the data\n    */\n    auto\
    \ n = data.length;\n    double sum = 0.0;\n    foreach (i, x; data) \n    {\n\
    \        sum += x;\n    }\n    double mean = sum / n;\n    /*\n        Computing\
    \ the variance\n    */\n    double variance = 0.0;\n    foreach (i, x; data) \n\
    \    {\n        auto term = x - mean;\n        variance += term * term;\n    }\n\
    \    variance /= n;\n   \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeybgkhue.d(82): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeybgkhue.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    long[] deepest_nesting = [];\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpva2imjcc.d(16): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpva2imjcc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\talias\
    \ vec = immutable(long)[];\n\tauto v = paren_string.split(\" \").map!(a => {\n\
    \t\timmutable int paren_count = 0;\n\t\timmutable int max_count = 0;\n\t\tforeach(immutable\
    \ char c; a)\n\t\t{\n\t\t\tif(c == '(')\n\t\t\t{\n\t\t\t\t++paren_count;\n\t\t\
    \t\tmax_count = max(paren_count, max_count);\n\t\t\t}\n\t\t\telse if(c == ')')\n\
    \t\t\t{\n\t\t\t\t--paren_count;\n\t\t\t}\n\t\t}\n\t\treturn max_count;\n\t}).array;\n\
    \treturn v;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpukgme2ks.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_depth;\n    long[] open_parens;\n    paren_string = filter!(isAlphaNum)(paren_string);\n\
    \    auto group = split(paren_string, \" \");\n    for (string p : group)\n  \
    \  {\n        long depth = 0;\n        open_parens = [];\n        for (size_t\
    \ i = 0; i < p.length; i++)\n        {\n            if (p[i] == '(')\n       \
    \     {\n                depth++;\n                open_parens ~= depth;\n   \
    \         }\n            else if (p[i] == ')')\n            {\n              \
    \  long parenthesis_idx = open_parens.length - 1;\n                if (open_parens[parenthesis_idx]\
    \ == depth)\n                {\n                    open_parens.popBack();\n \
    \                   depth--;\n                }\n            }\n        }\n  \
    \      max_depth ~= depth;\n    }\n    return max_depth;\n}\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgjvxmpeo.d(18): Error: found \''p\'' when expecting \'';\''
    following statement\n/tmp/tmpgjvxmpeo.d(18): Error: expression expected, not \'':\''\n/tmp/tmpgjvxmpeo.d(18):
    Error: found \''group\'' when expecting \'';\'' following for condition\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgjvxmpeo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nest_level = new long[];\n    if (paren_string.length > 0) \n    {\n   \
    \     string[] paren_groups = split(paren_string);\n        foreach (paren_group;\
    \ paren_groups) \n        {\n            int nest_level = 0;\n            int\
    \ max_nest_level_in_group = 0;\n            foreach (paren; paren_group) \n  \
    \          {\n                if (paren == '(') \n                {\n        \
    \            nest_level++;\n                }\n                else if (paren\
    \ == ')') \n                {\n                    nest_level--;\n           \
    \     }\n                if (nest_level > max_nest_level_in_group) \n        \
    \        {\n                    max_nest_level_in_group = nest_level;\n      \
    \          }\n            }\n            max_nest_level ~= max_nest_level_in_group;\n\
    \        }\n    }\n    return max_nest_level;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplh_hb2ob.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parens = paren_string.split(\" \");\n    auto splitIndex = parens.map!(a =>\
    \ a.length);\n    auto v = parens.join.map!(a => a.ascii);\n    long[] level;\n\
    \    int maxlen = 0;\n    foreach(i; 0 .. v.length) \n    {\n        auto c =\
    \ v[i];\n        if (c == '(') \n        {\n            if (i < splitIndex[0])\
    \ \n            {\n                ++maxlen;\n                level ~= maxlen;\n\
    \            } \n            else \n            {\n                for (int j\
    \ = 1; j < splitIndex.length; ++j) \n                {\n                    if\
    \ (i < splitIndex[j]) \n                    {\n                        maxlen\
    \ = 1;\n                        level ~= maxlen;\n                        break;\n\
    \                    }\n                }\n            }\n        } \n       \
    \ else if (c == ')') \n        {\n            if (i < splitIndex[0]) \n      \
    \      {\n                --maxlen;\n                level ~= maxlen;\n      \
    \      } \n            else \n            {\n                for (int j = 1; j\
    \ < splitIndex.length; ++j) \n                {\n                    if (i < splitIndex[j])\
    \ \n                    {\n                        --maxlen;\n               \
    \         level ~= maxlen;\n                        break;\n                 \
    \   }\n                }\n            }\n        }\n    }\n    return level;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzfw_22jk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  auto items\
    \ = paren_string.split;\n  //long[] paren_val_arr;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuysnyek6.d(16): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuysnyek6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = split(paren_string);\n    auto paren_levels = [paren_groups.length];\n\
    \    foreach (index, paren_group; paren_groups)\n    {\n        int level = 0;\n\
    \        bool valid = true;\n        foreach (p; paren_group)\n        {\n   \
    \         if (p == '(')\n            {\n                level += 1;\n        \
    \    }\n            else if (p == ')')\n            {\n                level -=\
    \ 1;\n            }\n            else\n            {\n                // error\
    \ in input\n                valid = false;\n                break;\n         \
    \   }\n            if (level < 0)\n            {\n                // missing opening\
    \ paren\n                valid = false;\n                break;\n            }\n\
    \        }\n        if (valid && level == 0)\n        {\n            paren_levels[index]\
    \ = level;\n        }\n        else\n        {\n            paren_levels[index]\
    \ = -1;\n        }\n    }\n    return paren_levels;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphw1dktrt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = paren_string.split.map!(s => s.length - s.countChar('(') - s.countChar(')')).array;\n\
    \    return result;\n}\n \n/*\n    Write a function that takes a list of integers\
    \ and a target number to find a pair of indices that sum up to the target number.\n\
    \    E.g. [1,2,3,4,5,6] 8 --> [2,5]\n    >>> find_pair([1,2,3,4,5,6], 8)\n   \
    \ [2L, 5L]\n*/\nlong[] find_pair(long[] nums, long sum)\n{\n    long[] result\
    \ = [];\n    return result;\n}\n \n/*\n    Given a string and a dictionary, find\
    \ the minimum number of deletions of characters from the string to make the string\
    \ \n    a valid word that exists in the dictionary. If no such word exists, return\
    \ -1. E.g.\n    >>> min_deletions_to_make_valid_word(\"abc\", [\"a\", \"ab\",\
    \ \"abc\", \"abcd\"])\n    0L\n    >>> min_deletions_to_make_valid_word(\"abcdef\"\
    , [\"a\", \"ab\", \"abc\", \"abcd\"])\n    2L\n    >>> min_deletions_to_make_valid_word(\"\
    abx\", [\"a\", \"ab\", \"abc\", \"abcd\"])\n    -1L\n*/\nlong min_deletions_to_make_valid_word(string\
    \ s, string[] dictionary)\n{\n    long result = -1;\n    return result;\n}\n \n\
    \ \n/*\n    Binary search is usually used to search for an element in a sorted\
    \ list. Given a rotated sorted list, e.g. [3,4,5,1,2], find the index of a given\
    \ target element. Return -1 if the element is not found. E.g.\n    >>> binary_search_rotated([3,4,5,1,2],\
    \ 5)\n    2L\n    >>> binary_search_rotated([3,4,5,1,2], 2)\n    4L\n    >>> binary_search_rotated([3\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp025bnhuf.d(47): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp025bnhuf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nesting_level_list;\n    int paren_count = 0;\n    long max_nesting_level\
    \ = 0;\n    long start_pos = 0;\n    long pos = 0;\n    long next_pos = 0;\n \
    \   auto tmp_string = paren_string;\n    while(true)\n    {\n        next_pos\
    \ = tmp_string.find(' ');\n        if(next_pos == -1)\n        {\n           \
    \ next_pos = tmp_string.length;\n        }\n        auto sub_string = tmp_string[0..next_pos];\n\
    \        if(sub_string.find('(') == -1)\n        {\n            break;\n     \
    \   }\n        for(pos = 0; pos < sub_string.length; pos++)\n        {\n     \
    \       if(sub_string[pos] == '(')\n            {\n                paren_count++;\n\
    \                if(paren_count > max_nesting_level)\n                {\n    \
    \                max_nesting_level = paren_count;\n                }\n       \
    \     }\n            else if(sub_string[pos] == ')')\n            {\n        \
    \        paren_count--;\n            }\n        }\n        max_nesting_level_list\
    \ ~= max_nesting_level;\n        max_nesting_level = 0;\n        paren_count =\
    \ 0;\n        start_pos = next_pos + 1;\n        tmp_string = tmp_string[start_pos..$];\n\
    \    }\n    return max_nesting_level_list;\n}\n \n \n/*\n Find the nth term in\
    \ a fibonacci sequence using both a recursive function and a\n naive dynamic programming\
    \ implementation.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxezn2m8w.d(58): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpxezn2m8w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm : map;\n    import std.array : split;\n    import std.conv : to;\n\
    \    int[int] depth_map;\n    depth_map[')'] = -1;\n    depth_map['('] = 1;\n\
    \    return paren_string.split(\" \").map!(s => {\n        int current_depth =\
    \ 0;\n        int max_depth = 0;\n        foreach(c; s) {\n            current_depth\
    \ += depth_map[c];\n            max_depth = max(max_depth, current_depth);\n \
    \       }\n        return max_depth;\n    }).map!(x => x.to!long).array;\n}\n\
    /*\nInput to this function is an array of integers.\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfdj15z3v.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfdj15z3v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    enum\
    \ State {\n        OUTSIDE,\n        INSIDE,\n        INSIDE_PAREN\n    }\n  \
    \  //result to store the deepest nesting levels for each group\n    long[] res;\n\
    \    //What state am I in right now? Am I outside the group?\n    //Am I inside\
    \ the group but outside a pair of parentheses?\n    //Or am I inside the group\
    \ and inside a pair of parentheses?\n    State state = State.OUTSIDE;\n    //level\
    \ of nesting to track the deepest level of nesting\n    long level = 0;\n    //max_level\
    \ to track the deepest level of nesting\n    long max_level = 0;\n    //iterate\
    \ over the paren string\n    foreach(item; paren_string) \n    {\n        //if\
    \ I am inside the group and outside a pair of parentheses\n        if(state ==\
    \ State.INSIDE) \n        {\n            //if I encounter '(' then I am one level\
    \ deeper in nesting\n            if(item == '(') \n            {\n           \
    \     state = State.INSIDE_PAREN;\n                ++level;\n            }\n \
    \           //if I encounter ')' then I come out of the group and inside the group\
    \ the deepest level of nesting is max_level\n            else if(item == ')')\
    \ \n            {\n                state = State.OUTSIDE;\n                //save\
    \ the deepest level of nesting\n                res ~= max_level;\n          \
    \      //reset the deepest level of nesting to zero\n                max_level\
    \ = 0;\n            }\n        }\n        //if I am outside the group\n      \
    \  else if(state == State.OUTSIDE) \n        {\n            //I come inside the\
    \ group\n            if(item == '(') \n            {\n                state =\
    \ State.INSIDE;\n            }\n        }\n        //if I am inside the group\
    \ and inside a pair of parentheses\n        else if(state == State.INSIDE_PAREN)\
    \ \n        {\n            //if I encounter '(' then I am one level deeper in\
    \ nesting\n            if(item == '(') \n            {\n                ++level;\n\
    \            }\n            //if I encounter ')' then I come out of the pair of\
    \ parentheses and inside the group the deepest level of nesting is max_level\n\
    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu71inse5.d(70): Error: found \''unittest\'' instead of statement\n/tmp/tmpu71inse5.d(78):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpu71inse5.d(78):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu71inse5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ paren_string.split(\" \").map!((p) => p.chunks(1).map!((c) => c == \"(\" ? 1\
    \ : -1).\n    reduce!((a, b) => a + b).until!((x) => x == 0).\n    fold!((max,\
    \ x) => max > x ? max : x)).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz26cqpfu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    immutable\
    \ open_paren = \"(\".dup;\n    immutable close_paren = \")\".dup;\n    auto nest_levels\
    \ = appender!(long[])();\n    foreach (idx, token; paren_string.split()) \n  \
    \  {\n        immutable parentheses = token.dup;\n        immutable expected_len\
    \ = parentheses.count(open_paren) * 2;\n        assert(parentheses.count(close_paren)\
    \ == expected_len,\n            format(\"%s has closing and opening parens misaligned\"\
    , token));\n        int count = 0;\n        int max = 0;\n        foreach (char;\
    \ parentheses) \n        {\n            if (char == open_paren) \n           \
    \ {\n                ++count;\n                max = max(max, count);\n      \
    \      } \n            else \n            {\n                --count;\n      \
    \      }\n        }\n        assert(count == 0,\n            format(\"%s has closing\
    \ and opening parens misaligned\", token));\n        nest_levels.put(max);\n \
    \   }\n    return nest_levels.data;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgfg9h2uf.d(25): Error: no identifier for declarator char\n/tmp/tmpgfg9h2uf.d(27):
    Error: found \''==\'' when expecting \''.\'' following char\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpgfg9h2uf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ max_depth = 0;\n    // Stack based solution, push on open paren, pop on close\
    \ paren\n    auto s = new Stack!(int[])();\n    // using int[] as a marker for\
    \ a unique object that we can check for\n    s.push(new int[1]);\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp30n3qsef.d(19): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp30n3qsef.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ counts;\n    foreach(string group; paren_string.split(\" \"))\n    {\n     \
    \   long depth = 0L;\n        long max_depth = 0L;\n        foreach(char c; group)\n\
    \        {\n            if(c == '(')\n            {\n                depth++;\n\
    \                max_depth = max(depth, max_depth);\n            }\n         \
    \   else if(c == ')')\n            {\n                depth--;\n            }\n\
    \        }\n        counts ~= max_depth;\n    }\n    return counts;\n}\n/*\n \
    \   There are N children standing in a line. Each child is assigned a rating value.\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfi5qpeo2.d(35): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfi5qpeo2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tauto pairs\
    \ = split(paren_string);\n\treturn pairs.map!(a =>\n\t\t\t\t\t  {\n\t\t\t\t\t\t\
    \t  long result = 0L;\n\t\t\t\t\t\t\t  long temp = 0L;\n\t\t\t\t\t\t\t  foreach(in\
    \ ch; a)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t  switch(ch)\n\t\t\t\t\t\t\t\t  {\n\
    \t\t\t\t\t\t\t\t\t  case '(' :\n\t\t\t\t\t\t\t\t\t\t  temp++;\n\t\t\t\t\t\t\t\t\
    \t\t  break;\n\t\t\t\t\t\t\t\t\t  case ')' :\n\t\t\t\t\t\t\t\t\t\t  temp--;\n\t\
    \t\t\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t  result = max(result,\
    \ temp);\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t  return result;\n\t\t\t\t\t  }).array;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9hsofo1u.d(19): Error: basic type expected, not in\n/tmp/tmp9hsofo1u.d(19):
    Error: no identifier for declarator int\n/tmp/tmp9hsofo1u.d(19): Error: found
    \''in\'' when expecting \'';\''\n/tmp/tmp9hsofo1u.d(19): Error: found \'';\''
    when expecting \'')\''\n/tmp/tmp9hsofo1u.d(19): Error: found \'')\'' when expecting
    \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9hsofo1u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  return\
    \ paren_string.split().map!(s => \n    {\n      size_t depth = 0, max_depth =\
    \ 0;\n      foreach (c; s) \n      {\n        if (c == '(') \n        {\n    \
    \      ++depth;\n          max_depth = max(max_depth, depth);\n        } \n  \
    \      else if (c == ')') \n        {\n          --depth;\n        }\n      }\n\
    \      return max_depth;\n    }\n  ).array;\n}\n/*\n The function process_nested_parens()\
    \ takes a string and transforms it into a list of strings. \n All consecutive\
    \ parentheses are replaced by a string 'Depth = x' where x is the nesting level\
    \ of the parentheses \n and the nesting level of all other characters remains\
    \ as is. The list of string is then converted to a string \n and returned.\n*/\n\
    string process_nested_parens(string paren_string) \n{\n  return paren_string.split().map!(s\
    \ => \n    {\n      size_t depth = 0;\n      string parens = s;\n      size_t\
    \ i = 0;\n      while (i < parens.length) \n      {\n        if (parens[i] ==\
    \ '(') \n        {\n          ++depth;\n          parens[i..i+1] = format(\"Depth\
    \ = %s\", depth);\n          i += 10;\n        } \n        else if (parens[i]\
    \ == ')') \n        {\n          --depth;\n          parens[i..i+1] = format(\"\
    Depth = %s\", depth);\n          i += 10;\n        } \n        else \n       \
    \ {\n          ++i;\n        }\n      }\n      return parens;\n    }\n  ).join(\"\
    \ \");\n}\n/*\n  This function runs the tests for the problem. The output is similar\
    \ to the problem statement\n  for the function parse_nested_parens().\n*/\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2t_4fz3m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // This\
    \ \"slices\" the string at spaces and returns an array of strings\n    string[]\
    \ paren_groups = paren_string.split(\" \");\n    long[] max_nesting_depth = new\
    \ long[paren_groups.length];\n    foreach (i, paren_group; paren_groups) \n  \
    \  {\n        auto depth = 1L;\n        auto max_depth = 1L;\n        foreach\
    \ (c; paren_group) \n        {\n            if (c == '(') \n            {\n  \
    \              depth++;\n                max_depth = max(depth, max_depth);\n\
    \            }\n            else if (c == ')') \n            {\n             \
    \   depth--;\n            }\n        }\n        max_nesting_depth[i] = max_depth;\n\
    \    }\n    return max_nesting_depth;\n}\n/*\n Write a function that takes in\
    \ a string and returns a tuple of sequences of character types.\nThe character\
    \ types are upper case, lower case, numeric, and other.\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphstyhq2q.d(37): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmphstyhq2q.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren_group; split(paren_string, \" \"))\n\
    \    {\n        auto stack = new Stack!int;\n        long cur_max = 0L;\n    \
    \    long cur_count = 0L;\n        foreach(paren; paren_group)\n        {\n  \
    \          if(paren == '(')\n            {\n                ++cur_count;\n   \
    \             cur_max = max(cur_max, cur_count);\n                stack.push(1);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     --cur_count;\n                stack.pop();\n            }\n        }\n \
    \       result ~= cur_max;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpap8zkw_6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    //NOTE:\
    \ this was a problem I had written in the past, so I know it works.\n    //I have\
    \ not checked it against the problem statement!\n    import std.stdio;\n    import\
    \ std.datetime;\n    import std.conv;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.exception;\n    import std.file;\n    import std.range;\n    import\
    \ std.math;\n    import std.typecons;\n    import std.regex;\n    import std.string;\n\
    \    import std.container;\n    import std.regexp;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.typecons;\n    import std.bigint;\n    import std.random;\n\
    \    import std.algorithm;\n    import std.range;\n    import std.math;\n    import\
    \ std.typecons;\n    /* */\n    string[] parens = paren_string.split(\" \");\n\
    \    writeln(parens);\n    long[] result;\n    foreach(paren_set; parens)\n  \
    \  {\n        long max_paren_nesting = 0;\n        long cur_paren_nesting = 0;\n\
    \        foreach(paren; paren_set)\n        {\n            if(paren == '(')\n\
    \            {\n                cur_paren_nesting++;\n                max_paren_nesting\
    \ = max(max_paren_nesting, cur_paren_nesting);\n            }\n            else\
    \ if(paren == ')')\n            {\n                cur_paren_nesting--;\n    \
    \        }\n        }\n        result ~= max_paren_nesting;\n    }\n    return\
    \ result;\n}\nlong[] parse_nested_parens(string paren_string) \n{\n    //NOTE:\
    \ this was a problem I had written in the past, so I know it works.\n    //I have\
    \ not checked it against the problem statement!\n    import std.stdio;\n    import\
    \ std.datetime;\n    import std.conv;\n    import std.algorithm;\n   \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeve9g9n4.d(75): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeve9g9n4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Step\
    \ 1: split paren_string into multiple paren groups\n    auto paren_groups = paren_string.split(\"\
    \ \");\n    // Step 2: process each paren group, e.g. (()())\n    long[] output\
    \ = new long[paren_groups.length];\n    foreach (i, group; paren_groups)\n   \
    \ {\n        long longest_depth = 0L;\n        long depth = 0L;\n        foreach\
    \ (ch; group)\n        {\n            if (ch == '(')\n            {\n        \
    \        depth++;\n                longest_depth = max(longest_depth, depth);\n\
    \            }\n            else if (ch == ')')\n            {\n             \
    \   depth--;\n            }\n        }\n        // Step 3: assign longest_depth\
    \ to output\n        output[i] = longest_depth;\n    }\n    return output;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg7olf06w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[0];\n    long[] parentheses = paren_string.toUTF8z().filter!(c\
    \ => c == '(' || c == ')').map!(c => c == '(' ? 1L : -1L).array;\n    long[] paren_count\
    \ = new long[parentheses.length];\n    paren_count[0] = parentheses[0];\n    foreach\
    \ (i, p; paren_count)\n    {\n        if (i != 0)\n        {\n            paren_count[i]\
    \ = paren_count[i - 1] + parentheses[i];\n        }\n    }\n    long i = 0;\n\
    \    long start = 0;\n    foreach (paren; parentheses)\n    {\n        if (paren_count[i]\
    \ == 0 && i != 0)\n        {\n            result ~= paren_count[i - 1];\n    \
    \        start = i + 1;\n        }\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb08eqp1e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\treturn\
    \ paren_string.split().map!((paren_string) => \n\t{\n\t\tint cnt = 0;\n\t\tint\
    \ max = 0;\n\t\tforeach(ch; paren_string) \n\t\t{\n\t\t\tif(ch == '(')\n\t\t\t\
    \t++cnt;\n\t\t\telse if(ch == ')')\n\t\t\t\t--cnt;\n\t\t\tmax = max(max, cnt);\n\
    \t\t}\n\t\treturn max;\n\t}).array;\n}\nlong[] parse_nested_parens2(string paren_string)\
    \ \n{\n\treturn paren_string.split().map!((paren_string) => \n\t{\n\t\tint cnt\
    \ = 0;\n\t\tint max = 0;\n\t\tforeach(ch; paren_string) \n\t\t{\n\t\t\tif(ch ==\
    \ '(')\n\t\t\t\t++cnt;\n\t\t\telse if(ch == ')')\n\t\t\t\t--cnt;\n\t\t\tmax =\
    \ max(max, cnt);\n\t\t}\n\t\treturn max;\n\t}).array;\n}\nlong[] parse_nested_parens3(string\
    \ paren_string) \n{\n\treturn paren_string.split().map!((paren_string) => \n\t\
    {\n\t\tint cnt = 0;\n\t\tint max = 0;\n\t\tforeach(ch; paren_string) \n\t\t{\n\
    \t\t\tif(ch == '(')\n\t\t\t\t++cnt;\n\t\t\telse if(ch == ')')\n\t\t\t\t--cnt;\n\
    \t\t\tmax = max(max, cnt);\n\t\t}\n\t\treturn max;\n\t}).array;\n}\nlong[] parse_nested_parens4(string\
    \ paren_string) \n{\n\treturn paren_string.split().map!((paren_string) => \n\t\
    {\n\t\tint cnt = 0;\n\t\tint max = 0;\n\t\tforeach(ch; paren_string) \n\t\t{\n\
    \t\t\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp75tgk2w0.d(72): Error: found \''unittest\'' instead of statement\n/tmp/tmp75tgk2w0.d(80):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp75tgk2w0.d(80):
    Error: found \''EOF\'' when expecting \'')\'' following template argument list\n/tmp/tmp75tgk2w0.d(80):
    Error: found \''EOF\'' when expecting \'';\'' following return statement\n/tmp/tmp75tgk2w0.d(80):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp75tgk2w0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /* ...\
    \ */\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_juw0m6h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    import\
    \ std.range;\n    import std.algorithm;\n    import std.array;\n    import std.datetime;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.meta;\n    import std.algorithm;\n    import std.array;\n    import std.complex;\n\
    \    import std.container;\n    import std.datetime;\n    import std.exceptio\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9owy7l_k.d(28): Error: \'';\'' expected\n/tmp/tmp9owy7l_k.d(36):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9owy7l_k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ nest_levels = [];\n    string[] toks = split(paren_string, ' ');\n    foreach(string\
    \ tok; toks) \n    {\n        long max_nest = 0;\n        long current_nest =\
    \ 0;\n        foreach(char c; tok) \n        {\n            if(c == '(') \n  \
    \          {\n                current_nest++;\n                max_nest = max(max_nest,\
    \ current_nest);\n            } \n            else if(c == ')') \n           \
    \ {\n                current_nest--;\n            }\n        }\n        nest_levels\
    \ ~= max_nest;\n    }\n    return nest_levels;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk5ebifuk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result = new long[];\n\tstring[] substrings = paren_string.split(\" \");\n\t\
    foreach(i, sub_str; substrings)\n\t{\n\t\tint count = 0;\n\t\tforeach(ch; sub_str)\n\
    \t\t{\n\t\t\tif(ch == '(')\n\t\t\t\tcount++;\n\t\t\telse if(ch == ')')\n\t\t\t\
    \tcount--;\n\t\t}\n\t\tresult ~= count;\n\t}\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp87dkt29o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ output;\n    foreach(paren; paren_string.split) \n    {\n        long depth\
    \ = 0L;\n        long max = 0L;\n        foreach(c; paren) \n        {\n     \
    \       if(c == '(') \n            {\n                depth++;\n             \
    \   max = max(depth, max);\n            }\n            else if(c == ')') \n  \
    \          {\n                depth--;\n            }\n        }\n        output\
    \ ~= max;\n    }\n    return output;\n}\n/*\n Implementation of a generalized\
    \ set like data structure with *some* set theoretic operations.\n    Assume given\
    \ a type T and a key function K, the class is given below.\n    The data structure\
    \ for the class is a Dictionary of T to List of T.\n    The key function is supposed\
    \ to be an equivalence relation.\n    The class provides the following methods:\n\
    \        add(T) -> Adds the given element to the structure.\n        equals(S)\
    \ -> Checks whether the current structure is same as the other structure.\n  \
    \      isSubset(S) -> Checks whether the other structure is a subset of the current\
    \ structure.\n        union(S) -> Constructs a union with the other structure\
    \ and returns a new structure.\n        intersect(S) -> Constructs an intersection\
    \ with the other structure and returns a new structure.\n        difference(S)\
    \ -> Constructs a difference with the other structure and returns a new structure.\n\
    */\nstruct GeneralizedSet(T, K) \n{\n    private \n    {\n        List!(T)[] data;\n\
    \    }\n    public \n    {\n        this() \n        {\n            data = new\
    \ List!(T)[];\n        }\n        alias K keyof;\n        void add(T element)\
    \ \n        {\n            auto list = data.get(keyof(element));\n           \
    \ if(list.empty) \n            {\n                list = new List!(T)();\n   \
    \             data[keyof(element)] = list;\n            }\n            list ~=\
    \ element;\n        }\n        GeneralizedSet!(T, K) opBinary(string op)(GeneralizedSet!(T,\
    \ K) other)() \n        {\n            GeneralizedSet\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbogf70lb.d(71): Error: semicolon expected following function
    declaration\n/tmp/tmpbogf70lb.d(71): Error: Declaration expected, not \''(\''\n/tmp/tmpbogf70lb.d(78):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpbogf70lb.d(79): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpbogf70lb.d(80): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpbogf70lb.d(82): Error: } expected following
    member declarations in aggregate\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbogf70lb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ res = long[0];\n    import std.algorithm.iteration : filter, map;\n    import\
    \ std.conv : to;\n    res ~= paren_string.split(' ').map!(paren_string => \n \
    \   {\n        long level = 0;\n        long max_level = 0;\n        paren_string.filter!(ch\
    \ => ch == '(' || ch == ')').each!(ch => \n        {\n            level += ch\
    \ == '(' ? 1 : -1;\n            max_level = max(max_level, level);\n        });\n\
    \        return max_level;\n    }).array;\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfxy2a_mt.d(14): Error: found \''[\'' when expecting \''.\''
    following long\n/tmp/tmpfxy2a_mt.d(14): Error: found \''0\'' when expecting identifier
    following \''long.\''\n/tmp/tmpfxy2a_mt.d(14): Error: semicolon expected following
    auto declaration, not \'']\''\n/tmp/tmpfxy2a_mt.d(14): Error: found \'']\'' instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfxy2a_mt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// Split\
    \ the string into groups of parentheses.\n\timmutable char[][] groups = paren_string.split(\"\
    \ \");\n\t\n\tlong[] paren_depth = new long[groups.length];\n\t\n\tforeach(uint\
    \ i; 0 .. groups.length)\n\t{\n\t\timmutable char[] group = groups[i];\n\t\t\n\
    \t\tuint deep = 0;\n\t\tuint deep_max = 0;\n\t\tforeach(uint j; 0 .. group.length)\n\
    \t\t{\n\t\t\tif(group[j] == '(')\n\t\t\t{\n\t\t\t\tdeep++;\n\t\t\t\tdeep_max =\
    \ max(deep_max, deep);\n\t\t\t}\n\t\t\telse if(group[j] == ')')\n\t\t\t{\n\t\t\
    \t\tdeep--;\n\t\t\t}\n\t\t}\n\t\tparen_depth[i] = deep_max;\n\t}\n\t\n\treturn\
    \ paren_depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbhig0fn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parse_nested_parens_one_group(string paren_string) \n    {\n        long max_level\
    \ = 0L;\n        long level = 0L;\n        foreach (char c; paren_string) \n \
    \       {\n            if (c == '(') \n            {\n                level +=\
    \ 1L;\n                max_level = max(max_level, level);\n            } \n  \
    \          else if (c == ')') \n            {\n                level -= 1L;\n\
    \            }\n        }\n        return max_level;\n    }\n    return paren_string.split().map!parse_nested_parens_one_group;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp37gl57rh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(long i;0..paren_string.length)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            long start = i;\n            long end = i;\n\
    \            long count = 0;\n            while(end<paren_string.length)\n   \
    \         {\n                if(paren_string[end] == '(')\n                {\n\
    \                    count++;\n                }\n                else if(paren_string[end]\
    \ == ')')\n                {\n                    count--;\n                }\n\
    \                if(count == 0)\n                {\n                    end =\
    \ end+1;\n                    break;\n                }\n                end++;\n\
    \            }\n            result ~= parse_nested_parens(paren_string[start..end]);\n\
    \            i = end-1;\n        }\n        else if(paren_string[i] == ')')\n\
    \        {\n            return result;\n        }\n        else if(paren_string[i]\
    \ == ' ')\n        {\n            if(result.length != 0)\n            {\n    \
    \            return result;\n            }\n        }\n        else\n        {\n\
    \            continue;\n        }\n    }\n    return result;\n}\n/*\nYou are given\
    \ a string, str, of length N consisting of lower case English alphabets, characters\
    \ like 'a', 'b', 'c', ... etc.\n    The task is to find the maximum number of\
    \ \n    characters of the same type you can remove from the string, such that\
    \ the remaining string is a palindrome.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxqjz7_6u.d(60): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpxqjz7_6u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // There's\
    \ no error checking in the rest of the code\n    assert(paren_string.length >\
    \ 0);\n    assert(paren_string.length % 2 == 0);\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpedkc19xr.d(17): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedkc19xr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ ret;\n    int index = 0;\n    //Split by space\n    foreach(paren_group; paren_string.split(\"\
    \ \"))\n    {\n        ret ~= get_max_nested_parens(paren_group);\n    }\n   \
    \ return ret;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcs5ma8w7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014260
