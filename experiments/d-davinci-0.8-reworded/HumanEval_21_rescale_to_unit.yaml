name: HumanEval_21_rescale_to_unit
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Given array of numbers (of at\
  \ least two elements), apply a linear transform to that array,\n    such that the\
  \ smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
  \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
  \ numbers) \n"
tests: "unittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0,\
  \ 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n\
  \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n\
  \    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n\
  \    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n\
  }\nvoid main(){}"
completions: ["{\n    float minValue = min(numbers);\n    float maxValue = max(numbers);\n\
    \    float[] normalized = cast(float[])numbers;\n    foreach(float &num; normalized)\n\
    \    {\n        num = (num - minValue) / (maxValue - minValue);\n    }\n    return\
    \ normalized;\n}", "{\n    float min_value = min(numbers);\n    float max_value\
    \ = max(numbers);\n    float range = max_value - min_value;\n    float[] result\
    \ = [];\n    foreach(index, number; numbers)\n    {\n        result ~= ((number\
    \ - min_value) / range);\n    }\n    return result;\n}", "{\n    float[] scaled\
    \ = new float[numbers.length];\n    float max = maxElement(numbers);\n    float\
    \ min = minElement(numbers);\n    float factor = 1.0 / (max - min);\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        scaled[i] = (numbers[i] - min)\
    \ * factor;\n    }\n    return scaled;\n}\n/*\n  Given a chromosome of length\
    \ 3, return a list of all possible\n  permutations of it, of length n\n*/", "{\n\
    \    float lowest = numbers[0];\n    float highest = numbers[0];\n    foreach(float\
    \ f; numbers) \n    {\n        if (f < lowest)\n            lowest = f;\n    \
    \    if (f > highest)\n            highest = f;\n    }\n    float[] result = new\
    \ float[numbers.length];\n    for (size_t i = 0; i < numbers.length; i++)\n  \
    \      result[i] = (numbers[i] - lowest) / (highest - lowest);\n    return result;\n\
    }\n/*\nTake a list of values and a list of corresponding frequencies\n*/\nfloat[]\
    \ frequency_weighted_mean(float[] values, size_t[] frequencies)\n{\n    assert(values.length\
    \ == frequencies.length);\n    float frequency_weighted_mean = 0.0;\n    size_t\
    \ total_weight = 0;\n    for (size_t i = 0; i < values.length; i++) \n    {\n\
    \        frequency_weighted_mean += values[i] * frequencies[i];\n        total_weight\
    \ += frequencies[i];\n    }\n    float result = frequency_weighted_mean / total_weight;\n\
    \    return result;\n}\n/*\nNormalise a list so that the sum of its elements equals\
    \ 1 (unless the list sums to zero, in which case, return an equal distribution)\n\
    */\nfloat[] normalise(float[] values)\n{\n    float[] result = new float[values.length];\n\
    \    if (values.sum > 0)\n        foreach(i, v; values)\n            result[i]\
    \ = v / values.sum;\n    else\n        foreach(i, v; values)\n            result[i]\
    \ = 1.0 / values.length;\n    return result;\n}\n/*\nReturn the cumulative sum\
    \ of a list\n    >>> cumulative_sum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n*/\nfloat[]\
    \ cumulative_sum(float[] numbers)\n{\n    float[] result = new float[numbers.length];\n\
    \    float running_sum = 0.0;\n    foreach(i, n; numbers)\n    {\n        running_sum\
    \ += n;\n        result[i", "{\n    float[] results;\n    float min, max;\n  \
    \  int i;\n    results.length = numbers.length;\n    min = numbers[0];\n    max\
    \ = numbers[0];\n    foreach(n; numbers) \n    {\n        if (n < min) \n    \
    \    {\n            min = n;\n        }\n        if (n > max) \n        {\n  \
    \          max = n;\n        }\n    }\n    float scale_factor = (1 - 0) / (max\
    \ - min);\n    float shift_amount = -min;\n    for (i = 0; i < numbers.length;\
    \ i++) \n    {\n        results[i] = numbers[i] * scale_factor + shift_amount;\n\
    \    }\n    return results;\n}", "{\n    import std.math;\n    auto min_n = min(numbers);\n\
    \    auto max_n = max(numbers);\n    auto range = max_n - min_n;\n    return numbers.map!((n)\
    \ => (n - min_n) / range);\n}\n/*\n Given a set of points and a point, calculate\
    \ the pairwise distance between each point and the give point.\n    >>> dist_to_point([[1,\
    \ 1], [2, 2], [3, 3]], [0, 0])\n    [sqrt(2), sqrt(8), sqrt(18)]\n*/\nfloat[]\
    \ dist_to_point(float[][] points, float[] point)\n{\n    import std.math;\n  \
    \  return points.map!((p) => sqrt(pow(p[0] - point[0], 2) + pow(p[1] - point[1],\
    \ 2)));\n}\n/*\n Given a set of points and a point, calculate a vector from the\
    \ set of points to the point.\n    >>> diff_to_point([[1, 1], [2, 2], [3, 3]],\
    \ [0, 0])\n    [[-1, -1], [-2, -2], [-3, -3]]\n*/\nfloat[][] diff_to_point(float[][]\
    \ points, float[] point)\n{\n    import std.algorithm;\n    import std.range;\n\
    \    import std.typecons;\n    return zip(points, repeat(point).take(points.length)).map!((p)\
    \ => p[0] - p[1]);\n}\n/*\n Given a set of points and a point, calculate the cosine\
    \ similarity between each point and the given point.\n    >>> cosine_similarity([[1,\
    \ 1], [2, 2], [3, 3]], [0, 0])\n    [0.0, 0.0, 0.0]\n*/\nfloat[] cosine_similarity(float[][]\
    \ points, float[] point)\n{\n    import std.math;\n    import std.range;\n   \
    \ import std.algorithm;\n    import std.numeric;\n    return zip(points, repeat(point).take(points.",
  "{\n    float min = min(numbers);\n    float max = max(numbers);\n    float[] scaled\
    \ = [];\n    //Tuple!(float,float) mm = minmax(numbers);\n    //float min = mm[0];\n\
    \    //float max = mm[1];\n    for(int i = 0; i < numbers.length; i++) {\n   \
    \     scaled ~= (numbers[i] - min) / (max - min);\n    }\n    return scaled;\n\
    }\n// rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n \n/*    Given array of numbers\
    \ (of at least two elements), apply a linear transform to that array,\n    such\
    \ that the smallest number will become 1 and the largest will become 2,\n    >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [1.0, 1.25, 1.5, 1.75, 2.0]",
  "{\n    /*\n     The range of the values is the difference between the lowest and\
    \ highest numbers.\n     We may calculate it with:\n    */\n    float min_val\
    \ = min(numbers);\n    float max_val = max(numbers);\n    float range = max_val\
    \ - min_val;\n    /*\n     Calculate the rescaled value for each number in the\
    \ array:\n    */\n    float[] rescaled = new float[numbers.length];\n    foreach(index,\
    \ elem; numbers)\n    {\n        float rescaled_val = (elem - min_val) / range;\n\
    \        rescaled[index] = rescaled_val;\n    }\n    return rescaled;\n}", "{\n\
    \    auto min = numbers[0];\n    auto max = numbers[0];\n    foreach(n; numbers)\
    \ \n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n\
    \            max = n;\n    }\n    auto value_range = max - min;\n    auto scaled\
    \ = new float[numbers.length];\n    for (size_t i = 0; i < numbers.length; i++)\
    \ \n    {\n        scaled[i] = (numbers[i] - min) / value_range;\n    }\n    return\
    \ scaled;\n}\nstruct Particle \n{\n    float[] position;\n    float[] velocity;\n\
    \    float[] acceleration;\n    float[] best_position;\n    float best_value;\n\
    \    void set_best_position() \n    {\n        best_position = position.dup;\n\
    \    }\n    float cost(float[] input) \n    {\n        auto result = 0.0;\n  \
    \      for (size_t i = 0; i < input.length; i++) \n        {\n            result\
    \ += pow(input[i], 2);\n        }\n        return result;\n    }\n    float[]\
    \ step(float C1, float C2, float W) \n    {\n        for (size_t i = 0; i < velocity.length;\
    \ i++) \n        {\n            auto r1 = rng.front;\n            auto r2 = rng.front;\n\
    \            rng.popFront;\n            rng.popFront;\n            auto new_velocity\
    \ =\n                W * velocity[i] +\n                C1 * r1 * (best_position[i]\
    \ - position[i]) +\n                C2 * r2 * (best_position[i] - position[i]);\n\
    \            new_velocity = clamp(new_velocity, -abs(best_position[i]), abs(best_position[i]));\n\
    \            velocity[i] = new_velocity;\n            position[i] += velocity[i];\n\
    \        }\n        return position;\n    }\n}\nstruct Swarm \n{\n    Particle[]\
    \ particles;\n    float[] best_position;\n    float best_value", "{\n    assert(numbers.length\
    \ >= 2);\n    float min_number = min(numbers);\n    float max_number = max(numbers);\n\
    \    float scale = 1.0f / (max_number - min_number);\n    //assert(max_number\
    \ != min_number);\n    float[] scaled_numbers = [];\n    foreach(float number;\
    \ numbers)\n    {\n      scaled_numbers ~= (number - min_number) * scale;\n  \
    \  }\n    return scaled_numbers;\n}", "{\n    assert(numbers.length &gt; 1);",
  "{\n    float min = min(numbers);\n    float max = max(numbers);\n    float[] result\
    \ = numbers;\n    foreach(n; 0..result.length)\n    {\n        result[n] = (result[n]\
    \ - min) / (max - min);\n    }\n    return result;\n}", "{\n    float[] result;\n\
    \    // Figure out the minimum and maximum\n    float min = std.min(numbers);\n\
    \    float max = std.max(numbers);\n    // Apply linear transform to all elements\n\
    \    result.length = numbers.length;\n    foreach (i, e; numbers) \n    {\n  \
    \      result[i] = (e - min) / (max - min);\n    }\n    return result;\n}", "{\n\
    \    float[] result = new float[];\n    float minimum = numbers[0];\n    float\
    \ maximum = numbers[0];\n    foreach(number; numbers)\n    {\n        if(number\
    \ < minimum)\n        {\n            minimum = number;\n        }\n        if(number\
    \ > maximum)\n        {\n            maximum = number;\n        }\n    }\n   \
    \ float delta = maximum - minimum;\n    foreach(number; numbers)\n    {\n    \
    \    float rescaled_number = (number - minimum) / delta;\n        result ~= rescaled_number;\n\
    \    }\n    return result;\n}\n// \nclass PriceDataEntry \n{\n    public float\
    \ High;\n    public float Low;\n    public float Open;\n    public float Close;\n\
    \    public float Volume;\n    public float AdjustedClose;\n}\n/*\n Given array\
    \ of PriceDataEntry, apply a linear transform to all the price fields\n    >>>\
    \ v = PriceDataEntry(High=4.0, Low=1.0, Open=3.0, Close=3.0, Volume=1000.0, AdjustedClose=3.0)\n\
    \    >>> rescale_to_unit(v)\n    PriceDataEntry(High=1.0, Low=0.0, Open=0.5, Close=0.5,\
    \ Volume=1000.0, AdjustedClose=0.5)\n */\nPriceDataEntry rescale_to_unit(PriceDataEntry\
    \ entry) \n{\n    PriceDataEntry result = entry;\n    float[] all_fields = [entry.High,\
    \ entry.Low, entry.Open, entry.Close, entry.AdjustedClose];\n    float[] rescaled_fields\
    \ = rescale_to_unit(all_fields);\n    result.High = rescaled_fields[0];\n    result.Low\
    \ = rescaled_fields[1];\n    result.Open = rescaled_fields[2];\n    result.Close\
    \ = rescaled_fields[3];\n    result.AdjustedClose = rescaled_fields[4];\n    return\
    \ result;\n}", "{\n    float[] result = new float[numbers.length];\n    float\
    \ max = numbers[0];\n    float min = numbers[0];\n    for (float n in numbers)\
    \ \n    {\n        if (n < min) \n        {\n            min = n;\n        }\n\
    \        if (n > max) \n        {\n            max = n;\n        }\n    }\n  \
    \  float amplitude = max - min;\n    for (int i = 0; i < numbers.length; i++)\
    \ \n    {\n        result[i] = (numbers[i] - min) / amplitude;\n    }\n    return\
    \ result;\n}\n/*\n Common timing function for animations\n \n    >>> easing_function(1.0)\n\
    \    1.0\n    >>> easing_function(0.5)\n    0.5\n    >>> easing_function(0.25)\n\
    \    0.21875\n    >>> easing_function(0.0)\n    0.0\n*/\nfloat easing_function(float\
    \ x) \n{\n    return pow(x, 2);\n}\nfloat ease_in_out(float x) \n{\n    return\
    \ x < 0.5 ? 2 * pow(x, 2) : 2 * (1 - pow(1 - x, 2));\n}", "{\n    auto min = reduce!min(numbers);\n\
    \    auto max = reduce!max(numbers);\n    auto result = new float[numbers.length];\n\
    \    foreach(i,v;numbers)\n    {\n        result[i] = (v-min)/(max-min);\n   \
    \ }\n    return result;\n}", "{\n    float[] result;\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        result ~= numbers[i];\n        if (numbers[i] < min)\n        {\n\
    \            min = numbers[i];\n        }\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n    }\n    for (int i = 0;\
    \ i < result.length; i++)\n    {\n        result[i] = (result[i] - min) / (max\
    \ - min);\n    }\n    return result;\n}\n/*\n Given array of numbers (of at least\
    \ two elements), apply a linear transform to that array,\n    such that the smallest\
    \ number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
    \ numbers) \n{\n    float[] result;\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n       \
    \ result ~= numbers[i];\n        if (numbers[i] < min)\n        {\n          \
    \  min = numbers[i];\n        }\n        if (numbers[i] > max)\n        {\n  \
    \          max = numbers[i];\n        }\n    }\n    for (int i = 0; i < result.length;\
    \ i++)\n    {\n        result[i] = (result[i] - min) / (max - min);\n    }\n \
    \   return result;\n}", "{\n    return numbers.map!(i => (i - numbers.min) / (numbers.max\
    \ - numbers.min));\n}\n/*\n Implements Newton-Raphson algorithm to find a root\
    \ of the equation f(x)=0\n given a function f and its derivative, and an initial\
    \ guess x0.\n \n Example:\n    >>> newton_raphson(sin, cos, 1.0);\n    0.7062\n\
    */\ndouble newton_raphson(Fun_!int delegate(double x) f, Fun_!int delegate(double\
    \ x) f_prime, double x0) \n{\n    while(true) \n    {\n        double dx = f(x0)\
    \ / f_prime(x0);\n        if(abs(dx) < 1e-15) \n        {\n            return\
    \ x0;\n        }\n        x0 -= dx;\n    }\n}", "{\n    float min_num = min(numbers);\n\
    \    float max_num = max(numbers);\n    float[] result = array(numbers);\n   \
    \ foreach(i, v; result)\n    {\n        result[i] = (v - min_num) / (max_num -\
    \ min_num);\n    }\n    return result;\n}", "{\n    assert(numbers.length >= 2);\n\
    \    float[] res = new float[numbers.length];\n    float a = -numbers[0];\n  \
    \  float b = 1.0 / (numbers[numbers.length - 1] + a);\n    foreach(float f; numbers)\n\
    \    {\n        res ~= (f + a) * b;\n    }\n    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
