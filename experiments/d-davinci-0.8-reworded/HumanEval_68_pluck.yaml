name: HumanEval_68_pluck
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
  \ a branch of a tree that has non-negative integer nodes\n    your task is to pluck\
  \ one of the nodes and return it.\n    The plucked node should be the node with\
  \ the smallest even value.\n    If multiple nodes with the same smallest even value\
  \ are found return the node that has smallest index.\n\n    The plucked node should\
  \ be returned in an array, [ smalest_value, its index ],\n    If there are no even\
  \ values or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
  \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2\
  \ has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n    [2L,\
  \ 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
  \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5L,\
  \ 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is the smallest value,\
  \ but  there are two zeros,\n                 so we will choose the first zero,\
  \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
  \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
  \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
  \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
  \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
  \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
completions: ["{ \n    // your code here\n}", "{\n    long smallest_value = 10001L;\n\
    \    long index = -1L;\n    long value = -1L;\n    foreach(long i, elem; arr)\n\
    \    {\n        if(elem < smallest_value && elem % 2 == 0)\n        {\n      \
    \      smallest_value = elem;\n            index = i;\n            value = elem;\n\
    \        }\n    }\n    if(index < 0)\n    {\n        return [].init;\n    }\n\
    \    return [value, index].init;\n}", "{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long[] res = new long[2];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[(int)i] % 2 == 0)\n        {\n            if (arr[(int)i] < min)\n    \
    \        {\n                min = arr[(int)i];\n                minIndex = i;\n\
    \            }\n        }\n    }\n    if (min % 2 == 0)\n    {\n        res[0]\
    \ = min;\n        res[1] = minIndex;\n    }\n    return res;\n}", "{\n    return\
    \ arr.takeWhile!((a) => a%2==0).dup.length==0 ? new long[](0) :\n           arr.indexOf(arr.min(a\
    \ => a%2==0 ? a : cast(long)double.infinity));\n}\n/*", "{\n    long[] result\
    \ = new long[2];\n    if (arr.length == 0)\n        return result;\n    result[0]\
    \ = arr[0];\n    result[1] = 0;\n    if (arr[0] % 2 == 0)\n    {\n        result[0]\
    \ = arr[0];\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = 100000;\n        result[1] = 0;\n    }\n    for (int i = 1; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n            if (arr[i]\
    \ < result[0])\n            {\n                result[0] = arr[i];\n         \
    \       result[1] = i;\n            }\n        }\n    }\n    if (result[0] ==\
    \ 100000)\n    {\n        result[0] = 0;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}\n/*\n    A magic number is a number whose digits, when added together,\
    \ sum to 7.\n    For example, the number 34 would be a magic number, because 3\
    \ + 4 = 7.\n    Create a function to return either true or false depending on\
    \ whether the number is a magic number.\n*/", "{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.stdio;\n    import std.range;\n    /*\n\
    \    import std.typecons;\n    import std.typecons : tuple;\n    import std.array;\n\
    \    */\n    // brute force:\n    // return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : tuple(arr.filter!(l => l.isEven).sort().take(1),\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).map!(t\
    \ => t[0]).take(1));\n    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0],\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).map!(t\
    \ => t[0]).take(1)[0]];\n    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0],\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).take(1)[0]];\n\
    \    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l => l.isEven).sort().take(1))\
    \ ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0], arr.enumerate.filter!(t\
    \ => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).", "{\n    auto result\
    \ = [];\n    long even = long.max;\n    long index = 0;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < even)\n \
    \       {\n            even = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (even == long.max) return result;\n    else return [even, index];\n\
    }", "{\n    import std.algorithm : min, filter, count;\n    import std.math :\
    \ min;\n    if(arr.length == 0)\n        return [];\n    arr.sort!q{(a,b) => a\
    \ > b};\n    auto y = arr.filter!q{x => x % 2 == 0}.array;\n    if(y.length ==\
    \ 0)\n        return [];\n    auto x = y.min;\n    return [x, arr.count!q{y =>\
    \ y == x}].min;\n}", "{\n    long min = 10001;\n    long minIdx = 0;\n    if (arr.length\
    \ == 0)\n        return [];\n    foreach (idx, el; arr)\n    {\n        if (el\
    \ % 2 == 0 && el < min)\n        {\n            min = el;\n            minIdx\
    \ = idx;\n        }\n    }\n    if (min == 10001)\n        return [];\n    return\
    \ [min, minIdx];\n}", "{\n    long[] result = [null, null];\n    long smallestIndex\
    \ = null;\n    long smallestValue = null;\n    bool allOdd = true;\n    bool noEvens\
    \ = true;\n    foreach( i, e; arr ) \n    {\n        if( e % 2 == 0 )\n      \
    \  {\n            noEvens = false;\n            if( allOdd )\n            {\n\
    \                smallestIndex = i;\n                smallestValue = e;\n    \
    \            allOdd = false;\n            }\n            else\n            {\n\
    \                if( e < smallestValue )\n                {\n                \
    \    smallestIndex = i;\n                    smallestValue = e;\n            \
    \    }\n            }\n        }\n    }\n    if( noEvens )\n    {\n        return\
    \ [];\n    }\n    else\n    {\n        result[0] = smallestValue;\n        result[1]\
    \ = smallestIndex;\n        return result;\n    }\n}", "{\n    import std.algorithm;\n\
    \    import std.stdio;\n    import std.array;\n    import std.conv;\n    auto\
    \ evArr = arr.filter!(a => a % 2 == 0).array;\n    if (evArr.length == 0) return\
    \ [];\n    auto mi = minElement(evArr);\n    auto res = arr.indexOf(mi);\n   \
    \ // writefln(\"%s\\n\", arr);\n    // writefln(\"%s\\n\", evArr);\n    // writefln(\"\
    %s\\n\", mi);\n    // writefln(\"%s\\n\", res);\n    return [mi, res];\n}\n \n\
    \ \n /*\n    \"Given a string representing a DNA sequence,\n    your task is to\
    \ reverse the string representing the complementary strand.\n    The complementary\
    \ strand follows the simple rules:", "{\n    size_t pos = 0;\n    long min = -1;\n\
    \    for (;pos < arr.length;++pos) {\n        if (arr[pos] > 0 && arr[pos] % 2\
    \ == 0) {\n            if (min == -1 || arr[pos] < min) {\n                min\
    \ = arr[pos];\n            }\n        }\n    }\n    if (min == -1) {\n       \
    \ return new long[0];\n    }\n    else {\n        return typeof(new long[0]).init[min,\
    \ pos];\n    }\n}", "{\n    int index = -1;\n    long[] smallest = typeof(smallest).init;\n\
    \    foreach(immutable i, immutable long item; arr)\n    {\n        if(item %\
    \ 2 == 0)\n        {\n            if(smallest.length == 0)\n            {\n  \
    \              index = i;\n                smallest ~= item;\n            }\n\
    \            else if(item < smallest[0])\n            {\n                index\
    \ = i;\n                smallest[0] = item;\n            }\n        }\n    }\n\
    \    if(index != -1)\n    {\n        return [smallest[0], cast(long)index];\n\
    \    }\n    return [0L];\n}", "{\n    struct loc\n    {\n        long index;\n\
    \        long value;\n    }\n    auto result = arr.filter!(e => e % 2 == 0).min(loc(long,\
    \ long));\n    if (result is null)\n        return [];\n    return [result.value,\
    \ result.index];\n}", "{\n    long min_even = 0L;\n    long min_even_idx = 0L;\n\
    \    bool found_even = false;\n    long i = 0L;\n    foreach(idx, val; arr) {\n\
    \        if (val % 2 == 0) {\n            if (!found_even) {\n               \
    \ min_even = val;\n                min_even_idx = idx;\n                found_even\
    \ = true;\n            } else {\n                if (val < min_even) {\n     \
    \               min_even = val;\n                    min_even_idx = idx;\n   \
    \             }\n            }\n        }\n    }\n    if (found_even) {\n    \
    \    return tuple(min_even, min_even_idx);\n    } else {\n        return tuple(0L,\
    \ 0L);\n    }\n}", "{ \n    if (arr.length == 0) \n        return new long[](0);\n\
    \    \n    long[] small(long[] arr) \n    {\n        long min = arr[0];\n    \
    \    int index = 0;\n        foreach (i, v; arr) \n        {\n            if (v\
    \ < min) \n            {\n                min = v;\n                index = i;\n\
    \            }\n        }\n        return tuple(min, index);\n    }\n    \n  \
    \  long[] even(long[] arr) \n    {\n        long[] even = new long[];\n      \
    \  foreach (v; arr) \n        {\n            if (v % 2 == 0)\n               \
    \ even ~= v;\n        }\n        return even;\n    }\n    \n    long[] even_arr\
    \ = even(arr);\n    if (even_arr.length == 0)\n        return new long[](0);\n\
    \    \n    return tuple(small(even_arr)[0], small(even_arr)[1]);\n}", "{\n   \
    \ long smallest = 0L;\n    long smallest_idx = 0L;\n    if (arr.empty)\n     \
    \   return [smallest, smallest_idx];\n    \n    long smallest_found = arr[0];\n\
    \    long smallest_idx_found = 0L;\n    foreach (e; arr) \n    {\n        if ((e\
    \ % 2) == 0 && (e < smallest_found)) \n        {\n            smallest_found =\
    \ e;\n            smallest_idx_found = cast(long)e;\n        }\n    }\n    if\
    \ (smallest_found == arr[0]) \n    {\n        if ((arr[0] % 2) == 0)\n       \
    \     return [smallest_found, smallest_idx_found];\n        else \n        {\n\
    \            foreach (e; arr) \n            {\n                if ((e % 2) ==\
    \ 0) \n                {\n                    smallest_found = e;\n          \
    \          smallest_idx_found = cast(long)e;\n                    break;\n   \
    \             }\n            }\n            return [smallest_found, smallest_idx_found];\n\
    \        }\n    }\n    return [smallest_found, smallest_idx_found];\n}", "{\n\
    \  long[] result;\n  foreach(val; arr)\n  {\n    if(val % 2 == 0)\n    {\n   \
    \   result = [val, indexOf(arr, val)];\n      break;\n    }\n  }\n  return result;\n\
    }", "{\n    if (arr.length == 0)\n        return new long[0];\n    int arrMin\
    \ = arr[0];\n    int arrMinIndex = 0;\n    bool isEven = false;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] < arrMin && (arr[i] %\
    \ 2) == 0)\n        {\n            arrMin = arr[i];\n            arrMinIndex =\
    \ i;\n            isEven = true;\n        }\n    }\n    if (isEven)\n        return\
    \ tuple(arrMin, arrMinIndex);\n    else\n        return new long[0];\n}", "{\n\
    \    int idx;\n    long smallest_even_val = int.max;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
