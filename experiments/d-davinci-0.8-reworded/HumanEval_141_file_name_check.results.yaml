name: HumanEval_141_file_name_check
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string file_types[]\
    \ = [\"txt\", \"exe\", \"dll\"];\n    foreach(file_type; file_types)\n    {\n\
    \        string extension = \".\" ~ file_type;\n        if(file_name.count(extension)\
    \ == 1)\n        {\n            string file_name_without_extension = file_name.split(extension)[0];\n\
    \            if(file_name_without_extension.length > 0)\n            {\n     \
    \           if(file_name_without_extension[0].isLetter)\n                {\n \
    \                   if(file_name_without_extension.count(\"0\":\"9\") <= 3)\n\
    \                    {\n                        return \"Yes\";\n            \
    \        }\n                }\n            }\n        }\n    }\n    return \"\
    No\";\n}\n// (function() {\n//   /* Fill in code here */\n// })();\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpofznbn01.d(22): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `string[] file_types`\\n/tmp/tmpofznbn01.d(33): Error: found `:` when\
    \ expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpofznbn01.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n\tbool is_txt =\
    \ \"txt\" in file_name.split(\".\")[1];\n\tbool is_exe = \"exe\" in file_name.split(\"\
    .\")[1];\n\tbool is_dll = \"dll\" in file_name.split(\".\")[1];\n\tbool no_ext\
    \ = is_txt || is_exe || is_dll;\n\tint count = 0;\n\tforeach(immutable c; file_name.split(\"\
    .\")[0]) \n\t{\n\t\tif(\"0\" .. \"9\" in c) \n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\
    }\n\tif(\"a\" .. \"z\" in file_name.split(\".\")[0][0]) \n\t{\n\t\tif(count <=\
    \ 3 && no_ext) \n\t\t{\n\t\t\treturn \"Yes\";\n\t\t}\n\t}\n\treturn \"No\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6kseahek.d(29): Error: found `..` when expecting `)`\\n/tmp/tmp6kseahek.d(29):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmp6kseahek.d(34):\
    \ Error: found `..` when expecting `)`\\n/tmp/tmp6kseahek.d(34): Error: found\
    \ `)` when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6kseahek.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    //If the file\
    \ name contains more than three digits\n    if(file_name.match(r\"\\d\\d\\d\"\
    ).length > 3)\n    {\n        return \"No\";\n    }\n    //If the file name contains\
    \ more than one dot\n    if(file_name.match(r\"\\.\").length > 1)\n    {\n   \
    \     return \"No\";\n    }\n    //If the file name contains 0 dots\n    if(file_name.match(r\"\
    \\.\").length == 0)\n    {\n        return \"No\";\n    }\n    //If the substring\
    \ before the dot is empty or is not a letter\n    if(file_name.match(r\"^[a-zA-Z]\"\
    ).length == 0)\n    {\n        return \"No\";\n    }\n    //If the substring after\
    \ the dot is not one of the provided strings\n    if(file_name.match(r\"\\.(exe|txt|dll)$\"\
    ).length == 0)\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt4n7fz33.d(23): Error: no property `match` for type `string`\\\
    n/tmp/tmpt4n7fz33.d(28): Error: no property `match` for type `string`\\n/tmp/tmpt4n7fz33.d(33):\
    \ Error: no property `match` for type `string`\\n/tmp/tmpt4n7fz33.d(38): Error:\
    \ no property `match` for type `string`\\n/tmp/tmpt4n7fz33.d(43): Error: no property\
    \ `match` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpt4n7fz33.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int len = file_name.length;\n\
    \    char ext = file_name[len-3];\n    char ext1 = file_name[len-2];\n    char\
    \ ext2 = file_name[len-1];\n    string extension = ext + ext1 + ext2;\n    uint\
    \ counter = 0;\n    for(uint i = 0; i < len; i++)\n    {\n        if(file_name[i]\
    \ == '.')\n        {\n            if(counter > 0)\n            {\n           \
    \     return \"No\";\n            }\n            counter++;\n        }\n     \
    \   if(isdigit(file_name[i]))\n        {\n            counter++;\n        }\n\
    \    }\n    if(counter > 3)\n    {\n        return \"No\";\n    }\n    if(file_name[0]\
    \ == '.')\n    {\n        return \"No\";\n    }\n    if(extension != \"txt\" &&\
    \ extension != \"exe\" && extension != \"dll\")\n    {\n        return \"No\"\
    ;\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyhyvi3xd.d(22): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpyhyvi3xd.d(26): Error: cannot implicitly\
    \ convert expression `cast(int)ext + cast(int)ext1 + cast(int)ext2` of type `int`\
    \ to `string`\\n/tmp/tmpyhyvi3xd.d(38): Error: undefined identifier `isdigit`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyhyvi3xd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto result\
    \ = true;\n    foreach(i; 0 .. file_name.length)\n    {\n        if (file_name[i]\
    \ >= '0' && file_name[i] <= '9')\n        {\n            if (result)\n       \
    \     {\n                if (i > 3)\n                {\n                    result\
    \ = false;\n                }\n            }\n        }\n        else if (file_name[i]\
    \ == '.')\n        {\n            if (i == 0 || i == file_name.length - 1)\n \
    \           {\n                result = false;\n            }\n            else\n\
    \            {\n                if (file_name[i + 1] == 't' && file_name[i + 2]\
    \ == 'x' && file_name[i + 3] == 't')\n                {\n                }\n \
    \               else if (file_name[i + 1] == 'e' && file_name[i + 2] == 'x' &&\
    \ file_name[i + 3] == 'e')\n                {\n                }\n           \
    \     else if (file_name[i + 1] == 'd' && file_name[i + 2] == 'l' && file_name[i\
    \ + 3] == 'l')\n                {\n                }\n                else\n \
    \               {\n                    result = false;\n                }\n  \
    \          }\n        }\n        else if (file_name[i] >= 'a' && file_name[i]\
    \ <= 'z')\n        {\n            if (i == file_name.length - 1)\n           \
    \ {\n                result = false;\n            }\n        }\n        else if\
    \ (file_name[i] >= 'A' && file_name[i] <= 'Z')\n        {\n            if (i ==\
    \ file_name.length - 1)\n            {\n                result = false;\n    \
    \        }\n        }\n        else\n        {\n            result = false;\n\
    \        }\n    }\n    if (result)\n    {\n        return \"Yes\";\n    }\n  \
    \  else\n    {\n        return \"No\";\n    }\n}\n/*\nGiven a string, return a\
    \ string representing its value in binary, and with the binary \nindices as specified\
    \ below.\nExamples:\n\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplumg2vhq.d(86): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplumg2vhq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    enum { MAX_DIGITS\
    \ = 3 };\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_83_ok0.d(22): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\n/tmp/tmpz_83_ok0.d(23): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz_83_ok0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    enum alph =\
    \ ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z'];\n    enum digits = ['0', '1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9'];\n    enum extention = ['txt', 'exe', 'dll'];\n    int dot_count\
    \ = 0;\n    int digit_count = 0;\n    int char_count = 0;\n    bool is_alph =\
    \ false;\n    string file_name_extention = \"\";\n    string file_name_without_extention\
    \ = \"\";\n    if (file_name.length == 0)\n    {\n        return \"No\";\n   \
    \ }\n    foreach (c; file_name)\n    {\n        if (c == '.')\n        {\n   \
    \         dot_count++;\n        }\n        else if (digits.canFind(c))\n     \
    \   {\n            digit_count++;\n        }\n        else if (alph.canFind(c))\n\
    \        {\n            is_alph = true;\n            char_count++;\n        }\n\
    \        else\n        {\n            return \"No\";\n        }\n    }\n    if\
    \ (dot_count != 1)\n    {\n        return \"No\";\n    }\n    if (digit_count\
    \ > 3)\n    {\n        return \"No\";\n    }\n    if (!is_alph)\n    {\n     \
    \   return \"No\";\n    }\n    file_name_extention = file_name[file_name.length\
    \ - 3 .. file_name.length];\n    file_name_without_\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiau310j8.d(24): Error: unterminated character constant\\n/tmp/tmpiau310j8.d(24):\
    \ Error: unterminated character constant\\n/tmp/tmpiau310j8.d(24): Error: unterminated\
    \ character constant\\n/tmp/tmpiau310j8.d(24): Error: unterminated character constant\\\
    n/tmp/tmpiau310j8.d(24): Error: unterminated character constant\\n/tmp/tmpiau310j8.d(24):\
    \ Error: unterminated character constant\\n/tmp/tmpiau310j8.d(24): Error: comma\
    \ expected separating array initializers, not `xt`\\n/tmp/tmpiau310j8.d(24): Error:\
    \ semicolon expected following auto declaration, not `63U`\\n/tmp/tmpiau310j8.d(24):\
    \ Error: found `63U` when expecting `;` following statement\\n/tmp/tmpiau310j8.d(24):\
    \ Error: found `63U` when expecting `;` following statement\\n/tmp/tmpiau310j8.d(24):\
    \ Error: found `ll` when expecting `;` following statement\\n/tmp/tmpiau310j8.d(69):\
    \ Error: found `unittest` when expecting `;` following statement\\n/tmp/tmpiau310j8.d(100):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiau310j8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    enum file_type\
    \ = [\"txt\", \"exe\", \"dll\"];\n    immutable file_name_type = file_name.split(\"\
    .\");\n    if (file_name_type.length != 2) return \"No\";\n    if (file_name_type[0].filter!(ch\
    \ => ch.isDigit).length > 3) return \"No\";\n    if (file_name_type[0].length\
    \ == 0) return \"No\";\n    if (!file_name_type[0][0].isAlpha) return \"No\";\n\
    \    if (file_name_type[1] !in file_type) return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9u9q3ftp.d(23): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9u9q3ftp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n\tstring [] file_name_array\
    \ = split(file_name, \".\");\n\t// Check for only one dot.\n\tif (file_name_array.length\
    \ > 2)\n\t{\n\t\treturn \"No\";\n\t}\n\t// Check for at least one letter\n\tif\
    \ (file_name_array[0].length == 0)\n\t{\n\t\treturn \"No\";\n\t}\n\t// Check for\
    \ correct file extension.\n\tif (!in(file_name_array[1], [\"txt\", \"exe\", \"\
    dll\"]))\n\t{\n\t\treturn \"No\";\n\t}\n\t// Check that the file name is not empty.\n\
    \tif (file_name_array[0].length == 0)\n\t{\n\t\treturn \"No\";\n\t}\n\t// Check\
    \ that there are no numbers in the file name.\n\tforeach (letter; file_name_array[0])\n\
    \t{\n\t\tif (in('0', '9', letter))\n\t\t{\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\t\
    // Check that the first letter is not a number.\n\tif (in('0', '9', file_name_array[0][0]))\n\
    \t{\n\t\treturn \"No\";\n\t}\n\treturn \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp_rfp8ks.d(34): Error: expression expected, not `in`\\n/tmp/tmpp_rfp8ks.d(46):\
    \ Error: expression expected, not `in`\\n/tmp/tmpp_rfp8ks.d(52): Error: expression\
    \ expected, not `in`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_rfp8ks.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto index =\
    \ file_name.find('.');\n    if ( index != string.npos ) \n    {\n        string\
    \ prefix = file_name[0..index];\n        string postfix = file_name[index+1..$];\n\
    \        size_t num_digits = 0;\n        bool letter_found = false;\n        for\
    \ (auto e : prefix) \n        {\n            if (isdigit(e))\n               \
    \ num_digits++;\n            else if (isalpha(e))\n                letter_found\
    \ = true;\n        }\n        if (num_digits > 3 || !letter_found || prefix.length\
    \ == 0)\n            return \"No\";\n        else if (postfix != \"txt\" && postfix\
    \ != \"exe\" && postfix != \"dll\")\n            return \"No\";\n        else\n\
    \            return \"Yes\";\n    } \n    else \n    {\n        return \"No\"\
    ;\n    }\n}\n/*\n10)\nCreate a function which takes a string representing a polynomial\
    \ expression,\nand returns the simplified expression.\nThe expression is of form\
    \ 'ax + b', where a and b are real numbers, and x\nis a variable name.\nx is considered\
    \ to be a valid variable name if and only if all the following conditions\nare\
    \ met:\n- The first character is 'x'.\n- The rest of the characters are letters\
    \ from the latin alphabet ( 'a'-'z' and 'A'-'Z' ).\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7yso5omx.d(29): Error: no identifier for declarator `e`\\n/tmp/tmp7yso5omx.d(29):\
    \ Error: expression expected, not `:`\\n/tmp/tmp7yso5omx.d(29): Error: found `prefix`\
    \ when expecting `;` following `for` condition\\n/tmp/tmp7yso5omx.d(48): Error:\
    \ unterminated /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp7yso5omx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    \n    //returns\
    \ the file name without the extension\n    auto name = file_name.split(\".\").front();\n\
    \    //returns the file's extension\n    auto extension = file_name.split(\".\"\
    ).back;\n    int count = 0;\n    foreach(i;0..name.length)\n    {\n        //if\
    \ a number is found, count increases by 1\n        if(isNumeric(name[i]))\n  \
    \      {\n            count++;\n        }\n    }\n    //checks if all conditions\
    \ are met\n    return (count<=3 && file_name.count('.')==1 && name[0].isAlpha\
    \ && extension == \"txt\" || extension == \"exe\" || extension == \"dll\") ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n  \
    \  assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpapk65amn.d(24): Error: no property `split` for type `string`\\\
    n/tmp/tmpapk65amn.d(26): Error: no property `split` for type `string`\\n/tmp/tmpapk65amn.d(37):\
    \ Error: no property `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpapk65amn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    static struct\
    \ file_name_check_result\n    {\n        string is_valid = \"No\";\n        uint\
    \ dot_pos = 0;\n        uint num_of_digits = 0;\n    } fncr;\n    static string\
    \ const valid_exts[] = [\"txt\", \"exe\", \"dll\"];\n    static string const alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    static string const digits = \"0123456789\"\
    ;\n    static string const dot = \".\";\n    static import std.range.primitives\
    \ : take, takeOne;\n    static import std.algorithm.comparison : startsWith;\n\
    \    static import std.algorithm.searching : count, any;\n    static import std.algorithm.iteration\
    \ : countUntil;\n    static import std.functional : pred;\n    static import std.array\
    \ : array;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjebi7ng7.d(28): Error: no identifier for declarator `string`\\\
    n/tmp/tmpjebi7ng7.d(28): Error: no identifier for declarator `valid_exts[]`\\\
    n/tmp/tmpjebi7ng7.d(28): Error: found `=` instead of statement\\n/tmp/tmpjebi7ng7.d(29):\
    \ Error: no identifier for declarator `string`\\n/tmp/tmpjebi7ng7.d(30): Error:\
    \ no identifier for declarator `string`\\n/tmp/tmpjebi7ng7.d(31): Error: no identifier\
    \ for declarator `string`\\n/tmp/tmpjebi7ng7.d(32): Error: static import `std`\
    \ cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(32): Error: static import\
    \ `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(33): Error: static\
    \ import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(34): Error:\
    \ static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(34):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(35):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(36):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(37):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(38):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(39):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(40):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(41):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(42):\
    \ Error: static import `std` cannot have an import bind list\\n/tmp/tmpjebi7ng7.d(43):\
    \ Error: static import `std` cannot have an import bind list\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjebi7ng7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] exten\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_position = file_name.find(\".\"\
    );\n    string sub = file_name[0..dot_position];\n    string after_dot = file_name[dot_position\
    \ + 1..$];\n    bool valid = true;\n    if (dot_position == 0) \n    {\n     \
    \   valid = false;\n    }\n    else if (count(file_name, \".\") != 1) \n    {\n\
    \        valid = false;\n    }\n    else if (!(exten.find(after_dot) != -1)) \n\
    \    {\n        valid = false;\n    }\n    int cnt = 0;\n    foreach (char c;\
    \ sub) \n    {\n        if (c >= '0' && c <= '9') \n        {\n            cnt++;\n\
    \        }\n    }\n    if (cnt > 3) \n    {\n        valid = false;\n    }\n \
    \   else if (!((sub[0] >= 'a' && sub[0] <= 'z') || (sub[0] >= 'A' && sub[0] <=\
    \ 'Z'))) \n    {\n        valid = false;\n    }\n    return valid ? \"Yes\" :\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp44p6t962.d(23): Error: no property `find` for type `string`\\\
    n/tmp/tmp44p6t962.d(31): Error: undefined identifier `count`\\n/tmp/tmp44p6t962.d(35):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp44p6t962.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string result\
    \ = \"No\";\n    int num_of_dots = 0;\n    int num_of_digits = 0;\n    string\
    \ file_name_ext;\n    string file_name_prefix;\n    foreach(char c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            num_of_dots++;\n        \
    \    continue;\n        }\n        if(num_of_dots == 0)\n        {\n         \
    \   file_name_prefix ~= c;\n        }\n        else\n        {\n            file_name_ext\
    \ ~= c;\n        }\n        if(isdigit(c))\n        {\n            num_of_digits++;\n\
    \        }\n    }\n    if(num_of_dots == 1 && num_of_digits <= 3 && file_name_prefix.length\
    \ != 0 \n        && isalpha(file_name_prefix[0]) && (file_name_ext == \"txt\"\
    \ || file_name_ext == \"exe\" || file_name_ext == \"dll\"))\n    {\n        result\
    \ = \"Yes\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n   \
    \ assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwl3zr057.d(42): Error: undefined identifier `isdigit`\\n/tmp/tmpwl3zr057.d(48):\
    \ Error: undefined identifier `isalpha`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpwl3zr057.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count =\
    \ 0;\n    int dot_count = 0;\n    int i = 0;\n    bool is_letter = false;\n  \
    \  bool is_extension = false;\n    int point = 0;\n    while(file_name[i] != '\\\
    0')\n    {\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n\
    \            point = i;\n        }\n        else if(file_name[i] >= '0' && file_name[i]\
    \ <= '9')\n        {\n            count++;\n        }\n        else if((file_name[i]\
    \ >= 'a' && file_name[i] <= 'z') || (file_name[i] >= 'A' && file_name[i] <= 'Z'))\n\
    \        {\n            is_letter = true;\n        }\n        else if(file_name[i]\
    \ == '.')\n        {\n            point = i;\n        }\n        i++;\n    }\n\
    \    string extension = file_name[point+1..$];\n    if(extension == \"txt\" ||\
    \ extension == \"exe\" || extension == \"dll\")\n    {\n        is_extension =\
    \ true;\n    }\n    if(count <= 3 && dot_count == 1 && is_letter && is_extension)\n\
    \    {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpibklwe4i.d(28): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428916]\\n??:? immutable(char)[] tmpibklwe4i.file_name_check(immutable(char)[])\
    \ [0x427aa4]\\n??:? void tmpibklwe4i.__unittest_L63_C1() [0x427d26]\\n??:? void\
    \ tmpibklwe4i.__modtest() [0x4285e8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c583]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b492]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4305a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430a58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430535]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b469]\\n??:? runModuleUnitTests [0x42c359]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428d28]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428caf]\\n??:? _d_run_main [0x428c1a]\\n??:? main [0x4285fb]\\\
    n??:? __libc_start_main [0x65974554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto extension\
    \ = file_name.split(\".\");\n    bool result = extension.length > 1 && extension[0].length\
    \ > 0 && \n        extension[0].all!(\"a\"..\"z\" ~ \"A\"..\"Z\") && \n      \
    \  extension[1] in [\"txt\", \"exe\", \"dll\"] &&\n        extension[0].all!(\"\
    0\"..\"9\");\n    return result ? \"Yes\" : \"No\";\n}\n \n \nstring file_name_check_regex(string\
    \ file_name) \n{\n    enum match = file_name.match(\"\\\\w+\\\\.(txt|exe|dll)\"\
    );\n    return match ? \"Yes\" : \"No\";\n}\n \n void main()\n {\n     assert(file_name_check(\"\
    example.txt\") == \"Yes\");\n     assert(file_name_check(\"1example.dll\") ==\
    \ \"No\");\n     assert(file_name_check(\"1example.exe\") == \"No\");\n     assert(file_name_check(\"\
    example.txt2\") == \"No\");\n     assert(file_name_check(\"exa3mple.txt\") ==\
    \ \"No\");\n     assert(file_name_check(\"exampl3.txt\") == \"No\");\n     assert(file_name_check_regex(\"\
    example.txt\") == \"Yes\");\n     assert(file_name_check_regex(\"1example.dll\"\
    ) == \"No\");\n     assert(file_name_check_regex(\"1example.exe\") == \"No\");\n\
    \     assert(file_name_check_regex(\"example.txt2\") == \"No\");\n     assert(file_name_check_regex(\"\
    exa3mple.txt\") == \"No\");\n     assert(file_name_check_regex(\"exampl3.txt\"\
    ) == \"No\");\n     //TODO add more tests.\n }\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5qbcmwev.d(24): Error: found `..` when expecting `)` following\
    \ template argument list\\n/tmp/tmp5qbcmwev.d(24): Error: semicolon expected,\
    \ not `\"z\"`\\n/tmp/tmp5qbcmwev.d(24): Error: found `..` when expecting `;` following\
    \ statement\\n/tmp/tmp5qbcmwev.d(24): Error: found `)` when expecting `;` following\
    \ statement\\n/tmp/tmp5qbcmwev.d(24): Error: found `&&` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5qbcmwev.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    /* aliases */\n\
    \    import std.array;\n    import std.algorithm;\n    import std.string;\n  \
    \  import std.typecons;\n    import std.typecons;\n    import std.range;\n   \
    \ import std.algorithm;\n    import std.algorithm : filter, map, count;\n    import\
    \ std.range : take, drop, takeExactly, dropExactly;\n    import std.range : find;\n\
    \    import std.range : empty;\n    import std.conv : text;\n    import std.range\
    \ : iota;\n    import std.regex : regex, ctRegex, RegexMatch;\n    import std.regex\
    \ : replace;\n    import std.math : sqrt;\n    import std.math : parse;\n    import\
    \ std.digest.sha : sha1;\n    import std.digest.crc : crc32;\n    import std.range\
    \ : only;\n    import std.math : isNaN;\n    import std.typecons : tuple;\n  \
    \  import std.typecons : Tuple;\n    import std.traits : Unqual;\n    import std.traits\
    \ : unqual;\n    import std.typecons : tuple;\n    import std.range : only;\n\
    \    import std.typecons : Tuple;\n    import std.traits : Unqual;\n    import\
    \ std.traits : unqual;\n    import std.range : only;\n    import std.range : only;\n\
    \    import std.range : only;\n    import std.range : only;\n    import std.range\
    \ : only;\n    import std.range : only;\n    import std.range : only;\n    import\
    \ std.range : only;\n    import std.range : only;\n    import std.range : only;\n\
    \    import std.range : only;\n    import std.range : only;\n    import std.range\
    \ : only;\n    import std.range : only;\n    import std.range : only;\n    import\
    \ std.range : only;\n    import std.range : only;\n    import std.range : only;\n\
    \    import std.range : only;\n    import std.range : only;\n    import std.range\
    \ : only;\n    import\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyysjto3c.d(75): Error: identifier expected following `import`\\\
    n/tmp/tmpyysjto3c.d(75): Error: `;` expected\\n/tmp/tmpyysjto3c.d(106): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyysjto3c.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_position\
    \ = file_name.find('.');\n    string extension = file_name.substr(dot_position\
    \ + 1);\n    if(extension.length != 3) \n    {\n        return \"No\";\n    }\n\
    \    else if(!std.regex.match(\"^[a-zA-Z]+$\", file_name.substr(0, dot_position)))\
    \ \n    {\n        return \"No\";\n    }\n    else if(!std.regex.match(\"^[a-zA-Z]$\"\
    , file_name[0])) \n    {\n        return \"No\";\n    }\n    else if(!std.regex.match(\"\
    ^[a-zA-Z0-9]+$\", extension)) \n    {\n        return \"No\";\n    }\n    else\
    \ if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\") \n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n/*\n    Create\
    \ a function which takes a string representing the file's name, and returns \n\
    \    its extention.\n    A file's name is considered to be valid if and only if\
    \ all the following conditions \n    are met:\n    - There should not be more\
    \ than three digits ('0'-'9') in the file's name.\n    - The file's name contains\
    \ exactly one dot '.'\n    - The substring before the dot should not be empty,\
    \ and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n\
    \    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\
    \    It is assured that the input is valid.\n    Examples:\n    >>> file_name_get_extension(\"\
    example.txt\")\n    \"txt\"\n    >>> file_name_get_extension(\"1example.dll\"\
    )\n    \"dll\"\n*/\nstring file_name_get_extension(string file_name) \n{\n   \
    \ int dot_position = file_name.find('.');\n    return file_name.substr(dot_position\
    \ + 1);\n}\n/*\n    Create a\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpifj6mez3.d(68): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpifj6mez3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string sub =\
    \ file_name[1..$-4];\n    if (file_name[$-3..$] == \"txt\" || file_name[$-3..$]\
    \ == \"exe\" || file_name[$-3..$] == \"dll\")\n    {\n        if (file_name[0..0]\
    \ != \"0\" && file_name[0..0] != \"1\" && file_name[0..0] != \"2\" && file_name[0..0]\
    \ != \"3\" && file_name[0..0] != \"4\" && file_name[0..0] != \"5\" && file_name[0..0]\
    \ != \"6\" && file_name[0..0] != \"7\" && file_name[0..0] != \"8\" && file_name[0..0]\
    \ != \"9\")\n        {\n            int num = 0;\n            foreach (c; sub)\n\
    \            {\n                if (c == \"0\" || c == \"1\" || c == \"2\" ||\
    \ c == \"3\" || c == \"4\" || c == \"5\" || c == \"6\" || c == \"7\" || c == \"\
    8\" || c == \"9\")\n                {\n                    num++;\n          \
    \      }\n            }\n            if (num <= 3)\n            {\n          \
    \      return \"Yes\";\n            }\n            else\n            {\n     \
    \           return \"No\";\n            }\n        }\n        else\n        {\n\
    \            return \"No\";\n        }\n    }\n    else\n    {\n        return\
    \ \"No\";\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n \
    \   assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqr7f5ntt.d(30): Error: incompatible types for `(c) == (\"0\"\
    )`: `immutable(char)` and `string`\\n/tmp/tmpqr7f5ntt.d(30): Error: incompatible\
    \ types for `(c) == (\"1\")`: `immutable(char)` and `string`\\n/tmp/tmpqr7f5ntt.d(30):\
    \ Error: incompatible types for `(c) == (\"2\")`: `immutable(char)` and `string`\\\
    n/tmp/tmpqr7f5ntt.d(30): Error: incompatible types for `(c) == (\"3\")`: `immutable(char)`\
    \ and `string`\\n/tmp/tmpqr7f5ntt.d(30): Error: incompatible types for `(c) ==\
    \ (\"4\")`: `immutable(char)` and `string`\\n/tmp/tmpqr7f5ntt.d(30): Error: incompatible\
    \ types for `(c) == (\"5\")`: `immutable(char)` and `string`\\n/tmp/tmpqr7f5ntt.d(30):\
    \ Error: incompatible types for `(c) == (\"6\")`: `immutable(char)` and `string`\\\
    n/tmp/tmpqr7f5ntt.d(30): Error: incompatible types for `(c) == (\"7\")`: `immutable(char)`\
    \ and `string`\\n/tmp/tmpqr7f5ntt.d(30): Error: incompatible types for `(c) ==\
    \ (\"8\")`: `immutable(char)` and `string`\\n/tmp/tmpqr7f5ntt.d(30): Error: incompatible\
    \ types for `(c) == (\"9\")`: `immutable(char)` and `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqr7f5ntt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"\
    example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"\
    No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto file_name_parts\
    \ = splitter(file_name, \".\");\n    int dot_count = 0;\n    int digits_count\
    \ = 0;\n    string file_extension = \"\";\n    string file_name_to_check = \"\"\
    ;\n    bool file_name_valid = true;\n    foreach(part; file_name_parts)\n    {\n\
    \        if(part == \"txt\" || part == \"exe\" || part == \"dll\")\n        {\n\
    \            file_extension = part;\n        }\n        else\n        {\n    \
    \        file_name_to_check = part;\n        }\n        if(part == \".\")\n  \
    \      {\n            dot_count += 1;\n        }\n        digits_count += count(part,\
    \ char(48..57));\n    }\n    if(file_name_to_check.length() == 0 || !file_name_to_check[0].isAlpha\
    \ || file_name_to_check[0].isLower)\n    {\n        file_name_valid = false;\n\
    \    }\n    if(digits_count > 3 || dot_count != 1 || file_extension == \"\")\n\
    \    {\n        file_name_valid = false;\n    }\n    if(file_name_valid)\n   \
    \ {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n\
    \    }\n    \n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuxbvwrnd.d(42): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuxbvwrnd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
