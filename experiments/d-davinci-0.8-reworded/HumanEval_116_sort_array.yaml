name: HumanEval_116_sort_array
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    In this Kata, you have\
  \ to sort an array of non-negative integers according to\n    number of ones in\
  \ their binary representation in ascending order.\n    For similar number of ones,\
  \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
  \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
  \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L, 0L,\
  \ 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[] arr)\
  \ \n"
tests: "unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
  \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
  \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L,\
  \ 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
  \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
  \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
  \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
  \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
  \ 16L, 32L]);\n}\nvoid main(){}"
completions: ["{\n    //return std.algorithm.sort(arr, (a, b) => cast(int)ones(a)\
    \ == cast(int)ones(b) ? a < b : ones(a) < ones(b));\n    return arr.sort!((a,\
    \ b) => cast(int)ones(a) == cast(int)ones(b) ? a < b : ones(a) < ones(b));\n}",
  "{\n    auto comparer = (long a, long b)\n    {\n        auto binA = to!string(a,\
    \ 2);\n        auto binB = to!string(b, 2);\n        if (count(binA, '1') < count(binB,\
    \ '1'))\n            return -1;\n        else if (count(binA, '1') > count(binB,\
    \ '1'))\n            return 1;\n        else if (a < b)\n            return -1;\n\
    \        else if (a > b)\n            return 1;\n        else\n            return\
    \ 0;\n    };\n    sort(arr, comparer);\n    return arr;\n}", "{\n    return quicksort(arr);\n\
    }", "{\n    int[] ones = new int[arr.length];\n    int[] zeros = new int[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++) {\n        long binary = arr[i];\n \
    \       int count = 0;\n        while (binary > 0) {\n            if (binary %\
    \ 2 == 1) {\n                count++;\n            }\n            binary /= 2;\n\
    \        }\n        ones[i] = count;\n        zeros[i] = arr[i];\n    }\n    long[]\
    \ result = new long[arr.length];\n    for (int i = 0; i < arr.length; i++) {\n\
    \        int minIndex = minIndex(ones);\n        result[i] = zeros[minIndex];\n\
    \        ones[minIndex] = int.max;\n    }\n    return result;\n}", "{\n    auto\
    \ members = [] (long item) \n    {\n        int num_ones = 0;\n        foreach(\
    \ c; item.to!string())\n        {\n            if(c == '1')\n                num_ones++;\n\
    \        }\n        return tuple(num_ones, item);\n    };\n    return arr.map!members.sort.map!(tuple_typeof(arr[0],\
    \ arr[0]).tupleof[1]);\n}", "{\n    arr.sort!(CompareByOnes)();\n    return arr;\n\
    }", "{\n    Tuple!(ulong,ulong)[] t;\n    foreach(i;arr)\n    {\n        ulong\
    \ b = i;\n        ulong count = 0;\n        while(b!=0)\n        {\n         \
    \   count += b & 1;\n            b = b >> 1;\n        }\n        t ~= tuple(count,i);\n\
    \    }\n    // sort by number of 1s in binary, then by decimal\n    t.sort!((e1,e2)=>e1[0]==e2[0]?e1[1]<e2[1]:e1[0]<e2[0]);\n\
    \    return t.map!(e=>e[1]).array;\n}\n```", "{\n    //arr.sort();\n    arr.sort!((int\
    \ i1, int i2)\n    {\n        return countOnes(i1) - countOnes(i2);\n    });\n\
    \    return arr;\n}", "{\n    long[] ones = new long[arr.length];\n    long[]\
    \ sorted = new long[arr.length];\n    auto arrTuple = new Tuple!(int, int)[arr.length];\n\
    \    foreach(int i, long a; arr) {\n        int one = 0;\n        int sign = a\
    \ < 0 ? -1 : 1;\n        a *= sign;\n        while(a > 0) {\n            if(a\
    \ & 1)\n                one++;\n            a >>= 1;\n        }\n        ones[i]\
    \ = one;\n        arrTuple[i] = tuple(one, a * sign);\n    }\n    auto sortedTuple\
    \ = insertionSort(arrTuple);\n    foreach(int i, tuple; sortedTuple) {\n     \
    \   sorted[i] = tuple[1];\n    }\n    return sorted;\n}", "{\n    return arr.dup.sort!((a,\
    \ b) => {\n        if (a.countOnes == b.countOnes)\n            return a < b;\n\
    \        return a.countOnes < b.countOnes;\n    });\n}", "{\n    arr = arr.map!((x)\
    \ => tuple(x, x.countOnes))\n        .map!((x) => tuple(x[0], x[1], x[0].countOnes))\n\
    \        .sort!((x, y) =>\n        {\n            if (x[1] == y[1])\n        \
    \        return x[0] > y[0];\n            return x[1] > y[1];\n        }).map!((x)\
    \ => x[0]).array;\n    return arr;\n}", "{\n    class Number\n    {\n        private\
    \ long value;\n        private int ones;\n        this(long value)\n        {\n\
    \            this.value = value;\n            ones = countOneBits(value);\n  \
    \      }\n        long getValue()\n        {\n            return value;\n    \
    \    }\n        int getOnes()\n        {\n            return ones;\n        }\n\
    \    }\n    Number[] numbers = arr.map!(a => new Number(a));\n    sort!((a, b)\
    \ => \n    {\n        if (a.getOnes() == b.getOnes())\n            return a.getValue()\
    \ < b.getValue();\n        return a.getOnes() < b.getOnes();\n    })(numbers);\n\
    \    return numbers.map!(n => n.getValue()).array;\n}", "{\n    long[] sorted_array\
    \ = arr.dup;\n    const bitmask = 1;\n    std.datetime.stopwatch sw = new std.datetime.stopwatch;\n\
    \    sw.start;\n    sort(sorted_array.begin, sorted_array.end, (a, b) =>\n   \
    \ {\n        if (popCount(a & bitmask) < popCount(b & bitmask)) return true;\n\
    \        if (popCount(a & bitmask) > popCount(b & bitmask)) return false;\n  \
    \      if (a < b) return true;\n        return false;\n    });\n    sw.stop;\n\
    \    writeln(sw.peek.seconds);\n    return sorted_array;\n}", "{\n    return arr.sorted!((a,\
    \ b) => // sort array with lambda function\n    {\n        if(__ctfe) // workaround\
    \ for DMD CTFE bug http://d.puremagic.com/issues/show_bug.cgi?id=7905\n      \
    \  {\n            static if(a == -2 || b == -2)\n                return a == -2\
    \ ? b > -2 : -2 > b;\n            static if(a == -3 || b == -3)\n            \
    \    return a == -3 ? b > -3 : -3 > b;\n            static if(a == -4 || b ==\
    \ -4)\n                return a == -4 ? b > -4 : -4 > b;\n            static if(a\
    \ == -5 || b == -5)\n                return a == -5 ? b > -5 : -5 > b;\n     \
    \       static if(a == -6 || b == -6)\n                return a == -6 ? b > -6\
    \ : -6 > b;\n        }\n        if(a == 0) // zero -> first\n            return\
    \ false;\n        if(b == 0) // zero -> first\n            return true;\n    \
    \    static assert(a != 0 && b != 0);\n        static if(a > 0 && b > 0) // positive\
    \ -> by ones, then by number\n        {\n            if(a == b)\n            \
    \    return false;\n            int aOnes = 0;\n            int bOnes = 0;\n \
    \           do\n            {\n                if(a & 1L)\n                  \
    \  ++aOnes;\n                if(b & 1L)\n                    ++bOnes;\n      \
    \          a = a >> 1;\n                b = b >> 1;\n            } while(a !=\
    \ 0 || b != 0);\n            if(aOnes == bOnes)\n                return a < b;\n\
    \            return aOnes < bOnes;\n        }\n        else if(a < 0 && b < 0)\
    \ // negative -> by number\n            return a > b;\n        else // one positive,\
    \ one negative -> negative -> first\n            return a < 0;\n    });\n}", "{\n\
    \  auto list = arr.map!(a => tuple(countOnes(a), a));\n  list.sort!((e, e2) =>\
    \ e[0] == e2[0] ? e[1] < e2[1] : e[0] < e2[0]);\n  return list.map!((e) => e[1]).array;\n\
    }", "{\n    return arr.sort!(x => x.clamp(0L, 1L).count, y => y)();\n}", "{\n\
    \    long[] res = arr.dup;\n    res.sort!(a, b => \n    {\n        if (a.countOnes\
    \ != b.countOnes)\n            return a.countOnes < b.countOnes;\n        else\n\
    \            return a < b;\n    });\n    return res;\n}", "{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int[string] aa = a.toString(\"2\").to!int[string];\n\
    \        int[string] bb = b.toString(\"2\").to!int[string];\n        return aa.countof('1')\
    \ == bb.countof('1') ? a - b : aa.countof('1') - bb.countof('1');\n    });\n}\n\
    /*\n    static assert(sort_array([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L, 5L]);\n\
    \    static assert(sort_array([-2L, -3L, -4L, -5L, -6L]) == [-6L, -5L, -4L, -3L,\
    \ -2L]);\n    static assert(sort_array([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 3L,\
    \ 4L]);\n*/", "{\n    if (arr.length < 2) \n        return arr;\n    \n    int[]\
    \ ranks = new int[arr.length];\n    int[] vals = new int[arr.length];\n    foreach\
    \ (i, elem; arr)\n    {\n        int rank = (cast(int) elem).countOnes;\n    \
    \    int j = i;\n        while (j > 0 && ranks[j - 1] == rank && vals[j - 1] >\
    \ elem)\n        {\n            vals[j] = vals[j - 1];\n            j--;\n   \
    \     }\n        ranks[j] = rank;\n        vals[j] = elem;\n    }\n    return\
    \ vals;\n}", "{\n    //~ return arr;\n    //~ return arr.sort!((a, b) => a.countOneBits()\
    \ < b.countOneBits() ? -1 : 1);\n    return arr.sort!((a, b) =>\n    {\n     \
    \   auto ac = a.countOneBits();\n        auto bc = b.countOneBits();\n       \
    \ return ac < bc ? -1 : ac > bc ? 1 : 0;\n    });\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
