language: d
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    // your code here\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb21xocb3.d(38): Error: function `tmpb21xocb3.pluck` has no `return`
    statement, but is expected to return a value of type `long[]`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpb21xocb3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallest_value = 10001L;\n \
    \   long index = -1L;\n    long value = -1L;\n    foreach(long i, elem; arr)\n\
    \    {\n        if(elem < smallest_value && elem % 2 == 0)\n        {\n      \
    \      smallest_value = elem;\n            index = i;\n            value = elem;\n\
    \        }\n    }\n    if(index < 0)\n    {\n        return [].init;\n    }\n\
    \    return [value, index].init;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5sby5ov6.d(54): Error: cannot implicitly convert expression
    `null` of type `void[]` to `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp5sby5ov6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long[] res = new long[2];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[(int)i] % 2 == 0)\n        {\n            if (arr[(int)i] < min)\n    \
    \        {\n                min = arr[(int)i];\n                minIndex = i;\n\
    \            }\n        }\n    }\n    if (min % 2 == 0)\n    {\n        res[0]\
    \ = min;\n        res[1] = minIndex;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxbyrobw2.d(47): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpxbyrobw2.d(49):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpxbyrobw2.d(51): Error:
    C style cast illegal, use `cast(int)i`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpxbyrobw2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.takeWhile!((a) => a%2==0).dup.length==0\
    \ ? new long[](0) :\n           arr.indexOf(arr.min(a => a%2==0 ? a : cast(long)double.infinity));\n\
    }\n/*\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph7e9s76t.d(43): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmph7e9s76t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  if (arr.length == 0)\n        return result;\n    result[0] = arr[0];\n   \
    \ result[1] = 0;\n    if (arr[0] % 2 == 0)\n    {\n        result[0] = arr[0];\n\
    \        result[1] = 0;\n    }\n    else\n    {\n        result[0] = 100000;\n\
    \        result[1] = 0;\n    }\n    for (int i = 1; i < arr.length; i++)\n   \
    \ {\n        if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < result[0])\n\
    \            {\n                result[0] = arr[i];\n                result[1]\
    \ = i;\n            }\n        }\n    }\n    if (result[0] == 100000)\n    {\n\
    \        result[0] = 0;\n        result[1] = 0;\n    }\n    return result;\n}\n\
    /*\n    A magic number is a number whose digits, when added together, sum to 7.\n\
    \    For example, the number 34 would be a magic number, because 3 + 4 = 7.\n\
    \    Create a function to return either true or false depending on whether the\
    \ number is a magic number.\n*/\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmptd_m49wy.d(84): unittest failure\n----------------\n??:?
    _d_unittestp [0x42891d]\n??:? void tmptd_m49wy.__unittest_L78_C1() [0x4282ee]\n??:?
    void tmptd_m49wy.__modtest() [0x4286a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b86a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430af5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430fa4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430a81]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b841]\n??:? runModuleUnitTests [0x42c7ad]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428de0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428d67]\n??:? _d_run_main [0x428cd2]\n??:? main [0x4286b3]\n??:?
    __libc_start_main [0x7ad8f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.stdio;\n    import std.range;\n    /*\n    import\
    \ std.typecons;\n    import std.typecons : tuple;\n    import std.array;\n   \
    \ */\n    // brute force:\n    // return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : tuple(arr.filter!(l => l.isEven).sort().take(1),\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).map!(t\
    \ => t[0]).take(1));\n    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0],\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).map!(t\
    \ => t[0]).take(1)[0]];\n    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0],\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).take(1)[0]];\n\
    \    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l => l.isEven).sort().take(1))\
    \ ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0], arr.enumerate.filter!(t\
    \ => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).\nunittest\n{\n   \
    \ alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf62lcbbx.d(54): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf62lcbbx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto result = [];\n    long even\
    \ = long.max;\n    long index = 0;\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < even)\n        {\n           \
    \ even = arr[i];\n            index = i;\n        }\n    }\n    if (even == long.max)\
    \ return result;\n    else return [even, index];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz5ifz0jk.d(51): Error: cannot implicitly convert expression
    `result` of type `void[]` to `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpz5ifz0jk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm : min, filter,\
    \ count;\n    import std.math : min;\n    if(arr.length == 0)\n        return\
    \ [];\n    arr.sort!q{(a,b) => a > b};\n    auto y = arr.filter!q{x => x % 2 ==\
    \ 0}.array;\n    if(y.length == 0)\n        return [];\n    auto x = y.min;\n\
    \    return [x, arr.count!q{y => y == x}].min;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa9udq0e9.d(41): Error: module `std.math` import `min` not found,
    did you mean function `std.math.sin`?\n/tmp/tmpa9udq0e9.d(44): Error: no property
    `sort` for type `long[]`\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/functional.d-mixin-121(121):
    Error: template lambda has no type\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1164):
    Error: template instance `std.functional.unaryFun!("x => x % 2 == 0", "a").unaryFun!long`
    error instantiating\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):        instantiated
    from here: `FilterResult!(unaryFun, long[])`\n/tmp/tmpa9udq0e9.d(45):        instantiated
    from here: `filter!(long[])`\n/tmp/tmpa9udq0e9.d(45): Error: no property `array`
    for type `FilterResult!(unaryFun, long[])`\n/tmp/tmpa9udq0e9.d(49): Error: template
    `std.algorithm.searching.count` cannot deduce function from argument types `!("y
    => y == x")(long[])`, candidates are:\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/searching.d(633):        `std.algorithm.searching.count(alias
    pred = "a == b", Range, E)(Range haystack, E needle) if (isInputRange!Range &&
    !isInfinite!Range && is(typeof(binaryFun!pred(haystack.front, needle)) : bool))`\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/searching.d(687):        `std.algorithm.searching.count(alias
    pred = "a == b", R1, R2)(R1 haystack, R2 needle) if (isForwardRange!R1 && !isInfinite!R1
    && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front))
    : bool))`\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/d'
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = 10001;\n    long minIdx\
    \ = 0;\n    if (arr.length == 0)\n        return [];\n    foreach (idx, el; arr)\n\
    \    {\n        if (el % 2 == 0 && el < min)\n        {\n            min = el;\n\
    \            minIdx = idx;\n        }\n    }\n    if (min == 10001)\n        return\
    \ [];\n    return [min, minIdx];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = [null, null];\n \
    \   long smallestIndex = null;\n    long smallestValue = null;\n    bool allOdd\
    \ = true;\n    bool noEvens = true;\n    foreach( i, e; arr ) \n    {\n      \
    \  if( e % 2 == 0 )\n        {\n            noEvens = false;\n            if(\
    \ allOdd )\n            {\n                smallestIndex = i;\n              \
    \  smallestValue = e;\n                allOdd = false;\n            }\n      \
    \      else\n            {\n                if( e < smallestValue )\n        \
    \        {\n                    smallestIndex = i;\n                    smallestValue\
    \ = e;\n                }\n            }\n        }\n    }\n    if( noEvens )\n\
    \    {\n        return [];\n    }\n    else\n    {\n        result[0] = smallestValue;\n\
    \        result[1] = smallestIndex;\n        return result;\n    }\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpybc7e750.d(40): Error: cannot implicitly convert expression
    `[null, null]` of type `typeof(null)[]` to `long[]`\n/tmp/tmpybc7e750.d(41): Error:
    cannot implicitly convert expression `null` of type `typeof(null)` to `long`\n/tmp/tmpybc7e750.d(42):
    Error: cannot implicitly convert expression `null` of type `typeof(null)` to `long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpybc7e750.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm;\n    import\
    \ std.stdio;\n    import std.array;\n    import std.conv;\n    auto evArr = arr.filter!(a\
    \ => a % 2 == 0).array;\n    if (evArr.length == 0) return [];\n    auto mi =\
    \ minElement(evArr);\n    auto res = arr.indexOf(mi);\n    // writefln(\"%s\\\
    n\", arr);\n    // writefln(\"%s\\n\", evArr);\n    // writefln(\"%s\\n\", mi);\n\
    \    // writefln(\"%s\\n\", res);\n    return [mi, res];\n}\n \n \n /*\n    \"\
    Given a string representing a DNA sequence,\n    your task is to reverse the string\
    \ representing the complementary strand.\n    The complementary strand follows\
    \ the simple rules:\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpniz3tt5v.d(56): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpniz3tt5v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    size_t pos = 0;\n    long min = -1;\n\
    \    for (;pos < arr.length;++pos) {\n        if (arr[pos] > 0 && arr[pos] % 2\
    \ == 0) {\n            if (min == -1 || arr[pos] < min) {\n                min\
    \ = arr[pos];\n            }\n        }\n    }\n    if (min == -1) {\n       \
    \ return new long[0];\n    }\n    else {\n        return typeof(new long[0]).init[min,\
    \ pos];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp67eedqh7.d(53): Error: only one index allowed to index `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp67eedqh7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int index = -1;\n    long[] smallest\
    \ = typeof(smallest).init;\n    foreach(immutable i, immutable long item; arr)\n\
    \    {\n        if(item % 2 == 0)\n        {\n            if(smallest.length ==\
    \ 0)\n            {\n                index = i;\n                smallest ~= item;\n\
    \            }\n            else if(item < smallest[0])\n            {\n     \
    \           index = i;\n                smallest[0] = item;\n            }\n \
    \       }\n    }\n    if(index != -1)\n    {\n        return [smallest[0], cast(long)index];\n\
    \    }\n    return [0L];\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv9190a58.d(41): Error: undefined identifier `smallest`\n/tmp/tmpv9190a58.d(48):
    Error: cannot implicitly convert expression `i` of type `immutable(ulong)` to
    `int`\n/tmp/tmpv9190a58.d(53): Error: cannot implicitly convert expression `i`
    of type `immutable(ulong)` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpv9190a58.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    struct loc\n    {\n        long index;\n\
    \        long value;\n    }\n    auto result = arr.filter!(e => e % 2 == 0).min(loc(long,\
    \ long));\n    if (result is null)\n        return [];\n    return [result.value,\
    \ result.index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpamvdmxsy.d(45): Error: found `,` when expecting `.` following
    long\n/tmp/tmpamvdmxsy.d(45): Error: found `long` when expecting identifier following
    `long`.\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpamvdmxsy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min_even = 0L;\n    long min_even_idx\
    \ = 0L;\n    bool found_even = false;\n    long i = 0L;\n    foreach(idx, val;\
    \ arr) {\n        if (val % 2 == 0) {\n            if (!found_even) {\n      \
    \          min_even = val;\n                min_even_idx = idx;\n            \
    \    found_even = true;\n            } else {\n                if (val < min_even)\
    \ {\n                    min_even = val;\n                    min_even_idx = idx;\n\
    \                }\n            }\n        }\n    }\n    if (found_even) {\n \
    \       return tuple(min_even, min_even_idx);\n    } else {\n        return tuple(0L,\
    \ 0L);\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxhqye1j4.d(59): Error: cannot implicitly convert expression
    `tuple(min_even, min_even_idx)` of type `Tuple!(long, long)` to `long[]`\n/tmp/tmpxhqye1j4.d(61):
    Error: cannot implicitly convert expression `tuple(0L, 0L)` of type `Tuple!(long,
    long)` to `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhqye1j4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    if (arr.length == 0) \n        return\
    \ new long[](0);\n    \n    long[] small(long[] arr) \n    {\n        long min\
    \ = arr[0];\n        int index = 0;\n        foreach (i, v; arr) \n        {\n\
    \            if (v < min) \n            {\n                min = v;\n        \
    \        index = i;\n            }\n        }\n        return tuple(min, index);\n\
    \    }\n    \n    long[] even(long[] arr) \n    {\n        long[] even = new long[];\n\
    \        foreach (v; arr) \n        {\n            if (v % 2 == 0)\n         \
    \       even ~= v;\n        }\n        return even;\n    }\n    \n    long[] even_arr\
    \ = even(arr);\n    if (even_arr.length == 0)\n        return new long[](0);\n\
    \    \n    return tuple(small(even_arr)[0], small(even_arr)[1]);\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5o5igajo.d(52): Error: cannot implicitly convert expression
    `i` of type `ulong` to `int`\n/tmp/tmp5o5igajo.d(55): Error: cannot implicitly
    convert expression `tuple(min, index)` of type `Tuple!(long, int)` to `long[]`\n/tmp/tmp5o5igajo.d(60):
    Error: new can only create structs, dynamic arrays or class objects, not `long[]`\''s\n/tmp/tmp5o5igajo.d(73):
    Error: cannot implicitly convert expression `tuple(small(even_arr)[0], small(even_arr)[1])`
    of type `Tuple!(long, long)` to `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp5o5igajo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallest = 0L;\n    long smallest_idx\
    \ = 0L;\n    if (arr.empty)\n        return [smallest, smallest_idx];\n    \n\
    \    long smallest_found = arr[0];\n    long smallest_idx_found = 0L;\n    foreach\
    \ (e; arr) \n    {\n        if ((e % 2) == 0 && (e < smallest_found)) \n     \
    \   {\n            smallest_found = e;\n            smallest_idx_found = cast(long)e;\n\
    \        }\n    }\n    if (smallest_found == arr[0]) \n    {\n        if ((arr[0]\
    \ % 2) == 0)\n            return [smallest_found, smallest_idx_found];\n     \
    \   else \n        {\n            foreach (e; arr) \n            {\n         \
    \       if ((e % 2) == 0) \n                {\n                    smallest_found\
    \ = e;\n                    smallest_idx_found = cast(long)e;\n              \
    \      break;\n                }\n            }\n            return [smallest_found,\
    \ smallest_idx_found];\n        }\n    }\n    return [smallest_found, smallest_idx_found];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppvvqry_8.d(42): Error: no property `empty` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppvvqry_8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n  long[] result;\n  foreach(val; arr)\n\
    \  {\n    if(val % 2 == 0)\n    {\n      result = [val, indexOf(arr, val)];\n\
    \      break;\n    }\n  }\n  return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptiibf_0_.d(45): Error: undefined identifier `indexOf`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptiibf_0_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    int arrMin = arr[0];\n    int arrMinIndex = 0;\n    bool isEven\
    \ = false;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ < arrMin && (arr[i] % 2) == 0)\n        {\n            arrMin = arr[i];\n  \
    \          arrMinIndex = i;\n            isEven = true;\n        }\n    }\n  \
    \  if (isEven)\n        return tuple(arrMin, arrMinIndex);\n    else\n       \
    \ return new long[0];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxzkwyl19.d(42): Error: cannot implicitly convert expression
    `arr[0]` of type `long` to `int`\n/tmp/tmpxzkwyl19.d(49): Error: cannot implicitly
    convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmpxzkwyl19.d(55):
    Error: cannot implicitly convert expression `tuple(arrMin, arrMinIndex)` of type
    `Tuple!(int, int)` to `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxzkwyl19.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int idx;\n    long smallest_even_val\
    \ = int.max;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0w2lntq4.d(42): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0w2lntq4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ []();\n    auto min_even = arr[0];\n    long min_index = 0;\n    foreach (const\
    \ i, index; arr)\n    {\n        if (i == 0)\n            continue;\n        if\
    \ (i % 2 == 0 && i < min_even)\n        {\n            min_even = i;\n       \
    \     min_index = index;\n        }\n    }\n    if (min_even % 2 == 0)\n     \
    \   return [min_even, min_index];\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ghn_dnp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    if\
    \ (arr.length == 0) return res;\n    long min = arr[0];\n    foreach (x; arr)\
    \ {\n        if (x < min && x % 2 == 0) min = x;\n    }\n    if (min % 2 != 0)\
    \ return res;\n    res[0] = min;\n    res[1] = arr.indexOf(min);\n    return res;\n\
    }\n/*\n    You are given a number N and a string S. Print all of the possible\
    \ ways to write a string\n    of length N from the characters in string S, comma\
    \ delimited in alphabetical order.\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1t1owkab.d(51): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp1t1owkab.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long[] res = new long[2];\n    long[] minEven = new\
    \ long[1];\n    long[] minEvenIdx = new long[1];\n    minEven[0] = 1000000;\n\
    \    minEvenIdx[0] = 1000000;\n    int i = 0;\n    foreach(val; arr)\n    {\n\
    \        if (val % 2 == 0)\n        {\n            if (val < minEven[0])\n   \
    \         {\n                minEven[0] = val;\n                minEvenIdx[0]\
    \ = i;\n            }\n        }\n        i++;\n    }\n    if (minEven[0] == 1000000)\n\
    \        return new long[0];\n    else\n    {\n        res[0] = minEven[0];\n\
    \        res[1] = minEvenIdx[0];\n        return res;\n    }\n}\n// version 2\n\
    long[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n\
    \    \n    long[] res = new long[2];\n    long[] minEven = new long[1];\n    long[]\
    \ minEvenIdx = new long[1];\n    minEven[0] = 1000000;\n    minEvenIdx[0] = 1000000;\n\
    \    foreach(val; arr)\n    {\n        if (val % 2 == 0)\n        {\n        \
    \    if (val < minEven[0])\n            {\n                minEven[0] = val;\n\
    \                minEvenIdx[0] = i;\n            }\n        }\n    }\n    if (minEven[0]\
    \ == 1000000)\n        return new long[0];\n    else\n    {\n        res[0] =\
    \ minEven[0];\n        res[1] = minEvenIdx[0];\n        return res;\n    }\n}\n\
    // version 3\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n       \
    \ return new long[0];\n    \n    long[] res = new long[2];\n    long[] minEven\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp099o5wdz.d(109): Error: semicolon expected, not \''unittest\''\n/tmp/tmp099o5wdz.d(109):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp099o5wdz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length > 0) \n    {\n   \
    \     long[] res = new long[2];\n        long min_even = 2147483647L;\n      \
    \  int index = 0;\n        foreach (i, v; arr) \n        {\n            if (v\
    \ == 0) \n            {\n                index = i;\n                break;\n\
    \            }\n            if (v % 2 == 0 && v < min_even) \n            {\n\
    \                min_even = v;\n                index = i;\n            }\n  \
    \      }\n        res[0] = min_even;\n        res[1] = index;\n        return\
    \ res;\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe43l3o56.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n\tlong minIndex = -1;\n\tlong minEvenValue\
    \ = -1;\n\tfor (long i = 0; i < arr.length; i++)\n\t{\n\t\tauto nextValue = arr[i];\n\
    \t\tif (nextValue % 2 == 0)\n\t\t{\n\t\t\tif (minEvenValue == -1 || nextValue\
    \ < minEvenValue)\n\t\t\t{\n\t\t\t\tminEvenValue = nextValue;\n\t\t\t\tminIndex\
    \ = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (minIndex == -1)\n\t{\n\t\treturn [];\n\t}\n\
    \treturn [minEvenValue, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3gh7_m0w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    alias Elem = Tuple!(long, long);\n\
    \    long[] oddArr = arr.filter!((long i) => i % 2 != 0);\n    long[] evenArr\
    \ = arr.filter!((long i) => i % 2 == 0);\n    if (evenArr.length == 0) return\
    \ [];\n    long minEven = evenArr.min;\n    long[] minEvenArr = evenArr.filter!((long\
    \ i) => i == minEven);\n    Elem minEvenArrElem = minEvenArr.zip.iota.front;\n\
    \    return [minEvenArrElem[0], minEvenArrElem[1]];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvr2gbrx6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return new long[0];\n    }\n    long[] even = filter!(e => e % 2 == 0)(arr);\n\
    \    if (even.length == 0) \n    {\n        return new long[0];\n    }\n    long\
    \ min = even[0];\n    long min_index = 0;\n    for (size_t i = 1; i < even.length;\
    \ i++) \n    {\n        if (even[i] < min) \n        {\n            min = even[i];\n\
    \            min_index = i;\n        }\n    }\n    return tuple(min, min_index);\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj3owlb20.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int index = -1;\n    long value =\
    \ -1;\n    long[] result = new long[0];\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (value == -1)\n\
    \            {\n                value = arr[i];\n                index = i;\n\
    \            }\n            else if (arr[i] < value)\n            {\n        \
    \        value = arr[i];\n                index = i;\n            }\n        }\n\
    \    }\n    if (index > -1)\n    {\n        result = new long[2];\n        result[0]\
    \ = value;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_jpvvyqa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    size_t i = 0;\n    long min = arr[0];\n    size_t min_pos\
    \ = 0;\n    while (i < arr.length) \n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < min) \n        {\n            min = arr[i];\n            min_pos = i;\n  \
    \      }\n        i++;\n    }\n    if (min == arr[0])\n        return new long[0];\n\
    \    return tuple(min, min_pos);\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqe36rzrp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto evens = std.filter!(e => (e\
    \ & 1) == 0)(arr);\n    if (evens.empty) \n        return [];\n    auto min =\
    \ std.min(evens);\n    auto minIndex = std.find(arr, min);\n    return [min, minIndex];\n\
    }\n/*\n \n void main() {\n     assert(pluck([4L, 2L, 3L]) == [2L, 1L]);\n    \
    \ assert(pluck([1L, 2L, 3L]) == [2L, 1L]);\n     assert(pluck([]) == []);\n  \
    \   assert(pluck([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n }\n \n */\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27rzwbl9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int smallIdx = 0;\n    long small\
    \ = 0;\n    int pos = 0;\n    int start = 0;\n    int[] ids = new int[2];\n  \
    \  /*This is not efficient*/\n    /*\n    foreach(i;arr)\n    {\n        if(isEven(i))\n\
    \        {\n            if(i<small)\n            {\n                small = i;\n\
    \                smallIdx = pos;\n            }\n        }\n        pos++;\n \
    \   }\n    */\n    /*But this is*/\n    // ids[1] = arr.length;\n    for(i;arr)\n\
    \    {\n        if(isEven(i))\n        {\n            ids[0] = i;\n          \
    \  ids[1] = start;\n            return ids;\n        }\n        start++;\n   \
    \ }\n    return ids;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxx1ocmc4.d(62): Error: found \'')\'' when expecting \'';\''
    following for condition\n/tmp/tmpxx1ocmc4.d(72): Error: found \''return\'' when
    expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxx1ocmc4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm.sorting : sort;\n\
    \    int minIdx = 0;\n    long minVal = 0;\n    bool hasEven = false;\n    if\
    \ (arr.empty)\n        return [ minVal, minIdx ];\n    else\n    {\n        int\
    \ i = 0;\n        foreach (val; arr)\n        {\n            if (val%2 == 0)\n\
    \            {\n                if (!hasEven)\n                {\n           \
    \         minVal = val;\n                    minIdx = i;\n                   \
    \ hasEven = true;\n                }\n                else\n                {\n\
    \                    if (val < minVal)\n                    {\n              \
    \          minVal = val;\n                        minIdx = i;\n              \
    \      }\n                }\n            }\n            i++;\n        }\n    \
    \    if (hasEven)\n            return [ minVal, minIdx ];\n        else\n    \
    \        return [ minVal, minIdx ];\n    }\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpglp5sjfp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int n = arr.length;\n    if (n ==\
    \ 0) return [0L, 0L];\n    long minEven = long.max;\n    int minIndex = -1;\n\
    \    foreach (i, ref e; arr) \n    {\n        if (e % 2 == 0 && e < minEven) \n\
    \        {\n            minEven = e;\n            minIndex = i;\n        }\n \
    \   }\n    if (minIndex == -1) return [0L, 0L];\n    return [minEven, minIndex];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttkfw8mn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  if (arr.length == 0)\n        return result;\n    \n    bool[] is_even = new\
    \ bool[arr.length];\n    foreach (i, a; arr)\n    {\n        if (a % 2 == 0)\n\
    \            is_even[i] = true;\n    }\n    \n    if (is_even.count(true) == 0)\n\
    \        return result;\n    \n    int min_value = min(arr.retro.filter!(i =>\
    \ is_even[i]).take(is_even.count(true)));\n    foreach (i, a; arr)\n    {\n  \
    \      if (a == min_value)\n        {\n            result[0] = a;\n          \
    \  result[1] = i;\n            break;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2k2vm1rg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long[] temp = new long[2];\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7103_0dj.d(41): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7103_0dj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n  long[] res = {};\n  if(arr.length\
    \ == 0) return res;\n  immutable(long) min = min(arr.filter!(x => x % 2 == 0));\n\
    \  res ~= min;\n  res ~= arr.indexOf(min);\n  return res;\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbyf3npz0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    //long arr = new long[];\n    int\
    \ index;\n    int minimum = arr[0];\n    long minimumIndex = 0;\n    long[] ans\
    \ = new long[2];\n    for(int i = 0; i < arr.length; i++)\n    {\n        if(arr[i]\
    \ % 2 == 0)\n        {\n            index = i;\n            if(arr[i] < minimum)\n\
    \            {\n                minimum = arr[i];\n                minimumIndex\
    \ = i;\n            }\n        }\n    }\n    if(minimum % 2 == 0)\n    {\n   \
    \     ans[0] = minimum;\n        ans[1] = minimumIndex;\n    }\n    return ans;\n\
    }\n// pluck([4L, 2L, 3L])\n// pluck([1L, 2L, 3L])\n// pluck([])\n// pluck([5L,\
    \ 0L, 3L, 0L, 4L, 2L])\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps68ksz78.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minValue = min(arr);\n    if(minValue\
    \ & 1)\n        return new long[0];\n    size_t minIndex = 0;\n    for(size_t\
    \ i = 0; i < arr.length; i++)\n    {\n        if(arr[i] == minValue)\n       \
    \ {\n            minIndex = i;\n            break;\n        }\n    }\n    return\
    \ tuple(minValue, minIndex);\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps1bbo4uy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    enum PluckResult { FAIL, PASS(long\
    \ smallestIndex, long smallestValue) }\n    // The longest branch has a length\
    \ of 10000.\n    static PluckResult[10000] dp = void;\n    static int maxLength\
    \ = 0;\n    static int nodeCount = 0;\n    static long[10000] values = void;\n\
    \    static int[10000] indices = void;\n    static bool[10000] even = void;\n\
    \    static int[] lengths = void;\n    static int[] branched = void;\n    static\
    \ int[] branches = void;\n    static int[] first = void;\n    static int[] last\
    \ = void;\n    static if (arr.length == 0)\n    {\n        return [0L, 0L];\n\
    \    }\n    static assert(arr.length <= 10000);\n    static foreach (i, value;\
    \ arr)\n    {\n        assert(value >= 0);\n        values[i] = value;\n     \
    \   indices[i] = i;\n        even[i] = value % 2 == 0;\n    }\n    void recursive(int\
    \ i, int length) {\n        nodeCount++;\n        lengths[i] = length;\n     \
    \   if (length > maxLength)\n        {\n            maxLength = length;\n    \
    \    }\n        if (i + 1 < arr.length && arr[i] < arr[i + 1])\n        {\n  \
    \          if (branched[i] == 0)\n            {\n                branches[i] =\
    \ i + 1;\n                first[i] = i + 1;\n                last[i] = i + 1;\n\
    \            }\n            else\n            {\n                last[i] = i +\
    \ 1;\n            }\n            branched[i]++;\n            recursive(i + 1,\
    \ length + 1);\n        }\n        if (i + 2 < arr.length && arr[i] < arr[i +\
    \ 2])\n        {\n            if (branched[i] == 0)\n            {\n         \
    \       branches[i] = i + 2;\n                first[i] = i + 2;\n            \
    \    last[i] = i + 2;\n            }\n            else\n            {\n      \
    \          last[i] = i + 2;\n            }\n           \nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbnwmg2qa.d(40): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmpbnwmg2qa.d(40):
    Error: type only allowed if anonymous enum and no enum type\n/tmp/tmpbnwmg2qa.d(40):
    Error: if type, there must be an initializer\n/tmp/tmpbnwmg2qa.d(58): Error: basic
    type expected, not foreach\n/tmp/tmpbnwmg2qa.d(58): Error: no identifier for declarator
    int\n/tmp/tmpbnwmg2qa.d(100): Error: found \''unittest\'' instead of statement\n/tmp/tmpbnwmg2qa.d(113):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpbnwmg2qa.d(113):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbnwmg2qa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    long[] ret = [arr[0], 0];\n    for (long i = 1; i < arr.length; i++)\n\
    \    {\n        if (arr[i] & 1)\n            continue;\n        if (arr[i] < ret[0])\n\
    \            ret = [arr[i], i];\n    }\n    if (ret[0] & 1)\n        return [];\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_lz0e59g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = [ 0L, 0L ];\n   \
    \ bool isFirst = true;\n    int i = 0;\n    foreach(elem; arr)\n    {\n      \
    \  if(elem % 2 == 0)\n        {\n            if(isFirst)\n            {\n    \
    \            result[0] = elem;\n                result[1] = i;\n             \
    \   isFirst = false;\n            }\n            else\n            {\n       \
    \         if(elem < result[0])\n                {\n                    result[0]\
    \ = elem;\n                    result[1] = i;\n                }\n           \
    \ }\n        }\n        i++;\n    }\n    return result;\n}\n/*\n    version 2\n\
    */\nlong[] pluck2(long[] arr) \n{\n    long[] result = [ 0L, 0L ];\n    bool isFirst\
    \ = true;\n    int i = 0;\n    foreach(elem; arr)\n    {\n        if(elem % 2\
    \ == 0)\n        {\n            if(isFirst)\n            {\n                result[0]\
    \ = elem;\n                result[1] = i;\n                isFirst = false;\n\
    \            }\n            else\n            {\n                if(elem < result[0])\n\
    \                {\n                    result[0] = elem;\n                  \
    \  result[1] = i;\n                }\n            }\n        }\n        i++;\n\
    \    }\n    return result;\n}\n/*\n    version 3\n*/\nlong[] pluck3(long[] arr)\
    \ \n{\n    long[] result = [ 0L, 0L ];\n    bool isFirst = true;\n    int i =\
    \ 0;\n    foreach(elem; arr)\n    {\n        if(elem % 2 == 0)\n        {\n  \
    \          if(isFirst)\n            {\n                result[0] = elem;\n   \
    \             result[1] = i;\n                isFirst = false;\n            }\n\
    \            else\n            {\n                if(elem < result[0])\n     \
    \           {\n                    result[0] = elem;\n                    result[1]\
    \ = i;\n                }\n            }\n        }\n        i++;\n    }\n   \
    \ return result;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppy6v7xmw.d(127): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppy6v7xmw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.array;\n    long[] treeNodes=arr.filter!(a=>a%2==0).sort.dup;\n\
    \    if(treeNodes.length==0) return [];\n    else \n    {\n        long smallest=treeNodes[0];\n\
    \        foreach(i,node; arr)\n        {\n            if(node==smallest)\n   \
    \         {\n                long[] res=[node,i];\n                return res;\n\
    \            }\n        }\n    }\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_xymmela.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = int.max;\n    long index\
    \ = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] %\
    \ 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if (min == int.max)\n    {\n        return [];\n\
    \    }\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptm15bxit.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long min = arr[0];\n    int index = 0;\n    bool found = false;\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n\
    \        {\n            found = true;\n            if (arr[i] < min)\n       \
    \     {\n                min = arr[i];\n                index = i;\n         \
    \   }\n        }\n    }\n    if (found)\n        return [min, index];\n    else\n\
    \        return new long[0];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcr0xxi_j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length==0) return new long[0];\n\
    \    long smallestIndex=0;\n    long smallestEven=arr[0];\n    for (size_t i=0;\
    \ i<arr.length; i++)\n    {\n        if (arr[i]%2==0)\n        {\n           \
    \ if (arr[i]<smallestEven)\n            {\n                smallestEven=arr[i];\n\
    \                smallestIndex=i;\n            }\n        }\n    }\n    if (smallestEven==arr[0])\
    \ return new long[0];\n    return [smallestEven, smallestIndex];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpydd_0ere.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    int\
    \ min = int.max;\n    int minIndex = int.max;\n    int count = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n\
    \            if (arr[i] < min)\n            {\n                min = arr[i];\n\
    \                minIndex = i;\n            }\n            count++;\n        }\n\
    \    }\n    res[0] = min;\n    res[1] = minIndex;\n    if (count == 0)\n    {\n\
    \        res[0] = 0;\n        res[1] = 0;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaim7uhgd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] ret = new long[2];\n    long\
    \ min_even = long.max;\n    long min_idx = long.max;\n    if (arr.length == 0)\
    \ return ret;\n    foreach (idx,val; arr)\n    {\n        if (val % 2 == 0)\n\
    \        {\n            if (val < min_even)\n            {\n                min_even\
    \ = val;\n                min_idx = idx;\n            }\n        }\n    }\n  \
    \  if (min_even == long.max)\n    {\n        return ret;\n    }\n    ret[0] =\
    \ min_even;\n    ret[1] = min_idx;\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpluh6ftk0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long smallest = long.max;\n    long index = long.max;\n  \
    \  for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 &&\
    \ arr[i] < smallest)\n        {\n            smallest = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if (smallest == long.max)\n        return new long[0];\n\
    \    return [smallest, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0txwu3sj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [];\n\
    \    foreach (i, item; arr)\n    {\n        if (item % 2 == 0) return [item, i];\n\
    \    }\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmponolc7et.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n  long min =  long.max;\n  long min_idx\
    \ = long.max;\n  foreach(idx, el; arr)\n  {\n    if(el > 0 && el % 2 == 0 && el\
    \ < min)\n    {\n      min = el;\n      min_idx = idx;\n    }\n  }\n  if(min !=\
    \ long.max)\n  {\n    return [min, min_idx];\n  }\n  return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_yumdlj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    foreach(d; 0 .. arr.length)\n   \
    \ {\n        if(arr[d] % 2 == 0)\n        {\n            return typeof(long[])([arr[d],\
    \ d]);\n        }\n    }\n    return typeof(long[])();\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj_xrn851.d(44): Error: found \''[\'' when expecting \''.\''
    following long\n/tmp/tmpj_xrn851.d(44): Error: found \'']\'' when expecting identifier
    following \''long.\''\n/tmp/tmpj_xrn851.d(47): Error: found \''[\'' when expecting
    \''.\'' following long\n/tmp/tmpj_xrn851.d(47): Error: found \'']\'' when expecting
    identifier following \''long.\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj_xrn851.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] ret = {};\n    foreach(idx,\
    \ el; arr)\n    {\n        if(el % 2 == 0)\n        {\n            if(ret.length\
    \ == 0)\n            {\n                ret = [el, idx];\n            }\n    \
    \        else if(el < ret[0])\n            {\n                ret = [el, idx];\n\
    \            }\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0f6itxcq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [];\n\
    \    auto result = tuple(arr[0], 0L);\n    foreach (i, v; arr) \n    {\n     \
    \   if (v % 2 == 0 && result[0] % 2 == 0) \n        {\n            if (v < result[0])\
    \ \n            {\n                result = tuple(v, i);\n            }\n    \
    \    } \n        else if (v % 2 == 0 && result[0] % 2 != 0) \n        {\n    \
    \        result = tuple(v, i);\n        }\n    }\n    if (result[0] % 2 != 0)\
    \ return [];\n    return [result[0], result[1]];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_a9m_24s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm.comparison :\
    \ min;\n    import std.typecons : tuple;\n    if(arr.length == 0)\n        return\
    \ [];\n    auto min_even = tuple(arr[0], 0);\n    foreach(immutable i, element;\
    \ arr)\n    {\n        if(element % 2 == 0)\n        {\n            min_even =\
    \ min(min_even, tuple(element, i));\n        }\n    }\n    return [min_even[0],\
    \ min_even[1]];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzwwql1u8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    bool is_empty(long[] arr) @property\
    \ { return arr.length == 0; }\n    long[] get_smallest_even(long[] arr) @property\
    \ \n    {\n        immutable result = [];\n        immutable index = -1;\n   \
    \     foreach(immutable i, immutable val; arr)\n        {\n            if(val\
    \ % 2 == 0)\n            {\n                if(result.length == 0) \n        \
    \        {\n                    result ~= val;\n                    index = i;\n\
    \                }\n                else if(val < result[0])\n               \
    \ {\n                    result[0] = val;\n                    index = i;\n  \
    \              }\n            }\n        }\n        if(result.length == 0) return\
    \ [];\n        return [result[0], index];\n    }\n    immutable res = get_smallest_even(arr);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp49nvai7y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long index = -1;\n    long ret =\
    \ 10_000_000;\n    foreach(i, v; arr)\n    {\n        if (v % 2 == 0 && v < ret)\n\
    \        {\n            ret = v;\n            index = i;\n        }\n    }\n \
    \   if (index == -1) return typeof(ret).init;\n    return [ret, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbeml2my9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestEven = long.max;\n \
    \   long smallestIndex = long.max;\n    size_t index = 0;\n    bool hasEven =\
    \ false;\n    foreach(value; arr)\n    {\n        if(value % 2 == 0)\n       \
    \ {\n            hasEven = true;\n            if(value < smallestEven)\n     \
    \       {\n                smallestEven = value;\n                smallestIndex\
    \ = index;\n            }\n        }\n        index++;\n    }\n    if(hasEven)\n\
    \    {\n        return tuple(smallestEven, smallestIndex);\n    }\n    else\n\
    \    {\n        return tuple();\n    }\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqb5j9_bi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    struct Node\n    {\n        long\
    \ value;\n        size_t index;\n    }\n    const(long) arr2 = arr;\n    immutable\
    \ nodes = std.typecons.tuple(map!(a => Node(a, i))(arr2, 0 .. arr2.length));\n\
    \    auto least = min(filter!(a => a.value % 2 == 0)(nodes));\n    if (least)\n\
    \        return [least.value, least.index];\n    return [];\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw7zp00x3.d(46): Error: found \''..\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7zp00x3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // check length is greater than zero\n\
    \    if (arr.length > 0)\n    {\n        size_t[] indices = ();\n        long\
    \ minimum = -1;\n        long index = -1;\n        // find smallest even value\n\
    \        for (size_t i = 0; i < arr.length; i++)\n        {\n            if (arr[i]\
    \ % 2 == 0)\n            {\n                if (minimum == -1)\n             \
    \   {\n                    minimum = arr[i];\n                    index = i;\n\
    \                }\n                else if (arr[i] < minimum)\n             \
    \   {\n                    minimum = arr[i];\n                    index = i;\n\
    \                }\n            }\n        }\n        // If no even values\n \
    \       if (minimum == -1)\n        {\n            return [];\n        }\n   \
    \     // If multiple values are smallest, return lowest index\n        if (arr.count!(minimum).length\
    \ > 1)\n        {\n            indices = arr.indicesOf!(minimum);\n          \
    \  index = indices[0];\n        }\n        return [minimum, index];\n    }\n \
    \   else\n    {\n        return [];\n    }\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu9hqwc86.d(43): Error: expression expected, not \'')\''\n/tmp/tmpu9hqwc86.d(43):
    Error: found \'';\'' when expecting \'')\''\n/tmp/tmpu9hqwc86.d(44): Error: semicolon
    expected, not \''long\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu9hqwc86.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min_even_value = cast(long)\
    \ ulong.max;\n    long min_even_value_idx = -1;\n    foreach(i, value; arr)\n\
    \    {\n        if(value % 2 == 0 && value < min_even_value)\n        {\n    \
    \        min_even_value = value;\n            min_even_value_idx = i;\n      \
    \  }\n    }\n    if(min_even_value_idx == -1)\n        return [];\n    return\
    \ [min_even_value, min_even_value_idx];\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo2mq6zz9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    else\n    {\n        long[] r = new long[2];\n        long\
    \ smallestEvenValue = 2;\n        long smallestEvenValueIndex = -1;\n        long\
    \ currentNodeValue;\n        for (long i = 0; i < arr.length; i++)\n        {\n\
    \            currentNodeValue = arr[i];\n            if (currentNodeValue % 2\
    \ == 0)\n            {\n                if (currentNodeValue < smallestEvenValue)\n\
    \                {\n                    smallestEvenValue = currentNodeValue;\n\
    \                    smallestEvenValueIndex = i;\n                }\n        \
    \    }\n        }\n        if (smallestEvenValueIndex == -1)\n            return\
    \ new long[0];\n        else\n        {\n            r[0] = smallestEvenValue;\n\
    \            r[1] = smallestEvenValueIndex;\n            return r;\n        }\n\
    \    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9os98uz3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\n    auto result = tuple(long.max, long.max);\n    for\
    \ (i, elem; arr.length > i; ++i) \n    {\n        if (elem % 2 == 0 && elem <\
    \ result[0]) \n        {\n            result = tuple(elem, i);\n        }\n  \
    \  }\n    if (result[0] == long.max) \n    {\n        return [];\n    }\n    return\
    \ [result[0], result[1]];\n}\nunittest\n{\n    alias candidate = pluck;\n\n  \
    \  assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq9qrb0xk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long[] even = new long[arr.length];\n    int x = 0;\n    for\
    \ (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n    \
    \    {\n            even[x] = arr[i];\n            x++;\n        }\n    }\n  \
    \  if (x == 0)\n        return new long[0];\n    long[] even2 = new long[x];\n\
    \    for (int j = 0; j < x; j++)\n    {\n        even2[j] = even[j];\n    }\n\
    \    long min = min(even2);\n    long[] res = new long[2];\n    res[0] = min;\n\
    \    for (int k = 0; k < arr.length; k++)\n    {\n        if (arr[k] == min)\n\
    \        {\n            res[1] = k;\n            break;\n        }\n    }\n  \
    \  return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph7wfg5fq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // Create the first element in the\
    \ returned tuple.\n    long[] smallest = tuple(arr[0], 0);\n    // Loop through\
    \ the array\n    foreach(l; arr) \n    {\n        // Is this element even and\
    \ less than the value in the tuple?\n        if(l % 2 == 0 && l < smallest[0])\
    \ \n        {\n            // Yes, replace the tuple element with the current\
    \ value.\n            smallest[0] = l;\n        }\n    }\n    // If the tuple\
    \ element is the same as the first element in the array, we have not found any\
    \ even numbers.\n    return arr[0] == smallest[0] ? [] : smallest;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpukdnxqhs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n  if (arr.length == 0)\n    return new\
    \ long[0];\n  \n  auto r = arr.filter!(x => x % 2 == 0);\n  if (r.length == 0)\n\
    \    return new long[0];\n  \n  // sort r, then return the first two elements\n\
    \  r.sort;\n  auto i = arr.indexOf(r[0]);\n  return new long[](r[0], i);\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp53rdj412.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // 1. find the first even number\n\
    \    // 2. if there is no even number, return empty array\n    // 3. else return\
    \ the first element with the smallest even number\n    // 4. since we are not\
    \ allowed to use library functions\n    //    we will have to implement a function\
    \ to get the index of the minimum element\n    // 5. the implementation of get_index_of_min()\
    \ can be found at the end of this file\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyvmh0dfj.d(46): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyvmh0dfj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    /*\n        Since there is no requirement\
    \ to sort the array, I will use a greedy algorithm \n        to find the first\
    \ smallest even number.\n        I will use a temporary array with size of 5 to\
    \ reduce the access time, this array will\n        will be allocated when first\
    \ needed, and it will be used to store the smallest even number\n        and its\
    \ index.\n        The temporary array will have the following structure:\n   \
    \     [\n            smallest_even_number, // at index 0\n            index_of_smallest_even_number,\
    \ // at index 1\n            smallest_odd_number, // at index 2\n            index_of_smallest_odd_number,\
    \ // at index 3\n            count_of_even_numbers // at index 4\n        ]\n\
    \    */\n    long[] tmp = new long[5];\n    // initialize the temporary array\
    \ with large numbers\n    tmp[0] = 10000L;\n    tmp[1] = 10000L;\n    tmp[2] =\
    \ 10000L;\n    tmp[3] = 10000L;\n    tmp[4] = 0L;\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf11jepxm.d(62): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf11jepxm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = [long.max, 0L];\n  \
    \  auto max = res[0];\n    int index = 0;\n    auto even = filter!((x) => x %\
    \ 2 == 0)(arr);\n    foreach(i, x; even)\n    {\n        if(x < max)\n       \
    \ {\n            max = x;\n            index = i;\n        }\n    }\n    if(max\
    \ != long.max)\n    {\n        res[0] = max;\n        res[1] = index;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmokkrnjk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto min(long.max);\n    bool hasEven\
    \ = false;\n    int counter = -1;\n    foreach(element; arr)\n    {\n        counter++;\n\
    \        if(element % 2 == 0)\n        {\n            hasEven = true;\n      \
    \      if(element < min)\n            {\n                min = element;\n    \
    \        }\n        }\n    }\n    if(hasEven)\n    {\n        return [min, arr.indexOf(min)];\n\
    \    }\n    else\n    {\n        return [];\n    }\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfy99bf3c.d(40): Error: unexpected ( in declarator\n/tmp/tmpfy99bf3c.d(40):
    Error: found \''.\'' when expecting \'')\''\n/tmp/tmpfy99bf3c.d(40): Error: no
    identifier for declarator min(long)\n/tmp/tmpfy99bf3c.d(40): Error: semicolon
    expected following function declaration\n/tmp/tmpfy99bf3c.d(40): Error: found
    \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpfy99bf3c.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // TODO\n    return null;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4asfiadc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long[] res = [0L, 0L]; \n    long\
    \ val = 0;\n    foreach(idx, val; arr)\n    {\n        if(val % 2 == 0)\n    \
    \    {\n            res[0] = val;\n            res[1] = idx;\n            break;\n\
    \        }\n    }\n    foreach(idx, val; arr)\n    {\n        if(val % 2 == 0\
    \ && val < res[0])\n        {\n            res[0] = val;\n            res[1] =\
    \ idx;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvevd8_mt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ long[].init;\n    immutable long[] even = arr.filter!(x => x % 2 == 0);\n  \
    \  if (even.length == 0)\n        return long[].init;\n    return [even.front,\
    \ arr.findIndex!(x => x == even.front)];\n}\n/*\nimport std.algorithm;\nimport\
    \ std.array;\nimport std.conv;\nimport std.range;\nimport std.stdio;\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9are6ac1.d(41): Error: found \''[\'' when expecting \''.\''
    following long\n/tmp/tmp9are6ac1.d(41): Error: found \'']\'' when expecting identifier
    following \''long.\''\n/tmp/tmp9are6ac1.d(44): Error: found \''[\'' when expecting
    \''.\'' following long\n/tmp/tmp9are6ac1.d(44): Error: found \'']\'' when expecting
    identifier following \''long.\''\n/tmp/tmp9are6ac1.d(47): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9are6ac1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto evens = arr.filter!(x => x %\
    \ 2 == 0).sort().uniq;\n    if (evens.length < 1)\n        return [];\n    return\
    \ [evens[0], arr.indexOf(evens[0])];\n}\n// http://ideone.com/rvkxj7\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptjjhkdld.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] plucked = [];\n    long i;\n\
    \    foreach(element; arr)\n    {\n        if(element % 2 == 0)\n        {\n \
    \           plucked ~= element;\n        }\n    }\n    long lowestValue = min(plucked);\n\
    \    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] == lowestValue)\n\
    \        {\n            plucked = [lowestValue, i];\n            break;\n    \
    \    }\n    }\n    return plucked;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8k1_hv21.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[0];\n    long\
    \ min_index = long.max;\n    long min_value = long.max;\n    foreach(index, value;\
    \ arr)\n    {\n        if (value % 2 == 0)\n        {\n            if (value <\
    \ min_value)\n            {\n                min_value = value;\n            \
    \    min_index = index;\n            }\n        }\n    }\n    if (min_value !=\
    \ long.max)\n    {\n        res = [min_value, min_index];\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxm7ttfqb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return typeof(arr).init;\n\
    \    auto min = arr[0];\n    foreach (i, e; arr) {\n        if (e < min) min =\
    \ e;\n    }\n    long mineven;\n    foreach (i, e; arr) {\n        if (e == min)\
    \ {\n            if (e % 2 == 0) {\n                mineven = i;\n           \
    \     break;\n            }\n        }\n    }\n    if (arr[0] % 2 == 0) {\n  \
    \      return [min, mineven];\n    }\n    return typeof(arr).init;\n}\n/*\n===\
    \ OK ===\nTest: [0L, 3L, 0L, 0L, 0L, 5L, 7L, 6L, 2L, 1L, 0L, 1L, 2L, 5L, 7L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 1L, 4L, 5L, 2L, 1L, 4L, 1L, 4L, 4L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 2L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 2L, 8L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp3ui1b2l.d(59): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpp3ui1b2l.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // Check if the array is empty\n\
    \    if (arr.length == 0) return new long[0];\n    \n    // Remove all non-even\
    \ values from the given array\n    long[] evens = removeIf!(a => a & 1)(arr);\n\
    \    \n    // Check if the array still has values\n    if (evens.length == 0)\
    \ return new long[0];\n    \n    // Find the minimum value\n    long min = min(evens);\n\
    \    \n    // Find the index of the minimum value and return it as part of an\
    \ array\n    return [min, indexOf(evens, min)];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcoxezmrw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    if\
    \ (arr.length > 0)\n    {\n        long minEven = int.max;\n        long minIndex\
    \ = int.max;\n        for (int i = 0; i < arr.length; i++)\n        {\n      \
    \      if (arr[i] % 2 == 0 && arr[i] < minEven)\n            {\n             \
    \   minEven = arr[i];\n                minIndex = i;\n            }\n        }\n\
    \        if (minEven != int.max)\n        {\n            res[0] = minEven;\n \
    \           res[1] = minIndex;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphjx56qvv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[];\n    auto min = new long[2];\n    min[0] = 10000L;\n    foreach\
    \ (a;arr) \n    {\n        if (a > 0 && a % 2 == 0 && a < min[0]) \n        {\n\
    \            min[0] = a;\n            min[1] = cast(long)arr.indexOf(a);\n   \
    \     }\n    }\n    if (min[0] != 10000L)\n        return min;\n    return new\
    \ long[];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvs6gslf3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long minEven = -1;\n    int minEvenIndex = -1;\n   \
    \ foreach (i, e; arr)\n    {\n        if (e % 2 == 0)\n        {\n           \
    \ if (minEven == -1 || e < minEven)\n            {\n                minEven =\
    \ e;\n                minEvenIndex = i;\n            }\n        }\n    }\n   \
    \ \n    if (minEvenIndex == -1)\n        return new long[0];\n    \n    return\
    \ new long[](minEven, minEvenIndex);\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnhya7hgq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] pr = new long[2];\n    long\
    \ m = (long.max)();\n    int s = arr.length;\n    for (int i = 0; i < s; i++)\n\
    \    {\n        if (arr[i] < m && arr[i] % 2 == 0)\n        {\n            m =\
    \ arr[i];\n            pr[0] = m;\n            pr[1] = i;\n        }\n    }\n\
    \    if (pr[0] != (long.max)()) return pr;\n    return new long[0];\n}\nlong[]\
    \ pluck(long[] arr) \n{\n    long[] pr = new long[2];\n    long m = (long.max)();\n\
    \    int s = arr.length;\n    for (int i = 0; i < s; i++)\n    {\n        if (arr[i]\
    \ < m && arr[i] % 2 == 0)\n        {\n            m = arr[i];\n            pr[0]\
    \ = m;\n            pr[1] = i;\n        }\n    }\n    if (pr[0] != (long.max)())\
    \ return pr;\n    return new long[0];\n}\nlong[] pluck(long[] arr) \n{\n    long[]\
    \ pr = new long[2];\n    long m = (long.max)();\n    int s = arr.length;\n   \
    \ for (int i = 0; i < s; i++)\n    {\n        if (arr[i] < m && arr[i] % 2 ==\
    \ 0)\n        {\n            m = arr[i];\n            pr[0] = m;\n           \
    \ pr[1] = i;\n        }\n    }\n    if (pr[0] != (long.max)()) return pr;\n  \
    \  return new long[0];\n}\nlong[] pluck(long[] arr) \n{\n    long[] pr = new long[2];\n\
    \    long m = (long.max)();\n    int s = arr.length;\n    for (int i = 0; i <\
    \ s; i++)\n    {\n        if (arr[i] < m && arr[i] % 2 == 0)\n        {\n    \
    \        m\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvsrcskq1.d(99): Error: found \''unittest\'' when expecting \'';\''
    following statement\n/tmp/tmpvsrcskq1.d(112): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmpvsrcskq1.d(112): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpvsrcskq1.d(112):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvsrcskq1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minVal = -1;\n    long minIndex\
    \ = -1;\n    long currentVal = -1;\n    long currentIndex = -1;\n    bool hasEvenNumber\
    \ = false;\n    foreach(idx, ref element; arr)\n    {\n        currentVal = element;\n\
    \        currentIndex = idx;\n        if(currentVal % 2 == 0)\n        {\n   \
    \         hasEvenNumber = true;\n            if(minVal == -1 || currentVal < minVal)\n\
    \            {\n                minVal = currentVal;\n                minIndex\
    \ = currentIndex;\n            }\n        }\n    }\n    if(hasEvenNumber)\n  \
    \  {\n        return [minVal, minIndex];\n    }\n    else\n    {\n        return\
    \ [];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8ui4a4f.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpchoc6b6o.d(44): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchoc6b6o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    long min = 2147483647;\n    long min_index = -1;\n    for (int i = 0; i <\
    \ arr.length; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min) {\n       \
    \     min = arr[i];\n            min_index = i;\n        }\n    }\n    if (min_index\
    \ == -1) return new long[0];\n    return new long[] { min, min_index };\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkou7dqcn.d(50): Error: found \''{\'' when expecting \'';\''
    following return statement\n/tmp/tmpkou7dqcn.d(50): Error: found \''}\'' when
    expecting \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpkou7dqcn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long[] ret = new long[2];\n    long min_even = arr[0];\n\
    \    long min_even_idx = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] < min_even && arr[i] % 2 == 0)\n        {\n            min_even\
    \ = arr[i];\n            min_even_idx = i;\n        }\n    }\n    if (min_even\
    \ % 2 == 0)\n    {\n        ret[0] = min_even;\n        ret[1] = min_even_idx;\n\
    \    }\n    return ret;\n}\n// BEGIN: Test Code\npublic class Test\n{\n    public\
    \ static void main(String[] args)\n    {\n        Test t = new Test();\n     \
    \   t.test();\n    }\n    public void test()\n    {\n        assert(arrayEq(pluck(new\
    \ long[]{4L, 2L, 3L}), new long[]{2L, 1L}));\n        assert(arrayEq(pluck(new\
    \ long[]{1L, 2L, 3L}), new long[]{2L, 1L}));\n        assert(arrayEq(pluck(new\
    \ long[]{}), new long[]{}));\n        assert(arrayEq(pluck(new long[]{5L, 0L,\
    \ 3L, 0L, 4L, 2L}), new long[]{0L, 1L}));\n    }\n    public boolean arrayEq(long[]\
    \ arr1, long[] arr2)\n    {\n        if (arr1.length != arr2.length)\n       \
    \     return false;\n        for (long i = 0; i < arr1.length; i++)\n        {\n\
    \            if (arr1[i] != arr2[i])\n                return false;\n        }\n\
    \        return true;\n    }\n}\n// END: Test Code\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvbmjfzw8.d(71): Error: found \''{\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(71):
    Error: found \''}\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(71): Error: found
    \''{\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(71): Error: found \''}\'' when
    expecting \'',\''\n/tmp/tmpvbmjfzw8.d(72): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmpvbmjfzw8.d(72): Error: found \''}\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(72):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(72): Error: found
    \''}\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(73): Error: found \''{\'' when
    expecting \'',\''\n/tmp/tmpvbmjfzw8.d(73): Error: expression expected, not \''}\''\n/tmp/tmpvbmjfzw8.d(73):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(73): Error: expression
    expected, not \''}\''\n/tmp/tmpvbmjfzw8.d(74): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmpvbmjfzw8.d(74): Error: found \''}\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(74):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpvbmjfzw8.d(74): Error: found
    \''}\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvbmjfzw8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto temp = [0L, 0L];\n    if(empty(arr))\n\
    \        return [];\n    foreach(i, val; arr)\n    {\n        if(val % 2 == 0\
    \ && val < temp[0])\n        {\n            temp[0] = val;\n            temp[1]\
    \ = i;\n        }\n    }\n    if(temp[0] == 0)\n        return [];\n    return\
    \ temp;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp45j2ip_r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long evenMin = long.max;\n    long\
    \ evenIndex = -1;\n    foreach(e; arr)\n    {\n        if(isEven(e) && e < evenMin)\n\
    \        {\n            evenMin = e;\n            evenIndex = index(arr, e);\n\
    \        }\n    }\n    return evenIndex != -1 ? [evenMin, evenIndex] : [];\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25tq1aew.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    if (arr.length == 0)\n        return\
    \ arr;\n    \n    long min_value = long.max;\n    long min_index = long.max;\n\
    \    long even_value = long.max;\n    long even_index = long.max;\n    \n    foreach(int\
    \ i, long value; arr)\n    {\n        if (value < min_value)\n        {\n    \
    \        min_value = value;\n            min_index = i;\n        }\n        if\
    \ (value % 2 == 0 && value < even_value)\n        {\n            even_value =\
    \ value;\n            even_index = i;\n        }\n    }\n    \n    return even_value\
    \ < long.max ? [even_value, even_index] : [min_value, min_index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gc2zss2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [].init;\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsal2zigb.d(41): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsal2zigb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = [], small=[];\n    int\
    \ n = arr.length;\n    if( n == 0 ) return res;\n    foreach(i,v; arr)\n    {\n\
    \        if(isEven(v))\n        {\n            small = [v,i];\n            break;\n\
    \        }\n    }\n    if(small.length == 0) return res;\n    for(int i=0; i<n;\
    \ i++)\n    {\n        if(isEven(arr[i]) && small[0] > arr[i])\n        {\n  \
    \          small = [arr[i],i];\n        }\n    }\n    return small;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1358d2br.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  int i = 0;\n    int r = 0;\n    foreach(e; arr)\n    {\n        if(e % 2 ==\
    \ 0)\n        {\n            result[0] = e;\n            result[1] = i;\n    \
    \        r = 1;\n            break;\n        }\n        i++;\n    }\n    foreach(e;\
    \ arr)\n    {\n        if(e % 2 == 0 && e < result[0])\n        {\n          \
    \  result[0] = e;\n            result[1] = i;\n            r = 1;\n        }\n\
    \        i++;\n    }\n    return result[0..r];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj444doxc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    /*\n    T[] createArray(alias f = () => T.init, size_t length);\n       \
    \ Creates an array of the given length, each element initialized using f.\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo0wi90wt.d(41): Error: unterminated /* */ comment\n/tmp/tmpo0wi90wt.d(57):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo0wi90wt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    if (arr.empty) return new long[0];\n    auto it = arr.retro;\n    auto result\
    \ = long[2];\n    result[0] = 2L;\n    result[1] = 0L;\n    foreach (i, v; it)\n\
    \    {\n        if (v % 2 == 0 && v < result[0]) \n        {\n            result[0]\
    \ = v;\n            result[1] = i;\n        }\n    }\n    if (result[0] == 2L)\
    \ return new long[0];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnhzj4if4.d(43): Error: found \''[\'' when expecting \''.\''
    following long\n/tmp/tmpnhzj4if4.d(43): Error: found \''2\'' when expecting identifier
    following \''long.\''\n/tmp/tmpnhzj4if4.d(43): Error: semicolon expected following
    auto declaration, not \'']\''\n/tmp/tmpnhzj4if4.d(43): Error: found \'']\'' instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnhzj4if4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [];\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_hvtpmfn.d(41): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hvtpmfn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minEvenValue = long.max;\n \
    \   long minEvenIndex = long.max;\n    if (arr.length == 0) return [];\n    for\
    \ (int i = 0; i < arr.length; i++) \n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < minEvenValue)\n        {\n            minEvenValue = arr[i];\n           \
    \ minEvenIndex = i;\n        }\n    }\n    if (minEvenValue == long.max) return\
    \ [];\n    return [minEvenValue, minEvenIndex];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnzkhr7wk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[];\n    \n    long smallest = arr[0];\n    long index    = 0;\n   \
    \ foreach (i, long value; arr) \n    {\n        if (value % 2 == 0 && value <\
    \ smallest) \n        {\n            smallest = value;\n            index    =\
    \ i;\n        }\n    }\n    \n    return smallest % 2 == 0 ? tuple(smallest, index)\
    \ : new long[];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqjwxprz6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph6wmso2b.d(295): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6wmso2b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    if (arr.length == 0) \n        return\
    \ []; \n  \n    auto minIndex = 0L; \n    auto minValue = -1L; \n    auto isEvenFound\
    \ = false; \n  \n    for (auto i = 0L; i < arr.length; i++) \n    { \n       \
    \ if (arr[i] % 2 == 0) \n        { \n            isEvenFound = true; \n      \
    \      if (minValue == -1 || minValue > arr[i]) \n            { \n           \
    \     minValue = arr[i]; \n                minIndex = i; \n            } \n  \
    \      } \n    } \n  \n    if (isEvenFound) \n        return tuple(minValue, minIndex);\
    \ \n  \n    return []; \n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvtj5cdi6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length < 1) \n        return\
    \ new long[2];\n    long min = long.max;\n    long min_index = -1;\n    long smallest_even_val\
    \ = long.max;\n    long smaalest_even_index = -1;\n    long[] ans = new long[2];\n\
    \    foreach (i, v; arr)\n    {\n        if (v < min) \n        {\n          \
    \  min = v;\n            min_index = i;\n        }\n        if (v < smallest_even_val\
    \ && v % 2 == 0) \n        {\n            smallest_even_val = v;\n           \
    \ smaalest_even_index = i;\n        }\n    }\n    if (smallest_even_val == long.max)\
    \ \n        return new long[2];\n    ans[0] = smallest_even_val;\n    ans[1] =\
    \ smaalest_even_index;\n    return ans;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvg9zg_nq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestVal = -1L;\n    long\
    \ smallestIndex = -1L;\n    long[] result = new long[2];\n    foreach(int i, long\
    \ item; arr)\n    {\n        if (smallestVal > item || smallestVal == -1L)\n \
    \       {\n            if (item % 2 == 0)\n            {\n                smallestVal\
    \ = item;\n                smallestIndex = i;\n            }\n        }\n    }\n\
    \    if (smallestVal == -1L)\n    {\n        return result;\n    }\n    result[0]\
    \ = smallestVal;\n    result[1] = smallestIndex;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptd51r4p2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return (arr.length == 0 || arr.all!(e\
    \ => e % 2)) ? [] : \n        [arr.filter!(e => e % 2 == 0).min, arr.indexOf(arr.filter!(e\
    \ => e % 2 == 0).min)];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_r8x46sd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n  if (arr.length == 0) return [0L, 0L];\n\
    \  auto pluck = arr.mapping!(a => a % 2 == 0 ? a : cast(long)LONG_MAX).minIndex;\n\
    \  return arr[pluck] == LONG_MAX ? [0L, 0L] : [arr[pluck], pluck];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7oshzc6g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long minEven = cast(long)1e9;\n    long index = 0;\n\
    \    long result = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n    \
    \    if (arr[i] % 2 == 0 && arr[i] < minEven)\n        {\n            minEven\
    \ = arr[i];\n            index = i;\n            result = minEven;\n        }\n\
    \    }\n    if (result == -1)\n        return new long[0];\n    return tuple(result,\
    \ index);\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptx64ppbv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min_even_idx = 0;\n    long\
    \ min_even_val = arr[0];\n    long[] ret_arr = new long[2];\n    foreach(ref idx,\
    \ ref val; arr)\n    {\n        if((val % 2) == 0)\n        {\n            if(val\
    \ < min_even_val)\n            {\n                min_even_val = val;\n      \
    \          min_even_idx = idx;\n            }\n        }\n    }\n    if(min_even_val\
    \ == arr[0])\n    {\n        ret_arr = new long[0];\n    }\n    else\n    {\n\
    \        ret_arr[0] = min_even_val;\n        ret_arr[1] = min_even_idx;\n    }\n\
    \    return ret_arr;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr8jswqj3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallest_even_value = 0;\n \
    \   long smallest_even_index = 0;\n    bool is_found = false;\n    int N = arr.length;\n\
    \    foreach(immutable i, immutable value; arr) \n    {\n        if (value !=\
    \ 0 && value % 2 == 0) \n        {\n            if (!is_found) \n            {\n\
    \                smallest_even_value = value;\n                smallest_even_index\
    \ = i;\n                is_found = true;\n            }\n            else \n \
    \           {\n                if (value < smallest_even_value) \n           \
    \     {\n                    smallest_even_value = value;\n                  \
    \  smallest_even_index = i;\n                }\n            }\n        }\n   \
    \ }\n    if (is_found) \n    {\n        return [smallest_even_value, smallest_even_index];\n\
    \    }\n    else \n    {\n        return [];\n    }\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi8fx89d5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long min = long.max;\n    size_t min_i = 0;\n    for (size_t\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            min_i = i;\n       \
    \ }\n    }\n    if (min == long.max)\n        return new long[0];\n    return\
    \ [min, min_i];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwbw0clzx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    if\
    \ (arr.length == 0) return res;\n    long min = arr[0], pos = 0;\n    if (arr[0]\
    \ % 2 == 0) \n    {\n        min = arr[0];\n        res[0] = min;\n        res[1]\
    \ = 0;\n    }\n    for (long i = 1; i < arr.length; i++) \n    {\n        if (arr[i]\
    \ % 2 == 0) \n        {\n            if (arr[i] < min) \n            {\n     \
    \           min = arr[i];\n                pos = i;\n            }\n        }\n\
    \    }\n    if (min == arr[0]) return res;\n    res[0] = min;\n    res[1] = pos;\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv81ng1h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long value = 0;\n    long index =\
    \ 0;\n    foreach(i, e; arr) \n    {\n        if(isEven(e) && (value == 0 || e\
    \ < value)) \n        {\n            value = e;\n            index = i;\n    \
    \    }\n    }\n    return tuple(value, index);\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsgiasxqk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res;\n    auto m = arr.chunks(2).filter!(a\
    \ => a[0] % 2 == 0).front();\n    if(m)\n    {\n        res = m[];\n    }\n  \
    \  else\n    {\n        res = [];\n    }\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzy6cjnl_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return new long[];\n    }\n    else \n    {\n        long minIndex = -1;\n\
    \        long minVal = arr[0];\n        foreach (inx, val; arr) \n        {\n\
    \            if (val % 2 == 0 && (val < minVal || minIndex == -1)) \n        \
    \    {\n                minIndex = inx;\n                minVal = val;\n     \
    \       }\n        }\n        if (minIndex == -1) \n        {\n            return\
    \ new long[];\n        }\n        else \n        {\n            return [minVal,\
    \ minIndex];\n        }\n    }\n}\n/*\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc17ibbaj.d(66): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpc17ibbaj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto minimum = new long[2];\n   \
    \ minimum[0] = long.max;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl08bnl80.d(42): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl08bnl80.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestEven = 10000;\n    long\
    \ index;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ == 0)\n        {\n            index = i;\n            return [0, index];\n \
    \       }\n        if (arr[i] < smallestEven && arr[i] % 2 == 0)\n        {\n\
    \            smallestEven = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (smallestEven != 10000)\n    {\n        return [smallestEven, index];\n\
    \    }\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qixvmou.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length < 1) \n        return\
    \ [];\n    \n    long min = minElement(arr.filter!(x => x % 2 == 0));\n    return\
    \ [min, arr.indexOf(min)];\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfb46nmqr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[];\n    \n    Tuple!(long, int)[][] res = new Tuple!(long, int)[][](arr.length);\n\
    \    Tuple!(long, int) best;\n    for (int i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] == 0)\n        {\n            best = tuple(0L, i);\n     \
    \       return [best[0], best[1]];\n        }\n        else if (arr[i] % 2 ==\
    \ 0)\n        {\n            best = tuple(arr[i], i);\n            return [best[0],\
    \ best[1]];\n        }\n    }\n    return new long[];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjgsnbhd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = 0L;\n    long index =\
    \ 0L;\n    long[] ret = new long[2];\n    if (arr.length == 0)\n        return\
    \ ret;\n    else if (arr.length == 1) {\n        ret[0] = arr[0];\n        ret[1]\
    \ = 0L;\n        return ret;\n    }\n    else {\n        min = arr[0];\n     \
    \   index = 0L;\n        for (int i = 0; i < arr.length; i++) {\n            if\
    \ (arr[i] % 2 == 0) {\n                if (arr[i] < min) {\n                 \
    \   min = arr[i];\n                    index = i;\n                }\n       \
    \     }\n        }\n        if (min == 0L)\n            return ret;\n        else\
    \ {\n            ret[0] = min;\n            ret[1] = index;\n            return\
    \ ret;\n        }\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_5v2p36j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minEven = long.max;\n    long\
    \ minEvenIdx = -1;\n    long[] ret = new long[2];\n    ret[0] = -1;\n    ret[1]\
    \ = -1;\n    foreach(i, val; arr)\n    {\n        if (val % 2 == 0 && val < minEven)\n\
    \        {\n            minEven = val;\n            minEvenIdx = i;\n        }\n\
    \    }\n    if (minEvenIdx != -1)\n    {\n        ret[0] = minEven;\n        ret[1]\
    \ = minEvenIdx;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeb89_nhb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] tmp = null;\n    long[] result\
    \ = {};\n    long evValue = 0L;\n    if (arr.length > 0)\n    {\n        foreach\
    \ (value; arr)\n        {\n            if (isEven(value))\n            {\n   \
    \             if (evValue == 0)\n                {\n                    evValue\
    \ = value;\n                    tmp = [value, arr.indexOf(value)];\n         \
    \       }\n                else if (value < evValue)\n                {\n    \
    \                evValue = value;\n                    tmp = [value, arr.indexOf(value)];\n\
    \                }\n            }\n        }\n        if (tmp.length > 0)\n  \
    \      {\n            result = tmp;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9fv423br.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestEvenIndex = -1L;\n \
    \   long smallestEvenValue = long.max;\n    foreach(i, e; arr)\n    {\n      \
    \  if(e % 2 == 0 && e < smallestEvenValue)\n        {\n            smallestEvenValue\
    \ = e;\n            smallestEvenIndex = i;\n        }\n    }\n    if(smallestEvenIndex\
    \ == -1L)\n    {\n        return long[].init;\n    }\n    return tuple(smallestEvenValue,\
    \ smallestEvenIndex);\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw0d_99jl.d(52): Error: found \''[\'' when expecting \''.\''
    following long\n/tmp/tmpw0d_99jl.d(52): Error: found \'']\'' when expecting identifier
    following \''long.\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw0d_99jl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] return_arr = [];\n    size_t\
    \ index = 0L;\n    long value = __numeric_limits!long.max;\n    bool has_zero\
    \ = false;\n    foreach(idx, element; arr)\n    {\n        if(element == 0L)\n\
    \        {\n            if(!has_zero)\n            {\n                index =\
    \ idx;\n                has_zero = true;\n            }\n        }\n        else\
    \ if(element % 2L == 0L && element < value)\n        {\n            index = idx;\n\
    \            value = element;\n        }\n    }\n    if(value != __numeric_limits!long.max)\n\
    \    {\n        return_arr ~= value;\n        return_arr ~= index;\n    }\n  \
    \  return return_arr;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppqeu8xza.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long[] min_val = new long[2];\n\
    \    foreach(long index, long val; arr) \n    {\n        if (val % 2 == 0) \n\
    \        {\n            if (val < min_val[0] || min_val[0] == 0) \n          \
    \  {\n                min_val[0] = val;\n                min_val[1] = index;\n\
    \            }\n        }\n    }\n    return min_val;\n}\n// O(n) solution\nlong[]\
    \ pluck(long[] arr) \n{ \n    long[] min_val = new long[2];\n    long val;\n \
    \   foreach(long index; arr) \n    {\n        val = arr[index];\n        if (val\
    \ % 2 == 0) \n        {\n            if (val < min_val[0] || min_val[0] == 0)\
    \ \n            {\n                min_val[0] = val;\n                min_val[1]\
    \ = index;\n            }\n        }\n    }\n    return min_val;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8jaxwthv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    /*\n        Alright, we have an array\
    \ of longs.\n        If its empty, we return [].\n        \n        What if its\
    \ not empty? We only want evens, so we will filter out the odds.\n        Then\
    \ we want the lowest even value, so we will sort descending.\n        Then we\
    \ want the index in the original array of that lowest even value.\n        \n\
    \        We can not use arr.sort because its not a long[].\n        We can not\
    \ use std.algorithm.sort because it does not have a descending option.\n     \
    \   We can not use std.algorithm.sortDescending because it cannot sort primitive\
    \ types.\n        We can not use std.algorithm.sort!(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3qfp48f7.d(40): Error: unterminated /* */ comment\n/tmp/tmp3qfp48f7.d(65):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3qfp48f7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto evens = arr.filter!(i => i %\
    \ 2 == 0)();\n    if (evens.empty)\n        return [];\n    else\n    {\n    \
    \    auto r = evens.min;\n        return [r, arr.indexOf(r)];\n    }\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8t90cj5s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    if (arr.length == 0)\n        return\
    \ [].dup;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwawvip2t.d(42): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwawvip2t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = [0L, 0L];\n    size_t\
    \ min_idx = arr.length;\n    long min_even = arr.length;\n    foreach(idx, val;\
    \ arr)\n    {\n        if(val % 2 == 0 && val < min_even)\n        {\n       \
    \     min_even = val;\n            min_idx = idx;\n        }\n    }\n    if(min_even\
    \ < arr.length)\n    {\n        result[0] = min_even;\n        result[1] = min_idx;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h0qd0j1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return arr;\n\
    \    long smallest = long.max;\n    long index = 0;\n    foreach (i, v; arr)\n\
    \    {\n        if (v%2 == 0 && v < smallest)\n        {\n            smallest\
    \ = v;\n            index = i;\n        }\n    }\n    if (smallest == long.max)\n\
    \        return [];\n    return [smallest, index];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc8w186tl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result;\nunittest\n{\n   \
    \ alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsgx7tt05.d(41): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsgx7tt05.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ typeof(arr).init;\n    else\n    {\n        // The std.algorithm.minElement\
    \ function only allows comparison of\n        // elements by iota, so we have\
    \ to shuffle the even numbers to the\n        // front of the array to be able\
    \ to use minElement.\n        auto newArr = arr.dup;\n        newArr.sort!(a,\
    \ b => a > b && a % 2 == 0 && b % 2 == 0);\n        newArr.sort!(a, b => a % 2\
    \ == 0 && b % 2 == 0);\n        int i = newArr.minElement!((a, b) => a % 2 ==\
    \ 0 && b % 2 == 0);\n        return [newArr[i], arr.indexOf(newArr[i])];\n   \
    \ }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdaft4u2p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    auto smallestEven = arr.filter!(x => x % 2 == 0).min;\n    if (smallestEven\
    \ == -1)\n        return [];\n    else\n        return [smallestEven, arr.indexOf(smallestEven)];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_gtqai4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long n = arr.length;\n    long[]\
    \ arr2 = new long[2];\n    if (n == 0) \n    {\n        return arr2;\n    }\n\
    \    long m = min(arr);\n    while (m % 2 != 0) \n    {\n        arr = arr.filter!(x\
    \ => x != m);\n        m = min(arr);\n    }\n    arr2[0] = m;\n    arr2[1] = arr.indexOf(m);\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgzocc8r_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestEven = long.max;\n \
    \   long index = -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n     \
    \   if (arr[i] % 2 == 0 && arr[i] < smallestEven)\n        {\n            smallestEven\
    \ = arr[i];\n            index = i;\n        }\n    }\n    return (index != -1)\
    \ ? [smallestEven, index] : [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpju9gyh4s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long minEven = long.max;\n    long minIndex = long.max;\n\
    \    long minValue = long.max;\n    \n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < minEven)\n\
    \            {\n                minEven = arr[i];\n                minIndex =\
    \ i;\n                minValue = arr[i];\n            }\n        }\n    }\n  \
    \  \n    if (minEven == long.max)\n        return new long[0];\n    else\n   \
    \     return [minValue, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvsqlrt12.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    long min = -1;\n    long min_idx = -1;\n    foreach (idx, e; arr)\n    {\n\
    \        if (e % 2 == 0)\n        {\n            if (min < 0 || e < min)\n   \
    \         {\n                min = e;\n                min_idx = idx;\n      \
    \      }\n        }\n    }\n    if (min < 0) return new long[0];\n    return [min,\
    \ min_idx];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw89a8i4_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.dup.map!(a => tuple(a,\
    \ arr.indexOf(a))).filter!(a => a[0] % 2 == 0).sort!((a, b) => a[0] > b[0]).sort!((a,\
    \ b) => a[1] > b[1]).front;\n}\nlong[] pluck2(long[] arr) \n{\n    return arr.dup.map!(a\
    \ => tuple(a, arr.indexOf(a))).filter!(a => a[0] % 2 == 0).sort!((a, b) => a[0]\
    \ > b[0]).sort!((a, b) => a[1] > b[1]).front;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg1_dd63y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] answer = new long[2];\n  \
    \  int smallest_index = -1;\n    long smallest_value = -1;\n    if (arr.length\
    \ > 0) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i]\
    \ != 0 && (arr[i] % 2) == 0) {\n                if (smallest_value == -1) {\n\
    \                    smallest_value = arr[i];\n                    smallest_index\
    \ = i;\n                } else if (arr[i] < smallest_value) {\n              \
    \      smallest_value = arr[i];\n                    smallest_index = i;\n   \
    \             }\n            }\n        }\n    }\n    if (smallest_index != -1)\
    \ {\n        answer[0] = smallest_value;\n        answer[1] = smallest_index;\n\
    \    }\n    return answer;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsxk8b6o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long[] ans = new long[2];\n    ans[0] = long.max;\n    for\
    \ (long i=0; i<arr.length; i++) \n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < ans[0])\n        {\n            ans[0] = arr[i];\n            ans[1] = i;\n\
    \        }\n    }\n    if (ans[0] == long.max)\n        return new long[0];\n\
    \    return ans;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnyn7mrz5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // YOUR CODE GOES HERE\n    return\
    \ null;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0vfri87.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] minEven = [std.numeric.max,\
    \ 0];\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpivd_uc2m.d(41): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpivd_uc2m.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  result[0] = long.max;\n    foreach(ref e; arr)\n    {\n        if(e%2 == 0\
    \ && e < result[0])\n        {\n            result[0] = e;\n            result[1]\
    \ = arr.indexOf(e);\n        }\n    }\n    if(result[0] == long.max)\n    {\n\
    \        return new long[2];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvly7a0ss.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallest_index = -1L;\n    long\
    \ smallest_even = long.max;\n    foreach(index, value; arr)\n    {\n        if(value\
    \ % 2 == 0 && value < smallest_even)\n        {\n            smallest_even = value;\n\
    \            smallest_index = index;\n        }\n    }\n    if(smallest_index\
    \ != -1L)\n    {\n        return [smallest_even, smallest_index];\n    }\n   \
    \ return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7_zxu71z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\n    long minEven = 0;\n    long minEvenIndex = 0;\n\
    \    long smallestIndex = 0;\n    long counter = 0;\n    foreach (value; arr)\
    \ \n    {\n        if (value % 2 == 0) \n        {\n            if (counter ==\
    \ 0) \n            {\n                minEven = value;\n                minEvenIndex\
    \ = counter;\n            }\n            else if (value < minEven) \n        \
    \    {\n                minEven = value;\n                minEvenIndex = counter;\n\
    \            }\n        }\n        counter++;\n    }\n    if (minEven == 0) \n\
    \    {\n        return [];\n    }\n    else \n    {\n        return [minEven,\
    \ minEvenIndex];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5i0m01ks.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = 0;\n    int index = 0;\n\
    \    bool found = false;\n    for (int i = 0; i < arr.length; i++) \n    {\n \
    \       if (arr[i] % 2 == 0) \n        {\n            if (found == false) \n \
    \           {\n                min = arr[i];\n                index = i;\n   \
    \             found = true;\n            }\n            else if (arr[i] < min)\
    \ \n            {\n                min = arr[i];\n                index = i;\n\
    \            }\n        }\n    }\n    if (found == false) \n    {\n        return\
    \ new long[];\n    }\n    return tuple(min, index);\n}\n/*\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1p_4vlsx.d(66): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp1p_4vlsx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\n    long minEven = 0;\n    long minEvenIndex = -1;\n\
    \    auto currEven = false;\n    foreach (i, long v; arr) \n    {\n        if\
    \ (v % 2 == 0) \n        {\n            if (!currEven) \n            {\n     \
    \           minEven = v;\n                minEvenIndex = i;\n                currEven\
    \ = true;\n            }\n            else \n            {\n                if\
    \ (v < minEven) \n                {\n                    minEven = v;\n      \
    \              minEvenIndex = i;\n                }\n            }\n        }\n\
    \    }\n    if (minEvenIndex == -1) \n    {\n        return [];\n    }\n    return\
    \ [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7tnxk8_k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[]().init;\n    \n    long[] plucked = new long[]().init;\n    long[]\
    \ nonZero = new long[]().init;\n    for (inout long e : arr)\n    {\n        if\
    \ (e % 2 == 0)\n        {\n            plucked ~= e;\n        }\n        else\n\
    \        {\n            nonZero ~= e;\n        }\n    }\n    if (plucked.length\
    \ == 0)\n        return new long[]().init;\n    \n    // sort:\n    plucked.sort!((a,\
    \ b) => a < b);\n    long value = plucked[0];\n    return [value, cast(size_t)arr.indexOf(value)];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpioum8tzv.d(45): Error: semicolon expected, not \'':\''\n/tmp/tmpioum8tzv.d(45):
    Error: expression expected, not \'':\''\n/tmp/tmpioum8tzv.d(45): Error: found
    \''arr\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpioum8tzv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    const int len = arr.length;\n   \
    \ long[] result = new long[2];\n    if (len == 0) \n    {\n        return result;\n\
    \    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc9xzmaox.d(46): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc9xzmaox.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    //scoped auto index = 0L;\n    auto\
    \ dg = std.algorithm.filter!((value) => value % 2 == 0)(arr);\n    //std.algorithm.any!(typeof(dg))(arr);\n\
    \    //foreach(val; arr)\n    //{\n    //    if(val % 2 == 0)\n    //    {\n \
    \   //        //std.algorithm.any!(value)(arr);\n    //        std.array.Appender!(long[])\
    \ app;\n    //        app.put(val);\n    //        //app.put(index);\n    // \
    \       //dg[0] = val;\n    //        //dg[1] = index;\n    //        //return\
    \ dg;\n    //    }\n    //    index++;\n    //}\n    if(dg.length == 0)\n    {\n\
    \        //dg = [ ];\n        return dg;\n    }\n    auto min = std.algorithm.min(dg);\n\
    \    long[] dg2;\n    dg2 ~= min;\n    dg2 ~= std.algorithm.minIndex(dg);\n  \
    \  return dg2;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeoizui_r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min_even = std.numeric.maxOf!long;\n\
    \    size_t min_idx = arr.length;\n    bool found = false;\n    foreach(i, v;\
    \ arr)\n    {\n        if (v % 2 == 0)\n        {\n            if (v < min_even)\n\
    \            {\n                min_even = v;\n                min_idx = i;\n\
    \                found = true;\n            }\n        }\n    }\n    if (found)\n\
    \    {\n        return [min_even, min_idx];\n    }\n    else\n    {\n        return\
    \ [];\n    }\n}\n/*\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptrme76mf.d(64): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmptrme76mf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minValue = 2L;\n    bool foundMinValue\
    \ = false;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ < minValue && arr[i] > 0)\n        {\n            minValue = arr[i];\n     \
    \       foundMinValue = true;\n        }\n    }\n    if (foundMinValue)\n    {\n\
    \        for (int i = 0; i < arr.length; i++)\n        {\n            if (arr[i]\
    \ == minValue)\n            {\n                return [minValue, i];\n       \
    \     }\n        }\n    }\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphimcbus3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = 20000;\n    long index\
    \ = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if(arr[i] %\
    \ 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if(index == -1)\n    {\n        return [];\n   \
    \ }\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn1mlio1_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length < 1) return new long[2];\n\
    \    long evenMin = uint.max;\n    uint evenMinIdx = uint.max;\n    for (uint\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ evenMin)\n        {\n            evenMin = arr[i];\n            evenMinIdx =\
    \ i;\n        }\n    }\n    return evenMin == uint.max ? new long[2] : new long[2]\
    \ {evenMin, evenMinIdx};\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc31k03kv.d(51): Error: found \''{\'' when expecting \'';\''
    following return statement\n/tmp/tmpc31k03kv.d(51): Error: found \''}\'' when
    expecting \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpc31k03kv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int resIndex = -1;\n    long res\
    \ = long.max;\n    if (arr.length == 0)\n        return new long[0];\n    foreach\
    \ (i, v; arr)\n    {\n        if (v != 0 && v % 2 == 0 && v < res)\n        {\n\
    \            res = v;\n            resIndex = i;\n        }\n    }\n    if (resIndex\
    \ == -1)\n        return new long[0];\n    return [res, resIndex];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpml6glhmt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.filter!(e => e % 2 ==\
    \ 0).minElementIndex!q{a < b}.map!(e => [e, arr.indexOf(e)]).array;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdyrzbs7w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] ret = [long.max, long.max];\n\
    \    foreach(idx, cur; arr) \n    {\n        if (cur > ret[0] || ((cur & 1) ==\
    \ 1 && cur < ret[0])) continue;\n        ret = [cur, idx];\n    }\n    if (ret[0]\
    \ == long.max) ret = [];\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwdok4unw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    if\
    \ (arr.length == 0) return res;\n    long min_even = 2 * LONG_MAX;\n    foreach\
    \ (index, value; arr)\n    {\n        if (value == 0)\n        {\n           \
    \ res[0] = value;\n            res[1] = index;\n            return res;\n    \
    \    }\n        if (value % 2 == 0 && value < min_even)\n        {\n         \
    \   min_even = value;\n            res[0] = value;\n            res[1] = index;\n\
    \        }\n    }\n    if (min_even > 100000) return [];\n    return res;\n}\n\
    ```\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1kmfv6io.d(61): Error: Declaration expected, not \''""\''\n/tmp/tmp1kmfv6io.d(61):
    Error: unterminated string constant starting at /tmp/tmp1kmfv6io.d(61)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1kmfv6io.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    /*\n    // Fail.\n    if(arr.length\
    \ == 0)\n        return [];\n    long minEven = long.max;\n    long index = 0;\n\
    \    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] % 2 == 0)\n\
    \        {\n            if(arr[i] < minEven)\n            {\n                minEven\
    \ = arr[i];\n                index = i;\n            }\n        }\n    }\n   \
    \ if(minEven == long.max)\n        return [];\n    return [minEven, index];\n\
    \    */\n    /*\n    // Fail.\n    if(arr.length == 0)\n        return [];\n \
    \   return [arr.filter!(a => a % 2 == 0).min, arr.filter!(a => a % 2 == 0).findIndex!(a\
    \ => a == arr.filter!(a => a % 2 == 0).min)];\n    */\n    return [arr.filter!(a\
    \ => a % 2 == 0).min, arr.indexOf(arr.filter!(a => a % 2 == 0).min)];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsnafrqn9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long lowestEven = int.max;\n    int index = 0;\n   \
    \ int lowestIndex = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n    \
    \    if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < lowestEven)\n \
    \           {\n                lowestEven = arr[i];\n                lowestIndex\
    \ = i;\n            }\n        }\n    }\n    if (lowestEven == int.max)\n    \
    \    return new long[0];\n    return [lowestEven, lowestIndex];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptk_chmje.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  if (arr.length < 1)\n        return result;\n    \n    long minEvenValue =\
    \ long.max;\n    long minEvenIndex = long.max;\n    for (long i = 0; i < arr.length;\
    \ i++) \n    {\n        if (arr[i] % 2 == 0 && arr[i] < minEvenValue) \n     \
    \   {\n            minEvenValue = arr[i];\n            minEvenIndex = i;\n   \
    \     }\n    }\n    if (minEvenValue != long.max) \n    {\n        result[0] =\
    \ minEvenValue;\n        result[1] = minEvenIndex;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcm8bx66_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return new long[0];\n    }\n    if (arr.length == 1) \n    {\n        return\
    \ arr[0] % 2 == 0 ? arr : new long[0];\n    }\n    long minEven = arr[0];\n  \
    \  long minEvenIdx = 0;\n    bool foundMinEven = false;\n    foreach (i, n; arr)\
    \ \n    {\n        if (n % 2 == 0) \n        {\n            if (!foundMinEven)\
    \ \n            {\n                minEven = n;\n                minEvenIdx =\
    \ i;\n                foundMinEven = true;\n            }\n            else \n\
    \            {\n                if (n < minEven) \n                {\n       \
    \             minEven = n;\n                    minEvenIdx = i;\n            \
    \    }\n            }\n        }\n    }\n    return foundMinEven ? [minEven, minEvenIdx]\
    \ : new long[0];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpllz4__ae.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto pred = (e) { return e % 2 ==\
    \ 0; };\n    auto fil = filter!pred(arr);\n    if (fil.empty)\n        return\
    \ [];\n    auto min = minElement(fil);\n    long idx = arr.countUntil(min);\n\
    \    return tuple(min, idx);\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphy5o3dq0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    auto result = arr.indexOf(arr.filter!(x => x % 2 == 0).min);\n    return\
    \ [arr[result], result];\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyh2hzeb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    /*\n        * First filter the array\
    \ to get only even values\n        * Then sort the result\n        * If the array\
    \ is empty return empty array\n        * Otherwise return the first element and\
    \ it's index\n    */\n    auto even = arr.filter!(n => n % 2 == 0)();\n    even.sort;\n\
    \    if (even.empty) return [].dup;\n    else return [even[0], arr.indexOf(even[0])].dup;\n\
    }\n// Test cases:\nunittest\n{\n    assert(pluck([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(pluck([1L, 2L, 3L]) == [2L, 1L]);\n    assert(pluck([]) == []);\n\
    \    assert(pluck([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqswjo9ud.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long index = 0;\n    long value =\
    \ 0;\n    long min = 100000;\n    long minEven = 100000;\n    foreach(i; arr)\
    \ \n    {\n        if(i%2 == 0) \n        {\n            if(i < minEven) \n  \
    \          {\n                minEven = i;\n                index = value;\n \
    \           }\n        }\n        value++;\n    }\n    if(minEven == 100000) \n\
    \    {\n        return [];\n    }\n    return [minEven, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxmp2u5vs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  result[0] = -1;\n    result[1] = -1;\n    size_t i = 0;\n    foreach(ref e;\
    \ arr)\n    {\n        if(e % 2 == 0)\n        {\n            if(result[0] ==\
    \ -1)\n            {\n                result[0] = e;\n                result[1]\
    \ = i;\n            }\n            else if(e < result[0])\n            {\n   \
    \             result[0] = e;\n                result[1] = i;\n            }\n\
    \        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsjpz8fb3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    long min = long.max;\n    int idx = -1;\n    foreach (i, v; arr) \n    {\n\
    \        if (v % 2 == 0 && v < min) \n        {\n            min = v;\n      \
    \      idx = i;\n        }\n    }\n    if (idx == -1) return new long[0];\n  \
    \  return [min, idx];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0fqhetr0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    long i = arr.minElement!(a => a % 2 == 0);\n    long index = 0;\n \
    \   foreach (immutable long elem; arr) \n    {\n        if (elem == i)\n     \
    \       break;\n        index++;\n    }\n    return [i, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt9pmvf5j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n  long[] result = new long[2];\n  long\
    \ evenNumber = long.max;\n  long index = long.max;\n  if(arr.length == 0)\n  {\n\
    \      return result;\n  }\n  for(int i = 0; i < arr.length; i++)\n  {\n     \
    \ if(arr[i] % 2 == 0 && arr[i] < evenNumber)\n      {\n          evenNumber =\
    \ arr[i];\n          index = i;\n      }\n  }\n  if(evenNumber == long.max &&\
    \ index == long.max)\n  {\n      return result;\n  }\n  result[0] = evenNumber;\n\
    \  result[1] = index;\n  return result;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbymvil9c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // find the smallest even value in\
    \ arr\n    long min_even = long.max;\n    foreach(i, el; arr)\n    {\n       \
    \ if (el % 2 == 0 && el < min_even)\n        {\n            min_even = el;\n \
    \       }\n    }\n    // find the first occurance of min_even\n    size_t min_index\
    \ = size_t.max;\n    foreach(i, el; arr)\n    {\n        if (el == min_even &&\
    \ i < min_index)\n        {\n            min_index = i;\n        }\n    }\n  \
    \  // construct return value\n    if (min_even == long.max) return [];\n    return\
    \ [min_even, min_index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppg4fdr30.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto result = [0L, -1L];\n    foreach(i,\
    \ x; arr)\n    {\n        if((x % 2 == 0) && (x < result[0] || result[0] == 0))\n\
    \        {\n            result[0] = x;\n            result[1] = i;\n        }\n\
    \    }\n    return result[0] == 0 ? [] : result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnk6sdi9v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n\tlong min = 1000000;\n\tint min_idx\
    \ = 0;\n\tlong[] res = new long[2];\n\tfor (int i = 0; i < arr.length; i++)\n\t\
    {\n\t\tif (arr[i] % 2 == 0 && arr[i] < min)\n\t\t{\n\t\t\tmin = arr[i];\n\t\t\t\
    min_idx = i;\n\t\t}\n\t}\n\tif (min != 1000000)\n\t{\n\t\tres[0] = min;\n\t\t\
    res[1] = min_idx;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn5iam3hg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto t = arr.map!(a => tuple(a, arr.indexOf(a))).filter!(t\
    \ => t[0] % 2 == 0).min();\n    return t ? [t[0], t[1]] : long[];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxw_k91tf.d(41): Error: found \''[\'' when expecting \''.\''
    following long\n/tmp/tmpxw_k91tf.d(41): Error: found \'']\'' when expecting identifier
    following \''long.\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxw_k91tf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    //cout << \"Array is: \" << endl;\n\
    \    //foreach(auto e; arr)\n    //    cout << e << \" \";\n    //cout << endl;\n\
    \    //cout << \"*\" << endl;\n    long[] result;\n    long result1 = long.max;\n\
    \    long result2 = long.max;\n    long index = 0;\n    foreach(auto e; arr)\n\
    \    {\n        if (e % 2 == 0)\n        {\n            //cout << \"even: \" <<\
    \ e << endl;\n            if (e < result1)\n            {\n                result1\
    \ = e;\n                result2 = index;\n            }\n        }\n        index++;\n\
    \    }\n    //cout << \"Smallest even value: \" << result1 << endl;\n    //cout\
    \ << \"Its index: \" << result2 << endl;\n    //cout << \"**\" << endl;\n    if\
    \ (result1 == long.max)\n        return result;\n    else\n        return [result1,\
    \ result2];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptls6b7_p.d(49): Error: basic type expected, not auto\n/tmp/tmptls6b7_p.d(49):
    Error: no identifier for declarator int\n/tmp/tmptls6b7_p.d(49): Error: found
    \''auto\'' when expecting \'';\''\n/tmp/tmptls6b7_p.d(49): Error: found \'';\''
    when expecting \'')\''\n/tmp/tmptls6b7_p.d(49): Error: found \'')\'' when expecting
    \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptls6b7_p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    if (arr.length == 1)\n        return (arr[0] % 2 ==\
    \ 0) ? arr : new long[0];\n    \n    const long min_arr_size = 2;\n    if (arr.length\
    \ < min_arr_size)\n        return new long[0];\n    \n    long[] even_numbers\
    \ = new long[];\n    long smallest_even = long.max;\n    long index = 0;\n   \
    \ foreach (n; arr)\n    {\n        if (n % 2 == 0)\n        {\n            even_numbers\
    \ ~= n;\n            if (n < smallest_even)\n            {\n                smallest_even\
    \ = n;\n                index = even_numbers.length - 1;\n            }\n    \
    \    }\n    }\n    \n    if (even_numbers.length == 0)\n        return new long[0];\n\
    \    \n    return [ smallest_even, index ];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf5yvszzl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long small = 0;\n    long index =\
    \ 0;\n    int even = 0;\n    foreach(long i, long x; arr)\n    {\n        if (x\
    \ % 2 == 0) \n        {\n            even = 1;\n            if (small == 0)\n\
    \            {\n                small = x;\n                index = i;\n     \
    \       }\n            else if (x < small)\n            {\n                small\
    \ = x;\n                index = i;\n            }\n        }\n    }\n    if (even\
    \ == 0)\n    {\n        return new long[]([]);\n    }\n    return new long[]([small,\
    \ index]);\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9i_8piy_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [];\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_hvtpmfn.d(41): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hvtpmfn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = [0L, 0L];\n    long\
    \ smallestEven = long.max;\n    for (int i = 0; i < arr.length; i++) \n    {\n\
    \        if(arr[i] % 2 == 0 && arr[i] < smallestEven)\n        {\n           \
    \ smallestEven = arr[i];\n            res[0] = smallestEven;\n            res[1]\
    \ = i;\n        }\n    }\n    if(smallestEven == long.max)\n        return [];\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrcpf4gq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto it = min(arr.filter!(a => a\
    \ % 2 == 0));\n    if (it.empty) \n        return [];\n    auto index = arr.indexOf(it.front);\n\
    \    return [it.front, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnnqsv4hn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] smallElem = {-1, -1};\n  \
    \  foreach(i, val; arr)\n    {\n        if (val % 2 == 0)\n        {\n       \
    \     if (smallElem[0] == -1 || smallElem[0] > val)\n            {\n         \
    \       smallElem[0] = val;\n                smallElem[1] = i;\n            }\n\
    \        }\n    }\n    return smallElem;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27c_u1q7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    size_t min = 0;\n    for (size_t\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n\
    \            if (min == 0)\n            {\n                min = i;\n        \
    \    }\n            else if (arr[i] < arr[min])\n            {\n             \
    \   min = i;\n            }\n        }\n    }\n    if (min == 0)\n    {\n    \
    \    return [];\n    }\n    else\n    {\n        return [arr[min], min];\n   \
    \ }\n}\n/*\n    assert(pluck([4L, 2L, 3L]) == [2L, 1L]);\n    assert(pluck([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(pluck([]) == []);\n    assert(pluck([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(pluck([1L, 1L, 1L, 1L, 1L, 1L])\
    \ == []);\n    assert(pluck([1L, 9L, 1L, 1L, 9L, 1L]) == [9L, 1L]);\n    assert(pluck([1L,\
    \ 7L, 1L, 1L, 9L, 1L]) == [7L, 1L]);\n    assert(pluck([1L, 9L, 1L, 1L, 7L, 1L])\
    \ == [7L, 4L]);\n    assert(pluck([1L, 2L, 1L, 1L, 3L, 1L]) == [2L, 1L]);\n  \
    \  assert(pluck([1L, 2L, 1L, 1L, 2L, 1L]) == [2L, 1L]);\n    assert(pluck([1L,\
    \ 2L, 1L, 1L, 3L, 1L]) == [2L, 1L]);\n    assert(pluck([1L, 2L, 1L, 1L, 2L, 1L])\
    \ == [2L, 1L]);\n    assert(pluck([1L, 2L, 1L, 1L,\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3t72hca1.d(64): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3t72hca1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    bool[] isEven = new bool[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        isEven[i] = arr[i] %\
    \ 2 == 0;\n    }\n    int firstIndex = 0;\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (isEven[i])\n        {\n            firstIndex = i;\n\
    \            break;\n        }\n    }\n    long smallestEven = arr[firstIndex];\n\
    \    int smallestEvenIndex = firstIndex;\n    for (int i = firstIndex; i < arr.length;\
    \ i++)\n    {\n        if (isEven[i] && arr[i] < smallestEven)\n        {\n  \
    \          smallestEven = arr[i];\n            smallestEvenIndex = i;\n      \
    \  }\n    }\n    if (smallestEvenIndex == firstIndex && smallestEven != arr[firstIndex])\n\
    \    {\n        return new long[0];\n    }\n    return [smallestEven, smallestEvenIndex];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpizcph4c5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    immutable len = arr.length;\n   \
    \ if (len == 0) return new long[0];\n    else if (len == 1) return arr[0] % 2\
    \ == 0 ? arr : new long[0];\n    else\n    {\n        static struct Node\n   \
    \     {\n            int index;\n            long value;\n        }\n        immutable\
    \ node = arr.map!(a => Node(0, a)).min!((a, b) => a.value < b.value);\n      \
    \  if (node.value % 2 == 0) return [node.value, node.index];\n        else return\
    \ new long[0];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb97sfg2e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.retro.filter!(x => x %\
    \ 2 == 0).min().map!(x => [x, arr.find(x)]).front;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzhexp1dt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    bool have_even = false;\n    long\
    \ small_val = arr[0];\n    long small_idx = 0;\n    foreach(i, val; arr)\n   \
    \ {\n        if(val & 1 == 0)\n        {\n            have_even = true;\n    \
    \        if(val < small_val)\n            {\n                small_val = val;\n\
    \                small_idx = i;\n            }\n        }\n    }\n    if(have_even)\n\
    \        return [small_val, small_idx];\n    else\n        return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvb919h9x.d(45): Error: 1 == 0 must be parenthesized when next
    to operator &\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvb919h9x.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int leastEven = 10000;\n    int index\
    \ = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] <\
    \ leastEven && arr[i] % 2 == 0)\n        {\n            leastEven = cast(int)arr[i];\n\
    \            index = i;\n        }\n    }\n    if (index == -1)\n    {\n     \
    \   return [];\n    }\n    return [leastEven, index];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpolyr0m7e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] smallestEven = [];\n    long\
    \ index = 0;\n    foreach(node; arr) \n    {\n        if(node % 2 == 0) \n   \
    \     {\n            if(smallestEven.length == 0) \n            {\n          \
    \      smallestEven ~= [node, index];\n            }\n            else if(node\
    \ < smallestEven[0]) \n            {\n                smallestEven[0] = node;\n\
    \                smallestEven[1] = index;\n            }\n        }\n        index++;\n\
    \    }\n    return smallestEven;\n}\n/*\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp44q027r5.d(60): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp44q027r5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    long min = int.max;\n    long minIndex = int.max;\n    int pos = 0;\n\
    \    foreach(item; arr)\n    {\n        if (item % 2 == 0 && item < min)\n   \
    \     {\n            min = item;\n            minIndex = pos;\n        }\n   \
    \     pos++;\n    }\n    if (min == int.max)\n        return [];\n    return [min,\
    \ minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpie06hhxx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [0L, 0L];\n    \n    auto idx = arr.indexOf(arr.min!(a => a % 2 == 0));\n  \
    \  auto res = [arr[idx], idx];\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphppc1z7j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    /* \n        in case the length\
    \ of array is 0,\n        or it has no even numbers,\n        return []\n    */\n\
    \    if (arr.length == 0)\n        return [];\n    /*\n        create an array\
    \ of two elements, \n        that will store the results of our search\n    */\n\
    \    long[] result = new long[2];\n    /*\n        we start with the first element\
    \ of the array,\n        and we take the smallest element with an even value\n\
    \    */\n    result[0] = arr[0];\n    /*\n        we start with the index 0,\n\
    \        and we take the index of the smallest element with an even value\n  \
    \  */\n    result[1] = 0;\n    /*\n        iterate each element of the array,\n\
    \        and for each element we take the following actions:\n        1) if the\
    \ element is even, but it's not the smallest element,\n           move it to the\
    \ right place, and store the index of the smallest even value\n        2) if the\
    \ element is even, and it's the smallest element,\n           store the index\
    \ of the smallest even value\n    */\n    foreach (i, x; arr) \n    {\n      \
    \  if (x % 2 == 0) \n        {\n            if (x > result[0]) \n            {\n\
    \                result[0] = x;\n                result[1] = i;\n            }\n\
    \        }\n    }\n    return result;\n}\n// static assert(pluck([4L, 2L, 3L])\
    \ == [2L, 1L]);\n// static assert(pluck([1L, 2L, 3L]) == [2L, 1L]);\n// static\
    \ assert(pluck([]) == []);\n// static assert(pluck([5L, 0L, 3L, 0L, 4L, 2L]) ==\
    \ [0L, 1L]);\n// static assert(pluck([0L, 2L, 3L, 0L, 4L, 2L]) == [0L, 0L]);\n\
    // static assert(pluck([2L, 2L, 3L, 0L, 4L, 2L]) == [2L, 0L]);\n// static assert(pluck([2L,\
    \ 2L, 3\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkf6e3upz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // sorting the array from smallest\
    \ to largest\n    arr.sort!((a, b) => a.compare(b)).retro;\n    // we'll use this\
    \ to get the index of the first found even number\n    size_t i = arr.length;\n\
    \    // we'll find the first even number, the loop will stop when i == 0\n   \
    \ while (true) \n    {\n        // if i == 0 we didn't find any even numbers in\
    \ the array\n        if (i == 0) return typeof(return).init;\n        // if i\
    \ is odd, subtract 1, then if i is even we found the first even number\n     \
    \   if (i % 2 == 0) break;\n        --i;\n    }\n    //return the even number\
    \ and it's index\n    return typeof(return).init(arr[i], i);\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp31mqsazl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm : filter, min,\
    \ minIndex, equal;\n    import std.range : zip;\n    import std.traits : isIntegral;\n\
    \    alias zipResult = typeof(zip(arr, 0L .. arr.length));\n    static assert(zipResult.isIntegral);\n\
    \    auto it = zip(arr, 0L .. arr.length)\n                .filter!(x => x[0]\
    \ % 2 == 0)\n                .min!(x => x[0]);\n    if (it.length > 0) {\n   \
    \     return [it[0], it[1]];\n    }\n    return [];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvmzddl26.d(43): Error: found \''..\'' when expecting \'',\''\n/tmp/tmpvmzddl26.d(45):
    Error: found \''..\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpvmzddl26.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.filter!(a => a % 2 ==\
    \ 0).empty \n        ? new long[2] \n        : new long[2](arr.filter!(a => a\
    \ % 2 == 0).min, arr.find!(a => a == arr.filter!(a => a % 2 == 0).min));\n}\n\
    /*\n    Alternative Solution:\n        long[] pluck(long[] arr)\n        {\n \
    \           import std.algorithm : min;\n            import std.range : iota;\n\
    \            import std.typecons : tuple;\n            auto maxInt = long.max;\n\
    \            return arr.iota.map!(y => tuple(y, arr[y]))\n                .filter!(t\
    \ => t[1] % 2 == 0)\n                .min!((a, b) => a[1] == b[1] \n         \
    \       ? a[0] < b[0] \n                : a[1] < b[1]).map!(t => t[1]).array;\n\
    \        }\n*/\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp60v2ov91.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = arr.filter!(x => x %\
    \ 2 == 0).sort.dup;\n    if (res.length == 0)\n        return res;\n    else\n\
    \        return arr.filter!(x => x == res[0]).sort.dup[0..1];\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_j4ca3n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto temp = arr;\n    temp.sort();\n\
    \    long min_even = -1;\n    size_t min_even_ind = size_t.max;\n    foreach(i,\
    \ j; temp)\n    {\n        if(j % 2 == 0)\n        {\n            min_even = j;\n\
    \            break;\n        }\n    }\n    if(min_even == -1)\n        return\
    \ [];\n    foreach(i, j; temp)\n    {\n        if(j == min_even)\n        {\n\
    \            min_even_ind = i;\n            break;\n        }\n    }\n    return\
    \ [min_even, min_even_ind];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfguiumxj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto even_indices = arr.retro.retro.filter!(a\
    \ => a % 2 == 0).retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy9vvpktr.d(41): Error: identifier expected following \''.\'',
    not \''unittest\''\n/tmp/tmpy9vvpktr.d(42): Error: semicolon expected following
    auto declaration, not \''{\''\n/tmp/tmpy9vvpktr.d(54): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy9vvpktr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long firstEvenIdx = -1;\n    long\
    \ minValue = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0)\n     \
    \   {\n            if(firstEvenIdx == -1)\n            {\n                firstEvenIdx\
    \ = i;\n                minValue = e;\n            }\n            else\n     \
    \       {\n                if(e < minValue)\n                {\n             \
    \       firstEvenIdx = i;\n                    minValue = e;\n               \
    \ }\n            }\n        }\n    }\n    if(firstEvenIdx >= 0)\n    {\n     \
    \   return [minValue, firstEvenIdx];\n    }\n    else\n    {\n        return [];\n\
    \    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgtubj6nu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm.iteration :\
    \ filter, map, max, min;\n    import std.conv : to;\n    import std.range : zip;\n\
    \    import std.algorithm.sorting : sort;\n    import std.typecons : tuple;\n\
    \    import std.traits : isIntegral;\n    import std.math : isOdd;\n    import\
    \ std.array : array;\n    import std.stdio : writeln;\n    import std.functional\
    \ : unaryFun;\n    import std.typecons : Tuple;\n    import std.algorithm.comparison\
    \ : minElement;\n    enum isEven = unaryFun!((a) => isIntegral!(a) && !isOdd(a));\n\
    \    auto evens = filter!isEven(arr);\n    writeln(evens);\n    auto it = evens.begin;\n\
    \    writeln(it);\n    auto itend = evens.end;\n    writeln(itend);\n    return\
    \ [ evens[0], 0 ];\n}\nlong[] pluck(long[] arr) \n{\n    import std.algorithm.iteration\
    \ : filter, map, max, min;\n    import std.conv : to;\n    import std.range :\
    \ zip;\n    import std.algorithm.sorting : sort;\n    import std.typecons : tuple;\n\
    \    import std.traits : isIntegral;\n    import std.math : isOdd;\n    import\
    \ std.array : array;\n    import std.stdio : writeln;\n    import std.functional\
    \ : unaryFun;\n    import std.typecons : Tuple;\n    import std.algorithm.comparison\
    \ : minElement;\n    enum isEven = unaryFun!((a) => isIntegral!(a) && !isOdd(a));\n\
    \    auto evens = filter!isEven(arr);\n    writeln(evens);\n    auto it = evens.begin;\n\
    \    writeln(it);\n    auto itend = evens.end;\n    writeln(itend);\n    return\
    \ [ evens[0], 0 ];\n}\nlong[] pluck(long[] arr) \n{\n    import std.al\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6k6tpn6_.d(87): Error: \'';\'' expected\n/tmp/tmp6k6tpn6_.d(100):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6k6tpn6_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpchoc6b6o.d(44): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchoc6b6o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014636
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] ret = new long[2];\n    if\
    \ (arr.length == 0)\n        return ret;\n    long[] _arr = new long[arr.length\
    \ + 1];\n    for (size_t i = 0; i < arr.length; i++) {\n        _arr[i + 1] =\
    \ arr[i];\n    }\n    size_t min_elem = findMinEven(_arr);\n    if (min_elem ==\
    \ _arr.length) {\n        return ret;\n    }\n    ret[0] = _arr[min_elem];\n \
    \   for (size_t i = 0; i < arr.length; i++) {\n        if (arr[i] == _arr[min_elem])\
    \ {\n            ret[1] = i;\n            break;\n        }\n    }\n    return\
    \ ret;\n}\nsize_t findMinEven(long[] arr) \n{\n    size_t res = arr.length;\n\
    \    long min = arr[0];\n    for (size_t i = 1; i < arr.length; i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (arr[i] < min) {\n                min\
    \ = arr[i];\n                res = i;\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgd82yuwm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n\tlong minVal = 999999999;\n\tlong posVal\
    \ = -1;\n\t\n\tforeach(long l; arr)\n\t{\n\t\tif (l % 2 == 0 && l < minVal)\n\t\
    \t{\n\t\t\tminVal = l;\n\t\t\tposVal = arr.indexOf(l);\n\t\t}\n\t}\n\t\n\tif (posVal\
    \ == -1) return [];\n\telse return [minVal, posVal];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmxoy9pp7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[];\n    auto result = arr.minPos!((a, b) => (a % 2 == 0) && (b % 2\
    \ == 0) ? a < b : a % 2 == 0 && b % 2 != 0);\n    if (result[0] % 2 == 0)\n  \
    \      return result;\n    return new long[];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5b_8qyf5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    \n    long minEven = cast(long)1e9;\n    long minEvenIndex = -1;\n\
    \    foreach (i, item; arr)\n    {\n        if (item % 2 == 0 && item < minEven)\n\
    \        {\n            minEven = item;\n            minEvenIndex = i;\n     \
    \   }\n    }\n    \n    if (minEven == cast(long)1e9)\n        return [];\n  \
    \  \n    return [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuazmbzam.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int index = 0;\n    long smallestEven\
    \ = 2147483647;\n    long[] ret = [0L,0L];\n    foreach(int i, long e; arr)\n\
    \    {\n        if(e % 2 == 0 && e < smallestEven)\n        {\n            smallestEven\
    \ = e;\n            index = i;\n        }\n    }\n    if(smallestEven == 2147483647)\n\
    \    {\n        return ret;\n    }\n    else\n    {\n        ret[0] = smallestEven;\n\
    \        ret[1] = index;\n        return ret;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1fy7zpg9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014637
