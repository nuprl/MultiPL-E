language: d
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    // your code here\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjyr1zr4o.d(38): Error: function `tmpjyr1zr4o.pluck` has no `return`
    statement, but is expected to return a value of type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjyr1zr4o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallest_value = 10001L;\n \
    \   long index = -1L;\n    long value = -1L;\n    foreach(long i, elem; arr)\n\
    \    {\n        if(elem < smallest_value && elem % 2 == 0)\n        {\n      \
    \      smallest_value = elem;\n            index = i;\n            value = elem;\n\
    \        }\n    }\n    if(index < 0)\n    {\n        return [].init;\n    }\n\
    \    return [value, index].init;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxamhcw6o.d(54): Error: cannot implicitly convert expression `null`
    of type `void[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxamhcw6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long[] res = new long[2];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[(int)i] % 2 == 0)\n        {\n            if (arr[(int)i] < min)\n    \
    \        {\n                min = arr[(int)i];\n                minIndex = i;\n\
    \            }\n        }\n    }\n    if (min % 2 == 0)\n    {\n        res[0]\
    \ = min;\n        res[1] = minIndex;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr1h6lstg.d(47): Error: C style cast illegal, use `cast(int)i`

    /tmp/tmpr1h6lstg.d(49): Error: C style cast illegal, use `cast(int)i`

    /tmp/tmpr1h6lstg.d(51): Error: C style cast illegal, use `cast(int)i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr1h6lstg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.takeWhile!((a) => a%2==0).dup.length==0\
    \ ? new long[](0) :\n           arr.indexOf(arr.min(a => a%2==0 ? a : cast(long)double.infinity));\n\
    }\n/*\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5xyjku4z.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xyjku4z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  if (arr.length == 0)\n        return result;\n    result[0] = arr[0];\n   \
    \ result[1] = 0;\n    if (arr[0] % 2 == 0)\n    {\n        result[0] = arr[0];\n\
    \        result[1] = 0;\n    }\n    else\n    {\n        result[0] = 100000;\n\
    \        result[1] = 0;\n    }\n    for (int i = 1; i < arr.length; i++)\n   \
    \ {\n        if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < result[0])\n\
    \            {\n                result[0] = arr[i];\n                result[1]\
    \ = i;\n            }\n        }\n    }\n    if (result[0] == 100000)\n    {\n\
    \        result[0] = 0;\n        result[1] = 0;\n    }\n    return result;\n}\n\
    /*\n    A magic number is a number whose digits, when added together, sum to 7.\n\
    \    For example, the number 34 would be a magic number, because 3 + 4 = 7.\n\
    \    Create a function to return either true or false depending on whether the\
    \ number is a magic number.\n*/\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjo8fsjcq.d(84): unittest failure

    ----------------

    ??:? _d_unittestp [0x42891d]

    ??:? void tmpjo8fsjcq.__unittest_L78_C1() [0x4282ee]

    ??:? void tmpjo8fsjcq.__modtest() [0x4286a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b86a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430af5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fa4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430a81]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b841]

    ??:? runModuleUnitTests [0x42c7ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428de0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.stdio;\n    import std.range;\n    /*\n    import\
    \ std.typecons;\n    import std.typecons : tuple;\n    import std.array;\n   \
    \ */\n    // brute force:\n    // return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : tuple(arr.filter!(l => l.isEven).sort().take(1),\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).map!(t\
    \ => t[0]).take(1));\n    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0],\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).map!(t\
    \ => t[0]).take(1)[0]];\n    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l\
    \ => l.isEven).sort().take(1)) ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0],\
    \ arr.enumerate.filter!(t => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).take(1)[0]];\n\
    \    //return arr.equal(1L) ? [1L, 0L] : [].equal(arr.filter!(l => l.isEven).sort().take(1))\
    \ ? [] : [arr.filter!(l => l.isEven).sort().take(1)[0], arr.enumerate.filter!(t\
    \ => t[1] == arr.filter!(l => l.isEven).sort().take(1)[0]).\nunittest\n{\n   \
    \ alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfkl12v9s.d(54): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfkl12v9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto result = [];\n    long even\
    \ = long.max;\n    long index = 0;\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < even)\n        {\n           \
    \ even = arr[i];\n            index = i;\n        }\n    }\n    if (even == long.max)\
    \ return result;\n    else return [even, index];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1wu36ahq.d(51): Error: cannot implicitly convert expression `result`
    of type `void[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1wu36ahq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm : min, filter,\
    \ count;\n    import std.math : min;\n    if(arr.length == 0)\n        return\
    \ [];\n    arr.sort!q{(a,b) => a > b};\n    auto y = arr.filter!q{x => x % 2 ==\
    \ 0}.array;\n    if(y.length == 0)\n        return [];\n    auto x = y.min;\n\
    \    return [x, arr.count!q{y => y == x}].min;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmputd2ofk6.d(41): Error: module `std.math` import `min` not found,
    did you mean function `std.math.sin`?

    /tmp/tmputd2ofk6.d(44): Error: no property `sort` for type `long[]`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/functional.d-mixin-121(121):
    Error: template lambda has no type

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1164):
    Error: template instance `std.functional.unaryFun!("x => x % 2 == 0", "a").unaryFun!long`
    error instantiating

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):        instantiated
    from here: `FilterResult!(unaryFun, long[])`

    /tmp/tmputd2ofk6.d(45):        instantiated from here: `filter!(long[])`

    /tmp/tmputd2ofk6.d(45): Error: no property `array` for type `FilterResult!(unaryFun,
    long[])`

    /tmp/tmputd2ofk6.d(49): Error: template `std.algorithm.searching.count` cannot
    deduce function from argument types `!("y => y == x")(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(633):        `std.algorithm.searching.count(alias
    pred = "a == b", Range, E)(Range haystack, E needle) if (isInputRange!Range &&
    !isInfinite!Range && is(typeof(binaryFun!pred(haystack.front, needle)) : bool))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(687):        `std.algorithm.searching.count(alias
    pred = "a == b", R1, R2)(R1 haystack, R2 needle) if (isForwardRange!R1 && !isInfinite!R1
    && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front))
    : bool))`

    /home/a.guha/repos/spack/opt/spack/lin'
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = 10001;\n    long minIdx\
    \ = 0;\n    if (arr.length == 0)\n        return [];\n    foreach (idx, el; arr)\n\
    \    {\n        if (el % 2 == 0 && el < min)\n        {\n            min = el;\n\
    \            minIdx = idx;\n        }\n    }\n    if (min == 10001)\n        return\
    \ [];\n    return [min, minIdx];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = [null, null];\n \
    \   long smallestIndex = null;\n    long smallestValue = null;\n    bool allOdd\
    \ = true;\n    bool noEvens = true;\n    foreach( i, e; arr ) \n    {\n      \
    \  if( e % 2 == 0 )\n        {\n            noEvens = false;\n            if(\
    \ allOdd )\n            {\n                smallestIndex = i;\n              \
    \  smallestValue = e;\n                allOdd = false;\n            }\n      \
    \      else\n            {\n                if( e < smallestValue )\n        \
    \        {\n                    smallestIndex = i;\n                    smallestValue\
    \ = e;\n                }\n            }\n        }\n    }\n    if( noEvens )\n\
    \    {\n        return [];\n    }\n    else\n    {\n        result[0] = smallestValue;\n\
    \        result[1] = smallestIndex;\n        return result;\n    }\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcuanqaj5.d(40): Error: cannot implicitly convert expression `[null,
    null]` of type `typeof(null)[]` to `long[]`

    /tmp/tmpcuanqaj5.d(41): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `long`

    /tmp/tmpcuanqaj5.d(42): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcuanqaj5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm;\n    import\
    \ std.stdio;\n    import std.array;\n    import std.conv;\n    auto evArr = arr.filter!(a\
    \ => a % 2 == 0).array;\n    if (evArr.length == 0) return [];\n    auto mi =\
    \ minElement(evArr);\n    auto res = arr.indexOf(mi);\n    // writefln(\"%s\\\
    n\", arr);\n    // writefln(\"%s\\n\", evArr);\n    // writefln(\"%s\\n\", mi);\n\
    \    // writefln(\"%s\\n\", res);\n    return [mi, res];\n}\n \n \n /*\n    \"\
    Given a string representing a DNA sequence,\n    your task is to reverse the string\
    \ representing the complementary strand.\n    The complementary strand follows\
    \ the simple rules:\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaf78nzoa.d(56): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaf78nzoa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    size_t pos = 0;\n    long min = -1;\n\
    \    for (;pos < arr.length;++pos) {\n        if (arr[pos] > 0 && arr[pos] % 2\
    \ == 0) {\n            if (min == -1 || arr[pos] < min) {\n                min\
    \ = arr[pos];\n            }\n        }\n    }\n    if (min == -1) {\n       \
    \ return new long[0];\n    }\n    else {\n        return typeof(new long[0]).init[min,\
    \ pos];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp14im2lmz.d(53): Error: only one index allowed to index `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp14im2lmz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int index = -1;\n    long[] smallest\
    \ = typeof(smallest).init;\n    foreach(immutable i, immutable long item; arr)\n\
    \    {\n        if(item % 2 == 0)\n        {\n            if(smallest.length ==\
    \ 0)\n            {\n                index = i;\n                smallest ~= item;\n\
    \            }\n            else if(item < smallest[0])\n            {\n     \
    \           index = i;\n                smallest[0] = item;\n            }\n \
    \       }\n    }\n    if(index != -1)\n    {\n        return [smallest[0], cast(long)index];\n\
    \    }\n    return [0L];\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp3p3ifm8.d(41): Error: undefined identifier `smallest`

    /tmp/tmpp3p3ifm8.d(48): Error: cannot implicitly convert expression `i` of type
    `immutable(ulong)` to `int`

    /tmp/tmpp3p3ifm8.d(53): Error: cannot implicitly convert expression `i` of type
    `immutable(ulong)` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp3p3ifm8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    struct loc\n    {\n        long index;\n\
    \        long value;\n    }\n    auto result = arr.filter!(e => e % 2 == 0).min(loc(long,\
    \ long));\n    if (result is null)\n        return [];\n    return [result.value,\
    \ result.index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3zl5tqkr.d(45): Error: found `,` when expecting `.` following long

    /tmp/tmp3zl5tqkr.d(45): Error: found `long` when expecting identifier following
    `long`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3zl5tqkr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min_even = 0L;\n    long min_even_idx\
    \ = 0L;\n    bool found_even = false;\n    long i = 0L;\n    foreach(idx, val;\
    \ arr) {\n        if (val % 2 == 0) {\n            if (!found_even) {\n      \
    \          min_even = val;\n                min_even_idx = idx;\n            \
    \    found_even = true;\n            } else {\n                if (val < min_even)\
    \ {\n                    min_even = val;\n                    min_even_idx = idx;\n\
    \                }\n            }\n        }\n    }\n    if (found_even) {\n \
    \       return tuple(min_even, min_even_idx);\n    } else {\n        return tuple(0L,\
    \ 0L);\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm3lkw96q.d(59): Error: cannot implicitly convert expression `tuple(min_even,
    min_even_idx)` of type `Tuple!(long, long)` to `long[]`

    /tmp/tmpm3lkw96q.d(61): Error: cannot implicitly convert expression `tuple(0L,
    0L)` of type `Tuple!(long, long)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm3lkw96q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    if (arr.length == 0) \n        return\
    \ new long[](0);\n    \n    long[] small(long[] arr) \n    {\n        long min\
    \ = arr[0];\n        int index = 0;\n        foreach (i, v; arr) \n        {\n\
    \            if (v < min) \n            {\n                min = v;\n        \
    \        index = i;\n            }\n        }\n        return tuple(min, index);\n\
    \    }\n    \n    long[] even(long[] arr) \n    {\n        long[] even = new long[];\n\
    \        foreach (v; arr) \n        {\n            if (v % 2 == 0)\n         \
    \       even ~= v;\n        }\n        return even;\n    }\n    \n    long[] even_arr\
    \ = even(arr);\n    if (even_arr.length == 0)\n        return new long[](0);\n\
    \    \n    return tuple(small(even_arr)[0], small(even_arr)[1]);\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo2_2wiwu.d(52): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpo2_2wiwu.d(55): Error: cannot implicitly convert expression `tuple(min,
    index)` of type `Tuple!(long, int)` to `long[]`

    /tmp/tmpo2_2wiwu.d(60): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpo2_2wiwu.d(73): Error: cannot implicitly convert expression `tuple(small(even_arr)[0],
    small(even_arr)[1])` of type `Tuple!(long, long)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo2_2wiwu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallest = 0L;\n    long smallest_idx\
    \ = 0L;\n    if (arr.empty)\n        return [smallest, smallest_idx];\n    \n\
    \    long smallest_found = arr[0];\n    long smallest_idx_found = 0L;\n    foreach\
    \ (e; arr) \n    {\n        if ((e % 2) == 0 && (e < smallest_found)) \n     \
    \   {\n            smallest_found = e;\n            smallest_idx_found = cast(long)e;\n\
    \        }\n    }\n    if (smallest_found == arr[0]) \n    {\n        if ((arr[0]\
    \ % 2) == 0)\n            return [smallest_found, smallest_idx_found];\n     \
    \   else \n        {\n            foreach (e; arr) \n            {\n         \
    \       if ((e % 2) == 0) \n                {\n                    smallest_found\
    \ = e;\n                    smallest_idx_found = cast(long)e;\n              \
    \      break;\n                }\n            }\n            return [smallest_found,\
    \ smallest_idx_found];\n        }\n    }\n    return [smallest_found, smallest_idx_found];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc5dwvk6z.d(42): Error: no property `empty` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc5dwvk6z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n  long[] result;\n  foreach(val; arr)\n\
    \  {\n    if(val % 2 == 0)\n    {\n      result = [val, indexOf(arr, val)];\n\
    \      break;\n    }\n  }\n  return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5i1j1yxc.d(45): Error: undefined identifier `indexOf`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5i1j1yxc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    int arrMin = arr[0];\n    int arrMinIndex = 0;\n    bool isEven\
    \ = false;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ < arrMin && (arr[i] % 2) == 0)\n        {\n            arrMin = arr[i];\n  \
    \          arrMinIndex = i;\n            isEven = true;\n        }\n    }\n  \
    \  if (isEven)\n        return tuple(arrMin, arrMinIndex);\n    else\n       \
    \ return new long[0];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplv0tyd63.d(42): Error: cannot implicitly convert expression `arr[0]`
    of type `long` to `int`

    /tmp/tmplv0tyd63.d(49): Error: cannot implicitly convert expression `arr[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmplv0tyd63.d(55): Error: cannot implicitly convert expression `tuple(arrMin,
    arrMinIndex)` of type `Tuple!(int, int)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplv0tyd63.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int idx;\n    long smallest_even_val\
    \ = int.max;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa97v5r7t.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa97v5r7t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ []();\n    auto min_even = arr[0];\n    long min_index = 0;\n    foreach (const\
    \ i, index; arr)\n    {\n        if (i == 0)\n            continue;\n        if\
    \ (i % 2 == 0 && i < min_even)\n        {\n            min_even = i;\n       \
    \     min_index = index;\n        }\n    }\n    if (min_even % 2 == 0)\n     \
    \   return [min_even, min_index];\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyf9g3ezo.d(41): Error: function expected before `()`, not `[]`
    of type `void[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyf9g3ezo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    if\
    \ (arr.length == 0) return res;\n    long min = arr[0];\n    foreach (x; arr)\
    \ {\n        if (x < min && x % 2 == 0) min = x;\n    }\n    if (min % 2 != 0)\
    \ return res;\n    res[0] = min;\n    res[1] = arr.indexOf(min);\n    return res;\n\
    }\n/*\n    You are given a number N and a string S. Print all of the possible\
    \ ways to write a string\n    of length N from the characters in string S, comma\
    \ delimited in alphabetical order.\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl3q_1_o0.d(51): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl3q_1_o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long[] res = new long[2];\n    long[] minEven = new\
    \ long[1];\n    long[] minEvenIdx = new long[1];\n    minEven[0] = 1000000;\n\
    \    minEvenIdx[0] = 1000000;\n    int i = 0;\n    foreach(val; arr)\n    {\n\
    \        if (val % 2 == 0)\n        {\n            if (val < minEven[0])\n   \
    \         {\n                minEven[0] = val;\n                minEvenIdx[0]\
    \ = i;\n            }\n        }\n        i++;\n    }\n    if (minEven[0] == 1000000)\n\
    \        return new long[0];\n    else\n    {\n        res[0] = minEven[0];\n\
    \        res[1] = minEvenIdx[0];\n        return res;\n    }\n}\n// version 2\n\
    long[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n\
    \    \n    long[] res = new long[2];\n    long[] minEven = new long[1];\n    long[]\
    \ minEvenIdx = new long[1];\n    minEven[0] = 1000000;\n    minEvenIdx[0] = 1000000;\n\
    \    foreach(val; arr)\n    {\n        if (val % 2 == 0)\n        {\n        \
    \    if (val < minEven[0])\n            {\n                minEven[0] = val;\n\
    \                minEvenIdx[0] = i;\n            }\n        }\n    }\n    if (minEven[0]\
    \ == 1000000)\n        return new long[0];\n    else\n    {\n        res[0] =\
    \ minEven[0];\n        res[1] = minEvenIdx[0];\n        return res;\n    }\n}\n\
    // version 3\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n       \
    \ return new long[0];\n    \n    long[] res = new long[2];\n    long[] minEven\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp767x8h88.d(109): Error: semicolon expected, not `unittest`

    /tmp/tmp767x8h88.d(109): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp767x8h88.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length > 0) \n    {\n   \
    \     long[] res = new long[2];\n        long min_even = 2147483647L;\n      \
    \  int index = 0;\n        foreach (i, v; arr) \n        {\n            if (v\
    \ == 0) \n            {\n                index = i;\n                break;\n\
    \            }\n            if (v % 2 == 0 && v < min_even) \n            {\n\
    \                min_even = v;\n                index = i;\n            }\n  \
    \      }\n        res[0] = min_even;\n        res[1] = index;\n        return\
    \ res;\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptywv9ipk.d(49): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmptywv9ipk.d(55): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptywv9ipk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n\tlong minIndex = -1;\n\tlong minEvenValue\
    \ = -1;\n\tfor (long i = 0; i < arr.length; i++)\n\t{\n\t\tauto nextValue = arr[i];\n\
    \t\tif (nextValue % 2 == 0)\n\t\t{\n\t\t\tif (minEvenValue == -1 || nextValue\
    \ < minEvenValue)\n\t\t\t{\n\t\t\t\tminEvenValue = nextValue;\n\t\t\t\tminIndex\
    \ = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (minIndex == -1)\n\t{\n\t\treturn [];\n\t}\n\
    \treturn [minEvenValue, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    alias Elem = Tuple!(long, long);\n\
    \    long[] oddArr = arr.filter!((long i) => i % 2 != 0);\n    long[] evenArr\
    \ = arr.filter!((long i) => i % 2 == 0);\n    if (evenArr.length == 0) return\
    \ [];\n    long minEven = evenArr.min;\n    long[] minEvenArr = evenArr.filter!((long\
    \ i) => i == minEven);\n    Elem minEvenArrElem = minEvenArr.zip.iota.front;\n\
    \    return [minEvenArrElem[0], minEvenArrElem[1]];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplbf57md9.d(41): Error: no property `filter` for type `long[]`

    /tmp/tmplbf57md9.d(42): Error: no property `filter` for type `long[]`

    /tmp/tmplbf57md9.d(44): Error: no property `min` for type `long[]`

    /tmp/tmplbf57md9.d(45): Error: no property `filter` for type `long[]`

    /tmp/tmplbf57md9.d(46): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplbf57md9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return new long[0];\n    }\n    long[] even = filter!(e => e % 2 == 0)(arr);\n\
    \    if (even.length == 0) \n    {\n        return new long[0];\n    }\n    long\
    \ min = even[0];\n    long min_index = 0;\n    for (size_t i = 1; i < even.length;\
    \ i++) \n    {\n        if (even[i] < min) \n        {\n            min = even[i];\n\
    \            min_index = i;\n        }\n    }\n    return tuple(min, min_index);\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp98ce66n8.d(44): Error: template instance `filter!((e) => e % 2
    == 0)` template `filter` is not defined

    /tmp/tmp98ce66n8.d(59): Error: cannot implicitly convert expression `tuple(min,
    min_index)` of type `Tuple!(long, long)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp98ce66n8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int index = -1;\n    long value =\
    \ -1;\n    long[] result = new long[0];\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (value == -1)\n\
    \            {\n                value = arr[i];\n                index = i;\n\
    \            }\n            else if (arr[i] < value)\n            {\n        \
    \        value = arr[i];\n                index = i;\n            }\n        }\n\
    \    }\n    if (index > -1)\n    {\n        result = new long[2];\n        result[0]\
    \ = value;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    size_t i = 0;\n    long min = arr[0];\n    size_t min_pos\
    \ = 0;\n    while (i < arr.length) \n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < min) \n        {\n            min = arr[i];\n            min_pos = i;\n  \
    \      }\n        i++;\n    }\n    if (min == arr[0])\n        return new long[0];\n\
    \    return tuple(min, min_pos);\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkdpvoelu.d(56): Error: cannot implicitly convert expression `tuple(min,
    min_pos)` of type `Tuple!(long, ulong)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkdpvoelu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto evens = std.filter!(e => (e\
    \ & 1) == 0)(arr);\n    if (evens.empty) \n        return [];\n    auto min =\
    \ std.min(evens);\n    auto minIndex = std.find(arr, min);\n    return [min, minIndex];\n\
    }\n/*\n \n void main() {\n     assert(pluck([4L, 2L, 3L]) == [2L, 1L]);\n    \
    \ assert(pluck([1L, 2L, 3L]) == [2L, 1L]);\n     assert(pluck([]) == []);\n  \
    \   assert(pluck([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n }\n \n */\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbdkmq4eo.d(40): Error: undefined identifier `filter` in package
    `std`

    /tmp/tmpbdkmq4eo.d(43): Error: undefined identifier `min` in package `std`

    /tmp/tmpbdkmq4eo.d(44): Error: undefined identifier `find` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbdkmq4eo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int smallIdx = 0;\n    long small\
    \ = 0;\n    int pos = 0;\n    int start = 0;\n    int[] ids = new int[2];\n  \
    \  /*This is not efficient*/\n    /*\n    foreach(i;arr)\n    {\n        if(isEven(i))\n\
    \        {\n            if(i<small)\n            {\n                small = i;\n\
    \                smallIdx = pos;\n            }\n        }\n        pos++;\n \
    \   }\n    */\n    /*But this is*/\n    // ids[1] = arr.length;\n    for(i;arr)\n\
    \    {\n        if(isEven(i))\n        {\n            ids[0] = i;\n          \
    \  ids[1] = start;\n            return ids;\n        }\n        start++;\n   \
    \ }\n    return ids;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4f2y6he9.d(62): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp4f2y6he9.d(72): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4f2y6he9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm.sorting : sort;\n\
    \    int minIdx = 0;\n    long minVal = 0;\n    bool hasEven = false;\n    if\
    \ (arr.empty)\n        return [ minVal, minIdx ];\n    else\n    {\n        int\
    \ i = 0;\n        foreach (val; arr)\n        {\n            if (val%2 == 0)\n\
    \            {\n                if (!hasEven)\n                {\n           \
    \         minVal = val;\n                    minIdx = i;\n                   \
    \ hasEven = true;\n                }\n                else\n                {\n\
    \                    if (val < minVal)\n                    {\n              \
    \          minVal = val;\n                        minIdx = i;\n              \
    \      }\n                }\n            }\n            i++;\n        }\n    \
    \    if (hasEven)\n            return [ minVal, minIdx ];\n        else\n    \
    \        return [ minVal, minIdx ];\n    }\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3wh9_5qg.d(44): Error: no property `empty` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3wh9_5qg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int n = arr.length;\n    if (n ==\
    \ 0) return [0L, 0L];\n    long minEven = long.max;\n    int minIndex = -1;\n\
    \    foreach (i, ref e; arr) \n    {\n        if (e % 2 == 0 && e < minEven) \n\
    \        {\n            minEven = e;\n            minIndex = i;\n        }\n \
    \   }\n    if (minIndex == -1) return [0L, 0L];\n    return [minEven, minIndex];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp905huut4.d(40): Error: cannot implicitly convert expression `arr.length`
    of type `ulong` to `int`

    /tmp/tmp905huut4.d(49): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp905huut4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  if (arr.length == 0)\n        return result;\n    \n    bool[] is_even = new\
    \ bool[arr.length];\n    foreach (i, a; arr)\n    {\n        if (a % 2 == 0)\n\
    \            is_even[i] = true;\n    }\n    \n    if (is_even.count(true) == 0)\n\
    \        return result;\n    \n    int min_value = min(arr.retro.filter!(i =>\
    \ is_even[i]).take(is_even.count(true)));\n    foreach (i, a; arr)\n    {\n  \
    \      if (a == min_value)\n        {\n            result[0] = a;\n          \
    \  result[1] = i;\n            break;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjoo99n5p.d(51): Error: no property `count` for type `bool[]`

    /tmp/tmpjoo99n5p.d(54): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjoo99n5p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long[] temp = new long[2];\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3wws13nd.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3wws13nd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n  long[] res = {};\n  if(arr.length\
    \ == 0) return res;\n  immutable(long) min = min(arr.filter!(x => x % 2 == 0));\n\
    \  res ~= min;\n  res ~= arr.indexOf(min);\n  return res;\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdb7gt37v.d(40): Error: a struct is not a valid initializer for
    a `long[]`

    /tmp/tmpdb7gt37v.d(42): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpdb7gt37v.d(44): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb7gt37v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    //long arr = new long[];\n    int\
    \ index;\n    int minimum = arr[0];\n    long minimumIndex = 0;\n    long[] ans\
    \ = new long[2];\n    for(int i = 0; i < arr.length; i++)\n    {\n        if(arr[i]\
    \ % 2 == 0)\n        {\n            index = i;\n            if(arr[i] < minimum)\n\
    \            {\n                minimum = arr[i];\n                minimumIndex\
    \ = i;\n            }\n        }\n    }\n    if(minimum % 2 == 0)\n    {\n   \
    \     ans[0] = minimum;\n        ans[1] = minimumIndex;\n    }\n    return ans;\n\
    }\n// pluck([4L, 2L, 3L])\n// pluck([1L, 2L, 3L])\n// pluck([])\n// pluck([5L,\
    \ 0L, 3L, 0L, 4L, 2L])\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2g9cy77g.d(42): Error: cannot implicitly convert expression `arr[0]`
    of type `long` to `int`

    /tmp/tmp2g9cy77g.d(52): Error: cannot implicitly convert expression `arr[cast(ulong)i]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2g9cy77g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minValue = min(arr);\n    if(minValue\
    \ & 1)\n        return new long[0];\n    size_t minIndex = 0;\n    for(size_t\
    \ i = 0; i < arr.length; i++)\n    {\n        if(arr[i] == minValue)\n       \
    \ {\n            minIndex = i;\n            break;\n        }\n    }\n    return\
    \ tuple(minValue, minIndex);\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0mkjxzy1.d(40): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp0mkjxzy1.d(52): Error: cannot implicitly convert expression `tuple(minValue,
    minIndex)` of type `Tuple!(long, ulong)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0mkjxzy1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    enum PluckResult { FAIL, PASS(long\
    \ smallestIndex, long smallestValue) }\n    // The longest branch has a length\
    \ of 10000.\n    static PluckResult[10000] dp = void;\n    static int maxLength\
    \ = 0;\n    static int nodeCount = 0;\n    static long[10000] values = void;\n\
    \    static int[10000] indices = void;\n    static bool[10000] even = void;\n\
    \    static int[] lengths = void;\n    static int[] branched = void;\n    static\
    \ int[] branches = void;\n    static int[] first = void;\n    static int[] last\
    \ = void;\n    static if (arr.length == 0)\n    {\n        return [0L, 0L];\n\
    \    }\n    static assert(arr.length <= 10000);\n    static foreach (i, value;\
    \ arr)\n    {\n        assert(value >= 0);\n        values[i] = value;\n     \
    \   indices[i] = i;\n        even[i] = value % 2 == 0;\n    }\n    void recursive(int\
    \ i, int length) {\n        nodeCount++;\n        lengths[i] = length;\n     \
    \   if (length > maxLength)\n        {\n            maxLength = length;\n    \
    \    }\n        if (i + 1 < arr.length && arr[i] < arr[i + 1])\n        {\n  \
    \          if (branched[i] == 0)\n            {\n                branches[i] =\
    \ i + 1;\n                first[i] = i + 1;\n                last[i] = i + 1;\n\
    \            }\n            else\n            {\n                last[i] = i +\
    \ 1;\n            }\n            branched[i]++;\n            recursive(i + 1,\
    \ length + 1);\n        }\n        if (i + 2 < arr.length && arr[i] < arr[i +\
    \ 2])\n        {\n            if (branched[i] == 0)\n            {\n         \
    \       branches[i] = i + 2;\n                first[i] = i + 2;\n            \
    \    last[i] = i + 2;\n            }\n            else\n            {\n      \
    \          last[i] = i + 2;\n            }\n           \nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpngn1rdie.d(40): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpngn1rdie.d(40): Error: no identifier for declarator `PASS(long smallestIndex,
    long smallestValue)`

    /tmp/tmpngn1rdie.d(40): Error: type only allowed if anonymous enum and no enum
    type

    /tmp/tmpngn1rdie.d(40): Error: if type, there must be an initializer

    /tmp/tmpngn1rdie.d(100): Error: found `unittest` instead of statement

    /tmp/tmpngn1rdie.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpngn1rdie.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpngn1rdie.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    long[] ret = [arr[0], 0];\n    for (long i = 1; i < arr.length; i++)\n\
    \    {\n        if (arr[i] & 1)\n            continue;\n        if (arr[i] < ret[0])\n\
    \            ret = [arr[i], i];\n    }\n    if (ret[0] & 1)\n        return [];\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyvc70p2h.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x42877d]

    ??:? void tmpyvc70p2h.__unittest_L54_C1() [0x4280e9]

    ??:? void tmpyvc70p2h.__modtest() [0x4284fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b66e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430801]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43078d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b645]

    ??:? runModuleUnitTests [0x42c5b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c40]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = [ 0L, 0L ];\n   \
    \ bool isFirst = true;\n    int i = 0;\n    foreach(elem; arr)\n    {\n      \
    \  if(elem % 2 == 0)\n        {\n            if(isFirst)\n            {\n    \
    \            result[0] = elem;\n                result[1] = i;\n             \
    \   isFirst = false;\n            }\n            else\n            {\n       \
    \         if(elem < result[0])\n                {\n                    result[0]\
    \ = elem;\n                    result[1] = i;\n                }\n           \
    \ }\n        }\n        i++;\n    }\n    return result;\n}\n/*\n    version 2\n\
    */\nlong[] pluck2(long[] arr) \n{\n    long[] result = [ 0L, 0L ];\n    bool isFirst\
    \ = true;\n    int i = 0;\n    foreach(elem; arr)\n    {\n        if(elem % 2\
    \ == 0)\n        {\n            if(isFirst)\n            {\n                result[0]\
    \ = elem;\n                result[1] = i;\n                isFirst = false;\n\
    \            }\n            else\n            {\n                if(elem < result[0])\n\
    \                {\n                    result[0] = elem;\n                  \
    \  result[1] = i;\n                }\n            }\n        }\n        i++;\n\
    \    }\n    return result;\n}\n/*\n    version 3\n*/\nlong[] pluck3(long[] arr)\
    \ \n{\n    long[] result = [ 0L, 0L ];\n    bool isFirst = true;\n    int i =\
    \ 0;\n    foreach(elem; arr)\n    {\n        if(elem % 2 == 0)\n        {\n  \
    \          if(isFirst)\n            {\n                result[0] = elem;\n   \
    \             result[1] = i;\n                isFirst = false;\n            }\n\
    \            else\n            {\n                if(elem < result[0])\n     \
    \           {\n                    result[0] = elem;\n                    result[1]\
    \ = i;\n                }\n            }\n        }\n        i++;\n    }\n   \
    \ return result;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ly9gn6k.d(127): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ly9gn6k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.array;\n    long[] treeNodes=arr.filter!(a=>a%2==0).sort.dup;\n\
    \    if(treeNodes.length==0) return [];\n    else \n    {\n        long smallest=treeNodes[0];\n\
    \        foreach(i,node; arr)\n        {\n            if(node==smallest)\n   \
    \         {\n                long[] res=[node,i];\n                return res;\n\
    \            }\n        }\n    }\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdirs22mw.d(41): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdirs22mw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = int.max;\n    long index\
    \ = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] %\
    \ 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if (min == int.max)\n    {\n        return [];\n\
    \    }\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long min = arr[0];\n    int index = 0;\n    bool found = false;\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n\
    \        {\n            found = true;\n            if (arr[i] < min)\n       \
    \     {\n                min = arr[i];\n                index = i;\n         \
    \   }\n        }\n    }\n    if (found)\n        return [min, index];\n    else\n\
    \        return new long[0];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp38jrzz0l.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmp38jrzz0l.__unittest_L62_C1() [0x428081]

    ??:? void tmp38jrzz0l.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b662]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d9c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430879]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b639]

    ??:? runModuleUnitTests [0x42c5a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length==0) return new long[0];\n\
    \    long smallestIndex=0;\n    long smallestEven=arr[0];\n    for (size_t i=0;\
    \ i<arr.length; i++)\n    {\n        if (arr[i]%2==0)\n        {\n           \
    \ if (arr[i]<smallestEven)\n            {\n                smallestEven=arr[i];\n\
    \                smallestIndex=i;\n            }\n        }\n    }\n    if (smallestEven==arr[0])\
    \ return new long[0];\n    return [smallestEven, smallestIndex];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaokpf0kw.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x428735]

    ??:? void tmpaokpf0kw.__unittest_L57_C1() [0x4280a1]

    ??:? void tmpaokpf0kw.__modtest() [0x4284b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b682]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43090d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430dbc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430899]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b659]

    ??:? runModuleUnitTests [0x42c5c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    int\
    \ min = int.max;\n    int minIndex = int.max;\n    int count = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n\
    \            if (arr[i] < min)\n            {\n                min = arr[i];\n\
    \                minIndex = i;\n            }\n            count++;\n        }\n\
    \    }\n    res[0] = min;\n    res[1] = minIndex;\n    if (count == 0)\n    {\n\
    \        res[0] = 0;\n        res[1] = 0;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz21af6bh.d(50): Error: cannot implicitly convert expression `arr[cast(ulong)i]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz21af6bh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] ret = new long[2];\n    long\
    \ min_even = long.max;\n    long min_idx = long.max;\n    if (arr.length == 0)\
    \ return ret;\n    foreach (idx,val; arr)\n    {\n        if (val % 2 == 0)\n\
    \        {\n            if (val < min_even)\n            {\n                min_even\
    \ = val;\n                min_idx = idx;\n            }\n        }\n    }\n  \
    \  if (min_even == long.max)\n    {\n        return ret;\n    }\n    ret[0] =\
    \ min_even;\n    ret[1] = min_idx;\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2x8utacd.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmp2x8utacd.__unittest_L63_C1() [0x4280ca]

    ??:? void tmp2x8utacd.__modtest() [0x42847c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b64a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430861]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b621]

    ??:? runModuleUnitTests [0x42c58d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bc0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long smallest = long.max;\n    long index = long.max;\n  \
    \  for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 &&\
    \ arr[i] < smallest)\n        {\n            smallest = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if (smallest == long.max)\n        return new long[0];\n\
    \    return [smallest, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [];\n\
    \    foreach (i, item; arr)\n    {\n        if (item % 2 == 0) return [item, i];\n\
    \    }\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpddbdsr7a.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x428685]

    ??:? void tmpddbdsr7a.__unittest_L47_C1() [0x427f6a]

    ??:? void tmpddbdsr7a.__modtest() [0x428408]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c66f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b502]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430695]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430621]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d9]

    ??:? runModuleUnitTests [0x42c445]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ad4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n  long min =  long.max;\n  long min_idx\
    \ = long.max;\n  foreach(idx, el; arr)\n  {\n    if(el > 0 && el % 2 == 0 && el\
    \ < min)\n    {\n      min = el;\n      min_idx = idx;\n    }\n  }\n  if(min !=\
    \ long.max)\n  {\n    return [min, min_idx];\n  }\n  return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps5s2w7zs.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286a5]

    ??:? void tmps5s2w7zs.__unittest_L56_C1() [0x428118]

    ??:? void tmps5s2w7zs.__modtest() [0x428428]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b522]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4f9]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428af4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    foreach(d; 0 .. arr.length)\n   \
    \ {\n        if(arr[d] % 2 == 0)\n        {\n            return typeof(long[])([arr[d],\
    \ d]);\n        }\n    }\n    return typeof(long[])();\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg99yawsh.d(44): Error: found `[` when expecting `.` following long

    /tmp/tmpg99yawsh.d(44): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpg99yawsh.d(47): Error: found `[` when expecting `.` following long

    /tmp/tmpg99yawsh.d(47): Error: found `]` when expecting identifier following `long`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg99yawsh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] ret = {};\n    foreach(idx,\
    \ el; arr)\n    {\n        if(el % 2 == 0)\n        {\n            if(ret.length\
    \ == 0)\n            {\n                ret = [el, idx];\n            }\n    \
    \        else if(el < ret[0])\n            {\n                ret = [el, idx];\n\
    \            }\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp18pmgw59.d(40): Error: a struct is not a valid initializer for
    a `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18pmgw59.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [];\n\
    \    auto result = tuple(arr[0], 0L);\n    foreach (i, v; arr) \n    {\n     \
    \   if (v % 2 == 0 && result[0] % 2 == 0) \n        {\n            if (v < result[0])\
    \ \n            {\n                result = tuple(v, i);\n            }\n    \
    \    } \n        else if (v % 2 == 0 && result[0] % 2 != 0) \n        {\n    \
    \        result = tuple(v, i);\n        }\n    }\n    if (result[0] % 2 != 0)\
    \ return [];\n    return [result[0], result[1]];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm.comparison :\
    \ min;\n    import std.typecons : tuple;\n    if(arr.length == 0)\n        return\
    \ [];\n    auto min_even = tuple(arr[0], 0);\n    foreach(immutable i, element;\
    \ arr)\n    {\n        if(element % 2 == 0)\n        {\n            min_even =\
    \ min(min_even, tuple(element, i));\n        }\n    }\n    return [min_even[0],\
    \ min_even[1]];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/comparison.d(1686):
    Error: incompatible types for `(_param_0) : (_param_1)`: `Tuple!(long, int)` and
    `Tuple!(long, immutable(ulong))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/comparison.d(1686):
    Error: cannot return non-void from `void` function

    /tmp/tmpuy7610y0.d(49): Error: template instance `std.algorithm.comparison.min!(Tuple!(long,
    int), Tuple!(long, immutable(ulong)))` error instantiating

    /tmp/tmpuy7610y0.d(49): Error: expression `min(min_even, tuple(element, i))` is
    `void` and has no value

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuy7610y0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    bool is_empty(long[] arr) @property\
    \ { return arr.length == 0; }\n    long[] get_smallest_even(long[] arr) @property\
    \ \n    {\n        immutable result = [];\n        immutable index = -1;\n   \
    \     foreach(immutable i, immutable val; arr)\n        {\n            if(val\
    \ % 2 == 0)\n            {\n                if(result.length == 0) \n        \
    \        {\n                    result ~= val;\n                    index = i;\n\
    \                }\n                else if(val < result[0])\n               \
    \ {\n                    result[0] = val;\n                    index = i;\n  \
    \              }\n            }\n        }\n        if(result.length == 0) return\
    \ [];\n        return [result[0], index];\n    }\n    immutable res = get_smallest_even(arr);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr32seg8b.d(51): Error: cannot modify `immutable` expression `result`

    /tmp/tmpr32seg8b.d(52): Error: cannot modify `immutable` expression `index`

    /tmp/tmpr32seg8b.d(54): Error: void has no value

    /tmp/tmpr32seg8b.d(54): Error: incompatible types for `(val) < (result[0])`: `immutable(long)`
    and `immutable(void)`

    /tmp/tmpr32seg8b.d(56): Error: cannot modify `immutable` expression `result[0]`

    /tmp/tmpr32seg8b.d(57): Error: cannot modify `immutable` expression `index`

    /tmp/tmpr32seg8b.d(62): Error: cannot implicitly convert expression `result[0]`
    of type `immutable(void)` to `immutable(int)`

    /tmp/tmpr32seg8b.d(64): Error: cannot implicitly convert expression `get_smallest_even(arr)`
    of type `long[]` to `immutable(long[])`

    /tmp/tmpr32seg8b.d(65): Error: cannot implicitly convert expression `res` of type
    `immutable(long[])` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr32seg8b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long index = -1;\n    long ret =\
    \ 10_000_000;\n    foreach(i, v; arr)\n    {\n        if (v % 2 == 0 && v < ret)\n\
    \        {\n            ret = v;\n            index = i;\n        }\n    }\n \
    \   if (index == -1) return typeof(ret).init;\n    return [ret, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkrmx251m.d(50): Error: cannot implicitly convert expression `0L`
    of type `long` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkrmx251m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestEven = long.max;\n \
    \   long smallestIndex = long.max;\n    size_t index = 0;\n    bool hasEven =\
    \ false;\n    foreach(value; arr)\n    {\n        if(value % 2 == 0)\n       \
    \ {\n            hasEven = true;\n            if(value < smallestEven)\n     \
    \       {\n                smallestEven = value;\n                smallestIndex\
    \ = index;\n            }\n        }\n        index++;\n    }\n    if(hasEven)\n\
    \    {\n        return tuple(smallestEven, smallestIndex);\n    }\n    else\n\
    \    {\n        return tuple();\n    }\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjmg4x4ez.d(59): Error: cannot implicitly convert expression `tuple(smallestEven,
    smallestIndex)` of type `Tuple!(long, long)` to `long[]`

    /tmp/tmpjmg4x4ez.d(63): Error: cannot implicitly convert expression `tuple()`
    of type `Tuple!()` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjmg4x4ez.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    struct Node\n    {\n        long\
    \ value;\n        size_t index;\n    }\n    const(long) arr2 = arr;\n    immutable\
    \ nodes = std.typecons.tuple(map!(a => Node(a, i))(arr2, 0 .. arr2.length));\n\
    \    auto least = min(filter!(a => a.value % 2 == 0)(nodes));\n    if (least)\n\
    \        return [least.value, least.index];\n    return [];\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2toclupx.d(46): Error: found `..` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2toclupx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // check length is greater than zero\n\
    \    if (arr.length > 0)\n    {\n        size_t[] indices = ();\n        long\
    \ minimum = -1;\n        long index = -1;\n        // find smallest even value\n\
    \        for (size_t i = 0; i < arr.length; i++)\n        {\n            if (arr[i]\
    \ % 2 == 0)\n            {\n                if (minimum == -1)\n             \
    \   {\n                    minimum = arr[i];\n                    index = i;\n\
    \                }\n                else if (arr[i] < minimum)\n             \
    \   {\n                    minimum = arr[i];\n                    index = i;\n\
    \                }\n            }\n        }\n        // If no even values\n \
    \       if (minimum == -1)\n        {\n            return [];\n        }\n   \
    \     // If multiple values are smallest, return lowest index\n        if (arr.count!(minimum).length\
    \ > 1)\n        {\n            indices = arr.indicesOf!(minimum);\n          \
    \  index = indices[0];\n        }\n        return [minimum, index];\n    }\n \
    \   else\n    {\n        return [];\n    }\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg3emmjrv.d(43): Error: expression expected, not `)`

    /tmp/tmpg3emmjrv.d(43): Error: found `;` when expecting `)`

    /tmp/tmpg3emmjrv.d(44): Error: semicolon expected, not `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg3emmjrv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164281
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min_even_value = cast(long)\
    \ ulong.max;\n    long min_even_value_idx = -1;\n    foreach(i, value; arr)\n\
    \    {\n        if(value % 2 == 0 && value < min_even_value)\n        {\n    \
    \        min_even_value = value;\n            min_even_value_idx = i;\n      \
    \  }\n    }\n    if(min_even_value_idx == -1)\n        return [];\n    return\
    \ [min_even_value, min_even_value_idx];\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9nyr7h5i.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x428695]

    ??:? void tmp9nyr7h5i.__unittest_L54_C1() [0x427f76]

    ??:? void tmp9nyr7h5i.__modtest() [0x428414]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c67f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b512]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b54]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430631]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4e9]

    ??:? runModuleUnitTests [0x42c455]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ae4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    else\n    {\n        long[] r = new long[2];\n        long\
    \ smallestEvenValue = 2;\n        long smallestEvenValueIndex = -1;\n        long\
    \ currentNodeValue;\n        for (long i = 0; i < arr.length; i++)\n        {\n\
    \            currentNodeValue = arr[i];\n            if (currentNodeValue % 2\
    \ == 0)\n            {\n                if (currentNodeValue < smallestEvenValue)\n\
    \                {\n                    smallestEvenValue = currentNodeValue;\n\
    \                    smallestEvenValueIndex = i;\n                }\n        \
    \    }\n        }\n        if (smallestEvenValueIndex == -1)\n            return\
    \ new long[0];\n        else\n        {\n            r[0] = smallestEvenValue;\n\
    \            r[1] = smallestEvenValueIndex;\n            return r;\n        }\n\
    \    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuxvtlski.d(74): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmpuxvtlski.__unittest_L70_C1() [0x427fe2]

    ??:? void tmpuxvtlski.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b64a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430861]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b621]

    ??:? runModuleUnitTests [0x42c58d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bc0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\n    auto result = tuple(long.max, long.max);\n    for\
    \ (i, elem; arr.length > i; ++i) \n    {\n        if (elem % 2 == 0 && elem <\
    \ result[0]) \n        {\n            result = tuple(elem, i);\n        }\n  \
    \  }\n    if (result[0] == long.max) \n    {\n        return [];\n    }\n    return\
    \ [result[0], result[1]];\n}\nunittest\n{\n    alias candidate = pluck;\n\n  \
    \  assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqceb_l13.d(45): Error: undefined identifier `i`

    /tmp/tmpqceb_l13.d(45): Error: undefined identifier `elem`

    /tmp/tmpqceb_l13.d(45): Error: undefined identifier `i`

    /tmp/tmpqceb_l13.d(45): Error: undefined identifier `i`

    /tmp/tmpqceb_l13.d(47): Error: undefined identifier `elem`

    /tmp/tmpqceb_l13.d(47): Error: undefined identifier `elem`

    /tmp/tmpqceb_l13.d(49): Error: undefined identifier `elem`

    /tmp/tmpqceb_l13.d(49): Error: undefined identifier `i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqceb_l13.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long[] even = new long[arr.length];\n    int x = 0;\n    for\
    \ (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n    \
    \    {\n            even[x] = arr[i];\n            x++;\n        }\n    }\n  \
    \  if (x == 0)\n        return new long[0];\n    long[] even2 = new long[x];\n\
    \    for (int j = 0; j < x; j++)\n    {\n        even2[j] = even[j];\n    }\n\
    \    long min = min(even2);\n    long[] res = new long[2];\n    res[0] = min;\n\
    \    for (int k = 0; k < arr.length; k++)\n    {\n        if (arr[k] == min)\n\
    \        {\n            res[1] = k;\n            break;\n        }\n    }\n  \
    \  return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprndcxwr1.d(59): Error: undefined identifier `min`, did you mean
    function `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprndcxwr1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // Create the first element in the\
    \ returned tuple.\n    long[] smallest = tuple(arr[0], 0);\n    // Loop through\
    \ the array\n    foreach(l; arr) \n    {\n        // Is this element even and\
    \ less than the value in the tuple?\n        if(l % 2 == 0 && l < smallest[0])\
    \ \n        {\n            // Yes, replace the tuple element with the current\
    \ value.\n            smallest[0] = l;\n        }\n    }\n    // If the tuple\
    \ element is the same as the first element in the array, we have not found any\
    \ even numbers.\n    return arr[0] == smallest[0] ? [] : smallest;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfxwfdb7g.d(41): Error: cannot implicitly convert expression `tuple(arr[0],
    0)` of type `Tuple!(long, int)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfxwfdb7g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n  if (arr.length == 0)\n    return new\
    \ long[0];\n  \n  auto r = arr.filter!(x => x % 2 == 0);\n  if (r.length == 0)\n\
    \    return new long[0];\n  \n  // sort r, then return the first two elements\n\
    \  r.sort;\n  auto i = arr.indexOf(r[0]);\n  return new long[](r[0], i);\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxqya7l9n.d(43): Error: no property `filter` for type `long[]`

    /tmp/tmpxqya7l9n.d(49): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxqya7l9n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // 1. find the first even number\n\
    \    // 2. if there is no even number, return empty array\n    // 3. else return\
    \ the first element with the smallest even number\n    // 4. since we are not\
    \ allowed to use library functions\n    //    we will have to implement a function\
    \ to get the index of the minimum element\n    // 5. the implementation of get_index_of_min()\
    \ can be found at the end of this file\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwmkzalol.d(46): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwmkzalol.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    /*\n        Since there is no requirement\
    \ to sort the array, I will use a greedy algorithm \n        to find the first\
    \ smallest even number.\n        I will use a temporary array with size of 5 to\
    \ reduce the access time, this array will\n        will be allocated when first\
    \ needed, and it will be used to store the smallest even number\n        and its\
    \ index.\n        The temporary array will have the following structure:\n   \
    \     [\n            smallest_even_number, // at index 0\n            index_of_smallest_even_number,\
    \ // at index 1\n            smallest_odd_number, // at index 2\n            index_of_smallest_odd_number,\
    \ // at index 3\n            count_of_even_numbers // at index 4\n        ]\n\
    \    */\n    long[] tmp = new long[5];\n    // initialize the temporary array\
    \ with large numbers\n    tmp[0] = 10000L;\n    tmp[1] = 10000L;\n    tmp[2] =\
    \ 10000L;\n    tmp[3] = 10000L;\n    tmp[4] = 0L;\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ef6go7y.d(62): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ef6go7y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = [long.max, 0L];\n  \
    \  auto max = res[0];\n    int index = 0;\n    auto even = filter!((x) => x %\
    \ 2 == 0)(arr);\n    foreach(i, x; even)\n    {\n        if(x < max)\n       \
    \ {\n            max = x;\n            index = i;\n        }\n    }\n    if(max\
    \ != long.max)\n    {\n        res[0] = max;\n        res[1] = index;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3f28roxg.d(43): Error: template instance `filter!((x) => x % 2
    == 0)` template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3f28roxg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto min(long.max);\n    bool hasEven\
    \ = false;\n    int counter = -1;\n    foreach(element; arr)\n    {\n        counter++;\n\
    \        if(element % 2 == 0)\n        {\n            hasEven = true;\n      \
    \      if(element < min)\n            {\n                min = element;\n    \
    \        }\n        }\n    }\n    if(hasEven)\n    {\n        return [min, arr.indexOf(min)];\n\
    \    }\n    else\n    {\n        return [];\n    }\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5unmycrz.d(40): Error: unexpected `(` in declarator

    /tmp/tmp5unmycrz.d(40): Error: found `.` when expecting `)`

    /tmp/tmp5unmycrz.d(40): Error: no identifier for declarator `min(long)`

    /tmp/tmp5unmycrz.d(40): Error: semicolon expected following function declaration

    /tmp/tmp5unmycrz.d(40): Error: found `)` when expecting `;` following statement

    /tmp/tmp5unmycrz.d(40): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5unmycrz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // TODO\n    return null;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp364dinly.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285bd]

    ??:? void tmp364dinly.__unittest_L43_C1() [0x427ea2]

    ??:? void tmp364dinly.__modtest() [0x428340]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430559]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]

    ??:? runModuleUnitTests [0x42c37d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a0c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long[] res = [0L, 0L]; \n    long\
    \ val = 0;\n    foreach(idx, val; arr)\n    {\n        if(val % 2 == 0)\n    \
    \    {\n            res[0] = val;\n            res[1] = idx;\n            break;\n\
    \        }\n    }\n    foreach(idx, val; arr)\n    {\n        if(val % 2 == 0\
    \ && val < res[0])\n        {\n            res[0] = val;\n            res[1] =\
    \ idx;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0zz8nqxo.d(42): Error: variable `val` is shadowing variable `tmp0zz8nqxo.pluck.val`

    /tmp/tmp0zz8nqxo.d(51): Error: variable `val` is shadowing variable `tmp0zz8nqxo.pluck.val`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0zz8nqxo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ long[].init;\n    immutable long[] even = arr.filter!(x => x % 2 == 0);\n  \
    \  if (even.length == 0)\n        return long[].init;\n    return [even.front,\
    \ arr.findIndex!(x => x == even.front)];\n}\n/*\nimport std.algorithm;\nimport\
    \ std.array;\nimport std.conv;\nimport std.range;\nimport std.stdio;\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphc9bm6iq.d(41): Error: found `[` when expecting `.` following long

    /tmp/tmphc9bm6iq.d(41): Error: found `]` when expecting identifier following `long`.

    /tmp/tmphc9bm6iq.d(44): Error: found `[` when expecting `.` following long

    /tmp/tmphc9bm6iq.d(44): Error: found `]` when expecting identifier following `long`.

    /tmp/tmphc9bm6iq.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphc9bm6iq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto evens = arr.filter!(x => x %\
    \ 2 == 0).sort().uniq;\n    if (evens.length < 1)\n        return [];\n    return\
    \ [evens[0], arr.indexOf(evens[0])];\n}\n// http://ideone.com/rvkxj7\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb2bduf01.d(40): Error: no property `filter` for type `long[]`

    /tmp/tmpb2bduf01.d(43): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb2bduf01.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] plucked = [];\n    long i;\n\
    \    foreach(element; arr)\n    {\n        if(element % 2 == 0)\n        {\n \
    \           plucked ~= element;\n        }\n    }\n    long lowestValue = min(plucked);\n\
    \    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] == lowestValue)\n\
    \        {\n            plucked = [lowestValue, i];\n            break;\n    \
    \    }\n    }\n    return plucked;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzax_b6t7.d(49): Error: undefined identifier `min`, did you mean
    function `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzax_b6t7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[0];\n    long\
    \ min_index = long.max;\n    long min_value = long.max;\n    foreach(index, value;\
    \ arr)\n    {\n        if (value % 2 == 0)\n        {\n            if (value <\
    \ min_value)\n            {\n                min_value = value;\n            \
    \    min_index = index;\n            }\n        }\n    }\n    if (min_value !=\
    \ long.max)\n    {\n        res = [min_value, min_index];\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return typeof(arr).init;\n\
    \    auto min = arr[0];\n    foreach (i, e; arr) {\n        if (e < min) min =\
    \ e;\n    }\n    long mineven;\n    foreach (i, e; arr) {\n        if (e == min)\
    \ {\n            if (e % 2 == 0) {\n                mineven = i;\n           \
    \     break;\n            }\n        }\n    }\n    if (arr[0] % 2 == 0) {\n  \
    \      return [min, mineven];\n    }\n    return typeof(arr).init;\n}\n/*\n===\
    \ OK ===\nTest: [0L, 3L, 0L, 0L, 0L, 5L, 7L, 6L, 2L, 1L, 0L, 1L, 2L, 5L, 7L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 1L, 4L, 5L, 2L, 1L, 4L, 1L, 4L, 4L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 2L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 2L, 8L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,\
    \ 8L, 8L, 8L, 8L, 8L, 8L\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd1a2m3me.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd1a2m3me.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // Check if the array is empty\n\
    \    if (arr.length == 0) return new long[0];\n    \n    // Remove all non-even\
    \ values from the given array\n    long[] evens = removeIf!(a => a & 1)(arr);\n\
    \    \n    // Check if the array still has values\n    if (evens.length == 0)\
    \ return new long[0];\n    \n    // Find the minimum value\n    long min = min(evens);\n\
    \    \n    // Find the index of the minimum value and return it as part of an\
    \ array\n    return [min, indexOf(evens, min)];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2yqhwgng.d(44): Error: template instance `removeIf!((a) => a &
    1)` template `removeIf` is not defined

    /tmp/tmp2yqhwgng.d(50): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp2yqhwgng.d(53): Error: undefined identifier `indexOf`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2yqhwgng.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    if\
    \ (arr.length > 0)\n    {\n        long minEven = int.max;\n        long minIndex\
    \ = int.max;\n        for (int i = 0; i < arr.length; i++)\n        {\n      \
    \      if (arr[i] % 2 == 0 && arr[i] < minEven)\n            {\n             \
    \   minEven = arr[i];\n                minIndex = i;\n            }\n        }\n\
    \        if (minEven != int.max)\n        {\n            res[0] = minEven;\n \
    \           res[1] = minIndex;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppmjm_k92.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42871d]

    ??:? void tmppmjm_k92.__unittest_L61_C1() [0x4280ee]

    ??:? void tmppmjm_k92.__modtest() [0x4284a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b66a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308f5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430da4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430881]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b641]

    ??:? runModuleUnitTests [0x42c5ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[];\n    auto min = new long[2];\n    min[0] = 10000L;\n    foreach\
    \ (a;arr) \n    {\n        if (a > 0 && a % 2 == 0 && a < min[0]) \n        {\n\
    \            min[0] = a;\n            min[1] = cast(long)arr.indexOf(a);\n   \
    \     }\n    }\n    if (min[0] != 10000L)\n        return min;\n    return new\
    \ long[];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa3tgz3bo.d(41): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpa3tgz3bo.d(49): Error: no property `indexOf` for type `long[]`

    /tmp/tmpa3tgz3bo.d(54): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa3tgz3bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long minEven = -1;\n    int minEvenIndex = -1;\n   \
    \ foreach (i, e; arr)\n    {\n        if (e % 2 == 0)\n        {\n           \
    \ if (minEven == -1 || e < minEven)\n            {\n                minEven =\
    \ e;\n                minEvenIndex = i;\n            }\n        }\n    }\n   \
    \ \n    if (minEvenIndex == -1)\n        return new long[0];\n    \n    return\
    \ new long[](minEven, minEvenIndex);\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprcr28fpa.d(52): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmprcr28fpa.d(60): Error: too many arguments for array

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcr28fpa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] pr = new long[2];\n    long\
    \ m = (long.max)();\n    int s = arr.length;\n    for (int i = 0; i < s; i++)\n\
    \    {\n        if (arr[i] < m && arr[i] % 2 == 0)\n        {\n            m =\
    \ arr[i];\n            pr[0] = m;\n            pr[1] = i;\n        }\n    }\n\
    \    if (pr[0] != (long.max)()) return pr;\n    return new long[0];\n}\nlong[]\
    \ pluck(long[] arr) \n{\n    long[] pr = new long[2];\n    long m = (long.max)();\n\
    \    int s = arr.length;\n    for (int i = 0; i < s; i++)\n    {\n        if (arr[i]\
    \ < m && arr[i] % 2 == 0)\n        {\n            m = arr[i];\n            pr[0]\
    \ = m;\n            pr[1] = i;\n        }\n    }\n    if (pr[0] != (long.max)())\
    \ return pr;\n    return new long[0];\n}\nlong[] pluck(long[] arr) \n{\n    long[]\
    \ pr = new long[2];\n    long m = (long.max)();\n    int s = arr.length;\n   \
    \ for (int i = 0; i < s; i++)\n    {\n        if (arr[i] < m && arr[i] % 2 ==\
    \ 0)\n        {\n            m = arr[i];\n            pr[0] = m;\n           \
    \ pr[1] = i;\n        }\n    }\n    if (pr[0] != (long.max)()) return pr;\n  \
    \  return new long[0];\n}\nlong[] pluck(long[] arr) \n{\n    long[] pr = new long[2];\n\
    \    long m = (long.max)();\n    int s = arr.length;\n    for (int i = 0; i <\
    \ s; i++)\n    {\n        if (arr[i] < m && arr[i] % 2 == 0)\n        {\n    \
    \        m\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmpbldnj2.d(99): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpmpbldnj2.d(112): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpmpbldnj2.d(112): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpmpbldnj2.d(112): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmpbldnj2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minVal = -1;\n    long minIndex\
    \ = -1;\n    long currentVal = -1;\n    long currentIndex = -1;\n    bool hasEvenNumber\
    \ = false;\n    foreach(idx, ref element; arr)\n    {\n        currentVal = element;\n\
    \        currentIndex = idx;\n        if(currentVal % 2 == 0)\n        {\n   \
    \         hasEvenNumber = true;\n            if(minVal == -1 || currentVal < minVal)\n\
    \            {\n                minVal = currentVal;\n                minIndex\
    \ = currentIndex;\n            }\n        }\n    }\n    if(hasEvenNumber)\n  \
    \  {\n        return [minVal, minIndex];\n    }\n    else\n    {\n        return\
    \ [];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4x5ql3ul.d(44): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4x5ql3ul.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    long min = 2147483647;\n    long min_index = -1;\n    for (int i = 0; i <\
    \ arr.length; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min) {\n       \
    \     min = arr[i];\n            min_index = i;\n        }\n    }\n    if (min_index\
    \ == -1) return new long[0];\n    return new long[] { min, min_index };\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph7jw8mfc.d(50): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmph7jw8mfc.d(50): Error: found `}` when expecting `;` following statement

    /tmp/tmph7jw8mfc.d(50): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph7jw8mfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long[] ret = new long[2];\n    long min_even = arr[0];\n\
    \    long min_even_idx = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] < min_even && arr[i] % 2 == 0)\n        {\n            min_even\
    \ = arr[i];\n            min_even_idx = i;\n        }\n    }\n    if (min_even\
    \ % 2 == 0)\n    {\n        ret[0] = min_even;\n        ret[1] = min_even_idx;\n\
    \    }\n    return ret;\n}\n// BEGIN: Test Code\npublic class Test\n{\n    public\
    \ static void main(String[] args)\n    {\n        Test t = new Test();\n     \
    \   t.test();\n    }\n    public void test()\n    {\n        assert(arrayEq(pluck(new\
    \ long[]{4L, 2L, 3L}), new long[]{2L, 1L}));\n        assert(arrayEq(pluck(new\
    \ long[]{1L, 2L, 3L}), new long[]{2L, 1L}));\n        assert(arrayEq(pluck(new\
    \ long[]{}), new long[]{}));\n        assert(arrayEq(pluck(new long[]{5L, 0L,\
    \ 3L, 0L, 4L, 2L}), new long[]{0L, 1L}));\n    }\n    public boolean arrayEq(long[]\
    \ arr1, long[] arr2)\n    {\n        if (arr1.length != arr2.length)\n       \
    \     return false;\n        for (long i = 0; i < arr1.length; i++)\n        {\n\
    \            if (arr1[i] != arr2[i])\n                return false;\n        }\n\
    \        return true;\n    }\n}\n// END: Test Code\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_3526j1t.d(71): Error: found `{` when expecting `,`

    /tmp/tmp_3526j1t.d(71): Error: found `}` when expecting `,`

    /tmp/tmp_3526j1t.d(71): Error: found `{` when expecting `,`

    /tmp/tmp_3526j1t.d(71): Error: found `}` when expecting `,`

    /tmp/tmp_3526j1t.d(72): Error: found `{` when expecting `,`

    /tmp/tmp_3526j1t.d(72): Error: found `}` when expecting `,`

    /tmp/tmp_3526j1t.d(72): Error: found `{` when expecting `,`

    /tmp/tmp_3526j1t.d(72): Error: found `}` when expecting `,`

    /tmp/tmp_3526j1t.d(73): Error: found `{` when expecting `,`

    /tmp/tmp_3526j1t.d(73): Error: expression expected, not `}`

    /tmp/tmp_3526j1t.d(73): Error: found `{` when expecting `,`

    /tmp/tmp_3526j1t.d(73): Error: expression expected, not `}`

    /tmp/tmp_3526j1t.d(74): Error: found `{` when expecting `,`

    /tmp/tmp_3526j1t.d(74): Error: found `}` when expecting `,`

    /tmp/tmp_3526j1t.d(74): Error: found `{` when expecting `,`

    /tmp/tmp_3526j1t.d(74): Error: found `}` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_3526j1t.d", '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto temp = [0L, 0L];\n    if(empty(arr))\n\
    \        return [];\n    foreach(i, val; arr)\n    {\n        if(val % 2 == 0\
    \ && val < temp[0])\n        {\n            temp[0] = val;\n            temp[1]\
    \ = i;\n        }\n    }\n    if(temp[0] == 0)\n        return [];\n    return\
    \ temp;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9li4ov4h.d(41): Error: undefined identifier `empty`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9li4ov4h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long evenMin = long.max;\n    long\
    \ evenIndex = -1;\n    foreach(e; arr)\n    {\n        if(isEven(e) && e < evenMin)\n\
    \        {\n            evenMin = e;\n            evenIndex = index(arr, e);\n\
    \        }\n    }\n    return evenIndex != -1 ? [evenMin, evenIndex] : [];\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp26ien1l8.d(44): Error: undefined identifier `isEven`

    /tmp/tmp26ien1l8.d(47): Error: undefined identifier `index`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26ien1l8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    if (arr.length == 0)\n        return\
    \ arr;\n    \n    long min_value = long.max;\n    long min_index = long.max;\n\
    \    long even_value = long.max;\n    long even_index = long.max;\n    \n    foreach(int\
    \ i, long value; arr)\n    {\n        if (value < min_value)\n        {\n    \
    \        min_value = value;\n            min_index = i;\n        }\n        if\
    \ (value % 2 == 0 && value < even_value)\n        {\n            even_value =\
    \ value;\n            even_index = i;\n        }\n    }\n    \n    return even_value\
    \ < long.max ? [even_value, even_index] : [min_value, min_index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv90g24zb.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286ed]

    ??:? void tmpv90g24zb.__unittest_L64_C1() [0x4283ba]

    ??:? void tmpv90g24zb.__modtest() [0x42846c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b56a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430bac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430689]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b541]

    ??:? runModuleUnitTests [0x42c4ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b3c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [].init;\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp380705eh.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp380705eh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = [], small=[];\n    int\
    \ n = arr.length;\n    if( n == 0 ) return res;\n    foreach(i,v; arr)\n    {\n\
    \        if(isEven(v))\n        {\n            small = [v,i];\n            break;\n\
    \        }\n    }\n    if(small.length == 0) return res;\n    for(int i=0; i<n;\
    \ i++)\n    {\n        if(isEven(arr[i]) && small[0] > arr[i])\n        {\n  \
    \          small = [arr[i],i];\n        }\n    }\n    return small;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1hysrl5e.d(41): Error: cannot implicitly convert expression `arr.length`
    of type `ulong` to `int`

    /tmp/tmp1hysrl5e.d(45): Error: undefined identifier `isEven`

    /tmp/tmp1hysrl5e.d(54): Error: undefined identifier `isEven`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1hysrl5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  int i = 0;\n    int r = 0;\n    foreach(e; arr)\n    {\n        if(e % 2 ==\
    \ 0)\n        {\n            result[0] = e;\n            result[1] = i;\n    \
    \        r = 1;\n            break;\n        }\n        i++;\n    }\n    foreach(e;\
    \ arr)\n    {\n        if(e % 2 == 0 && e < result[0])\n        {\n          \
    \  result[0] = e;\n            result[1] = i;\n            r = 1;\n        }\n\
    \        i++;\n    }\n    return result[0..r];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzi91b4xf.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287b5]

    ??:? void tmpzi91b4xf.__unittest_L66_C1() [0x42809a]

    ??:? void tmpzi91b4xf.__modtest() [0x428538]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c86f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b702]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43098d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430e3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430919]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6d9]

    ??:? runModuleUnitTests [0x42c645]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c78]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    /*\n    T[] createArray(alias f = () => T.init, size_t length);\n       \
    \ Creates an array of the given length, each element initialized using f.\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ccqfuns.d(41): Error: unterminated /* */ comment

    /tmp/tmp6ccqfuns.d(57): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ccqfuns.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    if (arr.empty) return new long[0];\n    auto it = arr.retro;\n    auto result\
    \ = long[2];\n    result[0] = 2L;\n    result[1] = 0L;\n    foreach (i, v; it)\n\
    \    {\n        if (v % 2 == 0 && v < result[0]) \n        {\n            result[0]\
    \ = v;\n            result[1] = i;\n        }\n    }\n    if (result[0] == 2L)\
    \ return new long[0];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv8pkwpza.d(43): Error: found `[` when expecting `.` following long

    /tmp/tmpv8pkwpza.d(43): Error: found `2` when expecting identifier following `long`.

    /tmp/tmpv8pkwpza.d(43): Error: semicolon expected following auto declaration,
    not `]`

    /tmp/tmpv8pkwpza.d(43): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv8pkwpza.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [];\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxupw8xey.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxupw8xey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minEvenValue = long.max;\n \
    \   long minEvenIndex = long.max;\n    if (arr.length == 0) return [];\n    for\
    \ (int i = 0; i < arr.length; i++) \n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < minEvenValue)\n        {\n            minEvenValue = arr[i];\n           \
    \ minEvenIndex = i;\n        }\n    }\n    if (minEvenValue == long.max) return\
    \ [];\n    return [minEvenValue, minEvenIndex];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[];\n    \n    long smallest = arr[0];\n    long index    = 0;\n   \
    \ foreach (i, long value; arr) \n    {\n        if (value % 2 == 0 && value <\
    \ smallest) \n        {\n            smallest = value;\n            index    =\
    \ i;\n        }\n    }\n    \n    return smallest % 2 == 0 ? tuple(smallest, index)\
    \ : new long[];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp_i6mg2_.d(41): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpp_i6mg2_.d(54): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp_i6mg2_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoqrstonf.d(295): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoqrstonf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    if (arr.length == 0) \n        return\
    \ []; \n  \n    auto minIndex = 0L; \n    auto minValue = -1L; \n    auto isEvenFound\
    \ = false; \n  \n    for (auto i = 0L; i < arr.length; i++) \n    { \n       \
    \ if (arr[i] % 2 == 0) \n        { \n            isEvenFound = true; \n      \
    \      if (minValue == -1 || minValue > arr[i]) \n            { \n           \
    \     minValue = arr[i]; \n                minIndex = i; \n            } \n  \
    \      } \n    } \n  \n    if (isEvenFound) \n        return tuple(minValue, minIndex);\
    \ \n  \n    return []; \n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp47tp2ds7.d(61): Error: cannot implicitly convert expression `tuple(minValue,
    minIndex)` of type `Tuple!(long, long)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp47tp2ds7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length < 1) \n        return\
    \ new long[2];\n    long min = long.max;\n    long min_index = -1;\n    long smallest_even_val\
    \ = long.max;\n    long smaalest_even_index = -1;\n    long[] ans = new long[2];\n\
    \    foreach (i, v; arr)\n    {\n        if (v < min) \n        {\n          \
    \  min = v;\n            min_index = i;\n        }\n        if (v < smallest_even_val\
    \ && v % 2 == 0) \n        {\n            smallest_even_val = v;\n           \
    \ smaalest_even_index = i;\n        }\n    }\n    if (smallest_even_val == long.max)\
    \ \n        return new long[2];\n    ans[0] = smallest_even_val;\n    ans[1] =\
    \ smaalest_even_index;\n    return ans;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo0ei1idd.d(72): unittest failure

    ----------------

    ??:? _d_unittestp [0x42872d]

    ??:? void tmpo0ei1idd.__unittest_L66_C1() [0x4280fa]

    ??:? void tmpo0ei1idd.__modtest() [0x4284ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b67a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430905]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430db4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430891]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b651]

    ??:? runModuleUnitTests [0x42c5bd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestVal = -1L;\n    long\
    \ smallestIndex = -1L;\n    long[] result = new long[2];\n    foreach(int i, long\
    \ item; arr)\n    {\n        if (smallestVal > item || smallestVal == -1L)\n \
    \       {\n            if (item % 2 == 0)\n            {\n                smallestVal\
    \ = item;\n                smallestIndex = i;\n            }\n        }\n    }\n\
    \    if (smallestVal == -1L)\n    {\n        return result;\n    }\n    result[0]\
    \ = smallestVal;\n    result[1] = smallestIndex;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpelcdu81u.d(68): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286dd]

    ??:? void tmpelcdu81u.__unittest_L62_C1() [0x4280aa]

    ??:? void tmpelcdu81u.__modtest() [0x42845c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c797]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b62a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430841]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b601]

    ??:? runModuleUnitTests [0x42c56d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return (arr.length == 0 || arr.all!(e\
    \ => e % 2)) ? [] : \n        [arr.filter!(e => e % 2 == 0).min, arr.indexOf(arr.filter!(e\
    \ => e % 2 == 0).min)];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpemsi85ys.d(40): Error: no property `all` for type `long[]`

    /tmp/tmpemsi85ys.d(41): Error: no property `filter` for type `long[]`

    /tmp/tmpemsi85ys.d(41): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpemsi85ys.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n  if (arr.length == 0) return [0L, 0L];\n\
    \  auto pluck = arr.mapping!(a => a % 2 == 0 ? a : cast(long)LONG_MAX).minIndex;\n\
    \  return arr[pluck] == LONG_MAX ? [0L, 0L] : [arr[pluck], pluck];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpef859ci1.d(41): Error: no property `mapping` for type `long[]`

    /tmp/tmpef859ci1.d(42): Error: undefined identifier `LONG_MAX`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpef859ci1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long minEven = cast(long)1e9;\n    long index = 0;\n\
    \    long result = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n    \
    \    if (arr[i] % 2 == 0 && arr[i] < minEven)\n        {\n            minEven\
    \ = arr[i];\n            index = i;\n            result = minEven;\n        }\n\
    \    }\n    if (result == -1)\n        return new long[0];\n    return tuple(result,\
    \ index);\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfkakw_j1.d(57): Error: cannot implicitly convert expression `tuple(result,
    index)` of type `Tuple!(long, long)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfkakw_j1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min_even_idx = 0;\n    long\
    \ min_even_val = arr[0];\n    long[] ret_arr = new long[2];\n    foreach(ref idx,\
    \ ref val; arr)\n    {\n        if((val % 2) == 0)\n        {\n            if(val\
    \ < min_even_val)\n            {\n                min_even_val = val;\n      \
    \          min_even_idx = idx;\n            }\n        }\n    }\n    if(min_even_val\
    \ == arr[0])\n    {\n        ret_arr = new long[0];\n    }\n    else\n    {\n\
    \        ret_arr[0] = min_even_val;\n        ret_arr[1] = min_even_idx;\n    }\n\
    \    return ret_arr;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj8a0vdm8.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x428725]

    ??:? void tmpj8a0vdm8.__unittest_L65_C1() [0x428091]

    ??:? void tmpj8a0vdm8.__modtest() [0x4284a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430dac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430889]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b649]

    ??:? runModuleUnitTests [0x42c5b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallest_even_value = 0;\n \
    \   long smallest_even_index = 0;\n    bool is_found = false;\n    int N = arr.length;\n\
    \    foreach(immutable i, immutable value; arr) \n    {\n        if (value !=\
    \ 0 && value % 2 == 0) \n        {\n            if (!is_found) \n            {\n\
    \                smallest_even_value = value;\n                smallest_even_index\
    \ = i;\n                is_found = true;\n            }\n            else \n \
    \           {\n                if (value < smallest_even_value) \n           \
    \     {\n                    smallest_even_value = value;\n                  \
    \  smallest_even_index = i;\n                }\n            }\n        }\n   \
    \ }\n    if (is_found) \n    {\n        return [smallest_even_value, smallest_even_index];\n\
    \    }\n    else \n    {\n        return [];\n    }\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpts5ybguy.d(43): Error: cannot implicitly convert expression `arr.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpts5ybguy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long min = long.max;\n    size_t min_i = 0;\n    for (size_t\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            min_i = i;\n       \
    \ }\n    }\n    if (min == long.max)\n        return new long[0];\n    return\
    \ [min, min_i];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    if\
    \ (arr.length == 0) return res;\n    long min = arr[0], pos = 0;\n    if (arr[0]\
    \ % 2 == 0) \n    {\n        min = arr[0];\n        res[0] = min;\n        res[1]\
    \ = 0;\n    }\n    for (long i = 1; i < arr.length; i++) \n    {\n        if (arr[i]\
    \ % 2 == 0) \n        {\n            if (arr[i] < min) \n            {\n     \
    \           min = arr[i];\n                pos = i;\n            }\n        }\n\
    \    }\n    if (min == arr[0]) return res;\n    res[0] = min;\n    res[1] = pos;\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppeu3wzn_.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x42881d]

    ??:? void tmppeu3wzn_.__unittest_L65_C1() [0x42818d]

    ??:? void tmppeu3wzn_.__modtest() [0x4285a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b76a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4309f5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430ea4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430981]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b741]

    ??:? runModuleUnitTests [0x42c6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ce0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long value = 0;\n    long index =\
    \ 0;\n    foreach(i, e; arr) \n    {\n        if(isEven(e) && (value == 0 || e\
    \ < value)) \n        {\n            value = e;\n            index = i;\n    \
    \    }\n    }\n    return tuple(value, index);\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp22q_0eek.d(44): Error: undefined identifier `isEven`

    /tmp/tmp22q_0eek.d(50): Error: cannot implicitly convert expression `tuple(value,
    index)` of type `Tuple!(long, long)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp22q_0eek.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res;\n    auto m = arr.chunks(2).filter!(a\
    \ => a[0] % 2 == 0).front();\n    if(m)\n    {\n        res = m[];\n    }\n  \
    \  else\n    {\n        res = [];\n    }\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfgs5cyp7.d(41): Error: no property `chunks` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfgs5cyp7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return new long[];\n    }\n    else \n    {\n        long minIndex = -1;\n\
    \        long minVal = arr[0];\n        foreach (inx, val; arr) \n        {\n\
    \            if (val % 2 == 0 && (val < minVal || minIndex == -1)) \n        \
    \    {\n                minIndex = inx;\n                minVal = val;\n     \
    \       }\n        }\n        if (minIndex == -1) \n        {\n            return\
    \ new long[];\n        }\n        else \n        {\n            return [minVal,\
    \ minIndex];\n        }\n    }\n}\n/*\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpohhhit1d.d(66): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpohhhit1d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto minimum = new long[2];\n   \
    \ minimum[0] = long.max;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptidi57av.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptidi57av.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestEven = 10000;\n    long\
    \ index;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ == 0)\n        {\n            index = i;\n            return [0, index];\n \
    \       }\n        if (arr[i] < smallestEven && arr[i] % 2 == 0)\n        {\n\
    \            smallestEven = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (smallestEven != 10000)\n    {\n        return [smallestEven, index];\n\
    \    }\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length < 1) \n        return\
    \ [];\n    \n    long min = minElement(arr.filter!(x => x % 2 == 0));\n    return\
    \ [min, arr.indexOf(min)];\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphq5twqee.d(43): Error: undefined identifier `minElement`

    /tmp/tmphq5twqee.d(44): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphq5twqee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[];\n    \n    Tuple!(long, int)[][] res = new Tuple!(long, int)[][](arr.length);\n\
    \    Tuple!(long, int) best;\n    for (int i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] == 0)\n        {\n            best = tuple(0L, i);\n     \
    \       return [best[0], best[1]];\n        }\n        else if (arr[i] % 2 ==\
    \ 0)\n        {\n            best = tuple(arr[i], i);\n            return [best[0],\
    \ best[1]];\n        }\n    }\n    return new long[];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpavahhjik.d(41): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpavahhjik.d(58): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpavahhjik.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = 0L;\n    long index =\
    \ 0L;\n    long[] ret = new long[2];\n    if (arr.length == 0)\n        return\
    \ ret;\n    else if (arr.length == 1) {\n        ret[0] = arr[0];\n        ret[1]\
    \ = 0L;\n        return ret;\n    }\n    else {\n        min = arr[0];\n     \
    \   index = 0L;\n        for (int i = 0; i < arr.length; i++) {\n            if\
    \ (arr[i] % 2 == 0) {\n                if (arr[i] < min) {\n                 \
    \   min = arr[i];\n                    index = i;\n                }\n       \
    \     }\n        }\n        if (min == 0L)\n            return ret;\n        else\
    \ {\n            ret[0] = min;\n            ret[1] = index;\n            return\
    \ ret;\n        }\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcx55al1h.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287e5]

    ??:? void tmpcx55al1h.__unittest_L70_C1() [0x428151]

    ??:? void tmpcx55al1h.__modtest() [0x428564]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c89f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b732]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4309bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430e6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430949]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b709]

    ??:? runModuleUnitTests [0x42c675]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ca8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minEven = long.max;\n    long\
    \ minEvenIdx = -1;\n    long[] ret = new long[2];\n    ret[0] = -1;\n    ret[1]\
    \ = -1;\n    foreach(i, val; arr)\n    {\n        if (val % 2 == 0 && val < minEven)\n\
    \        {\n            minEven = val;\n            minEvenIdx = i;\n        }\n\
    \    }\n    if (minEvenIdx != -1)\n    {\n        ret[0] = minEven;\n        ret[1]\
    \ = minEvenIdx;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp214tuz_8.d(66): unittest failure

    ----------------

    ??:? _d_unittestp [0x42871d]

    ??:? void tmp214tuz_8.__unittest_L60_C1() [0x4280ea]

    ??:? void tmp214tuz_8.__modtest() [0x42849c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b66a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308f5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430da4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430881]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b641]

    ??:? runModuleUnitTests [0x42c5ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] tmp = null;\n    long[] result\
    \ = {};\n    long evValue = 0L;\n    if (arr.length > 0)\n    {\n        foreach\
    \ (value; arr)\n        {\n            if (isEven(value))\n            {\n   \
    \             if (evValue == 0)\n                {\n                    evValue\
    \ = value;\n                    tmp = [value, arr.indexOf(value)];\n         \
    \       }\n                else if (value < evValue)\n                {\n    \
    \                evValue = value;\n                    tmp = [value, arr.indexOf(value)];\n\
    \                }\n            }\n        }\n        if (tmp.length > 0)\n  \
    \      {\n            result = tmp;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ar507p6.d(41): Error: a struct is not a valid initializer for
    a `long[]`

    /tmp/tmp0ar507p6.d(47): Error: undefined identifier `isEven`

    /tmp/tmp0ar507p6.d(52): Error: no property `indexOf` for type `long[]`

    /tmp/tmp0ar507p6.d(57): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ar507p6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestEvenIndex = -1L;\n \
    \   long smallestEvenValue = long.max;\n    foreach(i, e; arr)\n    {\n      \
    \  if(e % 2 == 0 && e < smallestEvenValue)\n        {\n            smallestEvenValue\
    \ = e;\n            smallestEvenIndex = i;\n        }\n    }\n    if(smallestEvenIndex\
    \ == -1L)\n    {\n        return long[].init;\n    }\n    return tuple(smallestEvenValue,\
    \ smallestEvenIndex);\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp86xpyuqw.d(52): Error: found `[` when expecting `.` following long

    /tmp/tmp86xpyuqw.d(52): Error: found `]` when expecting identifier following `long`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp86xpyuqw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] return_arr = [];\n    size_t\
    \ index = 0L;\n    long value = __numeric_limits!long.max;\n    bool has_zero\
    \ = false;\n    foreach(idx, element; arr)\n    {\n        if(element == 0L)\n\
    \        {\n            if(!has_zero)\n            {\n                index =\
    \ idx;\n                has_zero = true;\n            }\n        }\n        else\
    \ if(element % 2L == 0L && element < value)\n        {\n            index = idx;\n\
    \            value = element;\n        }\n    }\n    if(value != __numeric_limits!long.max)\n\
    \    {\n        return_arr ~= value;\n        return_arr ~= index;\n    }\n  \
    \  return return_arr;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp028012i5.d(42): Error: template instance `__numeric_limits!long`
    template `__numeric_limits` is not defined

    /tmp/tmp028012i5.d(60): Error: template instance `__numeric_limits!long` template
    `__numeric_limits` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp028012i5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long[] min_val = new long[2];\n\
    \    foreach(long index, long val; arr) \n    {\n        if (val % 2 == 0) \n\
    \        {\n            if (val < min_val[0] || min_val[0] == 0) \n          \
    \  {\n                min_val[0] = val;\n                min_val[1] = index;\n\
    \            }\n        }\n    }\n    return min_val;\n}\n// O(n) solution\nlong[]\
    \ pluck(long[] arr) \n{ \n    long[] min_val = new long[2];\n    long val;\n \
    \   foreach(long index; arr) \n    {\n        val = arr[index];\n        if (val\
    \ % 2 == 0) \n        {\n            if (val < min_val[0] || min_val[0] == 0)\
    \ \n            {\n                min_val[0] = val;\n                min_val[1]\
    \ = index;\n            }\n        }\n    }\n    return min_val;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpit5zyst5.d(77): Error: `tmpit5zyst5.pluck` called with argument
    types `(long[])` matches both:

    /tmp/tmpit5zyst5.d(38):     `tmpit5zyst5.pluck(long[] arr)`

    and:

    /tmp/tmpit5zyst5.d(55):     `tmpit5zyst5.pluck(long[] arr)`

    /tmp/tmpit5zyst5.d(78): Error: `tmpit5zyst5.pluck` called with argument types
    `(long[])` matches both:

    /tmp/tmpit5zyst5.d(38):     `tmpit5zyst5.pluck(long[] arr)`

    and:

    /tmp/tmpit5zyst5.d(55):     `tmpit5zyst5.pluck(long[] arr)`

    /tmp/tmpit5zyst5.d(79): Error: `tmpit5zyst5.pluck` called with argument types
    `(void[])` matches both:

    /tmp/tmpit5zyst5.d(38):     `tmpit5zyst5.pluck(long[] arr)`

    and:

    /tmp/tmpit5zyst5.d(55):     `tmpit5zyst5.pluck(long[] arr)`

    /tmp/tmpit5zyst5.d(80): Error: `tmpit5zyst5.pluck` called with argument types
    `(long[])` matches both:

    /tmp/tmpit5zyst5.d(38):     `tmpit5zyst5.pluck(long[] arr)`

    and:

    /tmp/tmpit5zyst5.d(55):     `tmpit5zyst5.pluck(long[] arr)`

    /tmp/tmpit5zyst5.d(81): Error: `tmpit5zyst5.pluck` called with argument types
    `(long[])` matches both:

    /tmp/tmpi'
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    /*\n        Alright, we have an array\
    \ of longs.\n        If its empty, we return [].\n        \n        What if its\
    \ not empty? We only want evens, so we will filter out the odds.\n        Then\
    \ we want the lowest even value, so we will sort descending.\n        Then we\
    \ want the index in the original array of that lowest even value.\n        \n\
    \        We can not use arr.sort because its not a long[].\n        We can not\
    \ use std.algorithm.sort because it does not have a descending option.\n     \
    \   We can not use std.algorithm.sortDescending because it cannot sort primitive\
    \ types.\n        We can not use std.algorithm.sort!(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"\
    a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")(\"a > b\")\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfe24c9ja.d(40): Error: unterminated /* */ comment

    /tmp/tmpfe24c9ja.d(65): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfe24c9ja.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto evens = arr.filter!(i => i %\
    \ 2 == 0)();\n    if (evens.empty)\n        return [];\n    else\n    {\n    \
    \    auto r = evens.min;\n        return [r, arr.indexOf(r)];\n    }\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgnbmrpq_.d(40): Error: no property `filter` for type `long[]`

    /tmp/tmpgnbmrpq_.d(46): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnbmrpq_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    if (arr.length == 0)\n        return\
    \ [].dup;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21yvq3v8.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21yvq3v8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = [0L, 0L];\n    size_t\
    \ min_idx = arr.length;\n    long min_even = arr.length;\n    foreach(idx, val;\
    \ arr)\n    {\n        if(val % 2 == 0 && val < min_even)\n        {\n       \
    \     min_even = val;\n            min_idx = idx;\n        }\n    }\n    if(min_even\
    \ < arr.length)\n    {\n        result[0] = min_even;\n        result[1] = min_idx;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmply9g_g9y.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286d5]

    ??:? void tmply9g_g9y.__unittest_L58_C1() [0x4280a2]

    ??:? void tmply9g_g9y.__modtest() [0x428454]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c733]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430759]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c08]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306e5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b59d]

    ??:? runModuleUnitTests [0x42c509]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b98]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return arr;\n\
    \    long smallest = long.max;\n    long index = 0;\n    foreach (i, v; arr)\n\
    \    {\n        if (v%2 == 0 && v < smallest)\n        {\n            smallest\
    \ = v;\n            index = i;\n        }\n    }\n    if (smallest == long.max)\n\
    \        return [];\n    return [smallest, index];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result;\nunittest\n{\n   \
    \ alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpquk_kbud.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpquk_kbud.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ typeof(arr).init;\n    else\n    {\n        // The std.algorithm.minElement\
    \ function only allows comparison of\n        // elements by iota, so we have\
    \ to shuffle the even numbers to the\n        // front of the array to be able\
    \ to use minElement.\n        auto newArr = arr.dup;\n        newArr.sort!(a,\
    \ b => a > b && a % 2 == 0 && b % 2 == 0);\n        newArr.sort!(a, b => a % 2\
    \ == 0 && b % 2 == 0);\n        int i = newArr.minElement!((a, b) => a % 2 ==\
    \ 0 && b % 2 == 0);\n        return [newArr[i], arr.indexOf(newArr[i])];\n   \
    \ }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4g7paxqo.d(48): Error: no property `sort` for type `long[]`

    /tmp/tmp4g7paxqo.d(49): Error: no property `sort` for type `long[]`

    /tmp/tmp4g7paxqo.d(50): Error: no property `minElement` for type `long[]`

    /tmp/tmp4g7paxqo.d(51): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4g7paxqo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    auto smallestEven = arr.filter!(x => x % 2 == 0).min;\n    if (smallestEven\
    \ == -1)\n        return [];\n    else\n        return [smallestEven, arr.indexOf(smallestEven)];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx306kqj7.d(42): Error: no property `filter` for type `long[]`

    /tmp/tmpx306kqj7.d(46): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx306kqj7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long n = arr.length;\n    long[]\
    \ arr2 = new long[2];\n    if (n == 0) \n    {\n        return arr2;\n    }\n\
    \    long m = min(arr);\n    while (m % 2 != 0) \n    {\n        arr = arr.filter!(x\
    \ => x != m);\n        m = min(arr);\n    }\n    arr2[0] = m;\n    arr2[1] = arr.indexOf(m);\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1kggglha.d(46): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp1kggglha.d(49): Error: no property `filter` for type `long[]`

    /tmp/tmp1kggglha.d(50): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp1kggglha.d(53): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1kggglha.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallestEven = long.max;\n \
    \   long index = -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n     \
    \   if (arr[i] % 2 == 0 && arr[i] < smallestEven)\n        {\n            smallestEven\
    \ = arr[i];\n            index = i;\n        }\n    }\n    return (index != -1)\
    \ ? [smallestEven, index] : [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long minEven = long.max;\n    long minIndex = long.max;\n\
    \    long minValue = long.max;\n    \n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < minEven)\n\
    \            {\n                minEven = arr[i];\n                minIndex =\
    \ i;\n                minValue = arr[i];\n            }\n        }\n    }\n  \
    \  \n    if (minEven == long.max)\n        return new long[0];\n    else\n   \
    \     return [minValue, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    long min = -1;\n    long min_idx = -1;\n    foreach (idx, e; arr)\n    {\n\
    \        if (e % 2 == 0)\n        {\n            if (min < 0 || e < min)\n   \
    \         {\n                min = e;\n                min_idx = idx;\n      \
    \      }\n        }\n    }\n    if (min < 0) return new long[0];\n    return [min,\
    \ min_idx];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.dup.map!(a => tuple(a,\
    \ arr.indexOf(a))).filter!(a => a[0] % 2 == 0).sort!((a, b) => a[0] > b[0]).sort!((a,\
    \ b) => a[1] > b[1]).front;\n}\nlong[] pluck2(long[] arr) \n{\n    return arr.dup.map!(a\
    \ => tuple(a, arr.indexOf(a))).filter!(a => a[0] % 2 == 0).sort!((a, b) => a[0]\
    \ > b[0]).sort!((a, b) => a[1] > b[1]).front;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpklk0km0v.d(40): Error: no property `map` for type `long[]`

    /tmp/tmpklk0km0v.d(44): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpklk0km0v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] answer = new long[2];\n  \
    \  int smallest_index = -1;\n    long smallest_value = -1;\n    if (arr.length\
    \ > 0) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i]\
    \ != 0 && (arr[i] % 2) == 0) {\n                if (smallest_value == -1) {\n\
    \                    smallest_value = arr[i];\n                    smallest_index\
    \ = i;\n                } else if (arr[i] < smallest_value) {\n              \
    \      smallest_value = arr[i];\n                    smallest_index = i;\n   \
    \             }\n            }\n        }\n    }\n    if (smallest_index != -1)\
    \ {\n        answer[0] = smallest_value;\n        answer[1] = smallest_index;\n\
    \    }\n    return answer;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp74jn0not.d(68): unittest failure

    ----------------

    ??:? _d_unittestp [0x428785]

    ??:? void tmp74jn0not.__unittest_L62_C1() [0x428152]

    ??:? void tmp74jn0not.__modtest() [0x428504]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c83f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43095d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430e0c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4308e9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a9]

    ??:? runModuleUnitTests [0x42c615]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c48]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate'
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    long[] ans = new long[2];\n    ans[0] = long.max;\n    for\
    \ (long i=0; i<arr.length; i++) \n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < ans[0])\n        {\n            ans[0] = arr[i];\n            ans[1] = i;\n\
    \        }\n    }\n    if (ans[0] == long.max)\n        return new long[0];\n\
    \    return ans;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // YOUR CODE GOES HERE\n    return\
    \ null;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyskz1odw.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285bd]

    ??:? void tmpyskz1odw.__unittest_L43_C1() [0x427ea2]

    ??:? void tmpyskz1odw.__modtest() [0x428340]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430559]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]

    ??:? runModuleUnitTests [0x42c37d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a0c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] minEven = [std.numeric.max,\
    \ 0];\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd_d74ta6.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_d74ta6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  result[0] = long.max;\n    foreach(ref e; arr)\n    {\n        if(e%2 == 0\
    \ && e < result[0])\n        {\n            result[0] = e;\n            result[1]\
    \ = arr.indexOf(e);\n        }\n    }\n    if(result[0] == long.max)\n    {\n\
    \        return new long[2];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzxcota08.d(47): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzxcota08.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long smallest_index = -1L;\n    long\
    \ smallest_even = long.max;\n    foreach(index, value; arr)\n    {\n        if(value\
    \ % 2 == 0 && value < smallest_even)\n        {\n            smallest_even = value;\n\
    \            smallest_index = index;\n        }\n    }\n    if(smallest_index\
    \ != -1L)\n    {\n        return [smallest_even, smallest_index];\n    }\n   \
    \ return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\n    long minEven = 0;\n    long minEvenIndex = 0;\n\
    \    long smallestIndex = 0;\n    long counter = 0;\n    foreach (value; arr)\
    \ \n    {\n        if (value % 2 == 0) \n        {\n            if (counter ==\
    \ 0) \n            {\n                minEven = value;\n                minEvenIndex\
    \ = counter;\n            }\n            else if (value < minEven) \n        \
    \    {\n                minEven = value;\n                minEvenIndex = counter;\n\
    \            }\n        }\n        counter++;\n    }\n    if (minEven == 0) \n\
    \    {\n        return [];\n    }\n    else \n    {\n        return [minEven,\
    \ minEvenIndex];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu2wcgmaj.d(79): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286cd]

    ??:? void tmpu2wcgmaj.__unittest_L74_C1() [0x428039]

    ??:? void tmpu2wcgmaj.__modtest() [0x42844c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b54a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b8c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430669]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b521]

    ??:? runModuleUnitTests [0x42c48d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b1c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = 0;\n    int index = 0;\n\
    \    bool found = false;\n    for (int i = 0; i < arr.length; i++) \n    {\n \
    \       if (arr[i] % 2 == 0) \n        {\n            if (found == false) \n \
    \           {\n                min = arr[i];\n                index = i;\n   \
    \             found = true;\n            }\n            else if (arr[i] < min)\
    \ \n            {\n                min = arr[i];\n                index = i;\n\
    \            }\n        }\n    }\n    if (found == false) \n    {\n        return\
    \ new long[];\n    }\n    return tuple(min, index);\n}\n/*\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq5_r4zdg.d(66): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq5_r4zdg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\n    long minEven = 0;\n    long minEvenIndex = -1;\n\
    \    auto currEven = false;\n    foreach (i, long v; arr) \n    {\n        if\
    \ (v % 2 == 0) \n        {\n            if (!currEven) \n            {\n     \
    \           minEven = v;\n                minEvenIndex = i;\n                currEven\
    \ = true;\n            }\n            else \n            {\n                if\
    \ (v < minEven) \n                {\n                    minEven = v;\n      \
    \              minEvenIndex = i;\n                }\n            }\n        }\n\
    \    }\n    if (minEvenIndex == -1) \n    {\n        return [];\n    }\n    return\
    \ [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[]().init;\n    \n    long[] plucked = new long[]().init;\n    long[]\
    \ nonZero = new long[]().init;\n    for (inout long e : arr)\n    {\n        if\
    \ (e % 2 == 0)\n        {\n            plucked ~= e;\n        }\n        else\n\
    \        {\n            nonZero ~= e;\n        }\n    }\n    if (plucked.length\
    \ == 0)\n        return new long[]().init;\n    \n    // sort:\n    plucked.sort!((a,\
    \ b) => a < b);\n    long value = plucked[0];\n    return [value, cast(size_t)arr.indexOf(value)];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa2s0w_po.d(45): Error: semicolon expected, not `:`

    /tmp/tmpa2s0w_po.d(45): Error: expression expected, not `:`

    /tmp/tmpa2s0w_po.d(45): Error: found `arr` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa2s0w_po.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    const int len = arr.length;\n   \
    \ long[] result = new long[2];\n    if (len == 0) \n    {\n        return result;\n\
    \    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpilvui45p.d(46): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilvui45p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    //scoped auto index = 0L;\n    auto\
    \ dg = std.algorithm.filter!((value) => value % 2 == 0)(arr);\n    //std.algorithm.any!(typeof(dg))(arr);\n\
    \    //foreach(val; arr)\n    //{\n    //    if(val % 2 == 0)\n    //    {\n \
    \   //        //std.algorithm.any!(value)(arr);\n    //        std.array.Appender!(long[])\
    \ app;\n    //        app.put(val);\n    //        //app.put(index);\n    // \
    \       //dg[0] = val;\n    //        //dg[1] = index;\n    //        //return\
    \ dg;\n    //    }\n    //    index++;\n    //}\n    if(dg.length == 0)\n    {\n\
    \        //dg = [ ];\n        return dg;\n    }\n    auto min = std.algorithm.min(dg);\n\
    \    long[] dg2;\n    dg2 ~= min;\n    dg2 ~= std.algorithm.minIndex(dg);\n  \
    \  return dg2;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvqdrmzk.d(41): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmphvqdrmzk.d(62): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmphvqdrmzk.d(65): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvqdrmzk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min_even = std.numeric.maxOf!long;\n\
    \    size_t min_idx = arr.length;\n    bool found = false;\n    foreach(i, v;\
    \ arr)\n    {\n        if (v % 2 == 0)\n        {\n            if (v < min_even)\n\
    \            {\n                min_even = v;\n                min_idx = i;\n\
    \                found = true;\n            }\n        }\n    }\n    if (found)\n\
    \    {\n        return [min_even, min_idx];\n    }\n    else\n    {\n        return\
    \ [];\n    }\n}\n/*\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr6hx3mjc.d(64): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr6hx3mjc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long minValue = 2L;\n    bool foundMinValue\
    \ = false;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ < minValue && arr[i] > 0)\n        {\n            minValue = arr[i];\n     \
    \       foundMinValue = true;\n        }\n    }\n    if (foundMinValue)\n    {\n\
    \        for (int i = 0; i < arr.length; i++)\n        {\n            if (arr[i]\
    \ == minValue)\n            {\n                return [minValue, i];\n       \
    \     }\n        }\n    }\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2_sj1qbr.d(66): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmp2_sj1qbr.__unittest_L62_C1() [0x427ff2]

    ??:? void tmp2_sj1qbr.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c76b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430791]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c40]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43071d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5d5]

    ??:? runModuleUnitTests [0x42c541]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long min = 20000;\n    long index\
    \ = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if(arr[i] %\
    \ 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if(index == -1)\n    {\n        return [];\n   \
    \ }\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length < 1) return new long[2];\n\
    \    long evenMin = uint.max;\n    uint evenMinIdx = uint.max;\n    for (uint\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ evenMin)\n        {\n            evenMin = arr[i];\n            evenMinIdx =\
    \ i;\n        }\n    }\n    return evenMin == uint.max ? new long[2] : new long[2]\
    \ {evenMin, evenMinIdx};\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfrhue07k.d(51): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmpfrhue07k.d(51): Error: found `}` when expecting `;` following statement

    /tmp/tmpfrhue07k.d(51): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfrhue07k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int resIndex = -1;\n    long res\
    \ = long.max;\n    if (arr.length == 0)\n        return new long[0];\n    foreach\
    \ (i, v; arr)\n    {\n        if (v != 0 && v % 2 == 0 && v < res)\n        {\n\
    \            res = v;\n            resIndex = i;\n        }\n    }\n    if (resIndex\
    \ == -1)\n        return new long[0];\n    return [res, resIndex];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpax53srq7.d(49): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpax53srq7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.filter!(e => e % 2 ==\
    \ 0).minElementIndex!q{a < b}.map!(e => [e, arr.indexOf(e)]).array;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4de1v8nr.d(40): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4de1v8nr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] ret = [long.max, long.max];\n\
    \    foreach(idx, cur; arr) \n    {\n        if (cur > ret[0] || ((cur & 1) ==\
    \ 1 && cur < ret[0])) continue;\n        ret = [cur, idx];\n    }\n    if (ret[0]\
    \ == long.max) ret = [];\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpb2idycy_.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x428765]

    ??:? void tmpb2idycy_.__unittest_L49_C1() [0x4281d4]

    ??:? void tmpb2idycy_.__modtest() [0x4284e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b67a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43080d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cbc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430799]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b651]

    ??:? runModuleUnitTests [0x42c5bd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c28]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = new long[2];\n    if\
    \ (arr.length == 0) return res;\n    long min_even = 2 * LONG_MAX;\n    foreach\
    \ (index, value; arr)\n    {\n        if (value == 0)\n        {\n           \
    \ res[0] = value;\n            res[1] = index;\n            return res;\n    \
    \    }\n        if (value % 2 == 0 && value < min_even)\n        {\n         \
    \   min_even = value;\n            res[0] = value;\n            res[1] = index;\n\
    \        }\n    }\n    if (min_even > 100000) return [];\n    return res;\n}\n\
    ```\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqu0b70uc.d(61): Error: declaration expected, not `""`

    /tmp/tmpqu0b70uc.d(61): Error: unterminated string constant starting at /tmp/tmpqu0b70uc.d(61)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqu0b70uc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    /*\n    // Fail.\n    if(arr.length\
    \ == 0)\n        return [];\n    long minEven = long.max;\n    long index = 0;\n\
    \    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] % 2 == 0)\n\
    \        {\n            if(arr[i] < minEven)\n            {\n                minEven\
    \ = arr[i];\n                index = i;\n            }\n        }\n    }\n   \
    \ if(minEven == long.max)\n        return [];\n    return [minEven, index];\n\
    \    */\n    /*\n    // Fail.\n    if(arr.length == 0)\n        return [];\n \
    \   return [arr.filter!(a => a % 2 == 0).min, arr.filter!(a => a % 2 == 0).findIndex!(a\
    \ => a == arr.filter!(a => a % 2 == 0).min)];\n    */\n    return [arr.filter!(a\
    \ => a % 2 == 0).min, arr.indexOf(arr.filter!(a => a % 2 == 0).min)];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbsc2h85a.d(67): Error: no property `filter` for type `long[]`

    /tmp/tmpbsc2h85a.d(67): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbsc2h85a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    long lowestEven = int.max;\n    int index = 0;\n   \
    \ int lowestIndex = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n    \
    \    if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < lowestEven)\n \
    \           {\n                lowestEven = arr[i];\n                lowestIndex\
    \ = i;\n            }\n        }\n    }\n    if (lowestEven == int.max)\n    \
    \    return new long[0];\n    return [lowestEven, lowestIndex];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  if (arr.length < 1)\n        return result;\n    \n    long minEvenValue =\
    \ long.max;\n    long minEvenIndex = long.max;\n    for (long i = 0; i < arr.length;\
    \ i++) \n    {\n        if (arr[i] % 2 == 0 && arr[i] < minEvenValue) \n     \
    \   {\n            minEvenValue = arr[i];\n            minEvenIndex = i;\n   \
    \     }\n    }\n    if (minEvenValue != long.max) \n    {\n        result[0] =\
    \ minEvenValue;\n        result[1] = minEvenIndex;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqqevy8sn.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42872d]

    ??:? void tmpqqevy8sn.__unittest_L61_C1() [0x4280fe]

    ??:? void tmpqqevy8sn.__modtest() [0x4284b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b67a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430905]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430db4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430891]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b651]

    ??:? runModuleUnitTests [0x42c5bd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return new long[0];\n    }\n    if (arr.length == 1) \n    {\n        return\
    \ arr[0] % 2 == 0 ? arr : new long[0];\n    }\n    long minEven = arr[0];\n  \
    \  long minEvenIdx = 0;\n    bool foundMinEven = false;\n    foreach (i, n; arr)\
    \ \n    {\n        if (n % 2 == 0) \n        {\n            if (!foundMinEven)\
    \ \n            {\n                minEven = n;\n                minEvenIdx =\
    \ i;\n                foundMinEven = true;\n            }\n            else \n\
    \            {\n                if (n < minEven) \n                {\n       \
    \             minEven = n;\n                    minEvenIdx = i;\n            \
    \    }\n            }\n        }\n    }\n    return foundMinEven ? [minEven, minEvenIdx]\
    \ : new long[0];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto pred = (e) { return e % 2 ==\
    \ 0; };\n    auto fil = filter!pred(arr);\n    if (fil.empty)\n        return\
    \ [];\n    auto min = minElement(fil);\n    long idx = arr.countUntil(min);\n\
    \    return tuple(min, idx);\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe1n_e_f8.d(40): Error: variable `tmpe1n_e_f8.pluck.pred` type `void`
    is inferred from initializer `(e)

    {

    return e % 2 == 0;

    }

    `, and variables cannot be of type `void`

    /tmp/tmpe1n_e_f8.d(40): Error: template lambda has no value

    /tmp/tmpe1n_e_f8.d(41): Error: template instance `filter!pred` template `filter`
    is not defined

    /tmp/tmpe1n_e_f8.d(44): Error: undefined identifier `minElement`

    /tmp/tmpe1n_e_f8.d(45): Error: no property `countUntil` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe1n_e_f8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    auto result = arr.indexOf(arr.filter!(x => x % 2 == 0).min);\n    return\
    \ [arr[result], result];\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwcng7f2m.d(42): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwcng7f2m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    /*\n        * First filter the array\
    \ to get only even values\n        * Then sort the result\n        * If the array\
    \ is empty return empty array\n        * Otherwise return the first element and\
    \ it's index\n    */\n    auto even = arr.filter!(n => n % 2 == 0)();\n    even.sort;\n\
    \    if (even.empty) return [].dup;\n    else return [even[0], arr.indexOf(even[0])].dup;\n\
    }\n// Test cases:\nunittest\n{\n    assert(pluck([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(pluck([1L, 2L, 3L]) == [2L, 1L]);\n    assert(pluck([]) == []);\n\
    \    assert(pluck([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjf1uoo6r.d(46): Error: no property `filter` for type `long[]`

    /tmp/tmpjf1uoo6r.d(49): Error: no property `indexOf` for type `long[]`

    /tmp/tmpjf1uoo6r.d(48): Error: cannot implicitly convert expression `dup([])`
    of type `void[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjf1uoo6r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long index = 0;\n    long value =\
    \ 0;\n    long min = 100000;\n    long minEven = 100000;\n    foreach(i; arr)\
    \ \n    {\n        if(i%2 == 0) \n        {\n            if(i < minEven) \n  \
    \          {\n                minEven = i;\n                index = value;\n \
    \           }\n        }\n        value++;\n    }\n    if(minEven == 100000) \n\
    \    {\n        return [];\n    }\n    return [minEven, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] result = new long[2];\n  \
    \  result[0] = -1;\n    result[1] = -1;\n    size_t i = 0;\n    foreach(ref e;\
    \ arr)\n    {\n        if(e % 2 == 0)\n        {\n            if(result[0] ==\
    \ -1)\n            {\n                result[0] = e;\n                result[1]\
    \ = i;\n            }\n            else if(e < result[0])\n            {\n   \
    \             result[0] = e;\n                result[1] = i;\n            }\n\
    \        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8k7bwbyb.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x4287ad]

    ??:? void tmp8k7bwbyb.__unittest_L63_C1() [0x42817e]

    ??:? void tmp8k7bwbyb.__modtest() [0x428530]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c867]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430985]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430e34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430911]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6d1]

    ??:? runModuleUnitTests [0x42c63d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c70]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return new long[0];\n\
    \    long min = long.max;\n    int idx = -1;\n    foreach (i, v; arr) \n    {\n\
    \        if (v % 2 == 0 && v < min) \n        {\n            min = v;\n      \
    \      idx = i;\n        }\n    }\n    if (idx == -1) return new long[0];\n  \
    \  return [min, idx];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsoj0gqit.d(48): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsoj0gqit.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    long i = arr.minElement!(a => a % 2 == 0);\n    long index = 0;\n \
    \   foreach (immutable long elem; arr) \n    {\n        if (elem == i)\n     \
    \       break;\n        index++;\n    }\n    return [i, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwjdaqpv5.d(42): Error: no property `minElement` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwjdaqpv5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n  long[] result = new long[2];\n  long\
    \ evenNumber = long.max;\n  long index = long.max;\n  if(arr.length == 0)\n  {\n\
    \      return result;\n  }\n  for(int i = 0; i < arr.length; i++)\n  {\n     \
    \ if(arr[i] % 2 == 0 && arr[i] < evenNumber)\n      {\n          evenNumber =\
    \ arr[i];\n          index = i;\n      }\n  }\n  if(evenNumber == long.max &&\
    \ index == long.max)\n  {\n      return result;\n  }\n  result[0] = evenNumber;\n\
    \  result[1] = index;\n  return result;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjwec0ter.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x428745]

    ??:? void tmpjwec0ter.__unittest_L63_C1() [0x428116]

    ??:? void tmpjwec0ter.__modtest() [0x4284c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b692]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43091d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430dcc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4308a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b669]

    ??:? runModuleUnitTests [0x42c5d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c08]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // find the smallest even value in\
    \ arr\n    long min_even = long.max;\n    foreach(i, el; arr)\n    {\n       \
    \ if (el % 2 == 0 && el < min_even)\n        {\n            min_even = el;\n \
    \       }\n    }\n    // find the first occurance of min_even\n    size_t min_index\
    \ = size_t.max;\n    foreach(i, el; arr)\n    {\n        if (el == min_even &&\
    \ i < min_index)\n        {\n            min_index = i;\n        }\n    }\n  \
    \  // construct return value\n    if (min_even == long.max) return [];\n    return\
    \ [min_even, min_index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto result = [0L, -1L];\n    foreach(i,\
    \ x; arr)\n    {\n        if((x % 2 == 0) && (x < result[0] || result[0] == 0))\n\
    \        {\n            result[0] = x;\n            result[1] = i;\n        }\n\
    \    }\n    return result[0] == 0 ? [] : result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm0wvdz9a.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x428735]

    ??:? void tmpm0wvdz9a.__unittest_L51_C1() [0x4281a8]

    ??:? void tmpm0wvdz9a.__modtest() [0x4284b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c793]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b626]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307b9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430745]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5fd]

    ??:? runModuleUnitTests [0x42c569]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n\tlong min = 1000000;\n\tint min_idx\
    \ = 0;\n\tlong[] res = new long[2];\n\tfor (int i = 0; i < arr.length; i++)\n\t\
    {\n\t\tif (arr[i] % 2 == 0 && arr[i] < min)\n\t\t{\n\t\t\tmin = arr[i];\n\t\t\t\
    min_idx = i;\n\t\t}\n\t}\n\tif (min != 1000000)\n\t{\n\t\tres[0] = min;\n\t\t\
    res[1] = min_idx;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8pempgeh.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmp8pempgeh.__unittest_L58_C1() [0x4280e6]

    ??:? void tmp8pempgeh.__modtest() [0x428498]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b662]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d9c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430879]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b639]

    ??:? runModuleUnitTests [0x42c5a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto t = arr.map!(a => tuple(a, arr.indexOf(a))).filter!(t\
    \ => t[0] % 2 == 0).min();\n    return t ? [t[0], t[1]] : long[];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1utgw737.d(41): Error: found `[` when expecting `.` following long

    /tmp/tmp1utgw737.d(41): Error: found `]` when expecting identifier following `long`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1utgw737.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    //cout << \"Array is: \" << endl;\n\
    \    //foreach(auto e; arr)\n    //    cout << e << \" \";\n    //cout << endl;\n\
    \    //cout << \"*\" << endl;\n    long[] result;\n    long result1 = long.max;\n\
    \    long result2 = long.max;\n    long index = 0;\n    foreach(auto e; arr)\n\
    \    {\n        if (e % 2 == 0)\n        {\n            //cout << \"even: \" <<\
    \ e << endl;\n            if (e < result1)\n            {\n                result1\
    \ = e;\n                result2 = index;\n            }\n        }\n        index++;\n\
    \    }\n    //cout << \"Smallest even value: \" << result1 << endl;\n    //cout\
    \ << \"Its index: \" << result2 << endl;\n    //cout << \"**\" << endl;\n    if\
    \ (result1 == long.max)\n        return result;\n    else\n        return [result1,\
    \ result2];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg7s1gefx.d(49): Error: basic type expected, not `auto`

    /tmp/tmpg7s1gefx.d(49): Error: no identifier for declarator `_error_`

    /tmp/tmpg7s1gefx.d(49): Error: found `auto` when expecting `;`

    /tmp/tmpg7s1gefx.d(49): Error: found `;` when expecting `)`

    /tmp/tmpg7s1gefx.d(49): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg7s1gefx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[0];\n    \n    if (arr.length == 1)\n        return (arr[0] % 2 ==\
    \ 0) ? arr : new long[0];\n    \n    const long min_arr_size = 2;\n    if (arr.length\
    \ < min_arr_size)\n        return new long[0];\n    \n    long[] even_numbers\
    \ = new long[];\n    long smallest_even = long.max;\n    long index = 0;\n   \
    \ foreach (n; arr)\n    {\n        if (n % 2 == 0)\n        {\n            even_numbers\
    \ ~= n;\n            if (n < smallest_even)\n            {\n                smallest_even\
    \ = n;\n                index = even_numbers.length - 1;\n            }\n    \
    \    }\n    }\n    \n    if (even_numbers.length == 0)\n        return new long[0];\n\
    \    \n    return [ smallest_even, index ];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2k8useh.d(50): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2k8useh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long small = 0;\n    long index =\
    \ 0;\n    int even = 0;\n    foreach(long i, long x; arr)\n    {\n        if (x\
    \ % 2 == 0) \n        {\n            even = 1;\n            if (small == 0)\n\
    \            {\n                small = x;\n                index = i;\n     \
    \       }\n            else if (x < small)\n            {\n                small\
    \ = x;\n                index = i;\n            }\n        }\n    }\n    if (even\
    \ == 0)\n    {\n        return new long[]([]);\n    }\n    return new long[]([small,\
    \ index]);\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfyjegwrp.d(62): Error: cannot implicitly convert expression `[]`
    of type `void[]` to `ulong`

    /tmp/tmpfyjegwrp.d(64): Error: cannot implicitly convert expression `[small, index]`
    of type `long[]` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfyjegwrp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) return [];\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxupw8xey.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxupw8xey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = [0L, 0L];\n    long\
    \ smallestEven = long.max;\n    for (int i = 0; i < arr.length; i++) \n    {\n\
    \        if(arr[i] % 2 == 0 && arr[i] < smallestEven)\n        {\n           \
    \ smallestEven = arr[i];\n            res[0] = smallestEven;\n            res[1]\
    \ = i;\n        }\n    }\n    if(smallestEven == long.max)\n        return [];\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto it = min(arr.filter!(a => a\
    \ % 2 == 0));\n    if (it.empty) \n        return [];\n    auto index = arr.indexOf(it.front);\n\
    \    return [it.front, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy3xb_rzo.d(40): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpy3xb_rzo.d(43): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy3xb_rzo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] smallElem = {-1, -1};\n  \
    \  foreach(i, val; arr)\n    {\n        if (val % 2 == 0)\n        {\n       \
    \     if (smallElem[0] == -1 || smallElem[0] > val)\n            {\n         \
    \       smallElem[0] = val;\n                smallElem[1] = i;\n            }\n\
    \        }\n    }\n    return smallElem;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsivuicba.d(40): Error: a struct is not a valid initializer for
    a `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsivuicba.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    size_t min = 0;\n    for (size_t\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n\
    \            if (min == 0)\n            {\n                min = i;\n        \
    \    }\n            else if (arr[i] < arr[min])\n            {\n             \
    \   min = i;\n            }\n        }\n    }\n    if (min == 0)\n    {\n    \
    \    return [];\n    }\n    else\n    {\n        return [arr[min], min];\n   \
    \ }\n}\n/*\n    assert(pluck([4L, 2L, 3L]) == [2L, 1L]);\n    assert(pluck([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(pluck([]) == []);\n    assert(pluck([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(pluck([1L, 1L, 1L, 1L, 1L, 1L])\
    \ == []);\n    assert(pluck([1L, 9L, 1L, 1L, 9L, 1L]) == [9L, 1L]);\n    assert(pluck([1L,\
    \ 7L, 1L, 1L, 9L, 1L]) == [7L, 1L]);\n    assert(pluck([1L, 9L, 1L, 1L, 7L, 1L])\
    \ == [7L, 4L]);\n    assert(pluck([1L, 2L, 1L, 1L, 3L, 1L]) == [2L, 1L]);\n  \
    \  assert(pluck([1L, 2L, 1L, 1L, 2L, 1L]) == [2L, 1L]);\n    assert(pluck([1L,\
    \ 2L, 1L, 1L, 3L, 1L]) == [2L, 1L]);\n    assert(pluck([1L, 2L, 1L, 1L, 2L, 1L])\
    \ == [2L, 1L]);\n    assert(pluck([1L, 2L, 1L, 1L,\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn08ml246.d(64): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn08ml246.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    bool[] isEven = new bool[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        isEven[i] = arr[i] %\
    \ 2 == 0;\n    }\n    int firstIndex = 0;\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (isEven[i])\n        {\n            firstIndex = i;\n\
    \            break;\n        }\n    }\n    long smallestEven = arr[firstIndex];\n\
    \    int smallestEvenIndex = firstIndex;\n    for (int i = firstIndex; i < arr.length;\
    \ i++)\n    {\n        if (isEven[i] && arr[i] < smallestEven)\n        {\n  \
    \          smallestEven = arr[i];\n            smallestEvenIndex = i;\n      \
    \  }\n    }\n    if (smallestEvenIndex == firstIndex && smallestEven != arr[firstIndex])\n\
    \    {\n        return new long[0];\n    }\n    return [smallestEven, smallestEvenIndex];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwhm9h9gk.d(54): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4289f6]

    ??:? long[] tmpwhm9h9gk.pluck(long[]) [0x42805b]

    ??:? void tmpwhm9h9gk.__unittest_L70_C1() [0x4282d0]

    ??:? void tmpwhm9h9gk.__modtest() [0x4286c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca3f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b5d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43100c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ae9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8a9]

    ??:? runModuleUnitTests [0x42c815]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[]'
  stdout: ''
  timestamp: 1660164284
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    immutable len = arr.length;\n   \
    \ if (len == 0) return new long[0];\n    else if (len == 1) return arr[0] % 2\
    \ == 0 ? arr : new long[0];\n    else\n    {\n        static struct Node\n   \
    \     {\n            int index;\n            long value;\n        }\n        immutable\
    \ node = arr.map!(a => Node(0, a)).min!((a, b) => a.value < b.value);\n      \
    \  if (node.value % 2 == 0) return [node.value, node.index];\n        else return\
    \ new long[0];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj5el9g2u.d(50): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj5el9g2u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.retro.filter!(x => x %\
    \ 2 == 0).min().map!(x => [x, arr.find(x)]).front;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvi7ln8lb.d(40): Error: no property `retro` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvi7ln8lb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    bool have_even = false;\n    long\
    \ small_val = arr[0];\n    long small_idx = 0;\n    foreach(i, val; arr)\n   \
    \ {\n        if(val & 1 == 0)\n        {\n            have_even = true;\n    \
    \        if(val < small_val)\n            {\n                small_val = val;\n\
    \                small_idx = i;\n            }\n        }\n    }\n    if(have_even)\n\
    \        return [small_val, small_idx];\n    else\n        return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpln8hgmmq.d(45): Error: `1 == 0` must be parenthesized when next
    to operator `&`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpln8hgmmq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int leastEven = 10000;\n    int index\
    \ = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] <\
    \ leastEven && arr[i] % 2 == 0)\n        {\n            leastEven = cast(int)arr[i];\n\
    \            index = i;\n        }\n    }\n    if (index == -1)\n    {\n     \
    \   return [];\n    }\n    return [leastEven, index];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] smallestEven = [];\n    long\
    \ index = 0;\n    foreach(node; arr) \n    {\n        if(node % 2 == 0) \n   \
    \     {\n            if(smallestEven.length == 0) \n            {\n          \
    \      smallestEven ~= [node, index];\n            }\n            else if(node\
    \ < smallestEven[0]) \n            {\n                smallestEven[0] = node;\n\
    \                smallestEven[1] = index;\n            }\n        }\n        index++;\n\
    \    }\n    return smallestEven;\n}\n/*\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpooa3bhyg.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpooa3bhyg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    long min = int.max;\n    long minIndex = int.max;\n    int pos = 0;\n\
    \    foreach(item; arr)\n    {\n        if (item % 2 == 0 && item < min)\n   \
    \     {\n            min = item;\n            minIndex = pos;\n        }\n   \
    \     pos++;\n    }\n    if (min == int.max)\n        return [];\n    return [min,\
    \ minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [0L, 0L];\n    \n    auto idx = arr.indexOf(arr.min!(a => a % 2 == 0));\n  \
    \  auto res = [arr[idx], idx];\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg3j6zzvz.d(43): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg3j6zzvz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    /* \n        in case the length\
    \ of array is 0,\n        or it has no even numbers,\n        return []\n    */\n\
    \    if (arr.length == 0)\n        return [];\n    /*\n        create an array\
    \ of two elements, \n        that will store the results of our search\n    */\n\
    \    long[] result = new long[2];\n    /*\n        we start with the first element\
    \ of the array,\n        and we take the smallest element with an even value\n\
    \    */\n    result[0] = arr[0];\n    /*\n        we start with the index 0,\n\
    \        and we take the index of the smallest element with an even value\n  \
    \  */\n    result[1] = 0;\n    /*\n        iterate each element of the array,\n\
    \        and for each element we take the following actions:\n        1) if the\
    \ element is even, but it's not the smallest element,\n           move it to the\
    \ right place, and store the index of the smallest even value\n        2) if the\
    \ element is even, and it's the smallest element,\n           store the index\
    \ of the smallest even value\n    */\n    foreach (i, x; arr) \n    {\n      \
    \  if (x % 2 == 0) \n        {\n            if (x > result[0]) \n            {\n\
    \                result[0] = x;\n                result[1] = i;\n            }\n\
    \        }\n    }\n    return result;\n}\n// static assert(pluck([4L, 2L, 3L])\
    \ == [2L, 1L]);\n// static assert(pluck([1L, 2L, 3L]) == [2L, 1L]);\n// static\
    \ assert(pluck([]) == []);\n// static assert(pluck([5L, 0L, 3L, 0L, 4L, 2L]) ==\
    \ [0L, 1L]);\n// static assert(pluck([0L, 2L, 3L, 0L, 4L, 2L]) == [0L, 0L]);\n\
    // static assert(pluck([2L, 2L, 3L, 0L, 4L, 2L]) == [2L, 0L]);\n// static assert(pluck([2L,\
    \ 2L, 3\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo1u9d9nl.d(94): unittest failure

    ----------------

    ??:? _d_unittestp [0x42874d]

    ??:? void tmpo1u9d9nl.__unittest_L90_C1() [0x42802e]

    ??:? void tmpo1u9d9nl.__modtest() [0x4284cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430dd4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4308b1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b671]

    ??:? runModuleUnitTests [0x42c5dd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164284
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    // sorting the array from smallest\
    \ to largest\n    arr.sort!((a, b) => a.compare(b)).retro;\n    // we'll use this\
    \ to get the index of the first found even number\n    size_t i = arr.length;\n\
    \    // we'll find the first even number, the loop will stop when i == 0\n   \
    \ while (true) \n    {\n        // if i == 0 we didn't find any even numbers in\
    \ the array\n        if (i == 0) return typeof(return).init;\n        // if i\
    \ is odd, subtract 1, then if i is even we found the first even number\n     \
    \   if (i % 2 == 0) break;\n        --i;\n    }\n    //return the even number\
    \ and it's index\n    return typeof(return).init(arr[i], i);\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm_od6kl3.d(41): Error: no property `sort` for type `long[]`

    /tmp/tmpm_od6kl3.d(54): Error: cannot pass type `long[]` as a function argument

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm_od6kl3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm : filter, min,\
    \ minIndex, equal;\n    import std.range : zip;\n    import std.traits : isIntegral;\n\
    \    alias zipResult = typeof(zip(arr, 0L .. arr.length));\n    static assert(zipResult.isIntegral);\n\
    \    auto it = zip(arr, 0L .. arr.length)\n                .filter!(x => x[0]\
    \ % 2 == 0)\n                .min!(x => x[0]);\n    if (it.length > 0) {\n   \
    \     return [it[0], it[1]];\n    }\n    return [];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpelc1cupt.d(43): Error: found `..` when expecting `,`

    /tmp/tmpelc1cupt.d(45): Error: found `..` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpelc1cupt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    return arr.filter!(a => a % 2 ==\
    \ 0).empty \n        ? new long[2] \n        : new long[2](arr.filter!(a => a\
    \ % 2 == 0).min, arr.find!(a => a == arr.filter!(a => a % 2 == 0).min));\n}\n\
    /*\n    Alternative Solution:\n        long[] pluck(long[] arr)\n        {\n \
    \           import std.algorithm : min;\n            import std.range : iota;\n\
    \            import std.typecons : tuple;\n            auto maxInt = long.max;\n\
    \            return arr.iota.map!(y => tuple(y, arr[y]))\n                .filter!(t\
    \ => t[1] % 2 == 0)\n                .min!((a, b) => a[1] == b[1] \n         \
    \       ? a[0] < b[0] \n                : a[1] < b[1]).map!(t => t[1]).array;\n\
    \        }\n*/\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnfa9lfol.d(40): Error: no property `filter` for type `long[]`

    /tmp/tmpnfa9lfol.d(42): Error: no property `filter` for type `long[]`

    /tmp/tmpnfa9lfol.d(42): Error: no property `find` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnfa9lfol.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] res = arr.filter!(x => x %\
    \ 2 == 0).sort.dup;\n    if (res.length == 0)\n        return res;\n    else\n\
    \        return arr.filter!(x => x == res[0]).sort.dup[0..1];\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq39o56gz.d(40): Error: no property `filter` for type `long[]`

    /tmp/tmpq39o56gz.d(44): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq39o56gz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto temp = arr;\n    temp.sort();\n\
    \    long min_even = -1;\n    size_t min_even_ind = size_t.max;\n    foreach(i,\
    \ j; temp)\n    {\n        if(j % 2 == 0)\n        {\n            min_even = j;\n\
    \            break;\n        }\n    }\n    if(min_even == -1)\n        return\
    \ [];\n    foreach(i, j; temp)\n    {\n        if(j == min_even)\n        {\n\
    \            min_even_ind = i;\n            break;\n        }\n    }\n    return\
    \ [min_even, min_even_ind];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1je2vjsd.d(41): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1je2vjsd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    auto even_indices = arr.retro.retro.filter!(a\
    \ => a % 2 == 0).retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.retro.\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyyf2zpko.d(41): Error: identifier expected following `.`, not `unittest`

    /tmp/tmpyyf2zpko.d(42): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpyyf2zpko.d(54): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyyf2zpko.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{ \n    long firstEvenIdx = -1;\n    long\
    \ minValue = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0)\n     \
    \   {\n            if(firstEvenIdx == -1)\n            {\n                firstEvenIdx\
    \ = i;\n                minValue = e;\n            }\n            else\n     \
    \       {\n                if(e < minValue)\n                {\n             \
    \       firstEvenIdx = i;\n                    minValue = e;\n               \
    \ }\n            }\n        }\n    }\n    if(firstEvenIdx >= 0)\n    {\n     \
    \   return [minValue, firstEvenIdx];\n    }\n    else\n    {\n        return [];\n\
    \    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164284
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    import std.algorithm.iteration :\
    \ filter, map, max, min;\n    import std.conv : to;\n    import std.range : zip;\n\
    \    import std.algorithm.sorting : sort;\n    import std.typecons : tuple;\n\
    \    import std.traits : isIntegral;\n    import std.math : isOdd;\n    import\
    \ std.array : array;\n    import std.stdio : writeln;\n    import std.functional\
    \ : unaryFun;\n    import std.typecons : Tuple;\n    import std.algorithm.comparison\
    \ : minElement;\n    enum isEven = unaryFun!((a) => isIntegral!(a) && !isOdd(a));\n\
    \    auto evens = filter!isEven(arr);\n    writeln(evens);\n    auto it = evens.begin;\n\
    \    writeln(it);\n    auto itend = evens.end;\n    writeln(itend);\n    return\
    \ [ evens[0], 0 ];\n}\nlong[] pluck(long[] arr) \n{\n    import std.algorithm.iteration\
    \ : filter, map, max, min;\n    import std.conv : to;\n    import std.range :\
    \ zip;\n    import std.algorithm.sorting : sort;\n    import std.typecons : tuple;\n\
    \    import std.traits : isIntegral;\n    import std.math : isOdd;\n    import\
    \ std.array : array;\n    import std.stdio : writeln;\n    import std.functional\
    \ : unaryFun;\n    import std.typecons : Tuple;\n    import std.algorithm.comparison\
    \ : minElement;\n    enum isEven = unaryFun!((a) => isIntegral!(a) && !isOdd(a));\n\
    \    auto evens = filter!isEven(arr);\n    writeln(evens);\n    auto it = evens.begin;\n\
    \    writeln(it);\n    auto itend = evens.end;\n    writeln(itend);\n    return\
    \ [ evens[0], 0 ];\n}\nlong[] pluck(long[] arr) \n{\n    import std.al\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq0r4pt21.d(87): Error: `;` expected

    /tmp/tmpq0r4pt21.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq0r4pt21.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0) \n    {\n  \
    \      return [];\n    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4x5ql3ul.d(44): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4x5ql3ul.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164282
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    long[] ret = new long[2];\n    if\
    \ (arr.length == 0)\n        return ret;\n    long[] _arr = new long[arr.length\
    \ + 1];\n    for (size_t i = 0; i < arr.length; i++) {\n        _arr[i + 1] =\
    \ arr[i];\n    }\n    size_t min_elem = findMinEven(_arr);\n    if (min_elem ==\
    \ _arr.length) {\n        return ret;\n    }\n    ret[0] = _arr[min_elem];\n \
    \   for (size_t i = 0; i < arr.length; i++) {\n        if (arr[i] == _arr[min_elem])\
    \ {\n            ret[1] = i;\n            break;\n        }\n    }\n    return\
    \ ret;\n}\nsize_t findMinEven(long[] arr) \n{\n    size_t res = arr.length;\n\
    \    long min = arr[0];\n    for (size_t i = 1; i < arr.length; i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (arr[i] < min) {\n                min\
    \ = arr[i];\n                res = i;\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplv7opxyx.d(78): unittest failure

    ----------------

    ??:? _d_unittestp [0x4288dd]

    ??:? void tmplv7opxyx.__unittest_L74_C1() [0x4281be]

    ??:? void tmplv7opxyx.__modtest() [0x42865c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c997]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b82a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430ab5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430f64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430a41]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]

    ??:? runModuleUnitTests [0x42c76d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428da0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164284
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n\tlong minVal = 999999999;\n\tlong posVal\
    \ = -1;\n\t\n\tforeach(long l; arr)\n\t{\n\t\tif (l % 2 == 0 && l < minVal)\n\t\
    \t{\n\t\t\tminVal = l;\n\t\t\tposVal = arr.indexOf(l);\n\t\t}\n\t}\n\t\n\tif (posVal\
    \ == -1) return [];\n\telse return [minVal, posVal];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnza0dob4.d(48): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnza0dob4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ new long[];\n    auto result = arr.minPos!((a, b) => (a % 2 == 0) && (b % 2\
    \ == 0) ? a < b : a % 2 == 0 && b % 2 != 0);\n    if (result[0] % 2 == 0)\n  \
    \      return result;\n    return new long[];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfdolt2rr.d(41): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpfdolt2rr.d(42): Error: no property `minPos` for type `long[]`

    /tmp/tmpfdolt2rr.d(45): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfdolt2rr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164283
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    if (arr.length == 0)\n        return\
    \ [];\n    \n    long minEven = cast(long)1e9;\n    long minEvenIndex = -1;\n\
    \    foreach (i, item; arr)\n    {\n        if (item % 2 == 0 && item < minEven)\n\
    \        {\n            minEven = item;\n            minEvenIndex = i;\n     \
    \   }\n    }\n    \n    if (minEven == cast(long)1e9)\n        return [];\n  \
    \  \n    return [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164284
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in an array, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \    >>> pluck([4L, 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n    []\n   \
    \ \n    Example 4:\n    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n  \
    \  Explanation: 0 is the smallest value, but  there are two zeros,\n         \
    \        so we will choose the first zero, which has the smallest index.\n\n \
    \   Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    \n*/\nlong[] pluck(long[] arr) \n{\n    int index = 0;\n    long smallestEven\
    \ = 2147483647;\n    long[] ret = [0L,0L];\n    foreach(int i, long e; arr)\n\
    \    {\n        if(e % 2 == 0 && e < smallestEven)\n        {\n            smallestEven\
    \ = e;\n            index = i;\n        }\n    }\n    if(smallestEven == 2147483647)\n\
    \    {\n        return ret;\n    }\n    else\n    {\n        ret[0] = smallestEven;\n\
    \        ret[1] = index;\n        return ret;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp3zgeq0o.d(68): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286dd]

    ??:? void tmpp3zgeq0o.__unittest_L62_C1() [0x4280ae]

    ??:? void tmpp3zgeq0o.__modtest() [0x428460]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c73b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430761]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c10]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5a5]

    ??:? runModuleUnitTests [0x42c511]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164284
