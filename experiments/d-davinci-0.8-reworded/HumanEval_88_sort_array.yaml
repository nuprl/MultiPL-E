name: HumanEval_88_sort_array
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
  \ integers, return a cod of the given array after sorting,\n    you will sort the\
  \ given array in ascending order if the sum( first index value, last index value)\
  \ is odd,\n    or sort it in descending order if the sum( first index value, last\
  \ index value) is even.\n\n    Note:\n    * don't change the given array.\n\n  \
  \  Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n\
  \    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n  \
  \  >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n\
  \    \n*/\nlong[] sort_array(long[] array) \n"
tests: "unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
  \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
  \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
  \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
  \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
  \ 21L, 14L, 11L]);\n}\nvoid main(){}"
completions: ["{\n    // your code here\n    import std.conv;\n    long[] result =\
    \ array;\n    int sum = 0;\n    foreach(x; result)\n    {\n        sum += x;\n\
    \    }\n    if(sum % 2 == 0)\n    {\n        result.sort!((a, b) => a > b);\n\
    \    }\n    else\n    {\n        result.sort!((a, b) => a < b);\n    }\n    return\
    \ result;\n}", "{\n    int i = 0;\n    while(i < array.length)\n    {\n      \
    \  if((array[0] + array[array.length - 1]) % 2 == 0)\n        {\n            long\
    \ a = array[i];\n            long b = array[array.length - 1 - i];\n         \
    \   array[i] = b;\n            array[array.length - 1 - i] = a;\n        }\n \
    \       i++;\n    }\n    return array;\n}", "{\n    // TODO: Your code here.\n\
    \    auto result = array.dup;\n    auto len = result.length;\n    bool descending\
    \ = result[0] + result[len - 1] % 2 == 0;\n    if (descending) \n    {\n     \
    \   result.sort!((x, y) => y - x);\n    }\n    else \n    {\n        result.sort!((x,\
    \ y) => x - y);\n    }\n    return result;\n}", "{\n    long[] result = new long[array.length];\n\
    \    if(array.length == 0)\n        return result;\n    long total = 0;\n    for(long\
    \ i = 0; i < array.length; i++)\n    {\n        total += array[i];\n    }\n  \
    \  long first = array[0];\n    long last = array[array.length - 1];\n    if((first\
    \ + last) % 2 == 0)\n    {\n        std.algorithm.sort(array);\n        array.reverse();\n\
    \    }\n    else\n    {\n        std.algorithm.sort(array);\n    }\n    return\
    \ array;\n}", "{\n    int[] index = std.range(0, array.length);\n    int[long]\
    \ comparator = array.zip(index).sort;\n    if (comparator.values[0] + comparator.values[$\
    \ - 1] % 2 == 0) \n    {\n        comparator.values = comparator.values.reversed;\n\
    \    }\n    return index.map!((int i) => comparator[i]);\n}", "{\n    if (array.length\
    \ == 0 || array.length == 1) \n        return array;\n    \n    if (array[0] +\
    \ array[array.length - 1] % 2 == 0) \n        return array.sort(reverseCompare);\n\
    \    \n    return array.sort(Compare);\n}", "{\n    //  Sort the given array in\
    \ ascending order if the sum( first index value, last index value) is odd,\n \
    \   //  or sort it in descending order if the sum( first index value, last index\
    \ value) is even.\n    bool descending = cast(int)(array[0] + array[$-1]) % 2\
    \ == 0;\n    return array.sort( (a, b) => descending ? a < b : a > b);\n}", "{\n\
    \    enum ordering {\n        greater,\n        lesser\n    }\n    auto getFirstNLastSum\
    \ = (long[] arr) => {\n        import std.array;\n        return arr[0] + arr.back;\n\
    \    };\n    static bool isOdd(long n) {\n        return n % 2 == 1;\n    }\n\
    \    static bool isEven(long n) {\n        return n % 2 == 0;\n    }\n    auto\
    \ sortItems = (long[] arr, ordering o) => {\n        return o == ordering.greater\
    \ ? arr.sort(std.math.comparison!(\"a > b\")) : arr.sort(std.math.comparison!(\"\
    a < b\"));\n    };\n    static bool isEmpty(long[] arr) {\n        return arr.length\
    \ == 0;\n    }\n    static bool isSingleElement(long[] arr) {\n        return\
    \ arr.length == 1;\n    }\n    static bool isMoreThanTwo(long[] arr) {\n     \
    \   return arr.length > 2;\n    }\n    switch(true) {\n        case isEmpty(array):\n\
    \            return array;\n        case isSingleElement(array):\n           \
    \ return array;\n        case isMoreThanTwo(array):\n            if(isOdd(getFirstNLastSum(array)))\n\
    \                return sortItems(array, ordering.lesser);\n            else if(isEven(getFirstNLastSum(array)))\n\
    \                return sortItems(array, ordering.greater);\n    }\n}", "{\n \
    \   if (array.length == 0)\n        return array;\n    long sum = array[0] + array[array.length\
    \ - 1];\n    long[] ret = array.sort(x => x);\n    return (sum & 1) == 0 ? ret.reverse()\
    \ : ret;\n}", "{\n    size_t n = array.length;\n    if (n == 0) return array;\n\
    \    size_t m = n >> 1;\n    long* lhs = sort_array(array[0..m]);\n    long* rhs\
    \ = sort_array(array[m..$]);\n    if ((lhs[0] + rhs[$-1]) & 1) \n    {\n     \
    \   return lhs.sort().array() ~ rhs.sort().array();\n    }\n    else \n    {\n\
    \        return lhs.sort!q{a > b}.array() ~ rhs.sort!q{a > b}.array();\n    }\n\
    }", "{\n    return sort_array_internal(array, 0, array.length, 0);\n}", "{\n \
    \   long first_value = array[0];\n    long last_value = array[array.length - 1];\n\
    \    if((first_value + last_value) % 2 == 0)\n    {\n        std.sort(array);\n\
    \        return array;\n    }\n    else\n    {\n        std.sort(array);\n   \
    \     array.reverse();\n        return array;\n    }\n}", "{\n    int size = array.length;\n\
    \    long[] answer = array.dup;\n    bool isOdd = (array[0] + array[size - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        sort(answer);\n    }\n    else\n \
    \   {\n        sort(answer, (a, b) => b - a);\n    }\n    return answer;\n}",
  "{\n    long first = array[0];\n    long last = array[array.length - 1];\n    bool\
    \ isOdd = (first + last) % 2 == 1;\n    //std.algorithm.sort(array);\n    if (isOdd)\n\
    \    {\n        std.algorithm.sort(array);\n    }\n    else\n    {\n        array\
    \ = array.sorted;\n        array = array.reversed;\n    }\n    return array;\n\
    }", "{\n    if (array.length == 0) return array;\n    return sortArray(array);\n\
    }", "{\n    int n = array.length;\n    if (n == 0) return array;\n    bool odd\
    \ = (array[0] + array[n - 1]) % 2 == 1;\n    long[] copy = array.dup;\n    sort!((a,\
    \ b) => a < b, copy);\n    return odd ? copy : copy.reverse;\n}", "{\n  return\
    \ array.length == 0 || array.length == 1 ? array : sum(array[0], array[$ - 1])\
    \ % 2 == 0\n    ? array.sort().reverse() : array.sort();\n}", "{\n    if (array.length\
    \ == 0)\n        return array;\n    sort_by_oddness(array);\n    return array;\n\
    }", "{\n    if (array.length == 0)\n        return array;\n    auto start = array[0];\n\
    \    auto end = array[$ - 1];\n    enum direction = (start + end) % 2 == 0 ? sortDirection.descending\
    \ : sortDirection.ascending;\n    return array.sort!(direction == sortDirection.ascending\
    \ ? (x, y) => x < y : (x, y) => x > y);\n}", "{\n    if (array.length == 0)\n\
    \        return array;\n    \n    auto arraySum = array[0] + array[$-1];\n   \
    \ if (arraySum % 2 == 0)\n        return array.sort!\"a > b\";\n    \n    return\
    \ array.sort!\"a < b\";\n}", "{\n  int len = array.length;\n  if (len <= 1) return\
    \ array;\n  if ((array[0] + array[len - 1]) % 2 == 0)\n  {\n    return sort(array).idup;\n\
    \  }\n  else\n  {\n    return sort(array).dup;\n  }\n}", "{\n    auto ar = array.dup;\n\
    \    if (ar.length > 0) \n    {\n        auto len = ar.length;\n        if ((ar[0]\
    \ + ar[len - 1]) % 2 == 0) \n        {\n            ar.sort!((a, b) => a < b);\n\
    \        } \n        else \n        {\n            ar.sort!((a, b) => a > b);\n\
    \        }\n    }\n    return ar;\n}", "{\n    long[] temp = array.dup;\n    if(sum(temp[0],\
    \ temp[$-1]) % 2 == 0) {\n        temp.sort!q{b - a};\n    } else {\n        temp.sort!q{a\
    \ - b};\n    }\n    return temp;\n}", "{\n    if ( array.length == 0 )\n     \
    \   return array;\n    else if ( array.length == 1 )\n        return array;\n\
    \    else if ( array.length == 2 )\n    {\n        if ( array[0] > array[1] )\n\
    \        {\n            long temp = array[0];\n            array[0] = array[1];\n\
    \            array[1] = temp;\n        }\n        return array;\n    }\n    else\n\
    \    {\n        long sum = array[0] + array[array.length - 1];\n        if ( sum\
    \ % 2 == 0 )\n        {\n            sort(array);\n            return array.reverse();\n\
    \        }\n        else\n        {\n            sort(array);\n            return\
    \ array;\n        }\n    }\n}", "{\n    return sort_array(array, 0, array.length);\n\
    }\nlong[] sort_array(long[] array, long start, long len) \n{\n    long[] result\
    \ = new long[len];\n    if (len == 0) return result;\n    if (len == 1) {\n  \
    \      result[0] = array[start];\n        return result;\n    }\n    if (len ==\
    \ 2) {\n        if (array[start] > array[start + 1]) {\n            result[0]\
    \ = array[start + 1];\n            result[1] = array[start];\n        } else {\n\
    \            result[0] = array[start];\n            result[1] = array[start +\
    \ 1];\n        }\n        return result;\n    }\n    long half_len = len / 2;\n\
    \    long[] array1 = sort_array(array, start, half_len);\n    long[] array2 =\
    \ sort_array(array, start + half_len, len - half_len);\n    long i = 0;\n    long\
    \ j = 0;\n    if ((array1[0] + array1[array1.length - 1]) % 2 == 0) {\n      \
    \  while (i < array1.length && j < array2.length) {\n            if (array1[i]\
    \ > array2[j]) {\n                result[i + j] = array1[i];\n               \
    \ i++;\n            } else {\n                result[i + j] = array2[j];\n   \
    \             j++;\n            }\n        }\n        while (i < array1.length)\
    \ {\n            result[i + j] = array1[i];\n            i++;\n        }\n   \
    \     while (j < array2.length) {\n            result[i + j] = array2[j];\n  \
    \          j++;\n        }\n    } else {\n        while (i < array1.length &&\
    \ j < array2.length) {\n            if (array1[i] < array2[j]) {\n           \
    \     result[i + j] = array1[i];\n                i++;\n            } else {\n\
    \                result[i + j] = array2[j];\n                j++;\n          \
    \  }\n        }\n        while (", "{\n    if (array.length < 2)\n        return\
    \ array;\n    \n    long a = array[0];\n    long b = array[array.length - 1];\n\
    \    bool c = false;\n    if ((a + b) % 2 == 0)\n        c = true;\n    \n   \
    \ auto t = tuple(a, b, c);\n    return array.sort!( (l, r) => (t[0] + t[1]) %\
    \ 2 == 0 ? l > r : l < r );\n}", "{\n    if (array.length == 0)\n        return\
    \ array;\n    if (array.length == 1)\n        return array;\n    long first =\
    \ array[0];\n    long last = array[array.length - 1];\n    bool ascending = (first\
    \ + last) % 2 == 1;\n    if (ascending)\n        array.sort(int.compare);\n  \
    \  else\n        array.sort(int.compare).reverse();\n    return array;\n}", "{\n\
    \    size_t length = array.length;\n    if (length == 0L)\n        return array;\n\
    \    const bool odd_count = (array[0L] + array[length - 1L]) % 2L == 1L;\n   \
    \ if (odd_count)\n        std.algorithm.sort(array, (n, m) => n < m);\n    else\n\
    \        std.algorithm.sort(array, (n, m) => n > m);\n    return array;\n}", "{\n\
    \    if (array.length == 0) return array;\n    int isReverse = (array[0] + array[array.length\
    \ - 1]) % 2;\n    return array.sort.opCall() * (isReverse * -1 + 1);\n}", "{\n\
    \    return array.sort();\n}", "{\n    auto copy_array = copy(array);", "{\n \
    \   /*\n    int len = array.length;\n    if (len == 0)\n        return array;\n\
    \    long temp = 0;\n    bool swapped = false;\n    if (len > 1)\n    {\n    \
    \    for (int i = 0; i < len - 1; i++)\n        {\n            swapped = false;\n\
    \            for (int j = 0; j < len - i - 1; j++)\n            {\n          \
    \      if (array[j] > array[j + 1])\n                {\n                    temp\
    \ = array[j];\n                    array[j] = array[j + 1];\n                \
    \    array[j + 1] = temp;\n                    swapped = true;\n             \
    \   }\n            }\n            if (!swapped)\n                break;\n    \
    \    }\n    }\n    return array;\n    */\n    auto len = array.length;\n    auto\
    \ sum = array[0] + array[len - 1];\n    auto cmp = (sum % 2 == 0) ? (int a, int\
    \ b) { return a > b; } : (int a, int b) { return a < b; };\n    array = array.sort(cmp);\n\
    \    return array;\n}", "{\n    long[] s = array.dup;\n    if (s.length <= 1)\
    \ return s;\n    long sum = s[0] + s[$ - 1];\n    bool asc = (sum % 2L) == 1L;\n\
    \    sort(asc ? s : s.dup.reverse);\n    return s;\n}", "{\n    long temp, sum;\n\
    \    auto index = array.length;\n    auto findex = 0;\n    auto maxindex = 0;\n\
    \    auto minindex = 0;\n    auto max = 0;\n    auto min = 0;\n    sum = array[0]\
    \ + array[index - 1];\n    //Sorting in descending order if sum is even\n    if\
    \ (sum % 2 == 0)\n    {\n        for (int i = 0; i < index; i++)\n        {\n\
    \            for (int j = i + 1; j < index; j++)\n            {\n            \
    \    if (array[i] < array[j])\n                {\n                    temp = array[i];\n\
    \                    array[i] = array[j];\n                    array[j] = temp;\n\
    \                }\n            }\n        }\n    }\n    //Sorting in ascending\
    \ order if sum is odd\n    else\n    {\n        for (int i = 0; i < index; i++)\n\
    \        {\n            for (int j = i + 1; j < index; j++)\n            {\n \
    \               if (array[i] > array[j])\n                {\n                \
    \    temp = array[i];\n                    array[i] = array[j];\n            \
    \        array[j] = temp;\n                }\n            }\n        }\n    }\n\
    \    return array;\n}", "{\n  long s = 0L;\n  if(array.length)\n  {\n    s = array[0]\
    \ + array[array.length - 1];\n  }\n  if(s % 2)\n  {\n    return array.sort();\n\
    \  }\n  else\n  {\n    return array.sort((a, b) => b - a);\n  }\n}", "{\n    long\
    \ idx = array.length;\n    if (idx < 2)\n        return array;\n    long f = array[0];\n\
    \    long l = array[idx - 1];\n    auto s = tuple(sum,f,l);\n    std.algorithm.sort(array,\
    \ (a, b) => a < b);\n    if (s % 2 == 0)\n        return array.reversed.array;\n\
    \    return array;\n}", "{\n    long[] sorted = array.dup;\n    qsort(sorted);\n\
    \    long sum = sorted[0] + sorted[$-1];\n    return sum % 2 == 0 ? sorted : sorted.reversed;\n\
    }", "{\n    if (array.length > 0)\n    {\n        long first = array[0];\n   \
    \     long last = array[array.length - 1];\n        if ((first + last) % 2 !=\
    \ 0)\n        {\n            std.sort(array);\n        }\n        else\n     \
    \   {\n            array = std.sort(array);\n            array = array.reverse();\n\
    \        }\n    }\n    return array;\n}\n// END", "{\n    static struct Tuple1(T)\
    \ {T[] array; long sum;}\n    static int pred(Tuple1!(long) lhs, Tuple1!(long)\
    \ rhs) {\n        return lhs.sum < rhs.sum;\n    }\n    auto tmp = Tuple1!(long)(array[0L..$].dup);\n\
    \    tmp.sum = array[0L] + array[$-1L];\n    const a = [tmp];\n    while (true)\n\
    \    {\n        const index = a.lowerBound!pred(tmp).array.length;\n        a.insert(index,\
    \ tmp);\n        if (tmp.array.length == array.length)\n            break;\n \
    \       tmp.array.insert(0L, array[tmp.array.length]);\n        tmp.sum += array[tmp.array.length];\n\
    \    }\n    return a.map!(x => x.array).array.joiner.join;\n}", "{\n    if (array.length\
    \ == 0) return array;\n    enum flag { ASC, DESC }\n    alias ascflag = flag.ASC;\n\
    \    alias descflag = flag.DESC;\n    const(flag) order = (array[0] + array[$-1])\
    \ % 2 == 0 ? descflag : ascflag;\n    auto rng = array[];\n    // ok, we use insertion\
    \ sort here, as it is so easy to implement.\n    if (order == ascflag)\n    {\n\
    \        foreach (i, a; rng)\n        {\n            foreach (j, b; rng[i+1..$])\n\
    \            {\n                if (a > b)\n                {\n              \
    \      long t = a;\n                    a = b;\n                    b = t;\n \
    \               }\n            }\n        }\n    }\n    else\n    {\n        foreach\
    \ (i, a; rng)\n        {\n            foreach (j, b; rng[i+1..$])\n          \
    \  {\n                if (a < b)\n                {\n                    long\
    \ t = a;\n                    a = b;\n                    b = t;\n           \
    \     }\n            }\n        }\n    }\n    return rng;\n}", "{\n    size_t\
    \ len = array.length;\n    if (len <= 1)\n        return array;\n    auto sum\
    \ = array[0] + array[len - 1];\n    auto predicate = sum % 2 ? (a, b) { return\
    \ a > b; }\n                             : (a, b) { return a < b; };\n    quickSort(array[],\
    \ predicate);\n    return array;\n}", "{\n    if (array.length <= 1)\n       \
    \ return array;\n    \n    alias Result = Tuple!(long, bool);\n    bool isEven\
    \ = (array[0] + array[$ - 1]) % 2 == 0;\n    auto comparator = isEven ? (a, b)\
    \ => b - a : (a, b) => a - b;\n    auto result = array.map!(n => Result(n, n %\
    \ 2 == 0)).sort!((a, b) => comparator(a[0], b[0]));\n    return result.map!(r\
    \ => r[0]).array;\n}", "{\n    if (array.length == 0) return array;\n    return\
    \ array.indexSum % 2 == 0 ? array.sort() : array.sort((a, b) => b - a);\n}", "{\n\
    \    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        if ((array[0] + array[$\
    \ - 1]) % 2 == 0)\n            std.algorithm.sort(array, CompareType.byValueDescending);\n\
    \        else\n            std.algorithm.sort(array, CompareType.byValue);\n \
    \   }\n    return array;\n}", "{\n    if (array.length == 0)\n        return array;\n\
    \    \n    if (sum(array[0], array[$ - 1]) % 2 != 0)\n        return array.sort();\n\
    \    else\n        return sort(array, (lhs, rhs) => rhs - lhs);\n}", "{\n    alias\
    \ NumPair = Tuple!(long, long);\n    long sum = array[0] + array[$ - 1];\n   \
    \ NumPair[] sortedArray = array.map!( (x) => NumPair(x, x) );\n    sum.odd\n \
    \       ? sortedArray.sort!( (a, b) => a[0] < b[0] )\n        : sortedArray.sort!(\
    \ (a, b) => a[0] > b[0] );\n    return sortedArray.map!( (x) => x[0] ).array;\n\
    }", "{\n    long[] sorted_array = new long[array.length];\n    for (int i = 0;\
    \ i < array.length; i++)\n    {\n        sorted_array[i] = array[i];\n    }\n\
    \    if ((sorted_array[0] + sorted_array[sorted_array.length - 1]) % 2 == 0)\n\
    \    {\n        sort(sorted_array.sorted, (a, b) => a > b);\n    }\n    else\n\
    \    {\n        sort(sorted_array.sorted, (a, b) => a < b);\n    }\n    return\
    \ sorted_array;\n}", "{\n    // Your code here\n    // Before sorting, make a\
    \ copy of the given array.\n    auto copy = array.dup;\n    // If the sum of the\
    \ first and last value of the given array is even, sort the copy in descending\
    \ order.\n    if ((array[0] + array[$-1]) % 2 == 0)\n    {\n        sort(copy,\
    \ (long a, long b) => b < a);\n    }\n    // If the sum of the first and last\
    \ value of the given array is odd, sort the copy in ascending order.\n    else\n\
    \    {\n        sort(copy);\n    }\n    return copy;\n}", "{\n    if (array.length\
    \ == 0) return array;\n    long[][] index_value = new long[array.length][2];\n\
    \    foreach (int i, long v; array)\n    {\n        index_value[i][0] = i;\n \
    \       index_value[i][1] = v;\n    }\n    sort(index_value);\n    long[] array_copy\
    \ = array[];\n    foreach (i, int v; index_value)\n    {\n        array_copy[v[0]]\
    \ = v[1];\n    }\n    return array_copy;\n}\n/*\n    s = \"Python is Good programming\
    \ language\"\n    >>> str = \"Python is Good programming language\"\n    >>> fn(str)\n\
    \    'g'\n    >>> s = \"Hello World\"\n    >>> fn(s)\n    'w'\n    >>> s = \"\
    Python is Fun\"\n    >>> fn(s)\n    'f'\n    >>> s = \"dfdsfsd\"\n    >>> fn(s)\n\
    \    'd'\n    >>> s = \"zlekzbl\"\n    >>> fn(s)\n    'l'\n    >>> s = \"How are\
    \ you\"\n    >>> fn(s)\n    'w'\n    >>> s = \"How are you\"\n    >>> fn(s)\n\
    \    'w'\n*/\nchar fn(string s)\n{\n    string s_l = toLower(s);\n    string s_u\
    \ = toUpper(s);\n    char[][] char_arr = new char[][](\n        s_l,\n       \
    \ s_u\n    );\n    int[][] char_count = new int[2][256];\n    foreach (i, char[]\
    \ s; char_arr)\n    {\n        foreach (j, char c; s)\n        {\n           \
    \ char_count[i][c]++;\n        }\n    }\n    int[] counts = new int[2];\n    foreach\
    \ (i, char[] s; char_arr)\n    {\n        foreach (j, char c; s)\n        {\n\
    \            if (char_count[i][c] == 1)\n            {\n                counts[i",
  "{\n    if (array.length < 2) return array;\n    auto compare = (array[0L] + array[$\
    \ - 1L]) % 2L == 0 ? std.math.comparator!\"a > b\" : std.math.comparator!\"a <\
    \ b\";\n    return array.sort!(compare);\n}", "{\n    if (array.length == 0) return\
    \ array;\n    if (array.length == 1) return array;\n    long sum = array[0] +\
    \ array[array.length - 1];\n    if (sum % 2 == 0) \n    {\n        return array.sort!((a,\
    \ b) => b - a);\n    }\n    else \n    {\n        return array.sort!((a, b) =>\
    \ a - b);\n    }\n}", "{\n    if (array.length == 0)\n        return new long[0];\n\
    \    \n    bool is_even = (array[0] + array[$ - 1]) % 2 == 0;\n    auto cmp =\
    \ is_even ? std.functional.greater : std.functional.less;\n    return std.algorithm.sort(array,\
    \ cmp);\n}", "{\n    if (array.length == 0) return array;\n    long first_index\
    \ = array[0];\n    long last_index = array[array.length - 1];\n    if ((first_index\
    \ + last_index) % 2 != 0) {\n        array.sort;\n    } else {\n        array.sort.retro;\n\
    \    }\n    return array;\n}", "{ \n    int first_idx = 0;\n    int last_idx =\
    \ array.length - 1;\n    int first_value = array[first_idx];\n    int last_value\
    \ = array[last_idx];\n    int sum = first_value + last_value;\n    bool odd =\
    \ sum % 2 != 0;\n    auto tup = odd ? tuple(first_idx, last_idx) : tuple(last_idx,\
    \ first_idx);\n    auto tup_result = odd ? tuple(first_value, last_value) : tuple(last_value,\
    \ first_value);\n    auto results = to!(long[])([]);\n    int fst_idx = tup[0];\n\
    \    int sec_idx = tup[1];\n    long fst_val = tup_result[0];\n    long sec_val\
    \ = tup_result[1];\n    results ~= fst_val;\n    results ~= sec_val;\n    for\
    \ (int i = 0; i < array.length; i++)\n    {\n        int value = array[i];\n \
    \       if (value == fst_val || value == sec_val)\n        {\n            continue;\n\
    \        }\n        results ~= value;\n    }\n    sort(results);\n    return results;\n\
    }", "{\n    bool odd = (array.front + array.back) % 2 == 1;\n    auto tuple =\
    \ zip(array, iota(array.length));\n    auto tup = tuple.filter!((a, i) => a %\
    \ 2 == odd);\n    auto tup_sorted = tup.sort!((a, b) => a[0] > b[0]);\n    auto\
    \ tuple_sorted = tuple.sort!((a, b) => a[0] > b[0]);\n    long[] result = tuple_sorted\n\
    \        .map!((a, i) => a[0])\n        .map!((a, i) => \n        {\n        \
    \    if (i < tup_sorted.length)\n            {\n                return tup_sorted[i][0];\n\
    \            }\n            else\n            {\n                return a;\n \
    \           }\n        }\n        );\n    return result;\n}", "{\n    long[] the_array\
    \ = new long[array.length];\n    int the_end = array.length - 1;\n    int the_begin\
    \ = 0;\n    while (the_begin < the_end)\n    {\n        the_array[the_begin] =\
    \ array[the_begin];\n        the_array[the_end] = array[the_end];\n        the_begin++;\n\
    \        the_end--;\n    }\n    if (the_begin == the_end)\n    {\n        the_array[the_begin]\
    \ = array[the_begin];\n    }\n    if ((the_array[0] + the_array[the_array.length\
    \ - 1]) % 2 == 0)\n    {\n        return the_array.sort().array();\n    }\n  \
    \  else\n    {\n        return the_array.sort(std.typecons.greater).array();\n\
    \    }\n}", "{\n    long sum = array[0] + array[array.length - 1];\n    return\
    \ sum % 2 == 0 ? \n      sort!((a, b) => a > b)(array) :\n      sort!((a, b) =>\
    \ a < b)(array);\n}", "{\n    enum OP = typeof(sort_array).OP;\n    return sort_arrayImpl!(OP.asc)(array);\n\
    }", "{\n    if (array.length == 0) return array;\n    int start = 0;\n    int\
    \ end = array.length - 1;\n    if ((array[start] + array[end]) % 2 == 0) // check\
    \ if the sum of ( first index value, last index value) is even.\n    {\n     \
    \   sort!((x, y) => -(x > y))(array); // sort in descending order \n    }\n  \
    \  else\n    {\n        sort!((x, y) => x > y)(array); // sort in ascending order\
    \ \n    }\n    return array;\n}", "{\n  long[] r = array;\n  if(array.length ==\
    \ 0)\n    return array;\n  else if(array.length == 1)\n    return array;\n  else\n\
    \  {\n    bool asc = ((array[0] + array[array.length - 1]) % 2) == 0;\n    if(asc)\n\
    \      r.sort;\n    else\n      r.sort(std.typecons.scalar(long, -a));\n  }\n\
    \  return r;\n}", "{\n\tif (array.length == 0)\n\t\treturn new long[0];\n\tlong\
    \ first = array[0];\n\tlong last = array[array.length - 1];\n\tlong[] res = array.dup;\n\
    \tif ((first + last) % 2 == 0)\n\t\treturn res.sort(std.typecons.greater);\n\t\
    else\n\t\treturn res.sort(std.typecons.less);\n}", "{\n    return array.dup.sort;\n\
    }", "{\n    if (array.length == 0 || array.length == 1)\n        return array;\n\
    \    else\n    {\n        long first_value = array[0];\n        long last_value\
    \ = array[array.length - 1];\n        long sum = first_value + last_value;\n \
    \       if (sum % 2 == 0)\n            array.sort(std.typecons.unaryFun!((ref\
    \ long x, ref long y) => x > y));\n        else\n            array.sort(std.typecons.unaryFun!((ref\
    \ long x, ref long y) => x < y));\n        return array;\n    }\n}", "{\n    if\
    \ (array.length == 0)\n        return array;\n    if (array.length == 1)\n   \
    \     return array;\n    return iota(0L, array.length)\n        .map!(i => tuple(i,\
    \ array[i]))\n        .sort!((a, b) => a[1] < b[1])\n        .map!(a => a[1])\n\
    \        .array;\n}", "{\n    // Get the sum of the first and last elements\n\
    \    auto sum = array[0] + array[$-1];\n    // Get a copy of the array\n    auto\
    \ c = array.dup;\n    // Sort the array in descending order if sum is even\n \
    \   if (sum % 2 == 0)\n    {\n        c.sort!q{ b > a }();\n    }\n    // Sort\
    \ the array in ascending order if sum is odd\n    else\n    {\n        c.sort!q{\
    \ a < b }();\n    }\n    // Return the sorted array\n    return c;\n}", "{\n \
    \   auto result = array;\n    if (result.length > 0)\n    {\n        // code goes\
    \ here\n        if (result[0] + result[$-1] % 2 == 0)\n        {\n           \
    \ sort!((a, b) => a > b)(result);\n        }\n        else\n        {\n      \
    \      sort!((a, b) => a < b)(result);\n        }\n    }\n    return result;\n\
    }", "{\n    immutable long sum = array[0] + array[$-1];\n    immutable long n\
    \ = array.length;\n    immutable bool is_even = sum % 2 == 0;\n    immutable long\
    \ end = n - 1;\n    bool done = false;\n    for (; !done;) \n    {\n        done\
    \ = true;\n        for (immutable long i = 0; i < end; ++i) \n        {\n    \
    \        if (is_even ? array[i] < array[i + 1] : array[i] > array[i + 1]) \n \
    \           {\n                long tmp = array[i];\n                array[i]\
    \ = array[i + 1];\n                array[i + 1] = tmp;\n                done =\
    \ false;\n            }\n        }\n        --end;\n    }\n    return array;\n\
    }", "in {\n    assert( array.length == 0 || array.length > 0 && array.length <\
    \ 10000);\n    assert( forall(int i; 0 <= i && i < array.length; 0 <= array[i]\
    \ && array[i] <= 9));\n}\nout {\n    assert( result.length == array.length);\n\
    \    assert( forall(int i; 0 <= i && i < result.length - 1; result[i] <= result[i\
    \ + 1]));\n    if( array.length == 0) {\n        assert( result.length == 0);\n\
    \    } else {\n        if((array[0] + array[array.length - 1]) % 2 == 0) {\n \
    \           assert( forall(int i; 0 <= i && i < result.length - 1; result[i] >=\
    \ result[i + 1]));\n        } else {\n            assert( forall(int i; 0 <= i\
    \ && i < result.length - 1; result[i] <= result[i + 1]));\n        }\n    }\n\
    }\n{\n    typeof(array) result;\n    if( array.length == 0) {\n        result\
    \ = array;\n    } else {\n        long[] result1 = sort(array);\n        if((array[0]\
    \ + array[array.length - 1]) % 2 == 0) {\n            result = reverse(result1);\n\
    \        } else {\n            result = result1;\n        }\n    }\n    return\
    \ result;\n}", "{\n    if (array.length == 0) return array;\n    auto comp = array[0]\
    \ + array[$-1] == 1 ? std.functional.greater : std.functional.less;\n    return\
    \ array.sort!(comp);\n}", "{\n    long[long[]] new_array = [array[$ - 1L .. 0L]];\n\
    \    ulong len = array.length;\n    int i = 0;\n    int j = 0;\n    if(len ==\
    \ 0)\n    {\n        return [0L];\n    }\n    if(len == 1)\n    {\n        return\
    \ [array[0L]];\n    }\n    if(array[0L] + array[$ - 1L] % 2 == 0)\n    {\n   \
    \     foreach(index, value; array)\n        {\n            new_array[j][i] = value;\n\
    \            i++;\n        }\n        sort(new_array[j]);\n        return new_array[j];\n\
    \    }\n    else\n    {\n        foreach(index, value; array)\n        {\n   \
    \         new_array[j][i] = value;\n            i++;\n        }\n        sort(new_array[j],\
    \ std.algorithm.sorting.greater);\n        return new_array[j];\n    }\n}", "{\n\
    \    if (array.length == 0) \n        return array;\n    \n    bool is_ascending\
    \ = (array[0] + array[array.length - 1]) % 2 == 0;\n    long[] result = array.dup;\n\
    \    result.sort(is_ascending ? std.math.less : std.math.greater);\n    return\
    \ result;\n}", "{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array[0] + array[array.length - 1] % 2\
    \ == 0)\n        return sort(array, false);\n    else\n        return sort(array,\
    \ true);\n}", "{\n    if (array.length == 0) return new long[0];\n    if (array.length\
    \ == 1) return array;\n    auto array_copy = new long[](array.length);\n    auto\
    \ idx = array.length - 1;\n    size_t asc_idx = 0;\n    size_t desc_idx = idx;\n\
    \    if ((array[0] + array[idx]) % 2 == 0)\n    {\n        while (idx > 0)\n \
    \       {\n            if (array[asc_idx] % 2 == 0)\n            {\n         \
    \       array_copy[asc_idx] = array[asc_idx];\n                ++asc_idx;\n  \
    \          }\n            else\n            {\n                array_copy[desc_idx]\
    \ = array[asc_idx];\n                --desc_idx;\n            }\n            --idx;\n\
    \        }\n    }\n    else\n    {\n        while (idx > 0)\n        {\n     \
    \       if (array[asc_idx] % 2 == 0)\n            {\n                array_copy[desc_idx]\
    \ = array[asc_idx];\n                --desc_idx;\n            }\n            else\n\
    \            {\n                array_copy[asc_idx] = array[asc_idx];\n      \
    \          ++asc_idx;\n            }\n            --idx;\n        }\n    }\n \
    \   sort(array_copy);\n    return array_copy;\n}", "{\n  long[] result = new long[array.length];\n\
    \  if(array.length == 0 || array.length == 1) return array;\n  if((array[0] +\
    \ array[array.length - 1]) % 2 == 0) \n  {\n      int j = array.length - 1;\n\
    \      for(int i = 0; i < array.length; i++)\n      {\n          result[i] = array[j];\n\
    \          j--;\n      }\n  }\n  else \n  {\n      int i = 0;\n      int j = array.length\
    \ - 1;\n      while(i <= j)\n      {\n          if(array[i] % 2 != 0) i++;\n \
    \         if(array[j] % 2 != 0) j--;\n          if(array[i] % 2 == 0 && array[j]\
    \ % 2 == 0) \n          {\n              result[i] = array[i];\n             \
    \ result[j] = array[j];\n              i++;\n              j--;\n          }\n\
    \      }\n  }\n  return result;\n}", "{\n    if (array.length == 0) return array;\n\
    \    auto v = array.dup;\n    bool isOdd = ((v[0] + v[$-1]) % 2 == 1);\n    stableSort(v,\
    \ (a, b) => isOdd ? a < b : a > b);\n    return v;\n}", "{\n    alias tuple =\
    \ Tuple!(long, long);\n    alias arr = tuple[];\n    if (array.length == 0)\n\
    \        return array;\n    arr temp = new arr;\n    foreach (int i, long e; array)\n\
    \        temp ~= tuple(i, e);\n    temp.sort!(\n            (tuple a, tuple b)\
    \ => \n            {\n                auto sum = a[0] + b[0];\n              \
    \  if (sum % 2 == 0)\n                    return b[1] - a[1];\n              \
    \  else\n                    return a[1] - b[1];\n            }\n        );\n\
    \    foreach (tuple t; temp)\n        array[t[0]] = t[1];\n    return array;\n\
    }", "{\n    long[] r = null;\n    r = array.dup;\n    if (r.length < 1)\n    \
    \    return r;\n    if (r.length == 1)\n        return r;\n    long first = r[0];\n\
    \    long last = r[r.length - 1];\n    if ((first + last) % 2 == 0)\n    {\n \
    \       r.sort(long());\n        r.reverse;\n    }\n    else\n    {\n        r.sort(long());\n\
    \    }\n    return r;\n}", "{ \n    if (array.length == 0 || array.length == 1)\n\
    \        return array;\n    auto res = array.dup;\n    if ((array[0] + array[$-1])\
    \ % 2 == 0)\n        res.sort!(a, b => a > b);\n    else\n        res.sort!(a,\
    \ b => a < b);\n    return res;\n}", "{\n    long temp;\n    int index;\n    int\
    \ odd = (array.length % 2 == 0) ? 1 : 0;\n    for (int i = 0; i < array.length/2;\
    \ i++)\n    {\n        index = array.length - 1 - i;\n        if ((array[i] %\
    \ 2 == 0) && (array[index] % 2 == 0))\n        {\n            temp = (odd == 1)\
    \ ? array[i] : array[index];\n            array[i] = (odd == 1) ? array[index]\
    \ : array[i];\n            array[index] = temp;\n        }\n        else if ((array[i]\
    \ % 2 == 0) && (array[index] % 2 != 0))\n        {\n            temp = array[i];\n\
    \            array[i] = array[index - 1];\n            array[index - 1] = temp;\n\
    \        }\n        else if ((array[i] % 2 != 0) && (array[index] % 2 == 0))\n\
    \        {\n            temp = array[i + 1];\n            array[i + 1] = array[index];\n\
    \            array[index] = temp;\n        }\n    }\n    return array;\n}", "{\
    \ \n  if(array.length==0)\n    return [];\n  else if(array.length==1)\n    return\
    \ array;\n  \n  auto sum = array[0] + array[$-1];\n  if(sum%2==0)\n    return\
    \ sort(array, (a, b) => -cmp(a, b));\n  else\n    return sort(array, (a, b) =>\
    \ cmp(a, b));\n}", "{\n    if (array.length == 0)\n        return array;\n   \
    \ \n    long[] A = array.dup;\n    auto sort = (A.length % 2 == 0) ? A.sort()\
    \ : A.sort.reverse();\n    return sort.array;\n}", "{\n    /*your code here*/\n\
    \    if (array.length <= 1)\n        return array;\n    long[] copy = array.dup;\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n        std.algorithm.sort(copy,\
    \ std.numeric.ordering.greater);\n    else\n        std.algorithm.sort(copy);\n\
    \    return copy;\n}", "{\n    if (array.length == 0) return array;\n    auto\
    \ result = array.dup;\n    //auto result = array.opSlice();\n    //result.sort();\n\
    \    auto original_first = array[0];\n    auto original_last = array[$-1];\n \
    \   // alias\n    long first = result[0];\n    long last = result[$-1];\n    long\
    \ first_index = 0;\n    long last_index = result.length - 1;\n    //\n    if ((first\
    \ + last) % 2 == 0) \n    {\n        result.sort;\n        //\n        auto temp\
    \ = result[first_index];\n        result[first_index] = result[last_index];\n\
    \        result[last_index] = temp;\n        //\n        temp = result[0];\n \
    \       result[0] = result[$-1];\n        result[$-1] = temp;\n    }\n    else\n\
    \    {\n        result.sort;\n    }\n    //\n    auto temp = result[0];\n    result[0]\
    \ = result[$-1];\n    result[$-1] = temp;\n    //\n    temp = result[first_index];\n\
    \    result[first_index] = result[last_index];\n    result[last_index] = temp;\n\
    \    //\n    return result;\n}", "{\n    auto pred = (a, b) => (a[0] + a[$ - 1])\
    \ % 2 < (b[0] + b[$ - 1]) % 2;\n    return array.sort!(pred).map!(e => e.idup).array;\n\
    }", "{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    const reverse_array = array.reverse();\n \
    \   auto first_value = reverse_array[0];\n    auto last_value = reverse_array[reverse_array.length\
    \ - 1];\n    if ((first_value + last_value) % 2 == 0)\n        return reverse_array;\n\
    \    return array;\n}", "in\n{\n    assert(array.length > 0);\n    assert(array.length\
    \ <= 100);\n    foreach(long number; array)\n    {\n        assert(number >= 0L);\n\
    \        assert(number <= 100);\n    }\n}\nout\n{\n    assert(array.length > 0);\n\
    \    assert(array.length <= 100);\n    foreach(long number; array)\n    {\n  \
    \      assert(number >= 0L);\n        assert(number <= 100);\n    }\n}\nbody\n\
    {\n    if(array.length == 1)\n    {\n        return array;\n    }\n    else\n\
    \    {\n        if((array[0] + array[$-1]) % 2L == 0L)\n        {\n          \
    \  auto result = sort!(\"a > b\")(array);\n            return result;\n      \
    \  }\n        else\n        {\n            auto result = sort!(\"a < b\")(array);\n\
    \            return result;\n        }\n    }\n}", "{ \n    bool sort_order =\
    \ (array.length > 0) && ((array[0] + array[$-1]) % 2 == 0);\n    auto [sorted_array,\
    \ _] = sort(array, sort_order);\n    return sorted_array;\n}", "{\n    // Your\
    \ code goes here!\n    return array.dup.sort(array.front + array.back & 1 ? (long\
    \ a, long b) => b - a : (long a, long b) => a - b);\n}\n/*\n    Augmented Assignment\
    \ Operators", "{\n  auto size = array.length;\n  if (size == 0)\n    return [];\n\
    \  \n  return (array[0] + array[$-1]) % 2 != 0 ? array.sort.idup : array.sort.idup.retro;\n\
    }", "{\n  bool odd = (array.length > 0) && (array[0] + array[$-1]) % 2 == 1;\n\
    \  return array.sort!((a, b) => odd ? b < a : a < b);\n}", "{\n    if (array.length\
    \ == 0 || array.length == 1) \n        return array;\n    auto odd = array[0]\
    \ + array[$-1] % 2;\n    return array.sorted.array(odd ? std.cmp.greater : std.cmp.less);\n\
    }", "{\n    long temp;\n    bool odd = (array[0] + array[array.length - 1]) %\
    \ 2;\n    for (int i = 0; i < array.length; i++)\n    {\n        for (int j =\
    \ 0; j < array.length - 1; j++)\n        {\n            if ((array[j] > array[j\
    \ + 1]) == odd)\n            {\n                temp = array[j];\n           \
    \     array[j] = array[j + 1];\n                array[j + 1] = temp;\n       \
    \     }\n        }\n    }\n    return array;\n}", "{ \n    if (array.length ==\
    \ 0) return array;\n    long[] result = new long[array.length];\n    //tuple represents\
    \ the start and end index of the array which needs to be sorted.\n    tuple!(int,\
    \ int) idx = tuple(0, array.length - 1);\n    while (idx[0] < idx[1])\n    {\n\
    \        if ((array[idx[0]] + array[idx[1]]) % 2 == 0) //sort in descending order\n\
    \        {\n            result[idx[1]] = array[idx[0]];\n            result[idx[0]]\
    \ = array[idx[1]];\n        }\n        else //sort in ascending order\n      \
    \  {\n            result[idx[0]] = array[idx[0]];\n            result[idx[1]]\
    \ = array[idx[1]];\n        }\n        idx[0]++;\n        idx[1]--;\n    }\n \
    \   return result;\n}\n ", "{\n    if ( array.length & 1L == 1L ) {\n        std.array.sort(array);\n\
    \    } else {\n        std.array.sort(array, std.less, (a, b) => b - a);\n   \
    \ }\n    return array;\n}", "{\n    if (array.length == 0) return array;\n   \
    \ long first = array[0];\n    long last = array[array.length - 1];\n    sort(array);\n\
    \    if ((first + last) % 2 == 0)\n        reverse(array);\n    return array;\n\
    }", "{\n    if (array.length < 2) return array;\n    int first = 0;\n    int last\
    \ = array.length - 1;\n    long firstValue = array[first];\n    long lastValue\
    \ = array[last];\n    if ((firstValue + lastValue) % 2 == 0)\n    {\n        while\
    \ (first < last)\n        {\n            while (first < last && array[first] <\
    \ array[last])\n            {\n                long temp = array[first];\n   \
    \             array[first] = array[last];\n                array[last] = temp;\n\
    \                first++;\n                last--;\n            }\n          \
    \  while (first < last && array[first] >= array[last])\n            {\n      \
    \          last--;\n            }\n        }\n    }\n    else\n    {\n       \
    \ while (first < last)\n        {\n            while (first < last && array[first]\
    \ > array[last])\n            {\n                long temp = array[first];\n \
    \               array[first] = array[last];\n                array[last] = temp;\n\
    \                first++;\n                last--;\n            }\n          \
    \  while (first < last && array[first] <= array[last])\n            {\n      \
    \          last--;\n            }\n        }\n    }\n    return array;\n}", "{\n\
    \    return array.sum == 0 || array.sum % 2 == 0 ? sort(array,std.sort.descending)\
    \ : sort(array,std.sort.ascending);\n}\n/*", "{\n    long[] result = array.dup;\n\
    \    //return (result.length % 2 == 0) ? result.sort(std.typecons.greater) : result.sort(std.typecons.less);\n\
    \    return (result.sum % 2 == 0) ? result.sort(std.typecons.greater) : result.sort(std.typecons.less);\n\
    }", "{\n    if (array.length == 0 || array.length == 1)\n        return array;\n\
    \    \n    long[] ret = array.dup;\n    bool od = array[0] % 2;\n    auto f =\
    \ (long a, long b) {\n        bool aod = a % 2;\n        bool bod = b % 2;\n \
    \       if (aod != bod) {\n            if (aod == od)\n                return\
    \ -1;\n            return 1;\n        }\n        if (aod == od)\n            return\
    \ a - b;\n        return b - a;\n    };\n    ret.sort(f);\n    return ret;\n}",
  "{\n    if (array.length == 0) \n        return array;\n    if (array.length ==\
    \ 1) \n        return array;\n    if ((array[0] + array[array.length - 1]) % 2\
    \ == 0) \n        return rsort(array);\n    else \n        return sort(array);\n\
    }\nlong[] sort(long[] array) \n{\n    return array.sort();\n}\nlong[] rsort(long[]\
    \ array) \n{\n    return array.rsort();\n}", "{\n    auto length = array.length;\n\
    \    if (length == 0) return array;\n    bool sort_asc = (array[0] + array[length\
    \ - 1]) % 2 == 1;\n    sort(array, sort_asc ? (a, b) => a < b : (a, b) => a >\
    \ b);\n    return array;\n}", "{\n    if (array.length == 0 || array.length ==\
    \ 1)\n        return array;\n    auto result = array.dup;\n    if ( (result[0]\
    \ + result[$-1]) % 2 == 0)\n        result.sort!((a, b) => b.cmp(a));\n    else\n\
    \        result.sort!((a, b) => a.cmp(b));\n    return result;\n}", "{\n    auto\
    \ int64 = typeof(array[0]);\n    array = array.dup;\n    auto l = array.length;\n\
    \    l /= 2;\n    auto sortFunc = isOdd(array[0] + array[$-1]) ? (x, y) => x <\
    \ y : (x, y) => x > y;\n    array[0 .. l].sort!sortFunc;\n    array[l .. $].sort!sortFunc;\n\
    \    return array;\n}", "{\n    if (array.length < 2)\n        return array;\n\
    \    \n    long[] tmp = array.dup;\n    tmp.sort;\n    \n    return (array[0]\
    \ + array[$ - 1]) % 2 ? tmp : tmp.reverse;\n}", "{\n    alias P = typeof(array[0]);",
  "{\n    long[] cod_array = array.dup;\n    if(array.length > 0)\n    {\n       \
    \ switch(array[0L] + array[$ - 1L])\n        {\n            case in a :\n    \
    \            std.algorithm.sort(cod_array);\n                break;\n        \
    \    case in b :\n                std.algorithm.sort(cod_array, std.typecons.greater);\n\
    \                break;\n        }\n    }\n    return cod_array;\n}", "{\n   \
    \ static assert(isInputRange!(typeof(array), long));\n    static assert(isRandomAccessRange!(typeof(array)));\n\
    \    static assert(is(array[0] : long));\n    static assert(!is(array : string));\n\
    \    static assert(!is(array : ubyte[]));\n    if(array.length < 2) return array;\n\
    \    size_t n = array.length;\n    if((array[0] + array[n - 1]) % 2 == 0)\n  \
    \  {\n        quickSort(array, randomNumberGenerator);\n        return array;\n\
    \    }\n    quickSort(array, randomNumberGenerator);\n    reverse(array);\n  \
    \  return array;\n}", "{\n    // the result array\n    auto result_array = new\
    \ long[array.length];\n    // don't change the given array\n    foreach(index,\
    \ element; array)\n    {\n        result_array[index] = element;\n    }\n    //\
    \ sort the given array\n    if(array.length > 1)\n    {\n        if(array[0] +\
    \ array[$ - 1] % 2)\n        {\n            std.algorithm.sort(result_array);\n\
    \        }\n        else\n        {\n            std.algorithm.sort!(\"a < b\"\
    )(result_array);\n        }\n    }\n    return result_array;\n}", "in\n{\n   \
    \ assert(array.length == array.length);\n}\nout\n(result)\n{\n    assert(result.length\
    \ == array.length);\n    for (int i = 0; i < result.length - 1; i++)\n    {\n\
    \        assert(result[i] >= result[i + 1]);\n    }\n}\n{\n    if (array.length\
    \ <= 1)\n    {\n        return array;\n    }\n    else\n    {\n        long first\
    \ = array[0];\n        long last = array[array.length - 1];\n        bool ascending\
    \ = (first + last) % 2 == 1;\n        if (ascending)\n        {\n            return\
    \ std.sort(array);\n        }\n        else\n        {\n            return std.sort(array,\
    \ (x, y) => x > y);\n        }\n    }\n}", "{\n    // we return a new array, the\
    \ original given array is never changed", "{\n    long[] ar2 = array;\n    if\
    \ ((array.length != 0) && (array.length != 1))\n    {\n        if ((array[0] +\
    \ array[array.length - 1]) % 2 == 0)\n        {\n            std.random.shuffle(ar2);\n\
    \            std.sort(ar2);\n            std.reverse(ar2);\n        }\n      \
    \  else\n        {\n            std.random.shuffle(ar2);\n            std.sort(ar2);\n\
    \        }\n    }\n    return ar2;\n}", "{\n    if (array.length == 0 || array.length\
    \ == 1) return array;\n    long sum = array[0] + array[$-1];\n    bool isOdd =\
    \ sum % 2L != 0L;\n    if (isOdd) {\n        return array.sort();\n    } else\
    \ {\n        array.sort();\n        return array.reverse();\n    }\n}\n/*\n  \
    \  def sort_array(source_array):\n    odd = sorted(v for v in source_array if\
    \ v % 2 != 0)\n    even = sorted(v for v in source_array if v % 2 == 0)\n    return\
    \ [x for k, x in enumerate(odd + even) for i in range(k, len(source_array), 2)]\n\
    */", "{\n    // Sorts the array using the funny criterium.\n    auto last = array.length\
    \ - 1;\n    auto tup = tuple(array[0], array[last]);\n    auto direction = tup[0]\
    \ + tup[1] % 2 == 0 ? -1 : 1;\n    return array.sort(direction);\n}", "{\n   \
    \ // your code goes here\n    long[] sorted = array.dup;\n    if (array.length\
    \ == 0)\n        return sorted;\n    auto op = (sorted[0] + sorted[$-1]) & 1 ?\
    \ \">\" : \"<\";\n    sort(sorted, (a, b) => a eval op b);\n    return sorted;\n\
    }", "in\n{\n    enum int sum = 0;\n    enum long[] array_clone = array.dup;\n\
    \    foreach(idx, val; array_clone)\n    {\n        sum += val;\n    }\n    if(sum\
    \ % 2 == 0)\n    {\n        sort(array_clone, (a, b) => b - a);\n    }\n    else\n\
    \    {\n        sort(array_clone);\n    }\n    return array_clone;\n}", "{\n \
    \   if (array.length == 0)\n        return array;\n    if (array.length == 1)\n\
    \        return array;\n    if (array[0L] + array[array.length - 1L] % 2L == 0L)\n\
    \        sort(array, (a, b) => b - a);\n    else\n        sort(array, (a, b) =>\
    \ a - b);\n    return array;\n}\n```", "{\n    // if the array is empty\n    if\
    \ (array.length == 0) \n    {\n        return array;\n    }", "{\n    bool ascending\
    \ = array.length == 0 ? false : array[0] + array[array.length - 1] % 2 != 0;\n\
    \    auto numbers = array.array;\n    sort!(ascending ? (a, b) => a < b : (a,\
    \ b) => a > b)(numbers);\n    return numbers;\n}", "{\n    auto array = array.dup;\n\
    \    static if (array.length > 0) \n    {\n        static if (array[0] + array[$\
    \ - 1] % 2 == 0)\n        {\n            array.sort!((a, b) => a > b);\n     \
    \   } \n        else \n        {\n            array.sort!((a, b) => a < b);\n\
    \        }\n    }\n    return array;\n}", "{\n    bool odd = array.length.even;",
  "{\n    if (array.length < 2)\n        return array;\n    auto sum = array[0] +\
    \ array[$ - 1];\n    auto is_odd = cast(bool)(sum % 2);\n    return is_odd ? array.sort()\
    \ : array.sort(std.algorithm.comparison.greater);\n}", "{\n    if (array.length\
    \ == 0) return array;\n    const cmp_func cmp = array[0] + array[$ - 1] % 2 ==\
    \ 0 ? typeof(gt) : typeof(lt);\n    array.sort!(cmp);\n    return array;\n}",
  "{\n    return array.length == 0 ? array :\n        all(array, el => el >= 0) ?\
    \ \n            sort(array, tuple(a, b) => (a + b) % 2 == 0 ? b - a : a - b) :\
    \ array;\n}", "{\n    long[] result = array.dup;\n    result.sort;\n    if (mod(result[0]+result[$-1],\
    \ 2)==0)\n        result.reverse;\n    return result;\n}", "{\n    if (array.length\
    \ != 0)\n    {\n        int sum = (int)(array[0] + array[array.length - 1]);\n\
    \        if (sum % 2 == 0)\n        {\n            array.sort(new Comparator!(long,\
    \ long)\n            {\n                override long opCall(long x, long y) \n\
    \                {\n                    return y - x;\n                }\n   \
    \         });\n        } \n        else \n        {\n            array.sort;\n\
    \        }\n    }\n    return array;\n}", "{\n    bool even = (array.length ==\
    \ 0 ||\n                 array.length == 1) ?\n                true : \n     \
    \           (array[0] + array[$-1]) % 2 == 0;\n    if (even)\n    {\n        return\
    \ array.dup.sort;\n    }\n    else\n    {\n        return array.dup.sort.reverse;\n\
    \    }\n}", "{\n    if (array.length == 0)\n        return array;\n    // get\
    \ the value at the first index.\n    long first = array[0];\n    // get the value\
    \ at the last index.\n    long last = array[array.length - 1];\n    // Add the\
    \ values from the first and last indexes.\n    long sum = first + last;\n    //\
    \ create a function for sorting\n    void sort(long[] arr)\n    {\n        //\
    \ sort the array in ascending order\n        arr.sort(a, b => a > b);\n    }\n\
    \    // if the sum is odd, sort the array.\n    if (sum % 2 != 0)\n        sort(array);\n\
    \    // else reverse the array.\n    else\n        array.reverse();\n    // return\
    \ the result.\n    return array;\n}", "{\n    return (array.length != 0 ? sort(array[0]\
    \ + array[$ - 1] % 2 == 0 ? array : array.reverse) : array);\n}", "{\n    static\
    \ assert(is(typeof(array) == long[]));\n    long[] r;\n    typeof(r) val;\n  \
    \  auto length = array.length;\n    auto c = length;\n    auto m = div(array[0]\
    \ + array[$-1], 2);\n    if (c == 0) return r;\n    if (c == 1) return array;\n\
    \    while (c != 0)\n    {\n        c = 0;\n        if (m % 2 == 0)\n        {\n\
    \            val = array[0];\n            array[0] = array[$-1];\n           \
    \ array[$-1] = val;\n        }\n        for (size_t i = 0; i != array.length;\
    \ ++i)\n        {\n            if (array[i] > array[i + 1])\n            {\n \
    \               val = array[i];\n                array[i] = array[i + 1];\n  \
    \              array[i + 1] = val;\n                c = i;\n            }\n  \
    \      }\n    }\n    return array;\n}\nstring sort_array(string argument)\n{\n\
    \    return \"--\" + argument;\n}", "{\n    if ( array.length == 0 )\n       \
    \ return array;\n    if ( array.length == 1 )\n        return array;\n    auto\
    \ lo = 0L;\n    auto hi = array.length - 1L;\n    if ( (array[lo] + array[hi])\
    \ % 2 == 0 )\n    {\n        // descending\n        while ( lo < hi )\n      \
    \  {\n            if ( array[lo] % 2 != 0 )\n            {\n                //\
    \ find next odd\n                while ( array[hi] % 2 != 0 )\n              \
    \  {\n                    --hi;\n                }\n                swap(array[lo],\
    \ array[hi]);\n            }\n            ++lo;\n        }\n        std.algorithm.sort(array[0L..lo],\
    \ std.greater!\"a\");\n        std.algorithm.sort(array[lo..$], std.less!\"a\"\
    );\n    }\n    else\n    {\n        // ascending\n        while ( lo < hi )\n\
    \        {\n            if ( array[lo] % 2 == 0 )\n            {\n           \
    \     // find next even\n                while ( array[hi] % 2 == 0 )\n      \
    \          {\n                    --hi;\n                }\n                swap(array[lo],\
    \ array[hi]);\n            }\n            ++lo;\n        }\n        std.algorithm.sort(array[0L..lo],\
    \ std.less!\"a\");\n        std.algorithm.sort(array[lo..$], std.greater!\"a\"\
    );\n    }\n    return array;\n}\n// TESTS\nunittest\n{\n    auto values = [2L,\
    \ 4L, 3L, 0L, 1L, 5L];\n    auto array = sort_array(values);\n    assert(array\
    \ == [0L, 1L, 2L, 3L, 4L, 5L]);\n}\nunittest\n{\n    auto values = [2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L];\n    auto array = sort_array(values);\n    assert(array ==\
    \ [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n}\nunittest\n{\n    auto values = [5L];\n",
  "{\n    long[] sorted = array.dup;\n    if (array.length == 0)\n        return array;\n\
    \    if (array.length == 1)\n        return array;\n    auto num = new ulong[array.length];\n\
    \    for (int i = 0; i < array.length; i++)\n    {\n        num[i] = typeof(array[i]).init;\n\
    \    }\n    long[] temp = array.dup;\n    long[] toret = array.dup;\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        array.sort!((x, y) => y\
    \ > x);\n        array.reverse;\n        return array;\n    }\n    else \n   \
    \ {\n        array.sort!((x, y) => x > y);\n        array.reverse;\n        return\
    \ array;\n    }\n}", "{\n    if (array.length <= 0) return array;\n    return\
    \ array[0] + array[$ - 1] % 2 == 0 ? array.sort(std.typecons.reversed).array :\
    \ array.sort().array;\n}", "{\n    import std.algorithm : sort;\n    import std.array\
    \ : splice;\n    import std.conv : to;\n    import std.functional : binaryFun;\n\
    \    import std.range : iota;\n    import std.typecons : Tuple;\n    long[][2]\
    \ m = array.iota.sort!((a, b) => array[a] < array[b]).chunks(array.length / 2\
    \ + array.length % 2);\n    long[] result = m[0].map!(a => array[a]).array;\n\
    \    result ~= m[1].map!(a => array[a]).reverse.array;\n    return result;\n}",
  "{\n    long[] result = array.dup;", "{\n    long firstIndexValue = array[0];\n\
    \    long lastIndexValue = array[array.length - 1];\n    if((firstIndexValue +\
    \ lastIndexValue) % 2 == 0)\n    {\n        return sort(array, (a, b) => b < a);\n\
    \    }\n    else\n    {\n        return sort(array, (a, b) => a < b);\n    }\n\
    }", "{\n    auto result = array.dup;\n    auto rng = result.retro;\n    bool odd_index\
    \ = false;\n    if(rng.front + rng.back) % 2L != 0L)\n        odd_index = true;\n\
    \    if(odd_index)\n        sort(result, (a, b) => a > b);\n    else\n       \
    \ sort(result, (a, b) => a < b);\n    return result;\n}", "{\n\tif (array.length\
    \ == 0)\n\t\treturn array;\n\tlong first = array[0];\n\tlong last = array[array.length\
    \ - 1];\n\tif ((first + last) % 2 == 0)\n\t\treturn sort(array, (a, b) => b -\
    \ a);\n\telse\n\t\treturn sort(array, (a, b) => a - b);\n}", "{\n    if (array.length\
    \ == 0) return array;\n    if (array.length == 1) return array;\n    long m =\
    \ array[0];\n    long n = array[array.length - 1];\n    if ((m + n) % 2 == 0)\n\
    \    {\n        return array.sort.retro.copy;\n    }\n    else\n    {\n      \
    \  return array.sort.copy;\n    }\n}", "{\n    // Sort the array in ascending\
    \ order if the sum of the first and last index is odd, \n    // or in descending\
    \ order if the sum of the first and last index is even.\n    long[] copy = array.dup;\n\
    \    if ( (copy[0] + copy[copy.length - 1]) % 2 == 0 ) \n    {\n        sort(copy,\
    \ (a, b) => b - a);\n    }\n    else \n    {\n        sort(copy);\n    }\n   \
    \ return copy;\n}", "in \n{\n    assert(array.length != 0);\n}\nout (result)\n\
    {\n    assert(result.length == array.length);\n    assert(array.length == 0 ||\n\
    \        (result[0] <= result[$-1] &&\n        (array[0] + array[$-1]) % 2 ==\
    \ 0) ||\n        (result[0] >= result[$-1] &&\n        (array[0] + array[$-1])\
    \ % 2 == 1));\n}\n{\n    alias E = long;\n    if (array.length <= 1)\n    {\n\
    \        return array;\n    }\n    else if ((array[0] + array[$-1]) % 2 == 0)\n\
    \    {\n        return array.sort!((a, b) => b < a);\n    }\n    else\n    {\n\
    \        return array.sort!((a, b) => a < b);\n    }\n}", "{\n    array.sort();\n\
    \    if (array.length == 0 || array.length == 1) return array;\n    if ((array[0]\
    \ + array[$-1]) % 2 == 0)\n    {\n        array.reverse();\n    }\n    return\
    \ array;\n}", "{\n\tif (array.length < 2)\n\t\treturn array;\n\t\t\n\tif ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n\t\treturn sort!(\"a > b\")(array);\n\t\
    else\n\t\treturn sort!(\"a < b\")(array);\n}", "{\n    // Constraints:\n    assert(array\
    \ !is null && array.length <= 20);\n    foreach(x; array)\n        assert(x <=\
    \ 100L);\n    // End constraints\n    \n    import std.algorithm.sorting : sort;\n\
    \    if(array.length == 0) return [];\n    // make a copy of the given array\n\
    \    auto copy = new long[](array.length);\n    copy = array.dup;\n    // sort\
    \ the copy in ascending order using a lambda\n    copy.sort!((ref a, ref b) =>\
    \ a < b);\n    // create an array of ints of the same length\n    auto array_of_ints\
    \ = new int[](copy.length);\n    array_of_ints = iota(copy.length);\n    // create\
    \ a tuple of the array of ints and the copy\n    auto tuple = tuple(array_of_ints,\
    \ copy);\n    // sort the array of ints in descending order using a lambda\n \
    \   tuple[0].sort!((ref a, ref b) => a > b);\n    // return the sorted copy\n\
    \    return tuple[1];\n}", "{\n    if (array.length == 0)\n        return array;\n\
    \    if (array.length == 1)\n        return array;\n    bool is_even = (array[0]\
    \ + array[$-1]) % 2 == 0;\n    auto p = new bool[array.length];\n    foreach (idx,\
    \ elem; array)\n    {\n        if (idx % 2 == 0)\n            p[idx] = is_even;\n\
    \        else\n            p[idx] = !is_even;\n    }\n    array.sort!((a, b) =>\
    \ p[a] < p[b]);\n    return array;\n}", "{\n    long sum = array[0] + array[array.length\
    \ - 1];\n    auto sorter = (sum % 2 == 0) ? sort!((a, b) => a > b) : sort!((a,\
    \ b) => a < b);\n    return sorter(array);\n}", "{\n    // type cons: tuple\n\
    \    auto s = tuple(0L, 0L);\n    foreach(i, ref a; array)\n    {\n        s[0]\
    \ += a;\n        s[1] += i;\n    }\n    if(s[0] % 2)\n        array.sort!((a,\
    \ b) => a < b);\n    else\n        array.sort!((a, b) => a > b);\n    return array;\n\
    }", "{\n    long[] sortedArray = array.idup;\n    long sum = array[0] + array[$-1];\n\
    \    alias bool IsEven = (sum % 2 == 0);\n    if (IsEven) \n    {\n        sortedArray.sort!((a,\
    \ b) => { return b < a; });\n    } \n    else \n    {\n        sortedArray.sort!((a,\
    \ b) => { return a < b; });\n    }\n    return sortedArray;\n}", "{\n    if (array.length\
    \ == 0 || array.length == 1)\n        return array;\n    else\n    {\n       \
    \ auto ar = array.dup;\n        sort(ar);\n        return ar[0] + ar[$-1] % 2\
    \ ? ar : ar.reverse;\n    }\n}\n ", "{\n    if (array.length == 0)\n        return\
    \ array;\n    else if (array.length == 1)\n        return array;\n    else\n \
    \   {\n        long max = array[0];\n        long min = array[0];\n        for\
    \ (long i = 0; i < array.length; i++)\n        {\n            if (array[i] > max)\n\
    \                max = array[i];\n            if (array[i] < min)\n          \
    \      min = array[i];\n        }\n        if ((max + min) % 2 == 0)\n       \
    \     return array.sort!((a, b) => b < a);\n        else\n            return array.sort!((a,\
    \ b) => a < b);\n    }\n}", "{\n    long[] array_cpy = array.dup;\n    auto a\
    \ = array_cpy[0];\n    auto b = array_cpy[$-1];\n    if ((a + b) % 2 == 0)\n \
    \   {\n        auto max = std.algorithm.max;\n        std.algorithm.sort(array_cpy,\
    \ (a, b) => max(a, b));\n    }\n    else\n    {\n        auto min = std.algorithm.min;\n\
    \        std.algorithm.sort(array_cpy, (a, b) => min(a, b));\n    }\n    return\
    \ array_cpy;\n}", "{\n    auto sorted_array = array.dup;\n    if (array.length\
    \ > 0)\n    {\n        if (array[0] + array[$-1] % 2 == 0)\n        {\n      \
    \      sorted_array.sort!((x, y) => x < y);\n        }\n        else\n       \
    \ {\n            sorted_array.sort!((x, y) => x > y);\n        }\n    }\n    return\
    \ sorted_array;\n}", "{\n    long[] temp_arr = array.dup;\n    int i = 0;\n  \
    \  int j = array.length - 1;\n    while (i < j)\n    {\n        if (array[i] %\
    \ 2 == 0)\n        {\n            if (array[j] % 2 == 0)\n            {\n    \
    \            j--;\n            }\n            else\n            {\n          \
    \      swap(temp_arr[i], temp_arr[j]);\n                i++;\n               \
    \ j--;\n            }\n        }\n        else\n        {\n            i++;\n\
    \        }\n    }\n    quickSort(temp_arr, 0, temp_arr.length - 1);\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        for (i = 0; i < temp_arr.length\
    \ / 2; i++)\n        {\n            swap(temp_arr[i], temp_arr[temp_arr.length\
    \ - 1 - i]);\n        }\n    }\n    return temp_arr;\n}", "{\n    if (array.length\
    \ == 0)\n        return array;\n    auto sort = array[0] + array[$-1] % 2 ? sort\
    \ : reverse;\n    return sort(array.dup);\n}", "{\n    // ...\n}", "{\n    if\
    \ (array.length == 0)\n        return array;\n    long odd_sum = ((array[0] &\
    \ 1) == 1)? array[0] : 0;\n    long even_sum = ((array[0] & 1) == 0)? array[0]\
    \ : 0;\n    foreach (i, ref value; array[1 .. $])\n    {\n        if ((value &\
    \ 1) == 1)\n            odd_sum += value;\n        else\n            even_sum\
    \ += value;\n    }\n    auto comp_func = ((odd_sum + even_sum) & 1) == 1 ? (a,\
    \ b) => a < b : (a, b) => a > b;\n    array.sort(comp_func);\n    return array;\n\
    }\n// -------------", "in {\n  foreach(idx, v; array)\n    assert(v >= 0);\n}\n\
    out(result) {\n  assert(result.length == array.length);\n}\n{\n  int i = 0;\n\
    \  long[] res;\n  if (array.length > 0) {\n    int ind = array.length-1;\n   \
    \ int sum = array[0] + array[ind];\n    if (sum % 2 == 0) {\n      res = select(long[])array.dup.sort(std.algorithm.sorting.max);\n\
    \    } else {\n      res = select(long[])array.dup.sort(std.algorithm.sorting.min);\n\
    \    }\n  } else {\n    res = array;\n  }\n  return res;\n}", "{ \n    auto tuple\
    \ = tuple(0L, array.back);\n    long[] result = array;\n    if(tuple.front & 1)\n\
    \    {\n        result = array.sort();\n    }\n    else\n    {\n        result\
    \ = array.sort().reverse();\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[array.length];\n    if (array.length == 0)\n        return array;\n\
    \    if (array.length == 1)\n        return array;\n    bool sortOrder = (array[0]\
    \ + array[array.length - 1]) % 2 == 0;\n    if (sortOrder)\n    {\n        result\
    \ = array.copy();\n        result.sort(std.sort.descending);\n    }\n    else\n\
    \    {\n        result = array.copy();\n        result.sort(std.sort.ascending);\n\
    \    }\n    return result;\n}", "{\n    if (array.length == 0)\n        return\
    \ array;\n    long[] res = new long[array.length];\n    auto l = array[0];\n \
    \   auto r = array[$ - 1];\n    if ((l + r) % 2 == 0)\n    {\n        res = array.idup;\n\
    \        res.sort!\"a > b\";\n    }\n    else\n    {\n        res = array.idup;\n\
    \        res.sort!\"a < b\";\n    }\n    return res;\n}", "{\n    auto l = array.length;\n\
    \    if(l is 0)\n        return array;\n    else if(l is 1)\n        return array;\n\
    \    else\n    {\n        if((array[0] + array[$-1]) % 2 is 0)\n            return\
    \ sort!((a, b) => a > b)(array);\n        else\n            return sort!((a, b)\
    \ => a < b)(array);\n    }\n}", "{\n    long[] new_array = array.dup;\n    if(array.length\
    \ > 0 && array.length % 2 == 0)\n    {\n        new_array.sort!((x, y) => y -\
    \ x);\n    }\n    else\n    {\n        new_array.sort!((x, y) => x - y);\n   \
    \ }\n    return new_array;\n}", "{\n    long k = array.front + array.back;\n \
    \   if(k%2==0) \n    {\n        array.sort!((a, b) => b < a);\n    } \n    else\
    \ \n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n}",
  "{\n    auto first = array[0];\n    auto last = array[$-1];\n    auto sum = first\
    \ + last;\n    auto is_odd = sum % 2;\n    auto elem = new long[array.length];\n\
    \    auto mutable_array = array[];\n    auto i = 0;\n    while (true)\n    {\n\
    \        auto min = minElement(mutable_array);\n        auto max = maxElement(mutable_array);\n\
    \        if (is_odd)\n        {\n            elem[i] = min;\n            mutable_array\
    \ = array.filter!(x => x != min)[];\n        }\n        else\n        {\n    \
    \        elem[i] = max;\n            mutable_array = array.filter!(x => x != max)[];\n\
    \        }\n        i++;\n        if (mutable_array.length == 0)\n           \
    \ break;\n    }\n    return elem;\n}", "{\n    /*\n    long[] result;\n    if(array.length>0)\n\
    \    {\n        if(array[0]+array[array.length-1]%2==0)\n        {\n         \
    \   auto op_c = cmp(a, b){\n                if(a>b)\n                    return\
    \ -1;\n                else if(a<b)\n                    return 1;\n         \
    \       else\n                    return 0;\n            };\n            result\
    \ = array.dup.sort!op_c;\n        }\n        else\n        {\n            auto\
    \ op_c = cmp(a, b){\n                if(a>b)\n                    return 1;\n\
    \                else if(a<b)\n                    return -1;\n              \
    \  else\n                    return 0;\n            };\n            result = array.dup.sort!op_c;\n\
    \        }\n    }\n    else\n    {\n        result = array.dup;\n    }\n    return\
    \ result;\n    */\n    if(array.length<=1)\n        return array.dup;\n    else\n\
    \    {\n        if((array[0]+array[array.length-1])%2==0)\n        {\n       \
    \     sort!((a, b) => a > b)(array);\n        }\n        else\n        {\n   \
    \         sort!((a, b) => a < b)(array);\n        }\n        return array.dup;\n\
    \    }\n}", "{\n    auto n = array.length;\n    auto sorted = array.dup;\n   \
    \ if ((sorted[0] + sorted[$-1]) % 2 == 0)\n    {\n        sort!((a, b) => b <\
    \ a)(sorted);\n    }\n    else\n    {\n        sort!((a, b) => a < b)(sorted);\n\
    \    }\n    return sorted;\n}", "{\n    // Sorted array.\n    auto sorted_array\
    \ = array.dup;\n    const size_t n = sorted_array.length;\n    // Check if the\
    \ array is empty.\n    if (n == 0)\n    {\n        return [];\n    }\n    // Check\
    \ if the array contains only one element.\n    if (n == 1)\n    {\n        return\
    \ sorted_array;\n    }\n    // Sort the array in ascending order.\n    sort(sorted_array);\n\
    \    // Sum of first and last index values.\n    const long sum = sorted_array[0]\
    \ + sorted_array[n - 1];\n    // Check if sum is odd.\n    if (sum % 2 != 0)\n\
    \    {\n        return sorted_array;\n    }\n    // Sort the array in descending\
    \ order.\n    sort(sorted_array, std.functional.greater!\"a\"());\n    return\
    \ sorted_array;\n}", "{\n    // Making sure the array is not empty\n    if (array.length\
    \ == 0) \n    {\n        return array;\n    }\n    // If the array has only one\
    \ element, return it.\n    if (array.length == 1) \n    {\n        return array;\n\
    \    }\n    // If the sum of the first and last index is odd\n    if (array[0]\
    \ + array[$ - 1] % 2 != 0) \n    {\n        return array.sorted;\n    }\n    else\
    \ \n    {\n        array.sort;\n        return array.reverse;\n    }\n}", "{ \n\
    \    long sum1 = array[0] + array[array.length - 1];\n    long[] result = array.dup;\n\
    \    if (sum1 % 2 == 0) \n    {\n        result.sort!((a, b) => a > b);\n    }\n\
    \    else \n    {\n        result.sort!((a, b) => a < b);\n    }\n    return result;\n\
    }", "{\n    // Your code goes here!\n    return array.dup;\n}", "{\n    auto len\
    \ = array.length;\n    if (len == 0) \n    {\n        return [];\n    }", "{\n\
    \    if (array.length <= 0)\n        return array;\n    long[] newArray = array.dup;\n\
    \    if (array[0] + array[array.length - 1] % 2 == 0)\n        newArray.sort(\
    \ (a, b) => a < b );\n    else\n        newArray.sort( (a, b) => a > b );\n  \
    \  return newArray;\n}", "{\n    int i = 0;\n    int j = array.length - 1;\n \
    \   bool sorted = false;\n    long temp;\n    if(array.length == 0 || array.length\
    \ == 1)\n        return array;\n    else if(array.length % 2 == 0)\n    {\n  \
    \      while(!sorted)\n        {\n            sorted = true;\n            for(i\
    \ = 0; i < j; i++)\n            {\n                if(array[i] < array[i + 1])\n\
    \                {\n                    temp = array[i];\n                   \
    \ array[i] = array[i + 1];\n                    array[i + 1] = temp;\n       \
    \             sorted = false;\n                }\n            }\n            j--;\n\
    \        }\n    }\n    else\n    {\n        while(!sorted)\n        {\n      \
    \      sorted = true;\n            for(i = 0; i < j; i++)\n            {\n   \
    \             if(array[i] > array[i + 1])\n                {\n               \
    \     temp = array[i];\n                    array[i] = array[i + 1];\n       \
    \             array[i + 1] = temp;\n                    sorted = false;\n    \
    \            }\n            }\n            j--;\n        }\n    }\n    return\
    \ array;\n}", "{\n    // Given a mutable array,\n    // If the first index of\
    \ the array and the last index of the array\n    // summed is even, return the\
    \ array in descending order;\n    // else return the array in ascending order.\n\
    \    //\n    // The mutable array is not changed.\n    //\n    // Examples:\n\
    \    // >>> sort_array([])\n    // []\n    // >>> sort_array([5L])\n    // [5L]\n\
    \    // >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    // [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    // >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    // [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]\n    import std.array;\n    import std.range;\n    import std.math;\n\
    \    import std.typecons;\n    import std.algorithm;\n    if (array.length < 2)\n\
    \    {\n        return array;\n    }\n    // Sum the first and last index values.\n\
    \    long first_last_sum = array[0] + array[$ - 1];\n    // If the sum is even,\
    \ sort descending, else sort ascending.\n    bool descending = (first_last_sum\
    \ % 2 == 0);\n    long[] sorted = array[];\n    sort(sorted, descending ? std.greater.byValue!long\
    \ : std.less.byValue!long);\n    return sorted;\n}", "{\n    int size = array.length;\n\
    \    if (size == 0)\n        return array;\n    if (size == 1)\n        return\
    \ array;\n    //long[] ret = array.dup;\n    long[] ret = new long[size];\n  \
    \  auto a = array.sort;\n    long first = a[0];\n    long last = a[size - 1];\n\
    \    if ((first + last) % 2 == 0)\n    {\n        for (size_t i = 0; i < size;\
    \ i++)\n        {\n            ret[i] = a[size - 1 - i];\n        }\n    }\n \
    \   else\n    {\n        for (size_t i = 0; i < size; i++)\n        {\n      \
    \      ret[i] = a[i];\n        }\n    }\n    return ret;\n}\n// test", "{\n  \
    \  long[] copy = new long[];\n    copy = copy(array);\n    auto odd_array = array.filter!((x)\
    \ => (x % 2));\n    auto even_array = array.filter!((x) => (x % 2 == 0));\n  \
    \  quickSort(even_array);\n    quickSort(odd_array);\n    if (copy[0] + copy[copy.length\
    \ - 1] % 2 == 0)\n    {\n        copy = merge(even_array, odd_array);\n    }\n\
    \    else\n    {\n        copy = merge(odd_array, even_array);\n    }\n    return\
    \ copy;\n}", "{\n    if (array.length == 0)\n        return new long[0];\n   \
    \ if (array.length == 1)\n        return array;\n    if (array[0] + array[array.length\
    \ - 1] % 2 == 0)\n        sort(array);\n    else\n        reverse(sort(array));\n\
    \    return array;\n}", "{\n    auto cmp = (long lhs, long rhs) => array[lhs]\
    \ < array[rhs];\n    if((array.length > 0) & (cmp(0, array.length - 1)) is true)\
    \ \n    {\n        cmp = (long lhs, long rhs) => array[lhs] > array[rhs];\n  \
    \  }\n    auto isorted = iota(array.length);\n    isorted.sort!(cmp);\n    return\
    \ isorted.map!(i => array[i]).array;\n}", "{\n    long i1 = array[0];\n    long\
    \ il = array[$-1];\n    if ((i1 + il) % 2 == 0)\n    {\n        return array.sort!((a,\
    \ b) => b - a);\n    }\n    else\n    {\n        return array.sort!((a, b) =>\
    \ a - b);\n    }\n}", "{\n    // TODO\n}", "{\n  return tuple(tuple(array[0],\
    \ true), tuple(array[array.length - 1], false))\n    .map!((x) => (x[0] + (x[1]\
    \ ? 0 : 1)) % 2)\n    .reduce!q{a, b => (a + b) % 2 == 0}\n    ? array.sort!q{a,\
    \ b => a < b}\n    : array.sort!q{a, b => a > b};\n}\n// test_code\nunittest \n\
    {\n    assert(sort_array([]) == []);\n    assert(sort_array([5L]) == [5L]);\n\
    \    assert(sort_array([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n\
    \    assert(sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n}", "{\n    enum Condition \n    {\n        Odd,\n        Even\n    }\n\
    \    bool isOdd(long num) \n    {\n        return num % 2 == 1;\n    }\n    //\
    \ ...\n    auto len = array.length;\n    if (len == 0)\n        return array;\n\
    \    else if (len == 1)\n        return array;\n    else if (len == 2) \n    {\n\
    \        long a = array[0];\n        long b = array[1];\n        if (isOdd(a +\
    \ b))\n            return [min(a, b), max(a, b)];\n        else\n            return\
    \ [max(a, b), min(a, b)];\n    }\n    else \n    {\n        long a = array[0];\n\
    \        long b = array[$ - 1];\n        if (isOdd(a + b))\n            return\
    \ array.sort;\n        else\n            return array.sort.reverse;\n    }\n}",
  "{\n    if (array.length == 0)\n        return array;\n    if (array.length == 1)\n\
    \        return array;\n    auto firstValue = array[0];\n    auto lastValue =\
    \ array[$ - 1];\n    auto total = firstValue + lastValue;\n    auto ascendingOrder\
    \ = (total % 2 == 0) ? false : true;\n    if (ascendingOrder)\n        array.sort!((a,\
    \ b) => (a < b));\n    else\n        array.sort!((a, b) => (a > b));\n    return\
    \ array;\n}", "{\n    long[] result = new long[array.length];\n    if (array.length\
    \ <= 1)\n        return array;\n    result[0] = array[0];\n    result[array.length\
    \ - 1] = array[array.length - 1];\n    if ((result[0] + result[array.length -\
    \ 1]) % 2 == 0)\n    {\n        for (int i = 1; i < array.length - 1; i++)\n \
    \       {\n            auto t1 = array[i];\n            for (int j = i; j > 0;\
    \ j--)\n            {\n                if (result[j - 1] < t1)\n             \
    \   {\n                    break;\n                }\n                else\n \
    \               {\n                    result[j] = result[j - 1];\n          \
    \      }\n            }\n            result[j] = t1;\n        }\n    }\n    else\n\
    \    {\n        for (int i = 1; i < array.length - 1; i++)\n        {\n      \
    \      auto t1 = array[i];\n            for (int j = i; j > 0; j--)\n        \
    \    {\n                if (result[j - 1] > t1)\n                {\n         \
    \           break;\n                }\n                else\n                {\n\
    \                    result[j] = result[j - 1];\n                }\n         \
    \   }\n            result[j] = t1;\n        }\n    }\n    return result;\n}",
  "{\n    return \n    ( \n        array.length == 0 || array.length == 1 \n     \
    \   ? array \n        : (\n            ( array[0] + array[$-1] ) % 2 == 0 \n \
    \           ? array.sort( (a, b) => b - a ) \n            : array.sort( (a, b)\
    \ => a - b ) \n        )\n    );\n}", "{\n    if (array.length < 1)\n        return\
    \ array;\n    if (array.length == 1)\n        return array;\n    auto evenOddSum\
    \ = array[0] + array[array.length - 1];\n    bool even = evenOddSum % 2 == 0;\n\
    \    if (even)\n        array = array.sort!((a, b) => b.compare(a));\n    else\n\
    \        array = array.sort!((a, b) => a.compare(b));\n    return array;\n}",
  "{\n    return array.isEmpty ? new long[0] : sort_array_impl(array, 0, array.length,\
    \ true);\n}", "{\n    assert(!array.empty);\n    //return std.sort(array, cmp);\n\
    \    return array.dup.sort(cmp);\n}", "{\n    // If the array is empty, return\
    \ it\n    if (array.length == 0) return array;\n    \n    // If there is only\
    \ one element in the array, return it\n    if (array.length == 1) return array;\n\
    \    \n    // Create a new array that will be returned\n    long[] newArray =\
    \ array;\n    \n    // Sort the array using a sort function\n    // (use std.algorithm.sort)\n\
    \    newArray = newArray.sort;\n    \n    // If the sum of the first and last\
    \ index values is odd:\n    if ((newArray[0] + newArray[newArray.length - 1])\
    \ % 2 == 1)\n    {\n        // Return the array\n        return newArray;\n  \
    \  }\n    // Else:\n    else\n    {\n        // Reverse the array\n        //\
    \ (use std.algorithm.reverse)\n        newArray = newArray.reverse;\n        \n\
    \        // Return the array\n        return newArray;\n    }\n}", "{\n    //\
    \ todo: write your code here\n    auto len = array.length;\n    if (len < 2)\n\
    \        return array;\n    auto first = array[0];\n    auto last = array[$ -\
    \ 1];\n    auto comparator = (first + last) % 2 ? \">\" : \"<\";\n    auto func\
    \ = getAsFunction!(comparator)(int, int);\n    auto swap = (i, j) =>\n    {\n\
    \        auto temp = array[i];\n        array[i] = array[j];\n        array[j]\
    \ = temp;\n    };\n    auto partition = (left, right) =>\n    {\n        auto\
    \ pivot = array[left];\n        auto i = left;\n        auto j = right;\n    \
    \    while (i < j)\n        {\n            while (i < j && func(array[j], pivot))\n\
    \                j--;\n            swap(i, j);\n            while (i < j && func(pivot,\
    \ array[i]))\n                i++;\n            swap(i, j);\n        }\n     \
    \   return i;\n    };\n    auto quickSort = (left, right) =>\n    {\n        if\
    \ (left < right)\n        {\n            auto index = partition(left, right);\n\
    \            quickSort(left, index - 1);\n            quickSort(index + 1, right);\n\
    \        }\n    };\n    quickSort(0, len - 1);\n    return array;\n}", "{\n  \
    \  if (array.length == 0)\n        return array;\n    \n    if (array.length ==\
    \ 1)\n        return array;\n    \n    bool is_odd = (array[0] + array[array.length\
    \ - 1]) % 2 == 1;\n    \n    auto sort1 = &compare_numbers_desc;\n    auto sort2\
    \ = &compare_numbers_asc;\n    \n    auto sort_function = (is_odd) ? sort1 : sort2;\n\
    \    \n    array.sort(sort_function);\n    \n    return array;\n}", "{\n    if\
    \ (array.length == 0) return array;\n    if (array.length == 1) return array;\n\
    \    long a = array[0];\n    long b = array[$ - 1];\n    long sum = a + b;\n \
    \   if (sum % 2 == 0) {\n        return array.sort!\"q{a>b}\";\n    } else {\n\
    \        return array.sort!\"q{a<b}\";\n    }\n}", "{\n    long head = array[0];\n\
    \    long end = array[array.length - 1];\n    long adder = head + end;\n    if\
    \ (adder % 2 == 0)\n    {\n        sort!(\"a > b\")(array);\n    }\n    else\n\
    \    {\n        sort!(\"a < b\")(array);\n    }\n    return array;\n}", "{\n \
    \   if ( array.length == 0)\n        return array;\n    long[] sorted_array =\
    \ array;\n    if ( 0 == (array[0] + array[array.length - 1]) % 2 )\n        sorted_array\
    \ = array.sort!((a, b) => a > b);\n    else\n        sorted_array = array.sort!((a,\
    \ b) => a < b);\n    return sorted_array;\n}", "{\n    if (array.length == 0 ||\
    \ array.length == 1)\n        return array;\n    return sort_array_helper(array,\
    \ 0, array.length - 1);\n}", "{\n    bool is_odd = (array.length > 0 ? array[0]\
    \ : 0) + (array.length > 0 ? array[array.length - 1] : 0) % 2;\n    if (is_odd)\n\
    \    {\n        sort(array);\n    }\n    else\n    {\n        sort(array[], q{return\
    \ -q;});\n    }\n    return array;\n}", "{\n    static struct my_type {\n    \
    \    int idx;\n        long value;\n    }\n    auto result = my_type.array();\n\
    \    foreach (idx, value; array)\n    {\n        result ~= my_type(idx, value);\n\
    \    }\n    auto sum = result[0].value + result[$ - 1].value;\n    if (sum % 2\
    \ == 0)\n    {\n        result.sort!((a, b) => a.value < b.value);\n    }\n  \
    \  else\n    {\n        result.sort!((a, b) => a.value > b.value);\n    }\n  \
    \  return result.map!(x => x.value).array();\n}", "{\n    alias ElemType = long;\n\
    \    static assert(isIntegral!ElemType);\n    static assert(!isUnsigned!ElemType);\n\
    \    static assert(hasLength!ElemType);\n    static assert(hasSlicing!ElemType);\n\
    \    static assert(hasSwap!ElemType);\n    static assert(hasLessThan!ElemType);\n\
    \    static assert(hasGreaterThan!ElemType);\n    static assert(hasLessEqual!ElemType);\n\
    \    static assert(hasGreaterEqual!ElemType);\n    static assert(hasAssignOp!ElemType);\n\
    \    static assert(hasAddition!ElemType);\n    static assert(hasEqual!ElemType);\n\
    \    static assert(hasAssign!ElemType);\n    static assert(hasMove!ElemType);\n\
    \    static assert(hasBool!ElemType);\n    static assert(hasIndexing!ElemType);\n\
    \    static assert(hasIndexOf!ElemType);\n    static assert(hasTernary!ElemType);\n\
    \    static assert(hasUnaryPlus!ElemType);\n    static assert(hasUnaryNegation!ElemType);\n\
    \    static assert(hasComparable!ElemType);\n    static assert(hasPlusAssign!ElemType);\n\
    \    static assert(hasBitwiseLeftShift!ElemType);\n    static assert(hasBitwiseRightShift!ElemType);\n\
    \    static assert(hasBitwiseAnd!ElemType);\n    static assert(hasBitwiseOr!ElemType);\n\
    \    static assert(hasBitwiseXor!ElemType);\n    static assert(hasBitwiseComplement!ElemType);\n\
    \    static assert(hasBinaryPlus!ElemType);\n    static assert(hasBinarySubtraction!ElemType);\n\
    \    static assert(hasBinaryMultiplication!ElemType);\n    static assert(hasBinaryDivision!ElemType);\n\
    \    static assert(hasBinaryModulo!ElemType);\n    static assert(hasBinaryLessThan!ElemType);\n\
    \    static assert(hasBinaryGreaterThan!ElemType);\n    static assert(has", "in\n\
    {\n    assert(array.length > 0);\n}\nbody\n{\n    long sum = array[0] + array[array.length\
    \ - 1];\n    auto sorted = array.dup;\n    if (sum % 2 == 0) \n    {\n       \
    \ sorted.sort!(\"a > b\");\n    }\n    else \n    {\n        sorted.sort!(\"a\
    \ < b\");\n    }\n    return sorted;\n}", "{\n    int sum_indexes = array.length\
    \ > 0 ? array[0] + array[array.length - 1] : 0;\n    auto comparator = (sum_indexes\
    \ % 2 == 0) ? (a, b) => (a > b) : (a, b) => (a < b);\n    auto sorted = array.dup;\n\
    \    sorted.sort(comparator);\n    return sorted;\n}", "{\n    return array.length\
    \ == 0 ? \n        array : \n        array.take(1).array\n        .cat(array.drop(1).array.sort)\n\
    \        .cat(array.take(1).array);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
