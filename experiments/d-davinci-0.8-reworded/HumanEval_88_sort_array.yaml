name: HumanEval_88_sort_array
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
  \ integers, return a cod of the given array after sorting,\n    you will sort the\
  \ given array in ascending order if the sum( first index value, last index value)\
  \ is odd,\n    or sort it in descending order if the sum( first index value, last\
  \ index value) is even.\n\n    Note:\n    * don't change the given array.\n\n  \
  \  Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n\
  \    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n  \
  \  >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n\
  \    \n*/\nlong[] sort_array(long[] array) \n"
tests: "unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
  \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
  \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
  \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
  \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
  \ 21L, 14L, 11L]);\n}\nvoid main(){}"
completions: ["{\n    // your code here\n    import std.conv;\n    long[] result =\
    \ array;\n    int sum = 0;\n    foreach(x; result)\n    {\n        sum += x;\n\
    \    }\n    if(sum % 2 == 0)\n    {\n        result.sort!((a, b) => a > b);\n\
    \    }\n    else\n    {\n        result.sort!((a, b) => a < b);\n    }\n    return\
    \ result;\n}", "{\n    int i = 0;\n    while(i < array.length)\n    {\n      \
    \  if((array[0] + array[array.length - 1]) % 2 == 0)\n        {\n            long\
    \ a = array[i];\n            long b = array[array.length - 1 - i];\n         \
    \   array[i] = b;\n            array[array.length - 1 - i] = a;\n        }\n \
    \       i++;\n    }\n    return array;\n}", "{\n    // TODO: Your code here.\n\
    \    auto result = array.dup;\n    auto len = result.length;\n    bool descending\
    \ = result[0] + result[len - 1] % 2 == 0;\n    if (descending) \n    {\n     \
    \   result.sort!((x, y) => y - x);\n    }\n    else \n    {\n        result.sort!((x,\
    \ y) => x - y);\n    }\n    return result;\n}", "{\n    long[] result = new long[array.length];\n\
    \    if(array.length == 0)\n        return result;\n    long total = 0;\n    for(long\
    \ i = 0; i < array.length; i++)\n    {\n        total += array[i];\n    }\n  \
    \  long first = array[0];\n    long last = array[array.length - 1];\n    if((first\
    \ + last) % 2 == 0)\n    {\n        std.algorithm.sort(array);\n        array.reverse();\n\
    \    }\n    else\n    {\n        std.algorithm.sort(array);\n    }\n    return\
    \ array;\n}", "{\n    int[] index = std.range(0, array.length);\n    int[long]\
    \ comparator = array.zip(index).sort;\n    if (comparator.values[0] + comparator.values[$\
    \ - 1] % 2 == 0) \n    {\n        comparator.values = comparator.values.reversed;\n\
    \    }\n    return index.map!((int i) => comparator[i]);\n}", "{\n    if (array.length\
    \ == 0 || array.length == 1) \n        return array;\n    \n    if (array[0] +\
    \ array[array.length - 1] % 2 == 0) \n        return array.sort(reverseCompare);\n\
    \    \n    return array.sort(Compare);\n}", "{\n    //  Sort the given array in\
    \ ascending order if the sum( first index value, last index value) is odd,\n \
    \   //  or sort it in descending order if the sum( first index value, last index\
    \ value) is even.\n    bool descending = cast(int)(array[0] + array[$-1]) % 2\
    \ == 0;\n    return array.sort( (a, b) => descending ? a < b : a > b);\n}", "{\n\
    \    enum ordering {\n        greater,\n        lesser\n    }\n    auto getFirstNLastSum\
    \ = (long[] arr) => {\n        import std.array;\n        return arr[0] + arr.back;\n\
    \    };\n    static bool isOdd(long n) {\n        return n % 2 == 1;\n    }\n\
    \    static bool isEven(long n) {\n        return n % 2 == 0;\n    }\n    auto\
    \ sortItems = (long[] arr, ordering o) => {\n        return o == ordering.greater\
    \ ? arr.sort(std.math.comparison!(\"a > b\")) : arr.sort(std.math.comparison!(\"\
    a < b\"));\n    };\n    static bool isEmpty(long[] arr) {\n        return arr.length\
    \ == 0;\n    }\n    static bool isSingleElement(long[] arr) {\n        return\
    \ arr.length == 1;\n    }\n    static bool isMoreThanTwo(long[] arr) {\n     \
    \   return arr.length > 2;\n    }\n    switch(true) {\n        case isEmpty(array):\n\
    \            return array;\n        case isSingleElement(array):\n           \
    \ return array;\n        case isMoreThanTwo(array):\n            if(isOdd(getFirstNLastSum(array)))\n\
    \                return sortItems(array, ordering.lesser);\n            else if(isEven(getFirstNLastSum(array)))\n\
    \                return sortItems(array, ordering.greater);\n    }\n}", "{\n \
    \   if (array.length == 0)\n        return array;\n    long sum = array[0] + array[array.length\
    \ - 1];\n    long[] ret = array.sort(x => x);\n    return (sum & 1) == 0 ? ret.reverse()\
    \ : ret;\n}", "{\n    size_t n = array.length;\n    if (n == 0) return array;\n\
    \    size_t m = n >> 1;\n    long* lhs = sort_array(array[0..m]);\n    long* rhs\
    \ = sort_array(array[m..$]);\n    if ((lhs[0] + rhs[$-1]) & 1) \n    {\n     \
    \   return lhs.sort().array() ~ rhs.sort().array();\n    }\n    else \n    {\n\
    \        return lhs.sort!q{a > b}.array() ~ rhs.sort!q{a > b}.array();\n    }\n\
    }", "{\n    return sort_array_internal(array, 0, array.length, 0);\n}", "{\n \
    \   long first_value = array[0];\n    long last_value = array[array.length - 1];\n\
    \    if((first_value + last_value) % 2 == 0)\n    {\n        std.sort(array);\n\
    \        return array;\n    }\n    else\n    {\n        std.sort(array);\n   \
    \     array.reverse();\n        return array;\n    }\n}", "{\n    int size = array.length;\n\
    \    long[] answer = array.dup;\n    bool isOdd = (array[0] + array[size - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        sort(answer);\n    }\n    else\n \
    \   {\n        sort(answer, (a, b) => b - a);\n    }\n    return answer;\n}",
  "{\n    long first = array[0];\n    long last = array[array.length - 1];\n    bool\
    \ isOdd = (first + last) % 2 == 1;\n    //std.algorithm.sort(array);\n    if (isOdd)\n\
    \    {\n        std.algorithm.sort(array);\n    }\n    else\n    {\n        array\
    \ = array.sorted;\n        array = array.reversed;\n    }\n    return array;\n\
    }", "{\n    if (array.length == 0) return array;\n    return sortArray(array);\n\
    }", "{\n    int n = array.length;\n    if (n == 0) return array;\n    bool odd\
    \ = (array[0] + array[n - 1]) % 2 == 1;\n    long[] copy = array.dup;\n    sort!((a,\
    \ b) => a < b, copy);\n    return odd ? copy : copy.reverse;\n}", "{\n  return\
    \ array.length == 0 || array.length == 1 ? array : sum(array[0], array[$ - 1])\
    \ % 2 == 0\n    ? array.sort().reverse() : array.sort();\n}", "{\n    if (array.length\
    \ == 0)\n        return array;\n    sort_by_oddness(array);\n    return array;\n\
    }", "{\n    if (array.length == 0)\n        return array;\n    auto start = array[0];\n\
    \    auto end = array[$ - 1];\n    enum direction = (start + end) % 2 == 0 ? sortDirection.descending\
    \ : sortDirection.ascending;\n    return array.sort!(direction == sortDirection.ascending\
    \ ? (x, y) => x < y : (x, y) => x > y);\n}", "{\n    if (array.length == 0)\n\
    \        return array;\n    \n    auto arraySum = array[0] + array[$-1];\n   \
    \ if (arraySum % 2 == 0)\n        return array.sort!\"a > b\";\n    \n    return\
    \ array.sort!\"a < b\";\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
