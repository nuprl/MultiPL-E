name: HumanEval_70_strange_sort_list
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
  \ return array in strange order.\n    Strange sorting, is when you start with the\
  \ minimum value,\n    then maximum of the remaining integers, then minimum and so\
  \ on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L,\
  \ 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n \
  \   >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
  \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
  \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
  \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
  \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
  \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
  \ == [111111L]);\n}\nvoid main(){}"
completions: ["{\n    auto odd = true;\n    long[] result = [];\n    bool[] choosen\
    \ = new bool[lst.length];\n    long min_i = 0L;\n    long max_i = 0L;\n    long\
    \ i = 0L;\n    long min = lst[0];\n    long max = lst[0];\n    while (i < lst.length)\
    \ \n    {\n        if (choosen[i]) \n        {\n            i++;\n           \
    \ continue;\n        }\n        if (odd) \n        {\n            if (lst[i] <\
    \ min) \n            {\n                min = lst[i];\n                min_i =\
    \ i;\n            }\n        }\n        else \n        {\n            if (lst[i]\
    \ > max) \n            {\n                max = lst[i];\n                max_i\
    \ = i;\n            }\n        }\n        i++;\n    }\n    odd = !odd;\n    result\
    \ ~= min;\n    choosen[min_i] = true;\n    result ~= max;\n    choosen[max_i]\
    \ = true;\n    foreach (e; lst) \n    {\n        if (e == min || e == max) \n\
    \        {\n            continue;\n        }\n        if (odd) \n        {\n \
    \           if (e < min) \n            {\n                min = e;\n         \
    \       min_i = i;\n            }\n        }\n        else \n        {\n     \
    \       if (e > max) \n            {\n                max = e;\n             \
    \   max_i = i;\n            }\n        }\n        i++;\n    }\n    if (min !=\
    \ max) \n    {\n        odd = !odd;\n        result ~= min;\n        choosen[min_i]\
    \ = true;\n        result ~= max;\n        choosen[max_i] = true;\n    }\n   \
    \ return result;\n}", "{\n    if (lst.length % 2 == 0)\n    {\n        int i =\
    \ 0;\n        bool shift_down = true;\n        while (i < lst.length)\n      \
    \  {\n            if (shift_down)\n            {\n                long min = min(lst[i],\
    \ lst[i + 1]);\n                long max = max(lst[i], lst[i + 1]);\n        \
    \        lst[i] = min;\n                lst[i + 1] = max;\n            }\n   \
    \         else\n            {\n                long max = max(lst[i], lst[i +\
    \ 1]);\n                long min = min(lst[i], lst[i + 1]);\n                lst[i]\
    \ = min;\n                lst[i + 1] = max;\n            }\n            shift_down\
    \ = !shift_down;\n            i += 2;\n        }\n    }\n    else\n    {\n   \
    \     int i = 0;\n        bool shift_down = true;\n        while (i < lst.length\
    \ - 1)\n        {\n            if (shift_down)\n            {\n              \
    \  long min = min(lst[i], lst[i + 1]);\n                long max = max(lst[i],\
    \ lst[i + 1]);\n                lst[i] = min;\n                lst[i + 1] = max;\n\
    \            }\n            else\n            {\n                long max = max(lst[i],\
    \ lst[i + 1]);\n                long min = min(lst[i], lst[i + 1]);\n        \
    \        lst[i] = min;\n                lst[i + 1] = max;\n            }\n   \
    \         shift_down = !shift_down;\n            i += 2;\n        }\n    }\n \
    \   return lst;\n}", "{\n    auto sorted = sort(lst);\n    if (lst.length() %\
    \ 2 == 0)\n    {\n        long[] result = new long[lst.length()];\n        for\
    \ (int i = 0; i < lst.length(); i++)\n        {\n            if (i % 2 == 0)\n\
    \            {\n                result[i] = sorted[i / 2];\n            }\n  \
    \          else\n            {\n                result[i] = sorted[lst.length()\
    \ - i / 2 - 1];\n            }\n        }\n        return result;\n    }\n   \
    \ else\n    {\n        long[] result = new long[lst.length()];\n        for (int\
    \ i = 0; i < lst.length(); i++)\n        {\n            if (i % 2 == 0)\n    \
    \        {\n                result[i] = sorted[i / 2];\n            }\n      \
    \      else\n            {\n                result[i] = sorted[lst.length() -\
    \ i / 2 - 1];\n            }\n        }\n        return result;\n    }\n}", "{\n\
    \    lst = lst.dup;\n    lst.sort;\n    long[] lst1;\n    long[] lst2;\n    if\
    \ (lst.length == 0)\n    {\n        return [];\n    }\n    else if (lst.length\
    \ % 2 == 0)\n    {\n        lst1 = lst[0..$/2];\n        lst2 = lst[$/2..$];\n\
    \    }\n    else\n    {\n        lst1 = lst[0..$/2];\n        lst2 = lst[$/2+1..$];\n\
    \    }\n    long[] result = new long[0];\n    while (lst1.length != 0 && lst2.length\
    \ != 0)\n    {\n        result ~= lst1.front;\n        result ~= lst2.back;\n\
    \        lst1 = lst1[1..$];\n        lst2 = lst2[0..$-1];\n    }\n    if (lst1.length\
    \ != 0)\n    {\n        result ~= lst1.front;\n    }\n    else if (lst2.length\
    \ != 0)\n    {\n        result ~= lst2.front;\n    }\n    return result;\n}",
  "{\n    alias MinMax = Tuple!(long, long);\n    immutable MinMax minmax = lst[0\
    \ .. $ - 1].map!((el) {\n        return tuple(el, el);\n    }).reduce!(MinMax.minMax);\n\
    \    immutable MinMax maxmin = lst[0 .. $ - 1].map!((el) {\n        return tuple(el,\
    \ el);\n    }).reduce!(MinMax.maxMin);\n    long min = minmax[0];\n    long max\
    \ = maxmin[1];\n    long[] strange_sorted = new long[]($);\n    int i = 0;\n \
    \   while (i < $) {\n        strange_sorted[i] = min;\n        i++;\n        if\
    \ (i < $) {\n            strange_sorted[i] = max;\n            i++;\n        }\n\
    \    }\n    return strange_sorted;\n}", "{\n    long max = max(lst);\n    long\
    \ min = min(lst);\n    long[] res = typeof(res).init;\n    immutable bool increase\
    \ = true;\n    foreach(i; lst) \n    {\n        if(increase) \n        {\n   \
    \         auto x = min;\n            foreach(k; lst)\n            {\n        \
    \        if(k > x) \n                {\n                    if(k < max) \n   \
    \                 {\n                        x = k;\n                    }\n \
    \               }\n            }\n            max = x;\n            res ~= x;\n\
    \            increase = false;\n        }\n        else \n        {\n        \
    \    auto x = max;\n            foreach(k; lst)\n            {\n             \
    \   if(k < x) \n                {\n                    if(k > min) \n        \
    \            {\n                        x = k;\n                    }\n      \
    \          }\n            }\n            min = x;\n            res ~= x;\n   \
    \         increase = true;\n        }\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    \n    struct MinMax\n    {\n   \
    \     long min;\n        long max;\n    }\n    \n    MinMax findMinMax(long[]\
    \ lst)\n    {\n        MinMax mm;\n        mm.min = lst[0];\n        mm.max =\
    \ lst[0];\n        foreach (i; 1..lst.length)\n        {\n            if (lst[i]\
    \ < mm.min)\n                mm.min = lst[i];\n            if (lst[i] > mm.max)\n\
    \                mm.max = lst[i];\n        }\n        return mm;\n    }\n    \n\
    \    auto mm = findMinMax(lst);\n    long[] res = new long[lst.length];\n    bool\
    \ descending = false;\n    foreach (i; 0..lst.length)\n    {\n        if (descending)\n\
    \        {\n            res[i] = mm.max;\n            mm.max = mm.max == lst[0]\
    \ ? lst[1] : lst[0];\n        }\n        else\n        {\n            res[i] =\
    \ mm.min;\n            mm.min = mm.min == lst[0] ? lst[1] : lst[0];\n        }\n\
    \        descending = !descending;\n    }\n    return res;\n}", "{\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.algorithm.sorting;\n \
    \   import std.array;\n    import std.range;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.exception;\n    import std.string;\n    import\
    \ std.math;\n    int min_pos = 0;\n    int max_pos = 0;\n    immutable count =\
    \ lst.length;\n    long[] ret = new long[count];\n    foreach (index; 0..2*count-1)\n\
    \    {\n        if (index % 2 == 0)\n        {\n            ret[index] = lst[min_pos];\n\
    \            if (index + 1 == count)\n            {\n                sort(lst[0..$]);\n\
    \                min_pos = min_pos + 1;\n            }\n            else\n   \
    \         {\n                sort(lst[min_pos+1..$]);\n                min_pos\
    \ = min_pos + 1;\n            }\n        }\n        else\n        {\n        \
    \    ret[index] = lst[max_pos];\n            if (index + 1 == count)\n       \
    \     {\n                sort(lst[0..$]);\n                max_pos = max_pos +\
    \ 1;\n            }\n            else\n            {\n                sort(lst[max_pos+1..$]);\n\
    \                max_pos = max_pos + 1;\n            }\n        }\n    }\n   \
    \ return ret;\n}", "{\n    \n    int length_of_list = lst.length;\n    int length_of_list_divided_by_two\
    \ = length_of_list/2;\n    enum sort_direction { MIN, MAX }\n    sort_direction\
    \ sort_direction = sort_direction.MIN;\n    sort_direction next_sort_direction\
    \ = sort_direction.MAX;\n    long[] result_list = new long[length_of_list];\n\
    \    int source_list_index = 0;\n    for (int i = 0; i < length_of_list_divided_by_two;\
    \ i++)\n    {\n        \n        long max_value = lst[i];\n        int max_value_index\
    \ = i;\n        for (int j = source_list_index + 1; j < length_of_list; j++)\n\
    \        {\n            if(lst[j] > max_value)\n            {\n              \
    \  max_value = lst[j];\n                max_value_index = j;\n            }\n\
    \        }\n        if(sort_direction == sort_direction.MIN)\n        {\n    \
    \        result_list[i] = lst[i];\n            result_list[length_of_list_divided_by_two\
    \ + i] = max_value;\n        }\n        else\n        {\n            result_list[i]\
    \ = max_value;\n            result_list[length_of_list_divided_by_two + i] = lst[i];\n\
    \        }\n        sort_direction = next_sort_direction;\n        next_sort_direction\
    \ = (sort_direction == sort_direction.MIN) ? sort_direction.MAX : sort_direction.MIN;\n\
    \        source_list_index = max_value_index;\n    }\n    if(length_of_list %\
    \ 2 != 0)\n    {\n        result_list[length_of_list - 1] = lst[source_list_index];\n\
    \    }\n    return result_list;\n}", "{\n    // We need an array of tuples,\n\
    \    // where first value is `value`\n    // and second value is `index`.\n  \
    \  Tuple!(long, long)[] tuples = lst.map!(x => tuple(x, lst.indexOf(x)));\n  \
    \  // We will sort our array of tuples.\n    tuples.sort!((x, y) => x[0] < y[0]);\n\
    \    // We need to get all values\n    // from our array of tuples.\n    long[]\
    \ values = tuples.map!(x => x[0]).array;\n    // Finally, we will return array\
    \ of `long`\n    // where at index of tuple's `index` we\n    // will put tuple's\
    \ `value`.\n    return values.map!(x => tuple(x, values.indexOf(x))).array;\n\
    }\n/*\n    Put together two arrays.\n    If odd number of elements, let\n    last\
    \ element from first array\n    be at last position.", "{\n    int len = lst.length;\n\
    \    if (len <= 1)\n        return lst;\n    long[] res = new long[len];\n   \
    \ int c = 0;\n    res[c++] = lst[0];\n    long[] new_lst = lst[1..$];\n    long\
    \ min = new_lst[0];\n    long max = new_lst[0];\n    foreach (el; new_lst)\n \
    \   {\n        if (el < min)\n            min = el;\n        if (el > max)\n \
    \           max = el;\n    }\n    res[c++] = max;\n    if (len > 2)\n    {\n \
    \       for (int i = 0; i < len - 2; i++)\n        {\n            if (i % 2 ==\
    \ 0)\n            {\n                foreach (el; new_lst)\n                {\n\
    \                    if (el == min)\n                    {\n                 \
    \       res[c++] = el;\n                        new_lst -= el;\n             \
    \           break;\n                    }\n                }\n            }\n\
    \            else\n            {\n                foreach (el; new_lst)\n    \
    \            {\n                    if (el == max)\n                    {\n  \
    \                      res[c++] = el;\n                        new_lst -= el;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        if (len % 2 == 0)\n            res[c++] = new_lst[0];\n\
    \        else\n            res[c++] = min;\n    }\n    return res;\n}", "{\n \
    \   immutable(long)[] res = sort(lst);\n    immutable(long)[] tmp = res.dup;\n\
    \    auto len = lst.length;\n    res = res[0 .. len / 2];\n    if(len % 2 != 0)\n\
    \    {\n        res ~= tmp[len / 2];\n    }\n    long[] next = tmp[len / 2 ..\
    \ $];\n    foreach(k; 0 .. len / 2)\n    {\n        res ~= next[k];\n        if(len\
    \ % 2 == 0 || k < (len / 2) - 1)\n        {\n            res ~= next[len / 2 -\
    \ k - 1];\n        }\n    }\n    return res;\n}", "{\n    struct list_wrapper\n\
    \    {\n        long[] list;\n        size_t i;\n        long getElement()\n \
    \       {\n            return list[i];\n        }\n        void increment()\n\
    \        {\n            i++;\n        }\n        bool isEmpty()\n        {\n \
    \           return i == list.length;\n        }\n    }\n    auto min_max(list_wrapper\
    \ lw)\n    {\n        static if (is(typeof(lw.list[0]) == long))\n        {\n\
    \            long max = lw.getElement();\n            long min = lw.getElement();\n\
    \            lw.increment();\n            while (!lw.isEmpty())\n            {\n\
    \                max = max(max, lw.getElement());\n                min = min(min,\
    \ lw.getElement());\n                lw.increment();\n            }\n        \
    \    return tuple(min, max);\n        }\n        else\n        {\n           \
    \ // static assert(0, \"Sorry, this sorting is only available for integers\");\n\
    \            return tuple(0L, 0L);\n        }\n    }\n    auto wrapper = list_wrapper(lst,\
    \ 0);\n    long[] result;\n    auto t = min_max(wrapper);\n    while (!wrapper.isEmpty())\n\
    \    {\n        result ~= t[0];\n        result ~= t[1];\n        wrapper.increment();\n\
    \        t = min_max(wrapper);\n    }\n    return result;\n}", "{\n    long[]\
    \ original_list = lst;\n    auto len = lst.length;\n    long[] first_half_list\
    \ = lst[0..len/2];\n    long[] second_half_list = lst[len/2..$];\n    long[] mixed_list\
    \ = [];\n    long[] mixed_list_index = [];\n    long[] mixed_list_index_to_not_add\
    \ = [];\n    // long longest_list_length = max(first_half_list.length, second_half_list.length);\n\
    \    if (len > 0)\n    {\n        for (int x = 0; x < len; x++)\n        {\n \
    \           if (x%2 == 0)\n            {\n                mixed_list ~= first_half_list[x/2];\n\
    \                mixed_list_index ~= (x/2);\n            }\n            else\n\
    \            {\n                mixed_list ~= second_half_list[x/2];\n       \
    \         mixed_list_index ~= (len/2 + x/2);\n            }\n        }\n     \
    \   // writefln(\"mixed_list_index_to_not_add.length = %s\", mixed_list_index_to_not_add.length);\n\
    \        // writefln(\"mixed_list_index_to_not_add = %s\", mixed_list_index_to_not_add);\n\
    \        // writefln(\"mixed_list = %s\", mixed_list);\n        // writefln(\"\
    mixed_list_index = %s\", mixed_list_index);\n        // writefln(\"original_list\
    \ = %s\", original_list);\n        long[] array_of_same_value = [];\n        for\
    \ (int x = 0; x < len; x++)\n        {\n            if (!(mixed_list_index_to_not_add.find(x)))\n\
    \            {\n                long max_value = max(mixed_list);\n          \
    \      long min_value = min(mixed_list);\n                long index_of_max_value\
    \ = mixed_list.find(max_value);\n                long index_of_min_value = mixed_list.find(min_value);\n\
    \                if", "{\n    if (lst.length == 0) \n    {\n        return lst;\n\
    \    }\n    sort(lst);\n    size_t n = lst.length;\n    size_t i = 0;\n    size_t\
    \ j = n - 1;\n    size_t k = 0;\n    long[] res = new long[n];\n    while (k <\
    \ n) \n    {\n        res[k++] = lst[i++];\n        if (k < n) \n        {\n \
    \           res[k++] = lst[j--];\n        }\n    }\n    return res;\n}", "{\n\
    \    long[] output;\n    if (lst.length == 0)\n    {\n        return output;\n\
    \    }\n    else if (lst.length == 1)\n    {\n        output ~= lst[0];\n    \
    \    return output;\n    }\n    long[] tmp = lst.dup;\n    long[] sorted = tmp.sort;\n\
    \    long[] a = sorted[0..$/2];\n    long[] b = sorted[$/2..$];\n    a.reverse;\n\
    \    b.reverse;\n    foreach(a; b) \n    {\n        output ~= a.front;\n     \
    \   output ~= b.front;\n        a.popFront;\n        b.popFront;\n    }\n    if\
    \ (a.length > 0)\n    {\n        output ~= a.front;\n    }\n    return output;\n\
    }", "{\n    auto tpl = minMax(lst);\n    if (tpl[0] == tpl[1])\n        return\
    \ lst;\n    long min = tpl[0];\n    long max = tpl[1];\n    long[] lstSort = lst.retro;\n\
    \    lstSort -= lstSort.idup.array;\n    long[] newList = [];\n    while (lstSort.length\
    \ > 0)\n    {\n        auto tpl = minMax(lstSort);\n        min = tpl[0];\n  \
    \      max = tpl[1];\n        newList ~= min;\n        newList ~= max;\n     \
    \   lstSort -= [min, max];\n    }\n    return newList;\n}", "{\n    // TODO: Implement\
    \ strange_sort_list here.\n    return lst;\n}", "{\n    auto sort_range = retuple(lst[0L..$\
    \ / 2L], lst[($ / 2L)..$]);\n    auto sort_min = sort_range[0L].sort();\n    auto\
    \ sort_max = sort_range[1L].sort(std.algorithm.sorting.greater);\n    return zip!((x,\
    \ y) => tuple(x, y))(sort_min, sort_max).flatMap!(a => [a[0], a[1]]);\n}", "{\n\
    \    \n    // checking if list is empty or not\n    if(lst.length == 0)\n    {\n\
    \        return lst;\n    }\n    \n    // if not empty looping through list\n\
    \    // and creating a tuple of min and max value for the remaining items\n  \
    \  // and removing those values from the list\n    // and then appending those\
    \ items in the tuple to final list\n    auto final_list = [];\n    auto remain_list\
    \ = lst;\n    while(true)\n    {\n        auto element = tuple(remain_list[0],\
    \ remain_list[0]);\n        foreach(remain_item; remain_list)\n        {\n   \
    \         element[0] = min(element[0], remain_item);\n            element[1] =\
    \ max(element[1], remain_item);\n        }\n        final_list ~= element[0];\n\
    \        final_list ~= element[1];\n        remain_list = remain_list.remove(element[0]);\n\
    \        remain_list = remain_list.remove(element[1]);\n        if(remain_list.length\
    \ == 0)\n        {\n            break;\n        }\n    }\n    return final_list;\n\
    }\n// #endregion"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
