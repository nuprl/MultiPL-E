name: HumanEval_70_strange_sort_list
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
  \ return array in strange order.\n    Strange sorting, is when you start with the\
  \ minimum value,\n    then maximum of the remaining integers, then minimum and so\
  \ on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L,\
  \ 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n \
  \   >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
  \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
  \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
  \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
  \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
  \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
  \ == [111111L]);\n}\nvoid main(){}"
completions: ["{\n    auto odd = true;\n    long[] result = [];\n    bool[] choosen\
    \ = new bool[lst.length];\n    long min_i = 0L;\n    long max_i = 0L;\n    long\
    \ i = 0L;\n    long min = lst[0];\n    long max = lst[0];\n    while (i < lst.length)\
    \ \n    {\n        if (choosen[i]) \n        {\n            i++;\n           \
    \ continue;\n        }\n        if (odd) \n        {\n            if (lst[i] <\
    \ min) \n            {\n                min = lst[i];\n                min_i =\
    \ i;\n            }\n        }\n        else \n        {\n            if (lst[i]\
    \ > max) \n            {\n                max = lst[i];\n                max_i\
    \ = i;\n            }\n        }\n        i++;\n    }\n    odd = !odd;\n    result\
    \ ~= min;\n    choosen[min_i] = true;\n    result ~= max;\n    choosen[max_i]\
    \ = true;\n    foreach (e; lst) \n    {\n        if (e == min || e == max) \n\
    \        {\n            continue;\n        }\n        if (odd) \n        {\n \
    \           if (e < min) \n            {\n                min = e;\n         \
    \       min_i = i;\n            }\n        }\n        else \n        {\n     \
    \       if (e > max) \n            {\n                max = e;\n             \
    \   max_i = i;\n            }\n        }\n        i++;\n    }\n    if (min !=\
    \ max) \n    {\n        odd = !odd;\n        result ~= min;\n        choosen[min_i]\
    \ = true;\n        result ~= max;\n        choosen[max_i] = true;\n    }\n   \
    \ return result;\n}", "{\n    if (lst.length % 2 == 0)\n    {\n        int i =\
    \ 0;\n        bool shift_down = true;\n        while (i < lst.length)\n      \
    \  {\n            if (shift_down)\n            {\n                long min = min(lst[i],\
    \ lst[i + 1]);\n                long max = max(lst[i], lst[i + 1]);\n        \
    \        lst[i] = min;\n                lst[i + 1] = max;\n            }\n   \
    \         else\n            {\n                long max = max(lst[i], lst[i +\
    \ 1]);\n                long min = min(lst[i], lst[i + 1]);\n                lst[i]\
    \ = min;\n                lst[i + 1] = max;\n            }\n            shift_down\
    \ = !shift_down;\n            i += 2;\n        }\n    }\n    else\n    {\n   \
    \     int i = 0;\n        bool shift_down = true;\n        while (i < lst.length\
    \ - 1)\n        {\n            if (shift_down)\n            {\n              \
    \  long min = min(lst[i], lst[i + 1]);\n                long max = max(lst[i],\
    \ lst[i + 1]);\n                lst[i] = min;\n                lst[i + 1] = max;\n\
    \            }\n            else\n            {\n                long max = max(lst[i],\
    \ lst[i + 1]);\n                long min = min(lst[i], lst[i + 1]);\n        \
    \        lst[i] = min;\n                lst[i + 1] = max;\n            }\n   \
    \         shift_down = !shift_down;\n            i += 2;\n        }\n    }\n \
    \   return lst;\n}", "{\n    auto sorted = sort(lst);\n    if (lst.length() %\
    \ 2 == 0)\n    {\n        long[] result = new long[lst.length()];\n        for\
    \ (int i = 0; i < lst.length(); i++)\n        {\n            if (i % 2 == 0)\n\
    \            {\n                result[i] = sorted[i / 2];\n            }\n  \
    \          else\n            {\n                result[i] = sorted[lst.length()\
    \ - i / 2 - 1];\n            }\n        }\n        return result;\n    }\n   \
    \ else\n    {\n        long[] result = new long[lst.length()];\n        for (int\
    \ i = 0; i < lst.length(); i++)\n        {\n            if (i % 2 == 0)\n    \
    \        {\n                result[i] = sorted[i / 2];\n            }\n      \
    \      else\n            {\n                result[i] = sorted[lst.length() -\
    \ i / 2 - 1];\n            }\n        }\n        return result;\n    }\n}", "{\n\
    \    lst = lst.dup;\n    lst.sort;\n    long[] lst1;\n    long[] lst2;\n    if\
    \ (lst.length == 0)\n    {\n        return [];\n    }\n    else if (lst.length\
    \ % 2 == 0)\n    {\n        lst1 = lst[0..$/2];\n        lst2 = lst[$/2..$];\n\
    \    }\n    else\n    {\n        lst1 = lst[0..$/2];\n        lst2 = lst[$/2+1..$];\n\
    \    }\n    long[] result = new long[0];\n    while (lst1.length != 0 && lst2.length\
    \ != 0)\n    {\n        result ~= lst1.front;\n        result ~= lst2.back;\n\
    \        lst1 = lst1[1..$];\n        lst2 = lst2[0..$-1];\n    }\n    if (lst1.length\
    \ != 0)\n    {\n        result ~= lst1.front;\n    }\n    else if (lst2.length\
    \ != 0)\n    {\n        result ~= lst2.front;\n    }\n    return result;\n}",
  "{\n    alias MinMax = Tuple!(long, long);\n    immutable MinMax minmax = lst[0\
    \ .. $ - 1].map!((el) {\n        return tuple(el, el);\n    }).reduce!(MinMax.minMax);\n\
    \    immutable MinMax maxmin = lst[0 .. $ - 1].map!((el) {\n        return tuple(el,\
    \ el);\n    }).reduce!(MinMax.maxMin);\n    long min = minmax[0];\n    long max\
    \ = maxmin[1];\n    long[] strange_sorted = new long[]($);\n    int i = 0;\n \
    \   while (i < $) {\n        strange_sorted[i] = min;\n        i++;\n        if\
    \ (i < $) {\n            strange_sorted[i] = max;\n            i++;\n        }\n\
    \    }\n    return strange_sorted;\n}", "{\n    long max = max(lst);\n    long\
    \ min = min(lst);\n    long[] res = typeof(res).init;\n    immutable bool increase\
    \ = true;\n    foreach(i; lst) \n    {\n        if(increase) \n        {\n   \
    \         auto x = min;\n            foreach(k; lst)\n            {\n        \
    \        if(k > x) \n                {\n                    if(k < max) \n   \
    \                 {\n                        x = k;\n                    }\n \
    \               }\n            }\n            max = x;\n            res ~= x;\n\
    \            increase = false;\n        }\n        else \n        {\n        \
    \    auto x = max;\n            foreach(k; lst)\n            {\n             \
    \   if(k < x) \n                {\n                    if(k > min) \n        \
    \            {\n                        x = k;\n                    }\n      \
    \          }\n            }\n            min = x;\n            res ~= x;\n   \
    \         increase = true;\n        }\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    \n    struct MinMax\n    {\n   \
    \     long min;\n        long max;\n    }\n    \n    MinMax findMinMax(long[]\
    \ lst)\n    {\n        MinMax mm;\n        mm.min = lst[0];\n        mm.max =\
    \ lst[0];\n        foreach (i; 1..lst.length)\n        {\n            if (lst[i]\
    \ < mm.min)\n                mm.min = lst[i];\n            if (lst[i] > mm.max)\n\
    \                mm.max = lst[i];\n        }\n        return mm;\n    }\n    \n\
    \    auto mm = findMinMax(lst);\n    long[] res = new long[lst.length];\n    bool\
    \ descending = false;\n    foreach (i; 0..lst.length)\n    {\n        if (descending)\n\
    \        {\n            res[i] = mm.max;\n            mm.max = mm.max == lst[0]\
    \ ? lst[1] : lst[0];\n        }\n        else\n        {\n            res[i] =\
    \ mm.min;\n            mm.min = mm.min == lst[0] ? lst[1] : lst[0];\n        }\n\
    \        descending = !descending;\n    }\n    return res;\n}", "{\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.algorithm.sorting;\n \
    \   import std.array;\n    import std.range;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.exception;\n    import std.string;\n    import\
    \ std.math;\n    int min_pos = 0;\n    int max_pos = 0;\n    immutable count =\
    \ lst.length;\n    long[] ret = new long[count];\n    foreach (index; 0..2*count-1)\n\
    \    {\n        if (index % 2 == 0)\n        {\n            ret[index] = lst[min_pos];\n\
    \            if (index + 1 == count)\n            {\n                sort(lst[0..$]);\n\
    \                min_pos = min_pos + 1;\n            }\n            else\n   \
    \         {\n                sort(lst[min_pos+1..$]);\n                min_pos\
    \ = min_pos + 1;\n            }\n        }\n        else\n        {\n        \
    \    ret[index] = lst[max_pos];\n            if (index + 1 == count)\n       \
    \     {\n                sort(lst[0..$]);\n                max_pos = max_pos +\
    \ 1;\n            }\n            else\n            {\n                sort(lst[max_pos+1..$]);\n\
    \                max_pos = max_pos + 1;\n            }\n        }\n    }\n   \
    \ return ret;\n}", "{\n    \n    int length_of_list = lst.length;\n    int length_of_list_divided_by_two\
    \ = length_of_list/2;\n    enum sort_direction { MIN, MAX }\n    sort_direction\
    \ sort_direction = sort_direction.MIN;\n    sort_direction next_sort_direction\
    \ = sort_direction.MAX;\n    long[] result_list = new long[length_of_list];\n\
    \    int source_list_index = 0;\n    for (int i = 0; i < length_of_list_divided_by_two;\
    \ i++)\n    {\n        \n        long max_value = lst[i];\n        int max_value_index\
    \ = i;\n        for (int j = source_list_index + 1; j < length_of_list; j++)\n\
    \        {\n            if(lst[j] > max_value)\n            {\n              \
    \  max_value = lst[j];\n                max_value_index = j;\n            }\n\
    \        }\n        if(sort_direction == sort_direction.MIN)\n        {\n    \
    \        result_list[i] = lst[i];\n            result_list[length_of_list_divided_by_two\
    \ + i] = max_value;\n        }\n        else\n        {\n            result_list[i]\
    \ = max_value;\n            result_list[length_of_list_divided_by_two + i] = lst[i];\n\
    \        }\n        sort_direction = next_sort_direction;\n        next_sort_direction\
    \ = (sort_direction == sort_direction.MIN) ? sort_direction.MAX : sort_direction.MIN;\n\
    \        source_list_index = max_value_index;\n    }\n    if(length_of_list %\
    \ 2 != 0)\n    {\n        result_list[length_of_list - 1] = lst[source_list_index];\n\
    \    }\n    return result_list;\n}", "{\n    // We need an array of tuples,\n\
    \    // where first value is `value`\n    // and second value is `index`.\n  \
    \  Tuple!(long, long)[] tuples = lst.map!(x => tuple(x, lst.indexOf(x)));\n  \
    \  // We will sort our array of tuples.\n    tuples.sort!((x, y) => x[0] < y[0]);\n\
    \    // We need to get all values\n    // from our array of tuples.\n    long[]\
    \ values = tuples.map!(x => x[0]).array;\n    // Finally, we will return array\
    \ of `long`\n    // where at index of tuple's `index` we\n    // will put tuple's\
    \ `value`.\n    return values.map!(x => tuple(x, values.indexOf(x))).array;\n\
    }\n/*\n    Put together two arrays.\n    If odd number of elements, let\n    last\
    \ element from first array\n    be at last position.", "{\n    int len = lst.length;\n\
    \    if (len <= 1)\n        return lst;\n    long[] res = new long[len];\n   \
    \ int c = 0;\n    res[c++] = lst[0];\n    long[] new_lst = lst[1..$];\n    long\
    \ min = new_lst[0];\n    long max = new_lst[0];\n    foreach (el; new_lst)\n \
    \   {\n        if (el < min)\n            min = el;\n        if (el > max)\n \
    \           max = el;\n    }\n    res[c++] = max;\n    if (len > 2)\n    {\n \
    \       for (int i = 0; i < len - 2; i++)\n        {\n            if (i % 2 ==\
    \ 0)\n            {\n                foreach (el; new_lst)\n                {\n\
    \                    if (el == min)\n                    {\n                 \
    \       res[c++] = el;\n                        new_lst -= el;\n             \
    \           break;\n                    }\n                }\n            }\n\
    \            else\n            {\n                foreach (el; new_lst)\n    \
    \            {\n                    if (el == max)\n                    {\n  \
    \                      res[c++] = el;\n                        new_lst -= el;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        if (len % 2 == 0)\n            res[c++] = new_lst[0];\n\
    \        else\n            res[c++] = min;\n    }\n    return res;\n}", "{\n \
    \   immutable(long)[] res = sort(lst);\n    immutable(long)[] tmp = res.dup;\n\
    \    auto len = lst.length;\n    res = res[0 .. len / 2];\n    if(len % 2 != 0)\n\
    \    {\n        res ~= tmp[len / 2];\n    }\n    long[] next = tmp[len / 2 ..\
    \ $];\n    foreach(k; 0 .. len / 2)\n    {\n        res ~= next[k];\n        if(len\
    \ % 2 == 0 || k < (len / 2) - 1)\n        {\n            res ~= next[len / 2 -\
    \ k - 1];\n        }\n    }\n    return res;\n}", "{\n    struct list_wrapper\n\
    \    {\n        long[] list;\n        size_t i;\n        long getElement()\n \
    \       {\n            return list[i];\n        }\n        void increment()\n\
    \        {\n            i++;\n        }\n        bool isEmpty()\n        {\n \
    \           return i == list.length;\n        }\n    }\n    auto min_max(list_wrapper\
    \ lw)\n    {\n        static if (is(typeof(lw.list[0]) == long))\n        {\n\
    \            long max = lw.getElement();\n            long min = lw.getElement();\n\
    \            lw.increment();\n            while (!lw.isEmpty())\n            {\n\
    \                max = max(max, lw.getElement());\n                min = min(min,\
    \ lw.getElement());\n                lw.increment();\n            }\n        \
    \    return tuple(min, max);\n        }\n        else\n        {\n           \
    \ // static assert(0, \"Sorry, this sorting is only available for integers\");\n\
    \            return tuple(0L, 0L);\n        }\n    }\n    auto wrapper = list_wrapper(lst,\
    \ 0);\n    long[] result;\n    auto t = min_max(wrapper);\n    while (!wrapper.isEmpty())\n\
    \    {\n        result ~= t[0];\n        result ~= t[1];\n        wrapper.increment();\n\
    \        t = min_max(wrapper);\n    }\n    return result;\n}", "{\n    long[]\
    \ original_list = lst;\n    auto len = lst.length;\n    long[] first_half_list\
    \ = lst[0..len/2];\n    long[] second_half_list = lst[len/2..$];\n    long[] mixed_list\
    \ = [];\n    long[] mixed_list_index = [];\n    long[] mixed_list_index_to_not_add\
    \ = [];\n    // long longest_list_length = max(first_half_list.length, second_half_list.length);\n\
    \    if (len > 0)\n    {\n        for (int x = 0; x < len; x++)\n        {\n \
    \           if (x%2 == 0)\n            {\n                mixed_list ~= first_half_list[x/2];\n\
    \                mixed_list_index ~= (x/2);\n            }\n            else\n\
    \            {\n                mixed_list ~= second_half_list[x/2];\n       \
    \         mixed_list_index ~= (len/2 + x/2);\n            }\n        }\n     \
    \   // writefln(\"mixed_list_index_to_not_add.length = %s\", mixed_list_index_to_not_add.length);\n\
    \        // writefln(\"mixed_list_index_to_not_add = %s\", mixed_list_index_to_not_add);\n\
    \        // writefln(\"mixed_list = %s\", mixed_list);\n        // writefln(\"\
    mixed_list_index = %s\", mixed_list_index);\n        // writefln(\"original_list\
    \ = %s\", original_list);\n        long[] array_of_same_value = [];\n        for\
    \ (int x = 0; x < len; x++)\n        {\n            if (!(mixed_list_index_to_not_add.find(x)))\n\
    \            {\n                long max_value = max(mixed_list);\n          \
    \      long min_value = min(mixed_list);\n                long index_of_max_value\
    \ = mixed_list.find(max_value);\n                long index_of_min_value = mixed_list.find(min_value);\n\
    \                if", "{\n    if (lst.length == 0) \n    {\n        return lst;\n\
    \    }\n    sort(lst);\n    size_t n = lst.length;\n    size_t i = 0;\n    size_t\
    \ j = n - 1;\n    size_t k = 0;\n    long[] res = new long[n];\n    while (k <\
    \ n) \n    {\n        res[k++] = lst[i++];\n        if (k < n) \n        {\n \
    \           res[k++] = lst[j--];\n        }\n    }\n    return res;\n}", "{\n\
    \    long[] output;\n    if (lst.length == 0)\n    {\n        return output;\n\
    \    }\n    else if (lst.length == 1)\n    {\n        output ~= lst[0];\n    \
    \    return output;\n    }\n    long[] tmp = lst.dup;\n    long[] sorted = tmp.sort;\n\
    \    long[] a = sorted[0..$/2];\n    long[] b = sorted[$/2..$];\n    a.reverse;\n\
    \    b.reverse;\n    foreach(a; b) \n    {\n        output ~= a.front;\n     \
    \   output ~= b.front;\n        a.popFront;\n        b.popFront;\n    }\n    if\
    \ (a.length > 0)\n    {\n        output ~= a.front;\n    }\n    return output;\n\
    }", "{\n    auto tpl = minMax(lst);\n    if (tpl[0] == tpl[1])\n        return\
    \ lst;\n    long min = tpl[0];\n    long max = tpl[1];\n    long[] lstSort = lst.retro;\n\
    \    lstSort -= lstSort.idup.array;\n    long[] newList = [];\n    while (lstSort.length\
    \ > 0)\n    {\n        auto tpl = minMax(lstSort);\n        min = tpl[0];\n  \
    \      max = tpl[1];\n        newList ~= min;\n        newList ~= max;\n     \
    \   lstSort -= [min, max];\n    }\n    return newList;\n}", "{\n    // TODO: Implement\
    \ strange_sort_list here.\n    return lst;\n}", "{\n    auto sort_range = retuple(lst[0L..$\
    \ / 2L], lst[($ / 2L)..$]);\n    auto sort_min = sort_range[0L].sort();\n    auto\
    \ sort_max = sort_range[1L].sort(std.algorithm.sorting.greater);\n    return zip!((x,\
    \ y) => tuple(x, y))(sort_min, sort_max).flatMap!(a => [a[0], a[1]]);\n}", "{\n\
    \    \n    // checking if list is empty or not\n    if(lst.length == 0)\n    {\n\
    \        return lst;\n    }\n    \n    // if not empty looping through list\n\
    \    // and creating a tuple of min and max value for the remaining items\n  \
    \  // and removing those values from the list\n    // and then appending those\
    \ items in the tuple to final list\n    auto final_list = [];\n    auto remain_list\
    \ = lst;\n    while(true)\n    {\n        auto element = tuple(remain_list[0],\
    \ remain_list[0]);\n        foreach(remain_item; remain_list)\n        {\n   \
    \         element[0] = min(element[0], remain_item);\n            element[1] =\
    \ max(element[1], remain_item);\n        }\n        final_list ~= element[0];\n\
    \        final_list ~= element[1];\n        remain_list = remain_list.remove(element[0]);\n\
    \        remain_list = remain_list.remove(element[1]);\n        if(remain_list.length\
    \ == 0)\n        {\n            break;\n        }\n    }\n    return final_list;\n\
    }\n// #endregion", "{ \n    auto res = new long[];\n    //if the list is empty,\
    \ return an empty list\n    if(lst.length == 0)\n        return res;\n    //keep\
    \ track of the minimum and maximum value\n    long min = 0, max = 0;\n    //find\
    \ the minimum and maximum value, and the indexes\n    //of each value\n    auto\
    \ min_list = new Tuple!(long, long)[];\n    auto max_list = new Tuple!(long, long)[];\n\
    \    for(size_t i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == min)\n\
    \            min_list ~= tuple(lst[i], i);\n        else if(lst[i] < min)\n  \
    \      {\n            min = lst[i];\n            min_list = [tuple(lst[i], i)];\n\
    \        }\n        if(lst[i] == max)\n            max_list ~= tuple(lst[i], i);\n\
    \        else if(lst[i] > max)\n        {\n            max = lst[i];\n       \
    \     max_list = [tuple(lst[i], i)];\n        }\n    }\n    //for each value in\
    \ the list from the beginning, add\n    //the value to the result list. \n   \
    \ for(size_t i = 0; i < lst.length; i++)\n    {\n        //go through the minimum\
    \ and maximum list and add\n        //the value corresponding to the index of\
    \ i to the result\n        //list.\n        for(auto min_tuple : min_list)\n \
    \       {\n            if(min_tuple[1] == i)\n            {\n                res\
    \ ~= min_tuple[0];\n                break;\n            }\n        }\n       \
    \ for(auto max_tuple : max_list)\n        {\n            if(max_tuple[1] == i)\n\
    \            {\n                res ~= max_tuple[0];\n                break;\n\
    \            }\n        }\n    }\n    return res;\n}", "{\n    auto myList = lst.dup;\n\
    \    myList.sort();\n    long[] _ret = new long[0];\n    foreach(immutable i;\
    \ 0..(lst.length() / 2))\n    {\n        _ret ~= myList[i];\n        _ret ~= myList[(lst.length()\
    \ - 1) - i];\n    }\n    if(lst.length() % 2 != 0)\n    {\n        _ret ~= myList[lst.length()\
    \ / 2];\n    }\n    return _ret;\n}", "{\n\tif (lst.length <= 1)\n\t\treturn lst;\n\
    \tlst = lst.dup;\n\tlst.sort;\n\tlong[] dst = new long[lst.length];\n\tbool inverse\
    \ = false;\n\tint n = 0;\n\twhile (true) {\n\t\tif (inverse)\n\t\t\tn = lst.length\
    \ - 1;\n\t\tfor (int i = 0; i < lst.length; i++) {\n\t\t\tif (lst[n] == long.min)\n\
    \t\t\t\tcontinue;\n\t\t\tdst[i] = lst[n];\n\t\t\tlst[n] = long.min;\n\t\t\tif\
    \ (inverse)\n\t\t\t\tn--;\n\t\t\telse\n\t\t\t\tn++;\n\t\t}\n\t\tinverse = !inverse;\n\
    \t\tif (n == lst.length)\n\t\t\tbreak;\n\t}\n\treturn dst;\n}", "{\n    if (lst.length\
    \ == 0) \n    {\n        return lst;\n    }\n    long min_val = min(lst);\n  \
    \  long max_val = max(lst);\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool min_next = true;\n    int cnt = 0;\n    while\
    \ (cnt < lst.length) \n    {\n        if (min_next) \n        {\n            result[cnt]\
    \ = min_val;\n            remove(lst_copy, min_val);\n            min_val = min(lst_copy);\n\
    \        } \n        else \n        {\n            result[cnt] = max_val;\n  \
    \          remove(lst_copy, max_val);\n            max_val = max(lst_copy);\n\
    \        }\n        min_next = !min_next;\n        cnt += 1;\n    }\n    return\
    \ result;\n}", "{\n    return lst.zip(lst.length.enumerate).sort!((a, b) => (a[1]\
    \ * 2 / lst.length + a[1] % 2 * (lst.length - 1)) < (b[1] * 2 / lst.length + b[1]\
    \ % 2 * (lst.length - 1))).array();\n}", "{\n    return lst.sort.dg.joiner.joiner.joiner.joiner(lst.reverse);\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    \n    int mn = lst[0];\n\
    \    for (in", "{\n    if (lst.length == 0)\n        return new long[0];\n   \
    \ \n    lst.sort;\n    long min = lst[0];\n    lst = lst[1..$];\n    lst.reverse;\n\
    \    lst.unshift(min);\n    long result_length = lst.length * 2;\n    long[] result\
    \ = new long[result_length];\n    long i = 0;\n    long j = 1;\n    foreach (ele;\
    \ lst)\n    {\n        result[i] = ele;\n        result[j] = lst[$ - i - 1];\n\
    \        i += 2;\n        j += 2;\n    }\n    return result;\n}", "{\n    // You\
    \ code here\n    long[] newLst = new long[lst.length];\n    long min, max;\n \
    \   bool isMin = true;\n    bool isMax = false;\n    long counter = 0;\n    if(lst.length\
    \ == 0) return newLst;\n    do{\n        if(isMin)\n        {\n            min\
    \ = lst[0];\n            foreach(long index, long val; lst)\n            {\n \
    \               if(val < min) min = val;\n            }\n            newLst[counter]\
    \ = min;\n            isMin = false;\n            isMax = true;\n            counter++;\n\
    \        }\n        if(isMax)\n        {\n            max = lst[0];\n        \
    \    foreach(long index, long val; lst)\n            {\n                if(val\
    \ > max) max = val;\n            }\n            newLst[counter] = max;\n     \
    \       isMax = false;\n            isMin = true;\n            counter++;\n  \
    \      }\n    }while(counter < lst.length);\n    return newLst;\n}", "{\n    if\
    \ (lst.length == 0) \n    {\n        return lst;\n    }\n    return strange_sort_list(lst[1\
    \ .. $])\n        .map!((x) => (x < lst[0]))\n        .array\n        .replace(false,\
    \ tuple(lst[0], lst[0]))\n        .expand!((t) => [t[0], t[1]]);\n}", "{\n   \
    \ if (lst.length == 0) \n    {\n        return lst;\n    }\n    long[] result\
    \ = new long[lst.length];\n    long[][] t = lst.sort().chunks(2);\n    enum i\
    \ = 0;\n    foreach (chunk; t) \n    {\n        foreach (d; chunk) \n        {\n\
    \            result[i] = d;\n            i += 1;\n        }\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    int cnt\
    \ = lst.length;\n    auto reverse = ((cnt % 2) == 0) ? false : true;\n    auto\
    \ lst_rev = lst.sort.reverse;\n    long[] res = new long[cnt];\n    int i = 0;\n\
    \    while (cnt > 0)\n    {\n        if (!reverse)\n        {\n            res[i]\
    \ = lst[0];\n            lst = lst[1..$];\n        }\n        else\n        {\n\
    \            res[i] = lst_rev[0];\n            lst_rev = lst_rev[1..$];\n    \
    \    }\n        i++;\n        cnt--;\n        reverse = !reverse;\n    }\n   \
    \ return res;\n}", "{\n    // write here\n    return lst;\n}\n \n ", "{\n    if\
    \ (lst.length == 0) \n    {\n        return lst;\n    }\n    else if (lst.length\
    \ == 1) \n    {\n        return lst;\n    }\n    else if (lst.length == 2) \n\
    \    {\n        return lst;\n    }\n    else \n    {\n        long[] sorted_list\
    \ = sort(lst);\n        bool direction = true;\n        long[] new_list = new\
    \ long[sorted_list.length];\n        int i = 0;\n        int j = sorted_list.length\
    \ - 1;\n        int k = 0;\n        while (i < j) \n        {\n            if\
    \ (direction) \n            {\n                new_list[k] = sorted_list[i];\n\
    \                i++;\n            }\n            else \n            {\n     \
    \           new_list[k] = sorted_list[j];\n                j--;\n            }\n\
    \            direction = !direction;\n            k++;\n        }\n        if\
    \ (i == j) \n        {\n            new_list[k] = sorted_list[i];\n        }\n\
    \        return new_list;\n    }\n}", "{\n\tlst = sort(lst);\n\tlong[] res = new\
    \ long[lst.length];\n\tint i, j;\n\tint r;\n\ti = 0;\n\tj = lst.length - 1;\n\t\
    r = 0;\n\twhile(true)\n\t{\n\t\tif(i < lst.length)\n\t\t{\n\t\t\tres[r] = lst[i];\n\
    \t\t\ti++;\n\t\t\tr++;\n\t\t}\n\t\tif(j < lst.length)\n\t\t{\n\t\t\tres[r] = lst[j];\n\
    \t\t\tj--;\n\t\t\tr++;\n\t\t}\n\t\tif(r == lst.length)\n\t\t\tbreak;\n\t}\n\t\
    return res;\n}", "{\n    enum even = true;\n    enum odd = false;\n    // empty\
    \ case.\n    if (empty(lst)) \n    {\n        return lst;\n    }\n    // creating\
    \ tuple with \n    // first element being list of all even numbers\n    // second\
    \ element being list of all odd numbers\n    Tuple!(long[], long[]) list_of_even_odds\
    \ = tuple(filter!(isEven)(lst), filter!(isOdd)(lst));\n    // sorting list of\
    \ evens in ascending order\n    sort!(a => a < b)(list_of_even_odds[even]);\n\
    \    // sorting list of odds in descending order\n    sort!(a => a > b)(list_of_even_odds[odd]);\n\
    \    // result list\n    long[] result_list = new long[];\n    // list with even\
    \ elements\n    long[] list_even = list_of_even_odds[even];\n    // list with\
    \ odd elements\n    long[] list_odd = list_of_even_odds[odd];\n    // while even\
    \ and odd list are not empty\n    while (!empty(list_even) && !empty(list_odd))\
    \ \n    {\n        // append first element of even list to result list\n     \
    \   result_list ~= list_even[0];\n        // append first element of odd list\
    \ to result list\n        result_list ~= list_odd[0];\n        // remove first\
    \ element of even list\n        list_even = list_even[1 .. $];\n        // remove\
    \ first element of odd list\n        list_odd = list_odd[1 .. $];\n    }\n   \
    \ // append all the remaining numbers to result list\n    result_list ~= list_even;\n\
    \    result_list ~= list_odd;\n    return result_list;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto sorted = lst.array.sort;\n    long[] result\
    \ = new long[sorted.length];\n    for (auto i = 0; i < sorted.length; i += 2)\n\
    \    {\n        result[i] = sorted[i / 2];\n        if (i + 1 < sorted.length)\n\
    \            result[i + 1] = sorted[sorted.length - (i / 2) - 1];\n    }\n   \
    \ return result;\n}\n/*", "{\n    int low = 0;\n    int high = lst.length - 1;\n\
    \    long[] result = new long[lst.length];\n    int index = 0;\n    foreach(i;\
    \ 0..lst.length) \n    {\n        if(i % 2 == 0) \n        {\n            result[index]\
    \ = lst[low];\n            low++;\n        }\n        else \n        {\n     \
    \       result[index] = lst[high];\n            high--;\n        }\n        index++;\n\
    \    }\n    return result;\n}", "{\n    long[] even = [], odd = [];\n    foreach(val;\
    \ lst) {\n        if(val % 2 == 0)\n            even ~= val;\n        else\n \
    \           odd ~= val;\n    }\n    even.sort;\n    odd.sort;\n    long[] ret\
    \ = [];\n    while(even.length != 0 && odd.length != 0) {\n        ret ~= even.front;\n\
    \        even.popFront;\n        ret ~= odd.back;\n        odd.popBack;\n    }\n\
    \    return ret;\n}\n \n/*\n    Check if list is sorted, ascending or descending.\n\
    \    \n    Examples:\n    >>> is_sorted([1L, 2L, 3L, 4L])\n    true\n    >>> is_sorted([4L,\
    \ 3L, 2L, 1L])\n    true\n    >>> is_sorted([2L, 3L, 1L, 4L])\n    false\n   \
    \ >>> is_sorted([1L, 2L, 4L, 3L])\n    false\n    >>> is_sorted([])\n    true\n\
    */", "{ \n    if (lst.length == 0) \n        return lst; \n    long min_pos =\
    \ 0; \n    long min_val = lst[0]; \n    long max_pos = 0; \n    long max_val =\
    \ lst[0]; \n    long i = 0; \n    long[] res = new long[lst.length]; \n    for\
    \ (long l : lst) \n    { \n        if (l < min_val) \n        { \n           \
    \ min_val = l; \n            min_pos = i; \n        } \n        if (l > max_val)\
    \ \n        { \n            max_val = l; \n            max_pos = i; \n       \
    \ } \n        i++; \n    } \n    i = 0; \n    long dir = 1; \n    long pos = min_pos;\
    \ \n    if (min_pos < max_pos) \n    { \n        pos = max_pos; \n        dir\
    \ = -1; \n    } \n    for (long j = 0; j < lst.length; j++) \n    { \n       \
    \ res[i] = lst[pos]; \n        i++; \n        pos += dir; \n        if (dir ==\
    \ 1 && pos == max_pos) \n        { \n            dir = -1; \n            pos =\
    \ min_pos; \n        } \n        if (dir == -1 && pos == min_pos) \n        {\
    \ \n            dir = 1; \n            pos = max_pos; \n        } \n    } \n \
    \   return res; \n} \n/*\n    Once upon a time, on a way through the old wild\
    \ mountainous west,\u2026\n    \u2026 a man was given directions to go from one\
    \ point to another. \n    The directions were \"NORTH\", \"SOUTH\", \"WEST\",\
    \ \"EAST\". Clearly \"NORTH\" \n    and \"SOUTH\" are opposite, \"WEST\" and \"\
    EAST\" too. Going to one direction \n    and coming back the opposite direction\
    \ is a needless effort. Since this \n    is the wild west, with dreadfull weather",
  "{\n    if (lst.length == 0)\n        return lst;\n    sort(lst);\n    long[] result\
    \ = new long[lst.length];\n    int offset = lst.length / 2;\n    if (lst.length\
    \ % 2 == 0) \n        offset--;\n    int next_neg = 0;\n    int next_pos = offset;\n\
    \    foreach (i; 0 .. lst.length) \n    {\n        if (i % 2 == 0) \n        {\n\
    \            result[i] = lst[next_neg];\n            next_neg++;\n        } \n\
    \        else \n        {\n            result[i] = lst[next_pos];\n          \
    \  next_pos++;\n        }\n    }\n    return result;\n}", "{\n    // Getting a\
    \ tuple of arrays with the values sorted in ascending order and the original indexes\n\
    \    Tuple!(long[], int[]) tuple = sort_and_index(lst);\n    auto [new_lst, indexes]\
    \ = tuple;\n    long[] result = new long[new_lst.length];\n    bool even = true;\n\
    \    int index = 0;\n    while (true) {\n        if (new_lst.length <= 0) break;\n\
    \        if (even) {\n            result[index] = new_lst[0];\n            new_lst\
    \ = new_lst[1 .. $];\n        } else {\n            result[index] = new_lst[$\
    \ - 1];\n            new_lst = new_lst[0 .. $ - 1];\n        }\n        index++;\n\
    \        even = !even;\n    }\n    return result;\n}", "{\n    // C++: int n =\
    \ lst.size();", "{\n    long[] idx = new long[lst.length];\n    foreach(i; 0..lst.length)\
    \ idx[i] = i;\n    idx.sort!((i, j) => lst[i] < lst[j]);\n    return idx.map!(i\
    \ => lst[i]);\n}\n \n \n ", "{\n    if (empty(lst)) return lst;\n    auto s =\
    \ sort(lst);\n    auto n = s.length;\n    // Fisrt Item of list is first Item\
    \ of sorted list\n    auto result = new long[n];\n    result[0] = s[0];\n    //\
    \ Choose min/max item from list and add to result\n    int j = 1;\n    bool min\
    \ = true;\n    for (int i = 1; i < n; i++) {\n        if (min) {\n           \
    \ result[j] = s[i];\n            j += 2;\n        } else {\n            result[j]\
    \ = s[n - i];\n            j += 2;\n        }\n        min = !min;\n    }\n  \
    \  return result;\n}", "{\n    auto result = new long[lst.length];\n    size_t[int]\
    \ indexes = [0 : iota(lst.length)];\n    foreach(int i; 0 .. 2 * lst.length)\n\
    \    {\n        auto min_or_max = i % 2 == 0 ? std.algorithm.maxElement(lst[indexes])\
    \ : std.algorithm.minElement(lst[indexes]);\n        result[i / 2] = min_or_max.front;\n\
    \        indexes.remove(min_or_max.back);\n    }\n    return result;\n}", "{\n\
    \    if (lst.length & 1) \n    {\n        lst = lst.dup;\n        auto min = min(lst);\n\
    \        lst = lst.filter!(i => i != min);\n    }\n    auto it = new Tuple!(long,\
    \ long)(1, lst.length - 1);\n    long[] out = new long[lst.length];\n    foreach\
    \ (i; 0 .. out.length) \n    {\n        if (i & 1) \n        {\n            out[i]\
    \ = lst[it[0]];\n            it[0] += 2;\n        }\n        else \n        {\n\
    \            out[i] = lst[it[1]];\n            it[1] -= 2;\n        }\n    }\n\
    \    return out;\n}", "{\n    long[] result = new long[];\n    while(lst.length)\
    \ \n    {\n        immutable min = lst[0];\n        immutable max = lst[0];\n\
    \        foreach(immutable el; lst) \n        {\n            min = min(min, el);\n\
    \            max = max(max, el);\n        }\n        result ~= min;\n        lst\
    \ = lst.dup.remove(min);\n        if(lst.length) \n        {\n            result\
    \ ~= max;\n            lst = lst.dup.remove(max);\n        }\n    }\n    return\
    \ result;\n}\n/*\n    Given arrays of integers, return array in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.", "{\n    auto l = lst.array();\n\
    \    auto sort = l.sort();\n    long[] result = new long[lst.length];\n    result[0]\
    \ = sort[0];\n    if (lst.length <= 1) return result;\n    result[lst.length -\
    \ 1] = sort[lst.length - 1];\n    size_t j = 1;\n    size_t k = lst.length - 2;\n\
    \    for (size_t i = 1; i < lst.length - 1; i++)\n    {\n        if (i % 2 ==\
    \ 1)\n        {\n            result[j] = sort[i];\n            j++;\n        }\n\
    \        else\n        {\n            result[k] = sort[i];\n            k--;\n\
    \        }\n    }\n    return result;\n}", "{\n    auto isOdd = (lst.length %\
    \ 2) == 1;\n    auto isEven = !isOdd;\n    auto lst2 = lst.sort;\n    auto lst3\
    \ = lst2.dup;\n    long[] result;\n    if (isOdd)\n    {\n        result = lst3.init;\n\
    \    }\n    else\n    {\n        result = lst3;\n    }\n    int i = 0;\n    int\
    \ j = lst2.length - 1;\n    while (j >= 0)\n    {\n        if (i % 2 == 0)\n \
    \       {\n            result[i] = lst2[i / 2];\n        }\n        else\n   \
    \     {\n            result[i] = lst2[j];\n            j--;\n        }\n     \
    \   i++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n      \
    \  return lst;\n    \n    long[] res = new long[lst.length];\n    int k = 0;\n\
    \    int k_steps = (int)divCeil(lst.length, 2L);\n    int cmp = -1;\n    int len\
    \ = lst.length;\n    bool is_first = true;\n    long max_num = long.min;\n   \
    \ bool[] used = new bool[lst.length];\n    for (int i = 0; i < lst.length; i++)\
    \ \n    {\n        int min_idx = -1;\n        for (int j = 0; j < lst.length;\
    \ j++) \n        {\n            if (!used[j]) \n            {\n              \
    \  if (is_first)\n                    max_num = max(max_num, lst[j]);\n      \
    \          if (min_idx == -1 || lst[j] * cmp < lst[min_idx] * cmp)\n         \
    \           min_idx = j;\n            }\n        }\n        used[min_idx] = true;\n\
    \        res[k] = lst[min_idx];\n        k += k_steps;\n        if (k >= len)\
    \ \n        {\n            k = 1;\n            k_steps = (int)divCeil(len - 1,\
    \ 2L);\n            is_first = false;\n            cmp *= -1;\n        }\n   \
    \ }\n    return res;\n}", "{\n    int n = lst.length;\n    bool[] visited = new\
    \ bool[n];\n    visited[] = false;\n    long[] res = new long[n];\n    if (n ==\
    \ 0) return res;\n    res[0] = min(lst);\n    long cur = max(lst);\n    int idx\
    \ = 1;\n    int cur_idx = 0;\n    while (idx < n) {\n        int cur_idx = lst.countUntil((x)\
    \ => x == cur);\n        if (visited[cur_idx]) break;\n        visited[cur_idx]\
    \ = true;\n        res[idx] = cur;\n        cur = max(lst);\n        idx += 1;\n\
    \    }\n    return res;\n}\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", "{\n    auto comparer = (Tuple!(long,\
    \ int, bool) a, Tuple!(long, int, bool) b)\n    {\n        return a[0] < b[0];\n\
    \    };\n    SortedRange!(comparer) sorted_lst;\n    long[] res = new long[lst.length];\n\
    \    foreach(i, v; lst)\n    {\n        sorted_lst.insert(tuple(v, i, true));\n\
    \    }\n    for(int i = 0; i < sorted_lst.length; i += 2)\n    {\n        res[sorted_lst[i][1]]\
    \ = sorted_lst[i][0];\n    }\n    for(int i = sorted_lst.length - 1; i >= 0; i\
    \ -= 2)\n    {\n        res[sorted_lst[i][1]] = sorted_lst[i][0];\n    }\n   \
    \ return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    else\n\
    \    {\n        long min = min(lst);\n        long max = max(lst);\n        long[]\
    \ lst2 = lst[0..$-1];\n        long[] lst3 = lst[1..$];\n        long[] lst4 =\
    \ merge(lst2, lst3);\n        lst = [min];\n        bool odd = true;\n       \
    \ foreach (i; lst4)\n        {\n            if (odd)\n                lst ~= max(lst4);\n\
    \            else\n                lst ~= min(lst4);\n            odd = !odd;\n\
    \        }\n        return lst;\n    }\n}", "{\n    long[] res = new long[lst.length];\n\
    \    size_t curr = 0;\n    while (lst.length > 0) {\n        long min = min_element(lst);\n\
    \        lst = remove_if!(a => a == min)(lst);\n        res[curr] = min;\n   \
    \     ++curr;\n        if (lst.length > 0) {\n            long max = max_element(lst);\n\
    \            lst = remove_if!(a => a == max)(lst);\n            res[curr] = max;\n\
    \            ++curr;\n        }\n    }\n    return res;\n}", "{\n    struct Pair(T)\
    \ {\n        T min;\n        T max;\n    }\n    long[] res;\n    size_t i = 0;\n\
    \    while (i<lst.length)\n    {\n        Pair!(long) pair = Pair!(long)();\n\
    \        pair.min = min(lst[i]);\n        pair.max = max(lst[i]);\n        res\
    \ ~= pair.min;\n        res ~= pair.max;\n        ++i;\n    }\n    return res;\n\
    }", "{\n    bool is_even = true;\n    long[] result = new long[lst.length];\n\
    \    // .dup duplicates an array\n    long[] lst2 = lst.dup;\n    for (size_t\
    \ i = 0; i < lst.length; i++)\n    {\n        size_t min_index = minIndex(lst2);\n\
    \        size_t max_index = maxIndex(lst2);\n        if (is_even)\n        {\n\
    \            result[i] = lst2[min_index];\n            lst2 = lst2[min_index..$].dup;\n\
    \        }\n        else\n        {\n            result[i] = lst2[max_index];\n\
    \            lst2 = lst2[max_index..$].dup;\n        }\n        is_even = !is_even;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    else \n    {\n        long[] res = new long[lst.length];\n        auto t\
    \ = tuple(lst[$-1], lst[0]);\n        auto min_max = minmax(t);\n        res[0]\
    \ = min_max[0];\n        res[$-1] = min_max[1];\n        auto lst2 = lst[1..$-1];\n\
    \        int i = 1;\n        foreach (el; lst2) \n        {\n            if (i\
    \ % 2 == 0)\n                res[i] = lst2[0];\n            else\n           \
    \     res[i] = lst2[$-1];\n            i += 1;\n        }\n        return res;\n\
    \    }\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] ret\
    \ = new long[lst.length];\n    size_t i = 0;\n    int inc = 1;\n    while(true)\n\
    \    {\n        int min = min(lst).indices.front;\n        int max = max(lst).indices.front;\n\
    \        if(i == lst.length)\n            break;\n        ret[i] = lst[min];\n\
    \        ret[i+1] = lst[max];\n        lst[min] = long.max;\n        lst[max]\
    \ = long.min;\n        i += 2;\n    }\n    return ret;\n}", "{\n    // TODO: add\
    \ implementation here\n    return lst;\n}\n// Start tests\npublic static void\
    \ main(string[] args) \n{\n    var testCases = new long[][] \n    {\n        new\
    \ long[] {1L, 2L, 3L, 4L},\n        new long[] {5L, 5L, 5L, 5L},\n        new\
    \ long[] {},\n    };\n    var expectedResults = new long[][] \n    {\n       \
    \ new long[] {1L, 4L, 2L, 3L},\n        new long[] {5L, 5L, 5L, 5L},\n       \
    \ new long[] {},\n    };\n    var idx = 0;\n    foreach (var tc in testCases)\
    \ \n    {\n        var res = strange_sort_list(tc);\n        if (res != expectedResults[idx])\
    \ \n        {\n            throw new Exception(\"Error: \" + res);\n        }\n\
    \        idx++;\n    }\n}\n// End tests", "{\n    enum flag = true;\n    long[]\
    \ result = new long[lst.length];\n    int index = 0;\n    size_t min_index;\n\
    \    while (flag) \n    {\n        min_index = min_element(lst);\n        if (min_index\
    \ == -1) flag = false;\n        else \n        {\n            result[index] =\
    \ lst[min_index];\n            lst[min_index] = -1;\n            index++;\n  \
    \      }\n    }\n    flag = true;\n    while (flag) \n    {\n        min_index\
    \ = max_element(lst);\n        if (min_index == -1) flag = false;\n        else\
    \ \n        {\n            result[index] = lst[min_index];\n            lst[min_index]\
    \ = -1;\n            index++;\n        }\n    }\n    return result;\n}", "{\n\
    \    struct elem\n    {\n        long value;\n        bool visited;\n        elem(long\
    \ x) {\n            value = x;\n            visited = false;\n        }\n    }\n\
    \    static auto get_visited(elem[] elems)\n    {\n        long[] res;\n     \
    \   foreach(e; elems)\n        {\n            if(e.visited)\n                res\
    \ ~= e.value;\n        }\n        return res;\n    }\n    static auto get_unvisited(elem[]\
    \ elems)\n    {\n        long[] res;\n        foreach(e; elems)\n        {\n \
    \           if(!e.visited)\n                res ~= e.value;\n        }\n     \
    \   return res;\n    }\n    static auto strange_sort(elem[] elems)\n    {\n  \
    \      if(elems.length == 0)\n            return [];\n        long min = min(get_unvisited(elems));\n\
    \        long max = max(get_unvisited(elems));\n        long[] res;\n        res\
    \ ~= min;\n        res ~= max;\n        res ~= strange_sort(get_unvisited(elems)).array;\n\
    \        return res;\n    }\n    long[] res;\n    foreach(x; lst)\n    {\n   \
    \     res ~= elem(x);\n    }\n    return strange_sort(res).array;\n}", "{\n  \
    \  if (lst.length == 0)\n        return [];\n    alias LList = Tuple!(long, LList);\n\
    \    LList tl = tuple(lst[0], LList.init);\n    for (size_t i = 1; i < lst.length;\
    \ i++)\n    {\n        if (tl[0] > lst[i])\n            tl = tuple(lst[i], tl);\n\
    \        else\n            tl[1] ~= tuple(lst[i], LList.init);\n    }\n    LList\
    \ res = LList.init;\n    while (tl.length != 0)\n    {\n        if (tl[0] < tl[1][0])\n\
    \        {\n            res ~= tuple(tl[0], LList.init);\n            tl = tl[1];\n\
    \        }\n        else\n        {\n            res ~= tuple(tl[1][0], LList.init);\n\
    \            tl[1] = tl[1][1];\n        }\n    }\n    long[] res_ = new long[res.length];\n\
    \    for (size_t i = 0; i < res.length; i++)\n        res_[i] = res[i][0];\n \
    \   return res_;\n}", "{\n    if (lst.length == 0)\n        return [];\n    lst.sort();\n\
    \    auto max = lst.length - 1;\n    auto min = 0;\n    long[] result = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++) \n    {\n        if (i % 2 == 0) \n\
    \        {\n            result[i] = lst[min];\n            min++;\n        }\n\
    \        else \n        {\n            result[i] = lst[max];\n            max--;\n\
    \        }\n    }\n    return result;\n}", "{\n\tif (lst.length==0)\n\t\treturn\
    \ lst;\n\t\n\tlong[] result = new long[lst.length];\n\tTuple!(long, long, ubyte)[]\
    \ tuples = new Tuple!(long, long, ubyte)[lst.length];\n\tfor (size_t i=0; i<lst.length;\
    \ i++)\n\t{\n\t\ttuples[i] = tuple(lst[i], lst[i], 0u);\n\t}\n\t\n\t// sort by\
    \ first value (original array)\n\tstd.algorithm.sort!(\"a[0] < b[0]\")(tuples);\n\
    \t\n\t// fill array with minimum values\n\tfor (size_t i=0; i<lst.length; i+=2)\n\
    \t{\n\t\ttuples[i].tupleof[2] = 1u;\n\t\tresult[i] = tuples[i].tupleof[0];\n\t\
    }\n\t\n\t// fill array with maximum values\n\tfor (size_t i=1; i<lst.length; i+=2)\n\
    \t{\n\t\ttuples[i].tupleof[2] = 1u;\n\t\tresult[i] = tuples[i].tupleof[1];\n\t\
    }\n\t\n\t//sort by second value (remaining array)\n\tstd.algorithm.sort!(\"a[1]\
    \ < b[1]\")(tuples);\n\t\n\tint k=0;\n\tfor (size_t i=0; i<lst.length; i++)\n\t\
    {\n\t\tif (tuples[i].tupleof[2]==0u)\n\t\t{\n\t\t\tresult[k] = tuples[i].tupleof[0];\n\
    \t\t\tk++;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    auto length = lst.length;\n\
    \    bool toggle = true;\n    auto res = length.iota\n                .map!((i)\
    \ => lst[i])\n                .array;\n    while(res.length > 1)\n    {\n    \
    \    if(toggle)\n        {\n            res.remove(res.min);\n        }\n    \
    \    else\n        {\n            res.remove(res.max);\n        }\n        toggle\
    \ = !toggle;\n    }\n    return lst;\n}", "{\n    long[] result;\n    if (lst.length\
    \ == 0) \n    {\n        return result;\n    }\n    auto _lst = lst.dup;\n   \
    \ auto min_element = _lst[0];\n    auto min_index = 0;\n    foreach (index, value;\
    \ _lst) \n    {\n        if (value < min_element) \n        {\n            min_element\
    \ = value;\n            min_index = index;\n        }\n    }\n    auto first_element\
    \ = min_element;\n    result ~= first_element;\n    _lst.remove(min_index);\n\
    \    auto sort_lst = result.dup;\n    foreach (i; 0 .. _lst.length) \n    {\n\
    \        auto sub_lst = _lst.dup;\n        auto max_element = sub_lst[0];\n  \
    \      auto max_index = 0;\n        foreach (index, value; sub_lst) \n       \
    \ {\n            if (value > max_element) \n            {\n                max_element\
    \ = value;\n                max_index = index;\n            }\n        }\n   \
    \     sort_lst ~= max_element;\n        sub_lst.remove(max_index);\n        auto\
    \ min_element = sub_lst[0];\n        auto min_index = 0;\n        foreach (index,\
    \ value; sub_lst) \n        {\n            if (value < min_element) \n       \
    \     {\n                min_element = value;\n                min_index = index;\n\
    \            }\n        }\n        sort_lst ~= min_element;\n        sub_lst.remove(min_index);\n\
    \        _lst = sub_lst.dup;\n    }\n    return sort_lst;\n}", "{\n    // your\
    \ code here\n    if(lst.length == 0)\n        return lst;\n    lst.sort();\n \
    \   lst = lst.dup;\n    long[] result = new long[lst.length];\n    if(lst.length\
    \ == 1)\n        return lst;\n    else if(lst.length == 2)\n    {\n        result[0]\
    \ = lst[0];\n        result[1] = lst[1];\n        return result;\n    }\n    else\n\
    \    {\n        ulong j = 0;\n        ulong i = 0;\n        while(i < lst.length)\n\
    \        {\n            if(j < lst.length)\n            {\n                result[i]\
    \ = lst[j];\n                j += 2;\n                i++;\n            }\n  \
    \          else\n            {\n                j = 1;\n            }\n      \
    \  }\n        return result;\n    }\n}", "{\n    if (empty(lst)) return lst;\n\
    \    lst.sort();\n    auto minv = lst[0];\n    auto maxv = lst[$ - 1];\n    auto\
    \ newlst = [minv];\n    auto l = lst[1 .. $ - 1];\n    //long[] l = [i for i in\
    \ lst[1 .. $ - 1]];\n    while (!empty(l)) \n    {\n        newlst ~= l[$ - 1];\n\
    \        l = l[0 .. $ - 2];\n        if (empty(l)) break;\n        newlst ~= l[0];\n\
    \        l = l[1 .. $];\n    }\n    if (minv != maxv) \n    {\n        newlst\
    \ ~= maxv;\n    }\n    return newlst;\n}", "{\n    if (lst.length <= 1)\n    \
    \    return lst;\n    \n    long[] res = new long[lst.length];\n    auto n = lst.length;\n\
    \    long min = 0, max = n - 1;\n    bool min_first = true;\n    foreach (i; 0\
    \ .. n)\n    {\n        auto index = min_first ? min : max;\n        res[i] =\
    \ lst[index];\n        if (min_first)\n            min++;\n        else\n    \
    \        max--;\n        min_first = !min_first;\n    }\n    return res;\n}\n\
    /*\n    This function takes an array of integers and modifies it so that\n   \
    \ all values are distinct by increasing the values with the same amount.\n   \
    \ \n    Example:\n    >>> make_distinct([0L, 1L, 2L, 2L, 3L, 4L, 4L, 5L, 6L])\n\
    \    [0L, 1L, 2L, 4L, 3L, 4L, 6L, 5L, 6L]\n    >>> make_distinct([1L, 1L, 1L,\
    \ 1L, 1L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> make_distinct([1L, 2L, 3L, 4L, 5L])\n\
    \    [1L, 2L, 3L, 4L, 5L]\n    >>> make_distinct([])\n    []\n*/\nlong[] make_distinct(long[]\
    \ array) \n{\n    if (array.length <= 1)\n        return array;\n    \n    long[]\
    \ res = new long[array.length];\n    res[0] = array[0];\n    long index = 1, count\
    \ = 0;\n    foreach (i; 1 .. array.length)\n    {\n        if (array[i] == array[i\
    \ - 1])\n            count++;\n        else\n            count = 0;\n        res[index]\
    \ = array[i] + count;\n        index++;\n    }\n    return res;\n}\n/*\n    This\
    \ function takes 2 arrays and returns true if the second array\n    can be obtained\
    \ from the first one by deleting", "{\n    if (lst.length == 0) \n    {\n    \
    \    return lst;\n    }\n    long min = min(lst);\n    long max = max(lst);\n\
    \    long[] small = lst.filter!(a => a < max)();\n    long[] big = lst.filter!(a\
    \ => a > min)();\n    lst = new long[$];\n    bool flag = true;\n    foreach (i;\
    \ 0 .. lst.length / 2) \n    {\n        if (flag) \n        {\n            lst\
    \ ~= min;\n            lst ~= max;\n        } \n        else \n        {\n   \
    \         lst ~= max;\n            lst ~= min;\n        }\n        flag = !flag;\n\
    \    }\n    if (small.length == 0) \n    {\n        return lst;\n    }\n    if\
    \ (big.length == 0) \n    {\n        return lst;\n    }\n    return lst.zip(strange_sort_list(small)\
    \ ~ strange_sort_list(big)).map!((k,v) => v).array();\n}", "{\n\tauto res = new\
    \ long[](0);\n\tif(lst.length == 0) \n\t\treturn res;\n\telse \n\t{\n\t\tauto\
    \ first_half = new long[](lst.length / 2);\n\t\tauto second_half = new long[](lst.length\
    \ / 2);\n\t\tif(lst.length % 2 == 0) \n\t\t{\n\t\t\tforeach(i, x; lst) \n\t\t\t\
    {\n\t\t\t\tif(i % 2 == 0)\n\t\t\t\t\tfirst_half ~= x;\n\t\t\t\telse\n\t\t\t\t\t\
    second_half ~= x;\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tforeach(i, x; lst)\
    \ \n\t\t\t{\n\t\t\t\tif(i % 2 == 0)\n\t\t\t\t\tfirst_half ~= x;\n\t\t\t\telse\n\
    \t\t\t\t\tsecond_half ~= x;\n\t\t\t}\n\t\t\tfirst_half ~= lst[lst.length - 1];\n\
    \t\t}\n\t\t\n\t\tsecond_half = second_half.sort!((a, b) => b - a)();\n\t\tfirst_half\
    \ = first_half.sort!((a, b) => a - b)();\n\t\t\n\t\tif(lst.length % 2 == 0) \n\
    \t\t{\n\t\t\tfor(int i = 0; i < first_half.length; i++) \n\t\t\t{\n\t\t\t\tres\
    \ ~= first_half[i];\n\t\t\t\tres ~= second_half[i];\n\t\t\t}\n\t\t}\n\t\telse\
    \ \n\t\t{\n\t\t\tfor(int i = 0; i < first_half.length - 1; i++) \n\t\t\t{\n\t\t\
    \t\tres ~= first_half[i];\n\t\t\t\tres ~= second_half[i];\n\t\t\t}\n\t\t\tres\
    \ ~= first_half[first_half.length - 1];\n\t\t}\n\t\treturn res;\n\t}\n", "{\n\
    \    auto zipped = zip(lst, iota(lst.length));\n    auto sorted = sort(zipped,\
    \ (a, b) => std.cmp(a[0], b[0]));\n    auto result = map!(x => x[0])(sorted);\n\
    \    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n \
    \   long[] res = new long[lst.length];\n    long[] lst_1 = new long[lst.length];\n\
    \    foreach (ix, e; lst)\n        lst_1[ix] = e;\n    auto lst_max = max(lst_1);\n\
    \    auto lst_min = min(lst_1);\n    foreach (ix, e; lst)\n    {\n        if (ix\
    \ % 2 == 0)\n        {\n            res[ix] = lst_min;\n            lst_1 = remove(lst_1,\
    \ lst_min);\n            lst_min = min(lst_1);\n        }\n        else\n    \
    \    {\n            res[ix] = lst_max;\n            lst_1 = remove(lst_1, lst_max);\n\
    \            lst_max = max(lst_1);\n        }\n    }\n    return res;\n}\n ",
  "{\n    long[] sorted = lst.dup;\n    sorted.sort;\n    long[] output = new long[];\n\
    \    for (int i = 0; i < cast(int)sorted.length; i++) \n    {\n        int bottom\
    \ = i*2;\n        int top = sorted.length - (i+1)*2;\n        if (bottom < sorted.length)\
    \ \n        {\n            output ~= sorted[bottom];\n        }\n        if (top\
    \ >= 0) \n        {\n            output ~= sorted[top];\n        }\n    }\n  \
    \  return output;\n}\n ", "{\n    // Initialize accumulator list\n    long[] acc\
    \ = [];\n    // Iterate over length/2 (rounded down)\n    foreach (i; 0 .. (lst.length/2).floor)\
    \ \n    {\n        // Append minimum to accumulator list\n        acc ~= lst.min;\n\
    \        // Remove minimum from list\n        lst = lst.removeAll(lst.min);\n\
    \        // Append maximum to accumulator list\n        acc ~= lst.max;\n    \
    \    // Remove maximum from list\n        lst = lst.removeAll(lst.max);\n    }\n\
    \    // Append remaining item in lst to accumulator\n    acc ~= lst;\n    // Return\
    \ accumulator\n    return acc;\n}", "{\n    // for quick and dirty tests\n   \
    \ assert(1L == 1L);\n    assert(2L == 2L);\n    assert(3L == 3L);\n    assert(4L\
    \ == 4L);\n    assert(5L == 5L);\n    assert(6L == 6L);\n    assert(7L == 7L);\n\
    \    assert(8L == 8L);\n    assert(9L == 9L);\n    assert(10L == 10L);\n    assert(11L\
    \ == 11L);\n    assert(12L == 12L);\n    assert(13L == 13L);\n    assert(14L ==\
    \ 14L);\n    assert(15L == 15L);\n    assert(16L == 16L);\n    assert(17L == 17L);\n\
    \    assert(18L == 18L);\n    assert(19L == 19L);\n    assert(20L == 20L);\n \
    \   assert(21L == 21L);\n    assert(22L == 22L);\n    assert(23L == 23L);\n  \
    \  assert(24L == 24L);\n    assert(25L == 25L);\n    assert(26L == 26L);\n   \
    \ assert(27L == 27L);\n    assert(28L == 28L);\n    assert(29L == 29L);\n    assert(30L\
    \ == 30L);\n    assert(31L == 31L);\n    assert(32L == 32L);\n    assert(33L ==\
    \ 33L);\n    assert(34L == 34L);\n    assert(35L == 35L);\n    assert(36L == 36L);\n\
    \    assert(37L == 37L);\n    assert(38L == 38L);\n    assert(39L == 39L);\n \
    \   assert(40L == 40L);\n    assert(41L == 41L);\n    assert(42L == 42L);\n  \
    \  assert(43L == 43L);\n    assert(44L == 44L);\n    assert(45L == 45L);\n   \
    \ assert(46L == 46L);\n    assert(47L == 47L);\n    assert(48L == 48L);\n    assert(49L\
    \ == 49L);\n    assert(50L == 50L);\n   ", "{\n    // Write your code here\n \
    \   auto res = new long[](lst.length);\n    if (lst.length == 0) \n        return\
    \ res;\n    int i = 0;\n    int j = lst.length-1;\n    int k = 0;\n    while (k\
    \ < lst.length) \n    {\n        res[k++] = lst[i++];\n        if (k < lst.length)\n\
    \            res[k++] = lst[j--];\n    }\n    return res;\n}", "{\n    auto list_of_tuples\
    \ = zip(lst, iota(0L, lst.length));\n    // sort by descending for max and ascending\
    \ for min\n    list_of_tuples.sort!((a, b) => a[0] > b[0] ? -1 : a[0] < b[0] ?\
    \ 1 : 0);\n    list_of_tuples.sort!((a, b) => a[1] > b[1] ? 1 : a[1] < b[1] ?\
    \ -1 : 0);\n    return list_of_tuples.map!(a => a[0]).array;\n}", "{\n  if (lst.length\
    \ == 0)\n  {\n    return lst;\n  }\n  if (lst.length == 1)\n  {\n    return lst;\n\
    \  }\n  int n = lst.length;\n  long[] r = new long[n];\n  long[] s = new long[n];\n\
    \  int i = 0;\n  long min_val = min(lst);\n  long max_val = max(lst);\n  long\
    \ cur_val = min_val;\n  while (i < n)\n  {\n    r[i] = cur_val;\n    i++;\n  \
    \  cur_val = (i % 2 == 0) ? min_val : max_val;\n  }\n  i = 0;\n  foreach (long\
    \ l; lst)\n  {\n    if (l == min_val)\n    {\n      s[i] = l;\n      i++;\n  \
    \  }\n  }\n  foreach (long l; lst)\n  {\n    if (l == max_val)\n    {\n      s[i]\
    \ = l;\n      i++;\n    }\n  }\n  return r;\n}", "{\n    if (lst.length == 0)\
    \ \n    {\n        return lst;\n    }\n    else \n    {\n        long min = min_element(lst);\n\
    \        long max = max_element(lst);\n        long[] result = new long[lst.length];\n\
    \        bool min_or_max = true;\n        int odd_even = 0;\n        int result_index\
    \ = 0;\n        while (odd_even != lst.length) \n        {\n            if (min_or_max)\
    \ \n            {\n                result[result_index] = min;\n             \
    \   min_or_max = false;\n            }\n            else \n            {\n   \
    \             result[result_index] = max;\n                min_or_max = true;\n\
    \            }\n            result_index += 1;\n            odd_even += 1;\n \
    \       }\n        return result;\n    }\n}", "{\n    int i, len;\n    long[]\
    \ lst_end, res;\n    bool f;\n    // test\n    len = lst.length;\n    if (len\
    \ == 0) return lst;\n    //\n    f = true;\n    lst_end = new long[len];\n   \
    \ res = new long[len];\n    for (i = 0; i < len; i++) {\n        lst_end[i] =\
    \ lst[i];\n    }\n    for (i = 0; i < len; i++) {\n        if (f) {\n        \
    \    res[i] = lst_end[0];\n            lst_end = removeAt(lst_end, 0);\n     \
    \   } else {\n            res[i] = lst_end[lst_end.length - 1];\n            lst_end\
    \ = removeAt(lst_end, lst_end.length - 1);\n        }\n        f = !f;\n    }\n\
    \    return res;\n}", "{\n    int ln = lst.length;\n    if (ln < 2) \n       \
    \ return lst;\n    long tmp;\n    long[] lst1 = lst[$-1 .. $];\n    int ln1 =\
    \ lst1.length;\n    if (ln1 == 0) \n        return lst;\n    for (int i = 0; i\
    \ < ln1; i++) \n    {\n        if (i % 2 == 0) \n        {\n            tmp =\
    \ lst1[0];\n            lst1 = lst1[1 .. $];\n            lst1 ~= tmp;\n     \
    \   } \n        else \n        {\n            tmp = lst1[$-1];\n            lst1\
    \ = lst1[0 .. $-1];\n            lst1 = [tmp] ~ lst1;\n        }\n    }\n    return\
    \ lst1;\n}", "{\n    long[] result = [];\n    bool reverse = false;\n    result\
    \ ~= lst[0];\n    lst = lst[1..$];\n    while(lst.length != 0)\n    {\n      \
    \  if(reverse)\n        {\n            result ~= lst[0];\n            lst = lst[1..$];\n\
    \        }\n        else\n        {\n            result ~= lst[$-1];\n       \
    \     lst = lst[0..$-2];\n        }\n        reverse = !reverse;\n    }\n    return\
    \ result;\n}", "{\n\tint n = lst.length;\n\t\n\t// Removes duplicate elements\n\
    \tlst = lst.dup.sort().dedup;\n\t\n\t// We need the minimum and maximum values\n\
    \tlong min = lst[0];\n\tlong max = lst[$-1];\n\t\n\tint k = 0;\n\tauto res = new\
    \ long[n];\n\t\n\tif(n == 0) return res;\n\t\n\tint dir = 1; // 1 for ascending,\
    \ -1 for descending\n\tbool duplicate = n == 1;\n\t\n\twhile(true)\n\t{\n\t\t\
    if(k == n) break;\n\t\t\n\t\tif(duplicate) \n\t\t{\n\t\t\tres[k] = lst[0];\n\t\
    \t\tk++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Check if we have reached the minimum\
    \ or maximum\n\t\tif(lst[0] == min || lst[$-1] == max) \n\t\t{\n\t\t\t// The 'duplicate'\
    \ flag is set if there is only one element left\n\t\t\tif(lst.length == 1) duplicate\
    \ = true;\n\t\t\t\n\t\t\t// Changes direction\n\t\t\tdir *= -1;\n\t\t}\n\t\t\n\
    \t\t// Removes the minimum or maximum\n\t\tlst = lst[1..$-1];\n\t\t\n\t\t// Removes\
    \ the first or last element\n\t\tres[k] = dir == 1 ? lst[0] : lst[$-1];\n\t\t\
    k++;\n\t}\n\t\n\treturn res;\n}", "{\n    auto len = lst.length;\n    long[] ret\
    \ = new long[len];\n    if (len > 0) \n    {\n        int i = 0;\n        auto\
    \ it = lst.tupleof;\n        int2 dir = int2(1, -1);\n        bool asc = true;\n\
    \        while (i < len) \n        {\n            if (it.empty) \n           \
    \ {\n                asc = !asc;\n                it = lst.tupleof;\n        \
    \    }\n            else \n            {\n                ret[i] = it[asc ? 0\
    \ : $ - 1];\n                it = it[1 .. $ - 1];\n                i += dir[asc\
    \ ? 0 : 1];\n            }\n        }\n    }\n    return ret;\n}\n/*\n    int[]\
    \ strange_sort_list(int[] arr)\n    {\n        arr.sort();\n        bool asc =\
    \ true;\n        int mid_idx = (arr.length - 1) / 2;\n        int i = 0;\n   \
    \     while (i < arr.length)\n        {\n            if (asc)\n            {\n\
    \                arr[i] = arr[mid_idx];\n                mid_idx++;\n        \
    \    }\n            else\n            {\n                arr[i] = arr[mid_idx];\n\
    \                mid_idx--;\n            }\n            i++;\n            asc\
    \ = !asc;\n        }\n        return arr;\n    }\n*/\nauto strange_sort_list2(T)(T[]\
    \ lst) if (isArray!T) \n{\n    return lst.sort(true).array;\n}", "{ \n    if (lst.length==0)\n\
    \        return [];\n    else if (lst.length==1)\n        return lst;\n    long[]\
    \ up = [];\n    long[] down = [];\n    long[] res = [];\n    long min_val = lst[0];\n\
    \    long min_idx = 0;\n    long max_val = lst[0];\n    long max_idx = 0;\n  \
    \  foreach(int i, long x; lst) {\n        if (x > max_val) {\n            max_val\
    \ = x;\n            max_idx = i;\n        }\n        if (x < min_val) {\n    \
    \        min_val = x;\n            min_idx = i;\n        }\n    }\n    //writefln(\"\
    max_val=%s max_idx=%s min_val=%s min_idx=%s\",max_val,max_idx,min_val,min_idx);\n\
    \    if (min_idx > max_idx) {\n        res ~= min_val;\n        up = lst[0..min_idx];\n\
    \        down = lst[min_idx+1..$];\n    } else {\n        res ~= max_val;\n  \
    \      up = lst[0..max_idx];\n        down = lst[max_idx+1..$];\n    }\n    return\
    \ res ~ strange_sort_list(up) ~ strange_sort_list(down);\n}", "{\n  if (lst.length\
    \ == 0)\n    return lst;\n  long[] rlst = lst.dup;\n  auto rIter = rlst.randomAccess.front;\n\
    \  auto lIter = lst.front;\n  auto lIterEnd = lst.back;\n  rIter.put((lIter++).front);\n\
    \  lIterEnd.popFront;\n  rIter.put((lIterEnd--).front);\n  while (lIter <= lIterEnd)\n\
    \  {\n    rIter.put((lIter++).front);\n    rIter.put((lIterEnd--).front);\n  }\n\
    \  return rlst;\n}", "{\n    long[] res = [];\n    long[] tmplst = lst.dup;\n\
    \    size_t n = tmplst.length;\n    while (n != 0){\n        long min = minElement(tmplst);\n\
    \        long max = maxElement(tmplst);\n        n -= 2;\n        res ~= min;\n\
    \        tmplst = tmplst.filter!(i => i != min);\n        if (n < 0) break;\n\
    \        res ~= max;\n        tmplst = tmplst.filter!(i => i != max);\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return [];\n    bool[]\
    \ used = new bool[lst.length];\n    long[] result = new long[lst.length];\n  \
    \  result[0] = min(lst);\n    used[lst.indexOf(result[0])] = true;\n    long[]\
    \ remaining = lst[0..$ - 1];\n    foreach (idx; 1..lst.length) \n    {\n     \
    \   if (idx % 2 == 0)\n            result[idx] = min(remaining);\n        else\n\
    \            result[idx] = max(remaining);\n        used[lst.indexOf(result[idx])]\
    \ = true;\n        remaining = remaining[0..$ - 1];\n    }\n    return result;\n\
    }\n/*\n    Given strings s1 and s2, return the lexicographically smallest\n  \
    \  string obtained by placing the characters of s2 between the\n    characters\
    \ of s1.", "{\n    if (lst.length == 0)\n        return lst;\n    \n    lst.sort;\n\
    \    auto sz = cast(int) lst.length;\n    long[] rlst = lst[0 .. sz / 2];\n  \
    \  foreach (i; (sz / 2 .. sz).step(2))\n        rlst ~= lst[i];\n    foreach (i;\
    \ (sz / 2 - 1 .. 0).step(-2))\n        rlst ~= lst[i];\n    return rlst;\n}",
  "{\n    if (lst.length == 0) return lst;\n    bool addMin = true;\n    long[] res\
    \ = new long[lst.length];\n    auto lst2 = lst.dup;\n    lst2.sort;\n    lst2.reverse;\n\
    \    lst.sort;\n    foreach (index,item; lst) \n    {\n        if (addMin) \n\
    \        {\n            res[index] = item;\n            addMin = false;\n    \
    \    }\n        else \n        {\n            res[index] = lst2[0];\n        \
    \    lst2 = lst2[1..$];\n            addMin = true;\n        }\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length <= 1) \n    {\n        return lst;\n    }\n\
    \    else \n    {\n        long[] sorted_array = sort(lst);\n        int array_length\
    \ = sorted_array.length;\n        long[] min_array = new long[array_length / 2];\n\
    \        long[] max_array = new long[(array_length + 1) / 2];\n        min_array\
    \ = sorted_array[0 .. (array_length / 2)];\n        max_array = sorted_array[(array_length\
    \ / 2) .. $];\n        Tuple!(long[], long[]) t = tuple(max_array, min_array);\n\
    \        return flatten(reverse(t));\n    }\n}\n ", "{\n    const int min = 0;\n\
    \    const int max = 1;\n    const int size = lst.length;\n    long[] strange_lst\
    \ = new long[size];\n    auto index = 0;\n    auto index_list = new int[size];\n\
    \    auto to_sort = lst.dup;\n    auto index_type = min;\n    while (to_sort.length\
    \ != 0)\n    {\n        auto maximum = max(to_sort);\n        auto maximum_index\
    \ = 0;\n        foreach (index, el; to_sort)\n        {\n            if (el ==\
    \ maximum)\n            {\n                maximum_index = index;\n          \
    \      break;\n            }\n        }\n        auto minimum = min(to_sort);\n\
    \        auto minimum_index = 0;\n        foreach (index, el; to_sort)\n     \
    \   {\n            if (el == minimum)\n            {\n                minimum_index\
    \ = index;\n                break;\n            }\n        }\n        strange_lst[index]\
    \ = (index_type == min) ? minimum : maximum;\n        index_list[index] = (index_type\
    \ == min) ? minimum_index : maximum_index;\n        index_type = (index_type ==\
    \ min) ? max : min;\n        index++;\n        to_sort = delete(to_sort, (index_type\
    \ == min) ? minimum_index : maximum_index);\n    }\n    return strange_lst;\n}",
  "{\n\t\n\tlong[] r = new long[lst.length];\n\tint count = 0;\n\tauto t = tuple(lst);\n\
    \twhile(t[0].length > 0)\n\t{\n\t\tr[count] = t[0][0];\n\t\tcount++;\n\t\tt[0]\
    \ = t[0][1..$];\n\t\tt = t.rotateLeft;\n\t}\n\treturn r;\n}", "{\n    auto isEven\
    \ = (int n) { return n % 2 == 0; };\n    auto sorter = lst\n    .enumerate\n \
    \   .group\n    .sort\n    .enumerate\n    .sort((a, b) => isEven(a.index) ? (a.value[0]\
    \ > b.value[0]) : (a.value[0] < b.value[0]))\n    .map!(x => x.value[0])\n   \
    \ .array;\n    return sorter;\n}\n/*", "{\n    auto minmax = minmaxElement(lst);\n\
    \    bool isEven = true;\n    bool isMax = false;\n    bool isMin = false;\n \
    \   long[] result = new long[lst.length];\n    int i = 0;\n    foreach(el; lst)\n\
    \    {\n        if(el != *minmax.first && el != *minmax.second)\n        {\n \
    \           result[i] = el;\n            i++;\n        }\n    }\n    foreach(el;\
    \ lst)\n    {\n        if(isEven)\n        {\n            if(el == *minmax.first)\n\
    \            {\n                result[i] = el;\n                i++;\n      \
    \          isMin = true;\n            }\n            else if(el == *minmax.second)\n\
    \            {\n                isMax = true;\n            }\n        }\n    \
    \    else\n        {\n            if(el == *minmax.second && isMax)\n        \
    \    {\n                result[i] = el;\n                i++;\n              \
    \  isMax = false;\n            }\n            else if(el == *minmax.first && isMin)\n\
    \            {\n                result[i] = el;\n                i++;\n      \
    \          isMin = false;\n            }\n        }\n        isEven = !isEven;\n\
    \    }\n    return result;\n}", "{\n    long[] tmp;\n    auto i = 0;\n    auto\
    \ j = lst.length - 1;\n    auto k = 0;\n    long[] res;\n    res.length = lst.length;\n\
    \    while (i <= j) \n    {\n        tmp = lst[j..$];\n        res[k] = tmp[$-1];\n\
    \        k++;\n        if (i != j) \n        {\n            res[k] = tmp[0];\n\
    \            k++;\n        }\n        i++;\n        j--;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0) return lst;\n    bool isAsc = true;\n    long[]\
    \ tmp = lst.dup;\n    sort(tmp);\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    foreach(immutable elem; tmp)\n    {\n        if (isAsc)\n\
    \        {\n            result[i] = elem;\n            i += 2;\n        }\n  \
    \      else\n        {\n            result[i] = elem;\n            i -= 2;\n \
    \       }\n        if (i < 0)\n        {\n            i = 1;\n            isAsc\
    \ = true;\n        }\n        else if (i >= result.length)\n        {\n      \
    \      i = result.length - 2;\n            isAsc = false;\n        }\n    }\n\
    \    return result;\n}", "{\n    struct WeirdSorter {\n        size_t i;\n   \
    \     size_t last;\n        long[] lst;\n        size_t getIndex() {\n       \
    \     if (i > last)\n                return size_t.max;\n            if (i ==\
    \ last)\n                return i;\n            auto j = 2 * (i + 1) - 1;\n  \
    \          return j <= last ? j : last;\n        }\n        int opCmp(const WeirdSorter\
    \ rhs) const {\n            if (i == rhs.i)\n                return 0;\n     \
    \       if (i > rhs.i)\n                return 1;\n            return -1;\n  \
    \      }\n    }\n    if (lst.length == 0)\n        return lst;\n    auto s = WeirdSorter(0,\
    \ lst.length - 1, lst);\n    auto ws = new WeirdSorter[](lst.length);\n    auto\
    \ iter = ws.begin();\n    foreach (i; 0 .. ws.length) {\n        *iter = s;\n\
    \        s.i += 2;\n        iter++;\n    }\n    auto res = new long[](lst.length);\n\
    \    auto maxw = max(ws);\n    auto minw = min(ws);\n    foreach (i; 0 .. res.length)\
    \ {\n        auto w = i % 2 == 0 ? minw : maxw;\n        res[i] = lst[w.getIndex()];\n\
    \        if (w.getIndex() == w.last)\n            w.last--;\n        else\n  \
    \          w.i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\
    \ \n    {\n        return lst;\n    }\n    else \n    {\n        auto min = minElement(lst);\n\
    \        auto index_of_min = std.algorithm.find(lst, min);\n        auto lst_rest\
    \ = remove(lst, index_of_min);\n        auto new_lst = [min];\n        for (i\
    \ in 0..lst_rest.length/2) \n        {\n            auto max = maxElement(lst_rest);\n\
    \            auto index_of_max = std.algorithm.find(lst_rest, max);\n        \
    \    new_lst ~= max;\n            lst_rest = remove(lst_rest, index_of_max);\n\
    \            auto min = minElement(lst_rest);\n            auto index_of_min =\
    \ std.algorithm.find(lst_rest, min);\n            new_lst ~= min;\n          \
    \  lst_rest = remove(lst_rest, index_of_min);\n        }\n        if (lst_rest.length\
    \ == 1) \n        {\n            new_lst ~= lst_rest[0];\n        }\n        return\
    \ new_lst;\n    }\n}", "{\n    // if no elements in lst, return lst\n    if (lst.length\
    \ == 0) return lst;\n    // create empty list out of size lst.length and capacity\
    \ lst.length\n    auto sort_list = Tuple!(long[])([]);\n    // create an array\
    \ of bools for each element in lst\n    bool[] used = new bool[lst.length];\n\
    \    // true if element in lst is already in sort_list\n    // false if it is\
    \ not\n    // at first, all values in used are false\n    foreach (index, _; used)\
    \ \n    {\n        used[index] = false;\n    }\n    // fill sort_list with min\
    \ value from lst\n    // we know that there is at least one element in lst,\n\
    \    // so there will be also at least one element in sort_list\n    auto index_min\
    \ = lst.minIndex;\n    sort_list.front = lst[index_min];\n    used[index_min]\
    \ = true;\n    // starting from second element in sort_list\n    for (auto i =\
    \ 1; i < lst.length; i++) \n    {\n        auto min_value = lst.max;\n       \
    \ auto max_value = lst.min;\n        // position of min/max values in lst\n  \
    \      auto min_index = -1;\n        auto max_index = -1;\n        // for each\
    \ element in lst\n        foreach (i, element; lst) \n        {\n            //\
    \ if element already in sort_list, skip\n            if (used[i]) continue;\n\
    \            // if element smaller then min, make it min\n            if (element\
    \ < min_value) \n            {\n                min_value = element;\n       \
    \         min_index = i;\n            }\n            // if element greater then\
    \ max, make it max\n            if (element > max_value) \n            {\n   \
    \             max_value = element;\n                max_index = i;\n         \
    \   }\n        }\n        // if i is even, we need to add min value\n        if\
    \ (i % 2 == 0) \n        {\n            // if there is no more elements in lst,\
    \ add nothing", "{ \n    if (lst.length <= 2) \n        return lst; \n    long\
    \ mx = max(lst); \n    long mn = min(lst); \n    long[] res = new long[lst.length];\
    \ \n    int j = 0; \n    int k = lst.length-1; \n    for (int i = 0; i < lst.length;\
    \ i++) \n    { \n        if (i % 2 == 0) \n            res[i] = mn; \n       \
    \ else\n            res[i] = mx; \n        if (res[i] == lst[j]) \n          \
    \  j++; \n        else if (res[i] == lst[k]) \n            k--; \n    } \n   \
    \ return res; \n}", "{\n    int len = lst.length;\n    if (len == 0)\n       \
    \ return [];\n    auto res = new long[](len);\n    int a = 0;\n    int b = len\
    \ - 1;\n    int pos = 0;\n    bool is_a = true;\n    while (pos < len) \n    {\n\
    \        if (is_a) \n        {\n            res[pos] = lst[a];\n            a++;\n\
    \        }\n        else \n        {\n            res[pos] = lst[b];\n       \
    \     b--;\n        }\n        is_a = !is_a;\n        pos++;\n    }\n    return\
    \ res;\n}\n/*\n    Given a list of lists, return the sum of the lists that\n \
    \   have the same elements, but the elements are sorted in \n    different order.",
  "{\n    if (lst.length == 0)\n        return lst;\n    \n    lst.sort();\n    auto\
    \ res = new long[](lst.length);\n    size_t i = 0;\n    size_t j = lst.length\
    \ - 1;\n    while (i < lst.length/2) \n    {\n        res[i * 2] = lst[i];\n \
    \       res[i * 2 + 1] = lst[j];\n        i++;\n        j--;\n    }\n    if (lst.length\
    \ % 2 == 1)\n        res[lst.length - 1] = lst[lst.length / 2];\n    return res;\n\
    }", "{\n  if (lst.length == 0)\n    return lst;\n  auto tup = sort(lst);\n  int\
    \ middle = tup[0].length / 2;\n  long[] rez = new long[tup[0].length];\n  int\
    \ index = 0;\n  for (int i = 0; i < middle; i++)\n  {\n    rez[index] = tup[0][i];\n\
    \    index++;\n    rez[index] = tup[0][tup[0].length - i - 1];\n    index++;\n\
    \  }\n  if (tup[0].length % 2 != 0)\n    rez[index] = tup[0][middle];\n  return\
    \ rez;\n}", "{\n    long[] res = new long[lst.length];\n    // two pointers for\
    \ array\n    int l = 0;\n    int r = lst.length - 1;\n    // iterate up to half\
    \ of the array\n    for (int i = 0; i < (lst.length/2 + lst.length%2); i++)\n\
    \    {\n        // add maximum and minimum\n        res[2*i] = lst[l];\n     \
    \   res[2*i + 1] = lst[r];\n        // update points\n        l++;\n        r--;\n\
    \    }\n    return res;\n}", "{ \n    if (lst.length <= 1) return lst;", "{\n\
    \    long[] odd = new long[lst.length];\n    long[] even = new long[lst.length];\n\
    \    long[] result = new long[lst.length];\n    lst.sort();\n    int odd_counter\
    \ = 0;\n    int even_counter = 0;\n    foreach(num; lst)\n    {\n        if(num\
    \ % 2 == 0)\n        {\n            even[even_counter] = num;\n            even_counter++;\n\
    \        }\n        else\n        {\n            odd[odd_counter] = num;\n   \
    \         odd_counter++;\n        }\n    }\n    int odd_length = odd.length-1;\n\
    \    int even_length = even.length-1;\n    bool is_odd = true;\n    foreach(i;\
    \ 0..odd.length)\n    {\n        if(is_odd)\n        {\n            if(odd_length\
    \ == -1)\n            {\n                result[i] = even[even_length];\n    \
    \            even_length--;\n            }\n            else\n            {\n\
    \                result[i] = odd[odd_length];\n                odd_length--;\n\
    \            }\n        }\n        else\n        {\n            if(even_length\
    \ == -1)\n            {\n                result[i] = odd[odd_length];\n      \
    \          odd_length--;\n            }\n            else\n            {\n   \
    \             result[i] = even[even_length];\n                even_length--;\n\
    \            }\n        }\n        is_odd = !is_odd;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0) return [];\n    else \n    {\n        auto min\
    \ = min(lst);\n        long[] new_list = lst[min..$];\n        return [min, max(new_list)]\
    \ ~ strange_sort_list(new_list[0..max(new_list)]) ~ new_list[max(new_list)+1..$];\n\
    \    }\n}", "{\n    auto n = lst.length;\n    long[] res;\n    res.length = n;\n\
    \    auto indx = 0;\n    auto rep = sort(lst).length;\n    if (n == 0) \n    {\n\
    \        return res;\n    }\n    else \n    {\n        while (rep > 0) \n    \
    \    {\n            if (indx % 2 == 0) \n            {\n                res[indx]\
    \ = min(lst);\n                lst.remove(res[indx]);\n            }\n       \
    \     else \n            {\n                res[indx] = max(lst);\n          \
    \      lst.remove(res[indx]);\n            }\n            rep--;\n           \
    \ indx++;\n        }\n        return res;\n    }\n}\n/*", "{\n    if (lst.length\
    \ <= 1)\n        return lst;\n    auto t = zip(lst, iota(lst.length));\n    t.sort!(\"\
    a[0] < b[0]\");\n    auto smallest = t[0];\n    t.removeFront();\n    auto result\
    \ = [smallest[0]];\n    while (t.length > 0)\n    {\n        if (t.length == 1)\n\
    \        {\n            result ~= t[0][0];\n            t.removeFront();\n   \
    \     }\n        else\n        {\n            result ~= t[0][0];\n           \
    \ result ~= t[$-1][0];\n            t.removeFront();\n            t.removeBack();\n\
    \        }\n    }\n    return result;\n}\n \n/*", "{\n    int index = 0;\n   \
    \ long[] new_list = new long[lst.length];\n    long min_val = min(lst);\n    long\
    \ max_val = max(lst);\n    if (lst.length == 0)\n        return lst;\n    while\
    \ (index < lst.length) {\n        new_list[index] = min_val;\n        index++;\n\
    \        if (index < lst.length) {\n            new_list[index] = max_val;\n \
    \           index++;\n        }\n    }\n    return new_list;\n}", "{\n    long[]\
    \ sorted_list;\n    long min_elem;\n    min_elem = min(lst);\n    sorted_list\
    \ ~= min_elem;\n    auto b = lst.filter!(e => e != min_elem);\n    long[] lst2\
    \ = lst.filter!(e => e != min_elem);\n    lst = lst2;\n    int i = 0;\n    while(lst.length\
    \ != 0)\n    {\n        min_elem = min(lst);\n        sorted_list ~= min_elem;\n\
    \        lst = lst.filter!(e => e != min_elem);\n        long max_elem = max(lst);\n\
    \        sorted_list ~= max_elem;\n        lst = lst.filter!(e => e != max_elem);\n\
    \    }\n    return sorted_list;\n}\n ", "{\n  if (lst.length < 2) \n  {\n    return\
    \ lst;\n  }\n  bool[] marked = new bool[lst.length];\n  foreach (i; 0 .. lst.length)\
    \ \n  {\n    marked[i] = false;\n  }\n  auto max_it = maxElement(lst);\n  long\
    \ max_index = max_it[1];\n  long result_len = lst.length;\n  long[] result = new\
    \ long[result_len];\n  result[0] = lst[max_index];\n  marked[max_index] = true;\n\
    \  while (result_len > 1) \n  {\n    long min_index = lst.length - 1;\n    long\
    \ max_index = 0;\n    foreach (i; 0 .. lst.length) \n    {\n      if (!marked[i])\
    \ \n      {\n        if (lst[i] > lst[max_index]) \n        {\n          max_index\
    \ = i;\n        }\n        if (lst[i] < lst[min_index]) \n        {\n        \
    \  min_index = i;\n        }\n      }\n    }\n    result[result_len - 1] = lst[min_index];\n\
    \    marked[min_index] = true;\n    result[result_len - 2] = lst[max_index];\n\
    \    marked[max_index] = true;\n    result_len -= 2;\n  }\n  return result;\n\
    }\n/*", "{\n    auto s = lst.dup;\n    if (s.length <= 1) \n    {\n        return\
    \ s;\n    }\n    auto res = new long[](s.length);\n    immutable bool asc = false;\n\
    \    immutable bool inc = true;\n    immutable bool dec = false;\n    immutable\
    \ bool equal = true;\n    immutable bool not_equal = false;\n    immutable long\
    \ temp = 1;\n    immutable long k = 0;\n    immutable long min = s[0];\n    immutable\
    \ long max = s[0];\n    foreach (i; 1..s.length) \n    {\n        if (s[i] < min)\
    \ \n        {\n            min = s[i];\n        }\n        if (s[i] > max) \n\
    \        {\n            max = s[i];\n        }\n    }\n    if (s.length == 2)\
    \ \n    {\n        res[0] = min;\n        res[1] = max;\n        return res;\n\
    \    }\n    if (s.length == 3) \n    {\n        res[0] = min;\n        res[1]\
    \ = max;\n        res[2] = s[0] + s[1] + s[2] - res[0] - res[1];\n        return\
    \ res;\n    }\n    if (s.length % 2 == 0) \n    {\n        s.length -= 1;\n  \
    \  }\n    while (s.length > 1) \n    {\n        if (k % 2 == 0) \n        {\n\
    \            temp = s[0];\n            inc = true;\n            dec = false;\n\
    \            equal = true;\n            not_equal = false;\n            asc =\
    \ false;\n        }\n        else \n        {\n            temp = s[0];\n    \
    \        inc = false;\n            dec = true;\n            equal = true;\n  \
    \          not_equal = false;\n            asc = true;\n        }\n        for\
    \ (immutable long i = 1; i < s.length; i++) \n        {\n            if (dec)\
    \ \n            {\n                if (s[i] > temp) \n                {\n    \
    \                temp = s[i", "{\n    if (lst.length < 1)\n        return lst;\n\
    \    long[] ret = new long[lst.length];\n    lst.sort();\n    uint idx = 0;\n\
    \    while (idx < lst.length)\n    {\n        if (idx % 2 == 0)\n            ret[idx]\
    \ = lst[idx / 2];\n        else\n            ret[idx] = lst[lst.length - (idx\
    \ + 1) / 2];\n        idx += 1;\n    }\n    return ret;\n}", "{ \n    immutable\
    \ size = lst.length;\n    immutable half = size / 2;\n    if (size < 3) return\
    \ lst;\n    auto result = [lst[0], lst[size - 1]];\n    auto l = strange_sort_list(lst[1\
    \ .. half]);\n    auto r = strange_sort_list(lst[half .. $ - 1]);\n    foreach(i;\
    \ 0 .. half)\n    {\n        result ~= l[i];\n        result ~= r[i];\n    }\n\
    \    return result;\n}", "{\n    // \n    auto res = new long[lst.length];\n \
    \   auto min_max = minMax(lst);\n    auto min_val = min_max[0];\n    auto max_val\
    \ = min_max[1];\n    auto min_num = lst.count(min_val);\n    auto max_num = lst.count(max_val);\n\
    \    // \n    auto lhs = new long[lst.length-max_num];\n    auto rhs = new long[lst.length-min_num];\n\
    \    // \n    auto lhs_idx = 0L;\n    auto rhs_idx = 0L;\n    // \n    foreach(item;\
    \ lst)\n    {\n        if(item > min_val)\n        {\n            lhs[lhs_idx]\
    \ = item;\n            lhs_idx++;\n        }\n        else if(item < max_val)\n\
    \        {\n            rhs[rhs_idx] = item;\n            rhs_idx++;\n       \
    \ }\n    }\n    // \n    auto res_idx = 0L;\n    auto lhs_len = lhs.length;\n\
    \    auto rhs_len = rhs.length;\n    // \n    while(res_idx < lst.length)\n  \
    \  {\n        if(res_idx % 2 == 0)\n        {\n            res[res_idx] = min_val;\n\
    \            min_num--;\n        }\n        else\n        {\n            if(lhs_len\
    \ > 0 && rhs_len > 0)\n            {\n                res[res_idx] = max(lhs[lhs_len-1],\
    \ rhs[rhs_len-1]);\n                if(lhs[lhs_len-1] >= rhs[rhs_len-1])\n   \
    \             {\n                    lhs_len--;\n                }\n         \
    \       else\n                {\n                    rhs_len--;\n            \
    \    }\n            }\n            else if(lhs_len > 0)\n            {\n     \
    \           res[res_idx] = lhs[lhs_len-1];\n               ", "{\n    import std.typecons;\n\
    \    import std.range;\n    import std.algorithm;\n    immutable length = lst.length;\n\
    \    long[] arr = new long[length];\n    auto tmp = lst.map!(a => tuple(a, true)).array;\n\
    \    for (size_t i = 0; i < length; i++)\n    {\n        arr[i] = tmp.min!.front;\n\
    \        tmp.remove(tmp.min!);\n        if (!tmp.empty)\n        {\n         \
    \   arr[i + 1] = tmp.max!.front;\n            tmp.remove(tmp.max!);\n        }\n\
    \    }\n    return arr;\n}", "{\n    if (lst.length == 0)\n        return [];\n\
    \    else if (lst.length == 1)\n        return lst;\n    else\n    {\n       \
    \ long min = min(lst);\n        long max = max(lst);\n        long res[] = new\
    \ long[lst.length];\n        int i = 0;\n        while (min != max)\n        {\n\
    \            res[i] = min;\n            res[i + 1] = max;\n            i += 2;\n\
    \            lst -= [min, max];\n            min = min(lst);\n            max\
    \ = max(lst);\n        }\n        res[i] = min;\n        return res;\n    }\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    alias minMax = tuple!(long,\
    \ long);\n    auto sortHelper = (lst) {\n        if (lst.length <= 1)\n      \
    \      return lst;\n        long max = lst[0];\n        long min = lst[0];\n \
    \       long maxIdx = 0;\n        long minIdx = 0;\n        foreach (i, elem;\
    \ lst)\n        {\n            if (elem > max)\n            {\n              \
    \  max = elem;\n                maxIdx = i;\n            }\n            if (elem\
    \ < min)\n            {\n                min = elem;\n                minIdx =\
    \ i;\n            }\n        }\n        long[] newLst = lst[0..minIdx] ~ lst[minIdx\
    \ + 1..$];\n        return (newLst[0..maxIdx] ~ newLst[maxIdx + 1..$])\n     \
    \       .array;\n    };\n    long[] result = [lst[0]];\n    lst = lst[1..$];\n\
    \    bool isMax = true;\n    while (lst.length > 0)\n    {\n        if (isMax)\n\
    \        {\n            auto max = sortHelper(lst);\n            result ~= max[0];\n\
    \            lst = max[1..$];\n        }\n        else\n        {\n          \
    \  auto min = sortHelper(lst);\n            result ~= min[$ - 1];\n          \
    \  lst = min[0..$ - 1];\n        }\n        isMax = !isMax;\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    if (lst.length\
    \ == 1)\n        return lst;\n    return strange_sort_list(lst[0..$/2]) + strange_sort_list(lst[$/2..$]);\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] ret = new long[lst.length];\n\
    \    // TODO: Write code to implement strange_sort_list()\n    lst.sort();\n \
    \   size_t idx = 0;\n    while (lst.length > 1)\n    {\n        ret[idx] = lst[0];\n\
    \        ret[idx + 1] = lst[$ - 1];\n        idx += 2;\n        lst = lst[1 ..\
    \ $ - 1];\n    }\n    ret[idx] = lst[0];\n    return ret;\n}", "{\n    if (lst.length==0)\
    \ return new long[0];\n    long[] result = new long[lst.length];\n    int pos\
    \ = 0;\n    int[] neg = new int[1];\n    neg[0] = 0;\n    long[] temp = new long[lst.length];\n\
    \    long min = min(lst);\n    for (long i = 0; i < lst.length; i++) \n    {\n\
    \        if (lst[(int)i] > min) \n        {\n            temp[neg[0]] = lst[(int)i];\n\
    \            neg[0]++;\n        }\n    }\n    result[pos] = min;\n    pos++;\n\
    \    temp = temp[0..neg[0]];\n    while (neg[0] > 0) \n    {\n        min = min(temp);\n\
    \        result[pos] = min;\n        pos++;\n        long max = max(temp);\n \
    \       result[pos] = max;\n        pos++;\n        neg[0] -= 2;\n        temp\
    \ = temp[0..neg[0]];\n    }\n    return result;\n}", "{\n    if (lst.length <=\
    \ 1)\n        return lst;\n    else\n    {\n        auto tmp = lst.dup;\n    \
    \    tmp.sort;\n        long[] sorted = [tmp[0], tmp[$-1]];\n        tmp.remove(tmp[0]);\n\
    \        tmp.remove(tmp[$-1]);\n        while(tmp.length != 0)\n        {\n  \
    \          sorted ~= tmp[0];\n            sorted ~= tmp[$-1];\n            tmp.remove(tmp[0]);\n\
    \            tmp.remove(tmp[$-1]);\n        }\n        return sorted;\n    }\n\
    }", "{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n    bool\
    \ ascending = true;\n    return lst.sort()\n        .filter!(a => a != lst[0])\n\
    \        .sort!((a, b) => a > b).map!(a => \n        {\n            auto aa =\
    \ a;\n            a = aa;\n            if (ascending) \n            {\n      \
    \          return a;\n            }\n            else \n            {\n      \
    \          return a.popFront();\n            }\n        })\n        .array()\n\
    \        .insert(0, lst[0]);\n}", "{\n    if (lst.length < 2) return lst;\n  \
    \  if (lst.length == 2) return [min(lst[0], lst[1]), max(lst[0], lst[1])];\n \
    \   return res;\n}", "{\n    sort(lst);\n    long[] res = new long[$];\n    int\
    \ i = 0;\n    int j = (lst.length - 1);\n    while (true)\n    {\n        res[i]\
    \ = lst[i];\n        i += 1;\n        if (i >= lst.length) break;\n        res[i]\
    \ = lst[j];\n        j -= 1;\n        i += 1;\n        if (i >= lst.length) break;\n\
    \    }\n    return res;\n}", "{\n    enum bp = 0, ep = lst.length;\n    long[]\
    \ res = new long[lst.length];\n    int res_i = 0;\n    while (bp < ep)\n    {\n\
    \        long min = min_of_unseen(lst, bp, ep);\n        long max = max_of_unseen(lst,\
    \ bp, ep);\n        if (min < max)\n        {\n            res[res_i++] = min;\n\
    \            res[res_i++] = max;\n        }\n        else if (min == max)\n  \
    \      {\n            res[res_i++] = min;\n        }\n        bp = min + 1;\n\
    \        ep = max;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return [];\n    long min = 1000000000000000;\n    long max = -1000000000000000;\n\
    \    for (long l : lst)\n    {\n        if (l < min)\n            min = l;\n \
    \       if (l > max)\n            max = l;\n    }\n    uint[long] elements = [min:min];\n\
    \    long[] remaining = [min];\n    for (long l : lst)\n    {\n        if (l !=\
    \ min)\n            remaining ~= l;\n    }\n    uint[] result = [];\n    while\
    \ (true)\n    {\n        if (result.length % 2 == 0)\n        {\n            long\
    \ elem = remaining[0];\n            result ~= elem;\n            remaining = remaining[1..$];\n\
    \            elements[elem] = elem;\n        }\n        else\n        {\n    \
    \        long elem = remaining[$-1];\n            result ~= elem;\n          \
    \  remaining = remaining[0..$-1];\n            elements[elem] = elem;\n      \
    \  }\n        if (result.length == lst.length)\n            break;\n        if\
    \ (result.length % 2 == 0)\n        {\n            long last = remaining[$-1];\n\
    \            if (last > elements[$-1])\n            {\n                result\
    \ ~= last;\n                remaining = remaining[0..$-1];\n                elements[last]\
    \ = last;\n            }\n            else\n            {\n                long\
    \ first = remaining[0];\n                result ~= first;\n                remaining\
    \ = remaining[1..$];\n                elements[first] = first;\n            }\n\
    \        }\n        else\n        {\n            long last = remaining[$-1];\n\
    \            if (last < elements[$-1])\n            {\n                result\
    \ ~= last;\n                remaining = remaining[0..$-1];\n                elements[last]\
    \ = last;\n            }\n            else\n            {\n                long\
    \ first = remaining[0];\n                result ~= first;\n                remaining\
    \ = remaining[1..$];\n                elements[first] = first;\n            }\n\
    \        }\n    }\n    return result;", "{\n    if (lst.length == 0) return lst;\n\
    \    auto tmpLst = lst.dup;\n    auto r = appender!(typeof(return));\n    bool[int]\
    \ isVisited = bool[int](false);\n    bool isEven = true;\n    bool found = false;\n\
    \    while (tmpLst.length != 0) {\n        long min = tmpLst[0];\n        long\
    \ max = tmpLst[0];\n        int idxMin = 0;\n        int idxMax = 0;\n       \
    \ foreach (i, e; tmpLst) {\n            if (e < min) {\n                min =\
    \ e;\n                idxMin = i;\n            }\n            if (e > max) {\n\
    \                max = e;\n                idxMax = i;\n            }\n      \
    \  }\n        if (isEven) {\n            r.put(min);\n            isVisited[idxMin]\
    \ = true;\n        } else {\n            r.put(max);\n            isVisited[idxMax]\
    \ = true;\n        }\n        isEven = !isEven;\n        foreach (i, e; tmpLst)\
    \ {\n            if (!isVisited[i]) {\n                found = true;\n       \
    \         break;\n            }\n        }\n        if (!found) {\n          \
    \  tmpLst = [];\n        }\n    }\n    return r.data;\n}", "{\n    if (lst.length\
    \ == 0)\n        return new long[0];\n    if (lst.length == 1)\n        return\
    \ lst;\n    long minimum = lst[0];\n    long maximum = lst[0];\n    foreach (l;\
    \ lst)\n    {\n        if (l < minimum)\n            minimum = l;\n        if\
    \ (l > maximum)\n            maximum = l;\n    }\n    long[] minList = new long[lst.length];\n\
    \    long[] maxList = new long[lst.length];\n    int minCount = 0;\n    int maxCount\
    \ = 0;\n    foreach (i; lst)\n    {\n        if (i == minimum)\n            continue;\n\
    \        if (i == maximum)\n            continue;\n        if (i < minimum + maximum)\n\
    \            minList[minCount++] = i;\n        else\n            maxList[maxCount++]\
    \ = i;\n    }\n    minList = minList[0..minCount];\n    maxList = maxList[0..maxCount];\n\
    \    minList = minList.sort(min);\n    maxList = maxList.sort(max);\n    long[]\
    \ result = new long[lst.length];\n    result[0] = minimum;\n    result[lst.length\
    \ - 1] = maximum;\n    int current = 1;\n    for (;;)\n    {\n        if (minList.length\
    \ == 0 && maxList.length == 0)\n            break;\n        if (minList.length\
    \ != 0)\n        {\n            result[current] = minList[0];\n            minList\
    \ = minList[1..$];\n            current++;\n        }\n        if (maxList.length\
    \ != 0)\n        {\n            result[current] = maxList[0];\n            maxList\
    \ = maxList[1..$];\n            current++;\n        }\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0) return new long[0];\n    if (lst.length == 1)\
    \ return lst;\n    // Sort the array\n    auto s = lst.sort();\n    int l = s.length\
    \ - 1;\n    // Generate result array\n    long[] res = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        // If it's the end of\
    \ the array\n        if (l == 0)\n        {\n            res[i] = s[l];\n    \
    \        break;\n        }\n        // Get the minimum and maximum values, depending\
    \ on i\n        if (i % 2 == 0)\n        {\n            res[i] = s[0];\n     \
    \       s = s[1..$];\n        }\n        else\n        {\n            res[i] =\
    \ s[l];\n            s = s[0..$-1];\n        }\n        l--;\n    }\n    return\
    \ res;\n}\n ", "{\n    sort(lst);\n    immutable len = lst.length;\n    immutable\
    \ n = len / 2;\n    long[] l;\n    l.length = len;\n    foreach(immutable i, immutable\
    \ v; lst[0 .. n])\n    {\n        l[i] = v;\n        l[len - i - 1] = lst[n +\
    \ i];\n    }\n    if (len % 2 == 1)\n        l[n] = lst[n];\n    return l;\n}",
  "{\n    if (lst.length < 2)\n        return lst;\n    \n    long[] out = new long[lst.length];\n\
    \    auto range = zip(iota(0), lst).sort!((a, b) => a[1] > b[1] ? 1 : a[1] < b[1]\
    \ ? -1 : 0);\n    int index = 0;\n    while (range.length > 0)\n    {\n      \
    \  if (index % 2 == 0)\n            out[index] = range.front[1];\n        else\n\
    \            out[index] = range.back[1];\n        index++;\n        range = range[1..$-1];\n\
    \    }\n    return out;\n}", "{\n    if (lst.length == 0) return [];\n    if (lst.length\
    \ == 1) return lst;\n    import std.algorithm;\n    import std.array;\n    int\
    \ step = 2;\n    bool is_inc = true;\n    long[] new_lst = new long[lst.length];\n\
    \    foreach (idx, item; lst.enumerate)\n    {\n        new_lst[idx] = item;\n\
    \    }\n    foreach (idx, item; new_lst.enumerate)\n    {\n        if (idx < lst.length/2)\n\
    \        {\n            new_lst[idx] = lst[idx];\n        }\n        else if (idx\
    \ < lst.length-1)\n        {\n            new_lst[idx] = lst[lst.length-1-idx];\n\
    \        }\n        else\n        {\n            new_lst[idx] = lst[idx];\n  \
    \      }\n    }\n    return new_lst;\n}", "{\n\tstatic assert(!lst.empty);\n\t\
    auto min_index = minIndex(lst);\n\tlong[] result = [lst[min_index]];\n\tlong[]\
    \ remaining = lst.dup;\n\tremaining.remove(min_index);\n\twhile(!remaining.empty)\n\
    \t{\n\t\tif(remaining.length%2 == 0)\n\t\t{\n\t\t\tauto min_index = minIndex(remaining);\n\
    \t\t\tresult ~= remaining[min_index];\n\t\t\tremaining.remove(min_index);\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\tauto max_index = maxIndex(remaining);\n\t\t\tresult\
    \ ~= remaining[max_index];\n\t\t\tremaining.remove(max_index);\n\t\t}\n\t}\n\t\
    return result;\n}", "{\n    long[] orderedList = lst.dup.sort.array;\n    if (orderedList.length\
    \ % 2 == 0)\n    {\n        for (int i = 0; i < orderedList.length; i += 2)\n\
    \        {\n            long l1 = orderedList[i];\n            long l2 = orderedList[i\
    \ + 1];\n            orderedList[i] = l2;\n            orderedList[i + 1] = l1;\n\
    \        }\n    }\n    else\n    {\n        int maxPos = orderedList.length -\
    \ 1;\n        for (int i = 0; i < orderedList.length; i += 2)\n        {\n   \
    \         long l1 = orderedList[i];\n            long l2 = orderedList[maxPos];\n\
    \            orderedList[i] = l2;\n            orderedList[maxPos] = l1;\n   \
    \         maxPos--;\n        }\n    }\n    return orderedList;\n}\n/*", "{\n \
    \   if (lst.length == 0) \n    {\n        return lst;\n    }\n    long min = min(lst);\n\
    \    long max = max(lst);\n    long[] sorted = new long[lst.length];\n    bool\
    \ isMin = true;\n    long[] remaining = lst;\n    int count = 0;\n    while (count\
    \ < lst.length) \n    {\n        if (isMin) \n        {\n            isMin = false;\n\
    \            remaining = remove(remaining, min);\n            sorted[count] =\
    \ min;\n        } \n        else \n        {\n            isMin = true;\n    \
    \        remaining = remove(remaining, max);\n            sorted[count] = max;\n\
    \        }\n        min = min(remaining);\n        max = max(remaining);\n   \
    \     count++;\n    }\n    return sorted;\n}", "{\n    if (lst.length == 0)\n\
    \        return [];\n    auto direction = 1;\n    auto result = new long[lst.length];\n\
    \    auto source = lst.dup;\n    int i;\n    foreach (resultIndex; 0 .. result.length)\
    \ \n    {\n        auto best = source[0];\n        int bestIndex = 0;\n      \
    \  for (i = 1; i < source.length; i++) \n        {\n            if (direction\
    \ == 1) \n            {\n                if (source[i] > best) \n            \
    \    {\n                    best = source[i];\n                    bestIndex =\
    \ i;\n                }\n            }\n            else \n            {\n   \
    \             if (source[i] < best) \n                {\n                    best\
    \ = source[i];\n                    bestIndex = i;\n                }\n      \
    \      }\n        }\n        result[resultIndex] = best;\n        source = source[0\
    \ .. bestIndex] ~ source[bestIndex + 1 .. $];\n        direction *= -1;\n    }\n\
    \    return result;\n}\nstatic assert(strange_sort_list([1L, 2L, 3L, 4L]) == [1L,\
    \ 4L, 2L, 3L]);\nstatic assert(strange_sort_list([5L, 5L, 5L, 5L]) == [5L, 5L,\
    \ 5L, 5L]);\nstatic assert(strange_sort_list([]) == []);", "{\n    long[] sortedArray\
    \ = [];\n    sort(lst);\n    auto plus = lst.length;\n    while(plus != 0) {\n\
    \        sortedArray ~= lst[0];\n        sortedArray ~= lst[plus - 1];\n     \
    \   lst = lst[1..$-1];\n        plus -= 2;\n    }\n    return sortedArray;\n}",
  "{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n    else \n  \
    \  {\n        auto order = new long[lst.length];\n        auto max_min = minmax(lst);\n\
    \        auto max = max_min[1];\n        auto min = max_min[0];\n        auto\
    \ x = 0;\n        auto y = lst.length - 1;\n        foreach (idx, value; lst)\
    \ \n        {\n            if (idx % 2 == 0) \n            {\n               \
    \ order[idx] = min;\n                min = std.algorithm.partition(lst, v => v\
    \ > min).front;\n            }\n            else \n            {\n           \
    \     order[idx] = max;\n                max = std.algorithm.partition(lst, v\
    \ => v < max).back;\n            }\n        }\n        return order;\n    }\n}",
  "{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n    long[] result\
    \ = new long[lst.length];\n    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std.numeric.comparison);\n\
    \    lst.sort(std.numeric.comparison);\n    lst.sort(std", "{ \n    const auto\
    \ N = lst.length;\n    if (N == 0)\n        return lst;\n    auto indices = iota(0L,\
    \ N).array;\n    auto tmp = lst.array;\n    std.algorithm.sort(tmp, indices, std.less());\n\
    \    auto res = appender!(long[])();\n    foreach (i; 0 .. N / 2)\n    {\n   \
    \     res.put(lst[indices[i]]);\n        res.put(lst[indices[N - i - 1]]);\n \
    \   }\n    if (N % 2)\n        res.put(lst[indices[N / 2]]);\n    return res.data;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    auto z = lst.dup;\n\
    \    z = z.sort();\n    lst.length = 0;\n    for (int i = 0; i < z.length; i++)\n\
    \    {\n        if (i % 2 == 0)\n            lst ~= z[i];\n        else\n    \
    \        lst.insert(0, z[i]);\n    }\n    return lst;\n}", "{\n    long[] res\
    \ = new long[lst.length];\n    int min = min(lst).i;\n    int max = max(lst).i;\n\
    \    int index = 0;\n    long[] remaining = new long[lst.length];\n    int remaining_index\
    \ = 0;\n    int remaining_length = lst.length;\n    foreach(int i; lst)\n    {\n\
    \        if(i == min || i == max)\n        {\n            res[index] = i;\n  \
    \          index++;\n        }\n        else\n        {\n            remaining[remaining_index]\
    \ = i;\n            remaining_index++;\n        }\n    }\n    remaining_length\
    \ -= 2;\n    while(remaining_length > 0)\n    {\n        min = min(remaining).i;\n\
    \        max = max(remaining).i;\n        foreach(int i; remaining)\n        {\n\
    \            if(i == min || i == max)\n            {\n                res[index]\
    \ = i;\n                index++;\n            }\n            else\n          \
    \  {\n                remaining[remaining_index] = i;\n                remaining_index++;\n\
    \            }\n        }\n        remaining_length -= 2;\n    }\n    return res;\n\
    }", "{\n    // your code here\n    return null;\n}", "{\n    struct elem_pair(T,\
    \ U)\n    {\n        T first;\n        U second;\n    }\n    auto make_pair(T,\
    \ U)(T f, U s)\n    {\n        elem_pair!(T, U) p;\n        p.first = f;\n   \
    \     p.second = s;\n        return p;\n    }\n    size_t count = lst.length;\n\
    \    if (count == 0) return lst;\n    auto arr = lst.map!(a => make_pair(a, false));\n\
    \    size_t i = 0;\n    while (i < count)\n    {\n        if (i & 1)\n       \
    \ {\n            auto max = arr.max!((a, b) => a.first > b.first && !a.second);\n\
    \            max.second = true;\n            lst[i] = max.first;\n        }\n\
    \        else\n        {\n            auto min = arr.min!((a, b) => a.first <\
    \ b.first && !a.second);\n            min.second = true;\n            lst[i] =\
    \ min.first;\n        }\n        i++;\n    }\n    return lst;\n}", "{\n    auto\
    \ sorted_list = lst.sort()[];\n    auto even_indexes = [](int i){return (i & 1)\
    \ == 0;};\n    auto odd_indexes = [](int i){return (i & 1) == 1;};\n    auto even_elements\
    \ = sorted_list.filter!even_indexes;\n    auto odd_elements = sorted_list.filter!odd_indexes;\n\
    \    return even_elements.array.reverse().array ~ odd_elements.array;\n}\n/*\n\
    \    Given a list of integers and a value,\n    return the sum of all integers\
    \ that\n    are in the list and strictly higher than the given value.", "{ \n\
    \    if (lst.length == 0) \n        return lst; \n    else\n    { \n        auto\
    \ odd = new long[lst.length]; \n        auto even = new long[lst.length]; \n \
    \       int odd_ind = 0; \n        int even_ind = 0; \n        auto min_ind =\
    \ 0; \n        auto max_ind = lst.length - 1; \n        for (int i = 0; i < lst.length;\
    \ i++)\n        { \n            if (i % 2 == 0)\n            { \n            \
    \    odd[odd_ind] = lst[min_ind]; \n                odd_ind++; \n            \
    \    min_ind++; \n            } \n            else\n            { \n         \
    \       even[even_ind] = lst[max_ind]; \n                even_ind++; \n      \
    \          max_ind--; \n            } \n        } \n        return odd~even; \n\
    \    } \n} ", "{\n    if (lst.length == 0)\n        return lst;\n    bool asc\
    \ = true;\n    long[] result = new long[lst.length];\n    long next = lst[0];\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (asc)\n        {\n      \
    \      long max = next;\n            foreach (j; 0 .. lst.length)\n          \
    \  {\n                if (lst[j] > max && !result.contains(lst[j]))\n        \
    \            max = lst[j];\n            }\n            next = max;\n         \
    \   asc = false;\n        }\n        else\n        {\n            long min = next;\n\
    \            foreach (j; 0 .. lst.length)\n            {\n                if (lst[j]\
    \ < min && !result.contains(lst[j]))\n                    min = lst[j];\n    \
    \        }\n            next = min;\n            asc = true;\n        }\n    \
    \    result[i] = next;\n    }\n    return result;\n}", "{\n\tif (lst.length <\
    \ 2)\n\t\treturn lst;\n\tif (lst.length < 3)\n\t\treturn lst[0] > lst[1] ? lst.reverse()\
    \ : lst;\n\tlst.sort();\n\treturn std.range(0, lst.length / 2)\n\t.map!((i) =>\
    \ tuple(lst[i], lst[lst.length - i - 1]))\n\t.flatMap!((e) => e)\n\t.toArray();\n\
    }", "{\n    int[] positions = generate!(int)(lst.length).array;\n    enum n =\
    \ lst.length / 2 + lst.length % 2;\n    lst = lst.dup;\n    lst.sort();\n    auto\
    \ result = new long[](n);\n    foreach (int i, int j; iota(0, n))\n    {\n   \
    \     if (i % 2 == 0) \n        {\n            result[i] = lst[positions[j]];\n\
    \            positions[j] = -1;\n        }\n        else \n        {\n       \
    \     result[i] = lst[positions[lst.length - j - 1]];\n            positions[lst.length\
    \ - j - 1] = -1;\n        }\n    }\n    return result;\n}\n/*\n    Given array\
    \ of integers, return true if array contains some duplicate values.\n    Otherwise,\
    \ return false.", "{\n    int n = lst.length;\n    if (n == 0)\n        return\
    \ typeof(return).array();\n    else \n    {\n        auto lst2 = lst.dup;\n  \
    \      lst2.sort;\n        long[] res = new long[n];\n        bool flg = true;\n\
    \        int i = 0;\n        int j = 0;\n        int k = 1;\n        while (j\
    \ < n) \n        {\n            if (flg) \n            {\n                res[j]\
    \ = lst2[i];\n                i += 1;\n            }\n            else \n    \
    \        {\n                res[j] = lst2[n - k];\n                k += 1;\n \
    \           }\n            j += 1;\n            flg = !flg;\n        }\n     \
    \   return res;\n    }\n}\n/*\n    Given list of strings, return tuple\n    of\
    \ the number of elements that start\n    with 'f' and the number of elements that\n\
    \    start with 'b'. If no elements start with\n    'f' or 'b', return (0, 0).\n\
    \    \n    Example:\n    >>> foo_bar([\"foo\", \"bar\", \"foobar\"])\n    (1,\
    \ 1)\n    >>> foo_bar([\"foo\", \"bar\", \"baz\"])\n    (0, 1)\n    >>> foo_bar([\"\
    foobar\", \"foo\", \"bar\"])\n    (1, 1)\n    >>> foo_bar([\"foobar\", \"bar\"\
    ])\n    (1, 1)\n    >>> foo_bar([\"foobar\", \"foo\"])\n    (1, 0)\n    >>> foo_bar([\"\
    foo\", \"foobar\"])\n    (1, 0)\n    >>> foo_bar([\"bar\", \"baz\"])\n    (0,\
    \ 2)\n    >>> foo_bar([\"foobar\"])\n    (1, 0)\n    >>> foo_bar([\"foobar\",\
    \ \"foobar\"])\n    (2, 0)\n    >>> foo_bar([\"foobar\", \"foobar\", \"foobar\"\
    ])\n    (3, 0)\n    >>> foo_bar([\"foo\", \"foo\",", "{\n\tif (lst.length == 0)\n\
    \t\treturn lst;\n\telse\n\t{\n\t\tlong min = min(lst);\n\t\tlong max = max(lst);\n\
    \t\tlong[] zipped = zip(\n\t\t\t\t\t\t\tenumerate(lst),\n\t\t\t\t\t\t\t(j) =>\
    \ j[1] != min && j[1] != max ? j[0] : -1L\n\t\t\t\t\t\t\t).retro;\n\t\tlong[]\
    \ sorted = zip(lst, sort(lst)).retro;\n\t\tlong[] res = new long[lst.length];\n\
    \t\tforeach (j; 0 .. lst.length)\n\t\t{\n\t\t\tif (zipped[j] != -1L)\n\t\t\t\t\
    res[j] = sorted[zipped[j]];\n\t\t\telse\n\t\t\t\tres[j] = sorted[j];\n\t\t}\n\t\
    \treturn res;\n\t}\n}", "{\n    if (lst.length < 2)\n        return lst;\n   \
    \ long[] res = new long[lst.length];\n    int i = 0;\n    long min = min(lst);\n\
    \    long max = max(lst);\n    long del = min(min, max);\n    for (i = 0; i <\
    \ lst.length; i++)\n    {\n        if (i % 2 == 0)\n            res[i] = lst[i\
    \ / 2];\n        else\n            res[i] = lst[lst.length - i / 2 - 1];\n   \
    \ }\n    return res;\n}", "{\n\tif (lst.length <= 1) return lst;\n\tlong min =\
    \ min(lst);\n\tlong max = max(lst);\n\tint min_index = indexOf(lst, min);\n\t\
    int max_index = indexOf(lst, max);\n\tint mid = lst.length / 2;\n\t\n\tauto t\
    \ = (min, max);\n\t\n\tif (min_index == max_index) {\n\t\treturn lst;\n\t}\n\t\
    \n\tif (min_index > max_index) {\n\t\tstd.algorithm.swap(lst[min_index], lst[max_index]);\n\
    \t\tt = (max, min);\n\t}\n\t\n\tif (min_index == mid) return lst;\n\t\n\treturn\
    \ strange_sort_list(lst);\n}", "{\n    auto copy = lst.dup;\n    if (copy.length\
    \ == 0)\n        return copy;\n    bool odd = true;\n    long[] lst1;\n    long[]\
    \ lst2;\n    long[] lst3;\n    long[] lst4;\n    long[] lst5;\n    long[] lst6;\n\
    \    long[] lst7;\n    long[] lst8;\n    long[] lst9;\n    long[] lst10;\n   \
    \ long[] lst11;\n    long[] lst12;\n    long[] lst13;\n    long[] lst14;\n   \
    \ long[] lst15;\n    long[] lst16;\n    long[] lst17;\n    long[] lst18;\n   \
    \ long[] lst19;\n    long[] lst20;\n    long[] lst21;\n    long[] lst22;\n   \
    \ long[] lst23;\n    long[] lst24;\n    long[] lst25;\n    long[] lst26;\n   \
    \ long[] lst27;\n    long[] lst28;\n    long[] lst29;\n    long[] lst30;\n   \
    \ long[] lst31;\n    long[] lst32;\n    long[] lst33;\n    long[] lst34;\n   \
    \ long[] lst35;\n    long[] lst36;\n    long[] lst37;\n    long[] lst38;\n   \
    \ long[] lst39;\n    long[] lst40;\n    long[] lst41;\n    long[] lst42;\n   \
    \ long[] lst43;\n    long[] lst44;\n    long[] lst45;\n    long[] lst46;\n   \
    \ long[] lst47;\n    long[] lst48;\n    long[] lst49;\n    long[] lst50;\n   \
    \ long[] lst51;\n    long[] lst52;\n    long[] lst53;\n    long[] lst54;\n   \
    \ long[] lst55;\n    long[] lst56;\n    long[] lst57;\n    long[] lst58;\n   \
    \ long[] lst59;\n    long[] l", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    if (lst.length == 1)\n        return lst;\n    auto m = lst.max();\n    auto\
    \ l = lst.length;\n    long[] res = new long[l];\n    bool incr = true;\n    int\
    \ j = 0;\n    for (int i = 0; i < l; i++)\n    {\n        res[i] = lst[j];\n \
    \       if (incr == true)\n        {\n            j++;\n            if (j == l)\n\
    \            {\n                incr = false;\n                j = l - 2;\n  \
    \          }\n        }\n        else\n        {\n            j--;\n         \
    \   if (j == -1)\n            {\n                incr = true;\n              \
    \  j = 1;\n            }\n        }\n    }\n    return res;\n}\nauto strange_sort_list\
    \ = memoize!(strange_sort_list);", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    bool asc = true;\n    int i = 0;\n    auto pairs = zip(iota(lst.length),\
    \ lst);\n    sort!((a, b) => (asc ? a.item2 > b.item2 : a.item2 < b.item2))(pairs);\n\
    \    return pairs.map!(x => x.item2).array;\n}\n ", "{\n    long len = lst.length;\n\
    \    if (len == 0) \n    {\n        return lst;\n    }\n    auto a = [lst[0L]];\n\
    \    long minimum = a[0L];\n    long maximum = a[0L];\n    long min_index = 0L;\n\
    \    long max_index = 0L;\n    foreach (index, item; lst[1L .. $]) \n    {\n \
    \       if (item < minimum) \n        {\n            minimum = item;\n       \
    \     min_index = index + 1L;\n        }\n        else if (item > maximum) \n\
    \        {\n            maximum = item;\n            max_index = index + 1L;\n\
    \        }\n    }\n    auto min_max = tuple(minimum, maximum);\n    if (max_index\
    \ < min_index) \n    {\n        min_max.swap();\n    }\n    a ~= min_max;\n  \
    \  lst = lst[0L .. min_index] ~ lst[min_index + 1L .. max_index] ~ lst[max_index\
    \ + 1L .. $];\n    if (lst.length > 1L) \n    {\n        a ~= strange_sort_list(lst);\n\
    \    }\n    return a;\n}", "{\n    if (lst.length == 0) return [];\n    bool asc\
    \ = true;\n    long[] result = [lst[0]];\n    auto lst_ = lst[1..$];\n    while\
    \ (lst_.length > 0)\n    {\n        if (asc)\n        {\n            lst_ = lst_.sort!((a,\
    \ b) => a < b);\n            result ~= lst_[$-1];\n            lst_ = lst_[0..$-1];\n\
    \        }\n        else\n        {\n            lst_ = lst_.sort!((a, b) => a\
    \ > b);\n            result ~= lst_[$-1];\n            lst_ = lst_[0..$-1];\n\
    \        }\n        asc = !asc;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ < 2)\n        return lst;\n    \n    auto tpl = tuple(minElement(lst), maxElement(lst));\n\
    \    long res[] = new long[lst.length];\n    res[0] = tpl[0];\n    res[lst.length\
    \ - 1] = tpl[1];\n    \n    bool asc = false;\n    for (int i = 1; i < lst.length\
    \ - 1; i++) \n    {\n        if (asc)\n            res[i] = minElement(lst);\n\
    \        else\n            res[i] = maxElement(lst);\n        asc = !asc;\n  \
    \  }\n    return res;\n}", "{\n    if (lst.length == 0) \n    {\n        return\
    \ lst;\n    }\n    int start = 0;\n    int end = lst.length - 1;\n    bool is_max\
    \ = false;\n    long[] res = new long[lst.length];\n    long[] new_lst = new long[lst.length];\n\
    \    foreach (item; lst) \n    {\n        new_lst[start] = item;\n        start++;\n\
    \    }\n    quickSort(new_lst);\n    start = 0;\n    end = lst.length - 1;\n \
    \   while (start <= end) \n    {\n        if (is_max) \n        {\n          \
    \  res[start] = new_lst[end];\n            end--;\n        } \n        else \n\
    \        {\n            res[start] = new_lst[start];\n            start++;\n \
    \       }\n        is_max = !is_max;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0) \n    {\n        return [];\n    }", "{\n    //long[] lst2 = deepCopy(lst);\n\
    \    long[] lst2 = deepCopy(lst);\n    long[] lst3 = new long[0];\n    if (lst2.length\
    \ != 0)\n    {\n        long min = min(lst2);\n        while (lst2.length != 0)\n\
    \        {\n            lst3 ~= min;\n            lst2 = lst2.filter!(a => a !=\
    \ min);\n            if (lst2.length != 0)\n            {\n                long\
    \ max = max(lst2);\n                lst3 ~= max;\n                lst2 = lst2.filter!(a\
    \ => a != max);\n            }\n        }\n    }\n    return lst3;\n}", "{\n \
    \   if (lst.length == 0) \n    {\n        return lst;\n    }\n    //all items\
    \ are equal\n    if (lst.length > 1 && min(lst) == max(lst)) \n    {\n       \
    \ return lst;\n    }\n    long[] ret_list = [];\n    auto sort_list = sort(lst);\n\
    \    //main magic here\n    foreach (elem; sort_list) \n    {\n        if (sort_list.length\
    \ > 1) \n        {\n            ret_list ~= elem;\n            sort_list = sort_list[1\
    \ .. $ - 1];\n            sort_list = sort_list[$ - 1 .. 0];\n        }\n    \
    \    else \n        {\n            ret_list ~= elem;\n        }\n    }\n    return\
    \ ret_list;\n}", "{\n    if (lst.length == 0) \n    {\n        return lst;\n \
    \   }\n    long min = minElement(lst);\n    long max = maxElement(lst);\n    long[]\
    \ res = new long[lst.length];\n    int c = 0;\n    int i = 0;\n    while (c <\
    \ lst.length) \n    {\n        if (i % 2 == 0) \n        {\n            res[c]\
    \ = min;\n            ++c;\n            if (c == lst.length)\n            {\n\
    \                break;\n            }\n            min = minElement(filter!(a\
    \ => a != min)(lst));\n        } \n        else \n        {\n            res[c]\
    \ = max;\n            ++c;\n            if (c == lst.length)\n            {\n\
    \                break;\n            }\n            max = maxElement(filter!(a\
    \ => a != max)(lst));\n        }\n        ++i;\n    }\n    return res;\n}", "{\n\
    \    auto r = lst.sort().zip(enum(lst.sort().reversed()));\n    auto flatten =\
    \ staticMap!((x) => x[0], r);\n    flatten ~= staticMap!((x) => x[1], r);\n  \
    \  return flatten[0 .. lst.length];\n}", "{\n  immutable min_value = min(lst);\n\
    \  immutable max_value = max(lst);\n  long[] result;\n  foreach(immutable n; lst)\n\
    \  {\n      if(n != min_value && n != max_value)\n      {\n        result ~= n;\n\
    \      }\n  }\n  immutable forward = true;\n  while(result.length != 0)\n  {\n\
    \    if(forward)\n    {\n      foreach(immutable n; lst)\n      {\n        if(n\
    \ == min_value)\n        {\n          result = [n] ~ result;\n        }\n    \
    \    else if(n == max_value)\n        {\n          result ~= [n];\n        }\n\
    \      }\n      forward = false;\n    }\n    else\n    {\n      foreach(immutable\
    \ n; lst)\n      {\n        if(n == max_value)\n        {\n          result =\
    \ [n] ~ result;\n        }\n        else if(n == min_value)\n        {\n     \
    \     result ~= [n];\n        }\n      }\n      forward = true;\n    }\n  }\n\
    \  return result;\n}\n ", "{\n    if (lst.length == 0) \n    {\n        return\
    \ lst;\n    }", "{\n    long[] r = [], r2 = [], r3 = [];\n    foreach(long m;\
    \ lst) \n    {\n        r ~= m;\n    }\n    int len = r.length;\n    for(int i\
    \ = 0; i < len; i++) \n    {\n        if (i % 2 == 0) \n        {\n          \
    \  r2 ~= r[0];\n            r = r[1..$];\n        }\n        else \n        {\n\
    \            r2 ~= r[$-1];\n            r = r[0..$-1];\n        }\n    }\n   \
    \ foreach(m; r2) \n    {\n        r3 ~= m;\n    }\n    return r3;\n}\n/*\n   \
    \ This function checks if the given string is a palindrome.", "{\n    bool asc\
    \ = true;\n    long[] result = new long[lst.length];\n    foreach(i, ref x; lst)\n\
    \    {\n        result[i] = x;\n    }\n    for(size_t i = 0; i < lst.length; i++)\n\
    \    {\n        if(i % 2 == 0)\n        {\n            std.algorithm.sort(result[i]);\n\
    \        }\n        else\n        {\n            std.algorithm.sort(result[i],\
    \ asc);\n        }\n    }\n    return result;\n}\n/*\n    From a given array of\
    \ integers return array with non-duplicated integers.\n    Example:\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 4L, 4L, 5L, 5L, 5L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> remove_duplicates([])\n\
    \    []\n*/\nlong[] remove_duplicates(long[] lst) \n{\n    long[] result = new\
    \ long[lst.length];\n    foreach(i, ref x; lst)\n    {\n        result[i] = x;\n\
    \    }\n    std.algorithm.uniq(result);\n    return result;\n}\n/*\n    Given\
    \ array of integers, generate a new array containing the product\n    of all the\
    \ integers in the array except itself.", "{\n    long[] result = new long[$];\n\
    \    bool[] used = new bool[$];\n    long min, max;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        min = max = lst[0];\n        foreach (j; 1 .. lst.length)\n  \
    \      {\n            if (used[j])\n                continue;\n            min\
    \ = min(min, lst[j]);\n            max = max(max, lst[j]);\n        }\n      \
    \  if (i % 2 == 0)\n        {\n            result[i] = min;\n            used[index(lst,\
    \ min)] = true;\n        }\n        else\n        {\n            result[i] = max;\n\
    \            used[index(lst, max)] = true;\n        }\n    }\n    return result;\n\
    }\n/*\n    Tests\n*/", "{\n    struct KeyValue {\n        long key;\n        long\
    \ value;\n        this(long key, long value) {\n            this.key = key;\n\
    \            this.value = value;\n        }\n    }\n    auto cmp = (ref const\
    \ KeyValue a, ref const KeyValue b) {\n        return a.key < b.key;\n    };\n\
    \    auto pairs = zip(lst, iota(lst.length));\n    sort(pairs, cmp);\n    long[]\
    \ ret;\n    foreach (i, pair; pairs) {\n        ret ~= pair[1];\n    }\n    return\
    \ ret;\n}", "{\n    if (lst.length == 0) \n    {\n        return [];\n    }",
  "{\n    // \n    // \n    //\n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //\
    \ \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n \
    \   // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //",
  "{\n    auto result = lst[];\n    lst.sort;\n    auto max_value = lst[$-1];\n  \
    \  auto min_value = lst[0];\n    bool is_min = true;\n    foreach(i;0..lst.length)\n\
    \    {\n        if(is_min)\n        {\n            result ~= min_value;\n    \
    \        is_min = false;\n        }\n        else\n        {\n            result\
    \ ~= max_value;\n            is_min = true;\n        }\n    }\n    return result;\n\
    }", "{\n    auto len = lst.length;\n    if (len == 0) return [];\n    else if\
    \ (len == 1) return lst;\n    else if (len == 2) \n    {\n        if (lst[0] >\
    \ lst[1]) return [lst[1], lst[0]];\n        else return lst;\n    }\n    else\
    \ \n    {\n        enum MIN = 0;\n        enum MAX = 1;\n        long min = minElement(lst);\n\
    \        long max = maxElement(lst);\n        enum OP = MIN;\n        long[] res\
    \ = [min];\n        foreach (num; lst)\n        {\n            if (num == min\
    \ || num == max) continue;\n            if (OP == MIN) \n            {\n     \
    \           res ~= num;\n                OP = MAX;\n            }\n          \
    \  else if (OP == MAX) \n            {\n                res = [num] ~ res;\n \
    \               OP = MIN;\n            }\n        }\n        if (max > min) res\
    \ ~= max;\n        else res = [max] ~ res;\n        return res;\n    }\n}", "{\n\
    \    // TODO: sort lst as required, return it\n    return lst;\n}\n ", "{\n  \
    \  long[] new_lst;\n    long[] temp_lst;\n    // sort the list and return\n  \
    \  auto sorted_lst = std.algorithm.sort(lst);\n    // if list is even return the\
    \ list\n    if (sorted_lst.length % 2 == 0) \n    {\n        // return the list\n\
    \        return sorted_lst;\n    } \n    else \n    {\n        new_lst = new long[sorted_lst.length];\n\
    \        // set of the beginning to the mid point of the list\n        new_lst[0]\
    \ = sorted_lst[0];\n        long max_index = sorted_lst.length / 2;\n        long\
    \ min_index = max_index;\n        // if the number of items in the list is odd\
    \ swap the min and max\n        if (sorted_lst.length % 2 != 0) \n        {\n\
    \            max_index = max_index + 1;\n        }\n        // assign the min\
    \ and max values to the new list\n        for (int i = 1; i < sorted_lst.length\
    \ - 1; i = i + 2) \n        {\n            new_lst[i] = sorted_lst[max_index];\n\
    \            new_lst[i + 1] = sorted_lst[min_index];\n            // decrement\
    \ the max and min index\n            max_index = max_index - 1;\n            min_index\
    \ = min_index - 1;\n        }\n        // assign the last element in the list\n\
    \        new_lst[sorted_lst.length - 1] = sorted_lst[sorted_lst.length - 1];\n\
    \        // return the new list\n        return new_lst;\n    }\n}", "{\n\tlong[]\
    \ sorted;\n\tint direction = 1;\n\timmutable(long)[] sorted;\n\twhile(lst.length)\
    \ \n\t{\n\t\tif(direction == 1)\n\t\t{\n\t\t\tsorted ~= lst[0];\n\t\t\tlst = lst[1..$];\n\
    \t\t}\n\t\telse \n\t\t{\n\t\t\tsorted ~= lst[$-1];\n\t\t\tlst = lst[0..$-1];\n\
    \t\t}\n\t\tdirection *= -1;\n\t}\n\treturn sorted;\n}", "{\n    if (lst.length\
    \ == 0) \n    {\n        return [];\n    }\n    //TypeTuple!(int, int) t = tuple(lst[0],\
    \ lst[0]);\n    int[] index = new int[2];\n    index[0] = 0;\n    index[1] = 0;\n\
    \    for (int i = 0; i < lst.length; i++) \n    {\n        if (lst[i] < lst[index[0]])\
    \ \n        {\n            index[0] = i;\n        }\n        if (lst[i] > lst[index[1]])\
    \ \n        {\n            index[1] = i;\n        }\n    }\n    long[] new_lst\
    \ = new long[lst.length];\n    for (int i = 0; i < lst.length; i += 2) \n    {\n\
    \        new_lst[i] = lst[index[0]];\n        new_lst[i + 1] = lst[index[1]];\n\
    \    }\n    return new_lst;\n}", "{\n    if (lst.length < 1) \n    {\n       \
    \ return lst;\n    }\n    auto tuples = lst.map!(a => tuple(a, abs(a)));\n   \
    \ tuples.sort!(a => (a[1]));\n    auto temp = tuples.map!(a => a[0]);\n    int\
    \ front = 0;\n    int back = temp.length - 1;\n    long[] answer = new long[temp.length];\n\
    \    for (int i = 0; i < temp.length; i++) \n    {\n        if (i % 2 == 0) \n\
    \        {\n            answer[i] = temp[front];\n            front++;\n     \
    \   } \n        else \n        {\n            answer[i] = temp[back];\n      \
    \      back--;\n        }\n    }\n    return answer;\n}", "{\n    \n    const\
    \ long sort_up = 1L;\n    const long sort_down = 2L;\n    auto result = new long[](lst.length);\n\
    \    const long start_at = min(lst);\n    bool has_start_at = false;\n    long\
    \ counter = 0L;\n    long num_iterations = (lst.length % 2 == 0 ? lst.length :\
    \ lst.length - 1);\n    long sort_direction = sort_up;\n    long sort_num = start_at;\n\
    \    static if (is(typeof(lst) == DynamicArray!long))\n    {\n        auto lst_rnd\
    \ = lst.dup;\n        foreach (i; 0 .. num_iterations)\n        {\n          \
    \  if (!has_start_at)\n            {\n                lst_rnd[start_at] = -1L;\n\
    \                has_start_at = true;\n            }\n            result[counter]\
    \ = sort_num;\n            counter += 1L;\n            if (sort_direction == sort_up)\n\
    \            {\n                sort_num = max(lst_rnd);\n                sort_direction\
    \ = sort_down;\n            }\n            else if (sort_direction == sort_down)\n\
    \            {\n                sort_num = min(lst_rnd);\n                sort_direction\
    \ = sort_up;\n            }\n            lst_rnd[sort_num] = -1L;\n        }\n\
    \    }\n    else\n    {\n        foreach (i; 0 .. num_iterations)\n        {\n\
    \            if (!has_start_at)\n            {\n                lst[start_at]\
    \ = -1L;\n                has_start_at = true;\n            }\n            result[counter]\
    \ = sort_num;\n            counter += 1L;\n            if (sort_direction == sort_up)\n\
    \            {\n                sort_num = max(lst);\n                sort_direction\
    \ = sort_down;\n            }\n            else if (sort_direction == sort_down)\n\
    \            {\n                sort_num = min(lst);\n                sort_direction\
    \ = sort_up;\n            }\n            lst[", "{\n\tauto sorted = lst.sort();\n\
    \tint i=0;\n\tint j=sorted.length-1;\n\tauto result = new long[lst.length];\n\t\
    while(i<j)\n\t{\n\t\tresult[i]=sorted[i];\n\t\tresult[j]=sorted[j];\n\t\ti++;\n\
    \t\tj--;\n\t}\n\treturn result;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    Tuple!(long[], long[]) tuple = lst.chunks(lst.length/2);\n    long[]\
    \ left = tuple[0];\n    long[] right = tuple[1];\n    long[] joined = new long[lst.length];\n\
    \    bool is_even = false;\n    long left_index = 0;\n    long right_index = 0;\n\
    \    for (long i = 0; i < lst.length; i++)\n    {\n        if (is_even)\n    \
    \    {\n            joined[i] = left[left_index];\n            left_index++;\n\
    \        }\n        else\n        {\n            joined[i] = right[right_index];\n\
    \            right_index++;\n        }\n        is_even = !is_even;\n    }\n \
    \   return joined;\n}", "{ \n    long min, max;\n    int i;\n    long[] lst1;\n\
    \    bool add = true;\n    lst1 = new long[0];\n    if(lst.length == 0)\n    \
    \    return lst1;\n    while(lst.length > 0)\n    {\n        min = lst[0];\n \
    \       max = lst[0];\n        for(i = 0; i < lst.length; i++)\n        {\n  \
    \          if(lst[i] > max)\n                max = lst[i];\n            if(lst[i]\
    \ < min)\n                min = lst[i];\n        }\n        lst1 ~= add ? min\
    \ : max;\n        lst = lst.filter!(x => x != min && x != max);\n        add =\
    \ !add;\n    }\n    return lst1;\n}", "{\n    if (lst.length < 2) \n    {\n  \
    \      return lst;\n    }\n    alias Longs = long[];\n    auto min = minElement(lst);\n\
    \    auto idx = std.algorithm.find(lst, min);\n    return to!Longs(\n        chain(\n\
    \            [min],\n            strange_sort_list(lst[0..idx] + lst[idx + 1..$])\n\
    \        )\n    );\n}", "{\n    if (lst.length==0) return lst;\n    long[] odd=lst.filter!(x=>x%2!=0).sort!(a,b=>a>b);\n\
    \    long[] even=lst.filter!(x=>x%2==0).sort!(a,b=>a<b);\n    long[] res= new\
    \ long[lst.length];\n    int index=0;\n    for (int i=0;i<=res.length/2;i++)\n\
    \    {\n        res[index]=even[i];\n        index++;\n        if (odd.length>(res.length/2))\n\
    \        {\n            res[index]=odd[i];\n            index++;\n        }\n\
    \    }\n    return res;\n}", "{\n    immutable len = lst.length;\n    if (len\
    \ == 0) \n    {\n        return lst;\n    }\n    else if (len == 1) \n    {\n\
    \        return lst;\n    }\n    else \n    {\n        auto tmp = sort(lst);\n\
    \        auto index = sequence(0, 2 * len, 2);\n        index = repeat(index)\
    \ ~ repeat(reverse(index));\n        index = index[0..len];\n        auto result\
    \ = new long[len];\n        foreach (i, j; index) \n        {\n            result[i]\
    \ = tmp[j];\n        }\n        return result;\n    }\n}", "{\n    long[] result\
    \ = new long[lst.length];\n    if (lst.length == 0) \n    {\n        return result;\n\
    \    }\n    if (lst.length == 1) \n    {\n        result[0] = lst[0];\n      \
    \  return result;\n    }\n    bool asc = true;\n    int index = 0;\n    while\
    \ (true) \n    {\n        long[] sorted = copy(lst);\n        sorted.sort(asc\
    \ ? (a, b) => a - b : (a, b) => b - a);\n        result[index] = sorted[0];\n\
    \        lst = sorted[1 .. $];\n        if (lst.length == 0) \n        {\n   \
    \         break;\n        }\n        index += 1;\n        asc = !asc;\n    }\n\
    \    return result;\n}\n/*\n    \n    See tests for examples.\n    You can run\
    \ tests with command:\n    $ dmd -run tests.d", "{\n    // create tuple of (value,\
    \ index) pairs\n    long[][] idx_pair = zip(lst, iota(lst.length)).array;\n  \
    \  // sort by value\n    idx_pair.sort!(\"a[0] < b[0]\");\n    // extract just\
    \ the indices\n    long[] idx = idx_pair.map!(\"a[1]\").array;\n    // we need\
    \ to invert odd indices\n    idx = invert(idx[1..$-1].byChunk(2));\n    // append\
    \ last index\n    idx ~= idx_pair[$-1][1];\n    // get the sorted array\n    lst[idx]\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    Tuple!(long[], long[])\
    \ both = tuple(lst.dup, lst.dup);\n    both[1].sort;\n    auto p = both[1].partition;\n\
    \    alias min = p[0];\n    alias max = p[1].reverse;\n    auto result = new long[][max.length\
    \ + min.length];\n    foreach (i, ref elem; result)\n    {\n        if (i % 2\
    \ == 0)\n            elem = min[i ~/ 2];\n        else\n            elem = max[i\
    \ ~/ 2];\n    }\n    return result;\n}", "{\n    if (lst.length == 0) return lst;\n\
    \    /*\n    long[] sorted = new long[lst.length];\n    while(sorted.length)\n\
    \    {\n        long min = min(lst);\n        long max = max(lst);\n        if\
    \ (sorted.length%2)\n        {\n            sorted ~= min;\n            lst =\
    \ lst.filter!(e=>e!=min);\n        }\n        else\n        {\n            sorted\
    \ ~= max;\n            lst = lst.filter!(e=>e!=max);\n        }\n    }\n    return\
    \ sorted;\n    */\n    return lst;\n}", "{\n    auto lstNew = lst.dup;\n    lstNew.sort;\n\
    \    lstNew.reverse;\n    return lstNew;\n}\n//by dalke", "{\n    if (lst.length\
    \ < 2) \n    {\n        return lst;\n    }\n    lst.sort;\n    auto lst_len =\
    \ lst.length;\n    auto int_range = iota(0, lst_len, 2);\n    auto even_range\
    \ = iota(1, lst_len - 1, 2);\n    auto res = new long[lst_len];\n    foreach (i,\
    \ lst_elem; zip(int_range, lst)) \n    {\n        res[i] = lst_elem;\n    }\n\
    \    foreach (i, lst_elem; zip(even_range, lst)) \n    {\n        res[i] = lst_elem;\n\
    \    }\n    return res;\n}", "{ \n  if (lst.length == 0) return new long[0];\n\
    \  if (lst.length == 1) return lst;\n  if (lst.length == 2)\n  {\n      if (lst[0]\
    \ < lst[1]) return lst;\n      return [lst[1], lst[0]];\n  }\n  long[] arr = new\
    \ long[lst.length];\n  int idx = 0;\n  if (lst[0] < lst[1]) \n  {\n      arr[idx++]\
    \ = lst[0];\n      arr[idx++] = lst[1];\n  }\n  else\n  {\n      arr[idx++] =\
    \ lst[1];\n      arr[idx++] = lst[0];\n  }\n  long[] _lst = lst[2..$];\n  while(_lst.length\
    \ > 0)\n  {\n      long vmax = max(_lst);\n      long vmin = min(_lst);\n    \
    \  _lst = _lst.filter!( (x) => x != vmax && x != vmin );\n      arr[idx++] = vmax;\n\
    \      arr[idx++] = vmin;\n  }\n  return arr;\n}\n ", "{\n    int len = lst.length;\n\
    \    if (len == 0) return lst;\n    int k = len / 2;\n    long[] odd = new long[k],\
    \ even = new long[len - k];\n    auto cmp = (a, b) => b < a;\n    auto sorter\
    \ = (a, b) => {\n        return a.sort!(cmp);\n    };\n    auto zipped = zip(lst.sort!(cmp).take(k),\
    \ lst.sort().skip(k));\n    foreach(it; zipped) \n    {\n        odd ~= it[0];\n\
    \        even ~= it[1];\n    }\n    return (odd.sort!(cmp) ~ even.sort()).array;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
