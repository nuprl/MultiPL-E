name: HumanEval_115_max_fill
language: d
prompt: "import std.math;\n/*\n\n    You are given a rectangular grid of wells. Each\
  \ row represents a single well,\n    and each 1 in a row represents a single unit\
  \ of water.\n    Each well has a corresponding bucket that can be used to extract\
  \ water from it, \n    and all buckets have the same capacity.\n    Your task is\
  \ to use the buckets to empty the wells.\n    Output the number of times you need\
  \ to lower the buckets.\n\n    Example 1:\n    >>> max_fill([[0L, 0L, 1L, 0L], [0L,\
  \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L)\n    6L\n\n    Example 2:\n    >>> max_fill([[0L,\
  \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L)\n    5L\n\
  \    \n    Example 3:\n    >>> max_fill([[0L, 0L, 0L], [0L, 0L, 0L]], 5L)\n    0L\n\
  \n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length\
  \ <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 |\
  \ 1\n        * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long\
  \ capacity) \n"
tests: "unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
  \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
  \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
  \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
  \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L,\
  \ 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
completions: ["{\n    long longest = 0L;\n    long highest = 0L;\n    foreach(row;\
    \ grid)\n    {\n        long tmp = 0L;\n        foreach(cell; row)\n        {\n\
    \            if(cell == 1L)\n            {\n                tmp++;\n         \
    \   }\n            else\n            {\n                if(tmp > longest)\n  \
    \              {\n                    longest = tmp;\n                }\n    \
    \            tmp = 0L;\n            }\n        }\n        if(tmp > longest)\n\
    \        {\n            longest = tmp;\n        }\n        highest++;\n    }\n\
    \    return highest * longest * capacity;\n}", "{\n    long result = 0L;\n   \
    \ long max_depth = grid.length;\n    long well_length = grid[0].length;\n    foreach(long[]\
    \ row; grid)\n    {\n        result += max_depth - arrayMax(row);\n    }\n   \
    \ return result * capacity;\n}", "{\n    long total_water = 0;\n    long capacity_per_bucket\
    \ = 0;\n    long buckets_per_well = 0;\n    long buckets_to_use = 0;\n    long\
    \ i = 0;\n    foreach(well; grid)\n    {\n        total_water += count(well, 1L);\n\
    \    }\n    buckets_per_well = (long)ceil(total_water / (double)capacity);\n \
    \   buckets_to_use = buckets_per_well * count(grid, 1L);\n    capacity_per_bucket\
    \ = (long)ceil(total_water / (double)buckets_to_use);\n    return capacity_per_bucket;\n\
    }", "{\n    long result = 0L;\n    for (long[] well : grid) \n    {\n        long\
    \ overflow = 0L;\n        for (long drop : well) \n        {\n            overflow\
    \ += drop;\n            if (overflow >= capacity) \n            {\n          \
    \      overflow -= capacity;\n                result++;\n            }\n     \
    \   }\n        result += overflow / capacity;\n        if (overflow % capacity\
    \ > 0) \n        {\n            result++;\n        }\n    }\n    return result;\n\
    }", "{\n    long max = 0L;\n    foreach(row; grid)\n    {\n        long c = 0L;\n\
    \        foreach(col; row)\n        {\n            if(col)\n            {\n  \
    \              c++;\n            }\n            else\n            {\n        \
    \        max = max(max, c);\n                c = 0L;\n            }\n        }\n\
    \        max = max(max, c);\n    }\n    return capacity * max;\n}\n/*\n    void\
    \ main()\n    {\n        long[][] grid1 = [[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L],\
    \ [1L, 1L, 1L, 1L]];\n        long[][] grid2 = [[0L, 0L, 1L, 1L], [0L, 0L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]];\n        long[][] grid3 = [[0L, 0L,\
    \ 0L], [0L, 0L, 0L]];\n        assert(max_fill(grid1, 1L) == 6L);\n        assert(max_fill(grid2,\
    \ 2L) == 5L);\n        assert(max_fill(grid3, 5L) == 0L);\n    }\n*/", "{\n  \
    \  auto max_water = 0L;\n    auto water_count = 0L;\n    foreach(i; grid)\n  \
    \  {\n        foreach(j; i)\n        {\n            if(j == 1)\n            {\n\
    \                water_count++;\n            }\n        }\n        if(water_count\
    \ > max_water)\n        {\n            max_water = water_count;\n        }\n \
    \       water_count = 0;\n    }\n    return max_water > capacity ? max_water/capacity\
    \ : 0;\n}", "{\n    long empties = 0;\n    long rows = grid.length;\n    long\
    \ columns = grid[0].length;\n    for (long j = 0; j < columns; j++)\n    {\n \
    \       long m = 0;\n        for (long i = 0; i < rows; i++)\n        {\n    \
    \        long x = grid[i][j];\n            if (x > 0)\n            {\n       \
    \         empties += x;\n                m = max(m, x);\n            }\n     \
    \   }\n        empties -= m;\n    }\n    return empties;\n}", "{\n    int rows\
    \ = grid.length;\n    int cols = grid[0].length;\n    int result = 0;\n    while\
    \ (true) {\n        long[][] buckets = new long[rows][cols];\n        long[][]\
    \ new_grid = new long[rows][cols];\n        foreach (int row; 0 .. rows) {\n \
    \           foreach (int col; 0 .. cols) {\n                if (grid[row][col]\
    \ == 1) {\n                    buckets[row][col] = capacity;\n               \
    \ }\n            }\n        }\n        if (buckets.length == 0) {\n          \
    \  break;\n        }\n        buckets = fill_down(buckets);\n        buckets =\
    \ fill_up(buckets);\n        buckets = fill_right(buckets);\n        buckets =\
    \ fill_left(buckets);\n        foreach (int row; 0 .. rows) {\n            foreach\
    \ (int col; 0 .. cols) {\n                new_grid[row][col] = grid[row][col]\
    \ - buckets[row][col];\n            }\n        }\n        grid = new_grid;\n \
    \       result += 1;\n    }\n    return result;\n}", "{\n    auto buckets = repeat(capacity,\
    \ grid.length);", "{\n    long current_water_amount = 0L;\n    long max_water_amount\
    \ = 0L;\n    long max_water_amount_pos = 0L;\n    long left_bucket_pos = 0L;\n\
    \    long right_bucket_pos = 0L;\n    long start_bucket_pos = 0L;\n    long max_line_height\
    \ = grid.length;\n    long line_length = grid[0].length;\n    long max_line_pos\
    \ = max_line_height - 1L;\n    long line_pos = 0L;\n    while (line_pos <= max_line_pos)\n\
    \    {\n        current_water_amount = 0L;\n        right_bucket_pos = start_bucket_pos;\n\
    \        while (right_bucket_pos < line_length)\n        {\n            current_water_amount\
    \ += grid[line_pos][right_bucket_pos];\n            if (current_water_amount ==\
    \ capacity)\n            {\n                left_bucket_pos = right_bucket_pos\
    \ - capacity + 1L;\n                break;\n            }\n            else if\
    \ (current_water_amount > capacity)\n            {\n                left_bucket_pos\
    \ = right_bucket_pos - capacity;\n                start_bucket_pos = left_bucket_pos\
    \ + 1L;\n                break;\n            }\n            else\n           \
    \ {\n                right_bucket_pos++;\n            }\n        }\n        if\
    \ (current_water_amount > max_water_amount)\n        {\n            max_water_amount\
    \ = current_water_amount;\n            max_water_amount_pos = left_bucket_pos;\n\
    \        }\n        if (right_bucket_pos == line_length)\n        {\n        \
    \    start_bucket_pos = 0L;\n            line_pos++;\n        }\n    }\n    return\
    \ max_water_amount_pos;\n}", "{\n    long[][] heights = new long[grid.length][grid[0].length];\n\
    \    auto max = 0L;\n    auto res = 0L;\n    // ---\n    foreach (row; 0 .. grid.length)\
    \ \n    {\n        foreach (column; 0 .. grid[0].length) \n        {\n       \
    \     if (grid[row][column] == 1) \n            {\n                heights[row][column]\
    \ = max + 1;\n                if (max < heights[row][column]) \n             \
    \   {\n                    max = heights[row][column];\n                }\n  \
    \          }\n        }\n    }\n    // ---\n    foreach (row; 0 .. grid.length)\
    \ \n    {\n        foreach (column; 0 .. grid[0].length) \n        {\n       \
    \     if (heights[row][column] < max) \n            {\n                res +=\
    \ max - heights[row][column];\n            }\n        }\n    }\n    // ---\n \
    \   return res / capacity;\n}\n/*", "{\n    long bucket_size = capacity;\n   \
    \ long start_index = 0;\n    long end_index = grid[0].length - 1;\n    long wells_count\
    \ = grid.length;\n    long bucket_count = 0;\n    while (bucket_size != 0) {\n\
    \        bucket_count += bucket_size;\n        // fill bucket with as much water\
    \ as you can\n        while (bucket_size != 0 && start_index <= end_index) {\n\
    \            long[] current_well = grid[0];\n            long current_well_value\
    \ = current_well[start_index];\n            // if there is less water in a well\
    \ than available in the bucket\n            if (current_well_value < bucket_size)\
    \ {\n                current_well[start_index] = 0;\n                bucket_size\
    \ -= current_well_value;\n                start_index++;\n            }\n    \
    \        // if there is more water in a well than available in the bucket\n  \
    \          else {\n                current_well[start_index] -= bucket_size;\n\
    \                bucket_size = 0;\n            }\n        }\n        // if bucket\
    \ is full, move it to the next well\n        if (bucket_size == 0) {\n       \
    \     bucket_size = capacity;\n            start_index = 0;\n            end_index\
    \ = grid[0].length - 1;\n            grid.remove(0);\n            wells_count--;\n\
    \        }\n        // if there is no water in the bucket, move on to the next\
    \ well\n        else {\n            bucket_size = 0;\n        }\n    }\n    return\
    \ bucket_count;\n}", "{\n    // maximum capacity of each well\n    // in order\
    \ to win the game\n    long max = (long)grid.length * capacity;", "{\n    long\
    \ noOfTimesBucketLowered = 0L;\n    for (long[] row : grid)\n    {\n        for\
    \ (long i = 0L; i < capacity; i++)\n        {\n            for (long j = 0L; j\
    \ < row.length; j++)\n            {\n                if (row[j] > 0L)\n      \
    \          {\n                    row[j] -= 1L;\n                    noOfTimesBucketLowered\
    \ += 1L;\n                }\n            }\n        }\n    }\n    return noOfTimesBucketLowered;\n\
    }", "{\n    long result = 0L;\n    for (size_t i = 0u; i < grid.length; ++i)\n\
    \    {\n        result += grid[i].length - grid[i].count(0L);\n    }\n    return\
    \ result / capacity;\n}", "{\n    long result = 0L;\n    int i = 0;\n    int j\
    \ = 0;\n    while (i < grid.length)\n    {\n        j = 0;\n        while (j <\
    \ grid[i].length)\n        {\n            if (grid[i][j] == 1L)\n            {\n\
    \                grid[i][j] = 0L;\n                result++;\n               \
    \ if (j + 1 < grid[i].length)\n                {\n                    if (grid[i][j\
    \ + 1] == 1L)\n                    {\n                        result++;\n    \
    \                    grid[i][j + 1] = 0L;\n                    }\n           \
    \     }\n                if (i + 1 < grid.length)\n                {\n       \
    \             if (grid[i + 1][j] == 1L)\n                    {\n             \
    \           result++;\n                        grid[i + 1][j] = 0L;\n        \
    \            }\n                }\n            }\n            j++;\n        }\n\
    \        i++;\n    }\n    return result;\n}", "{\n    const long rows = grid.length;\n\
    \    const long cols = grid[0].length;\n    long row_maxes[rows];\n    foreach\
    \ (row; 0 .. rows)\n    {\n        long max = 0;\n        foreach (col; 0 .. cols)\n\
    \        {\n            max = grid[row][col] > max ? grid[row][col] : max;\n \
    \       }\n        row_maxes[row] = max;\n    }\n    long result = 0;\n    foreach\
    \ (col; 0 .. cols)\n    {\n        long column_max = 0;\n        foreach (row;\
    \ 0 .. rows)\n        {\n            column_max = grid[row][col] > column_max\
    \ ? grid[row][col] : column_max;\n        }\n        result += column_max;\n \
    \       foreach (row; 0 .. rows)\n        {\n            if (row_maxes[row] <\
    \ column_max)\n            {\n                result += column_max - row_maxes[row];\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long rows =\
    \ grid.length;\n    long cols = grid[0].length;\n    long result = 0;\n    long\
    \ diff = 0;\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0;\
    \ j < cols; j++)\n        {\n            if (grid[i][j] == 1)\n            {\n\
    \                diff = capacity - grid[i][j];\n                result += diff;\n\
    \                grid[i][j] += diff;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    immutable const N = grid.length;\n    immutable const M\
    \ = grid[0].length;\n    long[N] row_buffer;\n    long times = 0;\n    for (size_t\
    \ i = 0; i < N; i++) {\n        row_buffer[i] = 0;\n    }\n    for (size_t j =\
    \ 0; j < M; j++) {\n        for (size_t i = 0; i < N; i++) {\n            if (grid[i][j]\
    \ > 0) {\n                if (row_buffer[i] < grid[i][j]) {\n                \
    \    row_buffer[i] += capacity;\n                    times++;\n              \
    \  }\n                row_buffer[i] -= grid[i][j];\n            }\n        }\n\
    \    }\n    return times;\n}", "{\n    long result = 0L;\n    foreach(row; grid)\n\
    \    {\n        long sum_w = 0L;\n        foreach(v; row)\n        {\n       \
    \     if(v == 1L)\n            {\n                sum_w++;\n            }\n  \
    \      }\n        if(sum_w == row.length)\n        {\n            result += capacity;\n\
    \        }\n        else\n        {\n            result += max(sum_w, capacity);\n\
    \        }\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
