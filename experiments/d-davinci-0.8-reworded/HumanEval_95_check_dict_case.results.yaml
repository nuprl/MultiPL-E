language: d
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{ \n    if(dict.isNull) return false;\n    int dict_length = dict.get.length;\n\
    \    if(dict_length == 0) return false;\n    bool is_upper_case = false;\n   \
    \ foreach(key; dict.get.keys)\n    {\n        if(key.length == 0) return false;\n\
    \        if(key.length > 1) is_upper_case = key[0].isUpper;\n        if(is_upper_case\
    \ && !key.isUpper) return false;\n        if(!is_upper_case && !key.isLower) return\
    \ false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfquo16dy.d(24): Error: cannot implicitly convert expression `_aaLen(dict.get())`
    of type `ulong` to `int`

    /tmp/tmpfquo16dy.d(30): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpfquo16dy.d(31): Error: no property `isUpper` for type `string`

    /tmp/tmpfquo16dy.d(32): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfquo16dy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null)\n        return false;\n    if(dict.length ==\
    \ 0)\n        return false;\n    auto keys = dict.keys;\n    auto b = any!(isUpper(keys[0][0]));\n\
    \    return !any!(isLower(keys[0][0])) == b;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb62g50lx.d(28): Error: template instance `any!(isUpper(keys[0][0]))`
    template `any` is not defined

    /tmp/tmpb62g50lx.d(29): Error: template instance `any!(isLower(keys[0][0]))` template
    `any` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb62g50lx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{ \n    if (dict.isNull)\n        return false;\n    \n    enum is_upper\
    \ = true;\n    enum is_lower = true;\n    //foreach (k, v; dict) {\n    for (auto\
    \ key : dict.keys) {\n        string k = key;\n        string v = dict[key];\n\
    \        is_upper = is_upper && k.toUpper() == k;\n        is_lower = is_lower\
    \ && k.toLower() == k;\n    }\n    return is_upper || is_lower;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb5fp2hpi.d(29): Error: no identifier for declarator `key`

    /tmp/tmpb5fp2hpi.d(29): Error: expression expected, not `:`

    /tmp/tmpb5fp2hpi.d(29): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5fp2hpi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164376
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null)\n        return false;\n    bool result = true;\n\
    \    bool upper;\n    foreach (k, v; dict)\n    {\n        if (k.length == 0)\
    \ \n        {\n            result = false;\n            break;\n        }\n  \
    \      if (upper == false && k[0].isUpper())\n        {\n            upper = true;\n\
    \        }\n        if (upper == true && k[0].isLower())\n        {\n        \
    \    result = false;\n            break;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwabfstz4.d(34): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpwabfstz4.d(38): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwabfstz4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    bool is_lower =\
    \ dict.keys[0].isLower;\n    bool is_upper = dict.keys[0].isUpper;\n    if (is_lower\
    \ || is_upper)\n    {\n        foreach (key; dict.keys)\n        {\n         \
    \   if (is_lower)\n            {\n                if (!key.isLower)\n        \
    \            return false;\n            }\n            else if (is_upper)\n  \
    \          {\n                if (!key.isUpper)\n                    return false;\n\
    \            }\n        }\n        return true;\n    }\n    return false;\n}\n\
    /*\n    Return the number of vowels in a given string.\n    The function should\
    \ return an integer.\n    Example:\n    >>> count_vowels(\"apple\".nullable)\n\
    \    2\n    >>> count_vowels(\"HELLO\".nullable)\n    2\n    >>> count_vowels(\"\
    fun\".nullable)\n    1\n    >>> count_vowels(\"123\".nullable)\n    0\n*/\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dmsu481.d(25): Error: no property `isLower` for type `string`

    /tmp/tmp1dmsu481.d(26): Error: no property `isUpper` for type `string`

    /tmp/tmp1dmsu481.d(33): Error: no property `isLower` for type `string`

    /tmp/tmp1dmsu481.d(38): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dmsu481.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null) return false;\n    string[] keys = dict.keys;\n\
    \    bool lower_case = true;\n    bool upper_case = true;\n    foreach (key; keys)\
    \ \n    {\n        if (lower_case) \n        {\n            if (key.length !=\
    \ key.toLower().length) \n            {\n                lower_case = false;\n\
    \            }\n        }\n        if (upper_case) \n        {\n            if\
    \ (key.length != key.toUpper().length) \n            {\n                upper_case\
    \ = false;\n            }\n        }\n        if (!lower_case && !upper_case)\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3qp13s_g.d(31): Error: no property `toLower` for type `string`

    /tmp/tmp3qp13s_g.d(38): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3qp13s_g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.isNull)\n        return false;\n    string[] keyList\
    \ = dict.get.keys.array;\n    bool allUpper = true;\n    bool allLower = true;\n\
    \    foreach(key; keyList) \n    {\n        if(isUpper(key))\n            allLower\
    \ = false;\n        else\n            allUpper = false;\n    }\n    return allUpper\
    \ || allLower;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_jwdcud1.d(25): Error: no property `array` for type `string[]`

    /tmp/tmp_jwdcud1.d(30): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_jwdcud1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) return false;\n    if(dict.empty) return false;\n\
    \    bool first_is_upper = dict.keys[0].isUpper;\n    foreach(key; dict.keys)\
    \ \n    {\n        if(key.isUpper == first_is_upper) continue;\n        return\
    \ false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3hj0bg57.d(24): Error: no property `empty` for type `Nullable!(string[string])`

    /tmp/tmp3hj0bg57.d(25): Error: no property `isUpper` for type `string`

    /tmp/tmp3hj0bg57.d(28): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3hj0bg57.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    string caseType;\n    if (dict is null) return false;\n    foreach\
    \ (key, value; dict)\n    {\n        if (is(typeof(key) == string))\n        {\n\
    \            if (caseType.empty)\n            {\n                if (key.isUpperCase)\n\
    \                    caseType = \"upper\";\n                else if (key.isLowerCase)\n\
    \                    caseType = \"lower\";\n                else\n           \
    \         return false;\n            }\n            else\n            {\n    \
    \            if (caseType == \"upper\" && !key.isUpperCase)\n                \
    \    return false;\n                else if (caseType == \"lower\" && !key.isLowerCase)\n\
    \                    return false;\n            }\n        }\n        else\n \
    \           return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptksis5w4.d(29): Error: no property `empty` for type `string`

    /tmp/tmptksis5w4.d(31): Error: no property `isUpperCase` for type `string`

    /tmp/tmptksis5w4.d(33): Error: no property `isLowerCase` for type `string`

    /tmp/tmptksis5w4.d(40): Error: no property `isUpperCase` for type `string`

    /tmp/tmptksis5w4.d(42): Error: no property `isLowerCase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptksis5w4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool isLowercase = true;\n    bool isUppercase = true;\n    if\
    \ (dict.isNull)\n        return false;\n    foreach (k, v; dict) \n    {\n   \
    \     isLowercase &= isAlpha(k[0]) && k.toLower == k;\n        isUppercase &=\
    \ isAlpha(k[0]) && k.toUpper == k;\n    }\n    return isLowercase || isUppercase;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ziuj1f_.d(29): Error: undefined identifier `isAlpha`

    /tmp/tmp4ziuj1f_.d(29): Error: no property `toLower` for type `string`

    /tmp/tmp4ziuj1f_.d(30): Error: undefined identifier `isAlpha`

    /tmp/tmp4ziuj1f_.d(30): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ziuj1f_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin\n{\n    import std.algorithm;\n    import std.ascii;\n    import\
    \ std.conv;\n    import std.range;\n    import std.regex;\n    import std.traits;\n\
    }\nbody\n{\n    auto result = dict.value\n        .all!\"a.isUpper\" || dict.value\n\
    \        .all!\"a.isLower\";\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl11txje4.d(33): Error: no property `value` for type `Nullable!(string[string])`,
    did you mean `std.typecons.Nullable!(string[string]).Nullable._value`?

    /tmp/tmpl11txje4.d(34): Error: no property `value` for type `Nullable!(string[string])`,
    did you mean `std.typecons.Nullable!(string[string]).Nullable._value`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl11txje4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin {\n    assert(dict !is null);\n}\nbody {\n    if (dict.isNull) return\
    \ false;\n    auto dict_keys = dict.keys.sort;\n    foreach (key; dict_keys) {\n\
    \        if (!isUpperCase(key) && !isLowerCase(key)) return false;\n    }\n  \
    \  if (dict_keys.length <= 1) return true;\n    if (isUpperCase(dict_keys[0]))\
    \ {\n        foreach (key; dict_keys)\n            if (!isUpperCase(key)) return\
    \ false;\n    } else {\n        foreach (key; dict_keys)\n            if (!isLowerCase(key))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4fxcoqnt.d(27): Error: no property `sort` for type `string[]`

    /tmp/tmp4fxcoqnt.d(32): Error: undefined identifier `isUpperCase`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4fxcoqnt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n    if (isInputRange!(typeof(dict)))\n{\n    if (dict is null) return\
    \ false;\n    /*\n        In Nim we can make a String to be upper or lower case\
    \ by adding\n        ^ to the front of it (see https://nim-lang.org/docs/manual.html#case-conversion)\n\
    \        so we can use that as a way to determine if all keys are upper or all\
    \ \n        keys are lower.\n        str.isupper seems to return false all the\
    \ time, so we can't use that.\n    */\n    // This is just a cheat to get us started,\
    \ this is not the answer\n    return dict.all!((pair) => pair.key.isupper);\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbfk0vbj8.d(22): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpbfk0vbj8.d(22): Error: declaration expected, not `if`

    /tmp/tmpbfk0vbj8.d(33): Error: declaration expected, not `return`

    /tmp/tmpbfk0vbj8.d(34): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbfk0vbj8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164376
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n    if(is(TypeOf!(dict) == Nullable!(string[string])))\n{\n    if(dict.isNull)\n\
    \        return false;\n    bool allUpper = true;\n    bool allLower = true;\n\
    \    foreach(key; dict.get.keys)\n    {\n        if(!allUpper)\n            break;\n\
    \        allUpper = !(allUpper && anyLower(key));\n    }\n    foreach(key; dict.get.keys)\n\
    \    {\n        if(!allLower)\n            break;\n        allLower = !(allLower\
    \ && anyUpper(key));\n    }\n    return (allUpper || allLower);\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsf21fmsg.d(22): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpsf21fmsg.d(22): Error: declaration expected, not `if`

    /tmp/tmpsf21fmsg.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpsf21fmsg.d(28): Error: no identifier for declarator `dict.get.keys`

    /tmp/tmpsf21fmsg.d(28): Error: declaration expected, not `)`

    /tmp/tmpsf21fmsg.d(32): Error: no identifier for declarator `allUpper`

    /tmp/tmpsf21fmsg.d(32): Error: declaration expected, not `=`

    /tmp/tmpsf21fmsg.d(33): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsf21fmsg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164376
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return false;\n    string[] ks = dict.keys();\n\
    \    if (ks.length == 0) return false;\n    bool is_lower = true;\n    bool is_upper\
    \ = true;\n    foreach (int k; ks) {\n        if (is_lower && k >= 'A' && k <=\
    \ 'Z')\n            is_lower = false;\n        if (is_upper && k >= 'a' && k <=\
    \ 'z')\n            is_upper = false;\n    }\n    return is_lower || is_upper;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpel2rnt6m.d(28): Error: cannot implicitly convert expression `__r75[__key76]`
    of type `string` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpel2rnt6m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    bool lower = dict.byKey.all!(k\
    \ => k.all!(c => c.isLower));\n    bool upper = dict.byKey.all!(k => k.all!(c\
    \ => c.isUpper));\n    return lower || upper;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwtjeyo1x.d(25): Error: no property `all` for type `Result`

    /tmp/tmpwtjeyo1x.d(26): Error: no property `all` for type `Result`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwtjeyo1x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    else if (dict.length ==\
    \ 0) return false;\n    bool isLower = dict.keys[0].isLower;\n    foreach (k,\
    \ v; dict)\n    {\n        if (k.isLower != isLower) return false;\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkucjdfwq.d(25): Error: no property `isLower` for type `string`

    /tmp/tmpkucjdfwq.d(28): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkucjdfwq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    static immutable digitR = appender!(Chain)(\"0\" .. \"9\");\n\
    \    static immutable upperR = appender!(Chain)(\"A\" .. \"Z\");\n    static immutable\
    \ lowerR = appender!(Chain)(\"a\" .. \"z\");\n    bool lower = true;\n    bool\
    \ upper = true;\n    if (dict is null)\n        return false;\n    foreach (key;\
    \ dict.keys)\n    {\n        foreach (ch; key)\n        {\n            if (digitR.canFind(ch))\n\
    \                return false;\n            if (lowerR.canFind(ch))\n        \
    \        upper = false;\n            if (upperR.canFind(ch))\n               \
    \ lower = false;\n        }\n    }\n    return lower || upper;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl8lvgsgw.d(23): Error: found `..` when expecting `,`

    /tmp/tmpl8lvgsgw.d(24): Error: found `..` when expecting `,`

    /tmp/tmpl8lvgsgw.d(25): Error: found `..` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl8lvgsgw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164376
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return false;\n    else \n    {\n        string[]\
    \ keys = dict.isNull ? [] : dict.get.keys;\n        if (keys.length == 0) return\
    \ false;\n        bool allLowerCase = true;\n        bool allUpperCase = true;\n\
    \        foreach (key; keys)\n        {\n            if (key.isLower) allUpperCase\
    \ = false;\n            else if (key.isUpper) allLowerCase = false;\n        \
    \    else return false;\n        }\n        return allLowerCase || allUpperCase;\n\
    \    }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfe052pry.d(32): Error: no property `isLower` for type `string`

    /tmp/tmpfe052pry.d(33): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfe052pry.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    if (dict is null) \n    {\n        return false;\n    }\n\
    \    int lower = 0;\n    int upper = 0;\n    foreach (key; dict.keys) \n    {\n\
    \        if (key.isLower) \n        {\n            lower++;\n        }\n     \
    \   else if (key.isUpper) \n        {\n            upper++;\n        }\n     \
    \   else \n        {\n            return false;\n        }\n    }\n    if (lower\
    \ == 0 || upper == 0) \n    {\n        return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1lxuqn_j.d(32): Error: no property `isLower` for type `string`

    /tmp/tmp1lxuqn_j.d(36): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1lxuqn_j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) \n    {\n        return false;\n    }\n    if(dict.length\
    \ == 0) \n    {\n        return false;\n    }\n    bool all_keys_lower = true;\n\
    \    foreach(key; dict.keys) \n    {\n        if(key.isLowerCase) \n        {\n\
    \            continue;\n        }\n        all_keys_lower = false;\n        break;\n\
    \    }\n    if(all_keys_lower) \n    {\n        return true;\n    }\n    else\
    \ \n    {\n        bool all_keys_upper = true;\n        foreach(key; dict.keys)\
    \ \n        {\n            if(key.isUpperCase) \n            {\n             \
    \   continue;\n            }\n            all_keys_upper = false;\n          \
    \  break;\n        }\n        return all_keys_upper;\n    }\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp758o9nc9.d(34): Error: no property `isLowerCase` for type `string`

    /tmp/tmp758o9nc9.d(50): Error: no property `isUpperCase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp758o9nc9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.isNull)\n        return false;\n    import std.string;\n\
    \    string key;\n    foreach(key;dict.data.keys)\n    {\n        if(key.length\
    \ <= 0)\n            return false;\n        if(key[0].isUpper!(\"\")!is(typeof(key[0])))\n\
    \            return false;\n        if(key[0].isLower!(\"\")!is(typeof(key[0])))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0i1wvj2g.d(27): Error: no property `data` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0i1wvj2g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) \n    {\n        return false;\n    }\n    bool\
    \ lower = true;\n    bool upper = true;\n    foreach(key; dict.keys) \n    {\n\
    \        if(key.isUpper) \n        {\n            lower = false;\n        }\n\
    \        else if(key.isLower) \n        {\n            upper = false;\n      \
    \  }\n        else \n        {\n            return false;\n        }\n    }\n\
    \    return lower || upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk9dxxpqb.d(31): Error: no property `isUpper` for type `string`

    /tmp/tmpk9dxxpqb.d(35): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk9dxxpqb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null)\n        return false;\n    \n    bool expected\
    \ = true;\n    bool gotString = false;\n    bool gotUpper = false;\n    bool gotLower\
    \ = false;\n    foreach(string key, string value; dict)\n    {\n        if(isUpper(key[0]))\n\
    \            gotUpper = true;\n        else if(isLower(key[0]))\n            gotLower\
    \ = true;\n        \n        if(gotUpper && gotLower)\n            return false;\n\
    \        \n        gotString = true;\n    }\n    \n    if(gotString)\n       \
    \ return true;\n    else\n        return false;\n}\n/*\n    Given a dictionary\
    \ which represent the weather, the key is a string of the \n    city, the value\
    \ is a tuple of the max and min temperature.\n    Return a new dictionary which\
    \ contains only the city that has temperature \n    higher than 80, and the value\
    \ is the difference between the max and min \n    temperature.\n    The difference\
    \ can be negative, in this case, just remove the city from the\n    new dictionary.\n\
    \    Examples:\n    >>> city_to_temp = [\"New York\": (74, 66), \"Berlin\": (44,\
    \ 29), \"London\": (90, 77), \"Johannesburg\": (87, 59)].nullable\n    >>> temp_diff_dict(city_to_temp)\n\
    \    [\"London\": 13, \"Johannesburg\": 28]\n*/\nNullable!(string[int]) temp_diff_dict(Nullable!(string[(int,\
    \ int)]) city_to_temp) \n{\n    if(city_to_temp is null)\n        return null;\n\
    \        \n    auto result = new string[int];\n    foreach(string city, (int min,\
    \ int max) values; city_to_temp)\n    {\n        if(max > 80)\n            result[city]\
    \ = max - min;\n    }\n    \n    return result;\n}\n/*\n    Given an array which\
    \ contains the information of the student ID and their \n    grade. The student\
    \ ID is a string, and the grade is an array of strings.\n    Return a new array\
    \ which contains the student\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpic8h5rpo.d(61): Error: found `,` when expecting `.` following int

    /tmp/tmpic8h5rpo.d(61): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpic8h5rpo.d(66): Error: need size of rightmost array, not type `int`

    /tmp/tmpic8h5rpo.d(67): Error: basic type expected, not `(`

    /tmp/tmpic8h5rpo.d(67): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpic8h5rpo.d(67): Error: no identifier for declarator `_error_(int min,
    int max)`

    /tmp/tmpic8h5rpo.d(67): Error: found `values` when expecting `;`

    /tmp/tmpic8h5rpo.d(67): Error: expression expected, not `;`

    /tmp/tmpic8h5rpo.d(67): Error: found `city_to_temp` when expecting `)`

    /tmp/tmpic8h5rpo.d(67): Error: found `)` instead of statement

    /tmp/tmpic8h5rpo.d(73): Error: declaration expected, not `return`

    /tmp/tmpic8h5rpo.d(74): Error: unrecognized declaration

    /tmp/tmpic8h5rpo.d(75): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpic8h5rpo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164376
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) return false;\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu2gsp38n.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu2gsp38n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164376
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) return false;\n    bool all_uppercase = true;\n\
    \    bool all_lowercase = true;\n    foreach(key; dict.keys)\n    {\n        if(key.length\
    \ == 0) return false;\n        foreach(ch; key)\n        {\n            if(ch.isUpper)\n\
    \            {\n                all_lowercase = false;\n            }\n      \
    \      else if(ch.isLower)\n            {\n                all_uppercase = false;\n\
    \            }\n            else\n            {\n                return false;\n\
    \            }\n        }\n    }\n    return all_uppercase || all_lowercase;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxob6he43.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpxob6he43.d(35): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxob6he43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int upperCase = 0;\n    foreach(key; dict.keys)\n    {\n    \
    \    if(!key.isUpperCase)\n        {\n            upperCase = -1;\n          \
    \  break;\n        }\n    }\n    if(upperCase==0)\n        return true;\n    foreach(key;\
    \ dict.keys)\n    {\n        if(!key.isLowerCase)\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc25s_utx.d(26): Error: no property `isUpperCase` for type `string`

    /tmp/tmpc25s_utx.d(36): Error: no property `isLowerCase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc25s_utx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = false;\n    if(dict.isNull) \n    {\n        return\
    \ result;\n    }\n    else \n    {\n        bool isUpper = true;\n        bool\
    \ isLower = true;\n        foreach(key; dict.get.keys) \n        {\n         \
    \   isUpper &= isUpper(key);\n            isLower &= isLower(key);\n        }\n\
    \        result = isUpper || isLower;\n    }\n    return result;\n}\nstatic assert(check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable));\nstatic assert(!check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable));\nstatic assert(!check_dict_case([\"\
    a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable));\nstatic assert(!check_dict_case([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable));\nstatic\
    \ assert(check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable));\n\
    \ \n \nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph4q4onsv.d(34): Error: function expected before `()`, not `isUpper`
    of type `bool`

    /tmp/tmph4q4onsv.d(35): Error: function expected before `()`, not `isLower` of
    type `bool`

    /tmp/tmph4q4onsv.d(41):        called from here: `check_dict_case(nullable(["a":"apple",
    "b":"banana"]))`

    /tmp/tmph4q4onsv.d(41):        while evaluating: `static assert(check_dict_case(nullable(["a":"apple",
    "b":"banana"])))`

    /tmp/tmph4q4onsv.d(42): Error: CTFE failed because of previous errors in `check_dict_case`

    /tmp/tmph4q4onsv.d(42):        while evaluating: `static assert(!check_dict_case(nullable(["a":"apple",
    "A":"banana", "B":"banana"])))`

    /tmp/tmph4q4onsv.d(43): Error: incompatible types for `("a") : (8L)`: `string`
    and `long`

    /tmp/tmph4q4onsv.d(43):        while evaluating: `static assert(!check_dict_case(["a":"apple",
    8L:"banana", "a":"apple"].nullable))`

    /tmp/tmph4q4onsv.d(44): Error: CTFE failed because of previous errors in `check_dict_case`

    /tmp/tmph4q4onsv.d(44):        while evaluating: `static assert(!check_dic'
  stdout: ''
  timestamp: 1660164376
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    foreach (key, value; dict)\
    \ \n    {\n        if (key is string) \n        {\n            if (isUpperCase(key)\
    \ && !isUpperCase(key)) return false;\n            if (isLowerCase(key) && !isLowerCase(key))\
    \ return false;\n        }\n        else return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1_d97seh.d(28): Error: undefined identifier `isUpperCase`

    /tmp/tmp1_d97seh.d(28): Error: undefined identifier `isUpperCase`

    /tmp/tmp1_d97seh.d(29): Error: undefined identifier `isLowerCase`

    /tmp/tmp1_d97seh.d(29): Error: undefined identifier `isLowerCase`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_d97seh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n    if (is(typeof(dict) == Nullable!(string[string])))\n{\n    static\
    \ if (is(typeof(dict) == Nullable!(string[string])))\n    {\n        if (dict\
    \ is null)\n        {\n            return false;\n        }\n        else if (dict.length\
    \ == 0)\n        {\n            return false;\n        }\n        else\n     \
    \   {\n            string[] keys = dict.keys;\n            string[] values = dict.values;\n\
    \            bool flag = true;\n            for (int i = 0; i < keys.length; i++)\n\
    \            {\n                static if (is(typeof(keys[i]) == string))\n  \
    \              {\n                    static if (keys[i].toLower() == keys[i])\n\
    \                    {\n                        static if (values[i].toLower()\
    \ == values[i])\n                        {\n                            flag =\
    \ true;\n                        }\n                        else\n           \
    \             {\n                            flag = false;\n                 \
    \           break;\n                        }\n                    }\n       \
    \             else if (keys[i].toUpper() == keys[i])\n                    {\n\
    \                        static if (values[i].toUpper() == values[i])\n      \
    \                  {\n                            flag = true;\n             \
    \           }\n                        else\n                        {\n     \
    \                       flag = false;\n                            break;\n  \
    \                      }\n                    }\n                    else\n  \
    \                  {\n                        flag = false;\n                \
    \        break;\n                    }\n                }\n                else\n\
    \                {\n                    flag = false;\n                    break;\n\
    \                }\n            }\n            return flag;\n        }\n    }\n\
    \    else\n    {\n        static assert(0, \"dict is not an associative array\"\
    );\n    }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v5t8zyf.d(22): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmp2v5t8zyf.d(22): Error: declaration expected, not `if`

    /tmp/tmp2v5t8zyf.d(29): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v5t8zyf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) return false;\n    bool are_keys_lower = false;\n\
    \    bool are_keys_upper = false;\n    foreach(key; dict.keys)\n    {\n      \
    \  if(key.isUpper)\n        {\n            are_keys_upper = true;\n        }\n\
    \        else if(key.isLower)\n        {\n            are_keys_lower = true;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    return are_keys_lower ^ are_keys_upper;\n}\n/*\n    The function takes\
    \ a two-dimensional array and returns the sum of all \n    the numbers in the\
    \ array.\n    Examples:\n    >>> sum_of_numbers([[1, 2, 3], [1, 2, 3]].nullable)\n\
    \    12\n    >>> sum_of_numbers([[1, 2, 3], [4, 5, 6]].nullable)\n    21\n   \
    \ >>> sum_of_numbers([[1, 2, 3], [4, 5, 6], [7, 8, 9]].nullable)\n    45\n   \
    \ >>> sum_of_numbers([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]].nullable)\n\
    \    78\n    >>> sum_of_numbers([].nullable)\n    0\n*/\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_6cbmnt7.d(28): Error: no property `isUpper` for type `string`

    /tmp/tmp_6cbmnt7.d(32): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_6cbmnt7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin {\n    assert(dict !is null);\n} \nbody {\n    assert(dict !is null);\n\
    \    if (dict.isNull) return false;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3gjaqoy.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3gjaqoy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin\n{\n    assert(!dict.isNull);\n}\nbody\n{\n    return dict.length\
    \ == 0 ? \n        false : \n        dict.all!(kv => kv.key.toLower() == kv.key\
    \ || kv.key.toUpper() == kv.key);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpomsg67zx.d(30): Error: no property `all` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpomsg67zx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // your code here\n    bool isUpperCase = true;\n    bool isLowerCase\
    \ = true;\n    foreach(key, value; dict)\n    {\n        if(!std.ascii.isUpper(key[0]))\n\
    \        {\n            isUpperCase = false;\n        }\n        if(!std.ascii.isLower(key[0]))\n\
    \        {\n            isLowerCase = false;\n        }\n    }\n    return isUpperCase\
    \ || isLowerCase;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9sxfq0qx.d(28): Error: undefined identifier `ascii` in package
    `std`

    /tmp/tmp9sxfq0qx.d(32): Error: undefined identifier `ascii` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9sxfq0qx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    foreach (key; dict.keys) \n    {\n        if (key.length\
    \ == 0)\n            return false;\n        if (key[0].isUpper)\n            lower\
    \ = false;\n        if (key[0].isLower)\n            upper = false;\n    }\n \
    \   return lower || upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn2fnowo8.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpn2fnowo8.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn2fnowo8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    string[] keys =\
    \ dict.keys;\n    if (keys.length == 0)\n        return false;\n    return keys.every!(a\
    \ => a.isUpper).any && \n           keys.every!(a => a.isLower).any;\n}\n/*\n\
    \    Given an associative array where all keys are strings, return a new \n  \
    \  associative array where the case of the keys is changed.\n    In case the given\
    \ associative array is empty, return the same.\n    Examples:\n    >>> change_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    [\"A\": \"apple\", \"B\": \"\
    banana\"]\n    >>> change_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable)\n    [\"a\": \"apple\", \"a\": \"banana\", \"b\": \"banana\"\
    ]\n    >>> change_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"\
    ].nullable)\n    [\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"]\n    >>>\
    \ change_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable)\n    [\"nAME\": \"John\", \"aGE\": \"36\", \"cITY\": \"Houston\"]\n\
    \    >>> change_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n\
    \    [\"state\": \"NC\", \"zip\": \"12345\"]\n*/\nstring[string] change_dict_case(Nullable!(string[string])\
    \ dict)\n{\n    if (dict is null)\n        return [];\n    string[] keys = dict.keys;\n\
    \    if (keys.length == 0)\n        return [];\n    string[string] ret;\n    foreach\
    \ (k; keys)\n    {\n        if (k.isUpper)\n            ret[k.toLower] = dict[k];\n\
    \        else\n            ret[k.toUpper] = dict[k];\n    }\n    return ret;\n\
    }\n/*\n   \nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjkiyohe4.d(64): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjkiyohe4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict.isNull || dict.get.all!((k, v) => k.isLower || k.isUpper);\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0pnlcw71.d(23): Error: no property `all` for type `string[string]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0pnlcw71.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result;\n    // all keys must be strings\n    foreach(key;\
    \ dict.keys)\n    {\n        if(!is(typeof(key) == string)) return false;\n  \
    \  }\n    // check if all keys are uppercase or lowercase\n    result = dict.keys.all!(a\
    \ => a.toUpper() == a);\n    if(result) return true;\n    result = dict.keys.all!(a\
    \ => a.toLower() == a);\n    if(result) return true;\n    return false;\n}\n \n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpspo83n37.d(30): Error: no property `all` for type `string[]`

    /tmp/tmpspo83n37.d(32): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpspo83n37.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ int lowerCount = 0;\n    int upperCount = 0;\n    foreach (key; dict.keys) \n\
    \    {\n        if (key.isUpper) \n        {\n            upperCount++;\n    \
    \    }\n        else if (key.isLower) \n        {\n            lowerCount++;\n\
    \        }\n        else \n        {\n            return false;\n        }\n \
    \   }\n    return (lowerCount == 0 || upperCount == 0);\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2xz_1czx.d(31): Error: no property `isUpper` for type `string`

    /tmp/tmp2xz_1czx.d(35): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2xz_1czx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n    if (is(typeof(dict)))\n{\n    return dict == null || dict.all!((k,\
    \ v) => to.upper(k) == k || to.lower(k) == k);\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8n6naazk.d(22): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmp8n6naazk.d(22): Error: declaration expected, not `if`

    /tmp/tmp8n6naazk.d(25): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8n6naazk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool b = true;\n    if (dict is null)\n        return false;\n\
    \    //set!(string) keys = (dict.keys);\n    foreach (k; dict.keys)\n    {\n \
    \       auto ck = k.toLower();\n        if (ck != k)\n        {\n            b\
    \ = false;\n            break;\n        }\n    }\n    if (b)\n        return true;\n\
    \    foreach (k; dict.keys)\n    {\n        auto ck = k.toUpper();\n        if\
    \ (ck != k)\n        {\n            b = false;\n            break;\n        }\n\
    \    }\n    return b;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgswd0c3y.d(29): Error: no property `toLower` for type `string`

    /tmp/tmpgswd0c3y.d(40): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgswd0c3y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return false;\n    else if (dict.isEmpty) return\
    \ false;\n    else \n    {\n        /* \n            Here we are using built-in\
    \ function isUpper to check if the first \n            character of the first\
    \ value of the given associative array is \n            upper case. If yes, then\
    \ we will check all values of the dictionary \n            whether all keys are\
    \ upper case or not.\n            If the first character of the first value of\
    \ the given associative \n            array is not upper case, then we will check\
    \ all values of the \n            dictionary whether all keys are lower case or\
    \ not.\n        */\n        if (dict.values[0].isUpper)\n        {\n         \
    \   return dict.values.all!(k => k.isUpper);\n        }\n        else\n      \
    \  {\n            return dict.values.all!(k => k.isLower);\n        }\n    }\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_pptsm5l.d(24): Error: no property `isEmpty` for type `Nullable!(string[string])`

    /tmp/tmp_pptsm5l.d(36): Error: no property `isUpper` for type `string`

    /tmp/tmp_pptsm5l.d(38): Error: no property `all` for type `string[]`

    /tmp/tmp_pptsm5l.d(42): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_pptsm5l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null) return false;\n    // return dict.all!(k =>\
    \ k.isUpper).all!(k => k.isLower);\n    return true;\n}\n \nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf_ye24nv.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x4577a9]

    ??:? void tmpf_ye24nv.__unittest_L28_C1() [0x442253]

    ??:? void tmpf_ye24nv.__modtest() [0x4552b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460afb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456dd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c4a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c534]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c431]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456dad]

    ??:? runModuleUnitTests [0x4608d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458bb4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool flag = true;\n    int cnt = 0;\n    bool is_key_upper;\n\
    \    bool is_key_lower;\n    foreach(string key, value; dict)\n    {\n       \
    \ cnt++;\n        is_key_upper = isUpper(key);\n        is_key_lower = isLower(key);\n\
    \        if(!is_key_upper && !is_key_lower) \n        {\n            flag = false;\n\
    \            break;\n        }\n        if(cnt == 1) \n        {\n           \
    \ if(is_key_upper) flag = true;\n            else flag = false;\n        }\n \
    \       else \n        {\n            if(is_key_upper && !flag) break;\n     \
    \       if(is_key_lower && flag) break;\n        }\n    }\n    return flag;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0664jvnv.d(30): Error: undefined identifier `isUpper`

    /tmp/tmp0664jvnv.d(31): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0664jvnv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool isLower = false;\n    bool isUpper = false;\n    bool res\
    \ = true;\n    if (dict.isNull) return false;\n    foreach (key, value; dict)\n\
    \    {\n        if (key.isLower)\n        {\n            isLower = true;\n   \
    \     }\n        else if (key.isUpper)\n        {\n            isUpper = true;\n\
    \        }\n        else \n        {\n            res = false;\n            break;\n\
    \        }\n    }\n    return isLower || isUpper;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_nmx3x5g.d(29): Error: no property `isLower` for type `string`

    /tmp/tmp_nmx3x5g.d(33): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_nmx3x5g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin {\n    assert(dict.isNull);\n}\nout (result) \nin {\n    assert(result\
    \ == false);\n}\nbody {\n    immutable result = true;\n    if (dict !is null)\
    \ {\n        auto key = dict.keys.front;\n        if (key !is null) {\n      \
    \      immutable char_type = islower(key[0]);\n            if (char_type != null)\
    \ {\n                foreach (key; dict.keys) {\n                    if (char_type\
    \ != islower(key[0])) {\n                        result = false;\n           \
    \             break;\n                    }\n                }\n            }\
    \ else {\n                result = false;\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2dep8of6.d(26): Error: statement expected to be `{ }`, not `in`

    /tmp/tmp2dep8of6.d(26): Error: found `in` instead of statement

    /tmp/tmp2dep8of6.d(28): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2dep8of6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164377
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto keys = dict.keys();\n    if(keys.length == 0) \n    {\n\
    \        return false;\n    }\n    bool is_upper = (keys[0][0] >= 'A' && keys[0][0]\
    \ <= 'Z');\n    foreach(index, key; keys) \n    {\n        if(is_upper) \n   \
    \     {\n            if(key[0] < 'A' || key[0] > 'Z') \n            {\n      \
    \          return false;\n            }\n        }\n        else \n        {\n\
    \            if(key[0] < 'a' || key[0] > 'z') \n            {\n              \
    \  return false;\n            }\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp72_prq7.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x457b31]

    ??:? void tmpp72_prq7.__unittest_L48_C1() [0x4426b7]

    ??:? void tmpp72_prq7.__modtest() [0x455640]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460f77]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x45715e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c921]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c9b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c8ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x457135]

    ??:? runModuleUnitTests [0x460d4d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x459030]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) \n    {\n        return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr9qf8rzj.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x457729]

    ??:? void tmpr9qf8rzj.__unittest_L29_C1() [0x4421f3]

    ??:? void tmpr9qf8rzj.__modtest() [0x455234]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c425]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c4b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c3b1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d2d]

    ??:? runModuleUnitTests [0x460851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b34]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    /*\n    bool lower = false;\n    bool upper = false;\n    foreach(key;\
    \ dict.keys)\n    {\n        string s = key;\n        if(s.isLower)\n        {\n\
    \            lower = true;\n        }\n        else if(s.isUpper)\n        {\n\
    \            upper = true;\n        }\n        else\n        {\n            return\
    \ false;\n        }\n    }\n    return (lower && !upper) || (!lower && upper);\n\
    \    */\n    if(dict is null)\n    {\n        return false;\n    }\n    bool allUpper\
    \ = true;\n    bool allLower = true;\n    foreach(key; dict.keys)\n    {\n   \
    \     if(key.isUpper)\n        {\n            allLower = false;\n        }\n \
    \       else if(key.isLower)\n        {\n            allUpper = false;\n     \
    \   }\n        else\n        {\n            return false;\n        }\n    }\n\
    \    return allUpper || allLower;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcb8txh83.d(52): Error: no property `isUpper` for type `string`

    /tmp/tmpcb8txh83.d(56): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcb8txh83.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.algorithm;\n    import std.array;\n    import std.range;\n\
    \    import std.traits;\n    import std.typecons;\n    import std.meta;\n    import\
    \ std.string;\n    import std.conv;\n    import std.exception;\n    import std.range;\n\
    \    import std.typecons;\n    import std.algorithm;\n    import std.ascii;\n\
    \    import std.array;\n    import std.stdio;\n    import std.math;\n    import\
    \ std.typecons;\n    bool check_dict_case(Nullable!(string[string]) dict)\n  \
    \  {\n        return dict.aFilter!((x) => (x.isUpper && !x.isDigit) || (x.isLower\
    \ && !x.isDigit))\n                  .equal!(dict.aFilter!((x) => (x.isLower &&\
    \ !x.isDigit) || (x.isUpper && !x.isDigit)));\n    }\n    return dict.aFilter!((x)\
    \ => (x.isUpper && !x.isDigit) || (x.isLower && !x.isDigit))\n              .equal!(dict.aFilter!((x)\
    \ => (x.isLower && !x.isDigit) || (x.isUpper && !x.isDigit)));\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp99a0knk3.d(42): Error: no property `aFilter` for type `Nullable!(string[string])`

    /tmp/tmp99a0knk3.d(45): Error: no property `aFilter` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp99a0knk3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool lower = true;\n    bool upper = true;\n    if (dict is null)\
    \ return false;\n    foreach (k,v; dict)\n    {\n        if (k.length == 0) continue;\n\
    \        if (k[0].isUpperCase())\n        {\n            lower = false;\n    \
    \    }\n        else if (k[0].isLowerCase())\n        {\n            upper = false;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    return lower || upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v1inu7z.d(29): Error: no property `isUpperCase` for type `immutable(char)`

    /tmp/tmp0v1inu7z.d(33): Error: no property `isLowerCase` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v1inu7z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(dict is null) return false;\n\tenum is_lower = true;\n\tforeach(const\
    \ key; dict.keys)\n\t{\n\t\tif(key.length == 0)\n\t\t\treturn false;\n\t\tif(is_lower\
    \ && key[0].isUpper)\n\t\t\tis_lower = false;\n\t\telse if(!is_lower && key[0].isLower)\n\
    \t\t\treturn false;\n\t}\n\treturn true;\n}\n//test:\nunittest\n{\n\tauto dict\
    \ = [\"a\": \"apple\", \"b\": \"banana\"].nullable;\n\tassert(check_dict_case(dict));\n\
    \tdict = [\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable;\n\t\
    assert(!check_dict_case(dict));\n\tdict = [\"a\": \"apple\", 8L: \"banana\", \"\
    a\": \"apple\"].nullable;\n\tassert(!check_dict_case(dict));\n\tdict = [\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable;\n\tassert(!check_dict_case(dict));\n\
    \tdict = [\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable;\n\tassert(check_dict_case(dict));\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptwq9jg2i.d(29): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmptwq9jg2i.d(30): Error: cannot modify constant `is_lower`

    /tmp/tmptwq9jg2i.d(31): Error: no property `isLower` for type `immutable(char)`

    /tmp/tmptwq9jg2i.d(43): Error: incompatible types for `("a") : (8L)`: `string`
    and `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptwq9jg2i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull || !dict.keyValue.length) \n    {\n        return\
    \ false;\n    }\n    if (dict.keyValue.tupleof[0][0].isUpper) \n    {\n      \
    \  foreach (key,value; dict.keyValue) \n        {\n            if (key.isLower)\n\
    \            {\n                return false;\n            }\n        }\n    }\
    \ \n    else if (dict.keyValue.tupleof[0][0].isLower) \n    {\n        foreach\
    \ (key,value; dict.keyValue) \n        {\n            if (key.isUpper)\n     \
    \       {\n                return false;\n            }\n        }\n    } \n \
    \   else \n    {\n        return false;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp15cck5_e.d(23): Error: no property `keyValue` for type `Nullable!(string[string])`

    /tmp/tmp15cck5_e.d(27): Error: no property `keyValue` for type `Nullable!(string[string])`

    /tmp/tmp15cck5_e.d(29): Error: no property `keyValue` for type `Nullable!(string[string])`

    /tmp/tmp15cck5_e.d(37): Error: no property `keyValue` for type `Nullable!(string[string])`

    /tmp/tmp15cck5_e.d(39): Error: no property `keyValue` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp15cck5_e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    import std.algorithm : any,\
    \ count;\n    if (dict.isEmpty) return false;\n    string[] keys = dict.keys.array;\n\
    \    if (keys.any!(e => e[0].isUpper))\n    {\n        return keys.all!(e => e.isUpper);\n\
    \    }\n    else\n    {\n        return keys.all!(e => e.isLower);\n    }\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5rysg8o9.d(25): Error: no property `isEmpty` for type `Nullable!(string[string])`

    /tmp/tmp5rysg8o9.d(26): Error: no property `array` for type `string[]`

    /tmp/tmp5rysg8o9.d(27): Error: template `tmp5rysg8o9.check_dict_case.any!((e)
    => e[0].isUpper).any` cannot deduce function from argument types `!()(string[])`,
    candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(169):        `tmp5rysg8o9.check_dict_case.any!((e)
    => e[0].isUpper).any(Range)(Range range) if (isInputRange!Range && is(typeof(unaryFun!pred(range.front))))`

    /tmp/tmp5rysg8o9.d(29): Error: no property `all` for type `string[]`

    /tmp/tmp5rysg8o9.d(33): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5rysg8o9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    assert(dict !is null);\n    static if (is(ValueType!(dict) ==\
    \ string)) \n    {\n        static if (hasLength!dict) \n        {\n         \
    \   foreach (key; dict.keys) \n            {\n                if (to!string(key).toLowerCase()\
    \ != key && to!string(key).toUpperCase() != key)\n                    return false;\n\
    \            }\n            return true;\n        }\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeme482z5.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x457731]

    ??:? void tmpeme482z5.__unittest_L38_C1() [0x442109]

    ??:? void tmpeme482z5.__modtest() [0x455240]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c42d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c4bc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c3b9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d35]

    ??:? runModuleUnitTests [0x460859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b3c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool is_lowercase = true;\n    bool is_uppercase = true;\n  \
    \  if (dict.isNull)\n        return false;\n    foreach (idx, val; dict) \n  \
    \  {\n        is_lowercase &= isLower(idx);\n        is_uppercase &= isUpper(idx);\n\
    \    }\n    return is_lowercase || is_uppercase;\n}\n/*\n    Given an associative\
    \ array of key-value pairs in the form of a tuple, \n    return a new associative\
    \ array where the keys are the first elements of \n    the tuple and the values\
    \ are the second elements of the tuple.\n    Examples:\n    >>> list_to_dict([(\"\
    a\", \"apple\"), (\"b\", \"banana\")])\n    [\"a\": \"apple\", \"b\": \"banana\"\
    ]\n    >>> list_to_dict([(1, \"apple\"), (2, \"banana\")])\n    [1: \"apple\"\
    , 2: \"banana\"]\n    >>> list_to_dict([(1L, \"apple\"), (2L, \"banana\")])\n\
    \    [1: \"apple\", 2: \"banana\"]\n    >>> list_to_dict([(\"a\", 1), (\"b\",\
    \ 2)])\n    [\"a\": 1, \"b\": 2]\n    >>> list_to_dict([(\"a\", 1L), (\"b\", 2L)])\n\
    \    [\"a\": 1, \"b\": 2]\n*/\nTKey[TValue] list_to_dict(TKey, TValue)(TKey[TValue]\
    \ list) \n{\n    TKey[TValue] dict;\n    foreach (val; list)\n        dict[val[0]]\
    \ = val[1];\n    return dict;\n}\n/*\n    Given an associative array, return a\
    \ new associative array \n    where all keys are converted to lower case. \n \
    \   If the given associative array is empty, return an empty associative array.\n\
    \    Examples:\n    >>> keys_to_lower([\"a\": \"apple\", \"B\": \"banana\"].nullable)\n\
    \    [\"a\": \"apple\", \"b\": \"banana\"]\n    >>> keys_\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvblictm2.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvblictm2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ bool all_lower = true;\n    bool all_upper = true;\n    for (auto key; dict.keys)\
    \ \n    {\n        if (all_lower && !key.isAllLower) \n        {\n           \
    \ all_lower = false;\n        }\n        if (all_upper && !key.isAllUpper) \n\
    \        {\n            all_upper = false;\n        }\n    }\n    return all_lower\
    \ || all_upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9fuqkahj.d(29): Error: no identifier for declarator `key`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9fuqkahj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164378
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool bValid = true;\n    bool bLower;\n    string key;\n    string\
    \ value;\n    bool bFirst = true;\n    foreach(key, value; dict)\n    {\n    \
    \    if(bFirst)\n        {\n            bLower = (key[0] == key.toLower()[0]);\n\
    \            bFirst = false;\n        }\n        else\n        {\n           \
    \ if(bLower && (key[0] != key.toLower()[0]))\n            {\n                bValid\
    \ = false;\n                break;\n            }\n            else if(!bLower\
    \ && (key[0] != key.toUpper()[0]))\n            {\n                bValid = false;\n\
    \                break;\n            }\n        }\n    }\n    return bValid;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprc6y_gwl.d(32): Error: no property `toLower` for type `string`

    /tmp/tmprc6y_gwl.d(37): Error: no property `toLower` for type `string`

    /tmp/tmprc6y_gwl.d(42): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprc6y_gwl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    static assert(isArray!(dict));\n    static assert(isAssociativeArray!(dict));\n\
    \    static assert(is(typeof(dict[dict.keys[0]]) == string));\n    bool isUpperCase\
    \ = true;\n    bool isLowerCase = true;\n    foreach(key; dict.keys)\n    {\n\
    \        isUpperCase &= key.isUpperCase;\n        isLowerCase &= key.isLowerCase;\n\
    \    }\n    return isUpperCase || isLowerCase;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps5q_yir9.d(23): Error: template instance `isArray!dict` template
    `isArray` is not defined

    /tmp/tmps5q_yir9.d(23):        while evaluating: `static assert(isArray!dict)`

    /tmp/tmps5q_yir9.d(24): Error: template instance `isAssociativeArray!dict` template
    `isAssociativeArray` is not defined, did you mean AssociativeArray(Key, Value)?

    /tmp/tmps5q_yir9.d(24):        while evaluating: `static assert(isAssociativeArray!dict)`

    /tmp/tmps5q_yir9.d(30): Error: no property `isUpperCase` for type `string`

    /tmp/tmps5q_yir9.d(31): Error: no property `isLowerCase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps5q_yir9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // Write your code here\n    \n    bool uppercase = false;\n\
    \    bool lowercase = false;\n    if(dict.isNull)\n    {\n        return false;\n\
    \    }\n    foreach(key,value; dict)\n    {\n        if(key.length != 0)\n   \
    \     {\n            uppercase = toUpper(key[0]) == key[0];\n            lowercase\
    \ = toLower(key[0]) == key[0];\n            if(!uppercase && !lowercase)\n   \
    \         {\n                return false;\n            }\n        }\n    }\n\
    \    return uppercase || lowercase;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp26ab6_ti.d(35): Error: undefined identifier `toUpper`

    /tmp/tmp26ab6_ti.d(36): Error: undefined identifier `toLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26ab6_ti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null)\n        return false;\n    if(dict.empty)\n\
    \        return false;\n    string[] keys = dict.keys.toArray;\n    if(keys.length\
    \ < 2)\n        return true;\n    if(keys[0].toUpper == keys[0])\n    {\n    \
    \    foreach(i, e; keys)\n        {\n            if(i == 0)\n                continue;\n\
    \            if(e.toUpper != e)\n                return false;\n        }\n  \
    \  }\n    else if(keys[0].toLower == keys[0])\n    {\n        foreach(i, e; keys)\n\
    \        {\n            if(i == 0)\n                continue;\n            if(e.toLower\
    \ != e)\n                return false;\n        }\n    }\n    else\n        return\
    \ false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsfudtpwi.d(25): Error: no property `empty` for type `Nullable!(string[string])`

    /tmp/tmpsfudtpwi.d(27): Error: no property `toArray` for type `string[]`

    /tmp/tmpsfudtpwi.d(30): Error: no property `toUpper` for type `string`

    /tmp/tmpsfudtpwi.d(36): Error: no property `toUpper` for type `string`

    /tmp/tmpsfudtpwi.d(40): Error: no property `toLower` for type `string`

    /tmp/tmpsfudtpwi.d(46): Error: no property `toLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsfudtpwi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n    if (isSomeString!(dict.getKeyTypeString)) {\n    if (is(dict.getKeyTypeString\
    \ == \"string\")) {\n        string[] test = dict.keys.sort;\n        string first\
    \ = test[0];\n        string last = test[$ - 1];\n        if (first == last.toLower)\
    \ {\n            return true;\n        }\n        if (first == last.toUpper) {\n\
    \            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplirvka1r.d(22): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmplirvka1r.d(22): Error: declaration expected, not `if`

    /tmp/tmplirvka1r.d(27): Error: declaration expected, not `if`

    /tmp/tmplirvka1r.d(29): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplirvka1r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) \n    {\n        return false;\n    }\n    return\
    \ dict.values[0].isLower || dict.values[0].isUpper;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj7apdkux.d(27): Error: no property `isLower` for type `string`

    /tmp/tmpj7apdkux.d(27): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj7apdkux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    bool lower = false;\n  \
    \  foreach (key; dict.keys)\n    {\n        if (!is(typeof(key) == string)) return\
    \ false;\n        lower = islower(key[0]);\n        if (!lower) break;\n    }\n\
    \    if (lower)\n    {\n        foreach (key; dict.keys)\n        {\n        \
    \    if (!islower(key[0])) return false;\n        }\n    }\n    else\n    {\n\
    \        foreach (key; dict.keys)\n        {\n            if (!isupper(key[0]))\
    \ return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo5mi3du3.d(28): Error: undefined identifier `islower`, did you
    mean variable `lower`?

    /tmp/tmpo5mi3du3.d(35): Error: undefined identifier `islower`, did you mean variable
    `lower`?

    /tmp/tmpo5mi3du3.d(42): Error: undefined identifier `isupper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo5mi3du3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.algorithm : sort;\n    if (dict is null) \n    {\n\
    \        return false;\n    }\n    immutable keys = dict.keys.sort;\n    string[string]\
    \ lower;\n    string[string] upper;\n    foreach (key; keys) \n    {\n       \
    \ key.toLower() in lower[key.toLower()] = dict[key];\n        key.toUpper() in\
    \ upper[key.toUpper()] = dict[key];\n    }\n    return keys.all!(key => lower[key]\
    \ == dict[key]) || keys.all!(key => upper[key] == dict[key]);\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmnn18ary.d(28): Error: cannot implicitly convert expression `sort(keys(dict))`
    of type `SortedRange!(string[], "a < b")` to `immutable(SortedRange!(string[],
    "a < b"))`

    /tmp/tmpmnn18ary.d(31): Error: mutable method `std.range.SortedRange!(string[],
    "a < b").SortedRange.empty` is not callable using a `immutable` object

    /tmp/tmpmnn18ary.d(31):        Consider adding `const` or `inout` to std.range.SortedRange!(string[],
    "a < b").SortedRange.empty

    /tmp/tmpmnn18ary.d(31): Error: mutable method `std.range.SortedRange!(string[],
    "a < b").SortedRange.popFront` is not callable using a `immutable` object

    /tmp/tmpmnn18ary.d(31):        Consider adding `const` or `inout` to std.range.SortedRange!(string[],
    "a < b").SortedRange.popFront

    /tmp/tmpmnn18ary.d(31): Error: mutable method `std.range.SortedRange!(string[],
    "a < b").SortedRange.front` is not callable using a `immutable` object

    /tmp/tmpmnn18ary.d(31):        Consider adding `const` or `inout` to std.range.SortedRange!(string[],
    "a < b").SortedRange.front

    /tmp/tmpmnn18ary.d(36): Error: no property `all` for type `immutable(SortedRange!(string[],
    "a < b"))`

    /tmp/tmpmnn18ary.d(36): Error: no property `all` for type `immutable(SortedRange!(string[],
    "a < b"))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmnn18ary.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ int upper = 0;\n    int lower = 0;\n    foreach (key; dict.keys) \n    {\n \
    \       string _key = key;\n        if (_key.isUpper) \n        {\n          \
    \  upper++;\n        } \n        else if (_key.isLower) \n        {\n        \
    \    lower++;\n        } \n        else \n        {\n            return false;\n\
    \        }\n    }\n    return (upper > 0) ^ (lower > 0);\n}\nunittest\n{\n   \
    \ alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnaxy5e4x.d(32): Error: no property `isUpper` for type `string`

    /tmp/tmpnaxy5e4x.d(36): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnaxy5e4x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull || dict.get.length == 0)\n        return false;\n\
    \    bool uppers = false;\n    bool lowers = false;\n    foreach (k,v; dict.get)\n\
    \    {\n        if (k.toLower != k)\n            lowers = true;\n        if (k.toUpper\
    \ != k)\n            uppers = true;\n    }\n    return !(uppers && lowers);\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyxpj83_t.d(29): Error: no property `toLower` for type `string`

    /tmp/tmpyxpj83_t.d(31): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyxpj83_t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = false;\n    int lower_count = 0;\n    int upper_count\
    \ = 0;\n    foreach(key, value; dict)\n    {\n        if(isUpper(key))\n     \
    \   {\n            ++upper_count;\n        }\n        else if(isLower(key))\n\
    \        {\n            ++lower_count;\n        }\n        else\n        {\n \
    \           return false;\n        }\n    }\n    if(lower_count > 0 && upper_count\
    \ > 0)\n    {\n        return false;\n    }\n    return true;\n}\n/*\n    Given\
    \ an associative array, return true if all keys are strings, else return false.\n\
    \    >>> check_dict_str_keys([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n\
    \    true\n    >>> check_dict_str_keys([\"a\": \"apple\", \"A\": \"banana\", \"\
    B\": \"banana\"].nullable)\n    true\n    >>> check_dict_str_keys([\"a\": \"apple\"\
    , 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_str_keys([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    true\n\
    \    >>> check_dict_str_keys([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n\
    \    true\n*/\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzb4y0j9j.d(28): Error: undefined identifier `isUpper`

    /tmp/tmpzb4y0j9j.d(32): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzb4y0j9j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // your code here\n    static int upper_case = 0;\n    static\
    \ int lower_case = 0;\n    static bool init = false;\n    if (dict.isNull)\n \
    \       return false;\n    else\n    {\n        foreach(key, val; dict)\n    \
    \    {\n            if (key[0] >= 'A' && key[0] <= 'Z')\n            {\n     \
    \           if (init)\n                {\n                    if (upper_case ==\
    \ 0)\n                        return false;\n                }\n             \
    \   else\n                    upper_case = 1;\n            }\n            else\
    \ if (key[0] >= 'a' && key[0] <= 'z')\n            {\n                if (init)\n\
    \                {\n                    if (lower_case == 0)\n               \
    \         return false;\n                }\n                else\n           \
    \         lower_case = 1;\n            }\n            else\n                return\
    \ false;\n        }\n        init = true;\n        return true;\n    }\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2gpwcuil.d(68): unittest failure

    ----------------

    ??:? _d_unittestp [0x457b41]

    ??:? void tmp2gpwcuil.__unittest_L60_C1() [0x442890]

    ??:? void tmp2gpwcuil.__modtest() [0x45564c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460e93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x45716e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c83d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c8cc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c7c9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x457145]

    ??:? runModuleUnitTests [0x460c69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458f4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto rnd = uniform(0, dict.keys.length);\n    auto isupper =\
    \ dict.keys[rnd].isUpper;\n    for (auto k; dict.keys)\n    {\n        if (k.isUpper\
    \ != isupper)\n            return false;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq3kkmiw2.d(25): Error: no identifier for declarator `k`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq3kkmiw2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) \n    {\n        return false;\n    }\n    bool\
    \ result = false;\n    bool isUpper = true;\n    bool isLower = true;\n    foreach\
    \ (key, value; dict) \n    {\n        isUpper = isUpper && isUpperCase(key);\n\
    \        isLower = isLower && isLowerCase(key);\n    }\n    result = isUpper ||\
    \ isLower;\n    return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9k75ubbb.d(32): Error: undefined identifier `isUpperCase`

    /tmp/tmp9k75ubbb.d(33): Error: undefined identifier `isLowerCase`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9k75ubbb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(null == dict)\n        return false;\n    string[] keys =\
    \ dict.keys;\n    foreach(key; keys)\n    {\n        if(key.empty)\n         \
    \   return false;\n        if(key.toUpper != key && key.toLower != key)\n    \
    \        return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6l7hrd2d.d(28): Error: no property `empty` for type `string`

    /tmp/tmp6l7hrd2d.d(30): Error: no property `toUpper` for type `string`

    /tmp/tmp6l7hrd2d.d(30): Error: no property `toLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6l7hrd2d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    int ucount = 0;\n    int\
    \ lcount = 0;\n    foreach (k,v; dict) \n    {\n        if (k.isUpper) ucount++;\n\
    \        if (k.isLower) lcount++;\n    }\n    return ucount == dict.length ||\
    \ lcount == dict.length;\n}\nstring[string] dict = [\"Name\": \"John\", \"Age\"\
    : \"36\", \"City\": \"Houston\"];\nassert(check_dict_case(dict) == false);\n \n\
    string[string] dict2 = [\"STATE\": \"NC\", \"ZIP\": \"12345\"];\nassert(check_dict_case(dict2)\
    \ == true);\n \nstring[string] dict3 = [\"a\": \"apple\", \"b\": \"banana\"];\n\
    assert(check_dict_case(dict3) == true);\n \nstring[string] dict4 = [\"a\": \"\
    apple\", \"A\": \"banana\", \"B\": \"banana\"];\nassert(check_dict_case(dict4)\
    \ == false);\n \nstring[string] dict5 = [\"a\": \"apple\", 8L: \"banana\", \"\
    a\": \"apple\"];\nassert(check_dict_case(dict5) == false);\n \nstring[string]\
    \ dict6 = [];\nassert(check_dict_case(dict6) == false);\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdb879jnt.d(34): Error: declaration expected, not `assert`

    /tmp/tmpdb879jnt.d(37): Error: declaration expected, not `assert`

    /tmp/tmpdb879jnt.d(40): Error: declaration expected, not `assert`

    /tmp/tmpdb879jnt.d(43): Error: declaration expected, not `assert`

    /tmp/tmpdb879jnt.d(46): Error: declaration expected, not `assert`

    /tmp/tmpdb879jnt.d(49): Error: declaration expected, not `assert`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb879jnt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164379
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = true;\n    bool is_upper = true;\n    bool is_lower\
    \ = true;\n    if (dict is null) return false;\n    foreach (key, value; dict)\
    \ \n    {\n        if (is_lower && islower(key[0])) \n        {\n            is_upper\
    \ = false;\n        }\n        else if (is_upper && isupper(key[0])) \n      \
    \  {\n            is_lower = false;\n        }\n        else \n        {\n   \
    \         result = false;\n            break;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7y26olsp.d(29): Error: undefined identifier `islower`, did you
    mean variable `is_lower`?

    /tmp/tmp7y26olsp.d(33): Error: undefined identifier `isupper`, did you mean variable
    `is_upper`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7y26olsp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    alias key_type\
    \ = typeof(dict.keys[0]);\n    if (key_type != string)\n        return false;\n\
    \    bool is_lower = true;\n    for (string key; key = dict.keys.front; dict.keys.popFront())\n\
    \    {\n        if (key.isUpper)\n        {\n            is_lower = false;\n \
    \           break;\n        }\n    }\n    for (string key; key = dict.keys.front;\
    \ dict.keys.popFront())\n    {\n        if (is_lower ? key.isUpper : key.isLower)\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpprn7larj.d(26): Error: incompatible types for `(string) != (string)`:
    cannot use `!=` with types

    /tmp/tmpprn7larj.d(29): Error: assignment cannot be used as a condition, perhaps
    `==` was meant?

    /tmp/tmpprn7larj.d(29): Error: no property `popFront` for type `string[]`

    /tmp/tmpprn7larj.d(31): Error: no property `isUpper` for type `string`

    /tmp/tmpprn7larj.d(37): Error: assignment cannot be used as a condition, perhaps
    `==` was meant?

    /tmp/tmpprn7larj.d(37): Error: no property `popFront` for type `string[]`

    /tmp/tmpprn7larj.d(39): Error: no property `isUpper` for type `string`

    /tmp/tmpprn7larj.d(39): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpprn7larj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict.length != 0 && dict.all!(x => x.key.toLower == x.key\
    \ || x.key.toUpper == x.key);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdbnnj9uc.d(23): Error: no property `all` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdbnnj9uc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    bool state = true;\n   \
    \ if (dict.keys[0].toLower() == dict.keys[0]) {\n        foreach (key; dict.keys)\
    \ \n        {\n            if (key.toLower() != key) \n            {\n       \
    \         state = false;\n                break;\n            }\n        }\n \
    \   }\n    else if (dict.keys[0].toUpper() == dict.keys[0]) \n    {\n        foreach\
    \ (key; dict.keys) \n        {\n            if (key.toUpper() != key) \n     \
    \       {\n                state = false;\n                break;\n          \
    \  }\n        }\n    }\n    else \n    {\n        state = false;\n    }\n    return\
    \ state;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe900i54s.d(25): Error: no property `toLower` for type `string`

    /tmp/tmpe900i54s.d(28): Error: no property `toLower` for type `string`

    /tmp/tmpe900i54s.d(35): Error: no property `toUpper` for type `string`

    /tmp/tmpe900i54s.d(39): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe900i54s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool is_lower_case = false;\n    bool is_upper_case = false;\n\
    \    foreach(k, v; dict) \n    {\n        if (is_lower(k))\n        {\n      \
    \      is_lower_case = true;\n        }\n        else if (is_upper(k))\n     \
    \   {\n            is_upper_case = true;\n        }\n        else\n        {\n\
    \            return false;\n        }\n    }\n    return is_lower_case ^ is_upper_case;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxuqhynp6.d(27): Error: undefined identifier `is_lower`

    /tmp/tmpxuqhynp6.d(31): Error: undefined identifier `is_upper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxuqhynp6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif (dict is null)\n\t\treturn false;\n\tif (dict.length == 0)\n\
    \t\treturn false;\n\tbool is_upper = dict.byKey(\"a\").isNull;\n\tforeach (key,\
    \ value; dict) \n\t{\n\t\tif (key !is string)\n\t\t\treturn false;\n\t\tif (is_upper\
    \ && key.toLower() != key)\n\t\t\treturn false;\n\t\tif (!is_upper && key.toUpper()\
    \ != key)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbixqginy.d(27): Error: template `object.byKey` cannot deduce function
    from argument types `!()(Nullable!(string[string]), string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(2941):        `object.byKey(T
    : V[K], K, V)(T aa)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(2963):        `object.byKey(T
    : V[K], K, V)(T* aa)`

    /tmp/tmpbixqginy.d(32): Error: no property `toLower` for type `string`

    /tmp/tmpbixqginy.d(34): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbixqginy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict is null ? false : \n        dict.keys.all!((k) =>\
    \ k.toUpperInPlace() == k) || \n        dict.keys.all!((k) => k.toLowerInPlace()\
    \ == k);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvhay8sjl.d(24): Error: no property `all` for type `string[]`

    /tmp/tmpvhay8sjl.d(25): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvhay8sjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    bool all_lower\
    \ = false;\n    bool all_upper = false;\n    foreach (k, v; dict)\n    {\n   \
    \     if (!all_lower && k.isLower)\n            all_lower = true;\n        else\
    \ if (!all_upper && k.isUpper)\n            all_upper = true;\n        else\n\
    \            return false;\n    }\n    return all_lower || all_upper;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa6za9lif.d(29): Error: no property `isLower` for type `string`

    /tmp/tmpa6za9lif.d(31): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa6za9lif.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    if (dict.length\
    \ == 0)\n        return false;\n    bool all_lower = true;\n    bool all_upper\
    \ = true;\n    foreach (k, v; dict)\n    {\n        all_lower = all_lower && k.isLower;\n\
    \        all_upper = all_upper && k.isUpper;\n    }\n    return all_lower || all_upper;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4j8654mi.d(31): Error: no property `isLower` for type `string`

    /tmp/tmp4j8654mi.d(32): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4j8654mi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk_bnfete.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_bnfete.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.math;\n    import std.algorithm;\n    import std.ascii;\n\
    \    import std.typecons;\n    import std.array;\n    import std.range;\n    if\
    \ (dict.isNull)\n        return false;\n    enum bool isUpper = true;\n    foreach\
    \ (k; dict.get.keys) \n    {\n        if (!k.isUpper) \n        {\n          \
    \  isUpper = false;\n            break;\n        }\n    }\n    return isUpper\
    \ || all!(isLower)(dict.get.keys);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_lw_53ae.d(34): Error: function `std.ascii.isUpper(dchar c)` is
    not callable using argument types `(string)`

    /tmp/tmp_lw_53ae.d(34):        cannot pass argument `k` of type `string` to parameter
    `dchar c`

    /tmp/tmp_lw_53ae.d(36): Error: cannot modify constant `isUpper`

    /tmp/tmp_lw_53ae.d(40): Error: template `std.algorithm.searching.all!(isLower).all`
    cannot deduce function from argument types `!()(string[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(122):        `std.algorithm.searching.all!(isLower).all(Range)(Range
    range) if (isInputRange!Range && is(typeof(unaryFun!pred(range.front))))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_lw_53ae.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    auto haslower = false;\n\
    \    auto hasupper = false;\n    foreach (k, _; dict) \n    {\n        if (k.length\
    \ != 0) \n        {\n            if (isUpper(k[0])) \n            {\n        \
    \        hasupper = true;\n            } \n            else \n            {\n\
    \                haslower = true;\n            }\n        }\n    }\n    return\
    \ haslower.implies(!hasupper);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphia5qi8v.d(30): Error: undefined identifier `isUpper`

    /tmp/tmphia5qi8v.d(40): Error: no property `implies` for type `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphia5qi8v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    bool lower = true;\n   \
    \ bool upper = true;\n    foreach (key; dict.keys)\n    {\n        lower = lower\
    \ && (key == toLower(key));\n        upper = upper && (key == toUpper(key));\n\
    \    }\n    return lower || upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwmhyxdt0.d(28): Error: undefined identifier `toLower`

    /tmp/tmpwmhyxdt0.d(29): Error: undefined identifier `toUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwmhyxdt0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    /*\n    bool res = true;\n    foreach(k, v; dict)\n    {\n  \
    \      if(!k.isUpper) \n        {\n            res = false;\n            break;\n\
    \        }\n    }\n    return res;\n    */\n    bool is_key_upper = true;\n  \
    \  foreach(k, v; dict)\n    {\n        if(!k.isUpper)\n        {\n           \
    \ is_key_upper = false;\n            break;\n        }\n    }\n    if(is_key_upper)\
    \ return true;\n    bool is_key_lower = true;\n    foreach(k, v; dict)\n    {\n\
    \        if(!k.isLower)\n        {\n            is_key_lower = false;\n      \
    \      break;\n        }\n    }\n    return is_key_lower;\n}\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbtdxhjnd.d(38): Error: no property `isUpper` for type `string`

    /tmp/tmpbtdxhjnd.d(48): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtdxhjnd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif (dict.isNull) \n    {\n\t\treturn false;\n\t}\n\tbool hasLowercaseKey\
    \ = false;\n\tbool hasUppercaseKey = false;\n\tforeach (string key; dict.get)\
    \ \n    {\n\t\tif (key.isUpper) \n        {\n\t\t\thasUppercaseKey = true;\n\t\
    \t}\n\t\telse if (key.isLower) \n        {\n\t\t\thasLowercaseKey = true;\n\t\t\
    }\n\t\telse \n        {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn hasLowercaseKey\
    \ != hasUppercaseKey;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0b3a1py3.d(31): Error: no property `isUpper` for type `string`

    /tmp/tmp0b3a1py3.d(35): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0b3a1py3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n    if (is(Nullable!(string[string]) == null)) \n{\n    return dict\
    \ is null;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhkd34sl.d(22): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpxhkd34sl.d(22): Error: declaration expected, not `if`

    /tmp/tmpxhkd34sl.d(25): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhkd34sl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict.count == 0 ? false : dict.keys().all!(key => key.toLower\
    \ == key || key.toUpper == key);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvwr9_35v.d(23): Error: no property `count` for type `Nullable!(string[string])`

    /tmp/tmpvwr9_35v.d(23): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwr9_35v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.isNull) return false;\n    bool isLower = true;\n   \
    \ string[] lower_dict;\n    string[] upper_dict;\n    foreach(k;dict.get.keys)\n\
    \    {\n        if(isLower)\n        {\n            isLower = k.isLower;\n   \
    \         if(isLower)\n            {\n                lower_dict[k] = dict[k];\n\
    \            }\n            else\n            {\n                upper_dict[k]\
    \ = dict[k];\n            }\n        }\n        else\n        {\n            if(!k.isUpper)\n\
    \            {\n                return false;\n            }\n            upper_dict[k]\
    \ = dict[k];\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyq1ml94q.d(31): Error: no property `isLower` for type `string`

    /tmp/tmpyq1ml94q.d(34): Error: cannot implicitly convert expression `k` of type
    `string` to `ulong`

    /tmp/tmpyq1ml94q.d(38): Error: cannot implicitly convert expression `k` of type
    `string` to `ulong`

    /tmp/tmpyq1ml94q.d(43): Error: no property `isUpper` for type `string`

    /tmp/tmpyq1ml94q.d(47): Error: cannot implicitly convert expression `k` of type
    `string` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyq1ml94q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool upper = false;\n    bool lower = false;\n    if (dict is\
    \ null) \n    {\n        return false;\n    }\n    foreach (k, v; dict) \n   \
    \ {\n        if (k.isUpper)\n        {\n            upper = true;\n        }\n\
    \        else if (k.isLower)\n        {\n            lower = true;\n        }\n\
    \        else\n        {\n            return false;\n        }\n    }\n    return\
    \ upper ^ lower;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa9ar1ya2.d(31): Error: no property `isUpper` for type `string`

    /tmp/tmpa9ar1ya2.d(35): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa9ar1ya2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    if (dict.empty)\n\
    \        return false;\n    auto first_key = dict.keys[0];\n    if (!first_key.isUpper)\n\
    \        return dict.keys.all!(e => e.isLower);\n    return dict.keys.all!(e =>\
    \ e.isUpper);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnjlkx766.d(25): Error: no property `empty` for type `Nullable!(string[string])`

    /tmp/tmpnjlkx766.d(28): Error: no property `isUpper` for type `string`

    /tmp/tmpnjlkx766.d(29): Error: no property `all` for type `string[]`

    /tmp/tmpnjlkx766.d(30): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnjlkx766.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict.isNull ? false : lower(dict).keys.minElement == upper(dict).keys.minElement;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_0j_d1le.d(23): Error: undefined identifier `lower`

    /tmp/tmp_0j_d1le.d(23): Error: undefined identifier `upper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_0j_d1le.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(dict.keys, k =>\n    {\n        if (dict.value.hasKey(k.toUpper()))\n\
    \            return false;\n    });\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr6d4kkhg.d(23): Error: no identifier for declarator `dict.keys`

    /tmp/tmpr6d4kkhg.d(23): Error: no identifier for declarator `k`

    /tmp/tmpr6d4kkhg.d(23): Error: found `=>` when expecting `;`

    /tmp/tmpr6d4kkhg.d(27): Error: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr6d4kkhg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    bool b1 = true;\n    bool\
    \ b2 = true;\n    foreach (key; dict.keys) \n    {\n        if (b1 && key.isUpperCase)\
    \ continue;\n        if (b2 && key.isLowerCase) continue;\n        b1 = false;\n\
    \        b2 = false;\n    }\n    return b1 || b2;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpllg0u4d7.d(28): Error: no property `isUpperCase` for type `string`

    /tmp/tmpllg0u4d7.d(29): Error: no property `isLowerCase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpllg0u4d7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ else \n    {\n        auto lower_case = dict.all!((x) => to!string(x.key).isLower);\n\
    \        auto upper_case = dict.all!((x) => to!string(x.key).isUpper);\n     \
    \   return lower_case || upper_case;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyow0325.d(29): Error: no property `all` for type `Nullable!(string[string])`

    /tmp/tmpxyow0325.d(30): Error: no property `all` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyow0325.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = true;\n    bool keysAreUpper = false;\n    foreach(key,\
    \ value; dict)\n    {\n        if(isUpper(key[0]))\n        {\n            keysAreUpper\
    \ = true;\n            continue;\n        }\n        else if(isLower(key[0]))\n\
    \        {\n            keysAreUpper = false;\n            continue;\n       \
    \ }\n        else\n        {\n            result = false;\n            break;\n\
    \        }\n    }\n    if(!dict.isNull)\n    {\n        foreach(key, value; dict)\n\
    \        {\n            if(keysAreUpper && !isUpper(key[0]))\n            {\n\
    \                result = false;\n                break;\n            }\n    \
    \        else if(!keysAreUpper && !isLower(key[0]))\n            {\n         \
    \       result = false;\n                break;\n            }\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnrkjeggt.d(27): Error: undefined identifier `isUpper`

    /tmp/tmpnrkjeggt.d(32): Error: undefined identifier `isLower`

    /tmp/tmpnrkjeggt.d(47): Error: undefined identifier `isUpper`

    /tmp/tmpnrkjeggt.d(52): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrkjeggt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif (dict is null)\n\t\treturn false;\n\t\n\tbool isUpper = true;\n\
    \tforeach (k, v; dict)\n\t{\n\t\tif (isUpper)\n\t\t{\n\t\t\tif (k[0] !is 'A'..'Z')\n\
    \t\t\t\tisUpper = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (k[0] !is 'a'..'z')\n\
    \t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpem_otdas.d(31): Error: found `..` when expecting `)`

    /tmp/tmpem_otdas.d(31): Error: found `)` when expecting `;` following statement

    /tmp/tmpem_otdas.d(36): Error: found `..` when expecting `)`

    /tmp/tmpem_otdas.d(36): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpem_otdas.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    immutable string_keys = true;\n    immutable lower_keys = true;\n\
    \    if (dict !is null) \n    {\n        foreach (key; dict.keys) \n        {\n\
    \            if (typeid(key) != typeid(string)) \n            {\n            \
    \    string_keys = false;\n                break;\n            }\n           \
    \ if (toLower(key) != key) \n            {\n                lower_keys = false;\n\
    \                break;\n            }\n        }\n    } \n    else \n    {\n\
    \        return false;\n    }\n    return string_keys && lower_keys;\n}\n/*\n\
    \    Given a non-negative integer in the form of an array of digits, \n    increment\
    \ one to the integer and return the result as an array of digits.\n    Example:\n\
    \    >>> increment_number([0])\n    [1]\n    >>> increment_number([0, 0])\n  \
    \  [0, 1]\n    >>> increment_number([9, 9])\n    [1, 0, 0]\n    >>> increment_number([4,\
    \ 2, 5, 6, 9])\n    [4, 2, 5, 7, 0]\n    >>> increment_number([5, 3, 1, 8, 2,\
    \ 9, 9, 5, 4, 6, 9, 5, 2, 4, 9, 1, 3, 6, 3, 4, 3, 6, 7, 8, 4, 1, 7, 5, 1, 1, 7,\
    \ 8, 4, 7, 7, 1, 8, 8, 7, 5, 8, 6, 7, 8, 3, 3, 3, 4, 1, 8, 7, 5, 3, 1, 3, 5, 4,\
    \ 6, 7, 1, 8, 8, 7, 5, 8, 6, 7, 8, 4, 6, 7, 5, 3, 3, 3, 4, 1, 8, 7, 5, 3, 1, 3,\
    \ 5, 4, 6, 7, 1, 8, 8, 7, 5, 8, 6, 7, 8, 4, 6, 7, 5, 3, 3, 3, 4, 1, 8, 7, 5, 3,\
    \ 1, 3, 5, 4, 6, 7, 1, 8,\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvf_kuiv4.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvf_kuiv4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.isNull)\n        return false;\n    \n    bool is_lower\
    \ = false;\n    foreach(key, value; dict)\n    {\n        if(is(typeof(key)))\n\
    \        {\n            if(key.isUpperCase)\n                is_lower = false;\n\
    \            else if(key.isLowerCase)\n                is_lower = true;\n    \
    \        else\n                return false;\n        }\n        else\n      \
    \      return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvso93fn6.d(31): Error: no property `isUpperCase` for type `string`

    /tmp/tmpvso93fn6.d(33): Error: no property `isLowerCase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvso93fn6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null)\n        return false;\n    \n    string[string]\
    \ Dict = dict;\n    if(Dict.empty)\n        return false;\n    \n    bool allLower\
    \ = true;\n    bool allUpper = true;\n    foreach(key; Dict.keys) \n    {\n  \
    \      if(key.isLower)\n            allUpper = false;\n        else if(key.isUpper)\n\
    \            allLower = false;\n        else\n            return false;\n    }\n\
    \    return allLower || allUpper;\n}\n/*\n    Given a string containing a domain\
    \ name, return a tuple containing the \n    organization and the top-level domain.\n\
    \    Examples:\n    >>> get_org_and_tld(\"google.com\")\n    (\"google\", \"com\"\
    )\n    >>> get_org_and_tld(\"google.co.uk\")\n    (\"google\", \"co.uk\")\n  \
    \  >>> get_org_and_tld(\"google.co.in\")\n    (\"google\", \"co.in\")\n    >>>\
    \ get_org_and_tld(\"google.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co.co\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2i874u57.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2i874u57.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null)\n        return false;\n    string[string] lower_dict\
    \ = [ \"a\": \"apple\", \"b\": \"banana\"];\n    string[string] upper_dict = [\
    \ \"STATE\": \"NC\", \"ZIP\": \"12345\"];\n    int lower = 0;\n    int upper =\
    \ 0;\n    foreach(key; dict.keys)\n    {\n        if(key in lower_dict)\n    \
    \        lower += 1;\n        if(key in upper_dict)\n            upper += 1;\n\
    \    }\n    return (lower == dict.length) || (upper == dict.length);\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplswsaikb.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x457be1]

    ??:? void tmplswsaikb.__unittest_L38_C1() [0x442491]

    ??:? void tmplswsaikb.__modtest() [0x4556f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x4610cb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x45720e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45ca75]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45cb04]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45ca01]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4571e5]

    ??:? runModuleUnitTests [0x460ea1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x459184]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null)\n        return false;\n    if(dict.length ==\
    \ 0)\n        return false;\n    return dict.keys.array.all!(isUpper) || dict.keys.array.all!(isLower);\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpru9qc4yo.d(27): Error: no property `array` for type `string[]`

    /tmp/tmpru9qc4yo.d(27): Error: no property `array` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpru9qc4yo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    ulong upper = 0, lower =\
    \ 0;\n    foreach (k, v; dict) \n    {\n        if (k is string) \n        {\n\
    \            if (k.toUpper() == k)\n                upper++;\n            else\
    \ if (k.toLower() == k)\n                lower++;\n            else\n        \
    \        return false;\n        }\n        else\n            return false;\n \
    \   }\n    return (upper * lower == 0);\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp3oiuyzv.d(29): Error: no property `toUpper` for type `string`

    /tmp/tmpp3oiuyzv.d(31): Error: no property `toLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp3oiuyzv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.algorithm.comparison: equal;\n    import std.algorithm.mutation:\
    \ all;\n    import std.array : array;\n    import std.conv: to;\n    import std.exception:\
    \ enforce;\n    import std.range: all, takeExactly;\n    import std.string: toLower,\
    \ toUpper;\n    import std.typecons: Tuple;\n    import std.typecons: Nullable;\n\
    \    import std.traits: isString;\n    import std.algorithm.sorting: sort;\n \
    \   import std.traits: isNumeric;\n    import std.array: iota;\n    import std.math:\
    \ isInfinity, isNaN;\n    import std.conv: to;\n    import std.array: sort;\n\
    \    if (dict is null)\n    {\n        return false;\n    }\n    if (dict.empty)\n\
    \    {\n        return false;\n    }\n    foreach (key, value; dict)\n    {\n\
    \        if (!is(typeof(key) == string))\n        {\n            return false;\n\
    \        }\n    }\n    if (equal(\n        dict.keys.map!(k => k.toLower()).array,\
    \ \n        dict.keys.map!(k => k.toUpper()).array))\n    {\n        return true;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvz4d71j2.d(24): Error: module `std.algorithm.mutation` import `all`
    not found

    /tmp/tmpvz4d71j2.d(28): Error: module `std.range` import `all` not found

    /tmp/tmpvz4d71j2.d(32): Error: module `std.traits` import `isString` not found

    /tmp/tmpvz4d71j2.d(35): Error: module `std.array` import `iota` not found

    /tmp/tmpvz4d71j2.d(38): Error: module `std.array` import `sort` not found

    /tmp/tmpvz4d71j2.d(43): Error: no property `empty` for type `Nullable!(string[string])`

    /tmp/tmpvz4d71j2.d(55): Error: no property `map` for type `string[]`

    /tmp/tmpvz4d71j2.d(56): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvz4d71j2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        bool upper;\n        if(dict.get.keys[0].toUpper() == dict.get.keys[0])\n\
    \        {\n            upper = true;\n        }\n        else if(dict.get.keys[0].toLower()\
    \ == dict.get.keys[0])\n        {\n            upper = false;\n        }\n   \
    \     else\n        {\n            return false;\n        }\n        foreach(Key;\
    \ dict.get.keys)\n        {\n            if(upper && Key.toUpper() != Key)\n \
    \           {\n                return false;\n            }\n            else\
    \ if(!upper && Key.toLower() != Key)\n            {\n                return false;\n\
    \            }\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpryrbuj9y.d(30): Error: no property `toUpper` for type `string`

    /tmp/tmpryrbuj9y.d(34): Error: no property `toLower` for type `string`

    /tmp/tmpryrbuj9y.d(44): Error: no property `toUpper` for type `string`

    /tmp/tmpryrbuj9y.d(48): Error: no property `toLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpryrbuj9y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool _ = (dict == null);\n    if(_)\n        return false;\n\
    \    bool result = true;\n    foreach(key; dict.keys)\n    {\n        auto temp\
    \ = dict[key];\n        if(key.length != 0 && key.toUpper.length == 0 && key.toLower.length\
    \ == 0)\n        {\n            result = false;\n            break;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwbi6vgfh.d(30): Error: no property `toUpper` for type `string`

    /tmp/tmpwbi6vgfh.d(30): Error: no property `toLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwbi6vgfh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(null == dict) return false;\n    bool upper = true;\n    foreach(key;\
    \ dict.keys)\n    {\n        if(upper)\n        {\n            if(!isUpperAlpha(key[0]))\n\
    \            {\n                upper = false;\n            }\n        }\n   \
    \     else\n        {\n            if(!isLowerAlpha(key[0]))\n            {\n\
    \                return false;\n            }\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb9zejzjy.d(29): Error: undefined identifier `isUpperAlpha`

    /tmp/tmpb9zejzjy.d(36): Error: undefined identifier `isLowerAlpha`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9zejzjy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin {\n    assert(dict.isValid && dict !is null);\n} \nbody {\n    bool\
    \ lower = true;\n    bool upper = true;\n    foreach(key; dict.get.keys) {\n \
    \       lower = lower && key.isLower;\n        upper = upper && key.isUpper;\n\
    \    }\n    return lower || upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkjjusk6f.d(29): Error: no property `isLower` for type `string`

    /tmp/tmpkjjusk6f.d(30): Error: no property `isUpper` for type `string`

    /tmp/tmpkjjusk6f.d(23): Error: no property `isValid` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjjusk6f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    if (dict.keys.empty) return\
    \ false;\n    bool found_upper = false;\n    bool found_lower = false;\n    foreach\
    \ (k; dict.keys)\n    {\n        if (k.length == 0) return false;\n        if\
    \ (found_upper) \n        {\n            if (k[0].isLower) return false;\n   \
    \     }\n        else if (found_lower)\n        {\n            if (k[0].isUpper)\
    \ return false;\n        }\n        else\n        {\n            if (k[0].isUpper)\
    \ found_upper = true;\n            else if (k[0].isLower) found_lower = true;\n\
    \            else return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_02huotz.d(24): Error: no property `empty` for type `string[]`

    /tmp/tmp_02huotz.d(32): Error: no property `isLower` for type `immutable(char)`

    /tmp/tmp_02huotz.d(36): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmp_02huotz.d(40): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmp_02huotz.d(41): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_02huotz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) \n    {\n        return false;\n    }\n    foreach\
    \ (k, v; dict) \n    {\n        int index = 0;\n        foreach (c; k) \n    \
    \    {\n            if (c.isUpper) \n            {\n                index++;\n\
    \            }\n        }\n        if (index == 0 || index == k.length) \n   \
    \     {\n            continue;\n        }\n        return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyk3y9hj6.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyk3y9hj6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin\n{\n  assert(false, \"Unimplemented\");\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmbqw836l.d(21): Error: function `tmpmbqw836l.check_dict_case` `in`
    and `out` contracts can only appear without a body when they are virtual interface
    functions or abstract

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmbqw836l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ string[] keys = dict.keys;\n    bool all_upper = true;\n    bool all_lower =\
    \ true;\n    foreach (key; keys) \n    {\n        all_upper = all_upper && key.isUpperCase;\n\
    \        all_lower = all_lower && key.isLowerCase;\n    }\n    return all_upper\
    \ || all_lower;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6mo_7yp4.d(32): Error: no property `isUpperCase` for type `string`

    /tmp/tmp6mo_7yp4.d(33): Error: no property `isLowerCase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6mo_7yp4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    enum hasLower =\
    \ false;\n    enum hasUpper = false;\n    foreach (key; dict.keys)\n    {\n  \
    \      if (is(typeof(key) == string))\n        {\n            if (std.string.isupper(key))\n\
    \                hasUpper = true;\n            else if (std.string.islower(key))\n\
    \                hasLower = true;\n            else\n                return false;\n\
    \        }\n        else\n            return false;\n    }\n    return hasLower\
    \ == hasUpper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpesvv006v.d(31): Error: undefined identifier `string` in package
    `std`

    /tmp/tmpesvv006v.d(32): Error: cannot modify constant `hasUpper`

    /tmp/tmpesvv006v.d(33): Error: undefined identifier `string` in package `std`

    /tmp/tmpesvv006v.d(34): Error: cannot modify constant `hasLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpesvv006v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    alias KeyType = typeof(dict.keys[0]);\n    return dict.keys.all!(key\
    \ => is(KeyType == string) && \n                                 is(key == toLower(key)\
    \ || \n                                    key == toUpper(key)));\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0zq4690v.d(25): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmp0zq4690v.d(25): Error: found `||` when expecting `)`

    /tmp/tmp0zq4690v.d(26): Error: found `key` when expecting `)` following template
    argument list

    /tmp/tmp0zq4690v.d(26): Error: found `)` when expecting `;` following `return`
    statement

    /tmp/tmp0zq4690v.d(26): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0zq4690v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool is_all_keys_lowercase = true;\n    bool is_all_keys_uppercase\
    \ = true;\n    if (dict is null) return false;\n    // loop over each pair of\
    \ the dictionary\n    foreach (kvp; dict) \n    {\n        // islower and isupper\
    \ return true if all characters of the string are\n        // lower and upper\
    \ case respectively, else they return false\n        is_all_keys_lowercase &=\
    \ kvp.key.islower;\n        is_all_keys_uppercase &= kvp.key.isupper;\n    }\n\
    \    return is_all_keys_lowercase || is_all_keys_uppercase;\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6__5jvh5.d(31): Error: no property `key` for type `string`

    /tmp/tmp6__5jvh5.d(32): Error: no property `key` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6__5jvh5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    string[string] lowerDict;\n\
    \    string[string] upperDict;\n    foreach (k, v; dict) \n    {\n        if (k\
    \ is string) \n        {\n            if (k.isUpper) \n            {\n       \
    \         upperDict[k] = v;\n            } \n            else \n            {\n\
    \                lowerDict[k] = v;\n            }\n        } \n        else \n\
    \        {\n            return false;\n        }\n    }\n    return lowerDict.length\
    \ == 0 || upperDict.length == 0;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpen8r09_2.d(30): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen8r09_2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk_bnfete.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_bnfete.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164380
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!dict)\n        return false;\n    enum bool all_upper = true;\n\
    \    enum bool all_lower = true;\n    if(dict.length == 0)\n        return false;\n\
    \    foreach(string key; dict.keys)\n    {\n        //if key is not all lower\
    \ case set all_lower to false\n        if(key.toLower() != key)\n            all_lower\
    \ = false;\n        //if key is not all upper case set all_upper to false\n  \
    \      if(key.toUpper() != key)\n            all_upper = false;\n    }\n    return\
    \ all_lower || all_upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd4s8e5fs.d(32): Error: no property `toLower` for type `string`

    /tmp/tmpd4s8e5fs.d(33): Error: cannot modify constant `all_lower`

    /tmp/tmpd4s8e5fs.d(35): Error: no property `toUpper` for type `string`

    /tmp/tmpd4s8e5fs.d(36): Error: cannot modify constant `all_upper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd4s8e5fs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // your code here\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0wirz9rf.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x457709]

    ??:? void tmp0wirz9rf.__unittest_L26_C1() [0x4420dd]

    ??:? void tmp0wirz9rf.__modtest() [0x455214]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c494]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d0d]

    ??:? runModuleUnitTests [0x460831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b14]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) return false;\n    if(dict.length < 1) return\
    \ false;\n    int? lower_keys_count;\n    int? upper_keys_count;\n    foreach(key;\
    \ dict.keys)\n    {\n        if(key.length > 0)\n        {\n            // if\
    \ the first letter is lowercase increment lower count\n            if(!lower_keys_count.isNull\
    \ && lower_keys_count.get < 1)\n            {\n                lower_keys_count\
    \ = 0;\n            }\n            if(!upper_keys_count.isNull && upper_keys_count.get\
    \ < 1)\n            {\n                upper_keys_count = 0;\n            }\n\
    \            if(!upper_keys_count.isNull && !lower_keys_count.isNull)\n      \
    \      {\n                break;\n            }\n            if(key[0].isUpper)\n\
    \            {\n                upper_keys_count++;\n            }\n         \
    \   else\n            {\n                lower_keys_count++;\n            }\n\
    \        }\n    }\n    return upper_keys_count is null || lower_keys_count is\
    \ null ||\n    upper_keys_count == lower_keys_count;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpepj2ep17.d(25): Error: no identifier for declarator `int`

    /tmp/tmpepj2ep17.d(25): Error: found `?` instead of statement

    /tmp/tmpepj2ep17.d(26): Error: no identifier for declarator `int`

    /tmp/tmpepj2ep17.d(26): Error: found `?` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpepj2ep17.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.isNull)\n        return false;\n    bool isLower = true;\n\
    \    bool isUpper = true;\n    foreach(index, value; dict)\n    {\n        isLower\
    \ = isLower && toLower(index) == index;\n        isUpper = isUpper && toUpper(index)\
    \ == index;\n    }\n    return isLower || isUpper;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuptvec2q.d(29): Error: undefined identifier `toLower`, did you
    mean variable `isLower`?

    /tmp/tmpuptvec2q.d(30): Error: undefined identifier `toUpper`, did you mean variable
    `isUpper`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuptvec2q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    bool all_lower_case = true;\n\
    \    bool all_upper_case = true;\n    foreach (i, key; dict.keys)\n    {\n   \
    \     if (all_lower_case)\n        {\n            if (key != key.toLower) all_lower_case\
    \ = false;\n        }\n        if (all_upper_case)\n        {\n            if\
    \ (key != key.toUpper) all_upper_case = false;\n        }\n        if (!all_lower_case\
    \ && !all_upper_case) return false;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgzhidnb3.d(30): Error: no property `toLower` for type `string`

    /tmp/tmpgzhidnb3.d(34): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgzhidnb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto lower = true;\n    auto upper = true;\n    foreach(key;\
    \ dict.keys)\n    {\n        if (isLower(key[0]))\n        {\n            upper\
    \ = false;\n        }\n        else if (isUpper(key[0]))\n        {\n        \
    \    lower = false;\n        }\n        else\n        {\n            return false;\n\
    \        }\n    }\n    return lower || upper;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwqm24vq.d(27): Error: undefined identifier `isLower`

    /tmp/tmppwqm24vq.d(31): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwqm24vq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedo_l3h9.d(21): Error: function `tmpedo_l3h9.check_dict_case` has
    no `return` statement, but is expected to return a value of type `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedo_l3h9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    foreach (key, value;\
    \ dict)\n    {\n        if (!is(typeof(key) == string))\n            return false;\n\
    \        if (key == toUpper(key))\n            return dict.all!(a => a.key ==\
    \ toUpper(a.key));\n        else if (key == toLower(key))\n            return\
    \ dict.all!(a => a.key == toLower(a.key));\n        else\n            return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg9h3r2lb.d(29): Error: undefined identifier `toUpper`

    /tmp/tmpg9h3r2lb.d(30): Error: no property `all` for type `Nullable!(string[string])`

    /tmp/tmpg9h3r2lb.d(31): Error: undefined identifier `toLower`

    /tmp/tmpg9h3r2lb.d(32): Error: no property `all` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9h3r2lb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ bool all_lowercase = false;\n    bool all_uppercase = false;\n    foreach (string\
    \ key; dict.keys) \n    {\n        if (key.length == 0) \n        {\n        \
    \    return false;\n        }\n        if (key.isAllLower) \n        {\n     \
    \       all_lowercase = true;\n        }\n        else if (key.isAllUpper) \n\
    \        {\n            all_uppercase = true;\n        }\n        else \n    \
    \    {\n            return false;\n        }\n    }\n    return all_lowercase\
    \ || all_uppercase;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgq3iomi_.d(35): Error: no property `isAllLower` for type `string`

    /tmp/tmpgq3iomi_.d(39): Error: no property `isAllUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgq3iomi_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.isNull) return false;\n    int count = 0;\n    foreach(key,\
    \ value; dict)\n    {\n        if(key.isEmpty) return false;\n        count +=\
    \ key.length;\n    }\n    return count % 2 == 0;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wjtydn2.d(27): Error: no property `isEmpty` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wjtydn2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    bool is_all_lower_case(string[string] dict) {\n       \
    \ foreach(key; dict.keys)\n            if(key != key.toLower)\n              \
    \  return false;\n        return true;\n    }\n    \n    bool is_all_upper_case(string[string]\
    \ dict) {\n        foreach(key; dict.keys)\n            if(key != key.toUpper)\n\
    \                return false;\n        return true;\n    }\n    \n    if(dict.isNull)\n\
    \        return false;\n    else\n        return is_all_lower_case(dict) || is_all_upper_case(dict);\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6v89r__q.d(26): Error: no property `toLower` for type `string`

    /tmp/tmp6v89r__q.d(33): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6v89r__q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // we assume that nullable is not null\n    assert(dict.isInitialized);\n\
    \    bool is_lower = dict.value.keys.front.isAllLower;\n    bool is_upper = dict.value.keys.front.isAllUpper;\n\
    \    foreach(key; dict.value.keys)\n    {\n        if (key.isAllLower != is_lower\
    \ && key.isAllUpper != is_upper)\n        {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpywum1318.d(24): Error: no property `isInitialized` for type `Nullable!(string[string])`

    /tmp/tmpywum1318.d(25): Error: no property `value` for type `Nullable!(string[string])`,
    did you mean `std.typecons.Nullable!(string[string]).Nullable._value`?

    /tmp/tmpywum1318.d(26): Error: no property `value` for type `Nullable!(string[string])`,
    did you mean `std.typecons.Nullable!(string[string]).Nullable._value`?

    /tmp/tmpywum1318.d(27): Error: no property `value` for type `Nullable!(string[string])`,
    did you mean `std.typecons.Nullable!(string[string]).Nullable._value`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpywum1318.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) \n    {\n        return false;\n    }\n    if(dict.empty)\
    \ \n    {\n        return false;\n    }\n    foreach(key, value; dict) \n    {\n\
    \        import std.algorithm : map;\n        auto lowerkey = key.map!(a => a.toLower()).array.toStringz();\n\
    \        auto upperkey = key.map!(a => a.toUpper()).array.toStringz();\n     \
    \   if(key == lowerkey) \n        {\n            continue;\n        }\n      \
    \  else if(key == upperkey) \n        {\n            continue;\n        }\n  \
    \      else \n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg3lurw0a.d(27): Error: no property `empty` for type `Nullable!(string[string])`

    /tmp/tmpg3lurw0a.d(34): Error: no property `toLower` for type `dchar`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):        instantiated
    from here: `MapResult!(__lambda3, string)`

    /tmp/tmpg3lurw0a.d(34):        instantiated from here: `map!string`

    /tmp/tmpg3lurw0a.d(35): Error: no property `toUpper` for type `dchar`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):        instantiated
    from here: `MapResult!(__lambda4, string)`

    /tmp/tmpg3lurw0a.d(35):        instantiated from here: `map!string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg3lurw0a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n    if (isNullable!(dict))\n{\n    return dict.isNull\n        ? false\n\
    \        : dict.get.all!(key => key.isUpper)\n        || dict.get.all!(key =>\
    \ key.isLower);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ngto_50.d(22): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmp9ngto_50.d(22): Error: declaration expected, not `if`

    /tmp/tmp9ngto_50.d(28): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ngto_50.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164381
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) \n    {\n        return false;\n    }\n    if\
    \ (dict.isNull || dict.length == 0) \n    {\n        return false;\n    }\n  \
    \  bool lower = false;\n    bool upper = false;\n    foreach (key, value; dict)\
    \ \n    {\n        if (key.isUpperCase) \n        {\n            upper = true;\n\
    \        } \n        else if (key.isLowerCase) \n        {\n            lower\
    \ = true;\n        } \n        else \n        {\n            return false;\n \
    \       }\n    }\n    return (lower && !upper) || (!lower && upper);\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyuei4fvi.d(35): Error: no property `isUpperCase` for type `string`

    /tmp/tmpyuei4fvi.d(39): Error: no property `isLowerCase` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyuei4fvi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool upperCase = true;\n    bool lowerCase = true;\n    foreach(k,\
    \ v; dict)\n    {\n        if (isUpper(k[0]))\n        {\n            lowerCase\
    \ = false;\n        } else if (isLower(k[0]))\n        {\n            upperCase\
    \ = false;\n        } else\n        {\n            return false;\n        }\n\
    \    }\n    return lowerCase || upperCase;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjs1tjzy0.d(27): Error: undefined identifier `isUpper`

    /tmp/tmpjs1tjzy0.d(30): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjs1tjzy0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ if (dict.keys.length == 0) \n    {\n        return false;\n    }\n    bool result;\n\
    \    if (dict.keys[0].isUpperCase) \n    {\n        result = dict.keys.all!(e\
    \ => e.isUpperCase);\n    } \n    else \n    {\n        result = dict.keys.all!(e\
    \ => e.isLowerCase);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_aif0g0p.d(32): Error: no property `isUpperCase` for type `string`

    /tmp/tmp_aif0g0p.d(34): Error: no property `all` for type `string[]`

    /tmp/tmp_aif0g0p.d(38): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_aif0g0p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    if (dict.length\
    \ == 0)\n        return false;\n    bool is_all_lower = false;\n    foreach (key;\
    \ dict.keys) \n    {\n        if (key.length == 0)\n            return false;\n\
    \        if (is_all_lower) \n        {\n            if (key != key.toLower)\n\
    \                return false;\n        }\n        else \n        {\n        \
    \    if (key != key.toUpper)\n                return false;\n            is_all_lower\
    \ = true;\n        }\n    }\n    return true;\n}\n/*\n    Given an associative\
    \ array, return an associative array with all strings \n    in lower case.\n \
    \   The function should return an empty associative array is the given associative\
    \ array is empty.\n    Examples:\n    >>> [\"a\": \"apple\", \"b\": \"banana\"\
    ].lower_case\n    [\"a\": \"apple\", \"b\": \"banana\"]\n    >>> [\"Name\": \"\
    John\", \"Age\": \"36\", \"City\": \"Houston\"].lower_case\n    [\"name\": \"\
    John\", \"age\": \"36\", \"city\": \"Houston\"]\n    >>> [\"State\": \"NC\", \"\
    ZIP\": \"12345\"].lower_case\n    [\"state\": \"NC\", \"zip\": \"12345\"]\n  \
    \  >>> [].lower_case\n    []\n    >>> [1 : \"apple\", \"b\": \"banana\"].lower_case\n\
    \    [1 : \"apple\", \"b\": \"banana\"]\n*/\nstring[string] lower_case(string[string]\
    \ dict)\n{\n    string[string] res;\n    foreach (key, value; dict)\n        res[key.toLower]\
    \ = value;\n    return res;\n}\n/*\n    Given an associative array, return an\
    \ associative array with all strings \n    in upper case.\n    The function should\
    \ return an empty associative array is the given associative array is empty.\n\
    \    Examples:\n    >>> [\"a\": \"apple\", \"b\": \"banana\"].upper_case\n   \
    \ [\"A\": \"apple\", \"B\": \"banana\"]\n    >>> [\"Name\": \"John\",\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpitv17y_4.d(69): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpitv17y_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool lower_case, upper_case;\n    if (dict is null) return false;\n\
    \    if (dict.empty) return false;\n    foreach (key; dict.keys) \n    {\n   \
    \     if (is(typeof(key) : string)) \n        {\n            lower_case = (key.toLower\
    \ == key);\n            upper_case = (key.toUpper == key);\n            if (lower_case\
    \ && upper_case) return false;\n        } \n        else \n        {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmxe7i8mi.d(25): Error: no property `empty` for type `Nullable!(string[string])`

    /tmp/tmpmxe7i8mi.d(30): Error: no property `toLower` for type `string`

    /tmp/tmpmxe7i8mi.d(31): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmxe7i8mi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto ret = true;\n    if(dict.isNull) return ret;\n    dict.each!(x\
    \ => { \n        if(ret) {\n            ret = x.key.isUpperCase || x.key.isLowerCase;\n\
    \        }\n    });\n    return ret;\n}\n/*\n    Given a list of strings, return\
    \ true if every string is lower case.\n    >>> is_lower_case([\"abc\", \"abcde\"\
    , \"abcdefg\"])\n    true\n    >>> is_lower_case([\"abc\", \"abCde\", \"abcdefg\"\
    ])\n    false\n    >>> is_lower_case([\"ABC\", \"ABCDE\", \"ABCDEFG\"])\n    false\n\
    \    >>> is_lower_case([\"abc\", \"DEF\", \"GHI\"])\n    false\n    >>> is_lower_case([\"\
    abc\", \"def\", \"ghi\"])\n    true\n    >>> is_lower_case([\"aBc\", \"Def\",\
    \ \"Ghi\"])\n    false\n*/\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpav2zjzm2.d(25): Error: no property `each` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpav2zjzm2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ size_t lower = 0;\n    size_t upper = 0;\n    foreach (key; dict.keys) \n  \
    \  {\n        if (isUpper(key[0])) \n        {\n            upper++;\n       \
    \ }\n        else if (isLower(key[0])) \n        {\n            lower++;\n   \
    \     }\n        else \n        {\n            return false;\n        }\n    }\n\
    \    return (lower == 0 || upper == 0);\n}\n/*\n    Given a list of strings, check\
    \ if all strings have the same length.\n    If the list is empty, return true.\n\
    \    Examples:\n    >>> check_same_length([\"code\", \"bug\"].nullable)\n    true\n\
    \    >>> check_same_length([\"code\", \"bug\", \"code\"].nullable)\n    true\n\
    \    >>> check_same_length([\"code\", \"bug\", \"code\", \"buggy\"].nullable)\n\
    \    false\n    >>> check_same_length([\"code\", \"bug\", \"code\", \"buggy\"\
    , \"testing\"].nullable)\n    false\n    >>> check_same_length([\"code\", \"bug\"\
    , \"code\", \"buggy\", \"testing\", \"bug\"].nullable)\n    false\n    >>> check_same_length([\"\
    code\", \"bug\", \"code\", \"buggy\", \"testing\", \"bug\", \"code\"].nullable)\n\
    \    false\n    >>> check_same_length([\"code\", \"bug\", \"code\", \"buggy\"\
    , \"testing\", \"bug\", \"code\", \"testing\"].nullable)\n    false\n    >>> check_same_length([\"\
    code\", \"bug\", \"code\", \"buggy\", \"testing\", \"bug\", \"code\", \"testing\"\
    , \"code\"].nullable)\n    false\n    >>> check_same_length([\"code\", \"bug\"\
    , \"code\", \"buggy\", \"testing\", \"bug\", \"code\", \"testing\", \"code\",\
    \ \"bug\"].nullable)\n    false\n    >>> check_same_length([\"code\", \"bug\"\
    , \"code\", \"buggy\", \"testing\", \"bug\", \"code\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_pk4wr3y.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_pk4wr3y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    if (dict.length == 0) return\
    \ false;\n    auto lower = 0, upper = 0;\n    foreach (key; dict.keys) \n    {\n\
    \        if (is_upper(key[0])) upper++;\n        else if (is_lower(key[0])) lower++;\n\
    \    }\n    return lower == 0 || upper == 0;\n}\n/*\n    Given a non-empty associative\
    \ array, return an array containing \n    the keys in sorted order.\n    The function\
    \ should return null if the given associative array is empty.\n    Examples:\n\
    \    >>> sort_dict_keys([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    [\"\
    a\", \"b\"]\n    >>> sort_dict_keys([\"a\": \"apple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable)\n    [\"A\", \"B\", \"a\"]\n    >>> sort_dict_keys([\"\
    a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    [8L, \"a\"]\n\
    \    >>> sort_dict_keys([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable)\n    [\"Age\", \"City\", \"Name\"]\n    >>> sort_dict_keys([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable)\n    [\"STATE\", \"ZIP\"]\n*/\nNullable!(string[])\
    \ sort_dict_keys(Nullable!(string[string]) dict) \n{\n    if (dict is null) return\
    \ null;\n    return dict.keys.sort();\n}\n/*\n    Given a non-empty associative\
    \ array, return an array containing \n    the values in sorted order.\n    The\
    \ function should return null if the given associative array is empty.\n    Examples:\n\
    \    >>> sort_dict_values([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n  \
    \  [\"apple\", \"banana\"]\n    >>> sort_dict_values([\"a\": \"apple\", \"A\"\
    : \"banana\", \"B\": \"banana\"].nullable)\n    [\"apple\",\nunittest\n{\n   \
    \ alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptbixdvfq.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptbixdvfq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    if (dict.empty) return false;\n\
    \    auto firstKey = dict.keys.front;\n    if (!is(typeof(firstKey) == string))\n\
    \        return false;\n    auto letter = firstKey[0];\n    return dict.keys.all!(k\
    \ => k[0] == letter);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprfk06uog.d(24): Error: no property `empty` for type `Nullable!(string[string])`

    /tmp/tmprfk06uog.d(25): Error: no property `front` for type `string[]`

    /tmp/tmprfk06uog.d(29): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprfk06uog.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu6xeuqaj.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x457709]

    ??:? void tmpu6xeuqaj.__unittest_L25_C1() [0x4420dd]

    ??:? void tmpu6xeuqaj.__modtest() [0x455214]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c494]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d0d]

    ??:? runModuleUnitTests [0x460831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b14]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n    if (is(typeof(dict) == Nullable!(string[string])))\n{\n    enum\
    \ key_type = KeyType.NONE;\n    foreach (key, value; dict) {\n        KeyType\
    \ currentKeyType = key_type.getKeyType(key);\n        if (key_type == KeyType.NONE)\
    \ {\n            key_type = currentKeyType;\n        } else if (key_type != currentKeyType)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3c1b5cml.d(22): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmp3c1b5cml.d(22): Error: declaration expected, not `if`

    /tmp/tmp3c1b5cml.d(25): Error: declaration expected, not `foreach`

    /tmp/tmp3c1b5cml.d(25): Error: no identifier for declarator `dict`

    /tmp/tmp3c1b5cml.d(25): Error: declaration expected, not `)`

    /tmp/tmp3c1b5cml.d(27): Error: declaration expected, not `if`

    /tmp/tmp3c1b5cml.d(29): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3c1b5cml.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164382
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    return dict.keys.all!(x\
    \ => x.isUpper) || dict.keys.all!(x => x.isLower);\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmqo0arvm.d(25): Error: no property `all` for type `string[]`

    /tmp/tmpmqo0arvm.d(25): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmqo0arvm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool all_lower = true;\n    bool all_upper = true;\n    if (dict\
    \ is null) return false;\n    foreach (k,v; dict)\n    {\n        if (k.length\
    \ > 0)\n        {\n            if (isLower(k[0])) all_upper = false;\n       \
    \     if (isUpper(k[0])) all_lower = false;\n        }\n    }\n    return all_lower\
    \ || all_upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoiuh5rls.d(30): Error: undefined identifier `isLower`

    /tmp/tmpoiuh5rls.d(31): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoiuh5rls.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool lower = true;\n    foreach(key; dict.keys)\n    {\n    \
    \    if(!is(typeof(key) == string))\n            return false;\n        bool isLower\
    \ = key.isLower();\n        if(lower && !isLower)\n            lower = false;\n\
    \        else if(!lower && isLower)\n            return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw0inhd0i.d(28): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw0inhd0i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) \n    {\n        return false;\n    }\n    immutable\
    \ int lowerCount = 0;\n    immutable int upperCount = 0;\n    foreach (item; dict.get)\
    \ \n    {\n        if (std.string.isLower(item.key)) \n        {\n           \
    \ lowerCount++;\n        }\n        else if (std.string.isUpper(item.key)) \n\
    \        {\n            upperCount++;\n        }\n        else \n        {\n \
    \           return false;\n        }\n    }\n    return lowerCount == dict.get.length\
    \ || upperCount == dict.get.length;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwh5zjlcf.d(31): Error: undefined identifier `string` in package
    `std`

    /tmp/tmpwh5zjlcf.d(33): Error: cannot modify `immutable` expression `0`

    /tmp/tmpwh5zjlcf.d(35): Error: undefined identifier `string` in package `std`

    /tmp/tmpwh5zjlcf.d(37): Error: cannot modify `immutable` expression `0`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwh5zjlcf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key, value; dict) \n    {\n        if(!is(typeof(key)\
    \ == string) || (isLower(key) && isUpper(key))) \n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo74rbyuj.d(25): Error: undefined identifier `isLower`

    /tmp/tmpo74rbyuj.d(25): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo74rbyuj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool allUpperCase = true;\n    bool allLowerCase = true;\n  \
    \  foreach(key; dict.keys)\n    {\n        if(isUpper(key[0])) allLowerCase =\
    \ false;\n        if(isLower(key[0])) allUpperCase = false;\n    }\n    return\
    \ allUpperCase || allLowerCase;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfl6kat_c.d(27): Error: undefined identifier `isUpper`

    /tmp/tmpfl6kat_c.d(28): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfl6kat_c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    /*\n    if (dict.isNull) \n    {\n        return false;\n   \
    \ }\n    */\n    if (dict.isNull || dict.isEmpty) \n    {\n        return false;\n\
    \    }\n    bool hasLower = false;\n    bool hasUpper = false;\n    foreach (key,\
    \ val; dict) \n    {\n        foreach (ch; key) \n        {\n            if (isUpper(ch))\
    \ \n            {\n                hasUpper = true;\n            }\n         \
    \   else if (isLower(ch)) \n            {\n                hasLower = true;\n\
    \            }\n            else \n            {\n                return false;\n\
    \            }\n        }\n    }\n    return hasLower == hasUpper;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyd0lwyab.d(29): Error: no property `isEmpty` for type `Nullable!(string[string])`

    /tmp/tmpyd0lwyab.d(39): Error: undefined identifier `isUpper`, did you mean variable
    `hasUpper`?

    /tmp/tmpyd0lwyab.d(43): Error: undefined identifier `isLower`, did you mean variable
    `hasLower`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyd0lwyab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict !is null && dict.all!(k => k.length == 0 || k[0].isLower\
    \ || k[0].isUpper);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmput8hwdul.d(23): Error: no property `all` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmput8hwdul.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin\n{\n    assert(dict.isNull);\n}\nout(result)\n{\n    assert(result\
    \ == true || result == false);\n}\nbody\n{\n    if (dict.isNull) \n    {\n   \
    \     return false;\n    }\n    else\n    {\n        string[string] d = dict.get!string[string]();\n\
    \        int lower = 0;\n        int upper = 0;\n        foreach (string k; d.keys)\n\
    \        {\n            if (k.length > 0)\n            {\n                if (k[0].isLower)\n\
    \                {\n                    lower++;\n                }\n        \
    \        else if (k[0].isUpper)\n                {\n                    upper++;\n\
    \                }\n                else\n                {\n                \
    \    return false;\n                }\n            }\n        }\n        return\
    \ (lower == 0 || upper == 0);\n    }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(2852):
    Error: incompatible types for `(fallback) : (this._value)`: `inout(string)` and
    `inout(string[string])`

    /tmp/tmpym06mzk4.d(38): Error: template instance `std.typecons.Nullable!(string[string]).Nullable.get!string`
    error instantiating

    /tmp/tmpym06mzk4.d(45): Error: no property `isLower` for type `immutable(char)`

    /tmp/tmpym06mzk4.d(49): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpym06mzk4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    bool result = true;\n\
    \    foreach (string key; dict.keys)\n    {\n        result = result && key.length\
    \ == 1 && key.equal_case_insensitive(\"a\");\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dtkihxu.d(28): Error: no property `equal_case_insensitive` for
    type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dtkihxu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    auto s = dict.keys.all!(s\
    \ => s.toLower() == s);\n    auto b = dict.keys.all!(s => s.toUpper() == s);\n\
    \    return s || b;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptjtsbksc.d(24): Error: no property `all` for type `string[]`

    /tmp/tmptjtsbksc.d(25): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptjtsbksc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    string dummy;\n    if (dict.isNull) \n    {\n        return false;\n\
    \    } \n    else if (dict.get.keys.length == 0) \n    {\n        return false;\n\
    \    }\n    else if (dict.get.keys[0].isLower(dummy)) \n    {\n        return\
    \ dict.get.keys.all!(x => x.isLower(dummy));\n    } \n    else if (dict.get.keys[0].isUpper(dummy))\
    \ \n    {\n        return dict.get.keys.all!(x => x.isUpper(dummy));\n    }\n\
    \    else \n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6__pcaum.d(32): Error: no property `isLower` for type `string`

    /tmp/tmp6__pcaum.d(34): Error: no property `all` for type `string[]`

    /tmp/tmp6__pcaum.d(36): Error: no property `isUpper` for type `string`

    /tmp/tmp6__pcaum.d(38): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6__pcaum.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    bool upper = true;\n\
    \    bool lower = true;\n    foreach (key; dict.keys) \n    {\n        if (!isUpper(key))\n\
    \            upper = false;\n        if (!isLower(key))\n            lower = false;\n\
    \    }\n    return upper || lower;\n}\n/*\n    * For example: given the following\
    \ lists of fruit, output their combined \n    total weight in kilograms, rounded\
    \ to the nearest whole number.\n    >>> list_sum([\"apple\": 5.0, \"banana\":\
    \ 5.5, \"pear\": 1.5], [\"apple\": 1.0, \"banana\": 2.0, \"grape\": 6.0])\n  \
    \  20.0\n    >>> list_sum([\"apple\": 5.0, \"banana\": 5.5, \"pear\": 1.5], [])\n\
    \    12.0\n    >>> list_sum([], [\"apple\": 1.0, \"banana\": 2.0, \"grape\": 6.0])\n\
    \    9.0\n    >>> list_sum([], [])\n    0.0\n*/\ndouble list_sum(string[double]\
    \ fruit1, string[double] fruit2) \n{\n    double total = 0.0;\n    // 1. Combine\
    \ the two lists. If a key is present in both lists, sum the values.\n    // fruit1\n\
    \    foreach (fruit; fruit1.keys) \n    {\n        total += fruit1[fruit];\n \
    \   }\n    // fruit2\n    foreach (fruit; fruit2.keys) \n    {\n        if (fruit1.find(fruit)\
    \ !is null)\n            total += fruit2[fruit];\n        else\n            total\
    \ += fruit2[fruit];\n    }\n    return total;\n}\n/*\n    2. Given a list of pairs\
    \ of a fruit name, weight in kilograms and its price per kilogram in USD, \n \
    \   return the total price of the list rounded to the nearest cent.\n    >>> list_price([\"\
    apple\": tuple(1.0, 2.0), \"banana\": tuple(2.0, 1.5), \"pear\": tuple(0.75, 4\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8qhl4inn.d(67): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8qhl4inn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    if (dict is null) \n    {\n        return false;\n    }\n\
    \    foreach (key, value; dict) \n    {\n        if (!is(typeof(key) == string))\
    \ \n        {\n            return false;\n        }\n        // Save the case\
    \ of the first key\n        if (dict.keys.length == 1) \n        {\n         \
    \   if (isLowerCase(key)) \n            {\n                // If the first key\
    \ is lower, return true if all following \n                // keys are lower\n\
    \                return dict.keys.all!(isLowerCase);\n            }\n        \
    \    if (isUpperCase(key)) \n            {\n                // If the first key\
    \ is upper, return true if all following \n                // keys are upper\n\
    \                return dict.keys.all!(isUpperCase);\n            }\n        }\n\
    \    }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx4lo0aye.d(37): Error: undefined identifier `isLowerCase`

    /tmp/tmpx4lo0aye.d(41): Error: no property `all` for type `string[]`

    /tmp/tmpx4lo0aye.d(43): Error: undefined identifier `isUpperCase`

    /tmp/tmpx4lo0aye.d(47): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx4lo0aye.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto case_checker = (d) => \n    {\n        auto keys = d.keys;\n\
    \        int upper = 0;\n        int lower = 0;\n        foreach(key; keys) \n\
    \        {\n            if(key.isUpperCase)\n                upper++;\n      \
    \      else if(key.isLowerCase)\n                lower++;\n        }\n       \
    \ return (upper > 0 && lower == 0) || (lower > 0 && upper == 0);\n    };\n   \
    \ return dict.isNull || case_checker(dict);\n}\n/*\n    Given a string, return\
    \ the first character in the string that has not \n    repeated again. For example,\
    \ given the string \"abacabde\", the function \n    should return 'e'.\n*/\nstring\
    \ find_non_repeating_char(string str) \n{\n    auto arr = str.chars;\n    foreach(ch;\
    \ arr) \n    {\n        if(str.count(ch) == 1)\n            return ch.to!string;\n\
    \    }\n    return \"\";\n}\n/*\n    Given a string and a list of words, return\
    \ all the words that contain \n    the string as a substring. The words can be\
    \ in any order.\n*/\nstring[] find_words_with_str(string s, string[] words) \n\
    {\n    string[] res;\n    foreach(word; words) \n    {\n        if(word.contains(s))\n\
    \            res ~= word;\n    }\n    return res;\n}\n/*\n    Given a list of\
    \ tuples, return the third item in each tuple.\n*/\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy60i374i.d(23): Error: variable `tmpy60i374i.check_dict_case.case_checker`
    type `void` is inferred from initializer `(d) => ()

    {

    auto keys = d.keys;

    int upper = 0;

    int lower = 0;

    foreach (key; keys)

    {

    if (key.isUpperCase)

    upper++;

    else if (key.isLowerCase)

    lower++;

    }

    return upper > 0 && (lower == 0) || lower > 0 && (upper == 0);

    }

    `, and variables cannot be of type `void`

    /tmp/tmpy60i374i.d(23): Error: template lambda has no value

    /tmp/tmpy60i374i.d(46): Error: no property `chars` for type `string`

    /tmp/tmpy60i374i.d(63): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy60i374i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.typecons : tuple;\n    import std.array : empty;\n\
    \    if (dict is null || dict.empty) \n    {\n        return false;\n    }\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmiam7mpe.d(29): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmiam7mpe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164383
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict.isNull ? false : dict.get().all!(e => is(typeof(e.key)\
    \ == string) && e.key.toLower() == e.key);\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4fjbv9pk.d(23): Error: no property `all` for type `string[string]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4fjbv9pk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.algorithm;\n    import std.algorithm.comparison;\n\
    \    import std.ascii;\n    import std.conv;\n    import std.range;\n    import\
    \ std.traits;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    return dict.fold!(false)((bool\
    \ s, string[string] d) => \n    s && d.byKey.map!(key => key.to!string).equal(\n\
    \    d.byKey.map!(key => key.to!string).toUpper()));\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp3gk4l9t.d(38): Error: template `std.ascii.toUpper` cannot deduce
    function from argument types `!()(MapResult!(__lambda4, Result))`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/ascii.d(628):        `std.ascii.toUpper(C)(C
    c) if (is(C : dchar))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp3gk4l9t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nin { \n    assert(dict !is null);\n} \nbody {\n    foreach(key; dict.keys)\
    \ {\n        if (key !is string) {\n            return false;\n        }\n   \
    \ }\n    bool lower_case = false;\n    bool upper_case = false;\n    foreach(key;\
    \ dict.keys) {\n        if (key.toLower == key) {\n            lower_case = true;\n\
    \        }\n        if (key.toUpper == key) {\n            upper_case = true;\n\
    \        }\n    }\n    return lower_case && !upper_case || !lower_case && upper_case;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqg3ctwuz.d(34): Error: no property `toLower` for type `string`

    /tmp/tmpqg3ctwuz.d(37): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqg3ctwuz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    //! dshorthand\n    if (dict is null) return false;\n    bool\
    \ lower = true;\n    bool upper = true;\n    foreach (value; dict) \n    {\n \
    \       if (!is(typeof(value.key) == string)) \n        {\n            return\
    \ false;\n        }\n        lower = lower && value.key.toLower() == value.key;\n\
    \        upper = upper && value.key.toUpper() == value.key;\n    }\n    return\
    \ lower || upper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt0941u6v.d(33): Error: no property `key` for type `string`

    /tmp/tmpt0941u6v.d(33): Error: no property `key` for type `string`

    /tmp/tmpt0941u6v.d(34): Error: no property `key` for type `string`

    /tmp/tmpt0941u6v.d(34): Error: no property `key` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt0941u6v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool u = true;\n    bool l = true;\n    foreach(string k, string\
    \ v; dict)\n    {\n        if (isLower(k))\n            u = false;\n        else\
    \ if (isUpper(k))\n            l = false;\n        else\n            return false;\n\
    \    }\n    return u || l;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz6ejj1az.d(27): Error: undefined identifier `isLower`

    /tmp/tmpz6ejj1az.d(29): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz6ejj1az.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    if (dict.length\
    \ == 0)\n        return false;\n    auto keys = dict.keys;\n    if (keys.length\
    \ == 0)\n        return false;\n    auto string_keys = keys.filter!(k => k is\
    \ string).map!(k => cast(string)k);\n    auto lower_keys = string_keys.filter!(k\
    \ => k.toLower == k);\n    auto upper_keys = string_keys.filter!(k => k.toUpper\
    \ == k);\n    if (lower_keys.length > 0 && upper_keys.length > 0)\n        return\
    \ false;\n    return true;\n}\n \nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv9uf2kqy.d(30): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv9uf2kqy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) return false;\n    if (dict.empty) return false;\n\
    \    int lower_case_keys = 0;\n    int upper_case_keys = 0;\n    foreach (key;\
    \ dict.keys)\n    {\n        if (key.toUpper() == key)\n        {\n          \
    \  upper_case_keys += 1;\n        }\n        else if (key.toLower() == key)\n\
    \        {\n            lower_case_keys += 1;\n        }\n        else\n     \
    \   {\n            return false;\n        }\n    }\n    return ((lower_case_keys\
    \ != 0) == (upper_case_keys != 0));\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi1grdv2z.d(24): Error: no property `empty` for type `Nullable!(string[string])`

    /tmp/tmpi1grdv2z.d(29): Error: no property `toUpper` for type `string`

    /tmp/tmpi1grdv2z.d(33): Error: no property `toLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi1grdv2z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \nnothrow @safe pure \n{\n    if (dict is null) return false;\n    if\
    \ (dict.length == 0) return false;\n    bool all_lower = true;\n    bool all_upper\
    \ = true;\n    auto it = dict.byKey.walk;\n    while(it.moveNext())\n    {\n \
    \       auto pair = it.current;\n        if (pair.key.length > 0)\n        {\n\
    \            if (pair.key.toUpper() != pair.key)\n            {\n            \
    \    all_upper = false;\n            }\n            if (pair.key.toLower() !=\
    \ pair.key)\n            {\n                all_lower = false;\n            }\n\
    \        }\n    }\n    return all_lower || all_upper;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4azk5nvx.d(28): Error: no property `walk` for type `Result`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4azk5nvx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ import std.conv;\n    bool first = true;\n    bool lower_case = false;\n   \
    \ foreach (pair; dict) \n    {\n        if (first) \n        {\n            lower_case\
    \ = to!string(pair.key) == toLower(pair.key);\n            first = false;\n  \
    \      }\n        if (lower_case && to!string(pair.key) != toLower(pair.key))\
    \ \n        {\n            return false;\n        } \n        else if (!lower_case\
    \ && to!string(pair.key) != toUpper(pair.key)) \n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc38_19oc.d(34): Error: no property `key` for type `string`

    /tmp/tmpc38_19oc.d(34): Error: undefined identifier `toLower`

    /tmp/tmpc38_19oc.d(37): Error: no property `key` for type `string`

    /tmp/tmpc38_19oc.d(37): Error: undefined identifier `toLower`

    /tmp/tmpc38_19oc.d(41): Error: no property `key` for type `string`

    /tmp/tmpc38_19oc.d(41): Error: undefined identifier `toUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc38_19oc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.algorithm : all;\n    import std.array : array;\n\
    \    return dict.map!(kv => !typeof(kv.key).isString || kv.key.toUpper() == kv.key).array.all;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcm085d8p.d(25): Error: no property `map` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcm085d8p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    static import std.typecons;\n    import std.conv;\n    import\
    \ std.string;\n    import std.array;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.math;\n    import std.ascii;\n    import std.regex;\n    import\
    \ std.typecons;\n    import std.typecons : Nullable;\n    bool result = false;\n\
    \    Nullable!(string[string]) test_dict;\n    test_dict = dict;\n    if(test_dict.isNull\
    \ || test_dict.isEmpty) \n    {\n        result = false;\n    } \n    else \n\
    \    {\n        bool all_keys_are_upper_case = all!(key => key.toUpper == key)(test_dict.keys);\n\
    \        bool all_keys_are_lower_case = all!(key => key.toLower == key)(test_dict.keys);\n\
    \        bool all_keys_are_strings = all!(key => is(typeof(key) == string))(test_dict.keys);\n\
    \        if(all_keys_are_upper_case) \n        {\n            result = true;\n\
    \        } \n        else if(all_keys_are_lower_case) \n        {\n          \
    \  result = true;\n        } \n        else if(all_keys_are_strings) \n      \
    \  {\n            result = false;\n        } \n        else \n        {\n    \
    \        result = false;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprs7znszz.d(37): Error: no property `isEmpty` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprs7znszz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    //TODO: Implement this function\n    import std.stdio;\n    import\
    \ std.conv;\n    import std.traits;\n    import std.algorithm;\n    import std.functional;\n\
    \    import std.array;\n    writeln(\"Please enter your dictionary: \");\n   \
    \ string[string] d = to!(string[string])(readln().idup);\n    int sz = d.length;\n\
    \    if (sz == 0)\n    {\n        return false;\n    }\n    auto a1 = d.keys;\n\
    \    string[string] new_dict;\n    foreach(i; 0..a1.length)\n    {\n        new_dict[to!string(a1[i])]\
    \ = d[a1[i]];\n    }\n    auto keys = new_dict.keys;\n    bool all_lower = all!(a\
    \ => a == a.toLower)(keys);\n    bool all_upper = all!(a => a == a.toUpper)(keys);\n\
    \    if (all_lower || all_upper)\n    {\n        return true;\n    }\n    else\n\
    \    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpld_va413.d(32): Error: cannot implicitly convert expression `_aaLen(d)`
    of type `ulong` to `int`

    /tmp/tmpld_va413.d(44): Error: template `tmpld_va413.check_dict_case.all!((a)
    => a == a.toLower).all` cannot deduce function from argument types `!()(string[])`,
    candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(122):        `tmpld_va413.check_dict_case.all!((a)
    => a == a.toLower).all(Range)(Range range) if (isInputRange!Range && is(typeof(unaryFun!pred(range.front))))`

    /tmp/tmpld_va413.d(45): Error: template `tmpld_va413.check_dict_case.all!((a)
    => a == a.toUpper).all` cannot deduce function from argument types `!()(string[])`,
    candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(122):        `tmpld_va413.check_dict_case.all!((a)
    => a == a.toUpper).all(Range)(Range range) if (isInputRange!Range && is(typeof(unaryFun!pred(range.front))))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpld_va413.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n        return false;\n    bool lower_keys\
    \ = true;\n    bool upper_keys = true;\n    foreach (k,v; dict)\n    {\n     \
    \   if (!(k.isLower)) lower_keys = false;\n        if (!(k.isUpper)) upper_keys\
    \ = false;\n    }\n    return lower_keys || upper_keys;\n}\n \nunittest\n{\n \
    \   alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsyewbwqk.d(29): Error: no property `isLower` for type `string`

    /tmp/tmpsyewbwqk.d(30): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsyewbwqk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool isUpper = false;\n    bool isLower = false;\n    foreach(key,\
    \ value; dict)\n    {\n        if(key.length > 0)\n        {\n            //string\
    \ u = key.toUpper;\n            string l = key.toLower;\n            if(key !=\
    \ l)\n            {\n                isLower = true;\n            }\n        \
    \    if(key != l.toUpper)\n            {\n                isUpper = true;\n  \
    \          }\n        }\n    }\n    if(isUpper && isLower)\n    {\n        return\
    \ false;\n    }\n    else if(isUpper)\n    {\n        return true;\n    }\n  \
    \  else if(isLower)\n    {\n        return true;\n    }\n    else\n    {\n   \
    \     return false;\n    }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpei07gmvz.d(30): Error: no property `toLower` for type `string`

    /tmp/tmpei07gmvz.d(35): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpei07gmvz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ return dict.all!(kvp => isLower(kvp.key) || isUpper(kvp.key));\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8k2bh9yo.d(27): Error: no property `all` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8k2bh9yo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    if (dict.length\
    \ == 0)\n        return false;\n    bool allLower = true;\n    bool allUpper =\
    \ true;\n    foreach (key; dict.keys)\n    {\n        allLower = allLower && key.isLower;\n\
    \        allUpper = allUpper && key.isUpper;\n    }\n    return allLower || allUpper;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjhaa11bw.d(31): Error: no property `isLower` for type `string`

    /tmp/tmpjhaa11bw.d(32): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjhaa11bw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.exception : enforce;\n    import std.range : isInputRange,\
    \ splitter, joiner;\n    import std.typecons : tuple;\n    import std.traits :\
    \ isSame;\n    import std.algorithm : contains;\n    import std.array : elementType;\n\
    \    import std.conv : to;\n    import std.meta : AliasSeq;\n    import std.meta\
    \ : AliasSeqOf;\n    import std.meta : ValueTypeTuple;\n    import std.functional\
    \ : unaryFun;\n    import std.uni : isUpper, isLower;\n    import std.array :\
    \ map;\n    import std.algorithm : count;\n    import std.typecons : isSome;\n\
    \    import std.typecons : isNone;\n    /*\n        AliasSeqOf!(string) is the\
    \ same as\n        alias KeyTypes = AliasSeq!(string);\n        alias KeyTypes\
    \ = typeof([\"a\": \"apple\", \"b\": \"banana\"]).KeyTypes;\n    */\n    static\
    \ if(isSome!(dict))\n    {\n        alias KeyTypes = AliasSeqOf!(dict);\n    \
    \    // mixin debugKeyTypes;\n        assert(isInputRange!(KeyTypes));\n     \
    \   alias KeyType = KeyTypes.elementType;\n        /*\n            map!(dict.byKey,\
    \ KeyTypes) returns tuple of lambda functions\n            map!(dict.byKey, KeyTypes).tupleof\
    \ returns tuple of lambda functions\n            map!(dict.byKey, KeyTypes).tupleof[0]\
    \ returns lambda function\n            map!(dict.byKey, KeyTypes).tupleof[0]()\
    \ returns lambda function result\n            map!(dict.byKey, KeyTypes).tupleof[0]()\
    \ == dict[\"a\"]\n        */\n        auto keys = map!(dict.byKey, KeyTypes).tupleof;\n\
    \        foreach(index, key; keys)\n        {\n            if(!is(KeyType == string))\n\
    \            {\n                return false;\n            }\n            if(index\
    \ == 0)\n            {\n                if(isUpper(key))\n                {\n\
    \                    if(count!(unaryFun\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp58b_fy5z.d(69): Error: found `unittest` when expecting `)` following
    template argument list

    /tmp/tmp58b_fy5z.d(70): Error: found `{` when expecting `)`

    /tmp/tmp58b_fy5z.d(81): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp58b_fy5z.d(81): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp58b_fy5z.d(81): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp58b_fy5z.d(81): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp58b_fy5z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    import std.algorithm\
    \ : all;\n    bool allLower = all!(k => isLower(k))(dict.keys);\n    bool allUpper\
    \ = all!(k => isUpper(k))(dict.keys);\n    return (allLower || allUpper);\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ymh9k0y.d(26): Error: template `tmp9ymh9k0y.check_dict_case.all!((k)
    => isLower(k)).all` cannot deduce function from argument types `!()(string[])`,
    candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(122):        `tmp9ymh9k0y.check_dict_case.all!((k)
    => isLower(k)).all(Range)(Range range) if (isInputRange!Range && is(typeof(unaryFun!pred(range.front))))`

    /tmp/tmp9ymh9k0y.d(27): Error: template `tmp9ymh9k0y.check_dict_case.all!((k)
    => isUpper(k)).all` cannot deduce function from argument types `!()(string[])`,
    candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(122):        `tmp9ymh9k0y.check_dict_case.all!((k)
    => isUpper(k)).all(Range)(Range range) if (isInputRange!Range && is(typeof(unaryFun!pred(range.front))))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ymh9k0y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.conv;\n    import std.ascii;\n    bool seenUpper =\
    \ false;\n    bool seenLower = false;\n    foreach(k; dict.keys())\n    {\n  \
    \      if (k.isLower)\n        {\n            seenLower = true;\n        }\n \
    \       else if (k.isUpper)\n        {\n            seenUpper = true;\n      \
    \  }\n        else\n        {\n            return false;\n        }\n    }\n \
    \   return seenUpper == seenLower;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbvbfvdk8.d(29): Error: function `std.ascii.isLower(dchar c)` is
    not callable using argument types `(string)`

    /tmp/tmpbvbfvdk8.d(29):        cannot pass argument `k` of type `string` to parameter
    `dchar c`

    /tmp/tmpbvbfvdk8.d(33): Error: function `std.ascii.isUpper(dchar c)` is not callable
    using argument types `(string)`

    /tmp/tmpbvbfvdk8.d(33):        cannot pass argument `k` of type `string` to parameter
    `dchar c`

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) \n    {\n        return false;\n    }\n    bool\
    \ lower = true;\n    foreach(k; dict.keys) \n    {\n        if(!k.isAlpha || k.isLower\
    \ != lower)\n        {\n            return false;\n        }\n        lower =\
    \ k.isLower;\n    }\n    return true;\n}\n \nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsk_2rfqb.d(30): Error: no property `isAlpha` for type `string`

    /tmp/tmpsk_2rfqb.d(30): Error: no property `isLower` for type `string`

    /tmp/tmpsk_2rfqb.d(34): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsk_2rfqb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    if (dict.length\
    \ == 0)\n        return false;\n    string[] keys = dict.keys;\n    bool allLower\
    \ = true;\n    bool allUpper = true;\n    foreach (key; keys)\n    {\n       \
    \ if (key.isUpper)\n            allLower = false;\n        else if (key.isLower)\n\
    \            allUpper = false;\n        else\n            return false;\n    }\n\
    \    return allLower || allUpper;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv4mr9gq9.d(32): Error: no property `isUpper` for type `string`

    /tmp/tmpv4mr9gq9.d(34): Error: no property `isLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv4mr9gq9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return false;\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpneg_5qrh.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpneg_5qrh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null)\n        return false;\n    bool firstUpper\
    \ = isUpper(dict.keys[0]);\n    foreach (key; dict.keys)\n    {\n        if (firstUpper\
    \ && !isUpper(key))\n            return false;\n        if (!firstUpper && !isLower(key))\n\
    \            return false;\n    }\n    return true;\n}\n/*\n    Given a file name\
    \ and a list of lines, write the contents to the file.\n    If the file name is\
    \ null, do nothing and return false.\n    If the file name is not null, write\
    \ each line to the file and return true.\n    Examples:\n    >>> writeLinesToFile(\"\
    F:\\\\test.txt\", [\"line 1\", \"line 2\", \"line 3\"])\n    true\n    >>> writeLinesToFile(null,\
    \ [\"line 1\", \"line 2\", \"line 3\"])\n    false\n*/\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2xbhltlo.d(25): Error: undefined identifier `isUpper`

    /tmp/tmp2xbhltlo.d(28): Error: undefined identifier `isUpper`

    /tmp/tmp2xbhltlo.d(30): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2xbhltlo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ enum boo = true;\n    for (string key; dict.byKey) \n    {\n        if (key.isUpperCase)\
    \ \n        {\n            if (boo) \n            {\n                boo = false;\n\
    \            } \n            else if (!boo) \n            {\n                return\
    \ false;\n            }\n        } \n        else if (key.isLowerCase) \n    \
    \    {\n            if (!boo) \n            {\n                return false;\n\
    \            }\n        } \n        else \n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n/*\n    Given a list of strings, return\
    \ a list of integers that indicate the minimum \n    length of the string. If\
    \ a word is not found in the list, ignore it.\n    If the list is empty or null,\
    \ return an empty list.\n    Examples:\n    >>> get_minimum_length([\"banana\"\
    , \"apple\", \"mango\", \"banana\", \"banana\"].nullable)\n    [4, 3, 5, 4, 4]\n\
    \    >>> get_minimum_length([\"banana\", \"apple\", \"mango\", \"banana\", \"\
    banana\", \"watermelon\"].nullable)\n    [4, 3, 5, 4, 4, 10]\n    >>> get_minimum_length([\"\
    apple\", \"banana\", \"apple\", \"banana\", \"apple\", \"banana\"].nullable)\n\
    \    [3, 4, 3, 4, 3, 4]\n    >>> get_minimum_length([\"durian\", \"banana\", \"\
    apple\", \"banana\", \"banana\", \"watermelon\"].nullable)\n    [5, 4, 3, 4, 4,\
    \ 10]\n    >>> get_minimum_length([\"durian\", \"banana\", \"apple\", \"durian\"\
    , \"banana\", \"watermelon\"].nullable)\n    [5, 4, 3, 5, 4, 10]\n    >>> get_minimum_length([\"\
    durian\", \"durian\", \"durian\", \"durian\", \"durian\", \"\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp97g504su.d(28): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp97g504su.d(53): Error: found `return` when expecting `)`

    /tmp/tmp97g504su.d(55): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp97g504su.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ bool check = false;\n    for (auto kvp; dict) \n    {\n        if (kvp.key.isLower)\
    \ \n        {\n            if (check) \n            {\n                return\
    \ false;\n            }\n            check = true;\n        }\n        else if\
    \ (kvp.key.isUpper) \n        {\n            if (!check) \n            {\n   \
    \             return false;\n            }\n        }\n        else \n       \
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcnlyne6_.d(28): Error: no identifier for declarator `kvp`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcnlyne6_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    string[string] d = dict!;\n    bool islower = true;\n    bool\
    \ isupper = true;\n    bool isstrkey = true;\n    foreach(key,val; d)\n    {\n\
    \        islower = islower && key.isLower;\n        isupper = isupper && key.isUpper;\n\
    \        isstrkey = isstrkey && (key is string);\n    }\n    return (islower ||\
    \ isupper) && isstrkey;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqofuv8rx.d(23): Error: template argument expected following `!`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqofuv8rx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict.map!(d => d.keys.map!(k => to!string(k).toLower()\
    \ == k).reduce!(a, b => a && b) ||\n                          d.keys.map!(k =>\
    \ to!string(k).toUpper() == k).reduce!(a, b => a && b)).getOrElse(false);\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ri_6fs9.d(23): Error: no property `map` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ri_6fs9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    /*\n        >>> check_dict_case([\"a\": \"apple\", \"b\": \"\
    banana\"].nullable)\n        true\n        >>> check_dict_case([\"a\": \"apple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable)\n        false\n        >>>\
    \ check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \        false\n        >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"].nullable)\n        false\n        >>> check_dict_case([\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n        true\n    */\n    if (dict.isNull)\
    \ return false;\n    string[] szKeys = dict.get.keys;\n    bool bCaseIsLower =\
    \ szKeys[0].isLowerCase;\n    /*\n        >>> check_dict_case([\"a\": \"apple\"\
    , \"b\": \"banana\"].nullable)\n        true\n        >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n        false\n\
    \        >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"\
    ].nullable)\n        false\n        >>> check_dict_case([\"Name\": \"John\", \"\
    Age\": \"36\", \"City\": \"Houston\"].nullable)\n        false\n        >>> check_dict_case([\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n        true\n    */\n    for\
    \ (auto key; szKeys)\n    {\n        /*\n            >>> check_dict_case([\"a\"\
    : \"apple\", \"b\": \"banana\"].nullable)\n            true\n            >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n            false\n\
    \            >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"\
    apple\"].nullable)\n            false\n            >>> check_dict_case(\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl1c04q86.d(50): Error: no identifier for declarator `key`

    /tmp/tmpl1c04q86.d(52): Error: unterminated /* */ comment

    /tmp/tmpl1c04q86.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpl1c04q86.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl1c04q86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result;\n    bool lower = true;\n    bool upper = true;\n\
    \    if (dict is null)\n    {\n        result = false;\n    }\n    else\n    {\n\
    \        foreach (key; dict.keys)\n        {\n            if (key.toLower() !=\
    \ key)\n            {\n                lower = false;\n            }\n       \
    \     if (key.toUpper() != key)\n            {\n                upper = false;\n\
    \            }\n        }\n        result = (lower || upper);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa_ywzpb8.d(34): Error: no property `toLower` for type `string`

    /tmp/tmpa_ywzpb8.d(38): Error: no property `toUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa_ywzpb8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    switch (dict) \n    {\n        case null:\n            return\
    \ false;\n        case string[string] x:\n            string[] keys = x.keys.array;\n\
    \            if (keys.length > 0) \n            {\n                bool lo = true;\n\
    \                bool up = true;\n                foreach (y; keys) \n       \
    \         {\n                    if (y != y.toLower)\n                       \
    \ lo = false;\n                    if (y != y.toUpper)\n                     \
    \   up = false;\n                }\n                return (lo || up);\n     \
    \       }\n            else\n                return false;\n    }\n}\n/*\n   \
    \ Unittest:\n    assert(check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable));\n\
    \    assert(!check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable));\n    assert(!check_dict_case([\"a\": \"apple\", 8L: \"banana\",\
    \ \"a\": \"apple\"].nullable));\n    assert(!check_dict_case([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\"].nullable));\n    assert(check_dict_case([\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"].nullable));\n*/\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr1s31kh7.d(27): Error: found `x` when expecting `:`

    /tmp/tmpr1s31kh7.d(27): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr1s31kh7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164384
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ alias kv = typeof(dict).KeyValue;\n    auto keys = dict.keys;\n    int len =\
    \ keys.length;\n    if (len == 0) \n    {\n        return false;\n    }\n    bool\
    \ all_lower = keys[0].isLower;\n    if (all_lower) \n    {\n        foreach (key;\
    \ keys) \n        {\n            if (!key.isLower) \n            {\n         \
    \       return false;\n            }\n        }\n    }\n    else \n    {\n   \
    \     foreach (key; keys) \n        {\n            if (!key.isUpper) \n      \
    \      {\n                return false;\n            }\n        }\n    }\n   \
    \ return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnid09rd6.d(27): Error: no property `KeyValue` for type `Nullable!(string[string])`

    /tmp/tmpnid09rd6.d(29): Error: cannot implicitly convert expression `keys.length`
    of type `ulong` to `int`

    /tmp/tmpnid09rd6.d(34): Error: no property `isLower` for type `string`

    /tmp/tmpnid09rd6.d(39): Error: no property `isLower` for type `string`

    /tmp/tmpnid09rd6.d(49): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnid09rd6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    //checking if the dictionary is empty\n    if(dict is null)\n\
    \    {\n        return false;\n    }\n    //getting the collection of keys from\
    \ the dictionary\n    auto keys = dict.keys;\n    //declaring variables\n    bool\
    \ allLower = true;\n    bool allUpper = true;\n    //looping through the keys\n\
    \    foreach(string key; keys)\n    {\n        //checking if the key is in upper\
    \ case\n        if(key.toUpper() != key)\n        {\n            allUpper = false;\n\
    \        }\n        //checking if the key is in lower case\n        if(key.toLower()\
    \ != key)\n        {\n            allLower = false;\n        }\n    }\n    //returning\
    \ true if either allUpper or allLower is true\n    return allUpper || allLower;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2jx2eqkv.d(37): Error: no property `toUpper` for type `string`

    /tmp/tmp2jx2eqkv.d(42): Error: no property `toLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2jx2eqkv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n        return false;\n    foreach (key,value;\
    \ dict)\n    {\n        if (is(typeof(key) == string))\n        {\n          \
    \  if(key[0].isUpper)\n                return false;\n        }\n        else\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk12du0mz.d(29): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk12du0mz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.algorithm;\n    import std.conv;\n    if(dict == null)\
    \ return false;\n    bool res = true;\n    dict.each!(key => {\n        res &=\
    \ (key.to!string.length == key.toUpper.length) || \n            (key.to!string.length\
    \ == key.toLower.length);\n    });\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgfhiern5.d(27): Error: template `tmpgfhiern5.check_dict_case.each!((key)
    => ()

    {

    res &= key.to!string.length == key.toUpper.length || key.to!string.length == key.toLower.length;

    }

    ).each` cannot deduce function from argument types `!()(Nullable!(string[string]))`,
    candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(906):        `tmpgfhiern5.check_dict_case.each!((key)
    => ()

    {

    res &= key.to!string.length == key.toUpper.length || key.to!string.length == key.toLower.length;

    }

    ).each(Range)(Range r) if (!isForeachIterable!Range && (isRangeIterable!Range
    || __traits(compiles, typeof(r.front).length)))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(945):        `tmpgfhiern5.check_dict_case.each!((key)
    => ()

    {

    res &= key.to!string.length == key.toUpper.length || key.to!string.length == key.toLower.length;

    }

    ).each(Iterable)(auto ref Iterable r) if (isForeachIterable!Iterable || __traits(compiles,
    Parameters!(Parameters!(r.opApply))))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgfhiern5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    string lower_case_key = \"\";\n    string upper_case_key = \"\
    \";\n    bool lower_case_exists = false;\n    bool upper_case_exists = false;\n\
    \    foreach(key, value; dict) \n    {\n        if(key.length > 0) \n        {\n\
    \            if(key[0].isLower) \n            {\n                lower_case_exists\
    \ = true;\n                lower_case_key = key;\n            } \n           \
    \ else if(key[0].isUpper) \n            {\n                upper_case_exists =\
    \ true;\n                upper_case_key = key;\n            } \n            else\
    \ \n            {\n                return false;\n            }\n        }\n \
    \   }\n    if(lower_case_exists && upper_case_exists) \n    {\n        return\
    \ false;\n    }\n    if(lower_case_exists) \n    {\n        foreach(key, value;\
    \ dict) \n        {\n            if(key != lower_case_key.toLower) \n        \
    \    {\n                return false;\n            }\n        }\n    }\n    if(upper_case_exists)\
    \ \n    {\n        foreach(key, value; dict) \n        {\n            if(key !=\
    \ upper_case_key.toUpper) \n            {\n                return false;\n   \
    \         }\n        }\n    }\n    return true;\n}\n/*\n    Given two lists of\
    \ integer numbers, nums1 and nums2, compute a list \n    of positive integers\
    \ from the first list that are not present in the \n    second list.\n    Examples:\n\
    \    >>> get_missing_ints([1, 2, 3, 4, 5], [1, 2, 5, 9, 10])\n    [3, 4]\n   \
    \ >>> get_missing_ints([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n    []\n    >>> get_missing_ints([1,\
    \ 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    >>> get_missing_ints([1, 2, 3, 4\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3otyukw6.d(73): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3otyukw6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    import std.array : appender;\n    import std.algorithm : all;\n\
    \    import std.algorithm : any;\n    import std.uni : toLower, toUpper;\n   \
    \ import std.range : takeWhile;\n    import std.string : startsWith;\n    import\
    \ std.getopt : ArgvInput;\n    import std.typecons : isSome;\n    if(isSome!(dict))\
    \ \n    {\n        string[] keys = dict.keys;\n        if(keys.any!(x => x.startsWith(\"\
    A\") || x.startsWith(\"a\"))) \n        {\n            auto lower = keys.takeWhile!(x\
    \ => x.startsWith(\"a\") || x.startsWith(\"A\"));\n            if(lower.all!(x\
    \ => x.toLower == x)) \n            {\n                return true;\n        \
    \    }\n        }\n        if(keys.any!(x => x.startsWith(\"Z\") || x.startsWith(\"\
    z\"))) \n        {\n            auto upper = keys.takeWhile!(x => x.startsWith(\"\
    z\") || x.startsWith(\"Z\"));\n            if(upper.all!(x => x.toUpper == x))\
    \ \n            {\n                return true;\n            }\n        }\n  \
    \  }\n    return false;\n}\n/*\n    Given a string, return true if it matches\
    \ the regular expression\n    /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$/\n\
    \    >>> check_email(\"me@somehost.co.uk\")\n    true\n    >>> check_email(\"\
    me@somehost.com\")\n    true\n    >>> check_email(\"me@somehost.a\")\n    false\n\
    \    >>> check_email(\"me@somehost.a2\")\n    false\n    >>> check_email(\"me@somehost.1234\"\
    )\n    false\n    >>> check_email(\"me@123.co.uk\")\n    true\n    >>> check_email(\"\
    me@123.com\")\n    true\n    >>> check_email(\"me@\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkchsrqrr.d(53): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkchsrqrr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is null) \n    {\n        return false;\n    }\n   \
    \ string[] keys = dict.keys;\n    if (keys.length == 0) \n    {\n        return\
    \ false;\n    }\n    string[] upper_keys = keys.map!((string elem) => \n     \
    \   return elem.toUpper;\n    );\n    string[] lower_keys = keys.map!((string\
    \ elem) => \n        return elem.toLower;\n    );\n    bool result = (upper_keys\
    \ == keys) || (lower_keys == keys);\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxrajdauf.d(33): Error: expression expected, not `return`

    /tmp/tmpxrajdauf.d(33): Error: found `elem` when expecting `)` following template
    argument list

    /tmp/tmpxrajdauf.d(34): Error: found `)` instead of statement

    /tmp/tmpxrajdauf.d(36): Error: expression expected, not `return`

    /tmp/tmpxrajdauf.d(36): Error: found `elem` when expecting `)` following template
    argument list

    /tmp/tmpxrajdauf.d(37): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxrajdauf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict is null) \n    {\n        return false;\n    }\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptrg1kuvp.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptrg1kuvp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164385
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool lower_case_present = false;\n    bool upper_case_present\
    \ = false;\n    foreach(key; dict.keys)\n    {\n        if(isUpper(key[0]))\n\
    \        {\n            upper_case_present = true;\n        }\n        else\n\
    \        {\n            lower_case_present = true;\n        }\n    }\n    return\
    \ (lower_case_present && upper_case_present) ? false : true;\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvd6mj3wm.d(27): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvd6mj3wm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164386
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = false;\n    if(dict.isNull)\n        return result;\n\
    \    bool isUpper = true;\n    foreach(key; dict.get.keys)\n    {\n        if(isUpper\
    \ && islower(key[0]))\n        {\n            result = false;\n            break;\n\
    \        }\n        else if(!isUpper && isupper(key[0]))\n        {\n        \
    \    result = false;\n            break;\n        }\n        else\n        {\n\
    \            isUpper = false;\n            result = true;\n        }\n    }\n\
    \    return result;\n}\n/*\n    Find the least common multiple (lcm) of n1 and\
    \ n2.\n    lcm is the smallest positive integer that is divisible by both n1 and\
    \ n2.\n    Examples:\n    >>> lcm(6, 4)\n    12\n    >>> lcm(12, 14)\n    84\n\
    \    >>> lcm(9, 5)\n    45\n*/\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg1f5riv2.d(29): Error: undefined identifier `islower`

    /tmp/tmpg1f5riv2.d(34): Error: undefined identifier `isupper`, did you mean variable
    `isUpper`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg1f5riv2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164386
