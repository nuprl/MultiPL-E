name: HumanEval_145_order_by_points
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
  \ sorts the given array of integers\n    in ascending order according to the sum\
  \ of their digits.\n    Note: if there are several items with similar sum of their\
  \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
  \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
  \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
  \ nums) \n"
tests: "unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
  \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
  \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
  \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L,\
  \ -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
  \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
completions: ["{\n    int[] l = new int[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        int sum = 0;\n        while (nums[i] != 0)\n        {\n\
    \            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n   \
    \     l[i] = sum;\n    }\n    Tuple!(int, long)[] sorted = sort!((t) => t[0],\
    \ Tuple!(int, long)(l, nums));\n    return sorted[$].tupleof[1];\n}", "{\n   \
    \ static struct Pair {\n        long num;\n        int digitsSum;\n        string\
    \ toString() { return format(\"(%s, %s)\", num, digitsSum); }\n    }\n    static\
    \ auto sum = (int n) {\n        if (n < 10)\n            return n;\n        else\n\
    \            return n % 10 + sum(n / 10);\n    };\n    if (nums.length == 0)\n\
    \        return nums;\n    auto p = nums.map!(n => Pair(n, sum(abs(n))));\n  \
    \  auto p2 = p.sort!((a, b) => a.digitsSum > b.digitsSum || (a.digitsSum == b.digitsSum\
    \ && a.num > b.num));\n    return p2.map!(x => x.num).array;\n}", "{\n    // your\
    \ code here\n    typeof(return) result = new typeof(return)(nums.length);\n  \
    \  int[] points = new int[nums.length];\n    int[] indices = new int[nums.length];\n\
    \    foreach(int i,long n; zip(i,nums))\n    {\n        indices[i] = i;\n    \
    \    points[i] = n.abs().sumDigits();\n    }\n    std.algorithm.sort(zip(points,indices));\n\
    \    foreach(i,p;points)\n    {\n        result[i] = nums[p];\n    }\n    return\
    \ result;\n}", "{\n    // return sort!((x, y) => sumDigits(x) < sumDigits(y))(nums);\n\
    \    auto my_tuple = zip(nums, iota(nums.length))\n            .map!(tuple =>\
    \ tupleof(tuple[0], sumDigits(tuple[0]), tuple[1]))\n            .sort!((t1, t2)\
    \ => t1[1] < t2[1] || (t1[1] == t2[1] && t1[2] < t2[2]));\n    return my_tuple.map!(tuple\
    \ => tuple[0]).array;\n}", "{\n    long[] res = new long[nums.length];\n    int[]\
    \ sums = new int[nums.length];\n    for (int i = 0; i < nums.length; i++)\n  \
    \  {\n        sums[i] = sumOfDigits(nums[i]);\n    }\n    string[] sumsStrs =\
    \ sums.map!(to!string);\n    string[] numsStrs = nums.map!(to!string);\n    string[]\
    \ zipped = zip(sumsStrs, numsStrs).map!((a, b) => a ~ b).sort.map!(to!string);\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        res[i] = to!long(zipped[i][1\
    \ .. $]);\n    }\n    return res;\n}", "{\n  auto y = nums.map!(x => tuple(x,\
    \ x.digits.sum())).sort!((a, b) => a[1] < b[1]);\n  return y.map!(x => x[0]).array;\n\
    }", "{\n    long[] result = nums;\n    static struct Item\n    {\n        int\
    \ value;\n        int position;\n    }\n    struct Item item;\n    Item[] items\
    \ = new Item[];\n    int i = 0;\n    foreach(n; nums)\n    {\n        item.value\
    \ = n;\n        item.position = i;\n        items ~= item;\n        i++;\n   \
    \ }\n    auto sort_fn = (a, b) => (a.value.digits.sum).cmp(b.value.digits.sum);\n\
    \    items.sort(sort_fn);\n    i = 0;\n    foreach(item; items)\n    {\n     \
    \   result[i] = item.value;\n        i++;\n    }\n    return result;\n}", "{\n\
    \    int n = nums.length;\n    if (n == 0) \n        return nums;\n    static\
    \ struct Pair { int num; int index; } \n    Pair[] newArr = new Pair[n];\n   \
    \ //int[] newArr = new int[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\
    \ \n    {\n        //newArr[i] = nums[i];\n        newArr[i].num = nums[i];\n\
    \        newArr[i].index = i;\n    }\n    //\n    int sumDigits(int val) \n  \
    \  {\n        int sum = 0;\n        int sign = 1;\n        if (val < 0) \n   \
    \     {\n            sign = -1;\n            val = val * sign;\n        }\n  \
    \      while (val != 0) \n        {\n            sum += val % 10;\n          \
    \  val /= 10;\n        }\n        return sum * sign;\n    }\n    //\n    //auto\
    \ newArr = nums.dup;\n    newArr.sort!(\n        (a, b) => (sumDigits(a.num) ==\
    \ sumDigits(b.num)) ?\n            a.index < b.index :\n            sumDigits(a.num)\
    \ < sumDigits(b.num)\n    );\n    foreach (i; 0 .. n) \n    {\n        nums[i]\
    \ = newArr[i].num;\n    }\n    return nums;\n}", "{\n    if (nums.length == 0)\
    \ \n    {\n        return [];\n    }\n    else\n    {\n        return nums.sort!((a,\
    \ b) => a.to!string.sum(&unparsed => cast(long) unparsed) < b.to!string.sum(&unparsed\
    \ => cast(long) unparsed));\n    }\n}", "{\n    long[ubyte] points = new long[ubyte];\n\
    \    foreach(i, v; nums)\n    {\n        long point = 0;\n        foreach(auto\
    \ d; v.to!string())\n        {\n            if(d.isDigit)\n                point\
    \ += d.getDigit;\n        }\n        points[i] = point;\n    }\n    auto m = zip(points,\
    \ nums);\n    m.sort!((a, b) => a[0] > b[0] || (a[0] == b[0] && a[1] > b[1]));\n\
    \    return m.map!(a => a[1]).array;\n}\n \n/*\n    Write a function that takes\
    \ in a string and returns a map of the form\n    char => int, where int is the\
    \ number of times the char appears in the string.\n    If string is empty, return\
    \ an empty map.\n    Ignore spaces, punctuation and other non-letter characters.\n\
    \    \n    For example:\n    >>> letter_count(\"The quick brown fox\")\n    ['h':\
    \ 1, 'e': 1, 'q': 1, 'u': 1, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 1, 'o': 2, 'w':\
    \ 1, 'n': 1, 'f': 1, 'x': 1]\n    >>> letter_count(\"the king and the royal family\"\
    )\n    ['t': 1, 'h': 2, 'e': 3, 'k': 1, 'i': 1, 'n': 2, 'g': 2, 'a': 1, 'd': 1,\
    \ 'r': 2, 'o': 2, 'y': 1, 'l': 1, 'f': 1, 'm': 1]\n    >>> letter_count(\"aa bb\
    \ cc\")\n    ['a': 2, 'b': 2, 'c': 2]\n    >>> letter_count(\"\")\n    []\n*/\n\
    long[char] letter_count(string s) \n{\n    long[char] ret = new long[char];\n\
    \    foreach(c; s.lower)\n    {\n        if(c.isLetter)\n            ret[", "{\n\
    \    return nums.sort!((a, b) => sumDigits(a) < sumDigits(b));\n}", "{\n    long[]\
    \ nums_copy = nums.dup;\n    int[] indices = iota(nums.length);\n    sort!(nums,\
    \ (x, y) => sum(x.digits) < sum(y.digits));\n    sort!(indices, (x, y) => sum(nums[x].digits)\
    \ < sum(nums[y].digits));\n    return indices.map!(i => nums_copy[i]).array;\n\
    }", "{\n    struct Point\n    {\n        int value;\n        int idx;\n    }\n\
    \    auto points = new Point[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        points[i].value = nums[i];\n        points[i].idx = i;\n\
    \    }\n    sort!((a, b) => {\n                int ai = a.value;\n           \
    \     int bi = b.value;\n                bool neg = false;\n                if\
    \ (ai < 0)\n                {\n                    ai = -ai;\n               \
    \     neg = true;\n                }\n                if (bi < 0)\n          \
    \      {\n                    bi = -bi;\n                    neg = true;\n   \
    \             }\n                int da = 0;\n                int db = 0;\n  \
    \              while (ai != 0)\n                {\n                    da += ai\
    \ % 10;\n                    ai /= 10;\n                }\n                while\
    \ (bi != 0)\n                {\n                    db += bi % 10;\n         \
    \           bi /= 10;\n                }\n                if (neg)\n         \
    \       {\n                    da = -da;\n                    db = -db;\n    \
    \            }\n                if (da == db)\n                    return a.idx\
    \ < b.idx;\n                return da < db;\n            })(points);\n    auto\
    \ result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \        result[i] = points[i].value;\n    return result;\n}", "{\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    struct Pair{\n        long\
    \ nums;\n        long index;\n    }\n    \n    long[] sums = new long[nums.length];\n\
    \    int j = 0;\n    foreach(index, num; nums)\n    {\n        long sum = 0;\n\
    \        while(num != 0)\n        {\n            sum += num % 10;\n          \
    \  num /= 10;\n        }\n        sums[j] = sum;\n        j++;\n    }\n    \n\
    \    Pair[] pairs = new Pair[nums.length];\n    for(int i = 0; i < nums.length;\
    \ i++)\n    {\n        pairs[i].nums = nums[i];\n        pairs[i].index = i;\n\
    \    }\n    \n    int i = 0;\n    foreach(index, p; pairs)\n    {\n        long\
    \ sum = 0;\n        while(p.nums != 0)\n        {\n            sum += p.nums %\
    \ 10;\n            p.nums /= 10;\n        }\n        sums[i] = sum;\n        i++;\n\
    \    }\n    \n    i = 0;\n    foreach(num; sums)\n    {\n        sums[i] += pairs[i].index;\n\
    \        i++;\n    }\n    \n    std.algorithm.sort!(\"a < b\")(sums);\n    \n\
    \    foreach(num; sums)\n    {\n        writeln(num);\n    }\n    \n    return\
    \ nums;\n}", "{\n    if (nums.length == 0) return nums;\n    return zip(nums,\
    \ map!(a => (a < 0 ? sum((-a).to!string.split(\"\").map!(to!long)) : sum(a.to!string.split(\"\
    \").map!(to!long)))(a)).array)().sort!q{a[1] < b[1]}.map!q{a[0]}.array;\n}", "{\n\
    \    // assign points to array of integers\n    long[] pointArray = [];\n    long[]\
    \ sortedArray = [];\n    long[] pointArraySort = [];\n    long[] sortedArraySort\
    \ = [];\n    int count = 0;\n    foreach(nums, x)\n    {\n        long point =\
    \ 0;\n        point = x;\n        pointArray ~= point;\n        foreach(to!string(x),y)\n\
    \        {\n            point += digitValue(y);\n        }\n        pointArray[count]\
    \ = point;\n        count++;\n    }\n    //sort points array\n    pointArraySort\
    \ = sort(pointArray);\n    //sort array\n    int numsCount = 0;\n    foreach(pointArraySort,\
    \ x)\n    {\n        int index = 0;\n        foreach(pointArray, y)\n        {\n\
    \            if(x == y)\n            {\n                sortedArray ~= nums[index];\n\
    \                break;\n            }\n            index++;\n        }\n    }\n\
    \    return sortedArray;\n}", "{\n    int r = 0;\n    int g = 0;\n    long l =\
    \ 0;\n    long[][] q = new long[nums.length][2];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        l = nums[i];\n        while (l != 0)\n        {\n     \
    \       r = (int)(l % 10);\n            l = (long)(l / 10);\n            g +=\
    \ r;\n        }\n        q[i][0] = g;\n        q[i][1] = nums[i];\n        g =\
    \ 0;\n    }\n    sort(q);\n    for (int i = 0; i < nums.length; i++)\n    {\n\
    \        nums[i] = q[i][1];\n    }\n    return nums;\n}", "{\n    if (nums.length\
    \ == 0)\n        return nums;\n    \n    bool[] nagative = new bool[nums.length];\n\
    \    int[] sum = new int[nums.length];\n    long[] result = new long[nums.length];\n\
    \    \n    for (int i = 0; i < nums.length; i++)\n    {\n        nagative[i] =\
    \ nums[i] < 0;\n        nums[i] = abs(nums[i]);\n        sum[i] = (int)(nums[i]\
    \ % 10);\n        nums[i] /= 10;\n        while (nums[i] != 0)\n        {\n  \
    \          sum[i] += (int)(nums[i] % 10);\n            nums[i] /= 10;\n      \
    \  }\n    }\n    \n    int[] map = new int[nums.length];\n    for (int i = 0;\
    \ i < nums.length; i++)\n        map[i] = i;\n    sort(map, (a, b) => sum[a] !=\
    \ sum[b] ? sum[a] - sum[b] : a - b);\n    \n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        int idx = map[i];\n        result[i] = nagative[idx] ?\
    \ -nums[idx] : nums[idx];\n    }\n    \n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(int i, long num; nums)\n    {\n        long x = 0;\n  \
    \      while(num > 0)\n        {\n            x += num % 10;\n            num\
    \ /= 10;\n        }\n        nums[i] = x;\n    }\n    auto cmp = (x, y) => x[0]\
    \ < y[0] || (x[0] == y[0] && x[1] < y[1]);\n    auto zipped = zip(nums, iota(nums.length));\n\
    \    zipped.sort(cmp);\n    foreach(i, tuple!(long, long) value; zipped)\n   \
    \ {\n        nums[i] = value[1];\n    }\n    return nums;\n}\n/*\n    Write a\
    \ function that takes in an array of integers and returns the\n    length of the\
    \ longest peak in the array. A peak is defined as adjacent\n    integers in the\
    \ array that are strictly increasing until they reach a\n    tip (the highest\
    \ value in the peak), at which point they become\n    strictly decreasing. At\
    \ least three integers are required to form a peak.", "{\n    return std.typecons.map!((n)\
    \ => n[0])(\n                std.algorithm.sort!((a, b) => a[1] < b[1])(\n   \
    \                 std.array.filter!((n) => n[1] != 0)(\n                     \
    \   std.typecons.zip(nums, std.algorithm.map!((n) => n.digits.fold!q{a + b}(0))(nums)))));\n\
    }\n \n \n \n \n/*\n    A Pythagorean triplet is a set of three natural numbers,\n\
    \    a < b < c, for which, a2 + b2 = c2\n    For example, 32 + 42 = 9 + 16 = 25\
    \ = 52.\n    There exists exactly one Pythagorean triplet for which a + b + c\
    \ = 1000.\n    Find the product abc.\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
