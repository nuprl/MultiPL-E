name: HumanEval_145_order_by_points
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
  \ sorts the given array of integers\n    in ascending order according to the sum\
  \ of their digits.\n    Note: if there are several items with similar sum of their\
  \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
  \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
  \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
  \ nums) \n"
tests: "unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
  \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
  \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
  \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L,\
  \ -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
  \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
completions: ["{\n    int[] l = new int[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        int sum = 0;\n        while (nums[i] != 0)\n        {\n\
    \            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n   \
    \     l[i] = sum;\n    }\n    Tuple!(int, long)[] sorted = sort!((t) => t[0],\
    \ Tuple!(int, long)(l, nums));\n    return sorted[$].tupleof[1];\n}", "{\n   \
    \ static struct Pair {\n        long num;\n        int digitsSum;\n        string\
    \ toString() { return format(\"(%s, %s)\", num, digitsSum); }\n    }\n    static\
    \ auto sum = (int n) {\n        if (n < 10)\n            return n;\n        else\n\
    \            return n % 10 + sum(n / 10);\n    };\n    if (nums.length == 0)\n\
    \        return nums;\n    auto p = nums.map!(n => Pair(n, sum(abs(n))));\n  \
    \  auto p2 = p.sort!((a, b) => a.digitsSum > b.digitsSum || (a.digitsSum == b.digitsSum\
    \ && a.num > b.num));\n    return p2.map!(x => x.num).array;\n}", "{\n    // your\
    \ code here\n    typeof(return) result = new typeof(return)(nums.length);\n  \
    \  int[] points = new int[nums.length];\n    int[] indices = new int[nums.length];\n\
    \    foreach(int i,long n; zip(i,nums))\n    {\n        indices[i] = i;\n    \
    \    points[i] = n.abs().sumDigits();\n    }\n    std.algorithm.sort(zip(points,indices));\n\
    \    foreach(i,p;points)\n    {\n        result[i] = nums[p];\n    }\n    return\
    \ result;\n}", "{\n    // return sort!((x, y) => sumDigits(x) < sumDigits(y))(nums);\n\
    \    auto my_tuple = zip(nums, iota(nums.length))\n            .map!(tuple =>\
    \ tupleof(tuple[0], sumDigits(tuple[0]), tuple[1]))\n            .sort!((t1, t2)\
    \ => t1[1] < t2[1] || (t1[1] == t2[1] && t1[2] < t2[2]));\n    return my_tuple.map!(tuple\
    \ => tuple[0]).array;\n}", "{\n    long[] res = new long[nums.length];\n    int[]\
    \ sums = new int[nums.length];\n    for (int i = 0; i < nums.length; i++)\n  \
    \  {\n        sums[i] = sumOfDigits(nums[i]);\n    }\n    string[] sumsStrs =\
    \ sums.map!(to!string);\n    string[] numsStrs = nums.map!(to!string);\n    string[]\
    \ zipped = zip(sumsStrs, numsStrs).map!((a, b) => a ~ b).sort.map!(to!string);\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        res[i] = to!long(zipped[i][1\
    \ .. $]);\n    }\n    return res;\n}", "{\n  auto y = nums.map!(x => tuple(x,\
    \ x.digits.sum())).sort!((a, b) => a[1] < b[1]);\n  return y.map!(x => x[0]).array;\n\
    }", "{\n    long[] result = nums;\n    static struct Item\n    {\n        int\
    \ value;\n        int position;\n    }\n    struct Item item;\n    Item[] items\
    \ = new Item[];\n    int i = 0;\n    foreach(n; nums)\n    {\n        item.value\
    \ = n;\n        item.position = i;\n        items ~= item;\n        i++;\n   \
    \ }\n    auto sort_fn = (a, b) => (a.value.digits.sum).cmp(b.value.digits.sum);\n\
    \    items.sort(sort_fn);\n    i = 0;\n    foreach(item; items)\n    {\n     \
    \   result[i] = item.value;\n        i++;\n    }\n    return result;\n}", "{\n\
    \    int n = nums.length;\n    if (n == 0) \n        return nums;\n    static\
    \ struct Pair { int num; int index; } \n    Pair[] newArr = new Pair[n];\n   \
    \ //int[] newArr = new int[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\
    \ \n    {\n        //newArr[i] = nums[i];\n        newArr[i].num = nums[i];\n\
    \        newArr[i].index = i;\n    }\n    //\n    int sumDigits(int val) \n  \
    \  {\n        int sum = 0;\n        int sign = 1;\n        if (val < 0) \n   \
    \     {\n            sign = -1;\n            val = val * sign;\n        }\n  \
    \      while (val != 0) \n        {\n            sum += val % 10;\n          \
    \  val /= 10;\n        }\n        return sum * sign;\n    }\n    //\n    //auto\
    \ newArr = nums.dup;\n    newArr.sort!(\n        (a, b) => (sumDigits(a.num) ==\
    \ sumDigits(b.num)) ?\n            a.index < b.index :\n            sumDigits(a.num)\
    \ < sumDigits(b.num)\n    );\n    foreach (i; 0 .. n) \n    {\n        nums[i]\
    \ = newArr[i].num;\n    }\n    return nums;\n}", "{\n    if (nums.length == 0)\
    \ \n    {\n        return [];\n    }\n    else\n    {\n        return nums.sort!((a,\
    \ b) => a.to!string.sum(&unparsed => cast(long) unparsed) < b.to!string.sum(&unparsed\
    \ => cast(long) unparsed));\n    }\n}", "{\n    long[ubyte] points = new long[ubyte];\n\
    \    foreach(i, v; nums)\n    {\n        long point = 0;\n        foreach(auto\
    \ d; v.to!string())\n        {\n            if(d.isDigit)\n                point\
    \ += d.getDigit;\n        }\n        points[i] = point;\n    }\n    auto m = zip(points,\
    \ nums);\n    m.sort!((a, b) => a[0] > b[0] || (a[0] == b[0] && a[1] > b[1]));\n\
    \    return m.map!(a => a[1]).array;\n}\n \n/*\n    Write a function that takes\
    \ in a string and returns a map of the form\n    char => int, where int is the\
    \ number of times the char appears in the string.\n    If string is empty, return\
    \ an empty map.\n    Ignore spaces, punctuation and other non-letter characters.\n\
    \    \n    For example:\n    >>> letter_count(\"The quick brown fox\")\n    ['h':\
    \ 1, 'e': 1, 'q': 1, 'u': 1, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 1, 'o': 2, 'w':\
    \ 1, 'n': 1, 'f': 1, 'x': 1]\n    >>> letter_count(\"the king and the royal family\"\
    )\n    ['t': 1, 'h': 2, 'e': 3, 'k': 1, 'i': 1, 'n': 2, 'g': 2, 'a': 1, 'd': 1,\
    \ 'r': 2, 'o': 2, 'y': 1, 'l': 1, 'f': 1, 'm': 1]\n    >>> letter_count(\"aa bb\
    \ cc\")\n    ['a': 2, 'b': 2, 'c': 2]\n    >>> letter_count(\"\")\n    []\n*/\n\
    long[char] letter_count(string s) \n{\n    long[char] ret = new long[char];\n\
    \    foreach(c; s.lower)\n    {\n        if(c.isLetter)\n            ret[", "{\n\
    \    return nums.sort!((a, b) => sumDigits(a) < sumDigits(b));\n}", "{\n    long[]\
    \ nums_copy = nums.dup;\n    int[] indices = iota(nums.length);\n    sort!(nums,\
    \ (x, y) => sum(x.digits) < sum(y.digits));\n    sort!(indices, (x, y) => sum(nums[x].digits)\
    \ < sum(nums[y].digits));\n    return indices.map!(i => nums_copy[i]).array;\n\
    }", "{\n    struct Point\n    {\n        int value;\n        int idx;\n    }\n\
    \    auto points = new Point[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        points[i].value = nums[i];\n        points[i].idx = i;\n\
    \    }\n    sort!((a, b) => {\n                int ai = a.value;\n           \
    \     int bi = b.value;\n                bool neg = false;\n                if\
    \ (ai < 0)\n                {\n                    ai = -ai;\n               \
    \     neg = true;\n                }\n                if (bi < 0)\n          \
    \      {\n                    bi = -bi;\n                    neg = true;\n   \
    \             }\n                int da = 0;\n                int db = 0;\n  \
    \              while (ai != 0)\n                {\n                    da += ai\
    \ % 10;\n                    ai /= 10;\n                }\n                while\
    \ (bi != 0)\n                {\n                    db += bi % 10;\n         \
    \           bi /= 10;\n                }\n                if (neg)\n         \
    \       {\n                    da = -da;\n                    db = -db;\n    \
    \            }\n                if (da == db)\n                    return a.idx\
    \ < b.idx;\n                return da < db;\n            })(points);\n    auto\
    \ result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \        result[i] = points[i].value;\n    return result;\n}", "{\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    struct Pair{\n        long\
    \ nums;\n        long index;\n    }\n    \n    long[] sums = new long[nums.length];\n\
    \    int j = 0;\n    foreach(index, num; nums)\n    {\n        long sum = 0;\n\
    \        while(num != 0)\n        {\n            sum += num % 10;\n          \
    \  num /= 10;\n        }\n        sums[j] = sum;\n        j++;\n    }\n    \n\
    \    Pair[] pairs = new Pair[nums.length];\n    for(int i = 0; i < nums.length;\
    \ i++)\n    {\n        pairs[i].nums = nums[i];\n        pairs[i].index = i;\n\
    \    }\n    \n    int i = 0;\n    foreach(index, p; pairs)\n    {\n        long\
    \ sum = 0;\n        while(p.nums != 0)\n        {\n            sum += p.nums %\
    \ 10;\n            p.nums /= 10;\n        }\n        sums[i] = sum;\n        i++;\n\
    \    }\n    \n    i = 0;\n    foreach(num; sums)\n    {\n        sums[i] += pairs[i].index;\n\
    \        i++;\n    }\n    \n    std.algorithm.sort!(\"a < b\")(sums);\n    \n\
    \    foreach(num; sums)\n    {\n        writeln(num);\n    }\n    \n    return\
    \ nums;\n}", "{\n    if (nums.length == 0) return nums;\n    return zip(nums,\
    \ map!(a => (a < 0 ? sum((-a).to!string.split(\"\").map!(to!long)) : sum(a.to!string.split(\"\
    \").map!(to!long)))(a)).array)().sort!q{a[1] < b[1]}.map!q{a[0]}.array;\n}", "{\n\
    \    // assign points to array of integers\n    long[] pointArray = [];\n    long[]\
    \ sortedArray = [];\n    long[] pointArraySort = [];\n    long[] sortedArraySort\
    \ = [];\n    int count = 0;\n    foreach(nums, x)\n    {\n        long point =\
    \ 0;\n        point = x;\n        pointArray ~= point;\n        foreach(to!string(x),y)\n\
    \        {\n            point += digitValue(y);\n        }\n        pointArray[count]\
    \ = point;\n        count++;\n    }\n    //sort points array\n    pointArraySort\
    \ = sort(pointArray);\n    //sort array\n    int numsCount = 0;\n    foreach(pointArraySort,\
    \ x)\n    {\n        int index = 0;\n        foreach(pointArray, y)\n        {\n\
    \            if(x == y)\n            {\n                sortedArray ~= nums[index];\n\
    \                break;\n            }\n            index++;\n        }\n    }\n\
    \    return sortedArray;\n}", "{\n    int r = 0;\n    int g = 0;\n    long l =\
    \ 0;\n    long[][] q = new long[nums.length][2];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        l = nums[i];\n        while (l != 0)\n        {\n     \
    \       r = (int)(l % 10);\n            l = (long)(l / 10);\n            g +=\
    \ r;\n        }\n        q[i][0] = g;\n        q[i][1] = nums[i];\n        g =\
    \ 0;\n    }\n    sort(q);\n    for (int i = 0; i < nums.length; i++)\n    {\n\
    \        nums[i] = q[i][1];\n    }\n    return nums;\n}", "{\n    if (nums.length\
    \ == 0)\n        return nums;\n    \n    bool[] nagative = new bool[nums.length];\n\
    \    int[] sum = new int[nums.length];\n    long[] result = new long[nums.length];\n\
    \    \n    for (int i = 0; i < nums.length; i++)\n    {\n        nagative[i] =\
    \ nums[i] < 0;\n        nums[i] = abs(nums[i]);\n        sum[i] = (int)(nums[i]\
    \ % 10);\n        nums[i] /= 10;\n        while (nums[i] != 0)\n        {\n  \
    \          sum[i] += (int)(nums[i] % 10);\n            nums[i] /= 10;\n      \
    \  }\n    }\n    \n    int[] map = new int[nums.length];\n    for (int i = 0;\
    \ i < nums.length; i++)\n        map[i] = i;\n    sort(map, (a, b) => sum[a] !=\
    \ sum[b] ? sum[a] - sum[b] : a - b);\n    \n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        int idx = map[i];\n        result[i] = nagative[idx] ?\
    \ -nums[idx] : nums[idx];\n    }\n    \n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(int i, long num; nums)\n    {\n        long x = 0;\n  \
    \      while(num > 0)\n        {\n            x += num % 10;\n            num\
    \ /= 10;\n        }\n        nums[i] = x;\n    }\n    auto cmp = (x, y) => x[0]\
    \ < y[0] || (x[0] == y[0] && x[1] < y[1]);\n    auto zipped = zip(nums, iota(nums.length));\n\
    \    zipped.sort(cmp);\n    foreach(i, tuple!(long, long) value; zipped)\n   \
    \ {\n        nums[i] = value[1];\n    }\n    return nums;\n}\n/*\n    Write a\
    \ function that takes in an array of integers and returns the\n    length of the\
    \ longest peak in the array. A peak is defined as adjacent\n    integers in the\
    \ array that are strictly increasing until they reach a\n    tip (the highest\
    \ value in the peak), at which point they become\n    strictly decreasing. At\
    \ least three integers are required to form a peak.", "{\n    return std.typecons.map!((n)\
    \ => n[0])(\n                std.algorithm.sort!((a, b) => a[1] < b[1])(\n   \
    \                 std.array.filter!((n) => n[1] != 0)(\n                     \
    \   std.typecons.zip(nums, std.algorithm.map!((n) => n.digits.fold!q{a + b}(0))(nums)))));\n\
    }\n \n \n \n \n/*\n    A Pythagorean triplet is a set of three natural numbers,\n\
    \    a < b < c, for which, a2 + b2 = c2\n    For example, 32 + 42 = 9 + 16 = 25\
    \ = 52.\n    There exists exactly one Pythagorean triplet for which a + b + c\
    \ = 1000.\n    Find the product abc.\n*/", "{\n    auto t = std.typecons.Tuple!(long,\
    \ int)(0,0);\n    return nums.sort!(a => std.math.reduce!((a, b) => a + b)(a.toString().map!(x\
    \ => to!int(x.toString())).array()), b => std.math.reduce!((a, b) => a + b)(b.toString().map!(x\
    \ => to!int(x.toString())).array())).array();\n}\n ", "{\n    auto sums = new\
    \ long[nums.length];\n    for (int i = 0; i < nums.length; i++)\n    {\n     \
    \   auto n = nums[i];\n        long s = 0;\n        while (n != 0)\n        {\n\
    \            s += n % 10;\n            n /= 10;\n        }\n        sums[i] =\
    \ s;\n    }\n    return zip(sums, nums).sort!q{ a[0] < b[0] || (a[0] == b[0] &&\
    \ a[1] < b[1]) }.map!q{ a[1] }.array;\n}\n ", "{\n  nums.sort!((a, b) => \n  {\n\
    \    int sumA = 0;\n    int sumB = 0;\n    foreach(n; a.toString.split(\"\").map!(\"\
    to!int\")[])\n      sumA += n;\n    foreach(n; b.toString.split(\"\").map!(\"\
    to!int\")[])\n      sumB += n;\n    return sumA < sumB;\n  });\n  return nums;\n\
    }", "{\n    int[] sums = new int[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        long num = nums[i];\n        while (num != 0)\n       \
    \ {\n            sums[i] += num % 10;\n            num /= 10;\n        }\n   \
    \ }\n    auto result = tuple(nums, sums);\n    result = sort(result, (t1, t2)\
    \ => t1[1] < t2[1] || (t1[1] == t2[1] && t1[0] < t2[0]));\n    return result.map!(t\
    \ => t[0]).array;\n}", "{\n    if (nums.length < 2)\n        return nums;\n  \
    \  return nums.sort!((a, b) => digits(a) < digits(b) || (digits(a) == digits(b)\
    \ && a < b));\n}", "{\n    long[] result;\n    int[] sums;\n    auto[res, sum]\
    \ = std.typecons.tuple(result, sums);\n    foreach(n; nums)\n    {\n        int\
    \ sum_digits = 0;\n        if(n < 0)\n        {\n            long pos = -n;\n\
    \            while(pos)\n            {\n                sum_digits += cast(int)(pos\
    \ % 10);\n                pos /= 10;\n            }\n        }\n        else\n\
    \        {\n            while(n)\n            {\n                sum_digits +=\
    \ cast(int)(n % 10);\n                n /= 10;\n            }\n        }\n   \
    \     res ~= n;\n        sum ~= sum_digits;\n    }\n    int[] sorted_indexes =\
    \ sort!((a, b) => sum[a] < sum[b])(iota(sum.length));\n    for(int i = 0; i <\
    \ res.length; i++)\n    {\n        result[i] = res[sorted_indexes[i]];\n    }\n\
    \    return result;\n}", "{\n    int[] out = nums.dup;", "{\n    /*return nums.sort!((a,\
    \ b) => \n    {\n        int aSum = 0;\n        int bSum = 0;\n        foreach(var\
    \ el; nums)\n        {\n            aSum += a % 10;\n            bSum += b % 10;\n\
    \        }\n        return aSum == bSum ? a.idx > b.idx : aSum > bSum;\n    });*/\n\
    \    \n    return nums.sort!((a, b) => (a % 10) + (a / 10) > (b % 10) + (b / 10)\
    \ ? 1 : (a % 10) + (a / 10) < (b % 10) + (b / 10) ? -1 : 0);\n}", "{\n    nums\
    \ = nums.copy();\n    nums.sort!(x => std.math.sum(x.digits))();\n    return nums;\n\
    }", "{\n    long[] result;\n    result = new long[nums.length];\n    int i, j,\
    \ temp;\n    for (i = 0; i < nums.length; i++)\n    {\n        for (j = i + 1;\
    \ j < nums.length; j++)\n        {\n            if (abs(nums[i]) > abs(nums[j]))\n\
    \            {\n                temp = nums[i];\n                nums[i] = nums[j];\n\
    \                nums[j] = temp;\n            }\n        }\n    }\n    return\
    \ nums;\n}", "{\n  // Write your solution here.\n  long[] index_array = new long[nums.length];\n\
    \  long[] sum_array = new long[nums.length];\n  long[] result = new long[nums.length];\n\
    \  for(int i = 0; i < nums.length; i++)\n  {\n    index_array[i] = i;\n    sum_array[i]\
    \ = 0;\n    long n = nums[i];\n    if(n < 0)\n    {\n      n = -n;\n    }\n  \
    \  while(n != 0)\n    {\n      sum_array[i] += n % 10;\n      n /= 10;\n    }\n\
    \  }\n  sort!(\"a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]\")(zip(sum_array,\
    \ index_array));\n  for(int i = 0; i < nums.length; i++)\n  {\n    result[i] =\
    \ nums[index_array[i]];\n  }\n  return result;\n}", "{\n    if (nums.length ==\
    \ 0)\n        return nums;\n    else\n    {\n        long[] result = new long[nums.length];\n\
    \        std.sort!(\"a.sumDigits().cmp(b.sumDigits())\")(nums);\n        foreach\
    \ (i, e; nums)\n            result[i] = e;\n        return result;\n    }\n}",
  "{\n    //Tuple!(long, long)[] temp = new Tuple!(long, long)[nums.length];\n   \
    \ //Tuple!(long, long)[] result = new Tuple!(long, long)[nums.length];\n    Tuple!(long,\
    \ long)[] temp = nums.map!(a => tuple(a, 0L)).array;\n    Tuple!(long, long)[]\
    \ result = new Tuple!(long, long)[nums.length];\n    long digitsum;\n    foreach(it,\
    \ i; temp)\n    {\n        digitsum = 0L;\n        foreach(digit; to!string(it[0]).split(\"\
    \"))\n        {\n            digitsum += to!long(digit);\n        }\n        it[1]\
    \ = digitsum;\n    }\n    temp.sort!(\"a[1] < b[1] || (a[1] == b[1] && a[0] <\
    \ b[0])\");\n    foreach(it, i; temp)\n    {\n        result[i] = tuple(it[0],\
    \ i);\n    }\n    result.sort!(\"a[1] < b[1]\");\n    return result.map!(a =>\
    \ a[0]).array;\n}", "{ \n    // Type your solution here.\n    enum Item(long num,\
    \ long points)\n    {\n        this(long num)\n        {\n            this.num\
    \ = num;\n            this.points = to!int(num).byValue.map!(int => abs(int)).sum;\n\
    \        }\n    }\n    auto range = nums.map!(num => Item(num));\n    return range.map!(item\
    \ => item.num).sort!((a, b) => a.points < b.points).array;\n}\n ", "{\n    if\
    \ (nums.length == 0)\n        return [];\n    \n    auto a = nums.map!(x => tuple(x,\
    \ x.abs.sum)).array();\n    a.sort!((a, b) => a[1] < b[1] || a[1] == b[1] && a[0]\
    \ < b[0]);\n    return a.map!(x => x[0]).array();\n}", "{\n    if (nums.length\
    \ == 0) return nums;\n    int[] sum_digits = new int[nums.length];\n    foreach\
    \ (index, item; nums) {\n        sum_digits[index] = reduce!((a, b) => a + b)(map!(a\
    \ => a - '0')(to!string(item)));\n    }\n    return nums[array(zip(sum_digits,\
    \ iota(nums.length))).sort.map!(a => a[1])];\n}", "{\n    static struct SumDigits\n\
    \    {\n        long sum;\n        long index;\n    }\n    SumDigits[] sumDigitsList\
    \ = nums.map!(n => SumDigits(n.abs.sumOfDigits, n)).array;\n    auto sorted_list\
    \ = sort!((a, b) => a.sum < b.sum || (a.sum == b.sum && a.index < b.index))(sumDigitsList);\n\
    \    return sorted_list.map!(e => e.index).array;\n}", "{\n    return nums.sort!((n1,\
    \ n2) => n1.sumOfDigits.compare(n2.sumOfDigits));\n}", "{\n    if (nums.length\
    \ == 0)\n        return new long[0];\n    \n    alias Tuple!(long, long) Item;\n\
    \    Item[] items = new Item[nums.length];\n    int i = 0;\n    foreach (l; nums)\n\
    \    {\n        items[i] = tuple(l, 0);\n        if (l >= 0)\n        {\n    \
    \        while (l)\n            {\n                items[i].tupleof[1] += l %\
    \ 10;\n                l /= 10;\n            }\n        }\n        else\n    \
    \    {\n            while (l)\n            {\n                items[i].tupleof[1]\
    \ -= l % 10;\n                l /= 10;\n            }\n        }\n        i++;\n\
    \    }\n    \n    items.sort!(\"a.tupleof[1] < b.tupleof[1]\");\n    long[] res\
    \ = new long[nums.length];\n    i = 0;\n    foreach (item; items)\n    {\n   \
    \     res[i] = item.tupleof[0];\n        i++;\n    }\n    return res;\n}", "{\n\
    \    auto arr = zip(iota(nums.length), nums);\n    arr.sort!((a, b) =>\n    {\n\
    \        auto [i,x] = a;\n        auto [j,y] = b;\n        return sumOfDigits(x)\
    \ < sumOfDigits(y) || (sumOfDigits(x) == sumOfDigits(y) && i < j);\n    });\n\
    \    return arr.map!((a) => a[1]).array;\n}", "{\n  int[] a = new int[nums.length];\n\
    \  int[int] b = new int[int];\n  long[] result = new long[nums.length];\n  int\
    \ sum = 0;\n  for (int i = 0; i < nums.length; i++) {\n    long number = nums[i];\n\
    \    for (int j = 0; j < i; j++) {\n      if (number == a[j]) {\n        break;\n\
    \      }\n    }\n    while (number != 0) {\n      sum += cast(int) number % 10;\n\
    \      number /= 10;\n    }\n    b[sum] = i;\n    a[i] = sum;\n    sum = 0;\n\
    \  }\n  sort(a);\n  for (int i = 0; i < nums.length; i++) {\n    result[i] = nums[b[a[i]]];\n\
    \  }\n  return result;\n}", "{\n    enum Nums(long num, int sum) \n    {\n   \
    \     Nums(long num, int sum) \n        {\n            this.num = num;\n     \
    \       this.sum = sum;\n        }\n    }\n    auto sorted_nums = Nums[nums.length];\n\
    \    foreach(i, num; nums) \n    {\n        auto sum = 0;\n        foreach(digit;\
    \ num.to!string()) \n        {\n            sum += digit.to!int() - '0'.to!int();\n\
    \        }\n        sorted_nums[i] = Nums(num, sum);\n    }\n    sorted_nums.sort!((a,\
    \ b) { return a.sum < b.sum || (a.sum == b.sum && a.num < b.num); });\n    return\
    \ sorted_nums.map!(a => a.num).array;\n}", "{\n    return nums.map!(n => tuple(n,\
    \ n.abs.to!string.map!(c => c.to!long).sum)).sort!((t1, t2) => t1[1] > t2[1] ||\
    \ (t1[1] == t2[1] && t1[0] > t2[0])).map!(t => t[0]).array;\n}", "{\n    if (nums.length\
    \ == 0)\n        return nums;\n    \n    /*\n    This uses a bit of indirection,\
    \ but is way simpler to code than \n    trying to work out how to use range.sort\n\
    \    */\n    auto indices = iota(nums.length);\n    static bool cmp(ref long a,\
    \ ref long b)\n    {\n        if (sumDigits(a) == sumDigits(b))\n            return\
    \ a < b;\n        return sumDigits(a) < sumDigits(b);\n    }\n    sort(indices,\
    \ cmp);\n    long[] result = new long[nums.length];\n    foreach (i, idx; indices)\n\
    \        result[i] = nums[idx];\n    return result;\n}", "{\n    auto nums_indices\
    \ = zip(nums, iota(nums.length));\n    auto nums_indices_sum = nums_indices.sort!((a,\
    \ b) => sumDigits(a[0]) < sumDigits(b[0]) || (sumDigits(a[0]) == sumDigits(b[0])\
    \ && a[1] < b[1]));\n    return nums_indices_sum.map!(x => x[0]).array;\n}\nlong\
    \ sumDigits(long num)\n{\n    long result = 0;\n    foreach(i; num.digits)\n \
    \   {\n        result += i;\n    }\n    return result;\n}", "{\n    import std.algorithm.sorting;\n\
    \    import std.algorithm.comparison;\n    import std.math;\n    import std.array;\n\
    \    import std.conv;\n    import std.range;\n    import std.stdio;\n    struct\
    \ Pair\n    {\n        long a;\n        long b;\n    }\n    auto len = nums.length;\n\
    \    if(len == 0)\n        return nums;\n    auto pair = new Pair[len];\n    for(int\
    \ i = 0; i < len; i++)\n    {\n        pair[i].a = nums[i];\n        pair[i].b\
    \ = 0;\n        string str = nums[i].to!string;\n        foreach(c; str)\n   \
    \     {\n            pair[i].b += c.to!long;\n        }\n    }\n    pair.sort!((x,\
    \ y) => (x.b < y.b));\n    long[] res = new long[len];\n    for(int i = 0; i <\
    \ len; i++)\n    {\n        res[i] = pair[i].a;\n    }\n    return res;\n}", "{\n\
    \    struct IntDescriptor{long[] digits; int index;long fullNumber;}", "{\n  \
    \  long[] num_copy = nums.dup;\n    //insertion sort\n    for (int i = 1; i <\
    \ num_copy.length; i++)\n    {\n        long temp = num_copy[i];\n        int\
    \ j = i - 1;\n        while (j >= 0 && temp < num_copy[j])\n        {\n      \
    \      num_copy[j + 1] = num_copy[j];\n            j = j - 1;\n        }\n   \
    \     num_copy[j + 1] = temp;\n    }\n    return num_copy;\n}", "{\n    //return\
    \ nums.sort!((n, m) => { return n.sumDigits().cmp(m.sumDigits()); });\n    const\
    \ IndexedValue!long[] c = nums.map!(n => { return tuple(n.sumDigits(), n); });\n\
    \    return c.sort!((n, m) => { return n[0].cmp(m[0]); }).map!(t => { return t[1];\
    \ }).array;\n}", "{\n    // your code goes here\n    import std.typecons : tuple;\n\
    \    import std.algorithm : sort;\n    auto nums_tuples = nums.map!(a => tuple(a,\
    \ abs(a)));\n    auto nums_tuples_sum = nums_tuples.map!(a => tuple(a, a[1].sumDigits));\n\
    \    nums_tuples_sum.sort!(a => a[1][1]);\n    nums_tuples_sum.sort!(a => a[1][0]);\n\
    \    auto result = nums_tuples_sum.map!(a => a[0][0]).array;\n    return result;\n\
    }", "{\n    // mixin(typeof(std.typecons.getTuple));\n    auto r = nums.map!(e\
    \ => Tuple(e, sumDigits(e)));\n    std.algorithm.sort!(a => (a[1], a[0]))(r);\n\
    \    return r.map!(e => e[0]).array;\n}", "{\n    if (nums.length == 0) return\
    \ new long[0];\n    else\n    {\n        long[] nums_out = new long[nums.length];\n\
    \        for (int i = 0; i < nums.length; i++)\n        {\n            nums_out[i]\
    \ = nums[i];\n        }\n        long[] counts = new long[nums.length];\n    \
    \    for (int i = 0; i < nums.length; i++)\n        {\n            long[] digits\
    \ = to(nums[i].abs, (x) => x % 10L);\n            counts[i] = digits.sum();\n\
    \        }\n        auto max = counts.max();\n        long[] counts_sorted = new\
    \ long[nums.length];\n        for (int i = 0; i < nums.length; i++)\n        {\n\
    \            counts_sorted[i] = counts[i];\n        }\n        counts_sorted.sort;\n\
    \        long min_index = counts.indexOf(counts_sorted[0]);\n        for (int\
    \ i = 0; i < nums.length; i++)\n        {\n            long min_count = counts_sorted[i];\n\
    \            nums_out[i] = nums[min_index];\n            counts[min_index] = max\
    \ + 1;\n            long[] new_counts = new long[nums.length];\n            for\
    \ (int j = 0; j < nums.length; j++)\n            {\n                new_counts[j]\
    \ = counts[j];\n            }\n            new_counts.sort;\n            min_index\
    \ = counts.indexOf(new_counts[0]);\n        }\n        return nums_out;\n    }\n\
    }\n \n/* \n    In mathematics, the factorial of a non-negative integer\n    n,\
    \ denoted by n!, is the product of all positive integers\n    less than or equal\
    \ to n. For example:\n    >>> factorial(1)\n    1\n    >>> factorial(3)\n    6\n\
    \    >>> factorial(5)\n    120\n*/\nlong factorial(long n) \n{\n    if (n == 0)\
    \ return", "{\n    nums = nums.dup;\n    nums.sort!((a, b) =>\n    {\n       \
    \ long sum1 = a.abs.digits.sum;\n        long sum2 = b.abs.digits.sum;\n     \
    \   return (sum1 == sum2) ? a < b : sum1 < sum2;\n    });\n    return nums;\n}",
  "{\n    if (nums.length == 0) return nums;\n    int[] sum = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        int val = cast(int)nums[i];\n\
    \        if (val < 0) val = -val;\n        while (val)\n        {\n          \
    \  sum[i] += val % 10;\n            val /= 10;\n        }\n    }\n    int[] idx\
    \ = new int[nums.length];\n    for (int i = 0; i < idx.length; i++) idx[i] = i;\n\
    \    std.algorithm.sort!(\"a[a0] > b[a0] || (a[a0] == b[a0] && a[a1] < b[a1])\"\
    )(tuple(sum, idx));\n    return idx.map!(a => nums[a]).array;\n}", "{\n    return\
    \ nums.dup.sort!q{a + sumDigits(a) < b + sumDigits(b)};\n}", "{\n    if (nums.length\
    \ == 0)\n        return nums;\n    \n    Map!(long, long[]) points = new Map!(long,\
    \ long[]);\n    foreach (index, item; nums)\n    {\n        long point = to!string(abs(item)).reduce!q{\
    \ a + b }.to!long;\n        if (points.count(point) == 0)\n            points[point]\
    \ = new long[];\n        points[point] ~= item;\n    }\n    \n    long[] result\
    \ = new long[];\n    foreach (item; points.byKey)\n    {\n        foreach (i;\
    \ item[1])\n            result ~= i;\n    }\n    return result;\n}", "{\n    static\
    \ struct MyTuple \n    {\n        long num;\n        long index;\n    }", "{\n\
    \    long[] ret;\n    int[] points;\n    foreach(idx, item; nums)\n    {\n   \
    \     points ~= abs(item);\n    }\n    ret = nums[].sort!(a, b => points[a] >\
    \ points[b]);\n    ret = ret[].sort!(a, b => points[a] < points[b]);\n    return\
    \ ret;\n}", "{\n    auto memo = nums.map!(x => tuple(x, x.abs.sum.toString)).sort!((x,\
    \ y) => x[1] < y[1]);\n    return memo.map!(x => x[0]).array;\n}", "{\n    struct\
    \ Point\n    {\n        long number;\n        int sum;\n        ulong index;\n\
    \    }\n    struct ComparePoint\n    {\n        int opCmp(Point p1, Point p2)\n\
    \        {\n            if (p1.sum == p2.sum)\n            {\n               \
    \ return p1.index > p2.index ? 1 : -1;\n            }\n            return p1.sum\
    \ > p2.sum ? 1 : -1;\n        }\n    }\n    Point[] points = new Point[nums.length];\n\
    \    foreach (i, n; nums)\n    {\n        Point p;\n        p.number = n;\n  \
    \      p.sum = 0;\n        foreach (j, d; to!string(n).dchars)\n        {\n  \
    \          p.sum += d.to!int - '0';\n        }\n        p.index = i;\n       \
    \ points[i] = p;\n    }\n    std.algorithm.sort!(ComparePoint)(points);\n    long[]\
    \ result = new long[nums.length];\n    foreach (i, p; points)\n    {\n       \
    \ result[i] = p.number;\n    }\n    return result;\n}", "{\n    struct Item\n\
    \    {\n        long num;\n        int index;\n        long sum;\n    }\n    long[]\
    \ res;\n    auto items = nums.map!(a => Item(a, a.countDigits(), a.countDigits().to!long)).sort!((a,\
    \ b) => a.sum < b.sum);\n    //auto items = nums.map!(a => Item(a, a.countDigits(),\
    \ a.countDigits().to!long)).array.sort!((a, b) => a.sum < b.sum);\n    foreach(item;\
    \ items)\n    {\n        res ~= item.num;\n    }\n    return res;\n}", "{\n  \
    \  auto toInt = new std.conv.to();\n    auto toSum = new int[](toInt(nums).map!(x\
    \ => x.map!((y) => y - '0').sum()));\n    return toInt(toSum).enumerate.sort!((a,\
    \ b) => (a[1] == b[1]) ? (a[0] < b[0]) : (a[1] < b[1])).map!(x => x[0]).map!(x\
    \ => nums[x]).array;\n}", "{\n    // Assuming that the size of the array won't\
    \ be that large\n    // The upperbound is 7 * 100 = 700\n    auto result = new\
    \ long[nums.length];\n    auto indices = new int[nums.length];\n    auto lookup\
    \ = new int[700];\n    for (int i = 0; i < nums.length; i++)\n    {\n        int\
    \ temp = nums[i].sumDigits();\n        indices[i] = i;\n        result[i] = nums[i];\n\
    \        lookup[temp] = temp;\n    }\n    auto toSort = zip(indices, result);\n\
    \    std.algorithm.sort!((int, long)a, (int, long)b => to!int(a[1]) < to!int(b[1]));\n\
    \    return toSort.map!(e => e[1]).array;\n}", "{\n    if (nums.length == 0)\n\
    \        return nums;\n    //Convert an array of longs to an array of Tuple with\
    \ the sum of digits and the original value\n    Tuple!(ulong, long)[nums.length]\
    \ numsTuple = new Tuple!(ulong, long)[nums.length];\n    foreach (i, number; nums)\n\
    \    {\n        ulong sum = 0;\n        //check if nums[i] is greater than 0\n\
    \        if (nums[i] >= 0)\n        {\n            //get the sum of digits\n \
    \           while (nums[i] > 0)\n            {\n                sum += nums[i]\
    \ % 10;\n                nums[i] /= 10;\n            }\n        }\n        else\n\
    \        {\n            //get the sum of digits\n            while (nums[i] <\
    \ 0)\n            {\n                sum += -(nums[i] % 10);\n               \
    \ nums[i] /= 10;\n            }\n        }\n        //Convert long to ulong for\
    \ sort with Tuple\n        numsTuple[i] = tuple(sum, nums[i]);\n    }\n    //custom\
    \ sort function\n    auto sortFunction = (a, b) =>\n    {\n        if (a[0] ==\
    \ b[0])\n            return a[1] < b[1];\n        return a[0] < b[0];\n    };\n\
    \    numsTuple.sort(sortFunction);\n    //convert back to a long[] array\n   \
    \ long[] result = new long[nums.length];\n    foreach (i, item; numsTuple)\n \
    \   {\n        result[i] = item[1];\n    }\n    return result;\n}", "{\n    auto\
    \ function_copy = nums.dup;\n    long temp = 0;\n    while(function_copy.length\
    \ > 0)\n    {\n        temp = function_copy[0];\n        function_copy.remove(0);\n\
    \        for(int i = 0; i < function_copy.length; i++)\n        {\n          \
    \  if(sumDigits(temp) > sumDigits(function_copy[i]))\n            {\n        \
    \        temp = function_copy[i];\n                function_copy.remove(i);\n\
    \                function_copy.insert(i, temp);\n            }\n        }\n  \
    \      function_copy.insert(0, temp);\n    }\n    return function_copy;\n}", "{\n\
    \    long[] array = new long[1];\n    int index = 0;\n    int sum = 0;\n    foreach(l;\
    \ nums)\n    {\n        sum = 0;\n        int L = l.to!int;\n        int[] digits\
    \ = to!int(std.string.toString(L))\n            .split(\"\")\n            .retro\n\
    \            .map!(a => a.to!int)\n            .array;\n        foreach(d; digits)\n\
    \        {\n            sum += d;\n        }\n        array ~= sum;\n    }\n \
    \   index = array.minIndex();\n    if(index != -1)\n    {\n        return [nums[index]]\
    \ ~ order_by_points(nums[0..index] ~ nums[index+1..$]);\n    }\n    else\n   \
    \ {\n        return [];\n    }\n    \n}", "{\n    \n    const uint MAX = 100;\n\
    \    uint[] counts = new uint[MAX];\n    int[] hash = new int[MAX];\n    int[]\
    \ indices = new int[nums.length];\n    long[] temp = new long[nums.length];\n\
    \    int[] result = new int[nums.length];\n    int x;\n    int y;\n    for (int\
    \ i = 0; i < nums.length; i++) {\n        indices[i] = i;\n        temp[i] = abs(nums[i]);\n\
    \    }\n    for (int i = 0; i < nums.length; i++) {\n        counts[temp[i] %\
    \ 10]++;\n    }\n    for (int i = 1; i < MAX; i++) {\n        counts[i] += counts[i\
    \ - 1];\n    }\n    for (int i = nums.length - 1; i >= 0; i--) {\n        x =\
    \ temp[i] % 10;\n        y = counts[x] - 1;\n        hash[y] = temp[i];\n    \
    \    counts[x]--;\n    }\n    for (int i = 0; i < MAX; i++) {\n        counts[i]\
    \ = 0;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        counts[hash[i]\
    \ / 10]++;\n    }\n    for (int i = 1; i < MAX; i++) {\n        counts[i] += counts[i\
    \ - 1];\n    }\n    for (int i = nums.length - 1; i >= 0; i--) {\n        x =\
    \ hash[i] / 10;\n        y = counts[x] - 1;\n        result[y] = indices[i];\n\
    \        counts[x]--;\n    }\n    for (int i = 0; i < nums.length; i++) {\n  \
    \      indices[i] = i;\n    }\n    for (int i = 0; i < nums.length; i++) {\n \
    \       x = result[i];\n        result[i] = indices[x];\n        indices[x] =\
    \ -1;\n    }\n    return result;\n}", "{ \n    int[] indexArr = new int[nums.length];\n\
    \    //Initialize the index array\n    for(int i = 0; i < indexArr.length; i++)\n\
    \    {\n        indexArr[i] = i;\n    }\n    //Tuple of the index array and the\
    \ array of numbers\n    Tuple!(int[], long[]) tuple = tuple(indexArr, nums);\n\
    \    //Define the array of tuples\n    Tuple!(int[], long[])[] tuples = new Tuple!(int[],\
    \ long[])[nums.length];\n    //Populate the array of tuples\n    for(int i = 0;\
    \ i < tuples.length; i++)\n    {\n        tuples[i] = tuple;\n    }\n    //Sort\
    \ the array of tuples\n    std.algorithm.sort!((t1, t2) => sumDigits(t1[1][t1[0][0]])\
    \ < sumDigits(t2[1][t2[0][0]]))(tuples);\n    //Checking the first tuple\n   \
    \ writeln(tuples[0][0][0]);\n    writeln(tuples[0][1][tuples[0][0][0]]);\n   \
    \ writeln(sumDigits(tuples[0][1][tuples[0][0][0]]));\n    //Using the array of\
    \ tuples to get the index of the sorted array and return\n    //the sorted array\n\
    \    long[] sortedArray = new long[nums.length];\n    foreach(i, tup; tuples)\n\
    \    {\n        sortedArray[i] = tup[1][tup[0][0]];\n    }\n    return sortedArray;\n\
    }", "{\n    auto l = nums.length;\n    static struct pair\n    {\n        long\
    \ data;\n        long index;\n    }\n    tuple!(long, long)[][] arr = new tuple!(long,\
    \ long)[][](l);\n    foreach(i, v; nums)\n    {\n        long digit = 0;\n   \
    \     while(v != 0)\n        {\n            digit += v % 10;\n            v /=\
    \ 10;\n        }\n        int j = 0;\n        while(j < l && tuple!(long, long)(digit,\
    \ i) > arr[j])\n        {\n            j++;\n        }\n        arr.insert(j,\
    \ tuple!(long, long)(digit, i));\n    }\n    long[] ans = new long[](l);\n   \
    \ foreach(i, v; arr)\n    {\n        ans[i] = nums[v.index];\n    }\n    return\
    \ ans;\n}", "{\n    /*TypeTuple!(long[], long[]) TT = std.algorithm.topN!(long[],\
    \ greater_sum, 2)(nums);\n    return TT[0];*/\n    auto cmp = (l, r) => l > r;\n\
    \    auto cmp2 = (l, r) => l.sum > r.sum;\n    auto sum = (l) => l.sum;\n    auto\
    \ arr = nums.map!(a => typeof(return) (a, a.sum));\n    arr.sort(cmp2);\n    return\
    \ arr.map!(a => a.n).array;\n}", "{\n    long[] array = (long[])nums.dup;\n  \
    \  long[] sum = new long[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        for (int j = 0; j < (nums[i]).to!string.length; j++)\n       \
    \ {\n            sum[i] += (nums[i]).to!string[j].to!long - '0'.to!long;\n   \
    \     }\n    }\n    sort(array, sum);\n    return array;\n}\n// Better solution\
    \ by Tofe\nlong[] order_by_points2(long[] nums) \n{\n    long[] result = (long[])nums.dup;\n\
    \    sort!((a, b) => tuple(a.sumDigits(), a) > tuple(b.sumDigits(), b))(result);\n\
    \    return result;\n}", "{\n    // sort array by the sum of the digits of the\
    \ elements, if sums are equal\n    // keep the original order\n    auto comp =\
    \ (a, b) => a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\n    int N = nums.length;\n\
    \    int[] sum_index = new int[][];\n    for (int i = 0; i < N; i++) {\n     \
    \   int sum = 0;\n        int n = abs(nums[i]);\n        while (n != 0) {\n  \
    \          sum += n % 10;\n            n /= 10;\n        }\n        sum_index[i]\
    \ = tuple(sum, i);\n    }\n    sum_index = sort(sum_index, comp);\n    long[]\
    \ result = new long[N];\n    for (int i = 0; i < N; i++) {\n        result[i]\
    \ = nums[sum_index[i][1]];\n    }\n    return result;\n}", "{\n    // create mapping\
    \ from item to it's sum of digits\n    long[long] sums = new long[long];\n   \
    \ foreach(n; nums) {\n        long s = 0;\n        foreach(c; to!string(n)) s\
    \ += c - '0';\n        sums[n] = s;\n    }\n    // create array of items sorted\
    \ by sum of digits\n    auto sorted = nums.dup;\n    sorted.sort!((x, y) => sums[x]\
    \ < sums[y]);\n    // create mapping from item to it's original index\n    long[long]\
    \ indexes = new long[long];\n    foreach(i, n; nums) indexes[n] = i;\n    // sort\
    \ items by their original index\n    sorted.sort!((x, y) => indexes[x] < indexes[y]);\n\
    \    return sorted;\n}\n \n/*\n    You were given a tree and a value.\n    Your\
    \ task is to find a path in the tree where sum of numbers on the path\n    is\
    \ equal to the given value.\n    The nodes of the tree are integers.\n    The\
    \ function should return an array of nodes that form the path.\n    If there are\
    \ several paths with the same sum, return the longest one.\n    If the sum is\
    \ not found, return the shortest.\n    If there are several shortest paths, return\
    \ the one that has the largest index.", "{\n    size_t[] points = new size_t[nums.length];\n\
    \    size_t i = 0;\n    foreach(n; nums)\n    {\n        points[i] = 0;\n    \
    \    foreach(c; n.to!string)\n        {\n            points[i] += c.to!long -\
    \ 48;\n        }\n        i++;\n    }\n    i = 0;\n    size_t[] points_order =\
    \ new size_t[nums.length];\n    foreach(p; points)\n    {\n        size_t j =\
    \ 0;\n        foreach(po; points_order)\n        {\n            if(points[j] <\
    \ p)\n            {\n                points_order[i] = j;\n                i++;\n\
    \                break;\n            }\n            j++;\n        }\n    }\n \
    \   long[] result = new long[nums.length];\n    i = 0;\n    foreach(po; points_order)\n\
    \    {\n        result[i] = nums[po];\n        i++;\n    }\n    return result;\n\
    }", "{\n    int[] sums = nums.map!(n => n.sumOfDigits).array;\n    return nums.sort!((a,\
    \ b) => sums[a] < sums[b] || sums[a] == sums[b] && a < b).array;\n}", "{\n   \
    \ int[] d = new int[nums.length];\n    int[] n = new int[nums.length];\n    foreach(int\
    \ i, long num; nums)\n    {\n        d[i] = num;\n        n[i] = abs(num);\n \
    \   }\n    while(1)\n    {\n        bool swapped = false;\n        foreach(int\
    \ i; 1..nums.length-1)\n        {\n            if (n[i] % 10 + n[i+1] % 10 > 9)\n\
    \            {\n                int tmp = n[i];\n                n[i] = n[i+1];\n\
    \                n[i+1] = tmp;\n                tmp = d[i];\n                d[i]\
    \ = d[i+1];\n                d[i+1] = tmp;\n                swapped = true;\n\
    \            }\n        }\n        if (!swapped)\n            break;\n    }\n\
    \    return d;\n}", "{\n    if (nums.length == 0)\n        return nums;\n    alias\
    \ IndexedLong = Tuple!(int, long);\n    IndexedLong[] indexedLongs = new IndexedLong[];\n\
    \    foreach (int i, long n; nums)\n    {\n        static if (n < 0)\n       \
    \     n = -n;\n        int num = n;\n        int sum = 0;\n        while (num\
    \ > 0)\n        {\n            sum += num % 10;\n            num /= 10;\n    \
    \    }\n        indexedLongs ~= tuple(sum, n);\n    }\n    std.algorithm.sort!((a,\
    \ b) => a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]))(indexedLongs);\n    long[]\
    \ ret = new long[];\n    foreach (IndexedLong a; indexedLongs)\n        ret ~=\
    \ a[1];\n    return ret;\n}", "{\n    if (nums.length == 0)\n        return nums;\n\
    \    \n    auto cmp = typeof(this).structof.dup;\n    cmp.points = 0;\n    cmp.index\
    \ = 0;\n    \n    auto cmp_t = typeof(cmp).init;\n    auto arr = nums.dup;\n \
    \   for (int i = 0; i < arr.length; i++)\n    {\n        cmp.points = 0;\n   \
    \     cmp.index = i;\n        long val = arr[i];\n        if (val < 0)\n     \
    \       val = -val;\n        while (val > 0)\n        {\n            cmp.points\
    \ += val % 10;\n            val /= 10;\n        }\n        arr[i] = cmp_t(cmp);\n\
    \    }\n    arr.sort!(a, b => a.points == b.points ? a.index < b.index : a.points\
    \ < b.points);\n    return arr.map!(a => nums[a.index]).array;\n}\n/*\n    Write\
    \ a function which returns all numbers from 1 to 100 which\n    are divisible\
    \ by both 3 and 7.", "{\n    if (nums.length == 0)\n        return [];\n    else\
    \ if (nums.length == 1)\n        return nums;\n    else\n    {\n        import\
    \ std.algorithm;\n        int[] indices = iota(nums.length);\n        long[] sums\
    \ = new long[nums.length];\n        for (int i = 0; i < sums.length; i++)\n  \
    \      {\n            sums[i] = nums[i] < 0 ? \n                - nums[i].abs.to!string.array\n\
    \                .map!(\"to!int\")\n                .reduce!(\"a + b\") :\n  \
    \              nums[i].to!string.array\n                .map!(\"to!int\")\n  \
    \              .reduce!(\"a + b\");\n        }\n        auto t = tuple(sums, indices);\n\
    \        t.sort;\n        long[] res = new long[nums.length];\n        foreach\
    \ (i, item; sums)\n        {\n            res[i] = nums[t[i][1]];\n        }\n\
    \        return res;\n    }\n}", "{\n    return nums\n        .map!(a => Tuple!(int,\
    \ long)(a.sumDigits, a))\n        .sort!((a, b) => (a[0] < b[0] || (a[0] == b[0]\
    \ && a[1] < b[1])))\n        .map!(a => a[1])\n        .array;\n}", "{\n    //\
    \ Your code here\n    return ();\n}\n ", "{\n    return nums\n        .retro\n\
    \        .sort!(a => digits_sum(a), b => digits_sum(b))\n        .array;\n}",
  "{\n    /*\n        Arrays are too slow for that task.\n        So we use associative\
    \ array instead.\n        We will encode the original index of each number as\
    \ a tuple,\n        e.g.:\n        >>> nums = [1L, 11L, -1L, -11L, -12L]\n   \
    \     >>> keys = nums.map!((x) => tuple(abs(x).sumDigits, typeof(nums).indexOf(x)));\n\
    \        >>> keys;\n        [tuple(2, 0), tuple(2, 1), tuple(2, 2), tuple(3, 3),\
    \ tuple(4, 4)]\n        The 'tuple' will be sorted by the first tuple item.\n\
    \        The 'tuple.length' is equal to 2, so the second item\n        (which\
    \ keeps the original index) will be used to break ties.\n    */\n    const uint\
    \ len = nums.length;\n    const uint z = tuple(0, 0); // default tuple value\n\
    \    ulong[][] keys = new ulong[][](len); // associated array for the 'keys'\n\
    \    foreach (i, ref num; nums) {\n        const uint key = abs(num).sumDigits;\n\
    \        keys[key] ~= tuple(key, i);\n    }\n    /*\n        Let's use merge sort\
    \ to sort the array with tuples.\n        It would be nice if it will be done\
    \ in-place.\n        Keep in mind that the order of the arrays elements\n    \
    \    is important (it keeps the order of the original numbers).\n    */\n    ulong[][]\
    \ merge(ulong[][] a, ulong[][] b) {\n        ulong[][] r = new ulong[][](a.length\
    \ + b.length);\n        uint i, j, k;\n        i = j = k = 0;\n        while (i\
    \ < a.length && j < b.length) {\n            if (a[i][0] <= b[j][0]) {\n     \
    \           r[k] = a[i];\n                ++i;\n            } else {\n       \
    \         r[k] = b[j];\n                ++j;\n            }\n            ++k;\n\
    \        }\n        while (", "{\n    auto nums_with_points = typeof(nums_with_points)();\n\
    \    foreach(i, num; nums)\n    {\n        nums_with_points ~= typeof(nums_with_points).init(num,\
    \ 0);\n        foreach(ch; num.to!string)\n        {\n            nums_with_points[i].sum\
    \ += ch.to!int - '0'.to!int;\n        }\n    }\n    sort!((x, y) => x.sum > y.sum\
    \ || (x.sum == y.sum && x.idx > y.idx))(nums_with_points);\n    foreach(i, num;\
    \ nums_with_points)\n    {\n        nums[i] = num.num;\n    }\n    return nums;\n\
    }", "{\n    struct Item\n    {\n        long[] points;\n        long num;\n  \
    \  }\n    static bool opCmp(Item a, Item b)\n    {\n        if (a.points[0] !=\
    \ b.points[0])\n            return a.points[0] < b.points[0];\n        return\
    \ a.points[1] < b.points[1];\n    }\n    auto items = new Item[](nums.length);\n\
    \    foreach (idx, num; nums)\n    {\n        long sum = 0;\n        while (num\
    \ != 0)\n        {\n            sum += num % 10;\n            num /= 10;\n   \
    \     }\n        items[idx].points = [sum, idx];\n        items[idx].num = nums[idx];\n\
    \    }\n    std.algorithm.sort(items, &opCmp);\n    auto result = new long[](nums.length);\n\
    \    foreach (idx, item; items)\n        result[idx] = item.num;\n    return result;\n\
    }", "{\n    // YOUR CODE HERE\n    return [];\n}\nstatic assert(order_by_points([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n \n/*", "{\n    \n \
    \   struct Entry\n    {\n        long num;\n        long digitSum;\n        int\
    \ index;\n    }\n    \n    auto counter = 0;\n    Entry[] input = nums.map!(n\
    \ => Entry(n, n.sumDigits, counter++));\n    \n    input.sort!((a, b) =>\n   \
    \     a.digitSum < b.digitSum ||\n        (a.digitSum == b.digitSum && a.index\
    \ < b.index));\n    \n    return input.map!(e => e.num).array;\n}", "{\n    long[]\
    \ numsClone = nums.dup;\n    if (nums.length == 0) return numsClone;\n    long[]\
    \ sums = [];\n    int i = 0;\n    foreach (num; nums)\n    {\n        long sum\
    \ = 0;\n        foreach (digit; num.to!string)\n        {\n            sum +=\
    \ digit.to!long;\n        }\n        sums ~= sum;\n    }\n    auto sort = sort!(\"\
    a < b\");\n    sort(sums);\n    numsClone.sort!(\"a.to!string < b.to!string\"\
    );\n    return numsClone;\n}", "{\n  import std.algorithm;\n  import std.array;\n\
    \  import std.conv;\n  import std.range;\n  import std.string;\n  import std.typecons;\n\
    \  auto zipped = zip(nums, iota(nums.length))\n    .map!(t => tuple(t[0], t[1],\n\
    \      t[0].to!string.map!(to!int).sum));\n  return zipped.sort!((t1, t2) => t1[2]\
    \ < t2[2] ||\n    (t1[2] == t2[2] && t1[1] < t2[1]))\n    .map!(t => t[0]).array;\n\
    }", "{\n    const long magic = '0';\n    long totalDigits = nums.length;\n   \
    \ long[] numsAndSumOfDigits = new long[totalDigits];\n    foreach(i, num; nums)\n\
    \    {\n        numsAndSumOfDigits[i] = num + (sum(digits(num) [char] magic) *\
    \ 10_000_000_000_000_000);\n    }\n    sort(numsAndSumOfDigits);\n    foreach(j,\
    \ num; numsAndSumOfDigits)\n    {\n        numsAndSumOfDigits[j] = num / 10_000_000_000_000_000;\n\
    \    }\n    return numsAndSumOfDigits;\n}\n// version with key=\nlong[] order_by_points2(long[]\
    \ nums) \n{\n    return sort(nums, (a, b) => (sum(digits(a) [char] '0')).cmp(sum(digits(b)\
    \ [char] '0')));\n}", "{\n    const int MAX_DIGITS = 12;\n    if (nums.length\
    \ == 0)\n        return nums;\n    long[MAX_DIGITS][nums.length] sums;\n    foreach\
    \ (i, n; nums)\n    {\n        long sum = 0;\n        long nn = abs(n);\n    \
    \    for (; nn > 0; nn /= 10)\n            sum += nn % 10;\n        sums[sum][i]\
    \ = n;\n    }\n    long[] result;\n    foreach (i; 0 .. MAX_DIGITS)\n    {\n \
    \       foreach (e; sums[i])\n        {\n            if (e != 0)\n           \
    \     result ~= e;\n        }\n    }\n    return result;\n}\n/*\n    Write a function\
    \ which checks whether the given string is a palindrome.\n    Note: a palindrome\
    \ is a string that reads the same backward or forward.", "{\n  auto comp_type\
    \ = tuple(long,long);\n  auto comparator = (typeof(comp_type) l, typeof(comp_type)\
    \ r) {\n    return l[0] < r[0] ? 1 : (l[0] > r[0] ? -1 : (l[1] < r[1] ? 1 : -1));\n\
    \  };\n  long[] result = new long[nums.length];\n  auto helper = new typeof(comp_type)[];\n\
    \  long sum = 0;\n  foreach(i,n; nums) {\n    int s = n;\n    sum = 0;\n    while(s\
    \ != 0) {\n      sum += s % 10;\n      s /= 10;\n    }\n    helper ~= typeof(comp_type)(sum,i);\n\
    \  }\n  helper.sort(comparator);\n  foreach(i,t; helper)\n    result[i] = nums[t[1]];\n\
    \  return result;\n}", "{\n    int[] indices = new int[nums.length];\n    int[]\
    \ sums = new int[nums.length];\n    long[] res = new long[nums.length];\n    foreach(int\
    \ i, long j; nums)\n    {\n        indices[i] = i;\n        sums[i] = 0;\n   \
    \     foreach(char c; to!string(j))\n        {\n            sums[i] += c - '0';\n\
    \        }\n    }\n    enum Func\n    {\n        Less,\n        Greater\n    }\n\
    \    auto sort_indices(int[] a, int[] b, Func func)\n    {\n        assert(a.length\
    \ == b.length);\n        int tmp;\n        for(int i = 0; i < a.length; i++)\n\
    \        {\n            for(int j = 0; j < a.length; j++)\n            {\n   \
    \             switch(func)\n                {\n                    case Func.Less:\n\
    \                        if(a[i] < a[j])\n                        {\n        \
    \                    tmp = a[i];\n                            a[i] = a[j];\n \
    \                           a[j] = tmp;\n                            tmp = b[i];\n\
    \                            b[i] = b[j];\n                            b[j] =\
    \ tmp;\n                        }\n                        break;\n          \
    \          case Func.Greater:\n                        if(a[i] > a[j])\n     \
    \                   {\n                            tmp = a[i];\n             \
    \               a[i] = a[j];\n                            a[j] = tmp;\n      \
    \                      tmp = b[i];\n                            b[i] = b[j];\n\
    \                            b[j] = tmp;\n                        }\n        \
    \                break;\n                }\n            }\n        }\n    }\n\
    \    sort_indices(sums, indices, Func.Less);\n    foreach(int i; indices)\n  \
    \  {\n        res[i] = nums[indices[i]];\n    }\n    return res;\n}", "{\n   \
    \ return \n    nums\n    .map!(n => tuple(n, n.to!string.map!(c => c.to!int).sum))\n\
    \    .sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]))\n    .map!(t\
    \ => t[0]);\n}", "{\n    //static assert(nums.length < 2*10_000);\n    int[][]\
    \ nums_pairs;\n    foreach(i, n; nums)\n    {\n        nums_pairs ~= [i, n];\n\
    \    }\n    sort!((p1, p2) => \n    {\n        int sum1 = sum(digits(p1[1]));\n\
    \        int sum2 = sum(digits(p2[1]));\n        if(sum1 == sum2)\n        {\n\
    \            return p1[0] < p2[0];\n        }\n        return sum1 < sum2;\n \
    \   })(nums_pairs);\n    long[] res;\n    foreach(p; nums_pairs)\n    {\n    \
    \    res ~= p[1];\n    }\n    return res;\n}\n \n```", "{\n  struct num\n  {\n\
    \    long num;\n    int sum;\n    int index;\n  }\n  auto nums_array = num[nums.length];\n\
    \  for(int i = 0; i < nums.length; i++)\n  {\n    auto n = num(nums[i], getSum(nums[i]),\
    \ i);\n    nums_array[i] = n;\n  }\n  nums_array.sort!((a, b) =>\n    ((a.sum\
    \ == b.sum)?(a.index < b.index):(a.sum < b.sum))\n  );\n  long[] result = new\
    \ long[nums.length];\n  for(int i = 0; i < nums.length; i++)\n  {\n    result[i]\
    \ = nums_array[i].num;\n  }\n  return result;\n}", "{\n    if (nums.length ==\
    \ 0)\n        return nums;\n    if (nums.length == 1)\n        return nums;\n\
    \    alias Pair = Tuple!(long, long);\n    long[][long] a;\n    foreach (i, x;\
    \ nums)\n    {\n        long sum = 0;\n        foreach (ch; to!string(x))\n  \
    \          sum += ch - '0';\n        a[sum].insert(i);\n    }\n    long[] b;\n\
    \    foreach (x; sort(a.keys))\n        foreach (i; a[x])\n            b ~= nums[i];\n\
    \    return b;\n}", "{\n\tint[] sumOfDigits = new int[nums.length];\n\tint[] index\
    \ = new int[nums.length];\n\tint[] temp = new int[nums.length];\n\tfor(int i =\
    \ 0; i < nums.length; i++)\n\t{\n\t\t// write your code here\n\t\tif(nums[i] <\
    \ 0)\n\t\t{\n\t\t\tnums[i] = -nums[i];\n\t\t}\n\t\tsumOfDigits[i] = nums[i] %\
    \ 10;\n\t\tnums[i] /= 10;\n\t\twhile(nums[i] > 0)\n\t\t{\n\t\t\tsumOfDigits[i]\
    \ += nums[i] % 10;\n\t\t\tnums[i] /= 10;\n\t\t}\n\t\tindex[i] = i;\n\t}\n\tint\
    \ tempValue;\n\tfor(int i = 0; i < sumOfDigits.length; i++)\n\t{\n\t\tfor(int\
    \ j = i + 1; j < sumOfDigits.length; j++)\n\t\t{\n\t\t\tif(sumOfDigits[i] > sumOfDigits[j])\n\
    \t\t\t{\n\t\t\t\ttempValue = sumOfDigits[i];\n\t\t\t\tsumOfDigits[i] = sumOfDigits[j];\n\
    \t\t\t\tsumOfDigits[j] = tempValue;\n\t\t\t\ttempValue = index[i];\n\t\t\t\tindex[i]\
    \ = index[j];\n\t\t\t\tindex[j] = tempValue;\n\t\t\t}\n\t\t}\n\t}\n\tlong[] temp1\
    \ = new long[nums.length];\n\tfor(int i = 0; i < nums.length; i++)\n\t{\n\t\t\
    temp1[i] = nums[index[i]];\n\t}\n\treturn temp1;\n}", "{\n\t// long[] result =\
    \ new long[nums.length];\n\t// for (int i = 0; i < nums.length; i++) {\n\t// \t\
    result[i] = sumDigits(nums[i]);\n\t// }\n\t// for (int i = 0; i < nums.length;\
    \ i++) {\n\t// \tfor (int j = i + 1; j < nums.length; j++) {\n\t// \t\tif (result[i]\
    \ < result[j]) {\n\t// \t\t\tlong temp = result[i];\n\t// \t\t\tresult[i] = result[j];\n\
    \t// \t\t\tresult[j] = temp;\n\t// \t\t}\n\t// \t}\n\t// }\n\t// for (int i =\
    \ 0; i < nums.length; i++) {\n\t// \tfor (int j = i + 1; j < nums.length; j++)\
    \ {\n\t// \t\tif (result[i] == result[j]) {\n\t// \t\t\tif (nums[i] > nums[j])\
    \ {\n\t// \t\t\t\tlong temp = nums[i];\n\t// \t\t\t\tnums[i] = nums[j];\n\t//\
    \ \t\t\t\tnums[j] = temp;\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\t// return\
    \ nums;\n\treturn nums.sort!((x, y) => sumDigits(x) > sumDigits(y) || sumDigits(x)\
    \ == sumDigits(y) && x > y);\n}\nlong sumDigits(long num) {\n\tlong sum = 0;\n\
    \tint sign = signbit(num);\n\tnum = abs(num);\n\twhile (num > 0) {\n\t\tsum +=\
    \ num % 10;\n\t\tnum /= 10;\n\t}\n\treturn sign ? -sum : sum;\n}", "{\n    return\
    \ nums\n        .map!(n => (n, sum(digits(n))))\n        .enumerate\n        .sort!((a,\
    \ b) => (a[1][1] == b[1][1]) ? a[0] < b[0] : a[1][1] < b[1][1])\n        .map!(p\
    \ => p[1][0])\n        .array;\n}\n \nlong[] digits(long n) \n{\n    long[] result;\n\
    \    auto s = to!string(n);\n    foreach (c; s)\n        result ~= c.to!long;\n\
    \    return result;\n}", "{\n    long[] input = nums;\n    //Tuple!(long, long)\
    \ temp;\n    long[] sums = new long[input.length];\n    /*\n    temp = new Tuple!(long,\
    \ long);\n    temp[0] = sum;\n    temp[1] = index;\n    */\n    for (int i = 0;\
    \ i < input.length; i++)\n    {\n        long sum = 0;\n        long num = abs(input[i]);\n\
    \        while (num != 0)\n        {\n            sum += num % 10;\n         \
    \   num /= 10;\n        }\n        sums[i] = sum;\n    }\n    for (int i = 0;\
    \ i < input.length; i++)\n    {\n        for (int j = 0; j < input.length; j++)\n\
    \        {\n            if (sums[i] < sums[j])\n            {\n              \
    \  long temp = sums[i];\n                sums[i] = sums[j];\n                sums[j]\
    \ = temp;\n                temp = input[i];\n                input[i] = input[j];\n\
    \                input[j] = temp;\n            }\n        }\n    }\n    return\
    \ input;\n}", "{\n  if (nums.length==0)\n    return nums;\n  else\n  {\n    auto\
    \ tmp=new long[nums.length];\n    for (int i=0;i<nums.length;i++)\n    {\n   \
    \   tmp[i]=nums[i];\n    }\n    auto arr = std.sort(tmp, (a, b) => {\n      if\
    \ (sum_of_digits(a)==sum_of_digits(b))\n        return 0;\n      else if (sum_of_digits(a)<sum_of_digits(b))\n\
    \        return -1;\n      else\n        return 1;\n    });\n    return arr;\n\
    \  }\n}\nlong sum_of_digits(long n)\n{\n  long num=abs(n);\n  long sum=0;\n  while\
    \ (num!=0)\n  {\n    sum+=num%10;\n    num/=10;\n  }\n  return sum;\n}", "{\n\
    \    int[][] sums_and_indexes = new int[][](nums.length);\n    for (int i = 0;\
    \ i < nums.length; i++) {\n        int sum = 0;\n        long num = nums[i];\n\
    \        if (num < 0) num = -num;\n        while (num != 0) {\n            sum\
    \ += num % 10;\n            num /= 10;\n        }\n        sums_and_indexes[i]\
    \ = [sum, i];\n    }\n    return sort!(\"(a, b) => (a[0] == b[0]) ? (a[1] < b[1])\
    \ : (a[0] < b[0])\")(sums_and_indexes)\n            .map!(t => nums[t[1]]).array;\n\
    }", "{\n    long[] list = new long[nums.length];\n    list = nums;\n    int[]\
    \ digits = new int[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        int total = 0;\n        foreach(char c; to!string(abs(nums[i])))\n\
    \        {\n            total += c.to!int;\n        }\n        digits[i] = total;\n\
    \    }\n    int[][] combined = [digits,list];\n    for (int j = 0; j < combined[0].length;\
    \ j++)\n    {\n        for (int k = j + 1; k < combined[0].length; k++)\n    \
    \    {\n            if (combined[0][j] > combined[0][k])\n            {\n    \
    \            combined[0][j] += combined[0][k];\n                combined[0][k]\
    \ = combined[0][j] - combined[0][k];\n                combined[0][j] -= combined[0][k];\n\
    \                combined[1][j] += combined[1][k];\n                combined[1][k]\
    \ = combined[1][j] - combined[1][k];\n                combined[1][j] -= combined[1][k];\n\
    \            }\n        }\n    }\n    long[] finalList = new long[combined[1].length];\n\
    \    for (int l = 0; l < combined[1].length; l++)\n    {\n        finalList[l]\
    \ = combined[1][l];\n    }\n    return finalList;\n}", "{\n    long[] result;\n\
    \    auto t = new Tuple!(ulong, long)(0, 0);\n    auto map = nums.map!(a => tuple(a.sumDigits(),\
    \ a)).sort!(a => a[0]).array;\n    result = map.map!(a => a[1]).array;\n    return\
    \ result;\n}", "{\n    long[] new_nums;\n    if (nums.length > 0) {\n        new_nums\
    \ = nums.dup;\n        new_nums.sort!((x, y) => {\n            auto sum_x = x.digits().sum;\n\
    \            auto sum_y = y.digits().sum;\n            if (sum_x > sum_y) {\n\
    \                return 1;\n            } else if (sum_x < sum_y) {\n        \
    \        return -1;\n            } else {\n                return 0;\n       \
    \     }\n        });\n    } else {\n        new_nums = [];\n    }\n    return\
    \ new_nums;\n}", "{\n    nums = nums.dup;\n    if (nums.length > 1)\n    {\n \
    \       auto sums = nums.map!((x) => (sumDigits(x), x)).enumerate;\n        sums.sort!((lhs,\
    \ rhs) => (lhs[0] == rhs[0]) ? (lhs[1] < rhs[1]) : (lhs[0] < rhs[0]));\n     \
    \   auto order = sums.map!((x) => x[1]).enumerate;\n        order.sort!((lhs,\
    \ rhs) => lhs[0] < rhs[0]);\n        return order.map!((x) => x[1]).array;\n \
    \   }\n    return nums;\n}", "{\n    return nums.\n        zip(iota(nums.length)).\n\
    \        sort!((a, b) => (sumDigits(a[0]) == sumDigits(b[0])) ? a[1] < b[1] :\
    \ sumDigits(a[0]) < sumDigits(b[0])).\n        map!(e => e[0]).\n        array;\n\
    }\nlong sumDigits(long n)\n{\n    return n > 0 ? n % 10 + sumDigits(n / 10) :\
    \ 0;\n}", "{\n  struct Container(long item, int points, int index)\n  {\n    long\
    \ item;\n    int points;\n    int index;\n  }\n  if (nums.length == 0)\n    return\
    \ [];\n  auto a = new Container[nums.length];\n  for (int i = 0; i < nums.length;\
    \ i++)\n  {\n    auto item = nums[i];\n    int points = 0;\n    while (item !=\
    \ 0)\n    {\n      points += item % 10;\n      item /= 10;\n    }\n    a[i] =\
    \ Container(nums[i], points, i);\n  }\n  a.sort!((ref a, ref b) => a.points <\
    \ b.points);\n  long[] result = new long[nums.length];\n  foreach (j, ref i; a)\n\
    \    result[j] = i.item;\n  return result;\n}", "{\n    if (nums.length == 0)\n\
    \        return nums;\n    \n    auto sorted = nums.dup;\n    auto sort_function\
    \ = (int x, int y) {\n        auto ax = x.to!string;\n        auto ay = y.to!string;\n\
    \        auto sum_x = ax.map!(a => a.to!int).sum;\n        auto sum_y = ay.map!(a\
    \ => a.to!int).sum;\n        return sum_x < sum_y || (sum_x == sum_y && x < y);\n\
    \    };\n    std.algorithm.sort!sort_function(sorted);\n    return sorted;\n}",
  "{\n    if (nums.length == 0) return nums;\n    auto t = new Tuple!(long, long)(0,\
    \ 0);\n    auto arr = new Tuple!(long, long)[nums.length];\n    long index = 0;\n\
    \    foreach (item; nums) {\n        t[0] = item;\n        t[1] = item;\n    \
    \    if (item < 0) t[1] = -t[1];\n        arr[index] = t;\n        index++;\n\
    \    }\n    sort!((a, b) => {\n        auto da = 0L;\n        auto db = 0L;\n\
    \        while (a[1] > 0) {\n            da += a[1] % 10;\n            a[1] /=\
    \ 10;\n        }\n        while (b[1] > 0) {\n            db += b[1] % 10;\n \
    \           b[1] /= 10;\n        }\n        return (da == db) ? (a[0] < b[0])\
    \ : (da < db);\n    })(arr);\n    return arr.map!(t => t[0]).array;\n}", "{\n\
    \    // write your code here\n    int[] sum_of_nums = new int[nums.length];\n\
    \    int[] sum_of_nums_copy = new int[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++) {\n        sum_of_nums[i] = (int) (nums[i] % 10) + (int) ((nums[i] / 10)\
    \ % 10) + (int) ((nums[i] / 100) % 10);\n        sum_of_nums_copy[i] = sum_of_nums[i];\n\
    \    }\n    sort(sum_of_nums);\n    long[] result = new long[nums.length];\n \
    \   for (int i = 0; i < nums.length; i++) {\n        for (int j = 0; j < nums.length;\
    \ j++) {\n            if (sum_of_nums[i] == sum_of_nums_copy[j]) {\n         \
    \       result[i] = nums[j];\n                sum_of_nums_copy[j] = 0;\n     \
    \           break;\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    auto nums2 = nums.dup;\n    for (int i = 0; i < nums.length; i++) \n    {\n\
    \        long n = nums[i];\n        long total = 0;\n        while (n != 0)\n\
    \        {\n            total += n % 10;\n            n /= 10;\n        }\n  \
    \      nums2[i] = total;\n    }\n    auto r = sort!(\"a[0] > b[0] || (a[0] ==\
    \ b[0] && a[1] < b[1]\")\n            ([tuple(nums2[i], i) for (i = 0; i < nums.length)]);\n\
    \    long[] res = new long[](nums.length);\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        res[i] = nums[r[i][1]];\n    }\n    return res;\n}", "{\n\
    \    /*\n    long[] res = [];\n    for (i in nums)\n    {\n        if (nums[i]\
    \ < 0)\n        {\n            res.insert(0, nums[i]);\n        }\n        else\n\
    \        {\n            res.insert(1, nums[i]);\n        }\n    }\n    return\
    \ res;\n    */\n    if (nums.length == 0)\n    {\n        return nums;\n    }\n\
    \    int len = nums.length;\n    for (int i = 0; i < len; i++)\n    {\n      \
    \  for (int j = i + 1; j < len; j++)\n        {\n            if (sum(abs(nums[i]))\
    \ > sum(abs(nums[j])))\n            {\n                long tmp = nums[i];\n \
    \               nums[i] = nums[j];\n                nums[j] = tmp;\n         \
    \   }\n        }\n    }\n    return nums;\n}", "{\n    long d_size = nums.length;\n\
    \    long[] result = new long[d_size];\n    typeof(result) indexs = new typeof(result);\n\
    \    for (size_t i = 0; i < d_size; i++)\n    {\n        result[i] = 0;\n    \
    \    indexs[i] = i;\n    }\n    foreach (i, ref s; result)\n    {\n        long\
    \ temp = nums[i];\n        if (temp < 0)\n            temp = -temp;\n        for\
    \ (; temp > 0; temp /= 10)\n            s += temp % 10;\n    }\n    quickSort(result,\
    \ indexs);\n    foreach (i, ref s; indexs)\n        s = nums[s];\n    return indexs;\n\
    }", "{\n    long[] res = new long[nums.length];\n    Tuple!(long, long)[] nums2\
    \ = new Tuple!(long, long)[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        long sum = 0;\n        foreach (long d; to!long(i.to!string))\n\
    \        {\n            sum += d;\n        }\n        nums2[i] = tuple(nums[i],\
    \ sum);\n    }\n    nums2.sort!((a, b) => a[1] < b[1]);\n    for (int i = 0; i\
    \ < nums.length; i++)\n    {\n        res[i] = nums2[i][0];\n    }\n    return\
    \ res;\n}", "{\n    long[] points;\n    long[][] digits;\n    foreach(n; nums)\n\
    \    {\n        points ~= n.abs.sumDigits;\n        digits ~= n.digits;\n    }\n\
    \    long[][] indices = points.tupleof.zip.sort;\n    return indices.map!((tuple)\
    \ => nums[tuple[1]])();\n}", "{\n    return nums.sort!\"a.sumOfDigits > b.sumOfDigits\
    \ || a.sumOfDigits == b.sumOfDigits && a > b\".array;\n}", "{\n    if (nums.length\
    \ == 0)\n        return nums;\n    auto nums_with_points = nums.map!(n => tuple(n,\
    \ nums.sum, n));\n    nums_with_points.sort!(a => a[1]);\n    return nums_with_points.map!(t\
    \ => t[2]).array;\n}", "{\n    long[] result = new long[nums.length];\n    int[]\
    \ sum = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n \
    \       long temp = nums[i];\n        int tempsum = 0;\n        while (temp >\
    \ 0) {\n            tempsum += temp % 10;\n            temp /= 10;\n        }\n\
    \        sum[i] = tempsum;\n    }\n    size_t[] indices = new size_t[nums.length];\n\
    \    foreach(index, value; sum) {\n        indices[index] = index;\n    }\n  \
    \  std.algorithm.sort!(\"a[i] < a[j]\")(indices, sum);\n    foreach(index, value;\
    \ indices) {\n        result[index] = nums[value];\n    }\n    return result;\n\
    }", "{\n    int[] points = new int[nums.length];\n    //int[] index = new int[nums.length];\n\
    \    //for (int i = 0; i < nums.length; i++) {\n        //index[i] = i;\n    //}\n\
    \    for (int i = 0; i < nums.length; i++) {\n        long x = nums[i];\n    \
    \    int sum = 0;\n        while (x != 0) {\n            sum += x % 10;\n    \
    \        x /= 10;\n        }\n        points[i] = sum;\n    }\n    long[] nums_new\
    \ = nums[0..nums.length];\n    sort(nums_new, (a, b) => a.to!int == b.to!int ?\
    \ 0 : (a.to!int < b.to!int ? -1 : 1));\n    return nums_new;\n}\n/*\n    Write\
    \ a function which takes an integer `x` and returns the next\n    power of 2 of\
    \ it (if `x` is already a power of 2, leave it as is).", "{\n    struct Item {\n\
    \        long sum;\n        long index;\n    }\n    auto compareItem = (Item a,\
    \ Item b) => a.sum < b.sum ? -1 : 1;\n    auto items = nums.map!(x => Item(x.sumDigits,\
    \ x.index)).array;\n    sort(items, compareItem);\n    return items.map!(x =>\
    \ nums[x.index]).array;\n}", "{\n  int[] nums_int = nums.map!((x) => x.to!int).array;\n\
    \  long[] result;\n  ulong[] nums_uint;\n  long[] sum_digits;\n  static int sum(int\
    \ x) \n  {\n    int sum = 0;\n    if (x < 0)\n    {\n      x = -x;\n    }\n  \
    \  while (x > 0)\n    {\n      sum += x % 10;\n      x /= 10;\n    }\n    return\
    \ sum;\n  }\n  result = nums.dup;\n  nums_uint = nums.map!((x) => (x < 0) ? -x\
    \ : x).map!((x) => x.to!ulong).array;\n  sum_digits = nums_uint.map!((x) => sum(x.to!int)).array;\n\
    \  sort!(\"(a, b) => b - a\")(sum_digits, result);\n  return result;\n}", "{\n\
    \    if (nums.length == 0) \n    {\n        return [];\n    }", "{\n    long[long[]]\
    \ nums_container = new long[nums.length][];\n    foreach(idx, n; nums) {\n   \
    \     nums_container[idx] = [n, sumOfDigits(n)];\n    }\n    nums_container.sort!(\"\
    a[1] < b[1]\");\n    long[] result = new long[nums.length];\n    foreach(idx,\
    \ n; nums_container) {\n        result[idx] = n[0];\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[nums.length];\n    int[] sumDigit = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++) {\n        int sum = 0;\n        long\
    \ x = nums[i];\n        for (int j = 0; j < nums.length; j++) {\n            if\
    \ (x < 0) {\n                x = -x;\n            }\n            sum += x % 10;\n\
    \            x /= 10;\n        }\n        sumDigit[i] = sum;\n    }\n    int[]\
    \ index = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n\
    \        int min = sumDigit[i];\n        int point = 0;\n        for (int j =\
    \ i; j < nums.length; j++) {\n            if (min > sumDigit[j]) {\n         \
    \       min = sumDigit[j];\n                point = j;\n            }\n      \
    \  }\n        index[i] = point;\n        sumDigit[point] = 999;\n    }\n    for\
    \ (int i = 0; i < nums.length; i++) {\n        result[i] = nums[index[i]];\n \
    \   }\n    return result;\n}", "{ \n    enum KeyType = tuple!(long, long);\n \
    \   auto original_order = new KeyType[](nums.length);\n    for (int i = 0; i <\
    \ nums.length; i++)\n    {\n        original_order[i] = tuple(nums[i], i);\n \
    \   }\n    return original_order.sort!((a, b) =>\n    {\n        int aSum = 0;\n\
    \        int bSum = 0;\n        int num = a[0];\n        while (num != 0)\n  \
    \      {\n            aSum += num % 10;\n            num /= 10;\n        }\n \
    \       num = b[0];\n        while (num != 0)\n        {\n            bSum +=\
    \ num % 10;\n            num /= 10;\n        }\n        if (aSum == bSum)\n  \
    \      {\n            return a[1] > b[1];\n        }\n        return aSum > bSum;\n\
    \    }).map!(x => x[0]).array;\n}", "{\n  return nums.sort!((a, b) => sumDigits(a)\
    \ < sumDigits(b));\n}", "{\n    auto reversed = map!q{a => a[0]}\n    (sort!q{(a,\
    \ b) => (b[1] > a[1]) || (b[1] == a[1] && b[0] > a[0])}\n    (map!q{a => tuple(a,\
    \ reduce!((a, b) => a + b)(a.digits))}\n    (nums)));\n    return map!q{a => reversed[a]}\n\
    \    (iota(nums.length));\n}\n/*\n    How many zeros at the end of the factorial\
    \ of a given number?", "{\n    return nums.sort!((a, b) => a.length > b.length)[0];\n\
    }", "{\n    if (nums.length == 0) return nums;\n    nums[].sort( (x, y) =>\n \
    \   {\n        int xd = sum(x.digits);\n        int yd = sum(y.digits);\n    \
    \    return xd < yd ? -1 : xd > yd ? 1 : 0;\n    });\n    return nums;\n}", "{\n\
    \    auto digit_sum = (long x) =>\n    {\n        long result = 0;\n        while\
    \ (x != 0)\n        {\n            result += x % 10;\n            x /= 10;\n \
    \       }\n        return result;\n    };\n    return sort(nums, (a, b) => tuple(digit_sum(a),\
    \ a).opCmp(tuple(digit_sum(b), b)));\n}", "{\n    /*\n        Sums is used to\
    \ hold the sums of the digits of each number in the array.\n        We pre-initialize\
    \ the array of sums to the length of the nums array.\n        Sorted_nums is used\
    \ to hold the sorted numbers from lowest to highest.\n        We pre-initialize\
    \ the array of sorted_nums to the length of the nums array.\n        Greatest_sum\
    \ is a variable used to hold the value of the greatest sum of digits\n       \
    \ in the array.\n        Smallest_sum is a variable used to hold the value of\
    \ the smallest sum of digits\n        in the array.\n        The variable i is\
    \ used to index through the arrays.\n        The variable j is used to check whether\
    \ the nums array has been completely\n        iterated through.\n        The variable\
    \ k is used to check whether the sums array has been completely\n        iterated\
    \ through.\n        The variable digit_sum is used to hold the sum of the digits\
    \ in the current\n        index of the nums array.\n        The variable starting_index\
    \ is used to hold the starting index of the \n        first number with the same\
    \ sum of digits in the array.\n        The variable ending_index is used to hold\
    \ the ending index of the \n        first number with the same sum of digits in\
    \ the array.\n        The variable starting_sum is used to hold the sum of the\
    \ digits of the \n        number at the starting_index.\n        The variable\
    \ ending_sum is used to hold the sum of the digits of the \n        number at\
    \ the ending_index.\n        The variable index_num is used to track how many\
    \ index numbers there are\n        with the same digit sum.\n    */\n    long[]\
    \ sums = new long[nums.length];\n    long[] sorted_nums = new long[nums.length];\n\
    \    long greatest_sum = 0;\n    long smallest_sum = 0;\n    int i = 0;\n    int\
    \ j = 0;\n    int k = 0;\n    long digit_sum = 0;\n    int starting_index = 0;\n\
    \    int ending_index = 0;\n    long starting_sum = 0;\n    long ending_sum =\
    \ 0;\n    int index_num = 0;\n    //This loop iterates through the nums array,\
    \ counting the sum of the", "{\n    // Sort the array of tuples `nums` by their\
    \ second element (its sum of digits)\n    // Return the sorted array of tuples\n\
    \    auto mapArray = zip(nums, nums.map!((x) => to!string(x).split(\"\").map!(x\
    \ => to!int(x)).sum()).array);\n    sort!((x, y) => (x[1] < y[1] || (x[1] == y[1]\
    \ && x[0] > y[0])));\n    return mapArray.map!(a => a[0]).array;\n}", "{\n   \
    \ long[] sums;\n    sums.length = nums.length;\n    for (long i = 0; i < nums.length;\
    \ i++)\n    {\n        sums[i] = sum(typeof(nums[i]).digits(nums[i]));\n    }\n\
    \    auto zipped = zip(sums, nums);\n    sort!(\"a[0] < b[0]\")(zipped);\n   \
    \ long[] result;\n    result.length = nums.length;\n    for (long i = 0; i < nums.length;\
    \ i++)\n    {\n        result[i] = zipped[i][1];\n    }\n    return result;\n}",
  "{\n    long[] res = new long[nums.length];\n    immutable int[] digits;\n    immutable\
    \ int sum;\n    int[] sums = new int[nums.length];\n    int[] sums_ind = new int[nums.length];\n\
    \    int j = 0;\n    foreach(immutable int i; 0..nums.length)\n    {\n       \
    \ sum = 0;\n        digits = nums[i].toString().map!(i => i.to!int()).array;\n\
    \        foreach(immutable int n; digits)\n        {\n            sum += n;\n\
    \        }\n        sums[j] = sum;\n        sums_ind[j] = i;\n        j++;\n \
    \   }\n    return std.algorithm.sort!((a, b) => a[0] < b[0])(tuple(sums, sums_ind))[1].array.map!(i\
    \ => nums[i]).array;\n}", "{\n    long maxDigits(long n)\n    {\n        long\
    \ ret = 0;\n        while(n > 0)\n        {\n            ret += n % 10;\n    \
    \        n /= 10;\n        }\n        return ret;\n    }\n    return sort!(((a,\
    \ b) => a.item1.idx > b.item1.idx))(nums.map!(x => tuple(x, maxDigits(x))));\n\
    }", "{\n    auto sorted = nums.dup;\n    auto points = sorted.map!((i) => new\
    \ Tuple!(int, int)(sumOfDigits(i), i));\n    points.sort!((a, b) => a[0] < b[0]\
    \ || (a[0] == b[0] && a[1] < b[1]));\n    sorted = points.map!((i) => i[1]).array;\n\
    \    return sorted;\n}", "{\n    long[][] copy = [];\n    nums.sort();\n    foreach(num;\
    \ nums)\n    {\n        if(copy.length == 0)\n        {\n            copy ~= [num,num.digits];\n\
    \        }\n        else\n        {\n            bool placed = false;\n      \
    \      foreach(i,cpy; copy)\n            {\n                if(num.digits >= cpy[1])\n\
    \                {\n                    copy.insert(i,[num,num.digits]);\n   \
    \                 placed = true;\n                    break;\n               \
    \ }\n            }\n            if(!placed)\n            {\n                copy\
    \ ~= [num,num.digits];\n            }\n        }\n    }\n    return copy.map!(tuple\
    \ => tuple[0]);\n}", "{\n    return nums.sort!((x, y) => sumDigits(x) < sumDigits(y)).array;\n\
    }", "{\n    auto key = (l) =>\n    {\n        l = abs(l);\n        long sum =\
    \ 0;\n        while (l != 0)\n        {\n            sum += l % 10;\n        \
    \    l /= 10;\n        }\n        return sum;\n    };\n    auto cmp = (a, b) =>\n\
    \    {\n        if (key(a) < key(b)) return -1;\n        if (key(a) > key(b))\
    \ return 1;\n        return a < b ? -1 : 1;\n    };\n    return nums.quicksort(cmp);\n\
    }", "{\n    \n    ulong[] result = new ulong[];\n    auto digits=nums.map!((n)=>\n\
    \    {\n        ulong r = 0;\n        for(int i=0;i<4;i++)\n        {\n      \
    \      r+=n%10;\n            n/=10;\n        }\n        return r;\n    });\n \
    \   auto t=typeof(digits);\n    auto t2=typeof(nums);\n    for(int i=0;i<digits.length;i++)\n\
    \    {\n        int min_pos=i;\n        for(int j=i+1;j<digits.length;j++)\n \
    \       {\n            if(digits[j]<digits[min_pos])\n            {\n        \
    \        min_pos=j;\n            }\n        }\n        ulong temp=digits[i];\n\
    \        digits[i]=digits[min_pos];\n        digits[min_pos]=temp;\n        ulong\
    \ temp2=nums[i];\n        nums[i]=nums[min_pos];\n        nums[min_pos]=temp2;\n\
    \    }\n    return nums;\n}", "{\n    if (nums.length == 0) return new long[0];\n\
    \    auto temp = nums.dup;\n    auto temp2 = nums.dup;\n    for (int i = 0; i\
    \ < nums.length; i++) \n    {\n        auto pos = 0;\n        for (int j = 0;\
    \ j < temp.length; j++) \n        {\n            if (temp[i] >= temp[j]) pos++;\n\
    \        }\n        temp2[pos] = temp[i];\n    }\n    return temp2;\n}", "{\n\
    \    auto cmp = (T)(T n1, T n2) {\n        return T.length < n2.length ? -1 :\
    \ T.length > n2.length ? 1 : 0;\n    };\n    return sort!cmp(nums);\n}\n/*\n \
    \   Write a function named `rps` (rock paper scissors) which takes an integer\n\
    \    (representing the number of rounds) and two functions as arguments.\n   \
    \ It should play the Rock-Paper-Scissors game with provided functions as players\n\
    \    and return true if the first player wins and false otherwise.", "{\n    int[]\
    \ sums = new int[nums.length];\n    auto points = new int[];\n    auto result\
    \ = new long[];\n    for (int i = 0; i < nums.length; i++)\n    {\n        int\
    \ sum = 0;\n        foreach (c; nums[i].to!string)\n        {\n            if\
    \ (isDigit(c))\n            {\n                sum += c.to!int - '0'.to!int;\n\
    \            }\n        }\n        sums[i] = sum;\n        points ~= i;\n    }\n\
    \    auto toSort = zip(sums, points);\n    std.algorithm.sort!((x, y) => x[0]\
    \ > y[0] || (x[0] == y[0] && x[1] > y[1]))(toSort);\n    foreach (i; toSort)\n\
    \    {\n        result ~= nums[i[1]];\n    }\n    return result;\n}", "{\n   \
    \ auto l1 = new Array!(tuple(long, size_t))(nums.length);\n    foreach(i, e; nums)\n\
    \    {\n        auto sum = 0L;\n        foreach(c; e.to!string())\n        {\n\
    \            if(c.isDigit)\n                sum += c.to!long;\n        }\n   \
    \     l1[i] = tuple(e, sum);\n    }\n    auto l2 = l1.sort!(\"a[1] < b[1]\");\n\
    \    return l2.map!(a => a[0]).array;\n}", "{\n    size_t i;\n    long[] res;\n\
    \    if(nums.length == 0)\n        return nums;\n    else\n    {\n        res\
    \ = new long[nums.length];\n        foreach(ref item; nums)\n        {\n     \
    \       if(item < 0)\n                item = -item;\n            res ~= item;\n\
    \        }\n        auto result = std.algorithm.sort!((x, y) => (x%10 + x/10)\
    \ < (y%10 + y/10))(res);\n        auto origIndex = std.algorithm.sort!((x, y)\
    \ => x < y)(result.save);\n        return nums[origIndex];\n    }\n}", "{\n  \
    \  auto v = nums.map!(n => tuple(n, n.sumOfDigits)).sort!((a, b) => a[1] < b[1]);\n\
    \    return v.map!(t => t[0]).array;\n}", "{\n    // TODO\n}\n/*\n    The lenght\
    \ of the given array is checked, if it is not 0, then the array is sorted\n  \
    \  according to the sum of its digits, if several items have similar sum, the\
    \ order is based\n    on their index in the original array.\n*/", "{\n\ttypeof(nums)\
    \ numeros = [ 3L, 2L, 1L ];", "{\n    import std.algorithm;\n    import std.conv;\n\
    \    import std.array;\n    auto converted_nums = nums.map!(i => tuple(i, i.to!string().map!(c\
    \ => c.to!int()).sum)).\n        enforce!(tuple!(long, int)).\n        sort!(t\
    \ => t[1]);\n    return converted_nums.map!(i => i[0]).array;\n}\n ", "{ \n  \
    \  // your code goes here\n    long[] temp=new long[nums.length];\n    foreach(int\
    \ i, ref long num; nums)\n    {\n        temp[i]=num;\n    }\n    sort(nums,(lhs,rhs)=>sum_digits(lhs)<sum_digits(rhs));\n\
    \    return nums;\n} ", "{\n    double[] points;\n    long[] idx;\n    nums.size();\n\
    \    // Allocate a set of points based on the number of elements\n    // present\
    \ in the nums array. This is effectively a 1-1 mapping\n    // of an index to\
    \ an element.\n    points = new double[nums.size()];\n    long i = 0;\n    foreach(long\
    \ n; nums)\n    {\n        double p = 0;\n        do\n        {\n            p\
    \ += n % 10;\n            n /= 10;\n        }\n        while(n != 0);\n      \
    \  points[i] = p;\n        i++;\n    }\n    idx = idx = new long[nums.size()];\n\
    \    for(i = 0; i < nums.size(); i++)\n    {\n        idx[i] = i;\n    }\n   \
    \ // Bubble sort the points in descending order,\n    // swapping their indices\
    \ at the same time.\n    auto swaps = true;\n    while(swaps)\n    {\n       \
    \ swaps = false;\n        for(i = 0; i < nums.size() - 1; i++)\n        {\n  \
    \          if(points[i] < points[i + 1])\n            {\n                auto\
    \ temp = points[i];\n                points[i] = points[i + 1];\n            \
    \    points[i + 1] = temp;\n                temp = idx[i];\n                idx[i]\
    \ = idx[i + 1];\n                idx[i + 1] = temp;\n                swaps = true;\n\
    \            }\n        }\n    }\n    // I'm a big dummy, so instead of sorting\
    \ it in place,\n    // I'm going to create a new sorted array with the\n    //\
    \ elements from the nums array.\n    auto sorted = new long[nums.size()];\n  \
    \  for(i = 0; i < nums.size(); i++)\n    {\n        sorted[i] = nums[idx[i]];\n\
    \    }\n    return sorted;\n}", "{\n    const int[] SUM_DIGITS = nums.map!(p =>\
    \ p.to!string.map!(ch => ch.to!int - '0'.to!int).sum.to!int).array;\n    auto\
    \ result = nums.dup;\n    sort!((a, b) => {\n        const int A = SUM_DIGITS[a];\n\
    \        const int B = SUM_DIGITS[b];\n        return A < B || (A == B && a <\
    \ b);\n    })(result);\n    return result;\n}", "{\n    if (nums.length < 2)\n\
    \        return nums;\n    long[] workingCopy = nums.dup;\n    sort(workingCopy,\
    \ (a, b) => sumDigits(a) < sumDigits(b));\n    return workingCopy;\n}", "{ \n\
    \    long sum = 0; \n    long[] sumArray = new long[nums.length]; \n    for (int\
    \ i = 0; i < nums.length; i++) \n    { \n        sum = 0; \n        while (nums[i]\
    \ != 0) \n        { \n            sum += nums[i] % 10; \n            nums[i] /=\
    \ 10; \n        } \n        sumArray[i] = sum; \n    } \n    int[] newSumArray\
    \ = zip!(nums, sumArray); \n    sort!(\"a[1] < b[1] || (a[1] == b[1] && a[0] <\
    \ b[0]\"); \n    return newSumArray.map!(a => a[0]).array; \n} \nlong[] order_by_points(long[]\
    \ nums) \n{ \n    long sum = 0; \n    long[] sumArray = new long[nums.length];\
    \ \n    for (int i = 0; i < nums.length; i++) \n    { \n        sum = 0; \n  \
    \      while (nums[i] != 0) \n        { \n            sum += nums[i] % 10; \n\
    \            nums[i] /= 10; \n        } \n        sumArray[i] = sum; \n    } \n\
    \    int[] newSumArray = zip!(nums, sumArray); \n    sort!(\"a[1] < b[1] || (a[1]\
    \ == b[1] && a[0] < b[0]\"); \n    return newSumArray.map!(a => a[0]).array; \n\
    } \nlong[] order_by_points(long[] nums) \n{ \n    long sum = 0; \n    long[] sumArray\
    \ = new long[nums.length]; \n    for (int i = 0; i < nums.length; i++) \n    {\
    \ \n        sum = 0; \n        while (nums[i] != 0) \n        { \n           \
    \ sum += nums[i] % 10; \n            nums[", "{\n    long[] sums = new long[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++) {\n        long n = nums[i];\n    \
    \    long s = 0;\n        while (n != 0) {\n            s += n % 10;\n       \
    \     n /= 10;\n        }\n        sums[i] = s;\n    }\n    auto ord = tuple(sums,\
    \ nums);\n    std.algorithm.sort!(\"a < b\")(ord);\n    return ord[1];\n}\n/*\n\
    \    Write a function which takes a string and a non-negative integer as parameters,\n\
    \    and returns a string with a maximum length of the integer,\n    consisting\
    \ of the first n non-whitespace characters of the string.\n    If the string has\
    \ less than n non-whitespace characters, just return the whole string.", "{\n\
    \    if (nums.length == 0)\n        return nums;\n    ulong[] sums = new ulong[nums.length];\n\
    \    int[] indexes = new int[nums.length];\n    foreach (i, v; nums)\n    {\n\
    \        sums[i] = abs(v).to!ulong;\n        indexes[i] = i;\n    }\n    for (int\
    \ i = 0; i < nums.length; i++)\n    {\n        for (int j = 0; j < nums.length\
    \ - 1; j++)\n        {\n            if (sums[j] > sums[j + 1])\n            {\n\
    \                swap(sums[j], sums[j + 1]);\n                swap(indexes[j],\
    \ indexes[j + 1]);\n            }\n        }\n    }\n    long[] new_nums = new\
    \ long[nums.length];\n    foreach (i, v; indexes)\n    {\n        new_nums[i]\
    \ = nums[v];\n    }\n    return new_nums;\n}", "{\n    alias Pair = Tuple!(long,\
    \ int);\n    auto numsByPoints = array(nums.map!(x => Pair(x, reduce!((a, b) =>\
    \ a + b, x.toString().map!(n => n.to!int - '0'.to!int).array).array)))\n     \
    \                .sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n\
    \    return numsByPoints.map!(x => x[0]).array;\n}", "{\n    static auto getSum\
    \ = (long num) => \n    {\n        long sum = 0;\n        for (; num != 0; num\
    \ /= 10)\n            sum += num % 10;\n        return sum;\n    };\n    return\
    \ nums\n        .map!(num => tuple(num, getSum(num)))\n        .sort!((a, b) =>\
    \ a[1] == b[1] ? a[0] < b[0] : a[1] < b[1])\n        .map!(x => x[0])\n      \
    \  .array;\n}", "{\n    auto s = nums.map!((x) => tuple(x, sum([(x % 10).abs,\
    \ ((x / 10) % 10).abs, (x / 100).abs])));\n    s.sort!((a, b) => a[1] == b[1]\
    \ ? a[0] < b[0] : a[1] < b[1]);\n    return s.map!((x) => x[0]).array;\n}", "{\
    \ \n    long[] sums = new long[nums.length];\n    foreach(immutable i, ref a;\
    \ nums)\n    {\n        long sum = 0;\n        if(a < 0)\n            a = abs(a);\n\
    \        while(a > 0)\n        {\n            sum += a % 10;\n            a /=\
    \ 10;\n        }\n        sums[i] = sum;\n    }\n    auto pairs = new typeof(nums.zip(sums));\n\
    \    pairs.sort!\"a.item2\";\n    foreach(pair; pairs)\n        nums[pair.item1]\
    \ = pair.item0;\n    return nums;\n}", "{\n  long[] points = new long[nums.length];\n\
    \  foreach(int i, long e; nums)\n  {\n    points[i] = std.math.abs(e);\n  }\n\
    \  int[][] zipped = zip(nums, points);\n  std.sort(zipped, (int[] a, int[] b)\
    \ {\n    return a[1] - b[1];\n  });\n  long[] ordered = new long[nums.length];\n\
    \  foreach(int i, int[] e; zipped)\n  {\n    ordered[i] = e[0];\n  }\n  return\
    \ ordered;\n}", "{\n    if (nums.length == 0)\n        return new long[0];\n \
    \   long[] result = new long[nums.length];\n    int[] sums = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        sums[i] = 0;\n    \
    \    if (nums[i] < 0)\n            nums[i] *= -1;\n        while (nums[i] != 0)\n\
    \        {\n            sums[i] += nums[i] % 10;\n            nums[i] /= 10;\n\
    \        }\n    }\n    assert(result.length == nums.length);\n    assert(result.length\
    \ == sums.length);\n    auto list = zip(sums, nums);\n    sort!((a, b) => a[0]\
    \ < b[0] || (a[0] == b[0] && a[1] < b[1]))(list);\n    foreach (i, val; list)\n\
    \    {\n        result[i] = val[1];\n    }\n    return result;\n}\n// void main()\n\
    // {\n//     writeln(order_by_points([1L, 11L, -1L, -11L, -12L]));\n//     writeln(order_by_points([]));\n\
    // }", "{\n    if (nums.length == 0) \n    {\n        return nums;\n    }\n  \
    \  else \n    {\n        Tuple!(long, long[])[] sums = new Tuple!(long, long[])[nums.length];\n\
    \        for (int i = 0; i < nums.length; i++) \n        {\n            long[]\
    \ arr = nums[i].toString().byCode.map!(c => to!long(c)).array;\n            long\
    \ sum = arr.reduce!((a, b) => a + b)();\n            sums[i] = tuple(sum, arr);\n\
    \        }\n        Sort!((a, b) => a[0] < b[0], int[])(sums);\n        long[]\
    \ result = new long[nums.length];\n        int j = 0;\n        foreach (tup; sums)\
    \ \n        {\n            foreach (item; tup[1]) \n            {\n          \
    \      result[j] = item;\n                j++;\n            }\n        }\n   \
    \     return result;\n    }\n}\n/*\n    Write a function which concatenates two\
    \ given strings, \n    removing the characters from the first string if the\n\
    \    second string is already present in the first string.\n    For example:\n\
    \    >>> concatenate_strings(\"abc\", \"xyz\")\n    \"xyz\"\n    >>> concatenate_strings(\"\
    abz\", \"xyz\")\n    \"abzxyz\"\n    >>> concatenate_strings(\"abc\", \"abz\"\
    )\n    \"abc\"\n    >>> concatenate_strings(\"\", \"xyz\")\n    \"xyz\"\n    >>>\
    \ concatenate_strings(\"\", \"\")\n    \"\"\n*/\nstring concatenate_strings(string\
    \ first, string second) \n{\n    foreach (char; second) \n    {\n        first\
    \ = first.replace(char, \"\");\n    }\n    return first ~ second;\n}\n/*\n   \
    \ Write a function which returns the third largest element\n    in a given array\
    \ of integers. If there are less than three\n    distinct integers in the array,\
    \ return -1.", "{\n    // TODO: implement order_by_points()\n    return null;\n\
    }\n// test\n/*\n    import std.stdio;\n    import std.math;\n    import std.typecons;\n\
    \    void main()\n    {\n        writeln(order_by_points([1L, 11L, -1L, -11L,\
    \ -12L]));\n        writeln(order_by_points([]));\n    }\n*/", "{\n    long[]\
    \ result = nums.dup;\n    result.sort((a, b) => cast(int)sumDigits(a) - cast(int)sumDigits(b));\n\
    \    return result;\n}\nlong sumDigits(long num)\n{\n    long result = 0;\n  \
    \  foreach(digit; num.toString().chars.map!((c) => cast(long)(c - '0')))\n   \
    \ {\n        result += digit;\n    }\n    return result;\n}\n// More compact version\n\
    long[] order_by_points2(long[] nums) \n{\n    long[] result = nums.dup;\n    result.sort((a,\
    \ b) => cast(int)sumDigits2(a) - cast(int)sumDigits2(b));\n    return result;\n\
    }\nlong sumDigits2(long num)\n{\n    return num.toString().chars.map!((c) => cast(long)(c\
    \ - '0')).sum;\n}", "{\n    if (nums.length == 0)\n        return nums;\n    else\n\
    \    {\n        int[] sums = new int[nums.length];\n        foreach (i, item;\
    \ nums)\n        {\n            int sum = 0;\n            foreach (j, digit; item.to!string)\n\
    \                sum += to!int(digit);\n            sums[i] = sum;\n        }\n\
    \        // https://stackoverflow.com/questions/17547112/how-to-generate-all-permutations-of-set-of-natural-numbers-without-repetitions\n\
    \        // Create the Permutations of the Nums array based on the sums of the\
    \ digits.\n        int[][] permutations = permutationsOf(sums);\n        int[]\
    \ sumsOfPermutations = new int[permutations.length];\n        // Sum up each permutation\
    \ and store it in the sumsOfPermutations array.\n        foreach (i, sum; sumsOfPermutations)\n\
    \            foreach (j, permutation; permutations)\n                sumsOfPermutations[i]\
    \ += permutation[j];\n        // Find the lowest sum and its index\n        int\
    \ minSum = min(sumsOfPermutations);\n        int indexOfMinSum = 0;\n        foreach\
    \ (index, sum; sumsOfPermutations)\n            if (sum == minSum)\n         \
    \       indexOfMinSum = index;\n        // Return the permutation with the lowest\
    \ sum as an array.\n        return to!(long[])(permutations[indexOfMinSum]);\n\
    \    }\n}", "{\n    int n = nums.length;\n    long[][]pairs = new long[n][];\n\
    \    foreach(i, x; nums)\n    {\n        pairs[i] = [i, x];\n    }\n    sort!(\"\
    a[1] > b[1] || (a[1] == b[1] && a[0] < b[0]\")(pairs);\n    long[]sorted = pairs.map!(x\
    \ => x[1]).array;\n    return sorted;\n}", "{\n    int[][] sums = new int[nums.length][2];\n\
    \    for (int i = 0; i < nums.length; i++) {\n        sums[i][0] = sum(nums[i]);\n\
    \        sums[i][1] = i;\n    }\n    auto comparator = (x, y) => x[0] == y[0]\
    \ ?\n                                x[1] - y[1] :\n                         \
    \       x[0] - y[0];\n    std.array.sort(sums, comparator);\n    long[] res =\
    \ new long[nums.length];\n    for (int i = 0; i < sums.length; i++) {\n      \
    \  res[i] = nums[sums[i][1]];\n    }\n    return res;\n}\n/*\n    Write a function\
    \ which maps the given array of integers\n    to the following function:\n   \
    \ f(x) = (x + 1) * (x + 2) * ... * (x + n)\n    You may assume that all elements\
    \ in array are non-negative.", "{\n    /*\n        Write your code here.\n   \
    \ */\n    if(nums.length == 0) return nums;\n    long[] x = new long[nums.length];\n\
    \    long[] temp = new long[nums.length];\n    long[] index = new long[nums.length];\n\
    \    for(int i = 0; i < nums.length; i++)\n    {\n        if(nums[i] < 0) x[i]\
    \ = abs(nums[i]);\n        else x[i] = nums[i];\n        index[i] = i;\n    }\n\
    \    for(int i = 0; i < nums.length; i++)\n    {\n        int sum = 0;\n     \
    \   while(x[i] > 0)\n        {\n            sum += x[i] % 10;\n            x[i]\
    \ /= 10;\n        }\n        temp[i] = sum;\n    }\n    for(int i = 0; i < nums.length\
    \ - 1; i++)\n    {\n        for(int j = i + 1; j < nums.length; j++)\n       \
    \ {\n            if(temp[i] > temp[j])\n            {\n                long t\
    \ = temp[i];\n                temp[i] = temp[j];\n                temp[j] = t;\n\
    \                t = nums[i];\n                nums[i] = nums[j];\n          \
    \      nums[j] = t;\n                t = index[i];\n                index[i] =\
    \ index[j];\n                index[j] = t;\n            }\n            else if(temp[i]\
    \ == temp[j])\n            {\n                if(index[i] > index[j])\n      \
    \          {\n                    long t = nums[i];\n                    nums[i]\
    \ = nums[j];\n                    nums[j] = t;\n                    t = index[i];\n\
    \                    index[i] = index[j];\n                    index[j] = t;\n\
    \                }\n            }\n        }\n    }\n    return nums;\n}\n//long[]\
    \ nums = [-1L, -11L, 1L, -12L, 11L", "{\n    long[] res = new long[nums.length];\n\
    \    int[] sum = new int[nums.length];\n    for (int i = 0; i < nums.length; i++)\
    \ {\n        sum[i] = nums[i] < 0 ? -nums[i] : nums[i];\n        while (sum[i]\
    \ > 0) {\n            sum[i] = sum[i] % 10 + sum[i] / 10;\n        }\n    }\n\
    \    auto sorted = sort!(a => a[1])(zip(nums, sum));\n    for (int i = 0; i <\
    \ nums.length; i++) {\n        res[i] = sorted[i][0];\n    }\n    return res;\n\
    }", "{\n  if (nums.length == 0)\n  {\n    return nums;\n  }\n  else\n  {\n   \
    \ long[] theNew = new long[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n      theNew[i] = nums[i];\n    }\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n      long sum1 = 0;\n      long sum2 = 0;\n      long divisor\
    \ = 10;\n      while (theNew[i] > 0)\n      {\n        long remainder = theNew[i]\
    \ % divisor;\n        sum1 += remainder;\n        theNew[i] /= divisor;\n    \
    \  }\n      divisor = 10;\n      while (nums[i] > 0)\n      {\n        long remainder\
    \ = nums[i] % divisor;\n        sum2 += remainder;\n        nums[i] /= divisor;\n\
    \      }\n      if (sum1 < sum2)\n      {\n        long temp = theNew[i];\n  \
    \      theNew[i] = theNew[i+1];\n        theNew[i+1] = temp;\n      }\n    }\n\
    \    return theNew;\n  }\n}", "{\n    if (nums.length == 0)\n        return nums;\n\
    \    else\n    {\n        long[] big = new long[nums.length];\n        for (int\
    \ i = 0; i < nums.length; i++)\n        {\n            long n = nums[i];\n   \
    \         big[i] = n > 0 ? n : -n;\n        }\n        return nums.dup.sort!((ref\
    \ long a, ref long b) => \n        {\n            auto[sum_a, sum_b] = tuple(sum_digits(big[a]),\
    \ sum_digits(big[b]));\n            if (sum_a == sum_b)\n                return\
    \ a > b;\n            else\n                return sum_a > sum_b;\n        });\n\
    \    }\n}\nlong sum_digits(long n)\n{\n    long s = 0;\n    do\n    {\n      \
    \  s += n % 10;\n        n /= 10;\n    } while (n != 0);\n    return s;\n}", "{\n\
    \    assert (nums != null);\n    // Sum the elements of the array\n    auto n\
    \ = nums.length;\n    auto arr = new tuple!(long, long)[n];\n    foreach (i, x;\
    \ nums) {\n        arr[i] = tuple(x, x.sum_digits());\n    }\n    // Sort the\
    \ array by sum\n    auto cmp = (t1, t2) => {\n        if (t1[1] == t2[1]) return\
    \ t1[0] > t2[0];\n        return t1[1] > t2[1];\n    };\n    sort(arr, cmp);\n\
    \    // Return the sorted array\n    return arr.map!(t => t[0]).array;\n}", "{\n\
    \    int[] points=new int[nums.length];\n    for(int i=0;i<nums.length;i++)\n\
    \    {\n        int sum=0;\n        long tmp=abs(nums[i]);\n        while(tmp!=0)\n\
    \        {\n            sum+=(int)(tmp%10);\n            tmp/=10;\n        }\n\
    \        points[i]=sum;\n    }\n    long[] result=new long[nums.length];\n   \
    \ int[] p=new int[points.length];\n    for(int i=0;i<points.length;i++)\n    {\n\
    \        p[i]=i;\n    }\n    int[] pp=new int[points.length];\n    for(int i=0;i<points.length;i++)\n\
    \    {\n        int max=i;\n        for(int j=i+1;j<points.length;j++)\n     \
    \   {\n            if(points[j]<points[max])\n            {\n                max=j;\n\
    \            }\n        }\n        int tmp=points[i];\n        points[i]=points[max];\n\
    \        points[max]=tmp;\n        pp[i]=p[max];\n        p[max]=p[i];\n    }\n\
    \    for(int i=0;i<nums.length;i++)\n    {\n        result[i]=nums[pp[i]];\n \
    \   }\n    return result;\n}\n//end of solution", "{\n    import std.algorithm.sorting\
    \ : sort;\n    import std.algorithm.comparison : equal;\n    import std.traits\
    \ : isIntegral;\n    import std.range : iota;\n    import std.typecons : Tuple;\n\
    \    import std.conv : to;\n    assert(nums.all!isIntegral);\n    static assert(is(typeof(unittest){}));\n\
    \    static if (nums.length)\n    {\n        int[int] sum_map;\n        foreach\
    \ (i, e; nums)\n        {\n            int sum = 0;\n            foreach (c; to!string(e))\n\
    \                sum += c.digit;\n            auto key = sum;\n            while\
    \ (key in sum_map)\n                key++;\n            sum_map[key] = i;\n  \
    \      }\n        long[] res;\n        foreach (key; sort(sum_map.keys))\n   \
    \         res ~= nums[sum_map[key]];\n        return res;\n    }\n    else\n \
    \       return [];\n}", "{\n    return sort(nums, (a, b) => \n    {\n        return\
    \ sumDigits(a) < sumDigits(b) ? -1 : sumDigits(a) > sumDigits(b) ? 1 : 0;\n  \
    \  });\n}\nlong sumDigits(long l)\n{\n    long result = 0;\n    while(l != 0)\n\
    \    {\n        result += l % 10;\n        l /= 10;\n    }\n    return result;\n\
    }", "{\n    if (nums.length == 0)\n        return nums;\n    return nums.sort!q{a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0])}()\n               .map!(i => i[1])();\n\
    }", "{\n    static struct Point(long[3] x) { long[] x; }\n    return nums.map!(x\
    \ => Point(x)).sort!(\"a.x[1] < b.x[1] || (a.x[1] == b.x[1] && a.x[2] < b.x[2])\"\
    ).map!(x => x.x[0]).array;\n}", "{\n    if (nums.length == 0)\n        return\
    \ nums;\n    auto longest = 0;\n    foreach (n; nums)\n    {\n        if (n.length\
    \ > longest)\n            longest = n.length;\n    }\n    long[][] matrix = new\
    \ long[][](longest, nums.length);\n    foreach (n; nums)\n    {\n        auto\
    \ row = 0;\n        foreach (d; n.toChars)\n        {\n            matrix[row][n]\
    \ = d.to!long;\n            row++;\n        }\n    }\n    auto sums = matrix.map!((line)\
    \ => line.sum);\n    auto indices = sums.enumerate.sort!((a, b) => a[1] < b[1]);\n\
    \    return indices.map!((a) => nums[a[0]]).array;\n}", "{\n    immutable type\
    \ Input = Tuple!(ulong, long);", "{\n    if (nums.length == 0) \n    {\n     \
    \   return nums;\n    }\n    Tuple!(int, long)[] tuples = new Tuple!(int, long)[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++) \n    {\n        tuples[i] = tuple(num2Int(nums[i]),\
    \ nums[i]);\n    }\n    tuples.sort!(\"a.tupleof[0] > b.tupleof[0] ? 1 : a.tupleof[0]\
    \ < b.tupleof[0] ? -1 : a.tupleof[1] > b.tupleof[1] ? 1 : a.tupleof[1] < b.tupleof[1]\
    \ ? -1 : 0\")(tuple2Comp);\n    long[] result = new long[nums.length];\n    for\
    \ (int i = 0; i < nums.length; i++) \n    {\n        result[i] = tuples[i].tupleof[1];\n\
    \    }\n    return result;\n}", "{\n    int[] sum = [];\n    foreach(i; 0..nums.length)\n\
    \    {\n        sum ~= nums[i].digits().sum;\n    }\n    int[] point = [];\n \
    \   foreach(i; 0..nums.length)\n    {\n        point ~= i;\n    }\n    //sort\n\
    \    auto sort = tuples!(int, \"a\", int, \"b\")(sum, point);\n    sort[] = sort[0\
    \ .. $].sort!((a, b) => a[0] < b[0]);\n    int[] newpoint = [];\n    foreach(i;\
    \ 0..nums.length)\n    {\n        newpoint ~= sort[i][1];\n    }\n    //int[]\
    \ newnums = [];\n    //foreach(i; 0..nums.length)\n    //{\n    //    newnums\
    \ ~= nums[newpoint[i]];\n    //}\n    //return newnums;\n    return nums[newpoint];\n\
    }\n \n \n \n ", "{\n    if (nums.length == 0)\n        return nums;\n    long[]\
    \ ans = new long[nums.length];\n    int index = 0;\n    for (long n : nums)\n\
    \    {\n        ans[index] = n;\n        index++;\n    }\n    sort(ans);\n   \
    \ index = 0;\n    int[] sum = new int[nums.length];\n    for (long n : nums)\n\
    \    {\n        sum[index] = n.to!string.split(\"\").map!(a => a.to!int).sum();\n\
    \        index++;\n    }\n    int[] mini = new int[nums.length];\n    index =\
    \ 0;\n    for (int n : sum)\n    {\n        if (n == min(sum))\n        {\n  \
    \          mini[index] = 1;\n        }\n        index++;\n    }\n    int i = 0;\n\
    \    while (i < mini.length)\n    {\n        if (mini[i] == 1)\n        {\n  \
    \          break;\n        }\n        i++;\n    }\n    long temp = ans[i];\n \
    \   ans[i] = ans[0];\n    ans[0] = temp;\n    for (int j = 1; j < ans.length;\
    \ j++)\n    {\n        if (sum[j] == sum[j-1])\n        {\n            continue;\n\
    \        }\n        for (int k = 0; k < ans.length; k++)\n        {\n        \
    \    if (sum[k] == sum[j])\n            {\n                temp = ans[k];\n  \
    \              ans[k] = ans[j];\n                ans[j] = temp;\n            \
    \    break;\n            }\n        }\n    }\n    return ans;\n}", "{\n    int[]\
    \ digit_sum = new int[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        int sum = 0;\n        foreach (char c; to!string(nums[i]))\n \
    \       {\n            if (c == '-')\n                continue;\n            sum\
    \ += c - '0';\n        }\n        digit_sum[i] = sum;\n    }\n    return nums.dup.sort!((a,\
    \ b) => digit_sum[a] < digit_sum[b] || (digit_sum[a] == digit_sum[b] && a < b));\n\
    }", "{\n    if (nums.length < 2)\n        return nums;\n    else\n    {\n    \
    \    // create a new array of tuples\n        Tuple!(ulong, long)[nums.length]\
    \ tArr;\n        // loop through each item in the array,\n        // add the sum\
    \ of its digits to the same place in the tuple array\n        foreach (i, num;\
    \ nums)\n        {\n            long total = 0;\n            foreach (letter;\
    \ to!string(num))\n                total += letter.to!long;\n            tArr[i]\
    \ = tuple(total, num);\n        }\n        // sort the tuple array, using the\
    \ first element as the key\n        sort!(tArr, (a, b) => a[0] < b[0]);\n    \
    \    // pull the values out of the tuples and add them to the new long array\n\
    \        long[] ans;\n        foreach (t; tArr)\n            ans ~= t[1];\n  \
    \      return ans;\n    }\n}", "{\n    if (nums.length == 0)\n        return new\
    \ long[0];\n    long[] arr = new long[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        long n = nums[i];\n        if (n < 0)\n            n =\
    \ -n;\n        long sum = 0;\n        while (n != 0)\n        {\n            sum\
    \ += n % 10;\n            n /= 10;\n        }\n        arr[i] = sum;\n    }\n\
    \    int[] idx = new int[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \        idx[i] = i;\n    idx.sort!((a, b) => arr[a] < arr[b] || (arr[a] == arr[b]\
    \ && a < b));\n    long[] res = new long[nums.length];\n    for (int i = 0; i\
    \ < nums.length; i++)\n        res[i] = nums[idx[i]];\n    return res;\n}", "{\n\
    \    long[] ret = nums.dup;\n    // Your code goes here\n    return ret;\n}",
  "{\n    long[] sum;\n    foreach(el; nums)\n    {\n        if(el < 0)\n        \
    \    sum ~= el.to!string.sum + -el;\n        else\n            sum ~= el.to!string.sum\
    \ + el;\n    }\n    assert(nums.length == sum.length);\n    long[][] p = sort!(long[])(\"\
    a[0] > b[0]\")(zip(sum, nums));\n    return p.map!((a) => a[1]).array;\n}", "{\n\
    \    int n = nums.length;\n    int[] sums = new int[n];\n    for (int i = 0; i\
    \ < n; i++) {\n        sums[i] = sumDigits(nums[i]);\n    }\n    return nums[sort(tuple(sums,\
    \ nums))[$]];\n}", "{\n    auto arr = nums.dup;\n    long[] result;\n    foreach(i;\
    \ 0 .. arr.length)\n    {\n        foreach(j; 0 .. arr.length - 1)\n        {\n\
    \            if(sum(std.string.digits(to!string(arr[j]))) > sum(std.string.digits(to!string(arr[j\
    \ + 1]))))\n            {\n                long tmp = arr[j];\n              \
    \  arr[j] = arr[j + 1];\n                arr[j + 1] = tmp;\n            }\n  \
    \      }\n    }\n    return arr;\n}", "{\n    int[] a = new int[nums.length];\n\
    \    // sum of digits\n    for (int i = 0; i < nums.length; i++)\n    {\n    \
    \    int sum = 0;\n        foreach (char ch; nums[i].to!string) \n        {\n\
    \            sum += ch.to!int - 48;\n        }\n        a[i] = sum;\n    }\n \
    \   // get min value\n    int min = int.max;\n    foreach (e; a) \n    {\n   \
    \     if (e < min) \n        {\n            min = e;\n        }\n    }\n    //\
    \ get min value index\n    int[] min_index = [];\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == min) \n        {\n            min_index ~=\
    \ i;\n        }\n    }\n    // get result\n    long[] res = new long[nums.length];\n\
    \    int[] flag = new int[nums.length];\n    int len = min_index.length;\n   \
    \ int j = 0;\n    for (int i = 0; i < nums.length; i++)\n    {\n        if (i\
    \ < len) \n        {\n            res[i] = nums[min_index[i]];\n            flag[min_index[i]]\
    \ = 1;\n        }\n        else \n        {\n            if (flag[j] == 0) \n\
    \            {\n                res[i] = nums[j];\n            }\n           \
    \ else \n            {\n                i--;\n            }\n            j++;\n\
    \        }\n    }\n    return res;\n}\n/*\n    Write a function that, given an\
    \ array A consisting of N integers,\n    returns the number of distinct values\
    \ in array A.", "{\n    if (nums.length == 0)\n        return nums;\n    auto\
    \ sumDigits = (long num) => {\n        long sum = 0;\n        while (num != 0)\n\
    \        {\n            sum += num % 10;\n            num /= 10;\n        }\n\
    \        return sum;\n    };\n    return nums.sort!((a, b) => tuple(sumDigits(a),\
    \ nums.indexOf(a)) < tuple(sumDigits(b), nums.indexOf(b)));\n}\n// (2 ms)", "{\n\
    \    static struct Entry {\n        long sum;\n        size_t index;\n    }\n\
    \    auto entry = [](long sum, size_t index) {\n        Entry e;\n        e.sum\
    \ = sum;\n        e.index = index;\n        return e;\n    };\n    auto comp =\
    \ [](const Entry a, const Entry b) {\n        return a.sum < b.sum || (a.sum ==\
    \ b.sum && a.index < b.index);\n    };\n    auto toLong = [](const Entry e) {\n\
    \        return e.index;\n    };\n    return nums.map!(entry, toLong)(comp);\n\
    }", "{\n    static int getSum(long x) \n    {\n        int sum = 0;\n        while\
    \ (x != 0) \n        {\n            sum += cast(int)(x % 10);\n            x /=\
    \ 10;\n        }\n        return sum;\n    }\n    long[] temp = nums[];\n    sort!((int\
    \ a, int b) => getSum(a) < getSum(b))(temp);\n    return temp;\n}", "{ \n    int[]\
    \ sums = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n\
    \        sums[i] = nums[i].digits.sum;\n    }\n    auto sorted = nums.zip(sums).sort!((x,\
    \ y) => x[1] < y[1]);\n    return sorted.map!(x => x[0]).array;\n}", "{\n    int[]\
    \ index;\n    int[] sum;\n    int[] sorted;\n    long[] result;\n    int i, j;\n\
    \    result = new long[nums.length];\n    if (nums.length == 0)\n        return\
    \ result;\n    index = new int[nums.length];\n    sum = new int[nums.length];\n\
    \    sorted = new int[nums.length];\n    for (i = 0; i < nums.length; i++)\n \
    \   {\n        sum[i] = 0;\n        if (nums[i] < 0)\n            index[i] = abs(nums[i]);\n\
    \        else\n            index[i] = nums[i];\n        while (index[i] != 0)\n\
    \        {\n            sum[i] += index[i] % 10;\n            index[i] /= 10;\n\
    \        }\n        sorted[i] = sum[i];\n    }\n    sort(sorted);\n    for (i\
    \ = 0; i < nums.length; i++)\n    {\n        for (j = 0; j < nums.length; j++)\n\
    \        {\n            if (sorted[i] == sum[j])\n            {\n            \
    \    result[i] = nums[j];\n                sum[j] = -1;\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    // Write your\
    \ solution here\n    return nums.sort!((x, y) => {\n        int xSum = x.digits().sum.to!int;\n\
    \        int ySum = y.digits().sum.to!int;\n        return xSum == ySum ? x >\
    \ y : xSum > ySum;\n    });\n}", "{\n    nums.sort!((n1, n2) => sumDigits(n1)\
    \ > sumDigits(n2) || \n                           (sumDigits(n1) == sumDigits(n2)\
    \ && nums.indexOf(n1) > nums.indexOf(n2))\n               );\n    return nums;\n\
    }\nlong sumDigits(long n)\n{\n    long sum = 0;\n    foreach(n; n.to!string)\n\
    \    {\n        if(n.to!char.isDigit)\n            sum += n.to!char.to!int - '0'.to!int;\n\
    \    }\n    return sum;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
