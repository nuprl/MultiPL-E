name: HumanEval_99_closest_integer
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
  \ takes a value (string) representing a number\n    and returns the closest integer\
  \ to it. If the number is equidistant\n    from two integers, round it away from\
  \ zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"\
  15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given\
  \ number is equidistant\n    from two integers, the one you should return is the\
  \ one that is the\n    farthest from zero. For example closest_integer(\"14.5\"\
  ) should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n\
  */\nlong closest_integer(string value) \n"
tests: "unittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"\
  10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"\
  -15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"\
  0\") == 0L);\n}\nvoid main(){}"
completions: ["{ \n    if (value.canParse!long())\n        return cast(long)value.to!double();",
  "{ \n    return value.to!long;\n}", "{\n    long result = 0;\n    double d = to!double(value);\n\
    \    double integral = 0;\n    double fractional = 0;\n    if (d >= 0) {\n   \
    \     fractional = modf(d, &integral);\n        if (fractional >= 0.5) {\n   \
    \         result = integral + 1;\n        } else {\n            result = integral;\n\
    \        }\n    } else {\n        fractional = modf(-d, &integral);\n        if\
    \ (fractional >= 0.5) {\n            result = -integral - 1;\n        } else {\n\
    \            result = -integral;\n        }\n    }\n    return result;\n}\n/*\n\
    \    Create a function that takes a string of two words separated by a space\n\
    \    and returns the string reversed. You can assume that the input will always\n\
    \    be a string of two words.", "{\n    return cast(int)round(to!double(value));\n\
    }", "{\n    real x = to!real(value);\n    real intpart;\n    real fracpart = modf(x,\
    \ &intpart);\n    long n = cast(long)intpart;\n    if (fracpart == -0.5 || fracpart\
    \ == 0.5) {\n        return x < 0 ? n - 1 : n + 1;\n    }\n    return fracpart\
    \ < 0 ? n - 1 : n + 1;\n}", "{\n    // this is an example, since floating point\
    \ operations\n    // are not always accurate and may be slightly wrong\n    //\
    \ or raise exceptions, you might want to round\n    // differently, say just always\
    \ round up.\n    double d = to!double(value);\n    return round(d);\n}", "{\n\
    \    auto l = to!long(value);\n    auto d = to!double(value);\n    // auto l =\
    \ to!(long)(value);\n    // auto d = to!(double)(value);\n    return l + (l >\
    \ d ? 0 : (l < d ? 1 : l.sign));\n}", "{\n\tauto x = to!double(value);\n\t\n\t\
    if(abs(x - round(x)) == 0.5)\n\t{\n\t\treturn x < 0 ? round(x)-1 : round(x)+1;\n\
    \t}\n\telse\n\t{\n\t\treturn round(x);\n\t}\n}", "{\n    long close=0;\n    if(is_integer(value)\
    \ || is_floating_point(value))\n    {\n        if(to!long(value)==to!long(value.chomp))\n\
    \        {\n            close=to!long(value);\n        }\n        else\n     \
    \   {\n            double value_=to!double(value);\n            long floor=cast(long)value_;\n\
    \            long ceil=floor+1;\n            if(abs(floor-value_)==abs(ceil-value_))\n\
    \            {\n                if(floor<0)\n                {\n             \
    \       close=floor;\n                }\n                else\n              \
    \  {\n                    close=ceil;\n                }\n            }\n    \
    \        else if(abs(floor-value_)<abs(ceil-value_))\n            {\n        \
    \        close=floor;\n            }\n            else\n            {\n      \
    \          close=ceil;\n            }\n        }\n    }\n    return close;\n}",
  "{\n    return round(to!double(value));\n}", "{\n  static import std.algorithm.searching\
    \ : roundTo;\n  return value.roundTo!\"0.1\".front;\n}", "{\n    return floor(to!real(value));\n\
    }", "{\n    return value.to!long.round;\n}\n/*\n    Create a function that takes\
    \ a value (string) representing a number\n    and returns the largest integer\
    \ that is less than or equal to it.", "{ \n    return value.to!long;\n}", "{\n\
    \    if (value.length > 1 && value[0] == '-') \n    {\n        return -closest_integer(value[1\
    \ .. $]);\n    }\n    auto d = to!double(value);\n    auto i = cast(long) d;\n\
    \    auto diff = d - i;\n    if (diff > 0.5) \n    {\n        return i + 1;\n\
    \    }\n    if (diff < -0.5) \n    {\n        return i - 1;\n    }\n    return\
    \ i;\n}", "{\n    long lvalue = to!long(value);\n    if(is(typeof(lvalue)))\n\
    \        return lvalue;\n    double dvalue = to!double(value);\n    if(dvalue\
    \ < 0)\n        return to!long(value.stripSuffix(\"0\").stripSuffix(\".\").to!long\
    \ - 1);\n    return to!long(value.stripSuffix(\"0\").stripSuffix(\".\").to!long\
    \ + 1);\n}", "{\n    long result = to!long(value);\n    double epsilon = abs(to!double(value)\
    \ - to!double(result));\n    long test = result + 1;\n    double epsilon2 = abs(to!double(value)\
    \ - to!double(test));\n    if (epsilon2 < epsilon) {\n        result = test;\n\
    \    }\n    return result;\n}", "{\n    // long round(real d)\n    // Returns\
    \ the closest integral value to d that is within the range\n    // of type long.\
    \ If there are two such values, the one that is even\n    // is returned. If d\
    \ is outside the range of type long, the result\n    // is undefined.\n    //\n\
    \    // The result is always exact. The rounding mode is always\n    // RoundTowardZero,\
    \ which is the same as truncation.\n    //\n    // If d is NaN, the result is\
    \ undefined.\n    //\n    // long round(real d, int digits)\n    // Returns the\
    \ result of rounding the value d to the specified number\n    // of digits to\
    \ the right of the decimal point.\n    //\n    // The rounding mode is always\
    \ RoundTowardZero, which is the same as\n    // truncation. If digits is larger\
    \ than the number of digits to the\n    // right of the decimal point in d, then\
    \ d is truncated to 0.\n    //\n    // If d is NaN, the result is undefined.\n\
    \    //\n    // long round(real d, RoundingMode mode)\n    // Returns the closest\
    \ integral value to d, but does so in a way that\n    // conforms to the specified\
    \ rounding mode.\n    //\n    // If d is NaN, the result is undefined.\n    //\n\
    \    // long round(real d, int digits, RoundingMode mode)\n    // Returns the\
    \ result of rounding the value d to the specified number\n    // of digits to\
    \ the right of the decimal point, in a way that conforms\n    // to the specified\
    \ rounding mode.\n    //\n    // If d is NaN, the result is undefined.\n    //\n\
    \    // RoundingMode defines the following constants:\n    //     RoundingMode.RoundNearestTiesToEven\n\
    \    //     RoundingMode.RoundNearestTiesToAway\n    //     RoundingMode.RoundTowardPositive\n\
    \    //     RoundingMode.RoundTowardNegative\n    //     RoundingMode.RoundTowardZero\n\
    \    //     RoundingMode.RoundFromZero\n    //\n    return round(to!real(value));\n\
    }\n/*\n    Create a function that takes a string and returns the string with\n\
    \    all vowels removed.", "{\n    //The following is my solution.\n    long closest;\n\
    \    value = value.strip;\n    closest = to!long(value);\n    foreach(i; value)\n\
    \    {\n        if(value[i] == '.')\n        {\n            if(closest >= 0)\n\
    \            {\n                if(value[i+1] >= '5')\n                {\n   \
    \                 closest++;\n                }\n            }\n            else\n\
    \            {\n                if(value[i+1] >= '5')\n                {\n   \
    \                 closest--;\n                }\n            }\n        }\n  \
    \  }\n    return closest;\n}", "{\n    double v = to!double(value);\n    return\
    \ cast(long) floor(v + sign(v) * 0.5);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
