name: HumanEval_132_is_nested
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = Stack!(char)();\n    for (char c; c = string.popFront();)\n\
    \    {\n        if (c == '[')\n        {\n            stack.push(c);\n       \
    \ }\n        else if (c == ']')\n        {\n            if (stack.empty)\n   \
    \         {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return !stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqducev2v.d(25): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\n/tmp/tmpqducev2v.d(26): Error: assignment cannot be\
    \ used as a condition, perhaps `==` was meant?\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqducev2v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    size_t brackets_count = 0;\n    size_t nested_brackets_count\
    \ = 0;\n    foreach(ch; string)\n    {\n        if(ch == '[')\n        {\n   \
    \         ++brackets_count;\n            ++nested_brackets_count;\n        }\n\
    \        else if(ch == ']')\n        {\n            if(brackets_count != 0)\n\
    \            {\n                --brackets_count;\n                if(nested_brackets_count\
    \ != 0)\n                {\n                    --nested_brackets_count;\n   \
    \             }\n            }\n            else\n            {\n            \
    \    return false;\n            }\n        }\n    }\n    return nested_brackets_count\
    \ != 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwm05ex_e.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f5d]\\n??:? void tmpwm05ex_e.__unittest_L52_C1()\
    \ [0x427aba]\\n??:? void tmpwm05ex_e.__modtest() [0x427ce0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430158]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aaed]\\n??:? runModuleUnitTests [0x42ba59]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428333]\\n??:? _d_run_main [0x42829e]\\n??:? main [0x427cf3]\\\
    n??:? __libc_start_main [0x2d794554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto s = string.representation;\n    auto len = s.length;\n\
    \    auto left = 0;\n    auto right = 0;\n    foreach(i; 0..len) {\n        if\
    \ (s[i] == '[') {\n            left += 1;\n        }\n        else if (s[i] ==\
    \ ']') {\n            right += 1;\n        }\n        if (right > left) {\n  \
    \          return false;\n        }\n    }\n    return left == right && left >\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp51xjddtq.d(25): Error: no property `representation` for type\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp51xjddtq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int c_left = 0;\n    int c_right = 0;\n    foreach(char elem;\
    \ string)\n    {\n        if(elem == '[')\n        {\n            c_left++;\n\
    \        }\n        else if(elem == ']')\n        {\n            c_right++;\n\
    \        }\n        if(c_right > c_left)\n        {\n            return false;\n\
    \        }\n    }\n    return c_left == c_right && c_left != 0;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7lyz5qkx.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f5d]\\n??:? void tmp7lyz5qkx.__unittest_L44_C1()\
    \ [0x427b08]\\n??:? void tmp7lyz5qkx.__modtest() [0x427cdc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430158]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aaed]\\n??:? runModuleUnitTests [0x42ba59]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428333]\\n??:? _d_run_main [0x42829e]\\n??:? main [0x427cef]\\\
    n??:? __libc_start_main [0x91282554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n\tint left_count = 0;\n\tint right_count = 0;\n\tfor (int i = 0;\
    \ i < string.length; i++)\n\t{\n\t\tif (string[i] == '[')\n\t\t{\n\t\t\tleft_count++;\n\
    \t\t}\n\t\telse if (string[i] == ']')\n\t\t{\n\t\t\tright_count++;\n\t\t}\n\t\t\
    if (right_count > left_count)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxzmmy9qk.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f6d]\\n??:? void tmpxzmmy9qk.__unittest_L44_C1()\
    \ [0x427b1c]\\n??:? void tmpxzmmy9qk.__modtest() [0x427cf0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd07]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab9a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd2d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcb9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab71]\\n??:? runModuleUnitTests [0x42badd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428430]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283b7]\\n??:? _d_run_main [0x428322]\\n??:? main [0x427d03]\\\
    n??:? __libc_start_main [0x479a2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // if string does not contain square brackets return false\n\
    \    if (string.count('[') != string.count(']'))\n        return false;\n    else\
    \ \n    {\n        immutable Stack!string open_brackets;\n        foreach (character;\
    \ string)\n        {\n            if (character == '[')\n                open_brackets.push(character);\n\
    \            else if (character == ']')\n            {\n                if (open_brackets.isEmpty())\n\
    \                    return false;\n                else\n                   \
    \ open_brackets.pop();\n            }\n        }\n        return true;\n    }\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptu4fbpbj.d(26): Error: no property `count` for type `string`\\\
    n/tmp/tmptu4fbpbj.d(26): Error: no property `count` for type `string`\\n/tmp/tmptu4fbpbj.d(30):\
    \ Error: template instance `Stack!string` template `Stack` is not defined\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptu4fbpbj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto sequence = new bool[string.length];\n    bool open_bracket;\n\
    \    bool close_bracket;\n    bool bracket_pair = false;\n    size_t pos;\n  \
    \  int open_count = 0;\n    int close_count = 0;\n    for (size_t i = 0; i < string.length;\
    \ i++) {\n        if (string[i] == '[') {\n            open_bracket = true;\n\
    \            open_count++;\n        } else {\n            close_bracket = true;\n\
    \            close_count++;\n        }\n        if (open_bracket && close_bracket)\
    \ {\n            bracket_pair = true;\n            open_bracket = false;\n   \
    \         close_bracket = false;\n        }\n        sequence[i] = bracket_pair;\n\
    \    }\n    if (open_count == close_count) {\n        return true;\n    } else\
    \ {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2w759jhf.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428115]\\n??:? void tmp2w759jhf.__unittest_L53_C1()\
    \ [0x427cc4]\\n??:? void tmp2w759jhf.__modtest() [0x427e98]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bf4b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42adde]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430069]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430518]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fff5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42adb5]\\n??:? runModuleUnitTests [0x42bd21]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4285d8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42855f]\\n??:? _d_run_main [0x4284ca]\\n??:? main [0x427eab]\\\
    n??:? __libc_start_main [0x5992e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    /*\n        For each ']' character, find the first matching\
    \ '[' that appears before it. \n        If no match can be found, return false.\n\
    \        If a match can be found, remove the '[', ']' pair from the string and\
    \ repeat this process until there are no pairs.\n        If only one bracket remains,\
    \ return false.\n        Return true.\n    */\n    string pairs = \"[]\";\n  \
    \  string::range r;\n    while ( (r = search(string, pairs) ) != string.empty)\n\
    \    {\n        // Make sure the pair is not just []\n        if (r.front == r.back)\n\
    \        {\n            // Find the matching '[' character that goes with the\
    \ ']'\n            auto idx = string.rfind(r.front, r.back);\n            if (idx\
    \ == string.notfound)\n            {\n                return false;\n        \
    \    }\n            else\n            {\n                // Remove the pair from\
    \ the string\n                string = erase(string, idx, r.back);\n         \
    \   }\n        }\n        else\n        {\n            return false;\n       \
    \ }\n    }\n    // If the string is not empty, it is not nested\n    return string.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyhrlvb7x.d(33): Error: use `.` for member lookup, not `::`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyhrlvb7x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto brackets = std.algorithm.filter!(i => i == '[' || i ==\
    \ ']') (string);\n    int count = 0;\n    bool open = false;\n    for (auto b\
    \ : brackets) {\n        if (b == '[') {\n            if (open)\n            \
    \    return false;\n            open = true;\n            count++;\n        }\
    \ else {\n            if (!open)\n                return false;\n            open\
    \ = false;\n            count--;\n        }\n    }\n    return count == 0;\n}\n\
    unittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptsotj6zk.d(28): Error: no identifier for declarator `b`\\n/tmp/tmptsotj6zk.d(28):\
    \ Error: expression expected, not `:`\\n/tmp/tmptsotj6zk.d(28): Error: found `brackets`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmptsotj6zk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int length = string.length;\n    int i = 0;\n    int nestCount\
    \ = 0;\n    while (i < length)\n    {\n        // open bracket found\n       \
    \ if (string[i] == '[')\n        {\n            nestCount++;\n        }\n    \
    \    // closed bracket found\n        else if (string[i] == ']')\n        {\n\
    \            nestCount--;\n        }\n        // if nest count ever drops below\
    \ 0, there is no possible way to have a nesting\n        if (nestCount < 0)\n\
    \        {\n            return false;\n        }\n        i++;\n    }\n    //\
    \ if nest count drops back to 0 at the end, a nesting exists\n    if (nestCount\
    \ == 0)\n    {\n        return true;\n    }\n    // if nest count doesn't drop\
    \ back to 0, there is an imbalance of open/closed brackets\n    else\n    {\n\
    \        return false;\n    }\n    \n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvuom3z9r.d(25): Error: cannot implicitly convert expression `string.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpvuom3z9r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto remaining_brackets = string.filter!(ch => ch == '[' ||\
    \ ch == ']');\n    auto stack = Stack!(char)();\n    foreach (ch; remaining_brackets)\
    \ {\n        if (ch == '[') {\n            stack.push(ch);\n        } else {\n\
    \            if (stack.empty) {\n                return false;\n            }\n\
    \            stack.pop();\n        }\n    }\n    return !stack.empty;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgz6gqnl2.d(25): Error: no property `filter` for type `string`\\\
    n/tmp/tmpgz6gqnl2.d(26): Error: template instance `Stack!char` template `Stack`\
    \ is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgz6gqnl2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int open_count = 0;\n    int nest_count = 0;\n    bool first_open\
    \ = false;\n    bool first_nest = false;\n    auto a = new int[n];\n    foreach(ch;\
    \ string)\n    {\n        if(ch == '[')\n        {\n            if(first_open\
    \ == false)\n            {\n                open_count++;\n                first_open\
    \ = true;\n            }\n            if(nest_count > 0)\n            {\n    \
    \            return true;\n            }\n            else\n            {\n  \
    \              nest_count = 0;\n            }\n        }\n        else if(ch ==\
    \ ']')\n        {\n            if(first_nest == false)\n            {\n      \
    \          nest_count++;\n                first_nest = true;\n            }\n\
    \            if(open_count > 0)\n            {\n                return true;\n\
    \            }\n            else\n            {\n                open_count =\
    \ 0;\n            }\n        }\n    }\n    return false;\n}\nunittest\n{\n   \
    \ alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n \
    \   assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\"\
    ) == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph19gy9fq.d(29): Error: undefined identifier `n`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph19gy9fq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool result = false;\n    enum dir { left, right } ;\n    struct\
    \ Bt {\n        dir direction;\n        string.RandomAccessRange.Tuple!(string,\
    \ int, dir) range;\n    }\n    auto ranges = map!(a => tuple(a, a[0], a[0] ==\
    \ '[' ? dir.left : dir.right))(string.split(\"\"));\n    Stack!Bt stack;\n   \
    \ for (auto r ; ranges) {\n        if (stack.empty || r[2] == dir.left) {\n  \
    \          stack.push(Bt(dir.left, r));\n        } else {\n            if (stack.top.direction\
    \ == dir.left) {\n                stack.pop();\n            } else {\n       \
    \         stack.push(Bt(dir.right, r));\n            }\n        }\n    }\n   \
    \ if (stack.empty) {\n        result = true;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ezrug6s.d(26): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\n/tmp/tmp3ezrug6s.d(33): Error: no identifier for declarator `r`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ezrug6s.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool is_nested = false;\n    if (string.length != 0) \n   \
    \ {\n        bool is_open = false;\n        int first_match = -1;\n        int\
    \ last_match = -1;\n        int num_open = 0;\n        int num_close = 0;\n  \
    \      for (int i = 0; i < string.length; i++) \n        {\n            if (string[i]\
    \ == '[') \n            {\n                num_open++;\n                if (!is_open)\
    \ \n                {\n                    is_open = true;\n                 \
    \   first_match = i;\n                }\n            }\n            else if (string[i]\
    \ == ']') \n            {\n                num_close++;\n                if (is_open)\
    \ \n                {\n                    is_open = false;\n                \
    \    last_match = i;\n                }\n            }\n        }\n        if\
    \ (num_open == num_close && (last_match > first_match)) \n        {\n        \
    \    is_nested = true;\n        }\n    }\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9gpqcu53.d(67): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427fb5]\\n??:? void tmp9gpqcu53.__unittest_L61_C1()\
    \ [0x427b64]\\n??:? void tmp9gpqcu53.__modtest() [0x427d38]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd4f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abe2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430224]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42abb9]\\n??:? runModuleUnitTests [0x42bb25]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428478]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283ff]\\n??:? _d_run_main [0x42836a]\\n??:? main [0x427d4b]\\\
    n??:? __libc_start_main [0xe801b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = Stack!int([]);\n    foreach(character; string)\n\
    \    {\n        if(character == '[')\n        {\n            stack.push(character);\n\
    \        }\n        else if(character == ']')\n        {\n            if(stack.empty)\n\
    \            {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiyqc24rp.d(25): Error: template instance `Stack!int` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpiyqc24rp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool isNested = false;\n    int subNested = 0;\n    int prevNested\
    \ = 0;\n    int maxNested = 0;\n    foreach(c; string)\n    {\n        if(c ==\
    \ '[')\n        {\n            subNested++;\n            maxNested = max(maxNested,\
    \ subNested);\n        }\n        else if(c == ']')\n        {\n            subNested--;\n\
    \        }\n        if(subNested < 0)\n        {\n            return false;\n\
    \        }\n        else if(prevNested > 0 && subNested == 0)\n        {\n   \
    \         prevNested = maxNested;\n            maxNested = 0;\n        }\n   \
    \     else if(prevNested > 0 && maxNested > 0)\n        {\n            isNested\
    \ = true;\n        }\n    }\n    return (subNested == 0 && isNested);\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpau2gfh80.d(34): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpau2gfh80.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n\tif (string.length < 2) return false;\nunittest\n{\n    alias\
    \ candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu308urqf.d(26): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu308urqf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9fx_3a4i.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ecd]\\n??:? void tmp9fx_3a4i.__unittest_L27_C1()\
    \ [0x427a4f]\\n??:? void tmp9fx_3a4i.__modtest() [0x427c4c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bbf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc19]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4300c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fba5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa5d]\\n??:? runModuleUnitTests [0x42b9c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42831c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282a3]\\n??:? _d_run_main [0x42820e]\\n??:? main [0x427c5f]\\\
    n??:? __libc_start_main [0xa03dd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Keeps track of the nesting level\n    // Should never be\
    \ more than 1\n    int level = 0;\n    foreach(c; string) {\n        level +=\
    \ c == '[' ? 1 : -1;\n        if(level < 0) return false;\n    }\n    return level\
    \ == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprxwldcrj.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmprxwldcrj.__unittest_L34_C1()\
    \ [0x427af8]\\n??:? void tmprxwldcrj.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd6fba554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    Stack!(char) stack;\n    foreach(c; string)\n    {\n      \
    \  if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\n\
    \        {\n            if(stack.empty)\n            {\n                return\
    \ false;\n            }\n            stack.pop();\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyq7h73xn.d(25): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpyq7h73xn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
