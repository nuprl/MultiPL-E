name: HumanEval_122_add_elements
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given a non-empty array\
  \ of integers arr and an integer k, return\n    the sum of the elements with at\
  \ most two digits from the first k elements of arr.\n\n    Example:\n\n    >>> add_elements([111L,\
  \ 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L], 4L)\n    24L\n\n    Constraints:\n      \
  \  1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n*/\nlong add_elements(long[]\
  \ arr, long k) \n"
tests: "unittest\n{\n    alias candidate = add_elements;\n\n    assert(candidate([1L,\
  \ -2L, -3L, 41L, 57L, 76L, 87L, 88L, 99L], 3L) == -4L);\n    assert(candidate([111L,\
  \ 121L, 3L, 4000L, 5L, 6L], 2L) == 0L);\n    assert(candidate([11L, 21L, 3L, 90L,\
  \ 5L, 6L, 7L, 8L, 9L], 4L) == 125L);\n    assert(candidate([111L, 21L, 3L, 4000L,\
  \ 5L, 6L, 7L, 8L, 9L], 4L) == 24L);\n    assert(candidate([1L], 1L) == 1L);\n}\n\
  void main(){}"
completions: ["{\n    auto arr2 = arr[0..$k];", "in\n{\n    assert(arr.length != 0);\n\
    \    assert(1 <= arr.length && arr.length <= 100);\n    assert(1 <= k && k <=\
    \ arr.length);\n    long sum = 0L;\n    long i = 0L;\n    for (; i < k; i += 1L)\n\
    \    {\n        if (arr[i] <= 99L)\n        {\n            sum += arr[i];\n  \
    \      }\n    }\n    return sum;\n}", "{\n    long result = 0L;\n    /* \n   \
    \     Do your magic here!\n    */\n    return result;\n}", "{ \n    const int\
    \ num_to_add = 2;\n    long sum = 0;\n    for (long i = 0; i < k; i++)\n    {\n\
    \        int num_digits = 0;\n        long current_num = arr[i];\n        while\
    \ (current_num > 0)\n        {\n            current_num /= 10;\n            num_digits++;\n\
    \        }\n        if (num_digits <= num_to_add)\n        {\n            sum\
    \ += arr[i];\n        }\n    }\n    return sum;\n}", "{\n    auto len = (int)arr.length;\n\
    \    if (len > 100 || len < 1)\n        return 0;\n    if (k > len || k < 1)\n\
    \        return 0;\n    auto sum = 0L;\n    foreach (i, e; arr)\n    {\n     \
    \   if (i == k)\n            break;\n        if (e <= 99)\n            sum +=\
    \ e;\n    }\n    return sum;\n}", "{\n    // create an alias for 2-byte unsigned\
    \ integer\n    alias uint16 = uint;\n    // as long as k <= 0, do not attempt\
    \ to process\n    if (k <= 0) return 0;\n    // set the starting sum to 0\n  \
    \  long sum = 0;\n    // iterate over the first k elements\n    foreach (i, element;\
    \ arr[0 .. k]) \n    {\n        // if it's less than 10, add to the sum\n    \
    \    if (element < 10) sum += element;\n        // otherwise, if it's less than\
    \ 100 (i.e. is a 2-digit number)\n        else if (element < 100) \n        {\n\
    \            // if it's not divisible by 10 and the remainder is less than 10,\
    \ add to the sum\n            if (element % 10 != 0 && element % 10 < 10) sum\
    \ += element;\n        }\n    }\n    // return the sum\n    return sum;\n}", "{\n\
    \    long result = 0L;\n    int k_int = to!int(k);\n    for (int i = 0; i < k_int;\
    \ i++) \n    {\n        if (arr[i] < 100L) \n        {\n            result +=\
    \ arr[i];\n        }\n    }\n    return result;\n}", "{\n    long total = 0L;\n\
    \    foreach(index, elem; arr[0..k]) \n    {\n        if (elem < 100L) \n    \
    \    {\n            total += elem;\n        }\n    }\n    return total;\n}", "in\
    \ \n{\n    import std.math : max;\n    import std.typecons : tuple;\n    import\
    \ std.range : take, enumerate;\n    import std.array : array;\n    import std.algorithm\
    \ : count;\n    import std.algorithm : map;\n    import std.conv : to;\n    import\
    \ std.algorithm : filter;\n    import std.algorithm : sum;\n    import std.range\
    \ : retro;\n    import std.typecons : tuple;\n    import std.conv : to;\n    import\
    \ std.algorithm : count;\n    import std.array : array;\n    import std.range\
    \ : take;\n    import std.range : retro;\n    import std.range : retro;\n    import\
    \ std.range : take;\n    import std.algorithm : count;\n    import std.algorithm\
    \ : sum;\n    import std.range : retro;\n    import std.range : take;\n    import\
    \ std.algorithm : map;\n    import std.conv : to;\n    import std.range : take;\n\
    \    import std.range : take;\n    import std.range : take;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.algorithm : map;\n \
    \   import std.algorithm : sum;\n    import std.algorithm : count;\n    import\
    \ std.range : retro;\n    import std.range : take;\n    import std.algorithm :\
    \ sum;\n    import std.algorithm : count;\n    import std.algorithm : count;\n\
    \    import std.range : retro;\n    import std.range : take;\n    import std.range\
    \ : retro;\n    import std.algorithm : map;\n    import std.algorithm : count;\n\
    \    import std.range : retro;\n    import std.algorithm : count;\n    import\
    \ std.range : retro;\n    import std.algorithm : count;\n    import std.range\
    \ : retro;\n    import std.range : take;\n    import std.range : retro;\n    import\
    \ std.range : take;\n    import std.algorithm : map;\n    import std.range : retro;\n\
    \    import std.range : take;\n    import std.range", "{\n    long sum = 0L;\n\
    \    foreach(index, element; arr[0 .. (min(k, arr.length))]) {\n        if (element\
    \ < 100L) {\n            sum += element;\n        }\n    }\n    return sum;\n}",
  "{\n    long total = 0L;\n    foreach(i; 0 .. k)\n    {\n        if(i >= arr.length)\
    \ break;\n        if(arr[i] > 99)\n        {\n            //split the number into\
    \ two digits\n            long[] digits = arr[i].digits(10);\n            long\
    \ newElement = digits[0] * 10 + digits[1];\n            total += newElement;\n\
    \        }\n        else\n        {\n            total += arr[i];\n        }\n\
    \    }\n    return total;\n}\n//TESTS\nunittest\n{\n    assert(add_elements([111L,\
    \ 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L], 4L) == 24L);\n    assert(add_elements([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L], 4L) == 20L);\n    assert(add_elements([11L,\
    \ 22L, 33L, 44L, 55L, 66L, 77L, 88L, 99L], 4L) == 110L);\n    assert(add_elements([111L,\
    \ 222L, 333L, 444L, 555L, 666L, 777L, 888L, 999L], 4L) == 444L);\n    assert(add_elements([],\
    \ 0L) == 0L);\n    assert(add_elements([3L, 21L, 111L, 11L, 22L, 33L, 44L, 55L,\
    \ 66L, 77L, 88L, 99L], 4L) == 47L);\n    assert(add_elements([3L, 21L, 111L, 11L,\
    \ 22L, 33L, 44L, 55L, 66L, 77L, 88L, 99L], 5L) == 57L);\n    assert(add_elements([3L,\
    \ 21L, 111L, 11L, 22L, 33L, 44L, 55L, 66L, 77L, 88L, 99L], 3L) == 37L);\n    assert(add_elements([3L,\
    \ 21L, 111L, 11L, 22L, 33L,", "{\n    import std.array;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.typecons;\n    import std.conv;\n    import\
    \ std.string;\n    import std.math;\n    import std.traits;\n    static assert(arr.length\
    \ >= 1);\n    static assert(k >= 1);\n    static assert(k <= arr.length);\n  \
    \  return arr.take(k).filter!(x => x.to!string.length <= 2).sum;\n}", "{\n   \
    \ long sum = 0L;\n    long[] new_arr = [];\n    foreach(i; 0 .. k)\n    {\n  \
    \      if(arr[i] >= 10L && arr[i] <= 99L)\n        {\n            new_arr ~= arr[i];\n\
    \        }\n    }\n    foreach(i; new_arr)\n    {\n        sum += i;\n    }\n\
    \    return sum;\n}", "{\n    long r = 0L;\n    static immutable size_t two =\
    \ twoDigits;\n    static immutable size_t one = oneDigit;\n    for (int i = 0;\
    \ i < k; i++)\n    {\n        auto x = arr[i];\n        if (x >= 10L && x < 100L)\
    \ r += x;\n        else if (x >= 1L && x < 10L) r += x;\n    }\n    return r;\n\
    }", "{\n    long sum = 0L;\n    foreach(idx, elem; arr[0 .. k])\n    {\n     \
    \   if (elem < 100L)\n        {\n            sum += elem;\n        }\n    }\n\
    \    return sum;\n}", "{\n    int i = 0;\n    long sum = 0;\n    while(i < k &&\
    \ i < arr.length)\n    {\n        if(abs(arr[i]) < 100)\n        {\n         \
    \   sum += arr[i];\n        }\n        i++;\n    }\n    return sum;\n}", "{\n\
    \    long result = 0L;\n    foreach(idx, elem; arr)\n    {\n        if(elem <\
    \ 10)\n        {\n            result += elem;\n        } else if(elem < 100)\n\
    \        {\n            result += elem;\n        }\n    }\n    return result;\n\
    }", "{\n    alias tuple = Tuple!(int, int);\n    long sum = 0;\n    for (; k >\
    \ 0; k--)\n    {\n        int num = arr[k-1];\n        int digits = std.math.log10(num)\
    \ + 1;\n        if (digits <= 2)\n        {\n            sum += num;\n       \
    \ }\n    }\n    return sum;\n}", "{\n    long total = 0L;\n    long[] slice =\
    \ arr[0 .. cast(ulong)k];\n    foreach(ref num; slice)\n    {\n        if(num\
    \ >= 0 && num < 100)\n        {\n            total += num;\n        }\n    }\n\
    \    return total;\n}", "{\n    long ret = 0L;\n    foreach(i; 0..k)\n    {\n\
    \        if(arr[i] < 100L)\n        {\n            ret += arr[i];\n        }\n\
    \    }\n    return ret;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
