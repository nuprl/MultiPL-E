name: HumanEval_122_add_elements
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given a non-empty array\
  \ of integers arr and an integer k, return\n    the sum of the elements with at\
  \ most two digits from the first k elements of arr.\n\n    Example:\n\n    >>> add_elements([111L,\
  \ 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L], 4L)\n    24L\n\n    Constraints:\n      \
  \  1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n*/\nlong add_elements(long[]\
  \ arr, long k) \n"
tests: "unittest\n{\n    alias candidate = add_elements;\n\n    assert(candidate([1L,\
  \ -2L, -3L, 41L, 57L, 76L, 87L, 88L, 99L], 3L) == -4L);\n    assert(candidate([111L,\
  \ 121L, 3L, 4000L, 5L, 6L], 2L) == 0L);\n    assert(candidate([11L, 21L, 3L, 90L,\
  \ 5L, 6L, 7L, 8L, 9L], 4L) == 125L);\n    assert(candidate([111L, 21L, 3L, 4000L,\
  \ 5L, 6L, 7L, 8L, 9L], 4L) == 24L);\n    assert(candidate([1L], 1L) == 1L);\n}\n\
  void main(){}"
completions: ["{\n    auto arr2 = arr[0..$k];", "in\n{\n    assert(arr.length != 0);\n\
    \    assert(1 <= arr.length && arr.length <= 100);\n    assert(1 <= k && k <=\
    \ arr.length);\n    long sum = 0L;\n    long i = 0L;\n    for (; i < k; i += 1L)\n\
    \    {\n        if (arr[i] <= 99L)\n        {\n            sum += arr[i];\n  \
    \      }\n    }\n    return sum;\n}", "{\n    long result = 0L;\n    /* \n   \
    \     Do your magic here!\n    */\n    return result;\n}", "{ \n    const int\
    \ num_to_add = 2;\n    long sum = 0;\n    for (long i = 0; i < k; i++)\n    {\n\
    \        int num_digits = 0;\n        long current_num = arr[i];\n        while\
    \ (current_num > 0)\n        {\n            current_num /= 10;\n            num_digits++;\n\
    \        }\n        if (num_digits <= num_to_add)\n        {\n            sum\
    \ += arr[i];\n        }\n    }\n    return sum;\n}", "{\n    auto len = (int)arr.length;\n\
    \    if (len > 100 || len < 1)\n        return 0;\n    if (k > len || k < 1)\n\
    \        return 0;\n    auto sum = 0L;\n    foreach (i, e; arr)\n    {\n     \
    \   if (i == k)\n            break;\n        if (e <= 99)\n            sum +=\
    \ e;\n    }\n    return sum;\n}", "{\n    // create an alias for 2-byte unsigned\
    \ integer\n    alias uint16 = uint;\n    // as long as k <= 0, do not attempt\
    \ to process\n    if (k <= 0) return 0;\n    // set the starting sum to 0\n  \
    \  long sum = 0;\n    // iterate over the first k elements\n    foreach (i, element;\
    \ arr[0 .. k]) \n    {\n        // if it's less than 10, add to the sum\n    \
    \    if (element < 10) sum += element;\n        // otherwise, if it's less than\
    \ 100 (i.e. is a 2-digit number)\n        else if (element < 100) \n        {\n\
    \            // if it's not divisible by 10 and the remainder is less than 10,\
    \ add to the sum\n            if (element % 10 != 0 && element % 10 < 10) sum\
    \ += element;\n        }\n    }\n    // return the sum\n    return sum;\n}", "{\n\
    \    long result = 0L;\n    int k_int = to!int(k);\n    for (int i = 0; i < k_int;\
    \ i++) \n    {\n        if (arr[i] < 100L) \n        {\n            result +=\
    \ arr[i];\n        }\n    }\n    return result;\n}", "{\n    long total = 0L;\n\
    \    foreach(index, elem; arr[0..k]) \n    {\n        if (elem < 100L) \n    \
    \    {\n            total += elem;\n        }\n    }\n    return total;\n}", "in\
    \ \n{\n    import std.math : max;\n    import std.typecons : tuple;\n    import\
    \ std.range : take, enumerate;\n    import std.array : array;\n    import std.algorithm\
    \ : count;\n    import std.algorithm : map;\n    import std.conv : to;\n    import\
    \ std.algorithm : filter;\n    import std.algorithm : sum;\n    import std.range\
    \ : retro;\n    import std.typecons : tuple;\n    import std.conv : to;\n    import\
    \ std.algorithm : count;\n    import std.array : array;\n    import std.range\
    \ : take;\n    import std.range : retro;\n    import std.range : retro;\n    import\
    \ std.range : take;\n    import std.algorithm : count;\n    import std.algorithm\
    \ : sum;\n    import std.range : retro;\n    import std.range : take;\n    import\
    \ std.algorithm : map;\n    import std.conv : to;\n    import std.range : take;\n\
    \    import std.range : take;\n    import std.range : take;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.algorithm : map;\n \
    \   import std.algorithm : sum;\n    import std.algorithm : count;\n    import\
    \ std.range : retro;\n    import std.range : take;\n    import std.algorithm :\
    \ sum;\n    import std.algorithm : count;\n    import std.algorithm : count;\n\
    \    import std.range : retro;\n    import std.range : take;\n    import std.range\
    \ : retro;\n    import std.algorithm : map;\n    import std.algorithm : count;\n\
    \    import std.range : retro;\n    import std.algorithm : count;\n    import\
    \ std.range : retro;\n    import std.algorithm : count;\n    import std.range\
    \ : retro;\n    import std.range : take;\n    import std.range : retro;\n    import\
    \ std.range : take;\n    import std.algorithm : map;\n    import std.range : retro;\n\
    \    import std.range : take;\n    import std.range", "{\n    long sum = 0L;\n\
    \    foreach(index, element; arr[0 .. (min(k, arr.length))]) {\n        if (element\
    \ < 100L) {\n            sum += element;\n        }\n    }\n    return sum;\n}",
  "{\n    long total = 0L;\n    foreach(i; 0 .. k)\n    {\n        if(i >= arr.length)\
    \ break;\n        if(arr[i] > 99)\n        {\n            //split the number into\
    \ two digits\n            long[] digits = arr[i].digits(10);\n            long\
    \ newElement = digits[0] * 10 + digits[1];\n            total += newElement;\n\
    \        }\n        else\n        {\n            total += arr[i];\n        }\n\
    \    }\n    return total;\n}\n//TESTS\nunittest\n{\n    assert(add_elements([111L,\
    \ 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L], 4L) == 24L);\n    assert(add_elements([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L], 4L) == 20L);\n    assert(add_elements([11L,\
    \ 22L, 33L, 44L, 55L, 66L, 77L, 88L, 99L], 4L) == 110L);\n    assert(add_elements([111L,\
    \ 222L, 333L, 444L, 555L, 666L, 777L, 888L, 999L], 4L) == 444L);\n    assert(add_elements([],\
    \ 0L) == 0L);\n    assert(add_elements([3L, 21L, 111L, 11L, 22L, 33L, 44L, 55L,\
    \ 66L, 77L, 88L, 99L], 4L) == 47L);\n    assert(add_elements([3L, 21L, 111L, 11L,\
    \ 22L, 33L, 44L, 55L, 66L, 77L, 88L, 99L], 5L) == 57L);\n    assert(add_elements([3L,\
    \ 21L, 111L, 11L, 22L, 33L, 44L, 55L, 66L, 77L, 88L, 99L], 3L) == 37L);\n    assert(add_elements([3L,\
    \ 21L, 111L, 11L, 22L, 33L,", "{\n    import std.array;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.typecons;\n    import std.conv;\n    import\
    \ std.string;\n    import std.math;\n    import std.traits;\n    static assert(arr.length\
    \ >= 1);\n    static assert(k >= 1);\n    static assert(k <= arr.length);\n  \
    \  return arr.take(k).filter!(x => x.to!string.length <= 2).sum;\n}", "{\n   \
    \ long sum = 0L;\n    long[] new_arr = [];\n    foreach(i; 0 .. k)\n    {\n  \
    \      if(arr[i] >= 10L && arr[i] <= 99L)\n        {\n            new_arr ~= arr[i];\n\
    \        }\n    }\n    foreach(i; new_arr)\n    {\n        sum += i;\n    }\n\
    \    return sum;\n}", "{\n    long r = 0L;\n    static immutable size_t two =\
    \ twoDigits;\n    static immutable size_t one = oneDigit;\n    for (int i = 0;\
    \ i < k; i++)\n    {\n        auto x = arr[i];\n        if (x >= 10L && x < 100L)\
    \ r += x;\n        else if (x >= 1L && x < 10L) r += x;\n    }\n    return r;\n\
    }", "{\n    long sum = 0L;\n    foreach(idx, elem; arr[0 .. k])\n    {\n     \
    \   if (elem < 100L)\n        {\n            sum += elem;\n        }\n    }\n\
    \    return sum;\n}", "{\n    int i = 0;\n    long sum = 0;\n    while(i < k &&\
    \ i < arr.length)\n    {\n        if(abs(arr[i]) < 100)\n        {\n         \
    \   sum += arr[i];\n        }\n        i++;\n    }\n    return sum;\n}", "{\n\
    \    long result = 0L;\n    foreach(idx, elem; arr)\n    {\n        if(elem <\
    \ 10)\n        {\n            result += elem;\n        } else if(elem < 100)\n\
    \        {\n            result += elem;\n        }\n    }\n    return result;\n\
    }", "{\n    alias tuple = Tuple!(int, int);\n    long sum = 0;\n    for (; k >\
    \ 0; k--)\n    {\n        int num = arr[k-1];\n        int digits = std.math.log10(num)\
    \ + 1;\n        if (digits <= 2)\n        {\n            sum += num;\n       \
    \ }\n    }\n    return sum;\n}", "{\n    long total = 0L;\n    long[] slice =\
    \ arr[0 .. cast(ulong)k];\n    foreach(ref num; slice)\n    {\n        if(num\
    \ >= 0 && num < 100)\n        {\n            total += num;\n        }\n    }\n\
    \    return total;\n}", "{\n    long ret = 0L;\n    foreach(i; 0..k)\n    {\n\
    \        if(arr[i] < 100L)\n        {\n            ret += arr[i];\n        }\n\
    \    }\n    return ret;\n}", "{\n    return arr.take(k).filter!(i => i < 100).sum;\n\
    }", "{\n    long count = 0L;\n    long total = 0L;\n    foreach(idx, val; arr)\
    \ {\n        if(val > 99) {\n            continue;\n        } else {\n       \
    \     total += val;\n            count++;\n        }\n        if(count == k) {\n\
    \            break;\n        }\n    }\n    return total;\n}", "{\n    long[] input\
    \ = arr.dup[0 .. k];\n    long sum = 0;\n    foreach(num; input)\n    {\n    \
    \    if(num < 10)\n        {\n            sum += num;\n        }\n        else\
    \ if(num < 100)\n        {\n            sum += num;\n        }\n    }\n    return\
    \ sum;\n}", "{\n    long sum = 0L;\n    foreach(num; arr[0 .. k])\n    {\n   \
    \     if (num >= 0 && num < 100)\n        {\n            sum += num;\n       \
    \ }\n    }\n    return sum;\n}", "{\n    assert(k >= 1L && k <= arr.length);\n\
    \    return arr.take(k).filter!(a => a >= 1L && a <= 99L).sum;\n}", "{\n    return\
    \ arr.take(cast(size_t)k).filter!((el) => el.length < 3L).sum;\n}\n//BEGIN_MAIN\n\
    //END_MAIN", "{\n    return arr.take(k).map!((e) => \n    {\n        static if\
    \ (e < 100)\n            return e;\n        else\n            return e % 100;\n\
    \    }).sum;\n}", "{\n    long sum = 0L;\n    foreach(item; take(arr, k)) \n \
    \   {\n        // add the item if it is less than 100 and\n        // has 2 or\
    \ less digits\n        if(item < 100L && item > 9L) \n        {\n            sum\
    \ += item;\n        }\n    }\n    return sum;\n}", "{\n    import std.algorithm.iteration\
    \ : filter, map;\n    return arr[0..k].filter!(x => x < 100).map!(x => x.to!int).sum;\n\
    }", "{\n    return reduce!((a, b) => a + b[0] * pow(10, b[1]))(\n        enumerate(arr[0\
    \ .. k])\n        .filter!(a => a[0] < 100)\n        .map!(a => a[1])\n    );\n\
    }", "{\n    long sum = 0L;\n    long two_digit_count = 0L;\n    long  pos = 0L;\n\
    \    long len = arr.length;\n    while(pos < k && two_digit_count < 2L)\n    {\n\
    \        if(arr[pos] > 9L && arr[pos] < 100L)\n        {\n            sum += arr[pos];\n\
    \            two_digit_count++;\n        }\n        pos++;\n    }\n    return\
    \ sum;\n}", "{\n    long count = 0L;\n    foreach(index, arr) {\n        if (index\
    \ < k)\n        {\n            if (arr[index] > 9 && arr[index] < 100)\n     \
    \       {\n                count += arr[index];\n            }\n        }\n  \
    \  }\n    return count;\n}", "{\n    long sum = 0L;\n    long i = 0L;\n    for\
    \ (; i < k; i++) \n    {\n        if (arr[i] >= 1L && arr[i] <= 99L) \n      \
    \  {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}", "in {\n\
    \    assert(k >= 1L);\n    assert(k <= arr.length);\n}\nout (result) {\n    assert(result\
    \ <= arr.length);\n}\n{\n    long sum = 0L;\n    long i = 0L;\n    while (i <\
    \ k) {\n        if (arr[i] >= 100L) {\n            sum += (arr[i] / 100L) * 100L;\n\
    \        } else {\n            sum += arr[i];\n        }\n        i++;\n    }\n\
    \    return sum;\n}", "{\n    return arr.take(k).filter!(x => x < 100).sum;\n}",
  "in\n{\n    assert(k >= 1);\n    assert(k <= arr.length);\n    return arr.take(k).filter!(a\
    \ => a < 100).sum;\n}", "in\n{\n    import std.algorithm : iota, take, map, sum;\n\
    \    import std.range : isRandomAccessRange;\n    import std.typecons : tuple;\n\
    \    static if (isRandomAccessRange!(typeof(arr)))\n    {\n        auto result\
    \ = iota(0L, k)\n        .map!(i => arr[i] < 100 ? arr[i] : 0L)\n        .sum;\n\
    \        return result;\n    }\n    else\n    {\n        enum arrSize = arr.size();\n\
    \        assert(k <= arrSize);\n        auto firstK = arr.take(arrSize);\n   \
    \     auto result = firstK\n        .map!(i => i < 100 ? i : 0L)\n        .sum;\n\
    \        return result;\n    }\n}", "{\n    // Write your code here\n    auto\
    \ res = 0L;\n    auto len = k < arr.length ? k : arr.length;\n    for (auto i\
    \ = 0; i < len; i++)\n    {\n        auto num = arr[i];\n        if (num / 10\
    \ == 0 || num / 100 == 0)\n        {\n            res += num;\n        }\n   \
    \ }\n    return res;\n}", "in \n{\n    assert(arr.length > 0);\n    assert(arr.length\
    \ <= 100);\n    assert(k > 0);\n    assert(k <= arr.length);\n    return arr.take(k).filter!(x\
    \ => x < 100).sum;\n}", "{\n    long result = 0L;\n    long[] res_arr = new long[k];\n\
    \    foreach(i; 0 .. k)\n    {\n        long num = arr[i];\n        long two_digs\
    \ = (num / 100L);\n        if(two_digs == 0L)\n        {\n            res_arr[i]\
    \ = num;\n        }\n        else\n        {\n            res_arr[i] = two_digs;\n\
    \        }\n    }\n    foreach(elem; res_arr)\n    {\n        result += elem;\n\
    \    }\n    return result;\n}", "{\n    long elems = 0L;\n    long x = 0L;\n \
    \   long sum = 0L;\n    long product = 0L;\n    long zero = 0L;\n    long temp\
    \ = 0L;\n    while (x < k)\n    {\n        product = arr[x] / 10L;\n        zero\
    \ = product * 10L;\n        temp = arr[x] - zero;\n        if (product == 0L)\n\
    \        {\n            elems = elems + 1L;\n        }\n        else\n       \
    \ {\n            if (temp == 0L)\n            {\n                elems = elems\
    \ + 2L;\n            }\n            else\n            {\n                elems\
    \ = elems + 1L;\n            }\n        }\n        if (elems > 3L)\n        {\n\
    \            elems = 3L;\n        }\n        if (elems == 3L)\n        {\n   \
    \         sum = sum + arr[x];\n        }\n        x = x + 1L;\n    }\n    return\
    \ sum;\n}", "{\n    auto (t1, t2) = tuple(arr.take(k).filter!(i => i >= 10 &&\
    \ i < 100).sum, \n                    arr.take(k).filter!(i => i < 10).sum);\n\
    \    return t1 + t2;\n}", "{\n    long sum = 0L;\n    long temp = 0L;\n    long\
    \ count = 0L;\n    long i = 0L;\n    while (count < k)\n    {\n        temp =\
    \ arr[i];\n        while (temp >= 10L)\n        {\n            temp /= 10L;\n\
    \        }\n        if (temp < 3L)\n        {\n            sum += arr[i];\n  \
    \          count++;\n        }\n        i++;\n    }\n    return sum;\n}", "{\n\
    \    return accumulate(takeExactly(arr, k), (total, curr) => \n    {\n       \
    \ long n = curr;\n        long tens = n / 10;\n        long ones = n % 10;\n \
    \       return tens <= 0 ? total + n : total + ones;\n    });\n}", "{\n    long[]\
    \ arr2 = map!(a => \n            (a > 100 ? 100L : a)\n        )(arr[0 .. k]);\n\
    \    return reduce!((a, b) => a + b)(arr2);\n}", "{\n    long sum = 0L;\n    long\
    \ dig, tmp;\n    for (long i = 0; i < k; i++) {\n        tmp = arr[i];\n     \
    \   dig = 1L;\n        while (tmp >= 10L) {\n            tmp /= 10L;\n       \
    \     dig++;\n        }\n        if (dig <= 2L) {\n            sum += arr[i];\n\
    \        }\n    }\n    return sum;\n}", "{\n    // Initialize sum to 0\n    long\
    \ sum = 0L;\n    // Loop over each value in arr[0..k-1]\n    foreach (idx, val;\
    \ arr[0..k])\n    {\n        // If val has at most 2 digits\n        if (val <\
    \ 100L)\n        {\n            // Add val to sum\n            sum += val;\n \
    \       }\n    }\n    // Return sum\n    return sum;\n}", "{\n    long[] temp\
    \ = new long[$];\n    foreach(i; 0..min(arr.length, k))\n    {\n        auto t\
    \ = arr[i].to!string();\n        if(t.length > 2)\n        {\n            if(t.length\
    \ > 3)\n            {\n                temp ~= std.stdio.to!long(t[$-2..$]);\n\
    \            }\n            else\n            {\n                temp ~= std.stdio.to!long(t[$-1..$]);\n\
    \            }\n        }\n        else\n        {\n            temp ~= arr[i];\n\
    \        }\n    }\n    return std.algorithm.reduce!\"a + b\"(temp);\n}", "{\n\
    \    // TODO: implement\n    return k;\n}", "{\n    long[] slice = arr[0..cast(size_t)k];\n\
    \    long sum = 0;\n    foreach(idx, value; slice)\n    {\n        if(value <\
    \ 100)\n        {\n            sum += value;\n        }\n    }\n    return sum;\n\
    }", "{\n    assert(k <= arr.length);\n    long sum = 0L;\n    long[] firstK =\
    \ arr[0 .. k];\n    firstK.filter!(i => i < 100L)().each!(sum +=);\n    return\
    \ sum;\n}", "{\n    /*\n        use std.algorithm.take to get the first k elements\
    \ from arr\n        use std.algorithm.filter to get all values that have 1 or\
    \ 2 digits\n        use std.algorithm.sum to calculate the sum of those values\n\
    \    */\n    return arr.take(k).filter!(value => value < 100).sum;\n}", "{\n \
    \   long output = 0L;\n    long i = 0L;\n    while (i < k)\n    {\n        if\
    \ (arr[i] < 100L)\n        {\n            output += arr[i];\n        }\n     \
    \   i++;\n    }\n    return output;\n}", "{\n    import std.typecons;\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.range;\n    import std.stdio;\n\
    \    import std.string;\n    import std.math;\n    import std.conv;\n    /*\n\
    \        1. we can use std.range.map with a lamda to check each element's\n  \
    \      magnitude and return the appropriate value.\n    */\n    return arr.take(cast(size_t)k).map!((a)\
    \ => a < 100 ? a : 0L).sum;\n}", "in\n{\n    assert(arr.length > 0);\n    assert(arr.length\
    \ <= 100);\n    assert(k <= arr.length);\n    assert(k > 0);\n}\nbody\n{\n   \
    \ long sum = 0;\n    long i = 0;\n    for (i = 0; i < k; i++)\n    {\n       \
    \ if (0 < arr[i] && arr[i] < 100)\n        {\n            sum += arr[i];\n   \
    \     }\n    }\n    return sum;\n}", "{\n    long ret = 0L;\n    for (auto el\
    \ : arr)\n    {\n        if (k == 0L)\n            break;\n        else if (el\
    \ > 9L && el < 100L)\n        {\n            ret += el;\n            k--;\n  \
    \      }\n        else if (el < 10L)\n        {\n            ret += el;\n    \
    \        k--;\n        }\n    }\n    return ret;\n}", "{\n    long result = 0L;\n\
    \    int c = 0;\n    while (c < k)\n    {\n        long x = arr[c];\n        if\
    \ (x < 100L)\n        {\n            result += x;\n        }\n        else\n \
    \       {\n            result += sum(to!(long[])(iota(10L)));\n        }\n   \
    \     c++;\n    }\n    return result;\n}", "{\n    long sum = 0L;\n    foreach(i;\
    \ 0 .. k) \n    {\n        if (arr[i] > 99L)\n            arr[i] = 99L;\n    \
    \    sum += arr[i];\n    }\n    return sum;\n}", "{\n    if (k > arr.length)\n\
    \        k = arr.length;\n    return arr.take(k).filter!(a => a > 9 && a < 100).sum;\n\
    }", "in\n{\n    assert(k >= 1L);\n    assert(k <= arr.length);\n}\nbody\n{\n \
    \   auto k2 = k * 2L;\n    auto count = 0L;\n    auto sum = 0L;\n    foreach (index,\
    \ value; arr)\n    {\n        if (value < 10L)\n        {\n            count++;\n\
    \            sum += value;\n        }\n        else if (value < 100L)\n      \
    \  {\n            count += 2L;\n            sum += value;\n        }\n       \
    \ else\n        {\n            count += 3L;\n            sum += value;\n     \
    \   }\n        if (count >= k2)\n        {\n            return sum;\n        }\n\
    \    }\n    return sum;\n}", "{\n    long[] a = new long[k];\n    foreach(long\
    \ i, immutable long x; arr)\n    {\n        if(x < 100L)\n        {\n        \
    \    if(i < k)\n            {\n                a[i] = x;\n            }\n    \
    \        else\n            {\n                break;\n            }\n        }\n\
    \    }\n    long sum = 0L;\n    foreach(long x; a)\n    {\n        sum += x;\n\
    \    }\n    return sum;\n}\n/*", "{\n    long ret = 0L;\n    foreach(i; 0 .. k)\n\
    \    {\n        if(arr[i] > 99L)\n        {\n            ret += 99L;\n       \
    \ }\n        else\n        {\n            ret += arr[i];\n        }\n    }\n \
    \   return ret;\n}", "{\n    long sum = 0L;\n    foreach(i; 0 .. min(k, arr.length))\n\
    \    {\n        long num = arr[i];\n        if (num > 9L && num < 100L)\n    \
    \    {\n            sum += num;\n        }\n    }\n    return sum;\n}", "{\n \
    \   long[] result = new long[100];\n    int j = 0;\n    long sum = 0;\n    foreach(element;\
    \ arr)\n    {\n        if(element > 9 && element < 100)\n        {\n         \
    \   result[j] = element;\n            j++;\n        }\n    }\n    foreach(element;\
    \ 0..k)\n    {\n        sum += result[element];\n    }\n    return sum;\n}", "{\n\
    \    long sum = 0L;\n    long max = 0L;\n    long i = 0L;\n    while (i < k)\n\
    \    {\n        max = max(max, arr[i]);\n        if (max <= 99L)\n        {\n\
    \            sum += arr[i];\n        }\n        i++;\n    }\n    return sum;\n\
    }", "{\n    long[] sublist = arr[0..k];\n    long result = 0;\n    foreach(i;\
    \ sublist) \n    {\n        if(i < 100) \n        {\n            result += i;\n\
    \        }\n    }\n    return result;\n}", "{\n    struct T {\n        long[]\
    \ arr;\n        long n;\n    }\n    T t = T(arr, k);\n    return t.arr.take(t.n).filter!(x\
    \ => x.digits == 1 || x.digits == 2).sum;\n}", "{\n    long s = 0L;\n    foreach(i;\
    \ 0 .. k)\n    {\n        if(arr[i] < 100L)\n        {\n            s += arr[i];\n\
    \        }\n    }\n    return s;\n}", "{\n    size_t count = 0;\n    long sum\
    \ = 0;\n    while (count < k)\n    {\n        if (0 < arr[count] && arr[count]\
    \ < 100)\n        {\n            sum += arr[count];\n        }\n        ++count;\n\
    \    }\n    return sum;\n}\n/*", "{ \n    import std.string : to;\n    enum int\
    \ MAX_N_DIGITS = 2;\n    long result = 0;\n    foreach(i, v; arr)\n    {\n   \
    \     if(v.to!string.length > MAX_N_DIGITS)\n            continue;\n        if(i\
    \ >= k)\n            break;\n        result += v;\n    }\n    return result;\n\
    }", "{\n    long sum = 0L;\n    long length = arr.length;\n    int counter = 0;\n\
    \    bool exit_loop = false;\n    while (!exit_loop)\n    {\n        int temp\
    \ = 0;\n        long val = arr[counter];\n        while (val > 0)\n        {\n\
    \            val /= 10;\n            temp++;\n        }\n        if (temp <= 2)\n\
    \        {\n            sum += arr[counter];\n        }\n        counter++;\n\
    \        if (counter == k)\n        {\n            exit_loop = true;\n       \
    \ }\n    }\n    return sum;\n}\n \nlong[] arr = [111L, 21L, 3L, 4000L, 5L, 6L,\
    \ 7L, 8L, 9L];\nlong k = 4L;\nwriteln(add_elements(arr, k));", "{ \n  long sum\
    \ = 0;\n  long max = arr[0];\n  long num_k = k;\n  for (;k > 0; k--)\n  {\n  \
    \  if (arr[k] > 99)\n      max = arr[k];\n  }\n  auto temp = cast(long) floor(log(max)\
    \ / log(10));\n  while (num_k > 0)\n  {\n    if (arr[num_k] > 9)\n    {\n    \
    \  if (temp < 2)\n        sum += arr[num_k];\n    }\n    else\n      sum += arr[num_k];\n\
    \    num_k--;\n  }\n  return sum;\n}", "{\n    long result = 0L;\n    long max\
    \   = long.max;\n    long limit = 100L;\n    long count = 0L;\n    foreach(value;\
    \ arr)\n    {\n        if (value < limit)\n        {\n            result += value;\n\
    \            ++count;\n        }\n        if (count == k)\n            break;\n\
    \    }\n    return result;\n}", "{\n    size_t len = arr.length;\n    size_t cnt\
    \ = 0;\n    long arr_1 = 0L;\n    long arr_2 = 0L;\n    long arr_3 = 0L;\n   \
    \ long arr_4 = 0L;\n    long arr_5 = 0L;\n    long ret = 0L;\n    auto len_ =\
    \ std.typecons.Tuple!(int, int)(len, k);\n    auto k_ = std.typecons.Tuple!(int,\
    \ int)(k, arr_1);\n    auto arr_1_ = std.typecons.Tuple!(int, int)(arr_1, arr_2);\n\
    \    auto arr_2_ = std.typecons.Tuple!(int, int)(arr_2, arr_3);\n    auto arr_3_\
    \ = std.typecons.Tuple!(int, int)(arr_3, arr_4);\n    auto arr_4_ = std.typecons.Tuple!(int,\
    \ int)(arr_4, arr_5);\n    auto arr_5_ = std.typecons.Tuple!(int, int)(arr_5,\
    \ arr_1);\n    while (true)\n    {\n        if (cnt >= len_._0) break;\n     \
    \   auto k_i = k_._0 + 1L;\n        auto k_ = std.typecons.Tuple!(int, int)(k_i,\
    \ arr_1);\n        cnt++;\n    }\n    cnt = 0;\n    while (true)\n    {\n    \
    \    if (cnt >= k_._0) break;\n        auto arr_1_i = arr_1_._0 + arr[cnt];\n\
    \        auto arr_1_ = std.typecons.Tuple!(int, int)(arr_1_i, arr_2);\n      \
    \  cnt++;\n    }\n    cnt = 0;\n    while (true)\n    {\n        if (cnt >= k_._0)\
    \ break;\n        if (arr[cnt] >= 100L)\n        {\n            auto arr_2_i =\
    \ arr_2_._0 + arr[cnt];\n            auto arr_2_ =", "{\n    /* \n    The algorithm\
    \ could be replaced by the following.\n    That would work as well as the one\
    \ below, but probably slightly faster.", "{\n    long sum = 0L;\n    long count\
    \ = 0L;\n    foreach(elem; arr)\n    {\n        if(count < k)\n        {\n   \
    \         if(elem < 100L)\n            {\n                sum += elem;\n     \
    \       }\n            count++;\n        }\n    }\n    return sum;\n}", "{\n \
    \   long result = 0L;\n    foreach(index, value; arr) \n    {\n        if (index\
    \ >= k) break;\n        if (value <= 99L) result += value;\n    }\n    return\
    \ result;\n}\n/*\n    Function add_elements() should return an integer with at\
    \ most two digits.", "{\n    auto size = len(arr);\n    assert(1 <= size <= 100L);\n\
    \    assert(1 <= k <= size);\n    auto tmp = arr[0..k];\n    auto it = tmp.enumerate;\n\
    \    while(it.moveNext)\n    {\n        auto val = it.current;\n        if(val[1]\
    \ > 99L)\n        {\n            tmp[val[0]] = 99L;\n        }\n    }\n    return\
    \ sum(tmp);\n}", "{\n    int c = 0;\n    int sum = 0;\n    for (; c < k; c++)\
    \ {\n        if (arr[c] < 10)\n            sum += arr[c];\n        else if (arr[c]\
    \ < 100)\n            sum += arr[c];\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0L;\n    foreach(el; arr[0..min(k, arr.length)]) \n    {\n        if(digits_count(el)\
    \ <= 2) \n        {\n            sum += el;\n        }\n    }\n    return sum;\n\
    }", "{\n    int count = 0;\n    long sum = 0;\n    foreach(elem; arr)\n    {\n\
    \        if(count == k)\n            break;\n        if(elem < 100)\n        {\n\
    \            count++;\n            sum += elem;\n        }\n    }\n    return\
    \ sum;\n}\n/*\n    Consider a directed graph consisting of n vertices\n    and\
    \ m edges, with vertex 1 being the starting point\n    and vertex n being the\
    \ ending point.", "{\n    /*\n        Make sure k is not out of range\n    */\n\
    \    assert(k >= 1L && k <= arr.length);\n    /*\n        Tally up the sum of\
    \ the first k numbers that have at most 2 digits\n    */\n    long sum = 0L;\n\
    \    long i = 0L;\n    while (i < k) \n    {\n        /*\n            Initialize\
    \ a temp value to the numbers first digit\n        */\n        long temp = arr[i]\
    \ % 10L;\n        /*\n            Increment the temp value until we reach a number\
    \ that has\n            more than 2 digits\n        */\n        while (temp <\
    \ 100L) \n        {\n            temp = temp * 10L + arr[i] % 10L;\n        }\n\
    \        /*\n            If the number of digits is more than 2, than we have\n\
    \            a value that exceeds the bounds, so move on to the\n            next\
    \ number\n        */\n        if (temp >= 100L) \n        {\n            i = i\
    \ + 1L;\n            continue;\n        }\n        /*\n            Tally up the\
    \ number that we are allowed to add\n        */\n        sum = sum + arr[i];\n\
    \        i = i + 1L;\n    }\n    return sum;\n}\n/*\n    Tests\n*/\nunittest \n\
    {\n    assert(add_elements([111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L], 4L) ==\
    \ 24L);\n    assert(add_elements([111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L], 3L)\
    \ == 21L);\n    assert(add_elements([111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L],\
    \ 9L) == 21L);\n    assert(add_elements([21L, 12L, 123L, 4L, 5L, 6L, 7L, 8L, 9L],\
    \ 4L) == 21L);\n    assert(add_elements([21L, 12L, 123L, 4L, 5L, 6L, 7L, 8L, 9L",
  "{\n    long sum = 0L;\n    for (long i = 0L; i < k; i++)\n    {\n        long a\
    \ = arr[i];\n        if (a < 100L)\n        {\n            sum += a;\n       \
    \ }\n    }\n    return sum;\n}", "in\n{\n    assert(1 <= k <= arr.length);\n \
    \   long sum = 0L;\n    long i = 0L;\n    while (i < k)\n    {\n        if (arr[i]\
    \ < 100L)\n        {\n            sum += arr[i];\n        }\n        i += 1L;\n\
    \    }\n    return sum;\n}", "{\n    assert(k >= 1L && k <= arr.length);\n   \
    \ long result = 0L;\n    foreach(index, elem; arr[0..k])\n    {\n        immutable\
    \ size = 10L;\n        immutable digits = max(arr.length * log(10L), 1L);\n  \
    \      if(elem < size ^^ digits)\n        {\n            result += elem;\n   \
    \     }\n    }\n    return result;\n}", "{\n    long result = 0L;\n    long smallest\
    \ = 0L;\n    long current = 0L;\n    long max = 0L;\n    long temp = 0L;\n   \
    \ long[][] a = new long[k][3];\n    foreach(i; 0 .. k)\n    {\n        a[i][0]\
    \ = arr[i];\n        a[i][1] = 0L;\n        a[i][2] = 0L;\n    }\n    foreach(i;\
    \ 0 .. k)\n    {\n        if(a[i][0] >= 10L && a[i][0] < 100L)\n        {\n  \
    \          a[i][1] = 1L;\n        }\n        else if(a[i][0] < 10L)\n        {\n\
    \            a[i][1] = 2L;\n        }\n        else\n        {\n            a[i][1]\
    \ = 0L;\n        }\n    }\n    foreach(i; 0 .. k)\n    {\n        smallest = a[i][1];\n\
    \        max = i;\n        foreach(j; i .. k)\n        {\n            if(a[j][1]\
    \ < smallest)\n            {\n                smallest = a[j][1];\n          \
    \      max = j;\n            }\n        }\n        temp = a[i][0];\n        a[i][0]\
    \ = a[max][0];\n        a[max][0] = temp;\n        temp = a[i][1];\n        a[i][1]\
    \ = a[max][1];\n        a[max][1] = temp;\n    }\n    foreach(i; 0 .. k)\n   \
    \ {\n        a[i][2] = i;\n    }\n    foreach(i; 0 .. k)\n    {\n        smallest\
    \ = a[i][2];\n        max = i;\n        foreach(j; i .. k)\n        {\n      \
    \      if(a[j][2] < smallest)\n            {\n                smallest = a[j][2];\n\
    \                max = j;\n            }\n        }\n        temp = a[i][0];\n\
    \        a[i][0] = a[", "{\n    // 0 <= arr[i] <= 10^5\n    assert(arr.length\
    \ >= 1 && arr.length <= 100);\n    assert(k >= 1 && k <= arr.length);\n    long\
    \ sum = 0L;\n    foreach(long elem; arr)\n    {\n        if(count_digits(elem)\
    \ <= 2L)\n        {\n            sum += elem;\n        }\n    }\n    return sum;\n\
    }", "{\n    long result = 0L;\n    long one = 0L;\n    long two = 0L;\n    long\
    \ three = 0L;\n    long four = 0L;\n    long five = 0L;\n    long six = 0L;\n\
    \    long seven = 0L;\n    long eight = 0L;\n    long nine = 0L;\n    long ten\
    \ = 0L;\n    long eleven = 0L;\n    long twelve = 0L;\n    long thirteen = 0L;\n\
    \    long fourteen = 0L;\n    long fifteen = 0L;\n    long sixteen = 0L;\n   \
    \ long seventeen = 0L;\n    long eighteen = 0L;\n    long nineteen = 0L;\n   \
    \ long twenty = 0L;\n    long rest = 0L;\n    foreach(i; 0 .. k)\n    {\n    \
    \    if(arr[i] == 1L)\n        {\n            one++;\n        }\n        else\
    \ if(arr[i] == 2L)\n        {\n            two++;\n        }\n        else if(arr[i]\
    \ == 3L)\n        {\n            three++;\n        }\n        else if(arr[i] ==\
    \ 4L)\n        {\n            four++;\n        }\n        else if(arr[i] == 5L)\n\
    \        {\n            five++;\n        }\n        else if(arr[i] == 6L)\n  \
    \      {\n            six++;\n        }\n        else if(arr[i] == 7L)\n     \
    \   {\n            seven++;\n        }\n        else if(arr[i] == 8L)\n      \
    \  {\n            eight++;\n        }\n        else if(arr[i] == 9L)\n       \
    \ {\n            nine++;\n        }\n        else if(arr[i] == 10L)\n        {\n\
    \            ten++;\n        }\n        else if(arr[i] == 11L)\n        {\n  \
    \          eleven++;\n        }\n        else if(arr[i] == 12L)\n        {\n \
    \           twelve++;\n        }\n        else if(arr[i] == 13L)\n        {\n\
    \            thirteen++;\n        }\n        else if(arr[i] == 14L)\n        {\n\
    \            fourteen++;\n       ", "in {\n    assert(k <= arr.length);\n    assert(k\
    \ > 0);\n    foreach (i,j; arr) {\n        assert(j >= 0);\n    }\n}\nout (result)\
    \ {\n    assert(result == 24L);\n}\n{\n    long sum = 0L;\n    long[] tmp = arr[0..k];\n\
    \    foreach (i,x; tmp) {\n        if(x < 100)\n            sum += x;\n    }\n\
    \    return sum;\n}", "{ \n    auto res = 0L;\n    auto i = 0L;\n    auto n =\
    \ arr.length;\n    while (i < n && i < k) {\n        if (arr[i] < 100) {\n   \
    \         res += arr[i];\n        }\n        ++i;\n    }\n    return res;\n}",
  "{\n    long sum = 0L;\n    long min;\n    long max;\n    foreach(i; arr[0..k])\n\
    \    {\n        if(i < 100L)\n        {\n            sum += i;\n        }\n  \
    \  }\n    return sum;\n}", "{\n    return arr.take(k).filter!(e => e < 100).sum;\n\
    }", "{\n    auto it = arr.take(k);\n    long sum = 0;\n    foreach(i; it)\n  \
    \  {\n        if(i < 100)\n        {\n            sum += i;\n        }\n    }\n\
    \    return sum;\n}", "{\n    assert(1 <= arr.length && arr.length <= 100);\n\
    \    assert(1 <= k && k <= arr.length);\n    return std.array.array(\n       \
    \         arr.ptr,\n                std.numeric.min(arr.length, k))\n        \
    \    .filter!(x => x < 100)\n            .sum;\n}", "{\n    long sum = 0L;\n \
    \   foreach(i; 0..k)\n    {\n        auto digits = iota(1,10);\n        if (std.typecons.countDigits(arr[i])\
    \ == 1 ||\n            std.typecons.countDigits(arr[i]) == 2)\n        {\n   \
    \         sum += arr[i];\n        }\n    }\n    return sum;\n}\n/*", "{\n    long\
    \ sum = 0L;\n    foreach(i; 0..k) \n    {\n        long num = arr[i];\n      \
    \  while(num >= 10L) \n        {\n            num /= 10L;\n        }\n       \
    \ sum += num;\n    }\n    return sum;\n}\n//str_to_long = (str) => std.conv.to!long(str);",
  "{\n    long result = 0L;\n    int two_digits = 0;\n    int i = 0;\n    while (i\
    \ < arr.length && two_digits < k)\n    {\n        if (arr[i] > 9L && arr[i] <\
    \ 100L)\n        {\n            result += arr[i];\n            two_digits++;\n\
    \        }\n        i++;\n    }\n    return result;\n}", "{ \n    int i = 0;\n\
    \    long result = 0;\n    foreach(n; arr)\n    {\n        if(n >= 0 && n < 10)\n\
    \        {\n            result += n;\n            i++;\n        }\n        else\
    \ if(n >= 10 && n < 100)\n        {\n            result += n;\n            i++;\n\
    \        }\n        if(i == k) break;\n    }\n    return result;\n} \n ", "{\n\
    \    return arr.take(k).filter!(i => i < 100).sum;\n}", "{\n    assert(arr.length\
    \ > 0);\n    assert(k <= arr.length);\n    int i = 0;\n    long result = 0;\n\
    \    while(i < k)\n    {\n        long num = arr[i];\n        if(num < 100)\n\
    \        {\n            result += num;\n        }\n        i++;\n    }\n    return\
    \ result;\n}\n/*", "{\n    assert(!arr.empty);\n    assert(k <= arr.length);\n\
    \    // TODO(sharvil): assert that k is not empty\n    long sum = 0L;\n    for\
    \ (long i = 0L; i < k; i++) {\n        int num_digits = 0;\n        long n = arr[i];\n\
    \        // First, get the number of digits of arr[i]\n        while (n > 0) {\n\
    \            n /= 10;\n            num_digits++;\n        }\n        // If the\
    \ number of digits is at most 2, then add it to the sum\n        if (num_digits\
    \ <= 2) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}",
  "{\n    long i = 0;\n    long sum = 0;\n    foreach(l; arr)\n    {\n        i++;\n\
    \        if(l <= 99)\n        {\n            sum += l;\n        }\n        if(i\
    \ == k)\n        {\n            break;\n        }\n    }\n    return sum;\n}",
  "{\n    assert(0L < arr.length && arr.length <= 100L);\n    assert(0L < k && k <=\
    \ arr.length);\n    long res = 0L;\n    for (long i = 0L; i < k; i++)\n    {\n\
    \        if (arr[i] < 100L)\n        {\n            res += arr[i];\n        }\n\
    \    }\n    return res;\n}", "{\n    return sum(arr[0 .. min(k, arr.length)].map!((l)\
    \ => l < 100 ? l : 0));\n}\n ", "{\n    // Type alias for tuple\n    alias P =\
    \ Tuple!(long, \"a\", long, \"b\");\n    // Get the first k elements of arr\n\
    \    auto tmp = arr[0..k];\n    // Return the sum of the elements with at most\
    \ two digits\n    return tmp.filter!(a => 9999L > a && a > 9L).map!(a => a.stringof.bytestring).joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.joiner.",
  "{\n    long[] elems = arr[0..k];\n    return elems.map!(a => a % 100).sum;\n}",
  "{\n    long sum = 0L;\n    for (long j = 0L; j < k; j++) \n    {\n        long\
    \ digit = arr[cast(size_t)j];\n        if (digit > 99L) \n        {\n        \
    \    continue;\n        }\n        else if (digit > 9L) \n        {\n        \
    \    sum += digit;\n        }\n        else \n        {\n            sum += digit;\n\
    \        }\n    }\n    return sum;\n}\n// BEGIN TEMPLATE", "{\n    int accumulator\
    \ = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (i == k) break;\n\
    \        if (arr[i] <= 99)\n        {\n            accumulator += arr[i];\n  \
    \      }\n    }\n    return accumulator;\n}", "{\n    long sum = 0L;\n    long[]\
    \ to_sum = new long[](k);\n    alias type_t = typeof(arr[0]);\n    alias num_digits\
    \ = DigitsOf!(type_t);\n    static if (num_digits > 2)\n    {\n        static\
    \ foreach (i; 0..k)\n        {\n            static if (isIntegral!(type_t))\n\
    \            {\n                static if (isUnsigned!(type_t))\n            \
    \    {\n                    to_sum[i] = cast(long) arr[i] % 100L;\n          \
    \      }\n                else\n                {\n                    to_sum[i]\
    \ = cast(long) arr[i] % 100L;\n                    if (to_sum[i] < 0L)\n     \
    \               {\n                        to_sum[i] = 100L + to_sum[i];\n   \
    \                 }\n                }\n            }\n            else\n    \
    \        {\n                to_sum[i] = cast(long) arr[i] % 100L;\n          \
    \  }\n        }\n    }\n    else\n    {\n        to_sum = arr[0..k];\n    }\n\
    \    foreach (n; to_sum)\n    {\n        sum += n;\n    }\n    return sum;\n}",
  "{\n    long sum = 0L;\n    int index = 0;\n    int limit = k.to!int;\n    foreach(current;\
    \ arr)\n    {\n        if(index < limit)\n        {\n            if(current.to!string.length\
    \ < 3)\n            {\n                sum += current;\n            }\n      \
    \  }\n        index++;\n    }\n    return sum;\n}", "{\n    long total = 0L;\n\
    \    int i = 0;\n    while(i < k)\n    {\n        if(arr[i] >= 10L && arr[i] <\
    \ 100L)\n        {\n            total += arr[i];\n        }\n        i++;\n  \
    \  }\n    return total;\n}\n// Dont make any changes here", "{\n    return arr.take(cast(size_t)k).filter!(x\
    \ => (x < 100) && (x > 9)).sum;\n}", "{\n    long n = arr.length;\n    immutable\
    \ return_val = 0L;\n    immutable count = 0L;\n    foreach(index, value; arr)\n\
    \    {\n        if (value < 100)\n        {\n            return_val += value;\n\
    \            count++;\n        }\n        if (count == k)\n            break;\n\
    \    }\n    return return_val;\n}", "{\n    auto res = 0L;\n    auto curr = 0L;\n\
    \    auto b = arr[0..k];\n    foreach(i; b)\n    {\n        auto j = 0L;\n   \
    \     auto x = i;\n        while(x >= 1)\n        {\n            j++;\n      \
    \      x /= 10;\n        }\n        if(j <= 2)\n        {\n            res +=\
    \ i;\n        }\n    }\n    return res;\n}", "{\n    long sum = 0L;\n    long\
    \ i = 0L;\n    while (i < k) \n    {\n        if (arr[i] >= 10L && arr[i] <= 99L)\
    \ \n        {\n            sum += arr[i];\n        }\n        ++i;\n    }\n  \
    \  return sum;\n}", "{\n    /*\n        This problem can be solved in O(n) time\
    \ and O(1) space.\n        The first idea that came to mind is to traverse the\
    \ array,\n        adding the elements as we go, but whenever we encounter\n  \
    \      an element with three or more digits, to subtract the\n        difference\
    \ of all other elements from the sum. This seems\n        like a pretty bad idea,\
    \ both with respect to time complexity\n        and to the code's general readability.\
    \ Instead, we can run\n        an algorithm similar to counting sort, where we\
    \ count the\n        number of elements with one, two and three or more digits.\n\
    \        This algorithm has the added benefit of being O(n) in time\n        and\
    \ O(1) in space.\n    */\n    long len = arr.length;\n    long n_elems_with_1_digit\
    \ = 0;\n    long n_elems_with_2_digits = 0;\n    long n_elems_with_3_or_more_digits\
    \ = 0;\n    long sum = 0;\n    foreach(x; arr) {\n        if (x < 10) {\n    \
    \        n_elems_with_1_digit++;\n        } else if (x < 100) {\n            n_elems_with_2_digits++;\n\
    \        } else {\n            n_elems_with_3_or_more_digits++;\n        }\n \
    \   }\n    if (k <= n_elems_with_1_digit) {\n        return k * (k + 1) / 2;\n\
    \    } else if (k <= n_elems_with_1_digit + n_elems_with_2_digits) {\n       \
    \ sum += n_elems_with_1_digit * (n_elems_with_1_digit + 1) / 2;\n        sum +=\
    \ (k - n_elems_with_1_digit) * (k - n_elems_with_1_digit + 1) / 2;\n        return\
    \ sum;\n    } else {\n        sum += n_elems_with_1_digit * (n_elems_with_1_digit\
    \ + 1) / 2;\n        sum += n_elems_with_2_digits", "{\n    // because we need\
    \ to only add elements that are either\n    // 1 or 2 digits, we can use this\
    \ to determine\n    bool two_digits(long n) \n    {\n        return n / 10L >\
    \ 0L;\n    }\n    // if we're only adding up to k elements,\n    // then we can\
    \ use take to only take the first k elements\n    return arr.take(k).filter!(two_digits).sum;\n\
    }", "{\n    /*\n        1. A slice of arr that contains the first k elements of\
    \ arr\n        2. A filter function which accepts an element of the slice and\n\
    \           returns true if that element has 2 or less digits\n        3. An aggregate\
    \ function that accumulates the elements from the filtered\n           slice and\
    \ returns their sum\n    */\n    return arr.take(k).filter!(a => a.digits.length\
    \ <= 2).reduce!((a, b) => a + b)();\n}", "{\n    assert(arr.length != 0);\n  \
    \  assert(k <= arr.length);\n    long res = 0;\n    for (long i = 0; i < k; i++)\n\
    \    {\n        long num = arr[i];\n        int length = num.to!string.length;\n\
    \        if (length == 1 || length == 2)\n        {\n            res += num;\n\
    \        }\n    }\n    return res;\n}", "{ \n    long[] result = new long[k];\
    \ \n    long sum = 0;\n    foreach(i; 0 .. k)\n    {\n        if(arr[i] < 100)\n\
    \        {\n            result[i] = arr[i];\n        }\n    }\n    return sum\
    \ = result.sum;\n}", "{\n    long x = 0L;\n    foreach(idx, val; arr)\n    {\n\
    \        if(idx <= k)\n        {\n            if(val.lengthof < 3)\n         \
    \   {\n                x += val;\n            }\n        }\n    }\n    return\
    \ x;\n}", "{\n    long result = 0L;\n    long k_counter = 0L;\n    foreach(long\
    \ element; arr)\n    {\n        if(element < 100L)\n        {\n            result\
    \ += element;\n            k_counter++;\n        }\n        if(k_counter == k)\n\
    \        {\n            break;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] a = arr[0..k];\n    long total = 0;\n    foreach(m; a)\n    {\n  \
    \      if(m < 100) total += m;\n    }\n    return total;\n}", "{\n    int[] arrOfLengths\
    \ = arr.map!(i => i.to!string.length);\n    return arr.retro.filter!(i => arrOfLengths[$\
    \ - 1] <= 2).take(k).sum;\n}", "{\n    // write your code in D language\n    long\
    \ result = 0L;\n    foreach(i, value; arr)\n    {\n        if(i == k) break;\n\
    \        if(value < 100L)\n        {\n            result += value;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] temp = new long[k];\n    foreach(a;\
    \ arr[0..k])\n    {\n        temp ~= a;\n    }\n    temp = temp.map!(a => (a<10)\
    \ ? a : ((a>99) ? 0 : a % 10));\n    return temp.sum;\n}\n/*", "{\n    long ans\
    \ = 0L;\n    int i = 0;\n    while ((i < cast(int)k) && (i < arr.length))\n  \
    \  {\n        long element = arr[i];\n        auto digits = to!string(element).length;\n\
    \        if (digits <= 2)\n        {\n            ans += element;\n        }\n\
    \        i++;\n    }\n    return ans;\n}", "{\n    auto result = 0L;\n    foreach(idx,\
    \ v; arr)\n    {\n        if(v < 100L)\n        {\n            result += v;\n\
    \        }\n        if(idx == k)\n        {\n            break;\n        }\n \
    \   }\n    return result;\n}", "{\n    return arr.take(k).filter!(i => i > 9 &&\
    \ i < 100).sum;\n}", "{\n    static assert(arr.length > 0);\n    static assert(k\
    \ > 0);\n    static assert(k <= arr.length);\n    long total = 0;\n    for (long\
    \ i = 0; i < k; i++) {\n        if (arr[i] < 100) {\n            total += arr[i];\n\
    \        }\n    }\n    return total;\n}\n// @exclude", "{\n    long sum = 0L;\n\
    \    long[] a = to!(long[])(arr[0..k]);\n    foreach(immutable l; a)\n    {\n\
    \        if(l < 100L) sum += l;\n    }\n    return sum;\n}", "{\n    long[] arr_copy\
    \ = arr.slice(0, k);\n    long sum = 0;\n    foreach(num; arr_copy)\n    {\n \
    \       long n_digits = cast(long)log10(num);\n        if(n_digits < 2)\n    \
    \    {\n            sum += num;\n        }\n    }\n    return sum;\n}", "{\n \
    \   // Edge case where k is 0\n    // Since we need to iterate through at least\
    \ 1 item\n    if (k == 0) return 0;\n    \n    // initialize a counter\n    long\
    \ counter = 0;\n    \n    // Iterate up to k items\n    for (long i = 0; i < k;\
    \ i++)\n    {\n        // Extract the element\n        auto element = arr[i];\n\
    \        \n        // if element is less than 99\n        if (element < 100)\n\
    \        {\n            // add to counter\n            counter += element;\n \
    \       }\n    }\n    \n    // return counter\n    return counter;\n}\n ", "{\n\
    \    long[] k_elems = arr[0..k];\n    return k_elems.filter!(x => x < 100).sum;\n\
    }", "{\n    long res = 0L;\n    for (int i = 0; i < min(k, arr.length); i++)\n\
    \    {\n        long num = arr[i];\n        if (num >= 10L && num < 100L)\n  \
    \      {\n            res += num;\n        }\n    }\n    return res;\n}\n// TEST\
    \ DRIVER", "{\n    long sum = 0L;\n    long k_max = min(arr.length, k);\n    foreach(i;\
    \ 0..k_max)\n    {\n        auto a = arr[i];\n        sum += (a < 10L || a < 100L)\
    \ ? a : 0L;\n    }\n    return sum;\n}", "{\n    long result = 0L;\n    //typecons.tuple!(long,\
    \ long)(tup)\n    foreach(tup; zip(arr, iota(1L)))\n    {\n        //auto(x, i)\
    \ = tup;\n        auto x = tup[0];\n        auto i = tup[1];\n        if(i >=\
    \ k) break;\n        if(log10(x) + 1L <= 2L)\n        {\n            result +=\
    \ x;\n        }\n    }\n    return result;\n}", "{\n    long result = 0L;\n  \
    \  long index = 0L;\n    while(index < k && index < arr.length)\n    {\n     \
    \   if(arr[index] < 100L)\n        {\n            result += arr[index];\n    \
    \    }\n        index++;\n    }\n    return result;\n}", "{\n    long sum = 0L;\n\
    \    foreach(i; 0 .. k)\n    {\n        sum += i < arr.length && arr[i] >= 10\
    \ && arr[i] < 100 ? arr[i] : 0L;\n    }\n    return sum;\n}", "in {\n    assert(1\
    \ <= k && k <= 100);\n    assert(1 <= arr.length && arr.length <= 100);\n}\nout\
    \ (result) {\n    assert(1 <= result && result <= 1000);\n}\n= add_elements_helper(arr,\
    \ 0L, k, 0L);", "{\n    long result = 0L;\n    long mod = 100L;\n    foreach(index,\
    \ value; zip(arr, iota(arr.length))) \n    {\n        if (value < mod) \n    \
    \    {\n            result += value;\n        }\n        if (index == k - 1) \n\
    \        {\n            break;\n        }\n    }\n    return result;\n}", "{\n\
    \tlong result = 0L;\n\tlong[] arr_slice = arr[0 .. k];\n\tforeach(elem; arr_slice)\n\
    \t{\n\t\tresult += elem % 100L;\n\t}\n\treturn result;\n}", "{\n    if (arr.length\
    \ == 0)\n        return 0;\n    long ret = 0;\n    for (long i = 0; i < k; i++)\
    \ {\n        long num = arr[i];\n        while (num > 0) {\n            if (num\
    \ / 10 == 0) {\n                ret += num;\n                break;\n        \
    \    }\n            num /= 10;\n        }\n    }\n    return ret;\n}", "{\n  \
    \  bool all_9s(int num)\n    {\n        return num == 999;\n    }\n    bool is_zero(int\
    \ num)\n    {\n        return num == 0;\n    }\n    auto num_size = (int num)\
    \ {\n        import std.algorithm;\n        return all_9s(num) || is_zero(num)\n\
    \            ? 1\n            : num.to!string.length;\n    };\n    auto sum_two_digits\
    \ = (long[] arr, long k) {\n        int total = 0;\n        for (int i = 0; i\
    \ < k; i++) {\n            if (num_size(arr[i]) == 2)\n                total +=\
    \ arr[i];\n        }\n        return total;\n    };\n    auto sum_three_digits\
    \ = (long[] arr, long k) {\n        int total = 0;\n        for (int i = 0; i\
    \ < k; i++) {\n            if (num_size(arr[i]) == 3)\n                total +=\
    \ arr[i];\n        }\n        return total;\n    };\n    return sum_two_digits(arr,\
    \ k) + sum_three_digits(arr, k);\n}", "{ \n    long sum = 0L;\n    for (size_t\
    \ i = 0; i < k; i++)\n    {\n        auto num = arr[i];\n        auto numStr =\
    \ format(num, \"%.*g\");\n        auto dotIndex = numStr.indexOf('.');\n     \
    \   if (dotIndex == null)\n        {\n            sum += num;\n        }\n   \
    \     else\n        {\n            auto strLength = numStr.length;\n         \
    \   if (strLength - dotIndex <= 2)\n            {\n                sum += num;\n\
    \            }\n        }\n    }\n    return sum;\n}", "{\n    long sum = 0L;\n\
    \    foreach(i; 0..k) \n    {\n        if(arr[i] < 100L)\n            sum += arr[i];\n\
    \    }\n    return sum;\n}\n/*\n    # Another Solution:\n    1. std.algorithm.sort\n\
    \    2. Take the slice of sorted array\n    3. Filter the slice to get values\
    \ less than 100\n    4. Take sum of the slice using std.algorithm.sum", "{ \n\
    \    /* \n        This is an example of a function which\n        should return\
    \ the sum of elements in \n        the first k elements of arr that have at\n\
    \        most two digits.", "{ \n    return arr.take(cast(int)k).filter!(e =>\
    \ e.length <= 2).sum;\n}", "in \n{\n    alias K = typeof(arr.length);\n    assert(1\
    \ <= k && k <= K.max);\n    assert(1 <= arr.length && arr.length <= 100);\n}\n\
    body \n{\n    long sum = 0L;\n    long n = arr.length;\n    long i = 0L;\n   \
    \ while(i < n && k > 0L)\n    {\n        long nd = arr[i];\n        if(nd < 10L)\n\
    \        {\n            sum += nd;\n            k--;\n        }\n        else\
    \ if(nd < 100L)\n        {\n            sum += nd;\n            k--;\n       \
    \ }\n        i++;\n    }\n    return sum;\n}", "{\n    long result = 0L;\n   \
    \ long max_power = 10L;\n    int index = 0;\n    while (k > 0L)\n    {\n     \
    \   long elem = arr[index];\n        if (elem >= max_power)\n        {\n     \
    \       elem /= max_power;\n            if (elem >= max_power)\n            {\n\
    \                elem /= max_power;\n            }\n        }\n        result\
    \ += elem;\n        k--;\n        index++;\n    }\n    return result;\n}", "{\n\
    \    long sum = 0L;\n    long i = 0L;\n    long end_index = min(k, arr.length);\n\
    \    for (; i < end_index; i++) \n    {\n        long val = arr[i];\n        if\
    \ (val < 100L) \n        {\n            sum += val;\n        }\n    }\n    return\
    \ sum;\n}", "{\n    // this is a really common algorithm problem, so we can solve\
    \ it in\n    // O(n) time and O(1) space\n    long sum = 0;\n    ulong i = 0;\n\
    \    // iterate over each element in the array and stop when we reach k\n    foreach\
    \ (elem; arr[0..k]) {\n        if (elem <= 99) {\n            // if the element\
    \ is less than 100, then add it to the sum\n            sum += elem;\n       \
    \ }\n        else {\n            // if the element is greater than 99, we have\
    \ to split it into\n            // its component parts\n            int ones =\
    \ cast(int)(elem % 10);\n            int tens = cast(int)((elem % 100) / 10);\n\
    \            int hundreds = cast(int)(elem / 100);\n            // add the component\
    \ parts to the sum\n            sum += ones + tens + hundreds;\n        }\n  \
    \  }\n    return sum;\n}\n ", "{\n    long sum = 0L;\n    ulong i = 0UL;\n   \
    \ while (i < k)\n    {\n        if (arr[i] >= 10L && arr[i] <= 99L)\n        {\n\
    \            sum += arr[i];\n        }\n        i++;\n    }\n    return sum;\n\
    }", "in \n{\n    assert(1 <= arr.length && arr.length <= 100);\n    assert(1 <=\
    \ k && k <= arr.length);\n}\nbody \n{\n    return arr[0..min(k, arr.length)].sum!((x)\
    \ => (x < 100 ? x : 0));\n}", "{\n    long sum = 0L;\n    int i = 0;\n    for\
    \ (i = 0; i < min(arr.length, k); i++)\n    {\n        if (arr[i] < 100)\n   \
    \     {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}", "{\n\
    \    long sum = 0L;\n    long upto = 0L;\n    while (upto < k)\n    {\n      \
    \  if (arr[upto] < 100L)\n        {\n            sum += arr[upto];\n        }\n\
    \        else\n        {\n            break;\n        }\n        upto++;\n   \
    \ }\n    return sum;\n}", "{\n    auto elems = arr.take(k).filter!((e) => e <\
    \ 100);\n    return elems.reduce!((a, b) => a + b)(0L);\n}", "{ \n  if (arr.length\
    \ == 0)\n  {\n    return 0;\n  }\n  else\n  {\n    auto temp_arr = arr[0..k];\n\
    \    auto new_arr = temp_arr.filter!((x) => x.to!string.length <= 2);\n    return\
    \ new_arr.reduce!((acc, e) => acc + e)(0);\n  }\n}", "{\n    long[] tup = std.typecons.Tuple!(long,\
    \ long)(0L, 0L);\n    tup = arr.map!(x => x >= 100 ? x : x).reduce!q{a, b => (a[0]\
    \ + b, a[1] + 1)}.only;\n    if (tup[1] > k) return arr.take(cast(size_t)k).sum\
    \ + arr.drop(cast(size_t)k).map!(x => x >= 100 ? x : x).sum;\n    return arr.take(cast(size_t)k).sum;\n\
    }\n/*\n    Test cases:\n    >>> add_elements([10L, 11L, 12L, 13L, 14L, 15L, 16L,\
    \ 17L, 18L, 19L], 4L)\n    60L\n    >>> add_elements([1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L, 1L], 4L)\n    4L\n    >>> add_elements([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L], 1L)\n    1L\n    >>> add_elements([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L], 10L)\n    55L\n    >>> add_elements([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L], 15L)\n    55L\n    >>> add_elements([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L], 20L)\n    55L\n    >>> add_elements([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L], 25L)\n    55L\n    >>> add_elements([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L], 30L)\n", "in {\n    assert(arr.length > 0 && arr.length <=\
    \ 100);\n    assert(k >= 1 && k <= arr.length);\n}\nout (result) {\n    assert(result\
    \ >= 1 && result <= 9999);\n}\n{\n    long result = 0;\n    foreach (i, elem;\
    \ arr) {\n        if (i == k) {\n            break;\n        }\n        if (elem\
    \ < 100) {\n            result += elem;\n        }\n    }\n    return result;\n\
    }", "{\n    long sum = 0L;\n    foreach(v; arr)\n    {\n        if(v >= 0L &&\
    \ v < 100L)\n        {\n            sum += v;\n        }\n    }\n    return sum;\n\
    }\n \n ", "{\n    import std.stdio;\n    import std.conv;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.array;\n    import std.math;\n    import\
    \ std.typecons;\n    import std.string;\n    import std.complex;\n    import std.exception;\n\
    \    import std.getopt;\n    import std.c.stdlib;\n    import std.datetime;\n\
    \    import std.format;\n    import std.random;\n    import std.typecons;\n  \
    \  import std.math;\n    import std.typecons;\n    alias Uint = uint;\n    alias\
    \ Ulong = ulong;\n    auto ret = 0L;\n    auto arr_ = arr[0..k];\n    foreach(el;\
    \ arr_)\n    {\n        if (el.length() < 3)\n        {\n            ret += el;\n\
    \        }\n    }\n    return ret;\n}", "{\n    import std.algorithm : take;\n\
    \    import std.algorithm : takeExactly;\n    import std.typecons : Tuple;\n \
    \   import std.math : ceil;\n    import std.conv : to;\n    import std.typecons\
    \ : tuple;\n    alias Tuple!(long, long) LongTuple;\n    enum is_one_digit = (arr)\
    \ {\n        return std.typecons.tuple(arr[0] >= 10, arr[0] < 100);\n    };\n\
    \    auto one_digit_tuple = std.typecons.tuple(is_one_digit(arr));\n    bool one_digit\
    \ = one_digit_tuple[0];\n    bool two_digit = one_digit_tuple[1];\n    if(one_digit)\
    \ {\n        auto one_digit_tuple = std.typecons.tuple(take(arr, k));\n      \
    \  auto one_digit_arr = one_digit_tuple[0];\n        auto rest_arr = one_digit_tuple[1];\n\
    \        auto arr_tuple = std.typecons.tuple(one_digit_arr, rest_arr);\n     \
    \   auto one_digit_arr = arr_tuple[0];\n        auto rest_arr = arr_tuple[1];\n\
    \        return one_digit_arr.sum();\n    }\n    if(two_digit) {\n        auto\
    \ two_digit_tuple = std.typecons.tuple(take(arr, k));\n        auto two_digit_arr\
    \ = two_digit_tuple[0];\n        auto rest_arr = two_digit_tuple[1];\n       \
    \ auto arr_tuple = std.typecons.tuple(two_digit_arr, rest_arr);\n        auto\
    \ two_digit_arr = arr_tuple[0];\n        auto rest_arr = arr_tuple[1];\n     \
    \   return two_digit_arr.sum();\n    }\n    return -1L;\n}", "{\n    long sum\
    \ = 0L;\n    for (size_t i = 0; i < k; i++) \n    {\n        if (arr[i] > 99)\n\
    \            sum += 0;\n        else\n            sum += arr[i];\n    }\n    return\
    \ sum;\n}", "{\n    if (arr.length == 0 || k <= 0) return 0;\n    long answer\
    \ = 0;\n    for (long element = 0; element < k; element++) {\n        if (element\
    \ > arr.length - 1) break;\n        if (arr[element] < 100) answer += arr[element];\n\
    \    }\n    return answer;\n}", "{ \n    // keep a running total\n    long total\
    \ = 0L;", "{\n    int sum = 0;\n    foreach(item; arr[0..k])\n    {\n        if(item\
    \ < 100)\n        {\n            sum += item;\n        }\n    }\n    return sum;\n\
    }\n// void main(string[] args)\n// {\n//     auto x = add_elements([111L, 21L,\
    \ 3L, 4000L, 5L, 6L, 7L, 8L, 9L], 4L);\n//     assert(x == 24L);\n// }", "{\n\
    \    auto sum = 0L;\n    auto count = 0L;\n    auto elem = 0L;\n    for (auto\
    \ i = 0L; i < arr.length; i++)\n    {\n        elem = arr[i];\n        if (elem\
    \ >= 10 && elem < 100)\n        {\n            count++;\n            sum += elem;\n\
    \        }\n        if (count == k)\n        {\n            break;\n        }\n\
    \    }\n    return sum;\n}", "{\n    int result = 0;\n    foreach(i; 0 .. k)\n\
    \    {\n        if(arr[i] < 10)\n        {\n            result += arr[i];\n  \
    \      }\n        else if(arr[i] < 100)\n        {\n            result += arr[i];\n\
    \        }\n    }\n    return result;\n}", "{\n    /*\n    The same algorithm\
    \ would work if the range of numbers\n    with at most two digits is changed from\
    \ 1-99 to 1-999, 1-9999, etc.\n    */\n    long sum = 0L;\n    long[] two_digit_numbers\
    \ = new long[99L];\n    long two_digit_numbers_index = 0L;\n    long left_index\
    \ = 0L;\n    long right_index = 0L;\n    long current_number = 0L;\n    long current_number_length\
    \ = 0L;\n    for (long i = 0L; i < 99L; i++)\n    {\n        two_digit_numbers[i]\
    \ = i + 1L;\n    }\n    for (long i = 0L; i < k; i++)\n    {\n        current_number\
    \ = arr[i];\n        current_number_length = (long)log10(current_number) + 1L;\n\
    \        if (current_number_length > 2L)\n        {\n            right_index =\
    \ (long)pow(10L, current_number_length - 2L) - 1L;\n            left_index = right_index\
    \ * 10L;\n            sum += two_digit_numbers[right_index - 1L];\n        }\n\
    \        else\n        {\n            two_digit_numbers_index = current_number\
    \ - 1L;\n            sum += two_digit_numbers[two_digit_numbers_index];\n    \
    \    }\n    }\n    return sum;\n}\n/*\n    Time Complexity: O(n) // n is the length\
    \ of arr\n    Space Complexity: O(1)\n*/\nlong add_elements_alt(long[] arr, long\
    \ k) \n{\n    long sum = 0L;\n    for (long i = 0L; i < k; i++)\n    {\n     \
    \   if (arr[i] > 99L)\n        {\n            sum += sum_of_two_digit_numbers(arr[i]);\n\
    \        }\n        else\n        {\n            sum += arr[i];\n        }\n \
    \   }\n    return sum;\n}", "{\n    int twoDigitCount = 0;\n    long twoDigitNumber\
    \ = 0;\n    long res = 0;\n    long num = 0;\n    for (int i = 0; i < k; i++)\n\
    \    {\n        num = arr[i];\n        if (num / 10 > 0)\n        {\n        \
    \    twoDigitCount++;\n            twoDigitNumber = num;\n        }\n        res\
    \ += num;\n    }\n    // If there's no 2-digit numbers, or if there's more than\
    \ one 2-digit numbers,\n    // return the current result.\n    if (twoDigitCount\
    \ <= 1)\n        return res;\n    // If the only 2-digit number is the first element,\
    \ return the result without\n    // the first element.\n    if (twoDigitNumber\
    \ == arr[0])\n        return res - twoDigitNumber;\n    // If there are 2-digit\
    \ numbers and the first element is a 1-digit number,\n    // return the result\
    \ without the first element plus the sum of the digits in the 2-digit number.\n\
    \    else\n        return res - arr[0] + (twoDigitNumber / 10) + (twoDigitNumber\
    \ % 10);\n}", "{\n    long sum = 0L;\n    for (immutable long i = 0L; i < min(k,\
    \ arr.length); i++) \n    {\n        if (arr[i] < 100L)\n            sum += arr[i];\n\
    \    }\n    return sum;\n}", "{\n    long sum = 0L;\n    long i = 0L;\n    long\
    \ limit = min(k, arr.length);\n    while (i < limit)\n    {\n        long num\
    \ = arr[i];\n        bool is_two_digit = num > 9L;\n        if (is_two_digit)\n\
    \        {\n            long tens = num / 10L;\n            bool is_three_digit\
    \ = tens > 9L;\n            if (is_three_digit)\n            {\n             \
    \   sum += tens;\n            }\n            else\n            {\n           \
    \     sum += num;\n            }\n        }\n        else\n        {\n       \
    \     sum += num;\n        }\n        i++;\n    }\n    return sum;\n}\nlong add_elements_deque(long[]\
    \ arr, long k) \n{\n    import std.algorithm;\n    import std.range;\n    import\
    \ std.typecons;\n    long sum = 0L;\n    long i = 0L;\n    long limit = min(k,\
    \ arr.length);\n    while (i < limit)\n    {\n        long num = arr[i];\n   \
    \     long[] digits = num.to!string().to!(long[]);\n        sum += digits.front;\n\
    \        sum += digits.drop(1).take(1).front;\n        i++;\n    }\n    return\
    \ sum;\n}", "{\n  int sum = 0;\n  int i = 0;\n  while(i < k)\n  {\n    sum +=\
    \ (arr[i] <= 99) ? arr[i] : 0;\n    i++;\n  }\n  return sum;\n}", "{\n    long\
    \ result = 0L;\n    foreach(elem; arr[0 .. min(k, arr.length)])\n    {\n     \
    \   if(elem <= 99L)\n        {\n            result += elem;\n        }\n    }\n\
    \    return result;\n}", "{\n    long sum = 0L;\n    long ones = 0L;\n    long\
    \ twos = 0L;\n    for (int i = 0; i < k; i++)\n    {\n        string int_str =\
    \ to!string(arr[i]);\n        if (int_str.length == 1)\n        {\n          \
    \  ones += arr[i];\n        }\n        else if (int_str.length == 2)\n       \
    \ {\n            twos += arr[i];\n        }\n    }\n    sum = ones + twos;\n \
    \   return sum;\n}", "{\n    long sum = 0L;\n    foreach(index, elem; arr[0..k])\n\
    \    {\n        if(elem < 100L)\n        {\n            sum += elem;\n       \
    \ }\n    }\n    return sum;\n}", "{\n    long sum = 0L;\n    long arrSize = arr.length;\n\
    \    k = min(k, arrSize);\n    for (int i = 0; i < k; i++)\n    {\n        sum\
    \ += arr[i] % 100;\n    }\n    return sum;\n}", "{\n  // I'm treating the function\
    \ call as a queue in which elements can be consumed\n  // By doing this, the number\
    \ of elements that can be consumed is k, not just len(arr)\n  // This takes care\
    \ of the 2nd constraint.\n  auto queue = arr.take(cast(size_t)k);\n  long sum\
    \ = 0;\n  foreach(elem; queue)\n  {\n    // check to see if the element has at\
    \ most 2 digits. If not, then don't add it.\n    sum += elem.to!string.length\
    \ <= 2 ? elem : 0;\n  }\n  return sum;\n}\n ", "{\n    long sum = 0L;\n    long\
    \ idx = 0L;\n    for (; k-- > 0L;)\n    {\n        if (arr[idx] < 100L)\n    \
    \    {\n            sum += arr[idx];\n        }\n        idx++;\n    }\n    return\
    \ sum;\n}", "{\n    long res = 0L;\n    foreach(idx, val; arr)\n    {\n      \
    \  if(idx + 1 > k) break;\n        if(val < 100L)\n        {\n            res\
    \ += val;\n        }\n    }\n    return res;\n}", "{\n    long sum = 0L;\n   \
    \ long n = arr.length;\n    for (long i = 0L; i < n; i++)\n    {\n        long\
    \ x = arr[i];\n        if (i >= k)\n            break;\n        if (x < 100L)\n\
    \            sum += x;\n    }\n    return sum;\n}", "{\n    assert(arr.length\
    \ != 0);\n    assert(k != 0);\n    long result = 0;\n    for (long num : arr[0..k])\n\
    \    {\n        if(num < 100)\n        {\n            result += num;\n       \
    \ }\n    }\n    return result;\n}", "{\n    long sum = 0L;\n    long index = 0L;\n\
    \    while (index < k) \n    {\n        if (arr[index] < 100L)\n        {\n  \
    \          sum += arr[index];\n        }\n        ++index;\n    }\n    return\
    \ sum;\n}", "{\n    long ret = 0L;\n    int i = 0;\n    while(i < k)\n    {\n\
    \        if(arr[i] < 100)\n        {\n            ret += arr[i];\n        }\n\
    \        i++;\n    }\n    return ret;\n}", "{\n    /*\n        Got a TLE for the\
    \ first implementation.\n        It seems like a lot of space is being allocated.\n\
    \        The stack space of a recursive function exceeds.\n        Therefore,\
    \ I will change the algorithm to be iterative.\n        I think the problem is\
    \ also in the result variable which\n        is allocated everytime the function\
    \ is called.", "{\n    long result = 0L;\n    auto n = arr.length;\n    immutable\
    \ int number_of_digits = 2;\n    for (long i = 0L; i < k; i++)\n    {\n      \
    \  auto digits = floor(log10(arr[i]));\n        if (digits + 1 <= number_of_digits)\n\
    \        {\n            result += arr[i];\n        }\n    }\n    return result;\n\
    }", "{\n    long result = 0L;\n    long[] two_digit_elements = [];\n    foreach(elem;\
    \ arr)\n    {\n        if (elem > 99L)\n        {\n            two_digit_elements\
    \ ~= elem;\n        }\n        else\n        {\n            result += elem;\n\
    \        }\n    }\n    result += sum(two_digit_elements[0 .. min(two_digit_elements.length,\
    \ k)]);\n    return result;\n}\n \n /////////", "{\n    import std.stdio;\n  \
    \  import std.algorithm;\n    import std.typecons;\n    assert(arr.length <= 100L);\n\
    \    assert(k <= arr.length);\n    auto sum_of_two_digits = arr.take(k).filter!(x\
    \ => x < 100).sum;\n    return sum_of_two_digits;\n}", "{\n    int index = 0;\n\
    \    long sum = 0;\n    while(k-- != 0)\n    {\n        long tmp = arr[index++];\n\
    \        if(tmp < 100 && tmp > 9)\n            sum += tmp;\n    }\n    return\
    \ sum;\n}", "{\n    long result = 0L;\n    alias k as size_t;\n    foreach(i;\
    \ 0..k)\n    {\n        auto digit_count = log10(arr[i]) + 1;\n        if(digit_count\
    \ < 3)\n        {\n            result += arr[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n    return arr.sumOf!((a) {\n        return a < 100 ? a : 0;\n\
    \    })(0, (int)k);\n}", "{\n    auto arr_k = arr[0..k];\n    auto sum = 0L;\n\
    \    foreach(num; arr_k) {\n        if(num < 100) {\n            sum += num;\n\
    \        }\n    }\n    return sum;\n}\n \n/*\n    Tests\n*/\nstatic assert(add_elements([111L,\
    \ 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L], 4L) == 24L);\nstatic assert(add_elements([111L,\
    \ 21L, 3L, 400L, 5L, 6L, 7L, 8L, 9L], 4L) == 33L);\n*/", "{\n    long total =\
    \ 0L;\n    size_t count = 0;\n    foreach(index, elem; arr)\n    {\n        if(is_two_digit(elem))\n\
    \        {\n            total += elem;\n            count++;\n        }\n    \
    \    if(count == k)\n            break;\n    }\n    return total;\n}", "{\n  \
    \  long sum = 0L;\n    int n = arr.length;\n    foreach(int idx; iota(0, min(k,\
    \ n)))\n    {\n        long num = arr[idx];\n        if (num < 100)\n        {\n\
    \            sum += num;\n        }\n    }\n    return sum;\n}", "in\n{\n    long\
    \ sum = 0L;\n    long count = 0L;\n    long i = 0L;\n    long arr_len = arr.length;\n\
    \    for (; i < arr_len; i++)\n    {\n        if (arr[i] >= 10L && arr[i] <= 99L)\n\
    \        {\n            count++;\n            sum += arr[i];\n        }\n    \
    \    if (count == k)\n        {\n            break;\n        }\n    }\n    return\
    \ sum;\n}", "{\n    long ret = 0L;\n    int cnt = 0;\n    foreach(int i; 0 ..\
    \ k)\n    {\n        ret += cast(long)arr[i];\n        if (arr[i] > 99) cnt +=\
    \ 3;\n        else if (arr[i] > 9) cnt += 2;\n        else cnt += 1;\n       \
    \ if (cnt > 2) break;\n    }\n    return ret;\n}", "{\n    // Check for invalid\
    \ parameters\n    assert(arr.length > 0);\n    assert(k > 0);\n    assert(k <=\
    \ arr.length);", "{\n    long sum = 0L;\n    for (int i = 0; i < min(k, arr.length);\
    \ i++) \n    {\n        if (arr[i] < 100L)\n            sum += arr[i];\n    }\n\
    \    return sum;\n}", "{\n  long result = 0L;\n  foreach(elem; arr[0 .. k])\n\
    \  {\n    if (elem > 99L)\n    {\n      // do nothing, ignore element greater\
    \ than 99\n    }\n    else\n    {\n      result += elem;\n    }\n  }\n  return\
    \ result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
