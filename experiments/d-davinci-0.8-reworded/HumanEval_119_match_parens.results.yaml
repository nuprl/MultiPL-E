language: d
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string stack;\n    foreach(el; lst)\n    {\n        string s =\
    \ el;\n        foreach(c; s)\n        {\n            if(c == '(')\n          \
    \      stack ~= '(';\n            else if(c == ')')\n            {\n         \
    \       if(stack.length == 0)\n                    return \"No\";\n          \
    \      stack = stack[0..$-1];\n            }\n        }\n    }\n    return stack.length\
    \ == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpa8do_kbn.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x42907d]

    ??:? void tmpa8do_kbn.__unittest_L41_C1() [0x427e46]

    ??:? void tmpa8do_kbn.__modtest() [0x4282e8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b265]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dad]

    ??:? runModuleUnitTests [0x42e18d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429540]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string[string] dict = [\"(\": \")\", \")\": \"(\"];\n    string[]\
    \ opn = [dict.keys];\n    string[] cls = [dict.values];\n    int[] vals = [1,\
    \ -1];\n    Map!int[string] m = [opn[i]: vals[i] for i in 0..1];\n    foreach\
    \ (a; lst)\n    {\n        foreach (ch; a)\n        {\n            int count =\
    \ 0;\n            foreach (tup; m)\n            {\n                if (tup.key\
    \ == ch)\n                {\n                    count += tup.value;\n       \
    \         }\n            }\n            if (count < 0)\n            {\n      \
    \          return \"No\";\n            }\n        }\n    }\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm0t_4z43.d(27): Error: comma expected separating array initializers,
    not `for`

    /tmp/tmpm0t_4z43.d(27): Error: semicolon expected, not `i`

    /tmp/tmpm0t_4z43.d(27): Error: found `..` when expecting `;` following statement

    /tmp/tmpm0t_4z43.d(27): Error: found `]` when expecting `;` following statement

    /tmp/tmpm0t_4z43.d(27): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm0t_4z43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161386
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return lst[0].filter!\"a.canFind('(')\".length == lst[1].filter!\"\
    a.canFind(')')\".length &&\n            lst[0].filter!\"a.canFind(')')\".length\
    \ == lst[1].filter!\"a.canFind('(')\".length ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt1cxrx05.d(23): Error: no property `filter` for type `string`

    /tmp/tmpt1cxrx05.d(23): Error: no property `filter` for type `string`

    /tmp/tmpt1cxrx05.d(24): Error: no property `filter` for type `string`

    /tmp/tmpt1cxrx05.d(24): Error: no property `filter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt1cxrx05.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // start from left side of first string\n    // and right side\
    \ of second string\n    int count = 0;\n    for (int i = 0; i < lst[0].length;\
    \ i++)\n    {\n        if (lst[0][i] == '(') \n            count++;\n        else\n\
    \            count--;\n    }\n    // if count is > 0, then there are more '('\
    \ than ')'\n    // if count is < 0, then there are more ')' than '('\n    // if\
    \ count is 0, then ( and ) are balanced\n    for (int i = lst[1].length - 1; i\
    \ >= 0; i--)\n    {\n        if (lst[1][i] == '(') \n            count++;\n  \
    \      else\n            count--;\n    }\n    if (count > 0) return \"No\";\n\
    \    else return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpicitju0w.d(36): Error: cannot implicitly convert expression `lst[1].length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpicitju0w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n\tint open = 0;\n\tint close = 0;\n\tint i;\n\t\n\tforeach(s; lst)\n\
    \t{\n\t\ti = s.countUntil('(');\n\t\t\n\t\tif(i == -1)\n\t\t{\n\t\t\ti = s.countUntil(')');\n\
    \t\t\t\n\t\t\tif(i == -1)\n\t\t\t\treturn \"No\";\n\t\t\telse\n\t\t\t\tclose +=\
    \ i;\n\t\t}\n\t\telse\n\t\t\topen += i;\n\t}\n\t\n\treturn open == close ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoyn6q831.d(29): Error: no property `countUntil` for type `string`

    /tmp/tmpoyn6q831.d(33): Error: no property `countUntil` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoyn6q831.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    \n    \n    \n    \n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxgpap5dm.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f45]

    ??:? void tmpxgpap5dm.__unittest_L29_C1() [0x427b80]

    ??:? void tmpxgpap5dm.__modtest() [0x4281ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d81f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a75c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c75]

    ??:? runModuleUnitTests [0x42d5f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429394]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(string i; lst)\n    {\n        s\
    \ ~= i;\n    }\n    bool check = true;\n    int counter = 0;\n    foreach(char\
    \ c; s)\n    {\n        if(c == '(')\n        {\n            counter += 1;\n \
    \       }\n        else if(c == ')')\n        {\n            counter -= 1;\n \
    \       }\n        if(counter < 0)\n        {\n            check = false;\n  \
    \          break;\n        }\n    }\n    return (check && counter == 0) ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7shme1_y.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmp7shme1_y.__unittest_L48_C1() [0x427e06]

    ??:? void tmp7shme1_y.__modtest() [0x4282a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b261]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42e189]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42948c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int x = 0;\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9vkdxrr.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9vkdxrr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161386
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    import std.algorithm.comparison : equal;\n    import std.algorithm.mutation\
    \ : sort;\n    import std.range : chunks;\n    import std.conv : to;\n    import\
    \ std.string : join;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    // sort string, then check if (('s == ')'s\n    string s = lst[0]\
    \ ~ lst[1];\n    bool[] a = s.equal(\"(\");\n    return a.sort.chunks(2).map!(b\
    \ => tuple(b[0].to!bool, b[1].to!bool)).all!(Tuple!(bool, bool)(0, 1)).to!string;\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwo9whqmn.d(24): Error: module `std.algorithm.mutation` import `sort`
    not found

    /tmp/tmpwo9whqmn.d(32): Error: cannot implicitly convert expression `equal(s,
    "(")` of type `bool` to `bool[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwo9whqmn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    bool r = false;\n    static if (is(typeof(std.math.abs(1)) ==\
    \ int))\n    {\n        int x = 0;\n        foreach (ele; lst)\n        {\n  \
    \          foreach (c; ele)\n            {\n                if (c == '(')\n  \
    \                  x++;\n                else\n                    x--;\n    \
    \            if (x < 0) break;\n            }\n            if (x < 0) break;\n\
    \        }\n        r = x == 0;\n    }\n    else\n    {\n        import std.math\
    \ : abs;\n        int x = 0;\n        foreach (ele; lst)\n        {\n        \
    \    foreach (c; ele)\n            {\n                if (c == '(')\n        \
    \            x++;\n                else\n                    x--;\n          \
    \      if (abs(x) > 1) break;\n            }\n            if (abs(x) > 1) break;\n\
    \        }\n        r = abs(x) == 1;\n    }\n    return r ? \"Yes\" : \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph014dps1.d(68): unittest failure

    ----------------

    ??:? _d_unittestp [0x42900d]

    ??:? void tmph014dps1.__unittest_L61_C1() [0x427dd2]

    ??:? void tmph014dps1.__modtest() [0x428274]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a795]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a824]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a721]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d3d]

    ??:? runModuleUnitTests [0x42d6bd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42945c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto str1 = lst[0];\n    auto str2 = lst[1];\n    int len1 = str1.length;\n\
    \    int len2 = str2.length;\n    int cnt = 0;\n    for (int i = 0; i < len1;\
    \ i++) {\n        cnt += str1[i] == '(' ? 1 : -1;\n        if (cnt < 0) {\n  \
    \          break;\n        }\n    }\n    for (int i = 0; i < len2; i++) {\n  \
    \      cnt += str2[i] == '(' ? 1 : -1;\n        if (cnt < 0) {\n            break;\n\
    \        }\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm344h5vi.d(25): Error: cannot implicitly convert expression `str1.length`
    of type `ulong` to `int`

    /tmp/tmpm344h5vi.d(26): Error: cannot implicitly convert expression `str2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm344h5vi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // First, we use reduce to concatenate all the input strings\n\
    \    string s = reduce!((a, b) => a ~ b)(lst);\n    // Now we use fold to count\
    \ the number of open parentheses\n    // and the number of close parentheses.\
    \ If the number of open\n    // parentheses is greater than the number of close\
    \ parentheses\n    // at any point, then we return \"No\"\n    auto res = fold!((a,\
    \ x) => {\n        int c = 0;\n        x == '(' ? c++ : c--;\n        if (c <\
    \ 0) {\n            return tuple(c, \"No\");\n        }\n        return tuple(c,\
    \ a[1]);\n    })(s, tuple(0, \"Yes\"));\n    return res[1];\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpen7g7pqr.d(24): Error: template instance `reduce!((a, b) => a ~
    b)` template `reduce` is not defined

    /tmp/tmpen7g7pqr.d(29): Error: template instance `fold!((a, x) => ()

    {

    int c = 0;

    x == ''('' ? c++ : c--;

    if (c < 0)

    {

    return tuple(c, "No");

    }

    return tuple(c, a[1]);

    }

    )` template `fold` is not defined, did you mean fmod?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen7g7pqr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto check = [](string s)\n    {\n        import std.algorithm\
    \ : canFind;\n        if (s.canFind(\")\"))\n        {\n            s = s.replaceAll(\"\
    )\", \"(\");\n            int count = 0;\n            foreach (ch; s)\n      \
    \      {\n                if (ch == '(')\n                    count++;\n     \
    \           else\n                    count--;\n                if (count < 0)\n\
    \                    return false;\n            }\n            return count ==\
    \ 0;\n        }\n        else\n            return true;\n    };\n    bool first\
    \ = check(lst[0]);\n    bool second = check(lst[1]);\n    if (first && second)\n\
    \        return \"Yes\";\n    else if (first)\n        return \"No\";\n    else\n\
    \    {\n        if (lst[0][0] == '(')\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph84aqyne.d(23): Error: found `s` when expecting `,`

    /tmp/tmph84aqyne.d(24): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmph84aqyne.d(43): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph84aqyne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161386
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    foreach(i; lst)\n    {\n        if(!empty(i))\n        {\n   \
    \         auto temp = i.replace(\"(\", \"\").replace(\")\", \"\");\n         \
    \   if(temp.length != 0) return \"No\";\n        }\n    }\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps25l72r8.d(25): Error: undefined identifier `empty`

    /tmp/tmps25l72r8.d(27): Error: no property `replace` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps25l72r8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto lparen = '(';\n    auto rparen = ')';\n    auto build_parens\
    \ = [](char ch, size_t n) \n    {\n        auto nstr = \"\";\n        for (size_t\
    \ i = 0; i < n; i++)\n            nstr ~= ch;\n        return nstr;\n    };\n\
    \    auto cnt_opens = [](string s) \n    {\n        return s.count;\n    };\n\
    \    auto cnt_closes = [](string s) \n    {\n        return s.count;\n    };\n\
    \    auto s1 = lst[0];\n    auto s2 = lst[1];\n    // auto s1_opens = s1.count;\n\
    \    // auto s1_closes = s1.count;\n    // auto s2_opens = s2.count;\n    // auto\
    \ s2_closes = s2.count;\n    size_t s1_opens = cnt_opens(s1);\n    size_t s1_closes\
    \ = cnt_closes(s1);\n    size_t s2_opens = cnt_opens(s2);\n    size_t s2_closes\
    \ = cnt_closes(s2);\n    if (s1_opens == s1_closes && s2_opens == s2_closes)\n\
    \        return \"Yes\";\n    if (s1_opens == s1_closes)\n        return \"No\"\
    ;\n    if (s2_opens == s2_closes)\n        return \"No\";\n    if (s1_opens ==\
    \ s2_closes)\n        return \"Yes\";\n    if (s2_opens == s1_closes)\n      \
    \  return \"Yes\";\n    if (s1_opens > s2_closes)\n    {\n        auto ss1 = build_parens(lparen,\
    \ s1_opens - s2_closes);\n        return (s1 ~ ss1 ~ s2).count == 0 ? \"Yes\"\
    \ : \"No\";\n    }\n    if (s2_opens > s1_closes)\n    {\n        auto ss2 = build_parens(rparen\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3ik_abga.d(25): Error: found `ch` when expecting `.` following
    char

    /tmp/tmp3ik_abga.d(25): Error: found `,` when expecting identifier following `char`.

    /tmp/tmp3ik_abga.d(25): Error: found `size_t` when expecting `,`

    /tmp/tmp3ik_abga.d(26): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmp3ik_abga.d(31): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp3ik_abga.d(32): Error: found `s` when expecting `,`

    /tmp/tmp3ik_abga.d(33): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmp3ik_abga.d(35): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp3ik_abga.d(36): Error: found `s` when expecting `,`

    /tmp/tmp3ik_abga.d(37): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmp3ik_abga.d(39): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp3ik_abga.d(68): Error: found `unittest` when expecting `,`

    /tmp/tmp3ik_abga.d(85): Error: found `void` when expecting `,`

    /tmp/tmp3ik_abga.d(85): Error: found `{` when expecti'
  stdout: ''
  timestamp: 1660161386
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int l1 = lst[0].length;\n    int l2 = lst[1].length;\n    int\
    \ s1 = 0;\n    int s2 = 0;\n    int i = 0;\n    int j = 0;\n    while(i < l1 ||\
    \ j < l2)\n    {\n        while(i < l1 && lst[0][i] == '(')\n        {\n     \
    \       s1++;\n            i++;\n        }\n        while(j < l2 && lst[1][j]\
    \ == '(')\n        {\n            s2++;\n            j++;\n        }\n       \
    \ while(i < l1 && lst[0][i] == ')')\n        {\n            s1--;\n          \
    \  i++;\n        }\n        while(j < l2 && lst[1][j] == ')')\n        {\n   \
    \         s2--;\n            j++;\n        }\n        if(s1 < 0 || s2 < 0)\n \
    \           return \"No\";\n    }\n    if(s1 != 0 || s2 != 0)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp91ql5qi3.d(23): Error: cannot implicitly convert expression `lst[0].length`
    of type `ulong` to `int`

    /tmp/tmp91ql5qi3.d(24): Error: cannot implicitly convert expression `lst[1].length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp91ql5qi3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Concatenate the two strings:\n    string s = lst[0] ~ lst[1];\n\
    \    int count = 0;\n    foreach(c; s)\n    {\n        if (c == '(')\n       \
    \     count++;\n        else\n            count--;\n        if (count < 0)\n \
    \           return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n\
    }\n/*\n    // One-liner:\n    string match_parens(string[] lst) \n    {\n    \
    \    int count = 0;\n        foreach(c; lst[0] ~ lst[1])\n        {\n        \
    \    if (c == '(')\n                count++;\n            else\n             \
    \   count--;\n            if (count < 0)\n                return \"No\";\n   \
    \     }\n        return count == 0 ? \"Yes\" : \"No\";\n    }\n*/\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnvp_2g1p.d(61): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnvp_2g1p.__unittest_L54_C1() [0x427dee]

    ??:? void tmpnvp_2g1p.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(c; lst[0]) count += c == '(' ? 1 :\
    \ -1;\n    count += count < 0 ? 0 : -lst[1].length;\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt9kh3kwf.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42901d]

    ??:? void tmpt9kh3kwf.__unittest_L28_C1() [0x427de6]

    ??:? void tmpt9kh3kwf.__modtest() [0x428288]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d96b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a819]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8a8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7a5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d4d]

    ??:? runModuleUnitTests [0x42d741]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // your code here\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsw_cmcnb.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f3d]

    ??:? void tmpsw_cmcnb.__unittest_L26_C1() [0x427b7c]

    ??:? void tmpsw_cmcnb.__modtest() [0x4281a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d817]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a754]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c6d]

    ??:? runModuleUnitTests [0x42d5ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42938c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    lst[0] = \"(\" + lst[0] + \")\";\n    lst[1] = \"(\" + lst[1]\
    \ + \")\";\n    string str = lst[0] + lst[1];\n    int level = 0;\n    foreach(c;\
    \ str)\n    {\n        if(c == '(')\n            level++;\n        else if(c ==\
    \ ')')\n            level--;\n        if(level < 0)\n            return \"No\"\
    ;\n    }\n    return level == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwiac903j.d(23): Error: invalid array operation `"(" + lst[0]` (possible
    missing [])

    /tmp/tmpwiac903j.d(24): Error: invalid array operation `"(" + lst[1]` (possible
    missing [])

    /tmp/tmpwiac903j.d(25): Error: invalid array operation `lst[0] + lst[1]` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwiac903j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n  // If number of ( != number of ) return \"No\"\n  if (count(lst[0],\
    \ '(') != count(lst[1], ')'))\n    return \"No\";\n  \n  return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt6y44brf.d(24): Error: undefined identifier `count`

    /tmp/tmpt6y44brf.d(24): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt6y44brf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int openCount = 0;\n    string str = \"\";\n    foreach(string\
    \ s; lst)\n    {\n        str ~= s;\n    }\n    foreach(char ch; str)\n    {\n\
    \        if(ch == '(')\n        {\n            openCount++;\n        }\n     \
    \   else if(ch == ')')\n        {\n            openCount--;\n        }\n    }\n\
    \    if(openCount < 0)\n    {\n        return \"No\";\n    }\n    else if(openCount\
    \ > 0)\n    {\n        return \"Yes\";\n    }\n    else\n    {\n        return\
    \ \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpix24dadz.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpix24dadz.__unittest_L53_C1() [0x427c84]

    ??:? void tmpix24dadz.__modtest() [0x4282b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto c1 = lst[0].filter!(s => s == '(' || s == ')');\n    auto\
    \ c2 = lst[1].filter!(s => s == '(' || s == ')');\n    auto c3 = c1 ~ c2;\n  \
    \  auto c4 = c2 ~ c1;\n    bool balanced1 = check_balanced(c3);\n    bool balanced2\
    \ = check_balanced(c4);\n    if (balanced1 && balanced2) return \"Yes\";\n   \
    \ else if (balanced1 && !balanced2) return \"Yes\";\n    else if (!balanced1 &&\
    \ balanced2) return \"Yes\";\n    else return \"No\";\n}\n//bool check_balanced(string\
    \ s)\n//{\n//    int cnt = 0;\n//    for (size_t i = 0; i < s.length; i++) {\n\
    //        if (s[i] == '(') cnt++;\n//        else if (s[i] == ')') cnt--;\n//\
    \        if (cnt < 0) return false;\n//    }\n//    return true;\n//}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_okvdz4r.d(23): Error: no property `filter` for type `string`

    /tmp/tmp_okvdz4r.d(24): Error: no property `filter` for type `string`

    /tmp/tmp_okvdz4r.d(27): Error: undefined identifier `check_balanced`

    /tmp/tmp_okvdz4r.d(28): Error: undefined identifier `check_balanced`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_okvdz4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    foreach(str; lst)\n    {\n        enum op_parens = std.count(str,\
    \ '(');\n        enum cl_parens = std.count(str, ')');\n        if(op_parens !=\
    \ cl_parens)\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7nwm0_81.d(25): Error: undefined identifier `count` in package
    `std`

    /tmp/tmp7nwm0_81.d(26): Error: undefined identifier `count` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nwm0_81.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto p = tuple(lst[0].filter!(x => x == '(' || x == ')'), lst[1].filter!(x\
    \ => x == '(' || x == ')'));\n    return p.length ? (p[0].length > p[1].length\
    \ ? \"Yes\" : \"No\") : \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx4akbxxs.d(23): Error: no property `filter` for type `string`

    /tmp/tmpx4akbxxs.d(23): Error: no property `filter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx4akbxxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    lst = lst.map!((a) => a.filter!(x => x == '(' || x == ')').joiner).joiner;\n\
    \    //print(lst);\n    int balance = 0;\n    foreach(char c; lst)\n    {\n  \
    \      if(c == '(') ++balance;\n        else if(c == ')')\n        {\n       \
    \     if(balance == 0) return \"No\";\n            --balance;\n        }\n   \
    \ }\n    return balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvgf3lix2.d(23): Error: no property `map` for type `string[]`

    /tmp/tmpvgf3lix2.d(26): Error: cannot implicitly convert expression `__r75[__key76]`
    of type `string` to `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvgf3lix2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    bool f = true;\n    string s = \"\";\n    foreach(var str; lst)\
    \ s ~= str;\n    foreach(char c; s) if(c == '(') f = false; else if(c == ')')\
    \ f = true; else f = false;\n    return f ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_b4yld0z.d(25): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_b4yld0z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    // divide the string into brackets\n\
    \    int[][] s_arr = s.chunks(1);\n    // check if the concatenated str is good\n\
    \    int num_brackets = s_arr.length;\n    if (num_brackets % 2 != 0)\n      \
    \  return \"No\";\n    // iterate through the array\n    int num_opens = 0;\n\
    \    int num_closes = 0;\n    foreach (i; 0 .. num_brackets)\n    {\n        if\
    \ (s_arr[i] == '(')\n            num_opens++;\n        else\n            num_closes++;\n\
    \        if (num_closes > num_opens)\n            return \"No\";\n    }\n    return\
    \ num_opens == num_closes ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkx2was5h.d(25): Error: no property `chunks` for type `string`

    /tmp/tmpkx2was5h.d(27): Error: cannot implicitly convert expression `s_arr.length`
    of type `ulong` to `int`

    /tmp/tmpkx2was5h.d(35): Error: incompatible types for `(s_arr[cast(ulong)i]) ==
    (''('')`: `int[]` and `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkx2was5h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // combine strings into one\n    string combined_string = \"\"\
    ;\n    for (string s; s = lst.popFront())\n    {\n        combined_string ~= s;\n\
    \    }\n    import std.typecons;\n    // set up queue for opening parens\n   \
    \ Queue!int open_parens = new Queue!int();\n    // loop through combined string\n\
    \    for (int i = 0; i < combined_string.length; i++)\n    {\n        // if current\
    \ character is a closing parens\n        if (combined_string[i] == ')')\n    \
    \    {\n            // check if there are any open parens\n            if (open_parens.length\
    \ > 0)\n            {\n                // if there are open parens, remove front\n\
    \                open_parens.popFront();\n            }\n            // if there\
    \ are not open parens\n            else\n            {\n                // return\
    \ No\n                return \"No\";\n            }\n        }\n        // if\
    \ current character is opening parens\n        else if (combined_string[i] ==\
    \ '(')\n        {\n            // add index to queue\n            open_parens.put(i);\n\
    \        }\n    }\n    // return Yes\n    return \"Yes\";\n}\nunittest\n{\n  \
    \  alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc29of88e.d(25): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmpc29of88e.d(29): Error: found `import` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc29of88e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(var x; lst)\n \
    \   {\n        foreach(char y; x)\n        {\n            if(y == '(') open++;\n\
    \            else if(y == ')') close++;\n        }\n    }\n    if(open == close)\
    \ return \"Yes\";\n    else return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg94dkuym.d(25): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg94dkuym.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    uint len = lst.length;\n    bool[] result = new bool[len];\n \
    \   uint o = 0, c = 0;\n    foreach(i, str; lst)\n    {\n        o = c = 0;\n\
    \        foreach(ch; str)\n        {\n            if(ch == '(')\n            \
    \    o++;\n            else if(ch == ')')\n                c++;\n        }\n \
    \       result[i] = (o == c);\n    }\n    return (all!((x) => x)(result)) ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsp6hws6r.d(23): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `uint`

    /tmp/tmpsp6hws6r.d(38): Error: template instance `all!((x) => x)` template `all`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsp6hws6r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    // At most 2n\
    \ - 1 positions\n    int[int] parens = new int[2 * s1.length + 1];\n    // i is\
    \ the index in parens, not in lst\n    int i = s1.length;\n    int tmp;\n    int\
    \ j;\n    int k;\n    int m;\n    foreach (c; s1) {\n        if (c == '(') {\n\
    \            parens[i]++;\n        } else {\n            parens[i]--;\n      \
    \  }\n        i++;\n    }\n    i = s1.length;\n    foreach (c; s2) {\n       \
    \ if (c == '(') {\n            parens[i]++;\n        } else {\n            parens[i]--;\n\
    \        }\n        i--;\n    }\n    // Find all the first and last '('\n    auto\
    \ stack = new std.typecons.Stack!(int[]);\n    tmp = -1;\n    foreach (c; parens)\
    \ {\n        if (c == 1) {\n            if (tmp == -1) {\n                tmp\
    \ = c;\n            } else {\n                stack.push([tmp, c]);\n        \
    \        tmp = -1;\n            }\n        }\n    }\n    // If stack is empty,\
    \ there are no matches, return 'No'\n    if (stack.empty) {\n        return \"\
    No\";\n    }\n    // If there is an unpaired '(' in parens, return 'No'\n    if\
    \ (tmp != -1) {\n        return \"No\";\n    }\n    // Find all possible combinations\n\
    \    auto new_stack = new std.typecons.Stack!(int[]);\n    auto group_stack =\
    \ new std.typecons.Stack!(int[]);\n    j = 1;\n    k = 1;\n    m = stack.length;\n\
    \    tmp = 1;\n    int[] arr;\n    foreach (c; stack) {\n        if (j < m) {\n\
    \            // In every iteration, reset j and k to 1\n            j =\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk91ipup5.d(83): Error: expression expected, not `unittest`

    /tmp/tmpk91ipup5.d(84): Error: found `{` when expecting `;` following statement

    /tmp/tmpk91ipup5.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpk91ipup5.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk91ipup5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if(lst[0].count(\"(\") == lst[1].count(\")\"))\n    {\n      \
    \  string s = lst[0] ~ lst[1];\n        int o = 0;\n        foreach(ch; s)\n \
    \       {\n            if(ch == '(')\n                o++;\n            else\n\
    \                o--;\n            if(o < 0)\n                return \"No\";\n\
    \        }\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf332vupa.d(23): Error: no property `count` for type `string`

    /tmp/tmpf332vupa.d(23): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf332vupa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return lst[0] == \"()(())\" && lst[1] == \")\" ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppfbt8l9k.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmppfbt8l9k.__unittest_L25_C1() [0x427c38]

    ??:? void tmppfbt8l9k.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d94b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a888]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a785]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d721]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str1 = lst[0];\n    string str2 = lst[1];\n    int c1 =\
    \ 0;\n    int c2 = 0;\n    foreach(c; str1)\n    {\n        if(c == '(')\n   \
    \         c1++;\n        else\n            c1--;\n        if(c1 < 0)\n       \
    \     return \"No\";\n    }\n    foreach(c; str2)\n    {\n        if(c == '(')\n\
    \            c2++;\n        else\n            c2--;\n        if(c2 < 0)\n    \
    \        return \"No\";\n    }\n    if(c1 == c2)\n        return \"Yes\";\n  \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd7sipl3i.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpd7sipl3i.__unittest_L49_C1() [0x427cc0]

    ??:? void tmpd7sipl3i.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n\tauto s = lst[0] ~ lst[1];\n\tint oCount = 0;\n\tforeach(c; s) \n\
    \t{\n\t\tif(c == '(')\n\t\t\toCount++;\n\t\telse\n\t\t\toCount--;\n\t\tif(oCount\
    \ < 0)\n\t\t\treturn \"No\";\n\t}\n\treturn (oCount == 0) ? \"Yes\" : \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnawvezra.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnawvezra.__unittest_L36_C1() [0x427dee]

    ??:? void tmpnawvezra.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string lhs = lst[0];\n    string rhs = lst[1];\n    string rev_rhs\
    \ = rhs.dup.reverse;\n    uint lhs_count = 0;\n    uint rhs_count = 0;\n    for\
    \ (; lhs_count < lhs.length; lhs_count++) {\n        if (lhs[lhs_count] == '(')\
    \ {\n            break;\n        }\n    }\n    for (; rhs_count < rhs.length;\
    \ rhs_count++) {\n        if (rhs[rhs_count] == ')') {\n            break;\n \
    \       }\n    }\n    string new_lhs = lhs[lhs_count..$];\n    string new_rhs\
    \ = rev_rhs[rhs_count..$];\n    foreach (c; new_lhs) {\n        if (c == '(')\
    \ {\n            new_rhs ~= ')';\n        } else {\n            new_rhs ~= '(';\n\
    \        }\n    }\n    if (new_rhs.length != new_lhs.length) {\n        return\
    \ \"No\";\n    }\n    uint count = 0;\n    foreach (c; new_rhs) {\n        if\
    \ (c == '(') {\n            count++;\n        } else {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return \"No\";\n        }\n\
    \    }\n    if (count == 0) {\n        return \"Yes\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdwen3wm8.d(25): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(char[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdwen3wm8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto parens = lst.join;\n    import std.traits;\n    static if\
    \ (IsForwardRange!(typeof(parens)))\n    {\n        import std.algorithm.searching\
    \ : all;\n        if (all!(countChar('(') == countChar(')'))(parens))\n      \
    \      return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppcq01hdo.d(23): Error: no property `join` for type `string[]`

    /tmp/tmppcq01hdo.d(25): Error: template instance `IsForwardRange!(typeof(parens))`
    template `IsForwardRange` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppcq01hdo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return match_parens_helper(lst[0], lst[1]);\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphhw31wud.d(23): Error: undefined identifier `match_parens_helper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphhw31wud.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if (lst[0].count('(') == lst[0].count(')')\n        && lst[1].count('(')\
    \ == lst[1].count(')'))\n    {\n        if (lst[0].count('(') == lst[1].count('('))\n\
    \        {\n            return \"Yes\";\n        }\n        else if (lst[0].count('(')\
    \ > lst[1].count('('))\n        {\n            if (lst[0].count('(') - lst[1].count('(')\
    \ \n                == lst[1].count(')'))\n            {\n                return\
    \ \"Yes\";\n            }\n        }\n        else if (lst[0].count('(') < lst[1].count('('))\n\
    \        {\n            if (lst[1].count('(') - lst[0].count('(') \n         \
    \       == lst[0].count(')'))\n            {\n                return \"Yes\";\n\
    \            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp16m2rkki.d(23): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(23): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(24): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(24): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(26): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(26): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(30): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(30): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(32): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(32): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(33): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(38): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(38): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(40): Error: no property `count` for type `string`

    /tmp/tmp16m2rkki.d(40): Error: no property `count` for typ'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    bool isBalanced(string str)\n    {\n        int count = 0;\n \
    \       for (int i = 0; i < str.length; i++)\n        {\n            if (str[i]\
    \ == '(')\n                count++;\n            else\n                count--;\n\
    \            if (count < 0)\n                return false;\n        }\n      \
    \  return count == 0;\n    }\n    Tuple!(\"open\"=>string, \"close\"=>string)\
    \ tup = tuple(\"open\"=>\"\", \"close\"=>\"\");\n    bool hasOpen, hasClose;\n\
    \    foreach (str; lst)\n    {\n        hasOpen = hasClose = false;\n        foreach\
    \ (ch; str)\n        {\n            if (ch == '(')\n                hasOpen =\
    \ true;\n            else\n                hasClose = true;\n        }\n     \
    \   if (hasOpen)\n            tup.open ~= str;\n        if (hasClose)\n      \
    \      tup.close ~= str;\n    }\n    if (isBalanced(tup.open + tup.close))\n \
    \       return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n  \
    \  alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmf1re7_4.d(37): Error: found `=>` when expecting `)` following
    template argument list

    /tmp/tmpmf1re7_4.d(37): Error: no identifier for declarator `Tuple!"open"`

    /tmp/tmpmf1re7_4.d(37): Error: found `=>` when expecting `;` following statement

    /tmp/tmpmf1re7_4.d(37): Error: found `)` when expecting `;` following statement

    /tmp/tmpmf1re7_4.d(37): Error: found `=>` when expecting `,`

    /tmp/tmpmf1re7_4.d(37): Error: found `=>` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmf1re7_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    //\n    // You can do it here!\n    //\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpum685cs2.d(21): Error: function `tmpum685cs2.match_parens` has
    no `return` statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpum685cs2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    static struct State \n    {\n        int open;\n        bool acceptable;\n\
    \        State(int open, bool acceptable) \n        {\n            this.open =\
    \ open;\n            this.acceptable = acceptable;\n        }\n    }\n    struct\
    \ S\n    {\n        State[] prefix;\n        State[] suffix;\n        S(State[]\
    \ prefix, State[] suffix) \n        {\n            this.prefix = prefix;\n   \
    \         this.suffix = suffix;\n        }\n    }\n    auto go(string s)\n   \
    \ {\n        auto r = [](State[] p) { return new S(p, p.reverse); };\n       \
    \ return s.split(\"\").map!(a => a == \"(\"\n                    ? r([new State(1,\
    \ true)])\n                    : a == \")\"\n                    ? r([new State(0,\
    \ false)])\n                    : new S([new State(0, true)], [new State(0, true)]));\n\
    \    }\n    auto match(S[] p, S[] q)\n    {\n        auto r = new S([], []);\n\
    \        for (int i = 0; i < p.length; i++) \n        {\n            for (int\
    \ j = 0; j < q.length; j++) \n            {\n                if (p[i].suffix[0].open\
    \ == 0 && q[j].prefix[0].open == 0) \n                {\n                    r.prefix\
    \ ~= new State(0, p[i].prefix[0].acceptable && q[j].prefix[0].acceptable);\n \
    \               }\n                else if (p[i].suffix[0].open == 0) \n     \
    \           {\n                    r.prefix ~= new State(q[j].prefix[0].open,\
    \ p[i].prefix[0].acceptable && q[j].prefix[0].acceptable);\n                }\n\
    \                else if (q[j].prefix[0].open == 0) \n                {\n    \
    \                r.prefix ~= new State(p[i].suffix[0].open, p[i].prefix[0].acceptable\
    \ && q[j].prefix[0].acceptable);\n                }\n                else \n \
    \               {\n                    int max_open = max(p[i\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmzyjm9tv.d(27): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpmzyjm9tv.d(28): Error: no identifier for declarator `State(int open, bool
    acceptable)`

    /tmp/tmpmzyjm9tv.d(37): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpmzyjm9tv.d(38): Error: no identifier for declarator `S(State[] prefix,
    State[] suffix)`

    /tmp/tmpmzyjm9tv.d(45): Error: found `p` when expecting `,`

    /tmp/tmpmzyjm9tv.d(45): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpmzyjm9tv.d(45): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpmzyjm9tv.d(74): Error: found `unittest` when expecting `,`

    /tmp/tmpmzyjm9tv.d(91): Error: found `void` when expecting `,`

    /tmp/tmpmzyjm9tv.d(91): Error: found `{` when expecting `,`

    /tmp/tmpmzyjm9tv.d(91): Error: expression expected, not `}`

    /tmp/tmpmzyjm9tv.d(91): Error: found `End of File` when expecting `,`

    /tmp/tmpmzyjm9tv.d(91): Error: found `End of'
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto lefts = 0;\n    auto rights = 0;\n    foreach(c; lst[0])\n\
    \    {\n        if(c == '(')\n            lefts++;\n        else if(c == ')')\n\
    \            rights++;\n    }\n    foreach(c; lst[1])\n    {\n        if(c ==\
    \ '(')\n            lefts++;\n        else if(c == ')')\n            rights++;\n\
    \    }\n    if(lefts != rights)\n        return \"No\";\n    int n = lefts;\n\
    \    int m = rights;\n    uint sz = n + m;\n    string[] best;\n    string[] cbest;\n\
    \    auto [ret, cands] = matchParens(lst, 0, 0, 0, sz);\n    if(!ret)\n      \
    \  return \"No\";\n    foreach(cand; cands)\n    {\n        if(!best.length ||\
    \ cand.length < best.length)\n        {\n            best = cand;\n        }\n\
    \    }\n    return best;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfo9ewc3l.d(46): Error: basic type expected, not `[`

    /tmp/tmpfo9ewc3l.d(46): Error: found `,` when expecting `]`

    /tmp/tmpfo9ewc3l.d(46): Error: semicolon expected, not `]`

    /tmp/tmpfo9ewc3l.d(46): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfo9ewc3l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // assert(lst.length == 2);\n    auto s = format(\"%s%s\", lst[0],\
    \ lst[1]);\n    uint lvl = 0;\n    for (uint i = 0; i < s.length; i++) {\n   \
    \     lvl += s[i] == '(' ? 1 : -1;\n        if (lvl < 0) {\n            return\
    \ \"No\";\n        }\n    }\n    return lvl == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq7_ymfa7.d(24): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7_ymfa7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string[string] adjacents = [];\n    foreach(i, string s; lst)\n\
    \    {\n        if(adjacents.find(s) == \"\")\n            adjacents[s] = \"\"\
    ;\n        else\n            return \"Yes\";\n        adjacents[lst[(i + 1) %\
    \ lst.length]] = s;\n    }\n    return \"No\";\n}\n/*\n    The unique count problem.\n\
    \    Given an array of integers of size N. Given a number K, find a\n    contiguous\
    \ subarray of size K containing the maximum number of unique\n    integers. If\
    \ there is more than one such subarray, then print the one\n    with minimum starting\
    \ index.\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd5h1vaf9.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd5h1vaf9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    string s = \"\";\n    foreach(e;\
    \ lst) \n    {\n        s ~= e;\n    }\n    foreach(e; s) \n    {\n        if(e\
    \ == '(') \n        {\n            left++;\n        }\n        else \n       \
    \ {\n            right++;\n        }\n    }\n    int count = 0;\n    foreach(e;\
    \ s) \n    {\n        if(e == '(') \n        {\n            count++;\n       \
    \ }\n        else \n        {\n            count--;\n        }\n        if(count\
    \ < 0) \n        {\n            return \"No\";\n        }\n    }\n    if(left\
    \ == right) \n    {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpss771jb6.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290b5]

    ??:? void tmpss771jb6.__unittest_L63_C1() [0x427e7a]

    ??:? void tmpss771jb6.__modtest() [0x42831c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e42b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b2d9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b368]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b265]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428de5]

    ??:? runModuleUnitTests [0x42e201]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429504]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int counter = 0;\n    lst.each!(s => s.each!(c => \n        {\
    \ \n            if (c == '(') \n                counter += 1; \n            else\
    \ \n                counter -= 1; \n        }));\n    return counter == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6pghs6uw.d(24): Error: no property `each` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6pghs6uw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    Tuple!(int, int)(0, 0).swap(Tuple!(int, int)(-lst[0].countChar('('),\
    \ lst[1].countChar(')')));\n    return (((0 < (lst[0].countChar(')') + lst[1].countChar('(')))\
    \ || ((0 < ((lst[0].countChar('(') + lst[1].countChar('(')) - (lst[0].countChar(')')\
    \ + lst[1].countChar(')')))) && (0 < ((lst[0].countChar(')') + lst[1].countChar(')'))\
    \ - (lst[0].countChar('(') + lst[1].countChar('(')))))) ? \"No\" : \"Yes\");\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp53b353v.d(23): Error: no property `swap` for type `Tuple!(int,
    int)`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    /tmp/tmpp53b353v.d(24): Error: no property `countChar` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp53b353v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if (lst[0].count(\"(\") == lst[1].count(\")\"))\n    {\n     \
    \   int left_parens = 0;\n        int right_parens = 0;\n        foreach (paren;\
    \ lst[0] ~ lst[1])\n        {\n            if (paren == '(')\n            {\n\
    \                left_parens++;\n            }\n            else\n           \
    \ {\n                right_parens++;\n            }\n            if (right_parens\
    \ > left_parens)\n            {\n                return \"No\";\n            }\n\
    \        }\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprq8qkokz.d(23): Error: no property `count` for type `string`

    /tmp/tmprq8qkokz.d(23): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprq8qkokz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    \n    int numOpen=0;\n    int numClose=0;\n    int nLength=0;\n\
    \    string sFinal=\"No\";\n    int i=0;\n    foreach(string s; lst)\n    {\n\
    \        nLength=s.length;\n        foreach(char c; s)\n        {\n          \
    \  if(c=='(')\n            {\n                numOpen++;\n            }\n    \
    \        else\n            {\n                numClose++;\n            }\n   \
    \     }\n        if(numOpen==numClose)\n        {\n            sFinal=\"Yes\"\
    ;\n        }\n        else\n        {\n            sFinal=\"No\";\n        }\n\
    \    }\n    return sFinal;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt5_4pa0y.d(31): Error: cannot implicitly convert expression `s.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt5_4pa0y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if (lst[0].length == 0)\n    {\n        if (isBalanced(lst[1]))\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    if (lst[1].length == 0)\n    {\n        if (isBalanced(lst[0]))\n       \
    \     return \"Yes\";\n        else\n            return \"No\";\n    }\n    string\
    \ temp = lst[0] ~ lst[1];\n    if (isBalanced(temp))\n        return \"Yes\";\n\
    \    temp = lst[1] ~ lst[0];\n    if (isBalanced(temp))\n        return \"Yes\"\
    ;\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7wdkbraq.d(25): Error: undefined identifier `isBalanced`

    /tmp/tmp7wdkbraq.d(32): Error: undefined identifier `isBalanced`

    /tmp/tmp7wdkbraq.d(38): Error: undefined identifier `isBalanced`

    /tmp/tmp7wdkbraq.d(41): Error: undefined identifier `isBalanced`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7wdkbraq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    foreach(s; lst)\n    {\n       \
    \ if (s.count(\")\") > s.count(\"(\"))\n        {\n            result = \"No\"\
    ;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4pzf6re9.d(26): Error: no property `count` for type `string`

    /tmp/tmp4pzf6re9.d(26): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4pzf6re9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    import std.algorithm : count;\n    int c = lst.map!(s => count(s,\
    \ '(')).reduce!(a, b => a - b);\n    int o = lst.map!(s => count(s, ')')).reduce!(a,\
    \ b => a - b);\n    return c == 0 && o == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphxf61yxv.d(24): Error: no property `map` for type `string[]`

    /tmp/tmphxf61yxv.d(25): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphxf61yxv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    const size_t l1 = lst[0].length;\n    const size_t l2 = lst[1].length;\n\
    \    const size_t lsum = l1 + l2;\n    const size_t n = 2 * lsum + 2;\n    uint\
    \ nw = 1 << lsum;\n    uint[size_t][size_t] dp = void;\n    foreach (i; 0 .. nw)\
    \ \n    {\n        foreach (j; 0 .. n) \n        {\n            dp[i][j] = (uint.max)();\n\
    \        }\n    }\n    dp[0][0] = 0;\n    foreach (mask; 0 .. nw) \n    {\n  \
    \      foreach (j; 0 .. n) \n        {\n            if (dp[mask][j] == (uint.max)())\
    \ \n            {\n                continue;\n            }\n            auto\
    \ open = j;\n            auto close = n - j;\n            auto left = dp[mask][j];\n\
    \            foreach (i; 0 .. lsum) \n            {\n                if ((mask\
    \ & (1 << i)) != 0) \n                {\n                    continue;\n     \
    \           }\n                auto tmask = mask | (1 << i);\n               \
    \ auto tleft = left;\n                if (i < l1) \n                {\n      \
    \              if (lst[0][i] == '(') \n                    {\n               \
    \         open += 1;\n                    }\n                    else \n     \
    \               {\n                        close += 1;\n                     \
    \   if (close > open) \n                        {\n                          \
    \  tleft += 1;\n                        }\n                    }\n           \
    \     }\n                else \n                {\n                    if (lst[1][i\
    \ - l1] == '(') \n                    {\n                        open += 1;\n\
    \                    }\n                    else \n                    {\n   \
    \                     close += 1;\n                        if (close > open) \n\
    \                        {\n                            tleft += 1;\n        \
    \                }\n                    }\n                }\n               \
    \ dp[tmask][open] = min(dp[tmask][open], tleft);\n            }\n        }\n \
    \   }\n    return dp[nw - 1][n\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx8e_2f3w.d(91): Error: found `unittest` when expecting `,`

    /tmp/tmpx8e_2f3w.d(108): Error: found `void` when expecting `,`

    /tmp/tmpx8e_2f3w.d(108): Error: found `{` when expecting `,`

    /tmp/tmpx8e_2f3w.d(108): Error: expression expected, not `}`

    /tmp/tmpx8e_2f3w.d(108): Error: found `End of File` when expecting `,`

    /tmp/tmpx8e_2f3w.d(108): Error: found `End of File` when expecting `]`

    /tmp/tmpx8e_2f3w.d(108): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmpx8e_2f3w.d(108): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx8e_2f3w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    for (int i = 0; i < lst[0].length;\
    \ i++)\n    {\n        if (lst[0][i] == '(')\n            left++;\n        else\n\
    \            right++;\n    }\n    for (int i = 0; i < lst[1].length; i++)\n  \
    \  {\n        if (lst[1][i] == '(')\n            left++;\n        else\n     \
    \       right++;\n    }\n    if (left == right)\n        return \"Yes\";\n   \
    \ return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp527op141.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmp527op141.__unittest_L43_C1() [0x428146]

    ??:? void tmp527op141.__modtest() [0x428300]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int openBrackets = 0;\n    int closedBrackets = 0;\n    foreach(item;\
    \ lst)\n    {\n        //Iterate through the list of strings, and count open and\
    \ closed brackets.\n        foreach(i; item)\n        {\n            if(i == '(')\n\
    \            {\n                openBrackets++;\n            }\n            else\
    \ if(i == ')')\n            {\n                closedBrackets++;\n           \
    \ }\n        }\n    }\n    //If the number of closed brackets is equal to the\
    \ number of open brackets,\n    //then there is a way to make a good string, return\
    \ \"Yes\".\n    if(closedBrackets == openBrackets)\n    {\n        return \"Yes\"\
    ;\n    }\n    //Otherwise, return \"No\".\n    else\n    {\n        return \"\
    No\";\n    }\n    \n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpej64kgl7.d(66): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmpej64kgl7.__unittest_L53_C1() [0x4280ae]

    ??:? void tmpej64kgl7.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(c; (lst[0] ~ lst[1]).front)\n    {\n\
    \        if(c == '(')\n            count++;\n        else if(c == ')')\n     \
    \       count--;\n        if(count < 0)\n            return \"No\";\n    }\n \
    \   return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpua5ztox2.d(24): Error: no property `front` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpua5ztox2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    import std.range : join, split;\n    string str1 = lst[0];\n \
    \   string str2 = lst[1];\n    //\n    if (str1 == \"\") return str2;\n    if\
    \ (str2 == \"\") return str1;\n    //\n    size_t totalL = str1.length + str2.length;\n\
    \    size_t countP = str1.count!`(` + str2.count!`(`;\n    size_t countN = str1.count!`)`\
    \ + str2.count!`)`;\n    //\n    if (countP == countN) return \"Yes\";\n    //\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp23gkjh6h.d(31): Error: no property `count` for type `string`

    /tmp/tmp23gkjh6h.d(31): Error: no property `count` for type `string`

    /tmp/tmp23gkjh6h.d(32): Error: no property `count` for type `string`

    /tmp/tmp23gkjh6h.d(32): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23gkjh6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int n = 0;\n    foreach(e; lst) \n    {\n        foreach(c; e)\n\
    \        {\n            if(c == '(') n++;\n            else n--;\n        }\n\
    \    }\n    return n == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeu20qs5f.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmpeu20qs5f.__unittest_L34_C1() [0x4280a2]

    ??:? void tmpeu20qs5f.__modtest() [0x42825c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    import std.regex;\n    import std.algorithm;\n    import std.conv;\n\
    \    import std.format;\n    if (mix(lst[0]) == mix(lst[1]))\n        return \"\
    Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo289v51n.d(27): Error: undefined identifier `mix`, did you mean
    template `max(T...)(T args) if (T.length >= 2)`?

    /tmp/tmpo289v51n.d(27): Error: undefined identifier `mix`, did you mean template
    `max(T...)(T args) if (T.length >= 2)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo289v51n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"No\";\n    int open = 0;\n    int close = 0;\n\
    \    foreach(i; 0 .. lst.length)\n    {\n        open += count(lst[i], '(');\n\
    \        close += count(lst[i], ')');\n    }\n    if (open == close)\n    {\n\
    \        result = \"Yes\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcut6zykb.d(28): Error: undefined identifier `count`

    /tmp/tmpcut6zykb.d(29): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcut6zykb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    enum Paren : char { LEFT = '(', RIGHT = ')' };\n    struct Node\
    \ \n    {\n        int left;\n        int right;\n        Paren parent;\n    \
    \    Node leftChild;\n        Node rightChild;\n        this(int l, int r, Paren\
    \ parent, Node left, Node right) \n        {\n            this.left = l;\n   \
    \         this.right = r;\n            this.parent = parent;\n            this.leftChild\
    \ = left;\n            this.rightChild = right;\n        }\n    }\n    string\
    \ s = lst[0] ~ lst[1];\n    int len = s.length;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach (c; s) \n    {\n        if (c == Paren.LEFT) \n        {\n\
    \            open++;\n        } \n        else \n        {\n            close++;\n\
    \        }\n    }\n    if (open != close) \n    {\n        return \"No\";\n  \
    \  }\n    /*\n        if the string is correct:\n        if you have an even number\
    \ of characters then you can shift\n        half to the left and half to the right\
    \ and it will be correct.\n        if you have an odd number of characters then\
    \ you can shift\n        (n+1)/2 to the left and (n-1)/2 to the right and it will\
    \ be correct.\n    */\n    if (len % 2 == 0) \n    {\n        return \"Yes\";\n\
    \    } \n    else \n    {\n        return \"No\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxruzl_0q.d(23): Deprecation: use `{ }` for an empty statement,
    not `;`

    /tmp/tmpxruzl_0q.d(24): Error: struct `tmpxruzl_0q.match_parens.Node` cannot have
    field `leftChild` with same struct type

    /tmp/tmpxruzl_0q.d(41): Error: cannot implicitly convert expression `s.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxruzl_0q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if (lst[0].length < lst[1].length)\n    {\n        auto tmp =\
    \ lst[0];\n        lst[0] = lst[1];\n        lst[1] = tmp;\n    }\n    foreach\
    \ (i, ch; lst[0])\n    {\n        if (ch == '(')\n        {\n            lst[0]\
    \ = lst[0][i+1..$];\n            break;\n        }\n    }\n    foreach (i, ch;\
    \ lst[1])\n    {\n        if (ch == ')')\n        {\n            lst[1] = lst[1][i+1..$];\n\
    \            break;\n        }\n    }\n    int x = lst[0].length;\n    int y =\
    \ lst[1].length;\n    int[int[]] dp = new int[x+1][y+1];\n    foreach (i; 0..x+1)\n\
    \    {\n        dp[i][0] = 0;\n    }\n    foreach (i; 0..y+1)\n    {\n       \
    \ dp[0][i] = 0;\n    }\n    foreach (i; 1..x+1)\n    {\n        foreach (j; 1..y+1)\n\
    \        {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            if\
    \ (lst[0][i-1] == '(' && lst[1][j-1] == ')')\n            {\n                dp[i][j]\
    \ = max(dp[i][j], 2 + dp[i-1][j-1]);\n            }\n        }\n    }\n    return\
    \ dp[x][y] > 0 ? \"Yes\" : \"No\";\n}\n/*\n    You are given an array of two strings,\
    \ both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n\
    \    Your job is to check if it is possible to concatenate the two strings in\n\
    \    some order, that the resulting string will be good.\n    A string S is considered\
    \ to be good if and\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwzcx7xhv.d(69): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwzcx7xhv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int i, j, k, len, open, close;\n    string one, two;\n    bool\
    \ a, b;\n    auto tuple = typeof(tuple(one, two))(lst[0], lst[1]);\n    tie(one,\
    \ two) = tuple;\n    len = one.length;\n    for (i = 0; i < len; i++) {\n    \
    \    a = true;\n        b = true;\n        open = 0;\n        close = 0;\n   \
    \     for (j = 0; j < i; j++) {\n            if (one[j] == '(') {\n          \
    \      open++;\n            } else {\n                close++;\n            }\n\
    \            if (open < close) {\n                a = false;\n               \
    \ break;\n            }\n        }\n        if (a) {\n            open = 0;\n\
    \            close = 0;\n            for (j = 0; j < i; j++) {\n             \
    \   if (two[j] == '(') {\n                    open++;\n                } else\
    \ {\n                    close++;\n                }\n                if (open\
    \ < close) {\n                    b = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (a && b) {\n           \
    \ open = 0;\n            close = 0;\n            for (j = i; j < len; j++) {\n\
    \                if (one[j] == '(') {\n                    open++;\n         \
    \       } else {\n                    close++;\n                }\n          \
    \      if (open < close) {\n                    a = false;\n                 \
    \   break;\n                }\n            }\n            if (a) {\n         \
    \       open = 0;\n                close = 0;\n                for (j = i; j <\
    \ len; j++) {\n                    if (two[j] == '(') {\n                    \
    \    open++;\n                    } else {\n                        close++;\n\
    \                    }\n                    if (open < close) {\n            \
    \            b = false;\n                        break;\n                    }\n\
    \                }\n            }\n        }\n        if (a && b) {\n        \
    \    return \"Yes\";\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp4a0bpk3.d(27): Error: undefined identifier `tie`

    /tmp/tmpp4a0bpk3.d(28): Error: cannot implicitly convert expression `one.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp4a0bpk3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return (canConcat(lst[0], lst[1]) ? \"Yes\" : \"No\");\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmping4epsj.d(23): Error: undefined identifier `canConcat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmping4epsj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int n1 = lst[0].length;\n    int n2 = lst[1].length;\n    int\
    \ i = 0;\n    int j = 0;\n    int c1 = 0;\n    int c2 = 0;\n    int c = 0;\n \
    \   while(i < n1)\n    {\n        if(lst[0][i] == '(')\n            c1++;\n  \
    \      else\n            c1--;\n        i++;\n    }\n    while(j < n2)\n    {\n\
    \        if(lst[1][j] == '(')\n            c2++;\n        else\n            c2--;\n\
    \        j++;\n    }\n    c = c1 + c2;\n    if(c < 0)\n        return \"No\";\n\
    \    else\n        return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfuxkmrca.d(23): Error: cannot implicitly convert expression `lst[0].length`
    of type `ulong` to `int`

    /tmp/tmpfuxkmrca.d(24): Error: cannot implicitly convert expression `lst[1].length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfuxkmrca.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n  int balance = 0;\n  for (int i = 0; i < lst[0].length; i++) \n \
    \ {\n    if (lst[0][i] == '(') \n    {\n      balance++;\n    } \n    else \n\
    \    {\n      balance--;\n    }\n  }\n  for (int i = 0; i < lst[1].length; i++)\
    \ \n  {\n    if (lst[1][i] == '(') \n    {\n      balance++;\n    } \n    else\
    \ \n    {\n      balance--;\n    }\n  }\n  return balance == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphqk76ob3.d(61): unittest failure

    ----------------

    ??:? _d_unittestp [0x42908d]

    ??:? void tmphqk76ob3.__unittest_L48_C1() [0x42813e]

    ??:? void tmphqk76ob3.__modtest() [0x4282f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428de6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a889]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a918]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a815]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dbd]

    ??:? runModuleUnitTests [0x42d7b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429550]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto chars = lst.joiner.join;\n    auto left = 0;\n    foreach(i,\
    \ ch; chars) \n    {\n        left += (ch == '(') ? 1 : -1;\n        if (left\
    \ < 0) return \"No\";\n    }\n    return left == 0 ? \"Yes\" : \"No\";\n}\n//\
    \ vim: set sw=4 ts=4 ft=d:\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsl2hij9k.d(23): Error: no property `joiner` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsl2hij9k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Write your code here\n    auto sb = appender!string();\n  \
    \  string s1 = lst[0];\n    string s2 = lst[1];\n    int balance = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            balance++;\n        else\n   \
    \         balance--;\n        if(balance < 0)\n            return \"No\";\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            balance++;\n\
    \        else\n            balance--;\n        if(balance < 0)\n            return\
    \ \"No\";\n    }\n    if(balance == 0)\n        return \"Yes\";\n    else\n  \
    \      return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgvtrtpl8.d(24): Error: template instance `appender!string` template
    `appender` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgvtrtpl8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // more readable:\n    // auto x = lst[0] ~ lst[1];\n    auto\
    \ x = lst[0] ~ lst[1];\n    auto s = 0;\n    foreach (c; x) s += c == '(' ? 1\
    \ : -1;\n    return s == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmput2qno3r.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmput2qno3r.__unittest_L30_C1() [0x4280c2]

    ??:? void tmput2qno3r.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d963]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a811]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a79d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d739]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // ***\n    // *** ERROR:\n    // ***     should return the strings\
    \ in their original order\n    // ***\n    // *** SORT lst\n    lst.sort();\n\
    \    // ***\n    // *** extract the brackets\n    // ***\n    string s = lst[0]\
    \ ~ lst[1];\n    // ***\n    // *** iterate over the brackets\n    // ***\n  \
    \  int o = 0;\n    for (int i = 0; i < s.length; i++)\n    {\n        // ***\n\
    \        // *** open bracket, bump count\n        // ***\n        if (s[i] ==\
    \ '(')\n        {\n            o++;\n        }\n        // ***\n        // ***\
    \ close bracket, bump count\n        // ***\n        else if (s[i] == ')')\n \
    \       {\n            o--;\n        }\n        // ***\n        // *** error\n\
    \        // ***\n        else\n        {\n            assert(false);\n       \
    \ }\n        // ***\n        // *** if the balance is negative, then fail\n  \
    \      // ***\n        if (o < 0)\n        {\n            return \"No\";\n   \
    \     }\n    }\n    // ***\n    // *** if there is a balance, then fail\n    //\
    \ ***\n    if (o != 0)\n    {\n        return \"No\";\n    }\n    // ***\n   \
    \ // *** it's balanced\n    // ***\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1rr1rby9.d(28): Error: no property `sort` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1rr1rby9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // for each of the strings, we'll calculate their difference between\n\
    \    // open and closed parentheses\n    int[] diffs = lst.map!((str) => str.count('(')\
    \ - str.count(')'));\n    // if the difference is negative, we're in trouble as\
    \ it means we've\n    // closed more parentheses than we opened\n    return diffs.any!((x)\
    \ => x < 0) ? \"No\" : \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdeoovjcr.d(25): Error: no property `map` for type `string[]`

    /tmp/tmpdeoovjcr.d(28): Error: no property `any` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdeoovjcr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    lst = lst.filter!(s => s.length > 0);\n    if (lst.length > 2)\
    \ \n        return \"No\";\n    if (lst.length == 1) \n        return (lst[0].count!(c\
    \ => c == '(') == lst[0].count!(c => c == ')')) ? \"Yes\" : \"No\";\n    else\
    \ if (lst[0].length == lst[1].length) \n        return (lst[0].count!(c => c ==\
    \ '(') == lst[0].count!(c => c == ')')) ? \"Yes\" : \"No\";\n    if (lst[0].count!(c\
    \ => c == '(') > lst[1].count!(c => c == '(')) \n        return match_parens([lst[0].dropOne!(c\
    \ => c == '('), lst[1]]);\n    else \n        return match_parens([lst[0], lst[1].dropOne!(c\
    \ => c == '(')]);\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3nxfzli.d(23): Error: no property `filter` for type `string[]`

    /tmp/tmph3nxfzli.d(27): Error: no property `count` for type `string`

    /tmp/tmph3nxfzli.d(27): Error: no property `count` for type `string`

    /tmp/tmph3nxfzli.d(29): Error: no property `count` for type `string`

    /tmp/tmph3nxfzli.d(29): Error: no property `count` for type `string`

    /tmp/tmph3nxfzli.d(30): Error: no property `count` for type `string`

    /tmp/tmph3nxfzli.d(30): Error: no property `count` for type `string`

    /tmp/tmph3nxfzli.d(31): Error: no property `dropOne` for type `string`

    /tmp/tmph3nxfzli.d(33): Error: no property `dropOne` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3nxfzli.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string first = lst[0];\n    string second = lst[1];\n    string\
    \ concat = lst[0] ~ lst[1];\n    if (concat.empty) \n    {\n        return \"\
    Yes\";\n    }\n    string b_concat = lst[1] ~ lst[0];\n    int f_count = 0;\n\
    \    int s_count = 0;\n    for (immutable char c : concat) \n    {\n        if\
    \ (c == '(') \n        {\n            f_count++;\n        }\n        else \n \
    \       {\n            f_count--;\n        }\n        if (f_count < 0) \n    \
    \    {\n            return \"No\";\n        }\n    }\n    for (immutable char\
    \ c : b_concat) \n    {\n        if (c == '(') \n        {\n            s_count++;\n\
    \        }\n        else \n        {\n            s_count--;\n        }\n    \
    \    if (s_count < 0) \n        {\n            return \"No\";\n        }\n   \
    \ }\n    if (f_count != 0 || s_count != 0) \n    {\n        return \"No\";\n \
    \   }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxmjvwpkx.d(33): Error: semicolon expected, not `:`

    /tmp/tmpxmjvwpkx.d(33): Error: expression expected, not `:`

    /tmp/tmpxmjvwpkx.d(33): Error: found `concat` when expecting `;` following `for`
    condition

    /tmp/tmpxmjvwpkx.d(48): Error: semicolon expected, not `:`

    /tmp/tmpxmjvwpkx.d(48): Error: expression expected, not `:`

    /tmp/tmpxmjvwpkx.d(48): Error: found `b_concat` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxmjvwpkx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    char[][] parens = lst.map!((a)=>a.dup).array;\n    char[][] front\
    \ = lst.map!((a)=>a.dup).array;\n    char[][] back = lst.map!((a)=>a.dup).array;\n\
    \    int i = 0;\n    while(i<parens.length) {\n        parens[i] = parens[i].dup;\n\
    \        front[i] = front[i].dup;\n        back[i] = back[i].dup;\n        i++;\n\
    \    }\n    string[] valid = [];\n    foreach(i; 0..3) {\n        if(i & 1) {\n\
    \            valid.insert(0, \"(\");\n        } else {\n            valid.insert(0,\
    \ \")\");\n        }\n        if(i & 2) {\n            valid.insert(0, \"(\");\n\
    \        } else {\n            valid.insert(0, \")\");\n        }\n    }\n   \
    \ valid = valid.dup;\n    foreach(bool isFirst; true, false) {\n        foreach(string\
    \ str; valid) {\n            char[][] rparens = parens.dup;\n            char[][]\
    \ rfront = front.dup;\n            char[][] rback = back.dup;\n            int\
    \ ri = 0;\n            while(ri<rparens.length) {\n                rparens[ri]\
    \ = rparens[ri].dup;\n                rfront[ri] = rfront[ri].dup;\n         \
    \       rback[ri] = rback[ri].dup;\n                ri++;\n            }\n   \
    \         if(isFirst) {\n                foreach(char c; str) {\n            \
    \        if(c == '(') {\n                        foreach(int q; 0..rfront.length)\
    \ {\n                            rfront[q].insert(0, c);\n                   \
    \     }\n                    } else {\n                        foreach(int q;\
    \ 0..rback.length) {\n                            rback[q].insert(0, c);\n   \
    \                     }\n                    }\n                }\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppab5a5h3.d(71): Error: found `unittest` instead of statement

    /tmp/tmppab5a5h3.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppab5a5h3.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppab5a5h3.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppab5a5h3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return ( lst[0].count('(') == lst[1].count(')') ) ? \"Yes\" :\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80unik4v.d(23): Error: no property `count` for type `string`

    /tmp/tmp80unik4v.d(23): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80unik4v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if(lst[0].length == 0 && lst[1].length == 0)\n        return \"\
    Yes\";\n    else if(lst[0].length == 0)\n    {\n        if(!__traits(compiles,\
    \ concatenate(\"\", lst[1])))\n            return \"No\";\n        else\n    \
    \        return \"Yes\";\n    }\n    else if(lst[1].length == 0)\n    {\n    \
    \    if(!__traits(compiles, concatenate(\"\", lst[0])))\n            return \"\
    No\";\n        else\n            return \"Yes\";\n    }\n    else if(lst[0].length\
    \ == 1 && lst[1].length == 1)\n    {\n        if(lst[0] == \"(\" && lst[1] ==\
    \ \")\")\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n    else if(lst[0].length == 1)\n    {\n        if(lst[0] == \"(\" &&\
    \ !__traits(compiles, concatenate(\"\", lst[1])))\n            return \"No\";\n\
    \        else if(lst[0] == \")\" && __traits(compiles, concatenate(\"\", lst[1])))\n\
    \            return \"No\";\n        else\n            return \"Yes\";\n    }\n\
    \    else if(lst[1].length == 1)\n    {\n        if(lst[1] == \"(\" && !__traits(compiles,\
    \ concatenate(\"\", lst[0])))\n            return \"No\";\n        else if(lst[1]\
    \ == \")\" && __traits(compiles, concatenate(\"\", lst[0])))\n            return\
    \ \"No\";\n        else\n            return \"Yes\";\n    }\n    else\n    {\n\
    \        if(!__traits(compiles, concatenate(\"\", lst[0])))\n        {\n     \
    \       string a =  lst[0].idup;\n            string b =  lst[1].idup;\n     \
    \       a ~= b[0];\n            b = b[1..$];\n            lst[0] = a;\n\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplxnhme43.d(74): Error: found `unittest` instead of statement

    /tmp/tmplxnhme43.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmplxnhme43.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplxnhme43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // First, we need to check if both strings are correct\n    //\
    \ on their own.\n    if ( isGood(lst[0]) && isGood(lst[1]) )\n    {\n        //\
    \ If they are, then we need to check all the\n        // possible combinations.\n\
    \        int len1 = lst[0].length;\n        int len2 = lst[1].length;\n      \
    \  bool good1 = isGood(lst[0] ~ lst[1]);\n        bool good2 = isGood(lst[1] ~\
    \ lst[0]);\n        if (good1 || good2)\n        {\n            return \"Yes\"\
    ;\n        }\n        else\n        {\n            return \"No\";\n        }\n\
    \    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps__u75fk.d(25): Error: undefined identifier `isGood`

    /tmp/tmps__u75fk.d(25): Error: undefined identifier `isGood`

    /tmp/tmps__u75fk.d(29): Error: cannot implicitly convert expression `lst[0].length`
    of type `ulong` to `int`

    /tmp/tmps__u75fk.d(30): Error: cannot implicitly convert expression `lst[1].length`
    of type `ulong` to `int`

    /tmp/tmps__u75fk.d(31): Error: undefined identifier `isGood`

    /tmp/tmps__u75fk.d(32): Error: undefined identifier `isGood`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps__u75fk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr9wm3hle.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f45]

    ??:? void tmpr9wm3hle.__unittest_L25_C1() [0x427b80]

    ??:? void tmpr9wm3hle.__modtest() [0x4281ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d81f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a75c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c75]

    ??:? runModuleUnitTests [0x42d5f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429394]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string _ = (lst[0] ~ lst[1]);\n    uint idx = 0;\n    bool pass\
    \ = true;\n    for (size_t i = 0; i < _.length; i++) {\n        if (_[i] == '(')\
    \ {\n            idx++;\n        } else {\n            idx--;\n        }\n   \
    \     if (idx < 0) {\n            pass = false;\n            break;\n        }\n\
    \    }\n    if (idx == 0 && pass) {\n        return \"Yes\";\n    }\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkpagjai9.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429035]

    ??:? void tmpkpagjai9.__unittest_L42_C1() [0x4280e2]

    ??:? void tmpkpagjai9.__modtest() [0x42829c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d983]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a831]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d65]

    ??:? runModuleUnitTests [0x42d759]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    import std.algorithm;\n    int sz = lst.reduce!((x, y) => x +\
    \ y).length;\n    if (sz % 2 == 1)\n        return \"No\";\n    if (lst[0].count!\"\
    (\" != lst[1].count!\"(\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppmq5tkzy.d(24): Error: invalid array operation `x + y` (possible
    missing [])

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/meta.d(803):        instantiated
    from here: `F!(__lambda2)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(2843):        instantiated
    from here: `staticMap!(ReduceSeedType, __lambda2)`

    /tmp/tmppmq5tkzy.d(24):        instantiated from here: `reduce!(string[])`

    /tmp/tmppmq5tkzy.d(27): Error: template `std.algorithm.searching.count` cannot
    deduce function from argument types `!("(")(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/searching.d(633):        `std.algorithm.searching.count(alias
    pred = "a == b", Range, E)(Range haystack, E nee'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if (lst[0].length > lst[1].length) \n    {\n        return match_parens(lst[1\
    \ .. $].array() ~ lst[0 .. 1].array());\n    }\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpejusq0rf.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpejusq0rf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161387
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string[] open = [\"(\", \")\", \"()\"];\n    string[] close =\
    \ [\")\", \"(\", \"()\"];\n    auto str_open = join(lst[0]);\n    auto str_close\
    \ = join(lst[1]);\n    int c1 = std.algorithm.count(str_open, open[0]);\n    int\
    \ c2 = std.algorithm.count(str_open, open[1]);\n    int c3 = std.algorithm.count(str_open,\
    \ open[2]);\n    int c4 = std.algorithm.count(str_close, close[0]);\n    int c5\
    \ = std.algorithm.count(str_close, close[1]);\n    int c6 = std.algorithm.count(str_close,\
    \ close[2]);\n    return c1 - c4 == 0 && c2 - c5 == 0 && c3 - c6 == 0? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7rbc3q5k.d(25): Error: undefined identifier `join`, did you mean
    function `main`?

    /tmp/tmp7rbc3q5k.d(26): Error: undefined identifier `join`, did you mean function
    `main`?

    /tmp/tmp7rbc3q5k.d(27): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp7rbc3q5k.d(28): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp7rbc3q5k.d(29): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp7rbc3q5k.d(30): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp7rbc3q5k.d(31): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp7rbc3q5k.d(32): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7rbc3q5k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    bool result = false;\n    static struct Stack(T) { T[] data; alias\
    \ data this; }\n    auto stack = Stack!(char)();\n    auto openParen = '(';\n\
    \    auto closeParen = ')';\n    int opens = 0;\n    int closes = 0;\n    for\
    \ (int i = 0; i < lst.length; i++)\n    {\n        for (char c : lst[i])\n   \
    \     {\n            if (c == openParen)\n            {\n                stack.data\
    \ ~= c;\n                opens++;\n            }\n            else if (c == closeParen)\n\
    \            {\n                closes++;\n                if (stack.data.length\
    \ > 0)\n                {\n                    stack.data.popBack();\n       \
    \         }\n            }\n        }\n    }\n    if (stack.data.length == 0 &&\
    \ opens > closes)\n    {\n        result = true;\n    }\n    return result ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe1afwvsv.d(32): Error: semicolon expected, not `:`

    /tmp/tmpe1afwvsv.d(32): Error: expression expected, not `:`

    /tmp/tmpe1afwvsv.d(32): Error: found `lst` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe1afwvsv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n\tint arr[int] = [];\n\tint tmp = 0;\n\tfor (int i = 0; i < lst.length;\
    \ i++)\n\t{\n\t\tfor (int j = 0; j < lst[i].length; j++)\n\t\t{\n\t\t\tif (lst[i][j]\
    \ == '(')\n\t\t\t\ttmp++;\n\t\t\telse\n\t\t\t\ttmp--;\n\t\t\tif (tmp < 0)\n\t\t\
    \t\treturn \"No\";\n\t\t}\n\t\tarr ~= tmp;\n\t\ttmp = 0;\n\t}\n\tif (arr[0] ==\
    \ arr[1])\n\t\treturn \"Yes\";\n\treturn \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwr3jbpgu.d(23): Deprecation: instead of C-style syntax, use D-style
    syntax `int[int] arr`

    /tmp/tmpwr3jbpgu.d(23): Error: cannot have associative array key of `void`

    /tmp/tmpwr3jbpgu.d(36): Error: cannot append type `int` to type `int[int]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwr3jbpgu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(a; lst)\n    {\n        foreach(b;\
    \ a)\n        {\n            if(b == '(')\n                count++;\n        \
    \    else\n                count--;\n        }\n    }\n    return count == 0 ?\
    \ \"Yes\" : \"No\";\n}\n/*\n    Write a function that returns all permutations\
    \ of a given list, the \n    permutations can be output in any order. \n    Assume\
    \ that all items in the list are unique.\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq3k318fq.d(36): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq3k318fq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto l = lst[0];\n    auto r = lst[1];\n    int lp = count(l,\
    \ '(');\n    int rp = count(r, ')');\n    // (...)()\n    if (lp > rp)\n     \
    \   return \"Yes\";\n    // ...(...)\n    if (lp == rp)\n        return \"Yes\"\
    ;\n    // ...)(...)\n    if (lp < rp)\n        return \"No\";\n    return \"\"\
    ;\n}\nstring match_parens(string[] lst) \n{\n    auto ans = \"No\";\n    int cnt\
    \ = 0;\n    foreach (i, v; lst)\n    {\n        auto r = v.retro;\n        cnt\
    \ += r.count('(') - r.count(')');\n        if (cnt < 0)\n            return ans;\n\
    \    }\n    if (cnt == 0)\n        ans = \"Yes\";\n    return ans;\n}\n// another\
    \ variant\nstring match_parens(string[] lst) \n{\n    return lst[0].retro.count('(')\
    \ > lst[1].retro.count(')') ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi1gvl6zg.d(25): Error: undefined identifier `count`

    /tmp/tmpi1gvl6zg.d(26): Error: undefined identifier `count`

    /tmp/tmpi1gvl6zg.d(44): Error: no property `retro` for type `string`

    /tmp/tmpi1gvl6zg.d(56): Error: no property `retro` for type `string`

    /tmp/tmpi1gvl6zg.d(56): Error: no property `retro` for type `string`

    /tmp/tmpi1gvl6zg.d(62): Error: `tmpi1gvl6zg.match_parens` called with argument
    types `(string[])` matches both:

    /tmp/tmpi1gvl6zg.d(21):     `tmpi1gvl6zg.match_parens(string[] lst)`

    and:

    /tmp/tmpi1gvl6zg.d(54):     `tmpi1gvl6zg.match_parens(string[] lst)`

    /tmp/tmpi1gvl6zg.d(63): Error: `tmpi1gvl6zg.match_parens` called with argument
    types `(string[])` matches both:

    /tmp/tmpi1gvl6zg.d(21):     `tmpi1gvl6zg.match_parens(string[] lst)`

    and:

    /tmp/tmpi1gvl6zg.d(54):     `tmpi1gvl6zg.match_parens(string[] lst)`

    /tmp/tmpi1gvl6zg.d(64): Error: `tmpi1gvl6zg.match_parens` called with argument
    types `(string[])` matches both:

    /tmp/tmpi1gvl6zg.d(21):     `tmpi1gvl6zg.match_parens(string[] lst)`

    and:

    /'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s = lst[0];\n    auto t = lst[1];\n    int len1 = s.length;\n\
    \    int len2 = t.length;\n    int tlen = len1 + len2;\n    int open = 0;\n  \
    \  int close = 0;\n    if(!s.empty) \n    {\n        foreach(i;0..len1) \n   \
    \     {\n            if(s[i] == '(') open++;\n            else close++;\n    \
    \    }\n    }\n    if(!t.empty) \n    {\n        foreach(i;0..len2) \n       \
    \ {\n            if(t[i] == '(') open++;\n            else close++;\n        }\n\
    \    }\n    if(open == close) return \"Yes\";\n    else return \"No\";\n}\n/*\n\
    \    A \"cookie-cutter\" is a two-dimensional shape that can be used to cut\n\
    \    out a shape from a larger piece of dough.\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjadredy5.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjadredy5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if (lst[0].length < lst[1].length) \n    {\n        return match_parens(lst[1..$].array);\n\
    \    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4tscufti.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4tscufti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int firstOpen\
    \ = s1.indexOf('(');\n    int secondOpen = s2.indexOf('(');\n    if (firstOpen\
    \ == -1 && secondOpen == -1)\n        return \"Yes\";\n    else if (firstOpen\
    \ == -1)\n        s1 = s2;\n    int firstClose = s1.indexOf(')');\n    if (firstClose\
    \ == -1)\n        return \"No\";\n    int secondClose = s2.indexOf(')');\n   \
    \ if (secondClose == -1)\n        s2 = s1;\n    else\n        s1 = s2;\n    int\
    \ firstOpen1 = s1.indexOf('(');\n    int secondOpen1 = s2.indexOf('(');\n    if\
    \ (firstOpen1 == -1 && secondOpen1 == -1)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnbc9caji.d(25): Error: no property `indexOf` for type `string`

    /tmp/tmpnbc9caji.d(26): Error: no property `indexOf` for type `string`

    /tmp/tmpnbc9caji.d(31): Error: no property `indexOf` for type `string`

    /tmp/tmpnbc9caji.d(34): Error: no property `indexOf` for type `string`

    /tmp/tmpnbc9caji.d(39): Error: no property `indexOf` for type `string`

    /tmp/tmpnbc9caji.d(40): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnbc9caji.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string x1 = lst[0];\n    string x2 = lst[1];\n    bool open_before_close(string\
    \ s)\n    {\n        foreach(i; 0 .. s.length)\n        {\n            if(s[i]\
    \ == ')' && s[i+1 .. $] != \"\")\n            {\n                return false;\n\
    \            }\n        }\n        return true;\n    }\n    bool same_open_close(string\
    \ s)\n    {\n        int open_count = 0;\n        int close_count = 0;\n     \
    \   foreach(c; s)\n        {\n            if(c == '(')\n            {\n      \
    \          open_count++;\n            }\n            else\n            {\n   \
    \             close_count++;\n            }\n        }\n        return open_count\
    \ == close_count;\n    }\n    string arr = x1 ~ x2;\n    if(open_before_close(arr)\
    \ && same_open_close(arr))\n    {\n        return \"Yes\";\n    }\n    else\n\
    \    {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyxhpvq4z.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x429205]

    ??:? void tmpyxhpvq4z.__unittest_L63_C1() [0x427e44]

    ??:? void tmpyxhpvq4z.__modtest() [0x428470]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aa01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a98d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f35]

    ??:? runModuleUnitTests [0x42d929]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto balanced = false;\n    auto count = 0;\n    foreach(ch; lst[0])\n\
    \    {\n        if(ch == '(')\n            count++;\n        else\n          \
    \  count--;\n        if(count < 0)\n            return \"No\";\n    }\n    balanced\
    \ = (count == 0);\n    if(!balanced)\n        return \"No\";\n    count = 0;\n\
    \    foreach(ch; lst[1])\n    {\n        if(ch == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    return (count == 0) ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7mjmkoh3.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x42909d]

    ??:? void tmp7mjmkoh3.__unittest_L49_C1() [0x427cd8]

    ??:? void tmp7mjmkoh3.__modtest() [0x428304]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9eb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428df6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a899]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a928]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a825]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dcd]

    ??:? runModuleUnitTests [0x42d7c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429560]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // TODO: Implement this function\n    // Please note that this\
    \ is the default implementation; \n    // it is not optimized for performance\n\
    \    return \"No\";\n}\nstatic void Main(string[] args) \n{\n    string result\
    \ = match_parens([\"()(\", \")\"]);\n    Console.WriteLine(result);\n}\n```\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsl05q779.d(33): Error: declaration expected, not `""`

    /tmp/tmpsl05q779.d(33): Error: unterminated string constant starting at /tmp/tmpsl05q779.d(33)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsl05q779.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{ \n    bool c_open = true;\n    bool c_close = true;\n    foreach(int\
    \ i, char item; lst[0])\n    {\n        if(item == '(')\n            c_open =\
    \ false;\n        if(item == ')')\n            c_close = false;\n    }\n    if(c_open\
    \ && c_close)\n        return \"Yes\";\n    foreach(int i, char item; lst[1])\n\
    \    {\n        if(item == '(')\n            c_open = false;\n        if(item\
    \ == ')')\n            c_close = false;\n    }\n    if(c_open && c_close)\n  \
    \      return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp39wjtj95.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x42907d]

    ??:? void tmp39wjtj95.__unittest_L45_C1() [0x427cbc]

    ??:? void tmp39wjtj95.__modtest() [0x4282e8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9cb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a879]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a908]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a805]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dad]

    ??:? runModuleUnitTests [0x42d7a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429540]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    enum parenthesis { OPEN, CLOSE\
    \ }\n    int sum = 0;\n    int[] par = s.map!(a => (parenthesis)((a == '(') ?\
    \ OPEN : CLOSE));\n    return  s.map!(a => (parenthesis)((a == '(') ? OPEN : CLOSE))\n\
    \            .reduce!(a => sum += (a == OPEN) ? 1 : -1)\n            .takeWhile!(a\
    \ => a == OPEN || a > 0)\n            .length == s.length ? \"Yes\" : \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvso4pd7u.d(26): Error: C style cast illegal, use `cast(parenthesis)(a
    == ''('' ? OPEN : CLOSE)`

    /tmp/tmpvso4pd7u.d(27): Error: C style cast illegal, use `cast(parenthesis)(a
    == ''('' ? OPEN : CLOSE)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvso4pd7u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string i; lst)\n    {\n        foreach(char\
    \ c; i)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n        }\n    }\n    return\
    \ (count == 0) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptlsgieoa.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmptlsgieoa.__unittest_L36_C1() [0x4280a6]

    ??:? void tmptlsgieoa.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string check_str = \"\";\n    foreach(s; lst) check_str ~= s;\n\
    \    bool result = true;\n    int opened = 0;\n    foreach(c; check_str) \n  \
    \  {\n        if(c == '(')\n            opened++;\n        else if(c == ')')\n\
    \            opened--;\n        if(opened < 0)\n        {\n            result\
    \ = false;\n            break;\n        }\n    }\n    return result ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8e6n9w7j.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmp8e6n9w7j.__unittest_L41_C1() [0x427e02]

    ??:? void tmp8e6n9w7j.__modtest() [0x4282a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b261]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42e189]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42948c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // get a count of each type of parenthesis\n    int leftCount,\
    \ rightCount;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n    \
    \        leftCount++;\n        else\n            rightCount++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            leftCount++;\n        else\n\
    \            rightCount++;\n    }\n    if(leftCount == rightCount)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxdt33iwx.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpxdt33iwx.__unittest_L44_C1() [0x4280fa]

    ??:? void tmpxdt33iwx.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto list = lst.retro.join();\n    int cnt = 0;\n    list.walk!(c\
    \ => c == '(' ? cnt++ : cnt--)();\n    return (cnt == 0 && list.walk!((x, y) =>\
    \ x == '(' && y == ')')().every)\n        ? \"Yes\"\n        : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp557j1rin.d(23): Error: no property `retro` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp557j1rin.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s = lst[0] ~ lst[1];\n    auto bal = lst[0].count('(') -\
    \ lst[0].count(')') + lst[1].count('(') - lst[1].count(')');\n    if (bal == 0)\n\
    \        return \"Yes\";\n    else if (bal < 0)\n        return \"No\";\n    else\n\
    \    {\n        size_t ps = 0;\n        for (size_t i = 0; i < s.length; i++)\n\
    \        {\n            if (s[i] == '(')\n                ps++;\n            else\n\
    \                ps--;\n            if (ps < 0)\n                return \"No\"\
    ;\n        }\n        return \"Yes\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2etximul.d(24): Error: no property `count` for type `string`

    /tmp/tmp2etximul.d(24): Error: no property `count` for type `string`

    /tmp/tmp2etximul.d(24): Error: no property `count` for type `string`

    /tmp/tmp2etximul.d(24): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2etximul.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return lst[0].canBeInverted() ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyud5wf6z.d(23): Error: no property `canBeInverted` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyud5wf6z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int n = lst[0].length;\n    int m = lst[1].length;\n    int[][]\
    \ dp = new int[n+1][m+1];\n    foreach(i; 0..=n)\n    {\n        foreach(j; 0..=m)\n\
    \        {\n            if(i == 0 && j == 0)\n            {\n                dp[i][j]\
    \ = 1;\n            }\n            else if(i == 0)\n            {\n          \
    \      dp[i][j] = dp[i][j-1] & (lst[1][j-1] == '(');\n            }\n        \
    \    else if(j == 0)\n            {\n                dp[i][j] = dp[i-1][j] & (lst[0][i-1]\
    \ == ')');\n            }\n            else\n            {\n                dp[i][j]\
    \ = (dp[i-1][j] & (lst[0][i-1] == ')')) | (dp[i][j-1] & (lst[1][j-1] == '('));\n\
    \            }\n        }\n    }\n    return dp[n][m] == 1 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpap_j5r9h.d(26): Error: expression expected, not `=`

    /tmp/tmpap_j5r9h.d(26): Error: found `n` when expecting `)`

    /tmp/tmpap_j5r9h.d(26): Error: found `)` instead of statement

    /tmp/tmpap_j5r9h.d(28): Error: found `..` when expecting `;` following statement

    /tmp/tmpap_j5r9h.d(28): Error: found `=` instead of statement

    /tmp/tmpap_j5r9h.d(34): Error: declaration expected, not `else`

    /tmp/tmpap_j5r9h.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpap_j5r9h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n  import std.algorithm;\n  import std.range;\n  import std.stdio;\n\
    \  string str = lst[0] ~ lst[1];\n  writeln(str);\n  int sz = str.length;\n  if(str.count!(ch\
    \ => ch == '(') != str.count!(ch => ch == ')'))\n  {\n    return \"No\";\n  }\n\
    \  else\n  {\n    int tmp = 0;\n    foreach(int i; str)\n    {\n      if(str[i]\
    \ == '(')\n      {\n        tmp += 1;\n      }\n      else\n      {\n        tmp\
    \ -= 1;\n      }\n      if(tmp < 0)\n      {\n        return \"No\";\n      }\n\
    \    }\n    return \"Yes\";\n  }\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg_20qn6u.d(28): Error: cannot implicitly convert expression `str.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_20qn6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    enum OpenParens = '(';\n    enum CloseParens = ')';\n    alias\
    \ Matched = tuple!(char, char);\n    bool input_ok = true;\n    string s = lst[0]\
    \ ~ lst[1];\n    auto sl = s.to!dchar[];\n    auto bs = BacktrackingState!(char,\
    \ Matched)();\n    int parens_count = 0;\n    foreach(c; sl)\n    {\n        switch(c)\n\
    \        {\n            case OpenParens:\n                ++parens_count;\n  \
    \              break;\n            case CloseParens:\n                --parens_count;\n\
    \                break;\n            default:\n                input_ok = false;\n\
    \                break;\n        }\n        if(parens_count < 0) input_ok = false;\n\
    \    }\n    if(!input_ok) return \"No\";\n    bs.add(sl);\n    auto res = bs.solve!((bs,\
    \ a, b) {\n        return a == OpenParens && b == CloseParens;\n    })();\n  \
    \  if(res.empty) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxmtn_by1.d(28): Error: no property `to` for type `string`

    /tmp/tmpxmtn_by1.d(29): Error: template instance `BacktrackingState!(char, Matched)`
    template `BacktrackingState` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxmtn_by1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(el; lst[0]) \n\
    \    {\n        if(el == '(')\n            left++;\n        else\n           \
    \ right++;\n    }\n    foreach(el; lst[1]) \n    {\n        if(el == '(')\n  \
    \          left++;\n        else\n            right++;\n    }\n    return left\
    \ == right ? \"Yes\" : \"No\";\n}\n// -----------------------------------------------------------------------------\n\
    string match_parens2(string[] lst) \n{\n    int good = true;\n    auto left =\
    \ lst[0].count!((x => x == '(')());\n    auto right = lst[0].count!((x => x ==\
    \ ')')());\n    good = left == right;\n    if(good) \n    {\n        left = lst[1].count!((x\
    \ => x == '(')());\n        right = lst[1].count!((x => x == ')')());\n      \
    \  good = left == right;\n    }\n    return good ? \"Yes\" : \"No\";\n}\n// -----------------------------------------------------------------------------\n\
    string match_parens3(string[] lst) \n{\n    auto left = lst[0].count!((x => x\
    \ == '(')());\n    auto right = lst[0].count!((x => x == ')')());\n    left +=\
    \ lst[1].count!((x => x == '(')());\n    right += lst[1].count!((x => x == ')')());\n\
    \    return left == right ? \"Yes\" : \"No\";\n}\n// -----------------------------------------------------------------------------\n\
    import std.conv;\nimport std.algorithm;\nimport std.range;\nimport std.array;\n\
    import std.typecons;\n/*\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp23dg2gl6.d(71): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23dg2gl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    \n    auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto S = s1\
    \ ~ s2;\n    auto parens = S.count(\"()\");\n    auto open_parens = S.count(\"\
    (\");\n    auto close_parens = S.count(\")\");\n    if (parens >= 2 && (open_parens\
    \ - close_parens) == 0)\n    {\n        return \"Yes\";\n    }\n    else\n   \
    \ {\n        return \"No\";\n    }\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkqzomvka.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkqzomvka.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int left = 0;\n    int right\
    \ = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            left++;\n\
    \        else\n            right++;\n        if(right > left)\n            return\
    \ \"No\";\n    }\n    if(left == right)\n        return \"Yes\";\n    return \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfufn5_ju.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpfufn5_ju.__unittest_L39_C1() [0x427df6]

    ??:? void tmpfufn5_ju.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string a = lst[0];\n    string b = lst[1];\n    string s = \"\"\
    ;\n    auto l = a.length;\n    auto m = b.length;\n    auto j = 1;\n    uint[int]\
    \ val = [0: 0, 1: 0];\n    while (j <= l)\n    {\n        s ~= a[j-1];\n     \
    \   auto x = s.find(\")\");\n        if (x != string.npos)\n        {\n      \
    \      s = s[0..$-1];\n            auto y = s.rfind(\"(\");\n            if (y\
    \ != string.npos)\n            {\n                s = s[0..$-1];\n           \
    \ }\n            else\n            {\n                val[0]++;\n            }\n\
    \        }\n        j++;\n    }\n    j = 1;\n    s = \"\";\n    while (j <= m)\n\
    \    {\n        s ~= b[j-1];\n        auto x = s.find(\")\");\n        if (x !=\
    \ string.npos)\n        {\n            s = s[0..$-1];\n            auto y = s.rfind(\"\
    (\");\n            if (y != string.npos)\n            {\n                s = s[0..$-1];\n\
    \            }\n            else\n            {\n                val[1]++;\n \
    \           }\n        }\n        j++;\n    }\n    if (val[0] == val[1])\n   \
    \ {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n\
    \    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp78abi11s.d(33): Error: no property `find` for type `string`

    /tmp/tmp78abi11s.d(34): Error: no property `npos` for type `string`

    /tmp/tmp78abi11s.d(37): Error: no property `rfind` for type `string`

    /tmp/tmp78abi11s.d(38): Error: no property `npos` for type `string`

    /tmp/tmp78abi11s.d(54): Error: no property `find` for type `string`

    /tmp/tmp78abi11s.d(55): Error: no property `npos` for type `string`

    /tmp/tmp78abi11s.d(58): Error: no property `rfind` for type `string`

    /tmp/tmp78abi11s.d(59): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp78abi11s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string res;\n    return \"No\";\n}\n \nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd4l69vn7.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f45]

    ??:? void tmpd4l69vn7.__unittest_L27_C1() [0x427b80]

    ??:? void tmpd4l69vn7.__modtest() [0x4281ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d81f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a75c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c75]

    ??:? runModuleUnitTests [0x42d5f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429394]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result;\n    auto s = new std.string.Joiner();\n    bool\
    \ b = true;\n    foreach(const e; lst)\n    {\n        s.put(e);\n        if(e.count('(')\
    \ != e.count(')'))\n        {\n            b = false;\n            break;\n  \
    \      }\n    }\n    if(b)\n    {\n        auto ss = s.toString();\n        int\
    \ c = 0;\n        foreach(e; ss)\n        {\n            if(e == '(')\n      \
    \          c++;\n            else\n                c--;\n            if(c < 0)\n\
    \            {\n                b = false;\n                break;\n         \
    \   }\n        }\n    }\n    if(b)\n        result = \"Yes\";\n    else\n    \
    \    result = \"No\";\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpccqpyq8y.d(24): Error: undefined identifier `string` in package
    `std`

    /tmp/tmpccqpyq8y.d(29): Error: no property `count` for type `const(string)`

    /tmp/tmpccqpyq8y.d(29): Error: no property `count` for type `const(string)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpccqpyq8y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // You need to write this function.\n    int left = count(lst[0].retro.filter!(c\
    \ => c == '('));\n    int right = count(lst[1].filter!(c => c == ')'));\n    return\
    \ left == right ? \"Yes\" : \"No\";\n}\n/*\n    Purely functional version of the\
    \ above algorithm.\n    Highly inefficient.\n*/\nstring match_parens2(string[]\
    \ lst) \n{\n    // You need to write this function.\n    int left = lst[0].retro.filter!(c\
    \ => c == '(').reduce!((a, b) => '(' ~ a);\n    int right = lst[1].filter!(c =>\
    \ c == ')').reduce!((a, b) => a ~ ')');\n    string result = left ~ right;\n \
    \   int count = 0;\n    foreach(c; result) {\n        if(c == '(') count++;\n\
    \        else count--;\n        if(count < 0) return \"No\";\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\";\n}\n/*\n    Based on the assumption that there\
    \ will only be either open parenthesis\n    or close parenthesis.\n*/\nstring\
    \ match_parens3(string[] lst) \n{\n    // You need to write this function.\n \
    \   int left = count(lst[0].retro.filter!(c => c == '('));\n    int right = count(lst[1].filter!(c\
    \ => c == ')'));\n    return left == right ? \"Yes\" : \"No\";\n}\n/*\n    The\
    \ test function that tests the correctness of the function.\n*/\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_ce_65j.d(24): Error: undefined identifier `count`

    /tmp/tmpf_ce_65j.d(25): Error: undefined identifier `count`

    /tmp/tmpf_ce_65j.d(35): Error: no property `retro` for type `string`

    /tmp/tmpf_ce_65j.d(36): Error: no property `filter` for type `string`

    /tmp/tmpf_ce_65j.d(37): Error: incompatible types for `(left) ~ (right)`: both
    operands are of type `int`

    /tmp/tmpf_ce_65j.d(53): Error: undefined identifier `count`

    /tmp/tmpf_ce_65j.d(54): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_ce_65j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s = lst[0] ~ lst[1];\n    auto i = 1;\n    for (; i < s.length;\
    \ i++)\n    {\n        if (s[i] == '(') break;\n    }\n    auto s2 = s[i..$];\n\
    \    s = s[0..i];\n    foreach (ch; s)\n    {\n        if (ch == '(') s2 ~= ')';\n\
    \        else if (ch == ')') s2 ~= '(';\n    }\n    return std.algorithm.find(s2,\
    \ \"(\") ? \"No\" : \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7l1xa5w.d(36): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7l1xa5w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    struct ParensCount(T) {\n        T open;\n        T close;\n \
    \   }\n    static @safe pure nothrow unittest {\n        assert(sum(ParensCount!\"\
    int\"(4, 2)) == 6);\n        assert(sum(ParensCount!\"int\"(-4, 2)) == -2);\n\
    \        assert(sum(ParensCount!\"int\"(4, -2)) == 2);\n        assert(sum(ParensCount!\"\
    int\"(-4, -2)) == -6);\n    }\n    template sum(ParensCount)(ParensCount p) {\n\
    \        return p.open + p.close;\n    }\n    static @safe pure nothrow unittest\
    \ {\n        assert(sum(ParensCount!\"int\"(4, 2)) == 6);\n        assert(sum(ParensCount!\"\
    int\"(-4, 2)) == -2);\n        assert(sum(ParensCount!\"int\"(4, -2)) == 2);\n\
    \        assert(sum(ParensCount!\"int\"(-4, -2)) == -6);\n    }\n    static if\
    \ (is(typeof(lst[0][0]) == char)) {\n        enum sz = lst.length;\n        ParensCount!\"\
    int\"[sz] nums;\n        foreach (idx, str; lst) {\n            foreach (ch; str)\
    \ {\n                if (ch == '(') {\n                    nums[idx].open++;\n\
    \                } else {\n                    nums[idx].close++;\n          \
    \      }\n            }\n        }\n        assert(nums.length == sz);\n     \
    \   nums[0].open -= sum(nums[1 .. $]);\n        auto t = sum(nums[0 .. 1]);\n\
    \        if (t >= 0) {\n            foreach (i; 1 .. sz - 1) {\n             \
    \   t += sum(nums[i .. i + 1]);\n                if (t < 0) {\n              \
    \      return \"No\";\n                }\n            }\n            return \"\
    Yes\";\n        } else {\n            return \"No\";\n        }\n    } else {\n\
    \        static assert(0,\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd0l6e60x.d(27): Error: basic type expected, not `unittest`

    /tmp/tmpd0l6e60x.d(27): Error: no identifier for declarator `_error_`

    /tmp/tmpd0l6e60x.d(27): Error: found `unittest` instead of statement

    /tmp/tmpd0l6e60x.d(33): Error: members of template declaration expected

    /tmp/tmpd0l6e60x.d(33): Error: declaration expected, not `(`

    /tmp/tmpd0l6e60x.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd0l6e60x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(inout i; lst)\n\
    \    {\n        foreach(inout j; i)\n        {\n            if(j == '(')\n   \
    \         {\n                left++;\n            }\n            else\n      \
    \      {\n                right++;\n            }\n        }\n    }\n    if(left\
    \ > right)\n    {\n        return \"Yes\";\n    }\n    else\n    {\n        return\
    \ \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkmqsgiei.d(25): Error: variable `tmpkmqsgiei.match_parens.i` `inout`
    variables can only be declared inside `inout` functions

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkmqsgiei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int a,b;\n    int len = lst.length;\n    if (len == 1)\n    {\n\
    \        a = lst[0].countChar('(');\n        b = lst[0].countChar(')');\n    \
    \    if (a == b)\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    else\n    {\n        a = lst[0].countChar('(');\n      \
    \  b = lst[0].countChar(')');\n        a += lst[1].countChar('(');\n        b\
    \ += lst[1].countChar(')');\n        if (a == b)\n            return \"Yes\";\n\
    \        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkw8g5j97.d(24): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmpkw8g5j97.d(27): Error: no property `countChar` for type `string`

    /tmp/tmpkw8g5j97.d(28): Error: no property `countChar` for type `string`

    /tmp/tmpkw8g5j97.d(36): Error: no property `countChar` for type `string`

    /tmp/tmpkw8g5j97.d(37): Error: no property `countChar` for type `string`

    /tmp/tmpkw8g5j97.d(38): Error: no property `countChar` for type `string`

    /tmp/tmpkw8g5j97.d(39): Error: no property `countChar` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkw8g5j97.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int n = lst[0].length;\n    int m = lst[1].length;\n    int[][]\
    \ dp = new int[n + 1][m + 1];\n    dp[0][0] = 1;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        for (int j = 0; j < m; j++)\n        {\n            if (lst[0][i]\
    \ == '(' && dp[i][j] > 0)\n            {\n                dp[i + 1][j] = max(dp[i\
    \ + 1][j], dp[i][j] + 1);\n            }\n            if (lst[1][j] == ')' &&\
    \ dp[i][j] > 0)\n            {\n                dp[i][j + 1] = max(dp[i][j + 1],\
    \ dp[i][j] - 1);\n            }\n            if (lst[0][i] == ')' && dp[i][j]\
    \ > 0)\n            {\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]\
    \ - 1);\n            }\n            if (lst[1][j] == '(' && dp[i][j] > 0)\n  \
    \          {\n                dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + 1);\n\
    \            }\n        }\n    }\n    return dp[n][m] > 0 ? \"Yes\" : \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvti7l75c.d(23): Error: cannot implicitly convert expression `lst[0].length`
    of type `ulong` to `int`

    /tmp/tmpvti7l75c.d(24): Error: cannot implicitly convert expression `lst[1].length`
    of type `ulong` to `int`

    /tmp/tmpvti7l75c.d(25): Error: variable `n` cannot be read at compile time

    /tmp/tmpvti7l75c.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpvti7l75c.d(37): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpvti7l75c.d(41): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpvti7l75c.d(45): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvti7l75c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Iterate through the string elements, if the current char is\
    \ an\n    // opening parenthesis, we increment an integer count by 1,\n    //\
    \ if it's a closing parenthesis, we decrement the count by 1.\n    // If the count\
    \ is negative, then there is no way to make a good string\n    // since there\
    \ are more closing parentheses than opening ones.\n    //\n    // If the count\
    \ is still 0, then there is a way to make a good string.\n    //\n    // A similar\
    \ logic can be applied to any expression that uses + and -\n    // to count occurrences,\
    \ e.g.\n    // https://www.geeksforgeeks.org/count-number-substrings-string-equal-given-sum/\n\
    \    // https://www.geeksforgeeks.org/count-substrings-string-k-distinct-characters/\n\
    \    int count = 0;\n    foreach(string s; lst) {\n        foreach(char c; s)\
    \ {\n            if (c == '(')\n                count++;\n            else\n \
    \               count--;\n            if (count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3y8wprcd.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmp3y8wprcd.__unittest_L48_C1() [0x427dda]

    ??:? void tmp3y8wprcd.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s = lst[0] ~ lst[1];\n    if (std.algorithm.count!((c) =>\
    \ c == '(')(s) !=\n        std.algorithm.count!((c) => c == ')')(s)) \n    {\n\
    \        return \"No\";\n    }\n    while (true)\n    {\n        auto a = s.join(\"\
    \").split(\")(\");\n        if (a.length == 1)\n        {\n            return\
    \ \"Yes\";\n        }\n        s = a;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6drjc86o.d(24): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmp6drjc86o.d(25): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp6drjc86o.d(31): Error: no property `join` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6drjc86o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string word1 = lst[0];\n    string word2 = lst[1];\n    // if\
    \ there are more closing parentheses in word1, we can't balance the\n    // parentheses\n\
    \    if (count(word1, ')') > count(word2, ')')) \n    {\n        return \"No\"\
    ;\n    }\n    // if there are more opening parentheses in word1, we can't balance\
    \ the\n    // parentheses\n    if (count(word1, '(') > count(word2, '(')) \n \
    \   {\n        return \"No\";\n    }\n    // keep track of the current balance\
    \ of parentheses\n    // if balance is positive we have more opening parentheses,\n\
    \    // if balance is negative we have more closing parentheses\n    int balance\
    \ = 0;\n    // try to match parentheses in word1\n    foreach (c; word1) \n  \
    \  {\n        if (c == '(') \n        {\n            balance++;\n        } \n\
    \        else \n        {\n            balance--;\n        }\n        // if balance\
    \ is negative we have closed more parentheses than opened\n        if (balance\
    \ < 0) \n        {\n            return \"No\";\n        }\n    }\n    // try to\
    \ match parentheses in word2\n    foreach (c; word2) \n    {\n        if (c ==\
    \ '(') \n        {\n            balance++;\n        } \n        else \n      \
    \  {\n            balance--;\n        }\n        // if balance is positive we\
    \ have more opening parentheses than closed\n        if (balance > 0) \n     \
    \   {\n            return \"No\";\n        }\n    }\n    // if the balance is\
    \ positive we can't close all the open parentheses,\n    // if the balance is\
    \ negative we can't open all the closed parentheses\n    // so if the balance\
    \ is 0 the parentheses are balanced\n    return balance == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp064pkdc4.d(27): Error: undefined identifier `count`

    /tmp/tmp064pkdc4.d(27): Error: undefined identifier `count`

    /tmp/tmp064pkdc4.d(33): Error: undefined identifier `count`

    /tmp/tmp064pkdc4.d(33): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp064pkdc4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{ \n   int left_count = 0;\n   int right_count = 0;\n   string left =\
    \ lst[0];\n   string right = lst[1];\n   foreach(x; left) {\n       if(x == '(')\
    \ {\n           left_count++;\n       }\n       else {\n           right_count++;\n\
    \       }\n   }\n   foreach(x; right) {\n       if(x == '(') {\n           left_count++;\n\
    \       }\n       else {\n           right_count++;\n       }\n   }\n   if(left_count\
    \ == right_count) {\n       return \"Yes\";\n   }\n   else {\n       return \"\
    No\";\n   }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi55_21tk.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpi55_21tk.__unittest_L50_C1() [0x428106]

    ??:? void tmpi55_21tk.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    auto balanced = false;\n\
    \    foreach(s; lst)\n    {\n        foreach(c; s)\n        {\n            if(c\
    \ == '(') left++;\n            else right++;\n            if(right > left)\n \
    \           {\n                balanced = false;\n                break;\n   \
    \         }\n            else balanced = true;\n        }\n    }\n    if(left\
    \ == right && balanced) return \"Yes\";\n    else return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq0__g2y9.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x42901d]

    ??:? void tmpq0__g2y9.__unittest_L43_C1() [0x427de2]

    ??:? void tmpq0__g2y9.__modtest() [0x428284]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8f7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a834]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a731]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d4d]

    ??:? runModuleUnitTests [0x42d6cd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42946c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return \"\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpel7wxv8w.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f3d]

    ??:? void tmpel7wxv8w.__unittest_L25_C1() [0x427b7c]

    ??:? void tmpel7wxv8w.__modtest() [0x4281a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d817]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a754]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c6d]

    ??:? runModuleUnitTests [0x42d5ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42938c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // TODO: Return \"Yes\" if there's a way to make a good string,\
    \ and return \"No\" otherwise.\n    // myresult = \"Yes\"\n    // For each string,\
    \ build a new string from the old one\n    // if the count of ( and ) is different,\
    \ skip the string\n    // if the count of ( and ) is the same, modify the string\
    \ to remove all\n    // the matching parantheses and add a space.\n    // if the\
    \ count of ( and ) is the same, modify the string to remove all\n    // the matching\
    \ parantheses and add a space.\n    // if the count of ( and ) is the same, modify\
    \ the string to remove all\n    // the matching parantheses and add a space.\n\
    \    // if the count of ( and ) is the same, modify the string to remove all\n\
    \    // the matching parantheses and add a space.\n    // if the count of ( and\
    \ ) is the same, modify the string to remove all\n    // the matching parantheses\
    \ and add a space.\n    // if the count of ( and ) is the same, modify the string\
    \ to remove all\n    // the matching parantheses and add a space.\n    // return\
    \ the result.\n    return \"\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9d9l7rhk.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f3d]

    ??:? void tmp9d9l7rhk.__unittest_L42_C1() [0x427b7c]

    ??:? void tmp9d9l7rhk.__modtest() [0x4281a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d817]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a754]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c6d]

    ??:? runModuleUnitTests [0x42d5ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42938c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int[] stack;\n    int top = 0;\n    int count = 0;\n    foreach(e;\
    \ lst)\n    {\n        foreach(ch; e)\n        {\n            count++;\n     \
    \       if(ch == '(')\n            {\n                stack ~= 1;\n          \
    \      top++;\n            }\n            else\n            {\n              \
    \  if(top > 0)\n                {\n                    stack = stack[0..$-1];\n\
    \                    top--;\n                }\n                else\n       \
    \         {\n                    count--;\n                    break;\n      \
    \          }\n            }\n        }\n    }\n    return count == lst.length\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7l_d2r36.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x42934d]

    ??:? void tmp7l_d2r36.__unittest_L53_C1() [0x427f8c]

    ??:? void tmp7l_d2r36.__modtest() [0x4285b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e86b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4290a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b535]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b5c4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b4c1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42907d]

    ??:? runModuleUnitTests [0x42e641]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429810]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto[left, right] = lst;\n    // tuple of two strings\n    if(right.length()\
    \ > left.length())\n    {\n        // if the length of the right string is greater\
    \ than the length of the left string\n        // swap the strings\n        auto[left,\
    \ right] = tuple(right, left);\n    }\n    // check if there are an equal number\
    \ of closing parentheses\n    if(left.count() != right.count()) return \"No\"\
    ;\n    if(left.count() == right.count() == 0) return \"Yes\";\n    // check if\
    \ the right string is a subset of the left string\n    return right.isSubsetOf(left)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph4hjr10m.d(23): Error: basic type expected, not `[`

    /tmp/tmph4hjr10m.d(23): Error: found `,` when expecting `]`

    /tmp/tmph4hjr10m.d(23): Error: semicolon expected, not `]`

    /tmp/tmph4hjr10m.d(23): Error: found `]` instead of statement

    /tmp/tmph4hjr10m.d(29): Error: basic type expected, not `[`

    /tmp/tmph4hjr10m.d(29): Error: found `,` when expecting `]`

    /tmp/tmph4hjr10m.d(29): Error: semicolon expected, not `]`

    /tmp/tmph4hjr10m.d(29): Error: found `]` instead of statement

    /tmp/tmph4hjr10m.d(33): Error: found `==` when expecting `)`

    /tmp/tmph4hjr10m.d(33): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph4hjr10m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"No\";\n    string str1 = lst[0];\n    string\
    \ str2 = lst[1];\n    string concat = str1 ~ str2;\n    int count = 0;\n    foreach(c;\
    \ concat) \n    {\n        if(c == '(') \n        {\n            count++;\n  \
    \      }\n        else \n        {\n            count--;\n        }\n        if(count\
    \ < 0) \n        {\n            break;\n        }\n    }\n    if(count == 0) \n\
    \    {\n        result = \"Yes\";\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3hm272c5.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmp3hm272c5.__unittest_L49_C1() [0x427e02]

    ??:? void tmp3hm272c5.__modtest() [0x4282a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d98b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a839]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42d761]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429500]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0];\n    string t = lst[1];\n    int ns = s.length;\n\
    \    int nt = t.length;\n    int[] m = new int[2*ns+nt];\n    int n = 0;\n   \
    \ foreach(i, c; s)\n    {\n        if(c == '(')\n            m[n++] = 1;\n   \
    \     else\n            m[n++] = -1;\n    }\n    foreach(i, c; t)\n    {\n   \
    \     if(c == '(')\n            m[n++] = 1;\n        else\n            m[n++]\
    \ = -1;\n    }\n    //printf(\"m: %s\\n\", m);\n    int c = 0;\n    bool pass\
    \ = true;\n    for(int i = 0; i < n; i++)\n    {\n        c += m[i];\n       \
    \ if(c < 0)\n        {\n            pass = false;\n            break;\n      \
    \  }\n    }\n    if(pass && c == 0)\n        return \"Yes\";\n    else\n     \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprye8amv9.d(25): Error: cannot implicitly convert expression `s.length`
    of type `ulong` to `int`

    /tmp/tmprye8amv9.d(26): Error: cannot implicitly convert expression `t.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprye8amv9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n\talias Stack = Tuple!(int, int);\n\tStack[] stack;\n\tStack p;\n\t\
    int start, end;\n\tforeach(s; lst)\n\t{\n\t\tstart = 0;\n\t\tend = s.length;\n\
    \t\twhile(start < end)\n\t\t{\n\t\t\tif(s[start] == '(')\n\t\t\t{\n\t\t\t\tp =\
    \ tuple(1, start);\n\t\t\t\tstack ~= p;\n\t\t\t}\n\t\t\telse if(s[start] == ')')\n\
    \t\t\t{\n\t\t\t\tif(stack.length == 0)\n\t\t\t\t{\n\t\t\t\t\treturn \"No\";\n\t\
    \t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp = stack.pop;\n\t\t\t\t\tif(start\
    \ - p[1] != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn \"No\";\n\t\t\t\t\t}\n\t\t\t\t\
    }\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t}\n\treturn \"Yes\";\n}\nunittest\n{\n  \
    \  alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpefp84ijd.d(30): Error: cannot implicitly convert expression `s.length`
    of type `ulong` to `int`

    /tmp/tmpefp84ijd.d(46): Error: no property `pop` for type `Tuple!(int, int)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpefp84ijd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // your code here...\n    bool good;\n    string s1 = lst[0];\n\
    \    string s2 = lst[1];\n    if (s1.length == 0 && s2.length == 0)\n        return\
    \ \"Yes\";\n    if (s1.length == 0 && s2.length != 0)\n        return \"No\";\n\
    \    if (s1.length != 0 && s2.length == 0)\n        return \"No\";\n    int i\
    \ = s1.length-1;\n    int j = s2.length-1;\n    while (s1[i] == '(' && s2[j] ==\
    \ ')')\n    {\n        i--;\n        j--;\n    }\n    if (i == -1)\n        good\
    \ = true;\n    else if (j == -1)\n        good = true;\n    else\n        good\
    \ = false;\n    if (good)\n        return \"Yes\";\n    else\n        return \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxzcx47vx.d(33): Error: cannot implicitly convert expression `s1.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpxzcx47vx.d(34): Error: cannot implicitly convert expression `s2.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxzcx47vx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int i;\n    int n = lst.length;\n    bool possible = true;\n \
    \   string res = \"\";\n    if (n == 0) return \"No\";\n    foreach (element;\
    \ lst)\n    {\n        foreach (char c; element)\n        {\n            if (c\
    \ == '(') i++;\n            else i--;\n            if (i < 0) possible = false;\n\
    \        }\n    }\n    if (i != 0) possible = false;\n    return possible ? \"\
    Yes\" : \"No\";\n}\n \nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplwqnz5wp.d(24): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwqnz5wp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result;\n    lst = lst.map!(a => a.replace(\"\", \" \"\
    ).replace(\" \", \"\"));\n    result = \"Yes\";\n    if (lst[0].length - lst[1].length\
    \ != 0)\n    {\n        result = \"No\";\n    }\n    int is_valid(string s)\n\
    \    {\n        int result_val;\n        result_val = 0;\n        string temp;\n\
    \        temp = s;\n        if (s.length == 0)\n        {\n            result_val\
    \ = 1;\n        }\n        if (s.length > 0)\n        {\n            for (int\
    \ i = 0; i < s.length; i++)\n            {\n                if (s[i] == '(')\n\
    \                {\n                    result_val += 1;\n                }\n\
    \                else\n                {\n                    result_val -= 1;\n\
    \                }\n                if (result_val < 0)\n                {\n \
    \                   break;\n                }\n            }\n        }\n    \
    \    return result_val;\n    }\n    if (is_valid(lst[0]) != 0 || is_valid(lst[1])\
    \ != 0)\n    {\n        result = \"No\";\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi0syftnf.d(24): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi0syftnf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    //Elements that are considered balanced\n    int[] balElem = [0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,\
    \ 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\
    \ 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146,\
    \ 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162,\
    \ 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178,\
    \ 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,\
    \ 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210,\
    \ 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,\
    \ 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,\
    \ 243, 244, 245,\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppui1n8zs.d(25): Error: expression expected, not `unittest`

    /tmp/tmppui1n8zs.d(26): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmppui1n8zs.d(42): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmppui1n8zs.d(42): Error: semicolon expected, not `main`

    /tmp/tmppui1n8zs.d(42): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppui1n8zs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int openCount = 0;\n    int closeCount = 0;\n    int matchCount\
    \ = 0;\n    string result = \"\";\n    foreach(string parenthese; lst)\n    {\n\
    \        foreach(char ch; parenthese)\n        {\n            if(ch == '(')\n\
    \            {\n                openCount++;\n            }\n            else\
    \ if(ch == ')')\n            {\n                closeCount++;\n            }\n\
    \        }\n        if(openCount == closeCount)\n        {\n            result\
    \ = \"Yes\";\n        }\n        else\n        {\n            matchCount = openCount\
    \ - closeCount;\n            if(matchCount < 0)\n            {\n             \
    \   matchCount = matchCount * -1;\n            }\n            if(matchCount <=\
    \ 1)\n            {\n                result = \"Yes\";\n            }\n      \
    \      else\n            {\n                result = \"No\";\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyag8dfkq.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmpyag8dfkq.__unittest_L63_C1() [0x427dac]

    ??:? void tmpyag8dfkq.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d93f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a87c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a779]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d715]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(c; lst[0])\n  \
    \  {\n        if(c == '(')\n            open++;\n        else if(c == ')')\n \
    \           close++;\n    }\n    foreach(c; lst[1])\n    {\n        if(c == '(')\n\
    \            open++;\n        else if(c == ')')\n            close++;\n    }\n\
    \    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgn4buc2t.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpgn4buc2t.__unittest_L41_C1() [0x428102]

    ??:? void tmpgn4buc2t.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto seq = lst[0] ~ lst[1];\n    if (seq.count('(') != seq.count(')'))\
    \ \n        return \"No\";\n    if (seq.count('(') == 0 && seq.count(')') == 0)\
    \ \n        return \"Yes\";\n    auto tmp = [];\n    foreach (c; seq) \n    {\n\
    \        if (c == '(') \n            tmp ~= c;\n        else if (c == ')') \n\
    \        {\n            if (tmp.length == 0) \n                return \"No\";\n\
    \            tmp.pop;\n        }\n    }\n    return tmp.length == 0 ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwnbmj_cp.d(24): Error: no property `count` for type `string`

    /tmp/tmpwnbmj_cp.d(24): Error: no property `count` for type `string`

    /tmp/tmpwnbmj_cp.d(26): Error: no property `count` for type `string`

    /tmp/tmpwnbmj_cp.d(26): Error: no property `count` for type `string`

    /tmp/tmpwnbmj_cp.d(32): Error: cannot append type `immutable(char)` to type `void[]`

    /tmp/tmpwnbmj_cp.d(37): Error: no property `pop` for type `void[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwnbmj_cp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n  // Your code here.\n  import std.algorithm : isSorted;\n  import\
    \ std.conv : to;\n  import std.functional : partial;\n  import std.range : chain,\
    \ joiner, map, filter;\n  import std.array : array;\n  import std.string : join;\n\
    \  import std.range : chunkBy;\n  int n = lst.length;\n  int count = 0;\n  string\
    \ output;\n  foreach(i; 0..n)\n  {\n      string a = lst[i];\n      if(count ==\
    \ 0)\n      {\n          output = a;\n          count = 1;\n      }\n      else\n\
    \      {\n          output = output.joiner(a);\n      }\n  }\n  string output2\
    \ = output.chunkBy!((a, b) => a == b);\n  string output3 = \"\";\n  foreach(i;\
    \ output2)\n  {\n      output3 = output3.joiner(i.array.length.to!string).joiner(i.front);\n\
    \  }\n  string output4 = output3.chunkBy!((a, b) => a != b).front;\n  bool output5\
    \ = output4.isSorted!((a, b) => a > b);\n  return output5 ? \"Yes\" : \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyo8jomqo.d(27): Error: module `std.range` import `joiner` not found,
    did you mean template `std.array.join(RoR, R)(RoR ror, scope R sep) if (isInputRange!RoR
    && isInputRange!(Unqual!(ElementType!RoR)) && isInputRange!R && is(Unqual!(ElementType!(ElementType!RoR))
    == Unqual!(ElementType!R)))`?

    /tmp/tmpyo8jomqo.d(27): Error: module `std.range` import `map` not found

    /tmp/tmpyo8jomqo.d(27): Error: module `std.range` import `filter` not found, did
    you mean template `std.meta.Filter(alias pred, TList...)`?

    /tmp/tmpyo8jomqo.d(30): Error: module `std.range` import `chunkBy` not found,
    did you mean template `std.range.chunks(Source)(Source source, size_t chunkSize)
    if (isInputRange!Source)`?

    /tmp/tmpyo8jomqo.d(31): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyo8jomqo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    auto par = new int[2];\n    par[0]\
    \ = par[1] = 0;\n    foreach(e; 0..lst.length) \n    {\n        if(lst[e] == \"\
    )\") \n        {\n            if(par[0] == 0) \n            {\n              \
    \  if(e == 0) \n                {\n                    par[1] += 1;\n        \
    \        }\n                else \n                {\n                    par[1]\
    \ += 1;\n                    if(par[1] > 1) \n                    {\n        \
    \                result = \"No\";\n                        break;\n          \
    \          }\n                }\n            }\n            else \n          \
    \  {\n                par[0] -= 1;\n            }\n        }\n        else \n\
    \        {\n            par[0] += 1;\n        }\n    }\n    if(par[0] > 0) \n\
    \    {\n        result = \"No\";\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjfj3db_2.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x429445]

    ??:? void tmpjfj3db_2.__unittest_L62_C1() [0x42820a]

    ??:? void tmpjfj3db_2.__modtest() [0x4286ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dfd3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42919e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ac9d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ad2c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ac29]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429175]

    ??:? runModuleUnitTests [0x42dda9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429908]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(s; lst)\n    {\n        foreach(c;\
    \ s)\n        {\n            count += c == '(' ? 1 : -1;\n            if(count\
    \ < 0)\n                return \"No\";\n        }\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpom_kz2um.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpom_kz2um.__unittest_L35_C1() [0x427dde]

    ??:? void tmpom_kz2um.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    \n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7o4_wmap.d(21): Error: function `tmp7o4_wmap.match_parens` has
    no `return` statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7o4_wmap.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    immutable s1 = lst[0];\n    immutable s2 = lst[1];\n    immutable\
    \ s3 = s1 ~ s2;\n    immutable l = s3.length;\n    immutable is_good = (string\
    \ s)\n    {\n        foreach(immutable i; 0 .. l)\n        {\n            immutable\
    \ x = (s[i] == '(') ? 1 : -1;\n            if(x == -1 && !is_good(s[0 .. i] ~\
    \ s[i + 1 .. $]))\n                return false;\n        }\n        return true;\n\
    \    };\n    return is_good(s3) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjpbaq0ob.d(32): Error: undefined identifier `is_good`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjpbaq0ob.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int n = 0;\n    foreach(e; lst) \n    {\n        n += reduce!((a,\
    \ b) => a + b, e.map!(x => x == '(' ? 1 : -1));\n    }\n    return n == 0 ? \"\
    Yes\" : \"No\";\n}\n/*\n    Sum the digits of a decimal number and find the sum\
    \ of those digits and so on until there is only one digit left.\n    Eg: 24 =\
    \ 2 + 4 = 6, 6 = 6\n    >>> digital_root(16)\n    7\n    >>> digital_root(456)\n\
    \    6\n*/\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpei8u6ax4.d(26): Error: template instance `reduce!((a, b) => a +
    b, e.map!((x) => x == ''('' ? 1 : -1))` template `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpei8u6ax4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int stackSize = 0;\n    foreach(char c; lst[0]) {\n        if\
    \ (c == '(') {\n            stackSize++;\n        } else {\n            stackSize--;\n\
    \        }\n    }\n    if (stackSize < 0) {\n        return \"No\";\n    }\n \
    \   foreach(char c; lst[1]) {\n        if (c == '(') {\n            stackSize++;\n\
    \        } else {\n            stackSize--;\n        }\n    }\n    if (stackSize\
    \ > 0) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpata4ki76.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x42905d]

    ??:? void tmpata4ki76.__unittest_L46_C1() [0x427da8]

    ??:? void tmpata4ki76.__modtest() [0x4282c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428db6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a859]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7e5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d8d]

    ??:? runModuleUnitTests [0x42d781]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429520]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n  int sum = 0;\n  foreach(char c; lst[0]) {\n    if (c == '(') sum++;\n\
    \    else sum--;\n  }\n  foreach(char c; lst[1]) {\n    if (c == '(') sum++;\n\
    \    else sum--;\n  }\n  if (sum == 0) return \"Yes\";\n  return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbejtez2t.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpbejtez2t.__unittest_L35_C1() [0x4280f6]

    ??:? void tmpbejtez2t.__modtest() [0x4282b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string first_string = lst[0];\n    string second_string = lst[1];\n\
    \    int first_len = first_string.length;\n    int second_len = second_string.length;\n\
    \    int num_open_parens = 0;\n    int num_close_parens = 0;\n    int i = 0;\n\
    \    bool can_be_balanced = true;\n    for (; i < first_len; i++) \n    {\n  \
    \      if (first_string[i] == '(')\n        {\n            num_open_parens++;\n\
    \        }\n        else if (first_string[i] == ')')\n        {\n            num_close_parens++;\n\
    \        }\n        if (num_close_parens > num_open_parens)\n        {\n     \
    \       can_be_balanced = false;\n            break;\n        }\n    }\n    num_open_parens\
    \ = 0;\n    num_close_parens = 0;\n    for (; i < first_len + second_len; i++)\
    \ \n    {\n        if (i >= first_len)\n        {\n            if (second_string[i\
    \ - first_len] == '(')\n            {\n                num_open_parens++;\n  \
    \          }\n            else if (second_string[i - first_len] == ')')\n    \
    \        {\n                num_close_parens++;\n            }\n        }\n  \
    \      else\n        {\n            if (first_string[i] == '(')\n            {\n\
    \                num_open_parens++;\n            }\n            else if (first_string[i]\
    \ == ')')\n            {\n                num_close_parens++;\n            }\n\
    \        }\n        if (num_close_parens > num_open_parens)\n        {\n     \
    \       can_be_balanced = false;\n            break;\n        }\n    }\n    if\
    \ (can_be_balanced)\n    {\n        return \"Yes\";\n    }\n    else\n    {\n\
    \        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmcmsj7q9.d(25): Error: cannot implicitly convert expression `first_string.length`
    of type `ulong` to `int`

    /tmp/tmpmcmsj7q9.d(26): Error: cannot implicitly convert expression `second_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmcmsj7q9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int parens_counter = 0;\n    foreach(string s; lst) \n    {\n\
    \        foreach(char c; s) \n        {\n            parens_counter += (c == '(')\
    \ ? 1 : -1;\n            if(parens_counter < 0) \n            {\n            \
    \    return \"No\";\n            }\n        }\n    }\n    return (parens_counter\
    \ == 0) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8w36tfh_.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmp8w36tfh_.__unittest_L37_C1() [0x427dde]

    ??:? void tmp8w36tfh_.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int openCount = 0;\n    foreach(string s; lst)\n    {\n      \
    \  foreach(ch; s)\n        {\n            if(ch == '(')\n                openCount++;\n\
    \            else if(ch == ')')\n                openCount--;\n        }\n   \
    \ }\n    return openCount == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7dqluvql.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmp7dqluvql.__unittest_L36_C1() [0x4280a6]

    ??:? void tmp7dqluvql.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ str)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c ==\
    \ ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n\
    \    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprh5st9oe.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmprh5st9oe.__unittest_L36_C1() [0x427df6]

    ??:? void tmprh5st9oe.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if (lst[0].length != lst[1].length)\n        return \"No\";\n\
    \    \n    // (()(()((()\n    // 2222\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv3o85y6h.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv3o85y6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // open and closed parentheses\n    static struct Tuple(int, int)[]\
    \ parentheses = [tuple(0, 0), tuple(1, -1)];\n    // check if concatenation of\
    \ the two strings is balanced\n    bool is_balanced(string str)\n    {\n     \
    \   int count = 0;\n        foreach(ch; str)\n        {\n            count +=\
    \ parentheses[ch == '(' ? 0 : 1].1;\n            if (count < 0)\n            \
    \    return false;\n        }\n        return count == 0;\n    }\n    // check\
    \ if the balanced concatenation is possible for each order of the two strings\n\
    \    return is_balanced(lst[0] ~ lst[1]) || is_balanced(lst[1] ~ lst[0]) ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdipoh0_d.d(24): Error: identifier expected for template type parameter

    /tmp/tmpdipoh0_d.d(24): Error: { } expected following `struct` declaration

    /tmp/tmpdipoh0_d.d(24): Error: no identifier for declarator `int`

    /tmp/tmpdipoh0_d.d(24): Error: found `,` instead of statement

    /tmp/tmpdipoh0_d.d(31): Error: found `0.1` when expecting `;` following statement

    /tmp/tmpdipoh0_d.d(31): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdipoh0_d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto result = true;\n    for (int i = 0; i < lst.length; i++)\n\
    \    {\n        int rightCount = 0;\n        int leftCount = 0;\n        for (int\
    \ j = 0; j < lst[i].length; j++)\n        {\n            if (lst[i][j] == '(')\n\
    \            {\n                leftCount++;\n            }\n            else\n\
    \            {\n                rightCount++;\n            }\n        }\n    \
    \    if (leftCount != rightCount)\n        {\n            result = false;\n  \
    \      }\n    }\n    return result ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplldo4d6d.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmplldo4d6d.__unittest_L46_C1() [0x427c7c]

    ??:? void tmplldo4d6d.__modtest() [0x4282a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d98b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a839]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42d761]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429500]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string res = \"Yes\";\n    int open = 0;\n    int close = 0;\n\
    \    foreach(int i;0..lst.length)\n    {\n        if(lst[i] == \")\")\n      \
    \  {\n            if(open == 0)\n            {\n                res = \"No\";\n\
    \                break;\n            }\n            else open -= 1;\n        }\n\
    \        else\n        {\n            open += 1;\n        }\n    }\n    return\
    \ res;\n}\nstring _match_parens(string[] lst) \n{\n    string res = \"Yes\";\n\
    \    foreach(i; 0..lst.length)\n    {\n        string a = lst[i];\n        int\
    \ open = 0;\n        int close = 0;\n        foreach(j; 0..a.length)\n       \
    \ {\n            if(a[j] == '(') open += 1;\n            else\n            {\n\
    \                if(open == 0)\n                {\n                    res = \"\
    No\";\n                    break;\n                }\n                else open\
    \ -= 1;\n            }\n        }\n        if(open > 0) close += open;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl13uz47z.d(26): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl13uz47z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str1 = lst[0];\n    string str2 = lst[1];\n    string good\
    \ = \"Yes\";\n    string bad = \"No\";\n    //string[] counter = new string[2];\n\
    \    // Type[] counter = new Type[2];\n    int counter1 = 0;\n    int counter2\
    \ = 0;\n    string joined;\n    foreach(l; str1)\n    {\n        if(l == '(')\n\
    \        {\n            counter1 += 1;\n        }\n        else if(l == ')')\n\
    \        {\n            counter1 -= 1;\n        }\n    }\n    foreach(l; str2)\n\
    \    {\n        if(l == '(')\n        {\n            counter2 += 1;\n        }\n\
    \        else if(l == ')')\n        {\n            counter2 -= 1;\n        }\n\
    \    }\n    if((counter1 + counter2) == 0)\n    {\n        return good;\n    }\n\
    \    else\n    {\n        return bad;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmosivs8n.d(76): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmpmosivs8n.__unittest_L63_C1() [0x428142]

    ??:? void tmpmosivs8n.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    enum Parenthesis { Open, Close }\n    struct Parens : Tuple!(Parenthesis,\
    \ Parenthesis)\n    {\n        alias Tuple!(Parenthesis, Parenthesis) Super;\n\
    \        this(Parenthesis left, Parenthesis right) {\n            mixin(Super(left,\
    \ right));\n        }\n    }\n    auto toParens = (string str) {\n        return\
    \ str.map!(c => (c == '(' ? Parenthesis.Open : Parenthesis.Close)).array;\n  \
    \  }\n    auto countDiff = (Parens p) {\n        return p[0] == Parenthesis.Open\
    \ ? 1 : -1;\n    }\n    auto sum = lst.map!(toParens).transpose.map!(sumOf!countDiff).array;\n\
    \    foreach (i, val; sum)\n    {\n        if (val == -1 && lst[1][i] == ')')\n\
    \            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ngu37ih.d(24): Error: base classes are not allowed for `struct`,
    did you mean `;`?

    /tmp/tmp6ngu37ih.d(34): Error: semicolon expected following auto declaration,
    not `auto`

    /tmp/tmp6ngu37ih.d(37): Error: semicolon expected following auto declaration,
    not `auto`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ngu37ih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto S1 = lst[0];\n    auto S2 = lst[1];\n    uint n1 = S1.length;\n\
    \    uint n2 = S2.length;\n    uint n = n1 + n2;\n    auto a1 = split(S1, '(');\n\
    \    auto a2 = split(S2, '(');\n    auto a = array(a1[1..$] ~ a2[1..$]);\n   \
    \ uint openParens = reduce!((a, b) => a + b)(map!((x) => x.length)(a));\n    uint\
    \ closedParens = n - openParens;\n    if(openParens == closedParens)\n       \
    \ return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxatneu5g.d(25): Error: cannot implicitly convert expression `S1.length`
    of type `ulong` to `uint`

    /tmp/tmpxatneu5g.d(26): Error: cannot implicitly convert expression `S2.length`
    of type `ulong` to `uint`

    /tmp/tmpxatneu5g.d(28): Error: undefined identifier `split`

    /tmp/tmpxatneu5g.d(29): Error: undefined identifier `split`

    /tmp/tmpxatneu5g.d(30): Error: undefined identifier `array`

    /tmp/tmpxatneu5g.d(31): Error: template instance `reduce!((a, b) => a + b)` template
    `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxatneu5g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // immutable bool CAN_CONCAT_HERE;\n    // immutable bool CAN_CONCAT_THERE;\n\
    \    enum CAN_CONCAT_HERE = 0;\n    enum CAN_CONCAT_THERE = 1;\n    // immutable\
    \ bool CONCATENATED;\n    // immutable bool NOT_CONCATENATED;\n    enum CONCATENATED\
    \ = 0;\n    enum NOT_CONCATENATED = 1;\n    bool[][] can_concat = new bool[2][2];\n\
    \    can_concat[CAN_CONCAT_HERE][CAN_CONCAT_THERE] = true;\n    can_concat[CAN_CONCAT_HERE][NOT_CONCATENATED]\
    \ = true;\n    can_concat[NOT_CONCATENATED][CAN_CONCAT_THERE] = true;\n    can_concat[NOT_CONCATENATED][NOT_CONCATENATED]\
    \ = false;\n    string left = lst[0];\n    string right = lst[1];\n    bool open_left\
    \ = count(left, '(') > count(left, ')');\n    bool open_right = count(right, '(')\
    \ > count(right, ')');\n    bool[][] table = new bool[left.length + 1][right.length\
    \ + 1];\n    for (int i = 0; i <= left.length; i++) {\n        for (int j = 0;\
    \ j <= right.length; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     table[i][j] = true;\n            } else if (i == 0) {\n                table[i][j]\
    \ = table[i][j - 1] && open_right;\n            } else if (j == 0) {\n       \
    \         table[i][j] = table[i - 1][j] && open_left;\n            } else {\n\
    \                table[i][j] = can_concat[left[i - 1] == '(' ? CAN_CONCAT_HERE\
    \ : NOT_CONCATENATED][right[j - 1] == '(' ? CAN_CONCAT_THERE : NOT_CONC\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6l_7qfs3.d(51): Error: found `unittest` when expecting `,`

    /tmp/tmp6l_7qfs3.d(68): Error: found `void` when expecting `,`

    /tmp/tmp6l_7qfs3.d(68): Error: found `{` when expecting `,`

    /tmp/tmp6l_7qfs3.d(68): Error: expression expected, not `}`

    /tmp/tmp6l_7qfs3.d(68): Error: found `End of File` when expecting `,`

    /tmp/tmp6l_7qfs3.d(68): Error: found `End of File` when expecting `]`

    /tmp/tmp6l_7qfs3.d(68): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmp6l_7qfs3.d(68): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp6l_7qfs3.d(68): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp6l_7qfs3.d(68): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp6l_7qfs3.d(68): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6l_7qfs3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return (isOk(lst[0])) && (isOk(lst[1])) ? \"Yes\" : \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_scyktm0.d(23): Error: undefined identifier `isOk`

    /tmp/tmp_scyktm0.d(23): Error: undefined identifier `isOk`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_scyktm0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    foreach(string s; lst)\n    {\n        int count = 0;\n      \
    \  foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n\
    \            else if(c == ')')\n                count--;\n            if(count\
    \ < 0)\n                return \"No\";\n        }\n    }\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpe9jxn8sx.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x429005]

    ??:? void tmpe9jxn8sx.__unittest_L38_C1() [0x427c40]

    ??:? void tmpe9jxn8sx.__modtest() [0x42826c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a78d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a81c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a719]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d35]

    ??:? runModuleUnitTests [0x42d6b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429454]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{ \n    string answer = \"No\";\n    int openCount = 0;\n    int closeCount\
    \ = 0;\n    int totalCount = 0;\n    foreach(string str; lst)\n    {\n       \
    \ totalCount += str.length;\n        openCount += count(str, '(');\n        closeCount\
    \ += count(str, ')');\n    }\n    if(openCount == closeCount)\n    {\n       \
    \ answer = \"Yes\";\n    }\n    return answer;\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj3eyda2_.d(30): Error: undefined identifier `count`

    /tmp/tmpj3eyda2_.d(31): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj3eyda2_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    ulong prefix_count = 0;\n    ulong postfix_count = 0;\n    foreach(c;\
    \ lst[0])\n    {\n        if(c == '(')\n            prefix_count++;\n        else\n\
    \            prefix_count--;\n    }\n    foreach(c; lst[1])\n    {\n        if(c\
    \ == '(')\n            postfix_count++;\n        else\n            postfix_count--;\n\
    \    }\n    if(prefix_count == 0 && postfix_count == 0)\n        return \"Yes\"\
    ;\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5ocvigmn.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmp5ocvigmn.__unittest_L44_C1() [0x427c90]

    ??:? void tmp5ocvigmn.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto stack = Stack!(string)();\n    stack.push(lst[0]);\n    stack.push(lst[1]);\n\
    \    string res = \"\";\n    while (stack.length > 0) \n    {\n        string\
    \ str = stack.pop;\n        uint count = 0;\n        foreach (c; str)\n      \
    \  {\n            if (c == '(') \n            {\n                count++;\n  \
    \          } \n            else if (c == ')') \n            {\n              \
    \  count--;\n            }\n            if (count < 0) \n            {\n     \
    \           return \"No\";\n            }\n        }\n        res = str ~ res;\n\
    \    }\n    if (count == 0) \n    {\n        return \"Yes\";\n    }\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpizxrzjgk.d(23): Error: template instance `Stack!string` template
    `Stack` is not defined

    /tmp/tmpizxrzjgk.d(48): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpizxrzjgk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto stack_ = Stack!string();\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzl4xpe2a.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzl4xpe2a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string res =\
    \ s1~s2;\n    int bal = 0;\n    foreach(c; res)\n    {\n        if(c == '(')\n\
    \            bal++;\n        else if(c == ')')\n            bal--;\n        if(bal\
    \ < 0)\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjkts0t1v.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpjkts0t1v.__unittest_L38_C1() [0x427df2]

    ??:? void tmpjkts0t1v.__modtest() [0x428294]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int balance = 0;\n    foreach(item; lst) \n    {\n        foreach(ch;\
    \ item) \n        {\n            if(ch == '(') balance++;\n            else balance--;\n\
    \            if(balance < 0) return \"No\";\n        }\n    }\n    return balance\
    \ ? \"No\" : \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn7ccn8bu.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpn7ccn8bu.__unittest_L35_C1() [0x427dda]

    ??:? void tmpn7ccn8bu.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string[] strA = lst[0];\n    string[] strB = lst[1];\n    string\
    \ strAB = strA ~ strB;\n    int flag = 0;\n    int sum = 0;\n    for (int i =\
    \ 0; i < strAB.length; i++)\n    {\n        if (strAB[i] == '(')\n        {\n\
    \            sum += 1;\n        }\n        else\n        {\n            sum -=\
    \ 1;\n        }\n        if (sum < 0)\n        {\n            flag = 1;\n    \
    \        break;\n        }\n    }\n    if (flag == 1 || sum != 0)\n    {\n   \
    \     return \"No\";\n    }\n    else\n    {\n        return \"Yes\";\n    }\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_q477t6r.d(23): Error: cannot implicitly convert expression `lst[0]`
    of type `string` to `string[]`

    /tmp/tmp_q477t6r.d(24): Error: cannot implicitly convert expression `lst[1]` of
    type `string` to `string[]`

    /tmp/tmp_q477t6r.d(25): Error: cannot implicitly convert expression `strA ~ strB`
    of type `string[]` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_q477t6r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return has_balanced_parens(lst[0] ~ lst[1]) ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpicxbug7o.d(23): Error: undefined identifier `has_balanced_parens`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpicxbug7o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n  string a = lst[0];\n  string b = lst[1];\n  while (a.count('(')\
    \ != a.count(')')) \n  {\n    if (a.count('(') > a.count(')')) \n    {\n     \
    \ a = a.replace(\"(\", \"\");\n    }\n    else \n    {\n      a = a.replace(\"\
    )\", \"\");\n    }\n  }\n  while (b.count('(') != b.count(')')) \n  {\n    if\
    \ (b.count('(') > b.count(')')) \n    {\n      b = b.replace(\"(\", \"\");\n \
    \   }\n    else \n    {\n      b = b.replace(\")\", \"\");\n    }\n  }\n  return\
    \ (a + b).count('(') == (a + b).count(')') ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplt9rhpwk.d(25): Error: no property `count` for type `string`

    /tmp/tmplt9rhpwk.d(25): Error: no property `count` for type `string`

    /tmp/tmplt9rhpwk.d(27): Error: no property `count` for type `string`

    /tmp/tmplt9rhpwk.d(27): Error: no property `count` for type `string`

    /tmp/tmplt9rhpwk.d(29): Error: no property `replace` for type `string`

    /tmp/tmplt9rhpwk.d(33): Error: no property `replace` for type `string`

    /tmp/tmplt9rhpwk.d(36): Error: no property `count` for type `string`

    /tmp/tmplt9rhpwk.d(36): Error: no property `count` for type `string`

    /tmp/tmplt9rhpwk.d(38): Error: no property `count` for type `string`

    /tmp/tmplt9rhpwk.d(38): Error: no property `count` for type `string`

    /tmp/tmplt9rhpwk.d(40): Error: no property `replace` for type `string`

    /tmp/tmplt9rhpwk.d(44): Error: no property `replace` for type `string`

    /tmp/tmplt9rhpwk.d(47): Error: invalid array operation `a + b` (possible missing
    [])

    /tmp/tmplt9rhpwk.d(47): Error: invalid array operation `a + b` (possible missing
    [])

    Failed: ["dmd", "-'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n  string m1 = \"(\";\n  string m2 = \")\";\n  return if(m1.match(lst[0].front.to!string)\
    \ && m2.match(lst[1].front.to!string)) \"Yes\" else \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ztq6pfh.d(25): Error: expression expected, not `if`

    /tmp/tmp8ztq6pfh.d(25): Error: found `"Yes"` when expecting `;` following `return`
    statement

    /tmp/tmp8ztq6pfh.d(25): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ztq6pfh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string res1 = lst[0];\n    string res2 = lst[1];\n    int paren\
    \ = 0;\n    foreach(c; res1)\n    {\n        if(c == '(')\n            paren++;\n\
    \        else\n            paren--;\n        if(paren < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; res2)\n    {\n        if(c == '(')\n        \
    \    paren++;\n        else\n            paren--;\n        if(paren < 0)\n   \
    \         return \"No\";\n    }\n    if(paren == 0)\n        return \"Yes\";\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbnmojeop.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpbnmojeop.__unittest_L49_C1() [0x427e4a]

    ??:? void tmpbnmojeop.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left_parens = 0;\n    int right_parens = 0;\n    foreach(c;\
    \ lst[0])\n    {\n        if(c == '(')\n            left_parens++;\n        else\n\
    \            right_parens++;\n    }\n    foreach(c; lst[1])\n    {\n        if(c\
    \ == '(')\n            left_parens++;\n        else\n            right_parens++;\n\
    \    }\n    int diff = abs(left_parens - right_parens);\n    return (left_parens\
    \ == right_parens) || (diff == 1 && left_parens > right_parens) ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjer2n3uu.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290bd]

    ??:? void tmpjer2n3uu.__unittest_L42_C1() [0x42815a]

    ??:? void tmpjer2n3uu.__modtest() [0x428328]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8b9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a948]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a845]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ded]

    ??:? runModuleUnitTests [0x42d7e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429580]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    import std.array;\n    import std.algorithm;\n    import std.string;\n\
    \    import std.typecons;\n    import std.algorithm : canFind;\n    import std.typecons\
    \ : tuple;\n    import std.conv : to;\n    import std.math : min;\n    import\
    \ std.range;\n    enum lst_size = lst.length;\n    string full_str = lst.join;\n\
    \    // find unmatched opening and closing brackets\n    string[string] unmatched\
    \ = [full_str: []] ;\n    foreach(string el; full_str)\n    {\n        string\
    \ type;\n        type = el == \"(\" ? \"left\" : \"right\";\n        if(unmatched.canFind(type))\n\
    \        {\n            // remove the latest element of the array\n          \
    \  if(unmatched[type].length == 0)\n            {\n                continue;\n\
    \            }\n            else\n            {\n                immutable ind\
    \ = unmatched[type].length - 1;\n                unmatched[type].remove(ind);\n\
    \            }\n        }\n        else\n        {\n            unmatched[type]\
    \ ~= el;\n        }\n    }\n    auto [left, right] = tuple(unmatched[\"left\"\
    ], unmatched[\"right\"]);\n    if(left.length == 0 && right.length == 0)\n   \
    \ {\n        return \"Yes\";\n    }\n    else if(left.length == 0 || right.length\
    \ == 0)\n    {\n        return \"No\";\n    }\n    else\n    {\n        string[int]\
    \ tmp = [left.length];\n        foreach(ind; 0..left.length)\n        {\n    \
    \        tmp[ind] = left[ind..$];\n        }\n        string[int] tmp2 = [right.length];\n\
    \        foreach(ind; 0..right.length)\n        {\n            tmp2[ind] = right[ind..$];\n\
    \        }\n        left = tmp.join;\n        right = tmp2.join;\n        tmp.length\
    \ = 0;\n        tmp2.length = 0;\n        // find the minimum number of matches\
    \ needed to get a good string\n        int ctr = 0;\n        foreach(char el;\
    \ left)\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg79eqv80.d(58): Error: basic type expected, not `[`

    /tmp/tmpg79eqv80.d(58): Error: found `,` when expecting `]`

    /tmp/tmpg79eqv80.d(58): Error: semicolon expected, not `]`

    /tmp/tmpg79eqv80.d(58): Error: found `]` instead of statement

    /tmp/tmpg79eqv80.d(86): Error: found `unittest` instead of statement

    /tmp/tmpg79eqv80.d(103): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg79eqv80.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return (() =>\n    {\n        int cnt = 0;\n        foreach (ch;\
    \ lst[0])\n        {\n            if (ch == '(')\n                cnt++;\n   \
    \         else\n                cnt--;\n        }\n        foreach (ch; lst[1])\n\
    \        {\n            if (ch == '(')\n                cnt++;\n            else\n\
    \                cnt--;\n        }\n        return cnt == 0 ? \"Yes\" : \"No\"\
    ;\n    })();\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp62jlupbv.d(41): Error: cannot implicitly convert expression `delegate
    () => delegate () => cnt == 0 ? "Yes" : "No"()` of type `string delegate() pure
    nothrow @nogc @safe` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp62jlupbv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{ \n    bool isGood(string s) {\n        int parens = 0;\n        foreach(c;\
    \ s) {\n            if(c == '(')\n                parens++;\n            else\n\
    \                parens--;\n            if(parens < 0)\n                return\
    \ false;\n        }\n        return parens == 0;\n    }\n    foreach(elem; lst)\n\
    \        if(!isGood(elem))\n            return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbrk8rqaz.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmpbrk8rqaz.__unittest_L40_C1() [0x427cd4]

    ??:? void tmpbrk8rqaz.__modtest() [0x428300]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d96f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a81d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d745]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(s; lst)\n    {\n        s ~= s;\n\
    \    }\n    return s.count(\")\") == s.count(\"(\") ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pe9qefm.d(24): Error: variable `s` is shadowing variable `tmp5pe9qefm.match_parens.s`

    /tmp/tmp5pe9qefm.d(28): Error: no property `count` for type `string`

    /tmp/tmp5pe9qefm.d(28): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pe9qefm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    int open = 0;\n    foreach(e; lst)\n\
    \    {\n        int temp = e.count!('(') - e.count!(')');\n        open += temp;\n\
    \        if(open < 0)\n        {\n            result = \"No\";\n            break;\n\
    \        }\n    }\n    if(open != 0)\n        result = \"No\";\n    return result;\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ijqszd5.d(27): Error: no property `count` for type `string`

    /tmp/tmp0ijqszd5.d(27): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ijqszd5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Good luck!\n    auto s = lst[0] ~ lst[1];\n    auto brackets\
    \ = typeof(s);\n    foreach(i; 0 .. lst.length)\n    {\n        brackets = lst[i];\n\
    \        brackets = brackets.replace('(', '<');\n        brackets = brackets.replace(')',\
    \ '>');\n        if(brackets.find('<') < brackets.find('>'))\n            return\
    \ \"No\";\n    }\n    brackets = s;\n    brackets = brackets.replace('(', '<');\n\
    \    brackets = brackets.replace(')', '>');\n    return brackets.find('<') < brackets.find('>')\
    \ ? \"No\" : \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5lppkj9g.d(25): Error: type `string` has no value

    /tmp/tmp5lppkj9g.d(29): Error: no property `replace` for type `string`

    /tmp/tmp5lppkj9g.d(30): Error: no property `replace` for type `string`

    /tmp/tmp5lppkj9g.d(31): Error: no property `find` for type `string`

    /tmp/tmp5lppkj9g.d(31): Error: no property `find` for type `string`

    /tmp/tmp5lppkj9g.d(35): Error: no property `replace` for type `string`

    /tmp/tmp5lppkj9g.d(36): Error: no property `replace` for type `string`

    /tmp/tmp5lppkj9g.d(37): Error: no property `find` for type `string`

    /tmp/tmp5lppkj9g.d(37): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5lppkj9g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return lst[0] + lst[1]\n        .replace(\"(\", \"~\")\n     \
    \   .replace(\")\", \"(\")\n        .replace(\"~\", \")\")\n        .count(\"\
    (\") == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgtwbur2d.d(24): Error: no property `replace` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgtwbur2d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0]+lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count += 1;\n        else\n   \
    \         count -= 1;\n        if(count < 0)\n            return \"No\";\n   \
    \ }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplum5bh0g.d(23): Error: invalid array operation `lst[0] + lst[1]`
    (possible missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplum5bh0g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int total = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                total++;\n     \
    \       else\n                total--;\n            if(total < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return total == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr67iykte.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpr67iykte.__unittest_L38_C1() [0x427dda]

    ??:? void tmpr67iykte.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n\tint num_open = 0;\n\tint num_close = 0;\n\tforeach(char ch; lst[0])\n\
    \t{\n\t\tif(ch == '(')\n\t\t\tnum_open++;\n\t\telse\n\t\t\tnum_close++;\n\t}\n\
    \t\n\tforeach(char ch; lst[1])\n\t{\n\t\tif(ch == '(')\n\t\t\tnum_open++;\n\t\t\
    else\n\t\t\tnum_close++;\n\t}\n\t\n\tif(num_open == num_close)\n\t\treturn \"\
    Yes\";\n\treturn \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjyqvz_5_.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpjyqvz_5_.__unittest_L45_C1() [0x4280fa]

    ??:? void tmpjyqvz_5_.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n\tint parenCount = 0;\n\tforeach(string s; lst)\n\t{\n\t\tforeach(char\
    \ c; s)\n\t\t{\n\t\t\tif(c == '(')\n\t\t\t\tparenCount++;\n\t\t\telse if(c ==\
    \ ')')\n\t\t\t\tparenCount--;\n\t\t\tif(parenCount < 0)\n\t\t\t\treturn \"No\"\
    ;\n\t\t}\n\t}\n\treturn parenCount == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpek1xvdaw.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpek1xvdaw.__unittest_L38_C1() [0x427dde]

    ??:? void tmpek1xvdaw.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto lhs = lst[0];\n    auto rhs = lst[1];\n    auto lhs_count\
    \ = 0;\n    auto rhs_count = 0;\n    foreach(paren; lhs)\n    {\n        lhs_count\
    \ += paren == '(' ? 1 : -1;\n        if(lhs_count < 0)\n            return \"\
    No\";\n    }\n    foreach(paren; rhs)\n    {\n        rhs_count += paren == '('\
    \ ? 1 : -1;\n        if(rhs_count < 0)\n            return \"No\";\n    }\n  \
    \  return rhs_count == lhs_count ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppe112tzg.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x42908d]

    ??:? void tmppe112tzg.__unittest_L41_C1() [0x427cc8]

    ??:? void tmppe112tzg.__modtest() [0x4282f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428de6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a889]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a918]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a815]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dbd]

    ??:? runModuleUnitTests [0x42d7b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429550]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    if (lst[0].length == 0)\n    {\n        if (lst[1].length % 2\
    \ == 0)\n        {\n            return \"Yes\";\n        }\n        else\n   \
    \     {\n            return \"No\";\n        }\n    }\n    else if (lst[1].length\
    \ == 0)\n    {\n        if (lst[0].length % 2 == 0)\n        {\n            return\
    \ \"Yes\";\n        }\n        else\n        {\n            return \"No\";\n \
    \       }\n    }\n    else\n    {\n        string lhs = lst[0][0 .. $ - 1];\n\
    \        string rhs = lst[1][1 .. $];\n        return (match_parens([lhs, rhs])\
    \ == \"Yes\" || match_parens([lst[0], rhs]) == \"Yes\" || match_parens([lhs, lst[1]])\
    \ == \"Yes\") ? \"Yes\" : \"No\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk4igj_eq.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x4292b5]

    ??:? void tmpk4igj_eq.__unittest_L52_C1() [0x427f82]

    ??:? void tmpk4igj_eq.__modtest() [0x428520]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dc03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42900e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ab40]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fe5]

    ??:? runModuleUnitTests [0x42d9d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429778]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    int openCnt = 0;\n    int closeCnt\
    \ = 0;\n    foreach(string s; lst) {\n        foreach(char c; s) {\n         \
    \   if(c == '(') openCnt++;\n            else closeCnt++;\n        }\n    }\n\
    \    if(openCnt < closeCnt) result = \"No\";\n    return result;\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjyy9tjcq.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x42900d]

    ??:? void tmpjyy9tjcq.__unittest_L35_C1() [0x427fd6]

    ??:? void tmpjyy9tjcq.__modtest() [0x428278]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a795]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a824]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a721]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d3d]

    ??:? runModuleUnitTests [0x42d6bd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42945c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // if both strings are empty, return yes\n    if (lst[0].length\
    \ == 0 && lst[1].length == 0)\n        return \"Yes\";\n    // if the concatenation\
    \ results in an empty string, return no\n    if (lst[0].length == 0 || lst[1].length\
    \ == 0)\n        return \"No\";\n    // if the the concatenation results in a\
    \ string with an open paren, return no\n    if (lst[0][0] == '(' || lst[1][0]\
    \ == '(')\n        return \"No\";\n    // otherwise, try combining the first character\
    \ of both strings\n    auto lst0 = lst[0].join(\"\").byLines.map!(x => x.idup);\n\
    \    auto lst1 = lst[1].join(\"\").byLines.map!(x => x.idup);\n    string combined\
    \ = lst0[0] ~ lst1[0];\n    // if the combined string results in a balanced string,\
    \ return yes\n    if (balanced(combined))\n        return \"Yes\";\n    else\n\
    \        return \"No\";\n}\n// check if string is balanced\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw3oe8vz2.d(33): Error: no property `join` for type `string`

    /tmp/tmpw3oe8vz2.d(34): Error: no property `join` for type `string`

    /tmp/tmpw3oe8vz2.d(37): Error: undefined identifier `balanced`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw3oe8vz2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n\tTuple!(char[], char[]) tup = tuple(lst[0].dup, lst[1].dup);\n\t\
    return (tup.expand.sort.eq(\"()\") ? \"Yes\" : \"No\");\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp69ccx79k.d(24): Error: no property `sort` for tuple `(char[], char[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp69ccx79k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int x = 0;\n    string[] lst2 = lst.filter!((string str)\n   \
    \ {\n        foreach(char c; str)\n        {\n            if(c == '(') x++;\n\
    \            else if(c == ')') x--;\n        }\n        return x > 0;\n    });\n\
    \    x = 0;\n    return std.algorithm.any!((string str)\n    {\n        foreach(char\
    \ c; str)\n        {\n            if(c == '(') x++;\n            else if(c ==\
    \ ')') x--;\n        }\n        return x == 0;\n    })(lst2) ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7577gqvs.d(24): Error: no property `filter` for type `string[]`

    /tmp/tmp7577gqvs.d(34): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7577gqvs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str = lst[0] ~ lst[1];\n    size_t len = str.length;\n\
    \    char[] arr = str.dup;\n    int bal = 0;\n    foreach(c; arr)\n    {\n   \
    \     if(c == '(')\n            bal++;\n        else\n            bal--;\n   \
    \     if(bal < 0)\n            return \"No\";\n    }\n    return bal == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ku7l8oh.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x42959d]

    ??:? void tmp_ku7l8oh.__unittest_L38_C1() [0x427f86]

    ??:? void tmp_ku7l8oh.__modtest() [0x428590]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dfef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4292a2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aee5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42af74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ae71]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429279]

    ??:? runModuleUnitTests [0x42ddc5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429ab4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    string t = \"\";\n    bool ok = true;\n\
    \    foreach(c; lst[0]) {\n        if(c == '(')\n            s ~= '(';\n     \
    \   else if(c == ')') {\n            if(s.length > 0)\n                s = s[0..$-1];\n\
    \            else\n                return \"No\";\n        }\n    }\n    foreach(c;\
    \ lst[1]) {\n        if(c == '(')\n            t ~= '(';\n        else if(c ==\
    \ ')') {\n            if(t.length > 0)\n                t = t[0..$-1];\n     \
    \       else\n                return \"No\";\n        }\n    }\n    if(t.length\
    \ > 0) {\n        if(s.length == 0)\n            return \"No\";\n        string[]\
    \ result = [];\n        foreach(i; 0..s.length) {\n            result ~= s[0..i]\
    \ ~ t;\n        }\n        foreach(i; result) {\n            if(i.match(\"^[()]*$\"\
    ).length == 0)\n                ok = false;\n        }\n        if(ok)\n     \
    \       return \"Yes\";\n        else\n            return \"No\";\n    }\n   \
    \ else {\n        return \"Yes\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpepvu9kwi.d(54): Error: no property `match` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpepvu9kwi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string res = \"Yes\";\n    bool flag = true;\n    int count_open\
    \ = 0;\n    int count_close = 0;\n    foreach(string s; lst) {\n        foreach(char\
    \ c; s) {\n            if(c == '(') {\n                count_open++;\n       \
    \     }\n            else if(c == ')') {\n                count_close++;\n   \
    \         }\n        }\n    }\n    if(count_open != count_close) {\n        res\
    \ = \"No\";\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpue_6nqsj.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpue_6nqsj.__unittest_L42_C1() [0x4280c2]

    ??:? void tmpue_6nqsj.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    lst = lst.map!(a => a.replace(\"()\", \"\").replace(\"(\", \"\"\
    ).replace(\")\", \"\"));\n    if (lst[0].empty && lst[1].empty)\n        return\
    \ \"Yes\";\n    if (lst[0].empty || lst[1].empty)\n        return \"No\";\n  \
    \  if (lst[0].length < lst[1].length)\n        return match_parens(lst.reverse);\n\
    \    if (lst[0].length == lst[1].length)\n        return \"No\";\n    if (lst[0].length\
    \ > lst[1].length)\n        lst[0] = lst[0].replace(lst[1], \"\");\n    return\
    \ match_parens(lst);\n}\n/*\n    Another solution is to count the pairs of parentheses\
    \ in each element.\n    In order to be balanced, the number of opening parentheses\
    \ needs to be\n    equal to the number of closing parentheses.\n    This is equivalent\
    \ to the sum of all parentheses being zero.\n*/\nstring match_parens(string[]\
    \ lst) \n{\n    import std.algorithm;\n    import std.array;\n    return (lst.map!(a\
    \ => a.filter!(b => b == '(' || b == ')').\n                            map!(b\
    \ => b == '(' ? 1 : -1).sum).sum == 0) ?\n           \"Yes\" : \"No\";\n}\n/*\n\
    \    Another solution is to use reduce to build a balance count.\n    if the balance\
    \ count is ever negative, we will return a false immediately.\n    if the balance\
    \ count is not equal to zero when we finish, then we return\n    false, otherwise\
    \ we return true.\n*/\nstring match_parens(string[] lst) \n{\n    bool balanced(string\
    \ s)\n    {\n        int balance = 0;\n        return s.all!(a =>\n        {\n\
    \            balance += (a == '(') ? 1 : -1;\n            return balance >= 0;\n\
    \        }) && balance == 0;\n    }\n    return balanced(lst[0] ~ lst[1]) ? \"\
    Yes\" : \"No\";\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7jmgqxxw.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7jmgqxxw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // 2 strings, 1 open and 1 close\n    string open = lst[0];\n\
    \    string close = lst[1];\n    // number of open and close parens\n    int open_parens\
    \ = open.length;\n    int close_parens = close.length;\n    // string to hold\
    \ result\n    string result = \"\";\n    // use string of same length as close\
    \ parens\n    string good = \"\";\n    foreach(i; 0..close_parens) {\n       \
    \ good ~= \"(\";\n    }\n    // if open parens not equal to close parens\n   \
    \ if(open_parens != close_parens) {\n        return \"No\";\n    }\n    // if\
    \ open parens equal to close parens\n    else {\n        // if number of open\
    \ parens equal to closed parens\n        if(open_parens == close_parens) {\n \
    \           if(open == close) {\n                return \"Yes\";\n           \
    \ }\n            else {\n                return \"No\";\n            }\n     \
    \   }\n        // if number of open parens greater than close parens\n       \
    \ else if(open_parens > close_parens) {\n            // while open parens not\
    \ equal to close parens\n            while(open_parens != close_parens) {\n  \
    \              // replace with close parens\n                open_parens = replace(open,\
    \ \"(\", \")\");\n            }\n            // if open parens equal to close\
    \ parens\n            if(open_parens == close_parens) {\n                if(open\
    \ == close) {\n                    return \"Yes\";\n                }\n      \
    \          else {\n                    return \"No\";\n                }\n   \
    \         }\n        }\n        // if number of close parens greater than open\
    \ parens\n        else if(close_parens > open_parens) {\n            // while\
    \ close parens not equal to open parens\n            while(close_parens != open_parens)\
    \ {\n                // replace with open parens\n                close_parens\
    \ = replace(close, \")\", \"(\");\n            }\n            // if close parens\
    \ equal to open parens\n           \nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjr9i8y5o.d(77): Error: found `unittest` instead of statement

    /tmp/tmpjr9i8y5o.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpjr9i8y5o.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjr9i8y5o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    return lst[0].countChar('(') == lst[1].countChar(')') ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6e2f3p36.d(23): Error: no property `countChar` for type `string`

    /tmp/tmp6e2f3p36.d(23): Error: no property `countChar` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6e2f3p36.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{ \n    import std.regex;\n    int close = 0;\n    int open = 0;\n  \
    \  foreach(string str; lst)\n    {\n        foreach(m; matchAll(str, `[\\)\\(]`))\n\
    \        {\n            if(m.hit == \")\")\n            {\n                close++;\n\
    \            }\n            else\n            {\n                open++;\n   \
    \         }\n        }\n    }\n    if(close == open)\n    {\n        return \"\
    Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqba5rc57.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x4cd46d]

    ??:? void tmpqba5rc57.__unittest_L46_C1() [0x4901aa]

    ??:? void tmpqba5rc57.__modtest() [0x4ca9b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x4dfc63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4cc6e6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4d3d29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4d3ebc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4d3cb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4cc6bd]

    ??:? runModuleUnitTests [0x4dfa39]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4ce9f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161396
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto stack = new Stack!int;\n    foreach(i; lst)\n    {\n    \
    \    foreach(c; i)\n        {\n            if(c == '(')\n                stack.push('(');\n\
    \            else if(stack.empty)\n                return \"No\";\n          \
    \  else\n                stack.pop;\n        }\n    }\n    return stack.empty\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3icyydgw.d(23): Error: template instance `Stack!int` template `Stack`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3icyydgw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    lst = lst.sort();\n    string str = lst[0] ~ lst[1];\n    Tuple!(char,\
    \ int)[] a = str.zip!(iota(0));\n    bool r = a.chunks!(2).all!(chunk => chunk[0].second\
    \ + 1 == chunk[1].second);\n    return r ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy2an63oj.d(23): Error: no property `sort` for type `string[]`

    /tmp/tmpy2an63oj.d(25): Error: no property `zip` for type `string`

    /tmp/tmpy2an63oj.d(26): Error: no property `chunks` for type `Tuple!(char, int)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy2an63oj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // check if we can match open parans on the right to close on\
    \ the left.\n    int right = 0;\n    foreach(c; lst[0]) {\n        if(c == '(')\
    \ right++;\n        else right--;\n        if(right < 0) return \"No\";\n    }\n\
    \    int left = 0;\n    foreach(c; lst[1]) {\n        if(c == '(') left++;\n \
    \       else left--;\n        if(left > 0) return \"No\";\n    }\n    if(left\
    \ == right) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr1n63njc.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpr1n63njc.__unittest_L39_C1() [0x427cc0]

    ??:? void tmpr1n63njc.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string a = lst[0];\n    string b = lst[1];\n    int open_parens_needed\
    \ = 0;\n    int close_parens_needed = 0;\n    foreach(i; 0 .. a.length) {\n  \
    \      if(a[i] == '(') {\n            open_parens_needed++;\n        } else {\n\
    \            if(open_parens_needed == 0) {\n                return \"No\";\n \
    \           }\n            open_parens_needed--;\n        }\n    }\n    foreach(i;\
    \ 0 .. b.length) {\n        if(b[i] == ')') {\n            close_parens_needed++;\n\
    \        } else {\n            if(close_parens_needed == 0) {\n              \
    \  return \"No\";\n            }\n            close_parens_needed--;\n       \
    \ }\n    }\n    if(open_parens_needed != close_parens_needed) {\n        return\
    \ \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_wh32eqm.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290a5]

    ??:? void tmp_wh32eqm.__unittest_L52_C1() [0x427e6a]

    ??:? void tmp_wh32eqm.__modtest() [0x42830c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dfe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a930]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a82d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dd5]

    ??:? runModuleUnitTests [0x42d7c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429568]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = join(lst);\n    if (s.count!(')') > s.count!('('))\n\
    \        return \"No\";\n    else \n    {\n        string[] split_lst = s.split(')');\n\
    \        int[] open_paren_count = split_lst.map!((x) => x.count!('(')).array;\n\
    \        int[] cumsum = cumsum(open_paren_count);\n        if (cumsum.any!((x)\
    \ => x < 0))\n            return \"No\";\n        else\n            return \"\
    Yes\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyhdrio_n.d(23): Error: undefined identifier `join`, did you mean
    function `main`?

    /tmp/tmpyhdrio_n.d(24): Error: no property `count` for type `string`

    /tmp/tmpyhdrio_n.d(24): Error: no property `count` for type `string`

    /tmp/tmpyhdrio_n.d(28): Error: no property `split` for type `string`

    /tmp/tmpyhdrio_n.d(29): Error: no property `map` for type `string[]`

    /tmp/tmpyhdrio_n.d(30): Error: undefined identifier `cumsum`

    /tmp/tmpyhdrio_n.d(31): Error: no property `any` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhdrio_n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto open = lst[0].count('(');\n    auto close = lst[0].count(')');\n\
    \    if (lst[1][0] == '(') {\n        open++;\n    } else {\n        close++;\n\
    \    }\n    if (open == close) {\n        return \"Yes\";\n    }\n    return \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprcadsvi3.d(23): Error: no property `count` for type `string`

    /tmp/tmprcadsvi3.d(24): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcadsvi3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161390
