name: HumanEval_26_remove_duplicates
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n From an array of integers, remove\
  \ all elements that occur more than once.\n    Keep order of elements left the same\
  \ as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L,\
  \ 4L]\n    \n*/\nlong[] remove_duplicates(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = remove_duplicates;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 4L, 3L, 5L]) == [1L, 4L, 5L]);\n}\nvoid main(){}"
completions: ["{\n    int[] counts = numbers.dup.countmap();\n    long[] result =\
    \ [];\n    foreach(long number; numbers)\n    {\n        if(counts[number] ==\
    \ 1)\n        {\n            result ~= number;\n        }\n    }\n    return result;\n\
    }", "{\n  return uniq(numbers);\n}\n \n/*\n Re-order an array in a random order.\n\
    \    >>> random_order([1L, 2L, 3L, 4L, 5L])\n    [2L, 1L, 5L, 4L, 3L]\n    >>>\
    \ random_order([1L, 2L, 3L, 4L, 5L])\n    [5L, 3L, 2L, 4L, 1L]\n*/\nlong[] random_order(long[]\
    \ numbers) \n{\n  return numbers.random_shuffle();\n}\n \n/*\n From an array of\
    \ integers, output their sum.\n    >>> sum_numbers([1L, 2L, 3L, 4L, 5L])\n   \
    \ 15L\n*/\nlong sum_numbers(long[] numbers) \n{\n  return numbers.sum;\n}\n \n\
    /*\n From an array of integers, output the highest number.\n    >>> find_highest([1L,\
    \ 2L, 3L, 4L, 5L])\n    5L\n*/\nlong find_highest(long[] numbers) \n{\n  return\
    \ numbers.max;\n}\n \n/*\n From an array of strings, output an array that contains\
    \ the length of each string.\n    >>> find_lengths([\"Hello\", \"World\"])\n \
    \   [5L, 5L]\n*/\nlong[] find_lengths(string[] strings) \n{\n  return strings.map!(a\
    \ => a.length);\n}\n \n/*\n From an array of strings, output all strings that\
    \ contain another string.\n    >>> find_contains([\"Hello\", \"World\"], \"o\"\
    )\n    [\"Hello\", \"World\"]\n    >>> find_contains([\"Hello\", \"World\"], \"\
    M\")\n    []\n*/\nstring[] find_contains(string[] strings, string value) \n{\n\
    \  return strings.filter!(a => a.contains(value));\n}\n \n/*\n From an array of\
    \ strings, remove all strings that contain another string.\n    >>> remove_contains([\"\
    Hello\", \"World\"], \"o\")\n    []\n    >>> remove_contains([\"Hello\", \"World\"\
    ], \"M\")\n    [\"Hello\",", "{\n\tstruct Node\n\t{\n\t\tlong data;\n\t\tNode*\
    \ next;\n\t}\n\tstruct LinkedList \n\t{\n\t\tNode* head;\n\t\tNode* tail;\n\t\t\
    void add(long data)\n\t\t{\n\t\t\tif(head is null)\n\t\t\t{\n\t\t\t\thead = new\
    \ Node;\n\t\t\t\thead.data = data;\n\t\t\t\ttail = head;\n\t\t\t}\n\t\t\telse\n\
    \t\t\t{\n\t\t\t\ttail.next = new Node;\n\t\t\t\ttail = tail.next;\n\t\t\t\ttail.data\
    \ = data;\n\t\t\t}\n\t\t}\n\t\tvoid append(LinkedList list)\n\t\t{\n\t\t\tif(head\
    \ is null)\n\t\t\t{\n\t\t\t\thead = list.head;\n\t\t\t\ttail = list.tail;\n\t\t\
    \t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttail.next = list.head;\n\t\t\t\ttail = list.tail;\n\
    \t\t\t}\n\t\t}\n\t\tvoid remove(long data)\n\t\t{\n\t\t\tNode* current = head;\n\
    \t\t\tNode* prev = null;\n\t\t\twhile(current !is null)\n\t\t\t{\n\t\t\t\tif(current.data\
    \ == data)\n\t\t\t\t{\n\t\t\t\t\tif(prev is null)\n\t\t\t\t\t{\n\t\t\t\t\t\thead\
    \ = current.next;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev.next\
    \ = current.next;\n\t\t\t\t\t}\n\t\t\t\t\tif(current is tail)\n\t\t\t\t\t{\n\t\
    \t\t\t\t\ttail = prev;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev\
    \ = current;\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t}\n\t\tvoid remove_duplicates()\n\
    \t\t{\n\t\t\tlong[] seen = new long", "{\n\tlong[] result = new long[];\n\tforeach(i;\
    \ numbers)\n\t{\n\t\tif(count(numbers, i) == 1)\n\t\t{\n\t\t\tresult ~= i;\n\t\
    \t}\n\t}\n\treturn result;\n}", "{\n    auto tmp = new long[numbers.length];\n\
    \    auto itmp = 0L;\n    foreach(n ; numbers) \n    {\n        if (numbers.count(n)\
    \ == 1) \n        {\n            tmp[itmp] = n;\n            itmp++;\n       \
    \ }\n    }\n    return tmp[0..itmp];\n}", "{\n    if(numbers.length == 0)\n  \
    \      return new long[0];\n    auto nums = uniq(numbers);\n    nums.sort();\n\
    \    return nums;\n}", "{\n  auto results = appender!(long[])();\n  foreach(n;\
    \ numbers)\n  {\n    if (results.empty || results.data[$-1] != n)\n      results.put(n);\n\
    \  }\n  return results.data;\n}", "{ \n    auto numbers_set = std.set.Set!long(numbers);\n\
    \    return numbers_set.array;\n}\n/*\n    From an array of integers, remove all\
    \ elements that occur more than once.\n    >>> remove_duplicates([1L, 2L, 3L,\
    \ 2L, 4L])\n    [1L, 3L, 4L]\n*/\nlong[] remove_duplicates_std(long[] numbers)\
    \ \n{ \n    auto numbers_set = numbers.unique;\n    return numbers_set.array;\n\
    }", "{\n    long[] result = [];\n    int count = 0;\n    foreach(index, num; numbers)\n\
    \    {\n        if(count == 0)\n        {\n            count = 1;\n          \
    \  result ~= num;\n        }\n        else\n        {\n            if(result[$-1]\
    \ != num)\n            {\n                result ~= num;\n            }\n    \
    \    }\n    }\n    return result;\n}", "{\n    auto s = set!(typeof(numbers[0]))(numbers);\n\
    \    return (numbers.dup).retain(a => s.remove(a));\n}", "{\n    auto set = new\
    \ set!(long)();\n    foreach(n; numbers) {\n        set.insert(n);\n    }\n  \
    \  long[] unique;\n    unique.length = set.length;\n    long i = 0;\n    foreach(n;\
    \ set) {\n        unique[i] = n;\n        i++;\n    }\n    return unique;\n}",
  "{ \n    auto ulong_numbers = to!ulong[](numbers);\n    // auto gen_ones = map!(constant(1))(ulong_numbers);\n\
    \    // writeln(map!(constant(1))(ulong_numbers));\n    // writeln(gen_ones);\n\
    \    // writeln(zip(ulong_numbers, gen_ones));\n    // auto unique_numbers = zip(ulong_numbers,\
    \ gen_ones).reduce!(a,b=>a+b);\n    auto unique_numbers = zip(ulong_numbers, map!(constant(1))(ulong_numbers)).reduce!(a,b=>a+b);\n\
    \    // writeln(unique_numbers);\n    auto unique_numbers_keys = unique_numbers.keys;\n\
    \    // writeln(unique_numbers_keys);\n    auto diff = numbers ~ unique_numbers_keys;\n\
    \    // writeln(diff);\n    foreach(i; 0..diff.length)\n    {\n        // writeln(diff[i]);\n\
    \        if(diff[i] in unique_numbers)\n        {\n            unique_numbers[diff[i]]\
    \ +=1;\n        }\n    }\n    // writeln(unique_numbers);\n    auto unique_values\
    \ = unique_numbers.values;\n    // writeln(unique_values);\n    auto unique_numbers_keys_with_duplicates\
    \ = zip(unique_numbers_keys, unique_values).filter!(a=>a[1]==1);\n    // writeln(unique_numbers_keys_with_duplicates);\n\
    \    return to!long[](unique_numbers_keys_with_duplicates.map!(a=>a[0]));\n}",
  "{\n    long[] result = [];\n    foreach(int i, long n; numbers)\n    {\n      \
    \  if (n in result)\n            continue;\n        result ~= n;\n    }\n    return\
    \ result;\n}\n/*\n    Given an array of integers, return the sum of two numbers\
    \ that equal the value target. \n    >>> two_sum([1L, 2L, 4L, 4L], 8L)\n    [4L,\
    \ 4L]\n*/\nlong[] two_sum(long[] numbers, long target) \n{\n    long[] result\
    \ = [];\n    foreach(int i, long n; numbers)\n    {\n        if (target - n in\
    \ numbers)\n        {\n            result ~= n;\n            result ~= target\
    \ - n;\n            break;\n        }\n    }\n    return result;\n}\n/*\n    Given\
    \ a word, return an array with the indices of all capital letters.\n    >>> capitals(\"\
    qQuIckBrOwNfOx\")\n    [1L, 5L, 9L, 10L]\n*/\nlong[] capitals(string word) \n\
    {\n    long[] result = [];\n    foreach(int i, char c; word)\n    {\n        if\
    \ (c.isUpper)\n            result ~= i;\n    }\n    return result;\n}\n/*\n  \
    \  Given an array of integers and a target, find all possible combinations \n\
    \    of a, b, c, d, such that a + b + c + d = target.\n    >>> four_sum([1L, 2L,\
    \ 3L, 4L, 5L, 6L, 7L], 10L)\n    [[1L, 2L, 3L, 4L], [1L, 2L, 5L, 2L], [1L, 3L,\
    \ 4L, 2L], [1L, 4L, 3L, 2L], [1L, 5L, 2L, 2L], [2L, 3L, 5L, 0L], [2L, 4L, 4L,\
    \ 0L], [2L, 5L, 3L, 0L], [3L, 4L, 3L, 0L], [3L, 5L, 2L, 0L", "{\n    return numbers.dup.sort.dedup;\n\
    }", "{\n    long[] result = numbers.dup;\n    immutable(int)[] duplicates = std.array.uniq(numbers);\n\
    \    foreach(i; 0 .. duplicates.length)\n    {\n        immutable(int) dup = duplicates[i];\n\
    \        for(int j = 0; j < result.length; ++j)\n        {\n            if(result[j]\
    \ == dup)\n            {\n                result = std.array.remove(result, j);\n\
    \                j--;\n            }\n        }\n    }\n    return result;\n}",
  "{\n    import std.algorithm : uniq;\n    return numbers.uniq;\n}", "{ \n    long[]\
    \ result = [];\n    int[] temp = new int[numbers.length];", "{\n  long[] result\
    \ = new long[];\n  bool[] seen = new bool[numbers.length];\n  ulong i = 0UL;\n\
    \  foreach(long number; numbers) \n  {\n    if(!seen[i]) \n    {\n      auto j\
    \ = 0UL;\n      auto found = false;\n      while(j < i && !found) \n      {\n\
    \        if(numbers[j] == number) \n        {\n          found = true;\n     \
    \   }\n        j++;\n      }\n      if(!found) \n      {\n        result ~= number;\n\
    \      }\n    }\n    seen[i] = true;\n    i++;\n  }\n  return result;\n}\n// from\
    \ http://www.digitalmars.com/d/2.0/phobos/std_random.html\nstruct Random\n{\n\
    \    long int seed;\n    enum uint32_t Max = 2147483647L;", "{\n    long[]result;\n\
    \    immutable a = [];\n    immutable b = [];\n    foreach(n; numbers) \n    {\n\
    \        if(n in a) \n        {\n            b ~= n;\n        } \n        else\
    \ \n        {\n            a ~= n;\n        }\n    }\n    result = a.difference(b);\n\
    \    return result;\n}\n/*\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n\
    \    [1L, 3L, 4L]\n*/", "{\n    auto m_dict = std.typecons.makeHashMap!(long,\
    \ long)();\n    auto m_list = std.typecons.makeArray!(long)();\n    foreach(num;\
    \ numbers) \n    {\n        if(m_dict.count(num) == 0) \n        {\n         \
    \   m_dict[num] = num;\n            m_list ~= num;\n        }\n    }\n    return\
    \ m_list;\n}", "{\n    long[] numbers_before = numbers.dup; //make a copy to make\
    \ sure the solution does not break the input\n    numbers = numbers.unique; \n\
    \    assert(numbers.length < numbers_before.length);\n    return numbers;\n}",
  "{\n    import std.algorithm.searching : all;\n    import std.algorithm.sorting\
    \ : uniq;\n    return numbers.uniq.array;\n}\n/*\nGiven an array of strings, remove\
    \ all elements that are prefixes of another array element.\nThe order of the output\
    \ does not matter.\n    >>> remove_prefixes([\"dog\", \"deer\", \"deal\"])\n \
    \   [\"deer\", \"deal\"]\n    >>> remove_prefixes([\"dog\", \"deer\", \"deal\"\
    ])\n    [\"dog\", \"deer\", \"deal\"]\n    >>> remove_prefixes([\"i\", \"am\"\
    , \"a\", \"student\"])\n    [\"i\", \"am\", \"student\"]\n*/\nstring[] remove_prefixes(string[]\
    \ names) \n{\n    import std.algorithm.searching : all;\n    import std.algorithm.sorting\
    \ : uniq;\n    import std.string : startsWith;\n    return names.filter!(a =>\
    \ !names.any!(n => a != n && a.startsWith(n))).array;\n}\n/*\nGiven an array of\
    \ strings, merge elements that are separated by a given string.\nThe order of\
    \ the output does not matter.\n    >>> merge_elements([\"a\", \"b\", \"c\", \"\
    d\", \"e\"], \"---\")\n    [\"a---b---c\", \"d---e\"]\n    >>> merge_elements([\"\
    a\", \"9\", \"b\", \"c\", \"d\", \"e\"], \".\")\n    [\"a.9.b.c\", \"d.e\"]\n\
    */\nstring[] merge_elements(string[] strings, string separator) \n{\n    import\
    \ std.algorithm.iteration : join;\n    return strings.chunks(2).map!(a => a.join(separator)).array;\n\
    }\n/*\nGiven an array of integers, compute the maximum sum of elements on a sliding\
    \ window of the array.\nThe window starts from the first element and moves along\
    \ the array.\nReturn zero if the window has no elements.\n    >>> max_sliding_window([10,\
    \ -1, -2, 2, 4, -1, 2, -3], 2)\n    [10, 8, 6", "{\n    auto result = new long[];\n\
    \    foreach(n; numbers)\n    {\n        if(count(numbers, n) == 1)\n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}\n/*\n GCD of\
    \ more numbers\n    Compute greatest common divisor of more than two numbers.\n\
    \    >>> gcd(4L, 6L, 8L)\n    2L\n    \n*/\nlong gcd(long[] numbers) \n{\n   \
    \ long gcd;\n    foreach(n; numbers)\n    {\n        gcd = gcd(gcd, n);\n    }\n\
    \    return gcd;\n}\n/*\n Dot product of two vectors\n    Compute the dot product\
    \ of two vectors.\n    >>> dot([1L, 2L, 3L], [4L, 5L, 6L])\n    32L\n    \n*/\n\
    long dot(long[] first, long[] second) \n{\n    if(first.length != second.length)\n\
    \    {\n        throw new Exception(\"Vectors need to be the same length\");\n\
    \    }\n    long result = 0;\n    foreach(n; first)\n    {\n        result +=\
    \ n * second[n];\n    }\n    return result;\n}\n/*\n Returns a vector of integers\
    \ from 1 to n\n    >>> range(4L)\n    [1L, 2L, 3L, 4L]\n    \n*/\nlong[] range(long\
    \ n) \n{\n    long[] res = new long[];\n    for(long i = 1; i <= n; i++)\n   \
    \ {\n        res ~= i;\n    }\n    return res;\n}\n/*\n Partition a set into subsets\n\
    \    Given a set of distinct positive integers, for each element of the set,\n\
    \    find the number of elements in the set that are strictly smaller than it.\n\
    \    Return the answer in the form of an array.\n    >>> partition({4L, 1L, 3L,\
    \ 2L})\n    [1L, 1L, 1L, 0L]\n    \n*/\nlong[] partition(long[] numbers) \n{\n\
    \    long[] res = new long[];\n    foreach", "{\n    auto temp = new long[numbers.length];\n\
    \    size_t j = 0;\n    foreach(num; numbers)\n    {\n        if(num != temp[j-1])\n\
    \        {\n            temp[j] = num;\n            j++;\n        }\n    }\n \
    \   return temp[0..j];\n}", "{\n    auto result = new long[0];\n    foreach(e;\
    \ numbers)\n    {\n        static long prev = -1;\n        static bool seen =\
    \ false;\n        if(e != prev)\n        {\n            if(!seen)\n          \
    \  {\n                result ~= e;\n            }\n            seen = false;\n\
    \        }\n        else\n        {\n            seen = true;\n        }\n   \
    \     prev = e;\n    }\n    return result;\n}", "{\n    return remove_duplicates(remove_duplicates);\n\
    }", "{\n\tauto unique = numbers.dup;\n\tunique.sort();\n\tunique.erase(unique.unique,\
    \ unique.length);\n\treturn unique;\n}", "{\n    long[] dups;\n    bool[] removeElement;\n\
    \    int i;\n    int j;\n    int k;\n    int len;\n    int dupCount;\n    int\
    \ count;\n    int index;\n    bool found;\n    bool found2;\n    int len2;\n \
    \   int len3;\n    len = numbers.length;\n    dups = new long[len];\n    removeElement\
    \ = new bool[len];\n    for (int i = 0; i < len; i++)\n    {\n        removeElement[i]\
    \ = false;\n    }\n    for (int i = 0; i < len; i++)\n    {\n        count = 0;\n\
    \        for (int j = 0; j < len; j++)\n        {\n            if (numbers[i]\
    \ == numbers[j])\n            {\n                count++;\n            }\n   \
    \     }\n        if (count > 1)\n        {\n            removeElement[i] = true;\n\
    \        }\n    }\n    dupCount = 0;\n    for (int i = 0; i < len; i++)\n    {\n\
    \        if (removeElement[i] == true)\n        {\n            dupCount++;\n \
    \       }\n    }\n    len2 = len - dupCount;\n    count = 0;\n    for (int i =\
    \ 0; i < len; i++)\n    {\n        if (removeElement[i] == false)\n        {\n\
    \            dups[count] = numbers[i];\n            count++;\n        }\n    }\n\
    \    for (int i = 0; i < len2; i++)\n    {\n        for (int j = i + 1; j < len2;\
    \ j++)\n        {\n            if (dups[i] == dups[j])\n            {\n      \
    \          for (int k = j; k < len2; k++)\n                {\n               \
    \     dups[k] = dups[k + 1];\n                }\n                len2--;\n   \
    \         }\n        }\n    }\n    return dups[0..len2];\n}", "{ \n    int[] counter\
    \ = new int[numbers.length];\n    long[] result = [];\n    int j = 0;\n    for\
    \ (long i = 0; i < numbers.length; i++)\n    {\n        int c = 1;\n        for\
    \ (long k = i + 1; k < numbers.length; k++)\n        {\n            if (numbers[i]\
    \ == numbers[k])\n            {\n                c++;\n            }\n       \
    \ }\n        if (c == 1)\n        {\n            result[j] = numbers[i];\n   \
    \         j++;\n        }\n    }\n    return result;\n}\n ", "{\n    auto no_duplicates\
    \ = new long[];\n    auto seen = new bool[];\n    foreach (n; numbers) \n    {\n\
    \        if (seen[n]) \n        {\n            continue;\n        }\n        seen[n]\
    \ = true;\n        no_duplicates ~= n;\n    }\n    return no_duplicates;\n}\n\
    /*\nGiven a matrix (nested array), return the transpose.\n    >>> transpose([[1,\
    \ 2, 3], [4, 5, 6]])\n    [[1, 4], [2, 5], [3, 6]]\n    \n*/\nlong[][] transpose(long[][]\
    \ matrix) \n{\n    auto result = new long[][](matrix[0].length);\n    foreach\
    \ (line; matrix) \n    {\n        foreach (i, n; line) \n        {\n         \
    \   result[i] ~= n;\n        }\n    }\n    return result;\n}\n/*\nGiven a list\
    \ of some items and a number N, return items that occur more than N times.\n \
    \   Keep order of elements left the same as in the input.\n    >>> frequent([1L,\
    \ 2L, 3L, 2L, 4L, 2L], 2L)\n    [2L]\n    \n*/\nlong[] frequent(long[] numbers,\
    \ long minimum_frequency) \n{\n    auto seen = new long[];\n    foreach (n; numbers)\
    \ \n    {\n        seen[n]++;\n    }\n    auto result = new long[];\n    foreach\
    \ (n; numbers) \n    {\n        if (seen[n] > minimum_frequency) \n        {\n\
    \            result ~= n;\n        }\n    }\n    return result;\n}\n/*\nGiven\
    \ a list of names, remove all that end with a given suffix.\n    >>> remove_suffix([\"\
    Sylvester\", \"Sly Stallone\", \"Mary Jane\", \"Mary Poppins\"], \"e\")\n    [\"\
    Sylvester\", \"Sly Stallone\", \"Mary Poppins\"]\n    >>> remove_suffix([\"Sylvester\"\
    , \"Sly Stallone\", \"Mary Jane\", \"Mary Po", "{\n    return numbers.dup.removeDups;\n\
    }", "in \n{\n    alias Counted = Tuple!(long, int);\n    bool isCounter = true;\n\
    \    Counted counted(long number, int count) {\n        return tuple(number, count);\n\
    \    }\n    import std.algorithm.mutation : swap;\n    import std.algorithm.comparison\
    \ : equal;\n    long[] result;\n    auto numbers_unique = numbers.enumerate.map!(counted);\n\
    \    auto occurrences = numbers_unique.groupBy!(a => a[0]);\n    foreach (number;\
    \ occurrences) {\n        auto number_and_count = number[0];\n        if (number_and_count[1]\
    \ == 1) {\n            result ~= number_and_count[0];\n        }\n    }\n    return\
    \ result;\n}", "{\n    return numbers.dup.retain(a => numbers.count(a) == 1);\n\
    }\n \n \n/*\n Write a function that takes two parameters, the first one is a sequence\
    \ of\n elements of any type, the second one is a set (which can be any ordered\n\
    \ collection) of elements of the same type of the first parameter.  It should\n\
    \ return a sequence with elements in the same order as in the first parameter\n\
    \ with duplicates removed.  The elements should be unique in the returned\n sequence.\n\
    \    >>> de_duplicate([\"Apple\", \"Apple\", \"Orange\", \"Pear\", \"Pear\", \"\
    Orange\"],\n    ...             [\"Apple\", \"Orange\"])\n    [\"Apple\", \"Pear\"\
    , \"Orange\"]\n*/\ntemplate de_duplicate(T)(T input, Set!T set) \n{\n    return\
    \ input.dup.retain(set.contains);\n}\n \n \n/*\n For a given collection of intervals,\
    \ given as pairs of integers, merge all\n overlapping intervals.\n    >>> merge_intervals([[1,\
    \ 2], [2, 4], [5, 6], [3, 5]])\n    [[1, 4], [5, 6]]\n*/\nimport std.algorithm\
    \ : sort, map, zip;\nlong[][] merge_intervals(long[][] intervals) \n{\n    auto\
    \ range = intervals.sort!((a, b) => a[0] < b[0]);\n    auto out = range.map!(a\
    \ => a.dup).front;\n    foreach (i, x; range) \n    {\n        auto y = out[$\
    \ - 1];\n        if (y[1] >= x[0]) \n        {\n            y[1] = max(y[1], x[1]);\n\
    \        } \n        else \n        {\n            out ~= x;\n        }\n    }\n\
    \    return out;\n}\n \n \n/*\n Given a string, write a function to check if it\
    \ is a permutation of a\n palindrome.\n    >>> is_palindrome_permutation(\"Taco\
    \ cat\")\n    true\n    >>> is_palindrome_permutation(\"Able was I ere I saw Elba\"\
    )", "{\n    // Iteration based method is easy, but inefficient. Let's see if we\
    \ can do better.\n    // We could use an associative array to keep track of occurences\
    \ of each number:\n    long[long] count = new long[long];\n    foreach (n; numbers)\
    \ {\n        count[n] += 1;\n    }\n    long[] result = new long[];\n    // Now\
    \ we need to iterate over the array again and copy all numbers with\n    // only\
    \ one occurence in it:\n    foreach (n; numbers) {\n        if (count[n] == 1)\
    \ {\n            result ~= n;\n        }\n    }\n    return result;\n}", "{\n\t\
    //long[] cnt = new long[64];\n\tint n = cast(int) numbers.length;\n\tauto set\
    \ = new int[n];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tset[i] = cast(int) numbers[i];\n\
    \t}\n\t\n\tint[] res = new int[n];\n\tint k = 0;\n\t//long start = clock();\n\t\
    for (int i = 0; i < n; i++)\n\t{\n\t\tint val = set[i];\n\t\tbool pass = true;\n\
    \t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tif (val == set[j])\n\t\t\t{\n\t\t\
    \t\tpass = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (pass)\n\t\t{\n\
    \t\t\tres[k] = val;\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\tlong[] final_res = new long[k];\n\
    \tfor (int i = 0; i < k; i++)\n\t{\n\t\tfinal_res[i] = cast(long) res[i];\n\t\
    }\n\t//printf(\"TIME: %fs\\n\", (clock() - start) / CLOCKS_PER_SEC);\n\treturn\
    \ final_res;\n}", "{ \n    long[] result = numbers[0..0]; \n    foreach (n; numbers)\
    \ \n    { \n        if (result.count(n) == 0) \n            result ~= n; \n  \
    \  } \n    return result; \n}", "{\n\tlong[] output;\n\tlong[] temp;\n\tint index\
    \ = 0;\n\ttemp = new long[];\n\tfor(int i = 0; i < numbers.length; i++) \n\t{\n\
    \t\tif(!temp.contains(numbers[i])) \n\t\t{\n\t\t\ttemp ~= numbers[i];\n\t\t}\n\
    \t}\n\toutput = new long[temp.length];\n\tfor(int j = 0; j < temp.length; j++)\
    \ \n\t{\n\t\toutput[j] = temp[j];\n\t}\n\treturn output;\n}", "{\n    long[] single_elements\
    \ = [];\n    foreach(n; numbers)\n    {\n        if(!single_elements.canFind(n))\n\
    \        {\n            single_elements ~= n;\n        }\n    }\n    return single_elements;\n\
    }\n \n/*\n    Given a list of words, remove the words that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([\"\
    the\", \"quick\", \"brown\", \"fox\", \"the\", \"fox\"])\n    [\"the\", \"quick\"\
    , \"brown\", \"fox\"]", "{\n    auto unique_numbers = Appender!(long[])();\n \
    \   auto already_seen = AssocArray!(long, bool)();\n    foreach(i; 0 .. numbers.length)\n\
    \    {\n        if(!already_seen.keyInSet(numbers[i]))\n        {\n          \
    \  unique_numbers.put(numbers[i]);\n            already_seen[numbers[i]] = true;\n\
    \        }\n    }\n    return unique_numbers.data;\n}", "{\n    long[] result;",
  "{\n    auto number_counts = count_occurrences(numbers);\n    return filter!((elem)\
    \ => number_counts[elem] == 1)(numbers);\n}", "{\n    long[] result = [];\n  \
    \  std.algorithm.nth_element(numbers, numbers.length / 2);\n    long pivot = numbers[numbers.length\
    \ / 2];\n    auto less_equal = std.typecons.scoped!(std.algorithm.less_equal)(pivot);\n\
    \    auto greater = std.typecons.scoped!(std.algorithm.greater)(pivot);\n    long[]\
    \ less = numbers.filter!less_equal;\n    long[] greater = numbers.filter!greater;\n\
    \    result = remove_duplicates(less) ~ result ~ remove_duplicates(greater);\n\
    \    return result;\n}", "{\n    long[] uniqs = new long[0];\n    foreach(long\
    \ number; numbers) \n    {\n        auto isUnique = true;\n        foreach(long\
    \ uniq; uniqs)\n        {\n            if(number == uniq)\n            {\n   \
    \             isUnique = false;\n                break;\n            }\n     \
    \   }\n        if(isUnique)\n        {\n            uniqs ~= number;\n       \
    \ }\n    }\n    return uniqs;\n}", "in\n{\n    // Body code\n}\nout(result)\n\
    {\n    // Body code\n}", "{\n    long[] result;\n    foreach(i; numbers) \n  \
    \  {\n        if(occurences(i, numbers) == 1) \n        {\n            result\
    \ ~= i;\n        }\n    }\n    return result;\n}\n/*\n    Returns an array of\
    \ frequencies of elements in arr.\n    >>> occurrences([1L, 2L, 2L, 3L])\n   \
    \ [1L, 2L, 1L]\n*/\nlong[] occurrences(long[] arr) \n{\n    long[] result;\n \
    \   foreach(i; arr) \n    {\n        result ~= occurences(i, arr);\n    }\n  \
    \  return result;\n}", "{\n  auto unique = unique_array!(long[], \"a < b\", \"\
    a == b\")(numbers);\n  //std.algorithm.uniq!((a, b) => a == b)(numbers);\n  //auto\
    \ unique = unique_array!(long[], \"a == b\")(numbers);\n  return unique;\n}",
  "{\n    auto result = new long[];\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n) == 1)\n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    // The std.algorithm.uniq on a sorted range will preserve\
    \ the order of the elements in the range.\n    return numbers.sort().uniq.array;\n\
    }", "    {\n    long[] results = [];\n    auto n_num = numbers.length;\n    foreach(int\
    \ i; 0..n_num)\n        {\n        foreach(int j; (i+1)..n_num)\n            {\n\
    \            if(numbers[i] == numbers[j])\n                {\n               \
    \ results ~= numbers[i];\n                break;\n                }\n        \
    \    }\n        }\n    return (numbers - results);\n    }\n/*\n From an array\
    \ of integers, remove all elements that occur more than once.\n    Keep order\
    \ of elements left the same as in the input.\n    >>> remove_duplicates([1L, 2L,\
    \ 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    */\nlong[] remove_duplicates_sort(long[]\
    \ numbers) \n    {\n    long[] results = [];\n    auto n_num = numbers.length;\n\
    \    numbers.sort;\n    foreach(int i; 0..n_num)\n        {\n        if(i == 0)\n\
    \            {\n            results ~= numbers[i];\n            }\n        else\n\
    \            {\n            if(numbers[i] != numbers[i-1])\n                {\n\
    \                results ~= numbers[i];\n                }\n            }\n  \
    \      }\n    return results;\n    }\n/*\n Given a string, return the sum of the\
    \ numbers appearing in the string, ignoring all other characters.\n    A number\
    \ is a series of 1 or more digit chars in a row.\n    >>> sum_numbers(\"abc123xyz\"\
    )\n    123\n    >>> sum_numbers(\"aa11b33\")\n    44\n    >>> sum_numbers(\"7\
    \ 11\")\n    18\n    */\nlong sum_numbers(string str) \n    {\n    long[] numbers\
    \ = [];\n    long sum = 0;\n    foreach(int i; 0..str.length)\n        {\n   \
    \     if(str[i].isDigit)\n            {\n            numbers ~= str[i].to!long;\n\
    \            }\n        }\n    foreach(long num; numbers)\n        {\n       \
    \ sum += num;\n        }\n    return sum;\n   ", "{\n    long[] result = [];\n\
    \    auto map = new Map!(typeof(numbers[0]), typeof(numbers[0]));\n    foreach(number;\
    \ numbers)\n    {\n        if(!map.containsKey(number))\n        {\n         \
    \   map[number] = number;\n            result ~= number;\n        }\n    }\n \
    \   return result;\n}", "{\n    long[] ret;\n    foreach(i; numbers)\n    {\n\
    \        if(ret.canFind(i))\n            continue;\n        ret ~= i;\n    }\n\
    \    return ret;\n}\n/*\n Given an array of integers, return an array with each\
    \ element repeated the specified number of times.\n    >>> repeat([1L, 2L, 3L],\
    \ 2L)\n    [1L, 1L, 2L, 2L, 3L, 3L]\n    >>> repeat([1L, 2L, 3L], 0L)\n    []\n\
    */\nlong[] repeat(long[] numbers, long repetitions) \n{\n    long[] ret;\n   \
    \ foreach(i; numbers)\n    {\n        for(int j = 0; j < repetitions; j++)\n \
    \           ret ~= i;\n    }\n    return ret;\n}\n/*\n Given an array of integers,\
    \ return a new array with each element copied from the input array in reverse\
    \ order.\n    >>> reverse([1L, 2L, 3L])\n    [3L, 2L, 1L]\n*/\nlong[] reverse(long[]\
    \ numbers) \n{\n    long[] ret;\n    foreach(i; numbers)\n    {\n        ret =\
    \ [i] ~ ret;\n    }\n    return ret;\n}\n/*\n Given an array of integers, return\
    \ an array of even and odd numbers.\n    >>> split_odd_even([1L, 2L, 3L, 4L, 5L,\
    \ 6L])\n    [[2L, 4L, 6L], [1L, 3L, 5L]]\n*/\nTuple!(long[], long[]) split_odd_even(long[]\
    \ numbers) \n{\n    long[] even, odd;\n    foreach(i; numbers)\n    {\n      \
    \  if(i % 2 == 0)\n            even ~= i;\n        else\n            odd ~= i;\n\
    \    }\n    return tuple(even, odd);\n}\n/*\n Given an array of integers, return\
    \ an array of primes.\n    >>> primes([2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n\
    \    [2L", "{\n    long[] result = [];\n    foreach(i; numbers)\n    {\n     \
    \   if(result.count(i) == 0)\n        {\n            result ~= i;\n        }\n\
    \    }\n    return result;\n}", "{\n    auto seen = tuple();\n    auto res = tuple();\n\
    \    foreach(num; numbers)\n    {\n        if (seen.canFind(num))\n          \
    \  continue;\n        else \n        {\n            seen ~= num;\n           \
    \ res ~= num;\n        }\n    }\n    return res;\n}", "{\n  return std.array.array(std.array.retain!(a\
    \ => !std.array.any!(b => a == b && a != b)(numbers))(numbers));\n}\n ", "{\n\
    \    import std.bitmanip;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.uni;\n    import std.conv;\n    import std.ascii;\n    import std.bigint;\n\
    \    import std.string;\n    import std.traits;\n    import std.functional;\n\
    \    import std.utility;\n    import std.algorithm;\n    import std.array;\n \
    \   import std.range;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.uni;\n    import std.conv;\n    import std.ascii;\n    import std.bigint;\n\
    \    import std.string;\n    import std.traits;\n    import std.functional;\n\
    \    import std.utility;\n    import std.algorithm;\n    import std.array;\n \
    \   import std.range;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.conv;\n    import std.ascii;\n    import std.bigint;\n    import std.string;\n\
    \    import std.traits;\n    import std.functional;\n    import std.utility;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.math;\n    import std.typecons;\n    import std.uni;\n    import\
    \ std.conv;\n    import std.ascii;\n    import std.bigint;\n    import std.string;\n\
    \    import std.traits;\n    import std.functional;\n    import std.utility;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.math;\n    import std.typecons;\n    import std.uni;\n    import\
    \ std.conv;\n    import std.ascii;\n    import std.bigint;\n    import std.string;\n\
    \    import std.traits;\n    import std.functional;\n    import std.utility;\n\
    \    import std.algorithm;\n    import std.array;\n    import", "{\n  return n_uniq(numbers);\n\
    }\n/*", "{\n  long[] result;\n  auto index = 0L;\n  foreach(i; numbers)\n  {\n\
    \    if(result.find(i) == -1)\n    {\n      result ~= i;\n    }\n  }\n  return\
    \ result;\n}\n/*\n    Crawl the web for the best phone numbers in the world.\n\
    \    >>> best_phone_numbers(1L)\n    [9081555555L]\n    \n*/\nlong[] best_phone_numbers(long\
    \ n) \n{\n  long[] result;\n  foreach(i; 0..n)\n  {\n    result ~= 9081555555L;\n\
    \  }\n  return result;\n}\n/*\n    Split the code into two sets of instructions:\n\
    \    >>> first_set_of_instructions(\"instruction(code)\")\n    [\"instruction(\"\
    , \")\"]\n    \n*/\nstring[] first_set_of_instructions(string code) \n{\n  return\
    \ [code[0..code.find(\"(\") + 1], code[code.find(\")\")..$]];\n}\n/*\n    Given\
    \ a number array in the form:\n        { {5L, 5L}, {2L, 5L}, {5L, 7L}, {1L, 7L},\
    \ {1L, 1L}, {5L, 3L}, {2L, 3L}, {5L, 2L}, {1L, 5L}, {2L, 2L}, {5L, 1L}, {1L, 2L},\
    \ {1L, 3L}, {2L, 7L}, {2L, 1L}, {1L, 6L}, {2L, 6L}, {5L, 4L}, {1L, 4L}, {2L, 4L}\
    \ }\n    Order it so that the largest number is on the outside and the smallest\
    \ number is on the inside.\n    >>> ring_ordering(numbers)\n    [2L, 1L, 3L, 6L,\
    \ 5L, 4L, 7L]\n    \n*/\nlong[] ring_ordering(long[][] numbers) \n{\n  long[]\
    \ result;\n  foreach(i; numbers)\n ", "{\n    int[] count = new int[numbers.length];\n\
    \    foreach(i; 0..numbers.length)\n    {\n        count[i] = 0;\n    }\n    foreach(i;\
    \ 0..numbers.length)\n    {\n        foreach(j; i+1..numbers.length)\n       \
    \ {\n            if(numbers[i] == numbers[j])\n            {\n               \
    \ count[i]++;\n                count[j]++;\n            }\n        }\n    }\n\
    \    long[] unique_numbers = new long[numbers.length];\n    int k = 0;\n    foreach(i;\
    \ 0..numbers.length)\n    {\n        if(count[i] == 0)\n        {\n          \
    \  unique_numbers[k] = numbers[i];\n            k++;\n        }\n    }\n    return\
    \ unique_numbers[0..k];\n}", "{\n    return std.algorithm.uniq(numbers).array;\n\
    }", "{\n\timport std.algorithm : uniq;\n\tauto result = numbers.uniq;\n\treturn\
    \ result;\n}", "{\n    long[] result;\n    /*\n        int[] result;\n       \
    \ int j = 0;\n        int i = 1;\n        while (i < numbers.length) {\n     \
    \       if (numbers[i] == numbers[j]) {\n                i++;\n            } else\
    \ {\n                j++;\n                numbers[j] = numbers[i];\n        \
    \        i++;\n            }\n        }\n        int[] output = new int[j + 1];\n\
    \        for (int k = 0; k < output.length; k++) {\n            output[k] = numbers[k];\n\
    \        }\n        return output;\n    */\n    return result;\n}", "{\n    long[]\
    \ noDupes = new long[];\n    long[] dupes = new long[];\n    foreach(n; numbers)\n\
    \    {\n        if(n in noDupes)\n        {\n            dupes ~= n;\n       \
    \ }\n        else\n        {\n            noDupes ~= n;\n        }\n    }\n  \
    \  numbers = numbers.dup;\n    foreach(d; dupes)\n    {\n        auto i = numbers.indexOf(d);\n\
    \        numbers = numbers[0..i] ~ numbers[i+1..$];\n    }\n    return numbers;\n\
    }\n/*\nExtract all non-overlapping substrings from a given string s that are palindromes.\n\
    \    Input strings will consist of only lowercase letters a-z.\n    Your function\
    \ should return an array of strings sorted in descending order of length.\n  \
    \  >>> palindromes(\"abracadabra\")\n    [\"aca\", \"cac\", \"ada\"]\n    >>>\
    \ palindromes(\"saippuakivikauppias\")\n    [\"saippuakivikauppias\", \"pp\",\
    \ \"ikauppi\", \"ikaupp\", \"aupp\", \"ipp\", \"ikaup\", \"au\", \"aippuakivikauppi\"\
    , \"ippua\", \"aippuakivikaupp\", \"aippuakivikaup\", \"aippuakivika\", \"ippuakivikauppi\"\
    , \"ivikauppias\", \"ikivikauppias\", \"auppias\", \"uvikauppias\", \"ikauppias\"\
    , \"aippuakivi\", \"ppuakivi\", \"ikivikauppi\", \"vikauppias\", \"aippuakiv\"\
    , \"uakivikauppias\", \"ppuakivikauppi\", \"ppuakivikaupp\", \"uakivikauppi\"\
    , \"kivikauppias\", \"ppuakivikaup\", \"ivikauppi\", \"ivikaupp\", \"kivikauppi\"\
    , \"ivika\", \"ikivikaupp\", \"ppuakivi\", \"ikivik", "{\n    return numbers.dup.sort.array.chunk(2).map!((element)\
    \ => element[0]).array;\n}", "{\n    import std.algorithm : max;\n    int max_number\
    \ = max(numbers);\n    ubyte[] is_present = new ubyte[max_number+1];\n    foreach\
    \ (num; numbers)\n    {\n        if (is_present[num] == 0)\n        {\n      \
    \      is_present[num] = 1;\n        }\n        else\n        {\n            is_present[num]\
    \ = 2;\n        }\n    }\n    return numbers.filter!(n => is_present[n] == 1);\n\
    }", "{\n\tMap!bool(long,bool) map = [numbers[0]:true];\n\tfor(size_t i = 1; i\
    \ < numbers.length; i++)\n\t{\n\t\tif(numbers[i] in map)\n\t\t{\n\t\t\tmap[numbers[i]]\
    \ = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmap[numbers[i]] = true;\n\t\t}\n\t}\n\
    \t\n\tlong[] unique = new long[0];\n\tforeach(elem; map.byKey)\n\t{\n\t\tif(map[elem])\n\
    \t\t{\n\t\t\tunique ~= elem;\n\t\t}\n\t}\n\treturn unique;\n}", "{\n    return\
    \ appender(numbers.dup)\n        .filter!((e) => !numbers.dup.filter!((e2) =>\
    \ e2 == e).popFront())().data;\n}", "{\n    auto result = numbers.dup;\n    size_t\
    \ i = 0;\n    foreach(n; numbers) \n    {\n        if (numbers[i] == n) \n   \
    \     {\n            result.removeAt(i);\n        }\n        else \n        {\n\
    \            i++;\n        }\n    }\n    return result;\n}", "{\n    auto no_duplicates\
    \ = numbers[0 .. $].uniq;\n    return no_duplicates;\n}", "{\n\t// as long as\
    \ they are in a range, we can use ints\n\tint[] count = new int[numbers.length];\n\
    \tlong[] result = new long[numbers.length];\n\tint nresults = 0;\n\tfor (int i\
    \ = 0; i < numbers.length; i++) {\n\t\tcount[i] = 0;\n\t}\n\tfor (int i = 0; i\
    \ < numbers.length; i++) {\n\t\tcount[i] = 0;\n\t\tfor (int j = 0; j < numbers.length;\
    \ j++) {\n\t\t\tif (numbers[i] == numbers[j]) {\n\t\t\t\tcount[i] += 1;\n\t\t\t\
    }\n\t\t}\n\t\tif (count[i] == 1) {\n\t\t\tresult[nresults] = numbers[i];\n\t\t\
    \tnresults += 1;\n\t\t}\n\t}\n\tresult = result[0..nresults];\n\treturn result;\n\
    }", "{\n    //array of bool for each number, if number exists set to true\n  \
    \  bool[] bools = new bool[numbers.length];\n    bool[] used = new bool[numbers.length];\n\
    \    //foreach used\n    bool first = true;\n    long used_number = 0;\n    bool\
    \ used_bool = false;\n    int used_number_index = 0;\n    int used_number_count\
    \ = 0;\n    int current_bools_index = 0;\n    int current_bools_counter = 0;\n\
    \    foreach(int index; 0..numbers.length)\n    {\n        //get first number\n\
    \        if(first)\n        {\n            used_number = numbers[index];\n   \
    \         used_bool = bools[index];\n            used_number_index = index;\n\
    \            used_number_count = current_bools_counter;\n            first = false;\n\
    \        }\n        else\n        {\n            //if number is same\n       \
    \     if(used_number == numbers[index])\n            {\n                //set\
    \ bool to true\n                bools[index] = true;\n                //add to\
    \ used\n                used[used_number_count] = used_bool;\n               \
    \ used_number_count++;\n                //used[used_number_count] = true;\n  \
    \          }\n            else\n            {\n                used_number = numbers[index];\n\
    \                used_bool = bools[index];\n                used_number_index\
    \ = index;\n                used_number_count = current_bools_counter;\n     \
    \       }\n        }\n        current_bools_counter++;\n    }\n    int total_duplicates\
    \ = 0;\n    foreach(i; used)\n    {\n        if(i)\n        {\n            total_duplicates++;\n\
    \        }\n    }\n    long[] result = new long[used.length - total_duplicates];\n\
    \    //copy to result without duplicates\n    int result_index = 0;\n    foreach(i;\
    \ used)\n    {\n        if(!i)\n        {\n            result[result_index] =\
    \ numbers[result_index];\n            result_index++;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    foreach(a; numbers)\n    {\n      \
    \  if(count(numbers, a) == 1)\n        {\n            result ~= a;\n        }\n\
    \    }\n    return result;\n}", "{\n    // write your code here\n    return numbers.removeDuplicates;\n\
    }", "{\n    import std.algorithm;\n    return numbers.sort().uniq.array;\n}",
  "{\n    long[] result = new long[0];\n    foreach(long number; numbers)\n    {\n\
    \        if(number !in result)\n        {\n            result ~= number;\n   \
    \     }\n    }\n    return result;\n}\n/*\n    Determine whether a given string\
    \ is a palindrome.\n    >>> is_palindrome(\"level\")\n    true\n    >>> is_palindrome(\"\
    rotor\")\n    true\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"\
    abs\")\n    false\n*/", "in {\n    foreach(n; numbers) n >= 0;\n}\nout (result)\
    \ {\n    foreach(n; result) n >= 0;\n    assert((size_t)result.length <= (size_t)numbers.length);\n\
    \    assert(result.sort().uniq().length == result.length);\n    assert(result.sort().uniq().sort()\
    \ == result.sort());\n}\nbody {\n    long[] res;\n    long last;\n    foreach(n;\
    \ numbers) {\n        if (n == last) {\n            continue;\n        }\n   \
    \     res ~= n;\n        last = n;\n    }\n    return res;\n}", "{\n    auto seen\
    \ = long[][](all(numbers));\n    sort(seen);\n    seen = uniq(seen);\n    return\
    \ seen;\n}", "{\n    import std.algorithm;\n    import std.range;\n    import\
    \ std.typecons;\n    import std.array;\n    return numbers.grouped(distinct).map!(a\
    \ => a[0]).array;\n}", "{\n    auto result = []{};\n    auto m = [numbers.length:\
    \ false];\n    foreach(n; numbers) {\n        if (!m[n]) {\n            result\
    \ ~= n;\n            m[n] = true;\n        }\n    }\n    return result;\n}\n/*\n\
    \    Given a list of strings and a number k, return the \n    first longest string\
    \ consisting of k consecutive strings taken in the list.\n    >>> first_longest_string([\"\
    zone\", \"abigail\", \"theta\", \"form\", \"libe\", \"zas\"], 2)\n    \"abigailtheta\"\
    \n*/\nstring first_longest_string(string[] list, int k)\n{\n    import std.array\
    \ : array;\n    auto myArray = array(list).joiner;\n    auto longestString = \"\
    \";\n    auto index = 0;\n    while(index < list.length - k + 1)\n    {\n    \
    \    auto slice = myArray.slice(index, index + k).to!string;\n        if(slice.length\
    \ > longestString.length)\n        {\n            longestString = slice;\n   \
    \     }\n        index++;\n    }\n    return longestString;\n}\n/*\n    Return\
    \ the sum of all elements in a given n x m two-dimensional list (list of lists).\n\
    \    >>> matrix_sum([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])\n    55\n*/", "{\n\
    \    if(numbers.length == 0)\n        return numbers;\n    if(numbers.length ==\
    \ 1)\n        return numbers;\n    if(numbers.length == 2)\n    {\n        if(numbers[0]\
    \ == numbers[1])\n            return new long[1] {numbers[0]};\n        else\n\
    \            return numbers;\n    }\n    long[] temp = new long[numbers.length];\n\
    \    temp[0] = numbers[0];\n    long count = 1;\n    for(size_t i = 1; i < numbers.length;\
    \ i++)\n    {\n        for(size_t j = 0; j < count; j++)\n        {\n        \
    \    if(numbers[i] == temp[j])\n                break;\n            if(j == count\
    \ - 1)\n            {\n                temp[count] = numbers[i];\n           \
    \     count++;\n            }\n        }\n    }\n    long[] result = new long[count];\n\
    \    for(size_t i = 0; i < count; i++)\n        result[i] = temp[i];\n    return\
    \ result;\n}", "{\n    auto seen = tuple();\n    return numbers.filter!(x => !seen.contains(x))\n\
    \                    .map!(x => seen ~= x)\n                    .array;\n}", "{\n\
    \    long[] sorted_numbers = std.algorithm.sort(numbers);\n    long[] unique_numbers\
    \ = [sorted_numbers[0]];\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        if (sorted_numbers[i] != sorted_numbers[i-1])\n        {\n          \
    \  unique_numbers ~= sorted_numbers[i];\n        }\n    }\n    return unique_numbers;\n\
    }\n \n \n \n \n/*\n    Find the first occurrence of an element in a sorted array.\n\
    \    >>> binary_search([1L, 2L, 3L, 2L, 4L], 2L)\n    1\n    >>> binary_search([1L,\
    \ 2L, 3L, 2L, 4L], 6L)\n    -1\n*/\n//TODO: Write function (and test)", "{\n \
    \   long[] res;\n    foreach(long num; numbers)\n    {\n        if (num in res)\
    \ \n        {\n            res = res.dup;\n            continue;\n        }\n\
    \        res ~= num;\n    }\n    return res;\n}\n/*\n    See how many times each\
    \ element occurs in an array of integers. \n    Return a dictionary with elements\
    \ as keys and number of occurences as values.\n    >>> count_occurences([1L, 2L,\
    \ 2L, 3L, 3L, 4L])\n    [1L: 1, 2L: 2, 3L: 2, 4L: 1]\n*/\nlong[long] count_occurences(long[]\
    \ numbers) \n{\n    long[long] res;\n    foreach(long num; numbers)\n    {\n \
    \       res[num]++;\n    }\n    return res;\n}\n/*\n    Check whether an array\
    \ of integers contains an element at least as big as the given one.\n    >>> has_big_element([1L,\
    \ 3L, 5L], 4L)\n    true\n    >>> has_big_element([1L, 3L, 5L], 5L)\n    true\n\
    \    >>> has_big_element([1L, 3L, 5L], 6L)\n    false\n*/", "{\n    long[] result\
    \ = [];\n    foreach(n; numbers) \n    {\n        if(!result.canFind(n)) \n  \
    \      {\n            result ~= n;\n        }\n    }\n    return result;\n}\n\
    /*\n    Take an array of integers and return a sorted version.\n    >>> remove_duplicates([4L,\
    \ 1L, 2L, 3L])\n    [1L, 2L, 3L, 4L]\n*/\nlong[] remove_duplicates2(long[] numbers)\
    \ \n{\n    long[] result = [];\n    foreach(n; numbers) \n    {\n        if(!result.canFind(n))\
    \ \n        {\n            result ~= n;\n        }\n    }\n    return result.sort();\n\
    }\n/*\n    Find the min element in the array.\n    >>> min([4L, 1L, 2L, 3L])\n\
    \    1L\n*/\nlong min(long[] numbers) \n{\n    long result = 0;\n    foreach(n;\
    \ numbers) \n    {\n        if(n<result) \n        {\n            result = n;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Find the max element in the\
    \ array.\n    >>> max([4L, 1L, 2L, 3L])\n    4L\n*/\nlong max(long[] numbers)\
    \ \n{\n    long result = 0;\n    foreach(n; numbers) \n    {\n        if(n>result)\
    \ \n        {\n            result = n;\n        }\n    }\n    return result;\n\
    }\n/*\n    Return an array without min and max elements.\n    >>> without_min_max([4L,\
    \ 1L, 2L, 3L])\n    [2L, 3L]\n*/\nlong[] without_min_max(long[] numbers) \n{\n\
    \    long[] result = [];\n    foreach(n; numbers) \n    {\n        if(n!=max(numbers)\
    \ && n!=min(numbers)) \n        {\n            result ~= n;\n        }\n    }\n\
    \    return result;\n}\n/*\n    Return an", "{\n    immutable long[] result;\n\
    \    foreach(i; 0 .. numbers.length)\n    {\n        if(occurrencesOf(numbers[i],\
    \ numbers) == 1)\n        {\n            result ~= numbers[i];\n        }\n  \
    \  }\n    return result;\n}", "{\n    long[]  output = [];\n    long[] tempArray\
    \ = [];\n    foreach(n; numbers)\n    {\n        if(tempArray.canFind(n))\n  \
    \      {\n        }\n        else\n        {\n            tempArray.insertBack(n);\n\
    \            output.insertBack(n);\n        }\n    }\n    return output;\n}",
  "{\n    long[] result = [];\n    foreach(n; numbers)\n    {\n        if(count(numbers,\
    \ n)==1)\n        {\n            result~=n;\n        }\n    }\n    return result;\n\
    }", "{\n    auto set = std.set(numbers);\n    return set.array;\n}", "{\n    auto\
    \ map = std.typecons.Map!(long, long)();\n    foreach(num; numbers)\n    {\n \
    \       if(map.count(num) == 0)\n        {\n            map[num] = num;\n    \
    \    }\n    }\n    return map.values;\n}", "{\n    /*\n    This algorithm is important\n\
    \    The basic idea is to use a result array and keep track of each integer that\
    \ has been seen\n    with a set\n    */\n    bool[] occured = new bool[std.numeric.max(numbers)\
    \ + 1];\n    long[] result = new long[];\n    foreach(num; numbers)\n    {\n \
    \       if(!occured[num])\n        {\n            result ~= num;\n           \
    \ occured[num] = true;\n        }\n    }\n    return result;\n}\n// Another way\
    \ to solve this\nlong[] remove_duplicates2(long[] numbers) \n{\n    /*\n    The\
    \ idea here is to create a set of the numbers, and then convert that to an array\n\
    \    */\n    long[] result = new long[];\n    foreach(num; std.set(numbers))\n\
    \    {\n        result ~= num;\n    }\n    return result;\n}\n// A faster way\
    \ to solve this\nlong[] remove_duplicates3(long[] numbers) \n{\n    /*\n    The\
    \ idea here is to use a hash table to keep track of each integer that has been\
    \ seen\n    with a set\n    */\n    long[] result = new long[];\n    bool[long]\
    \ occured = new bool[long];\n    foreach(num; numbers)\n    {\n        if(!occured[num])\n\
    \        {\n            result ~= num;\n            occured[num] = true;\n   \
    \     }\n    }\n    return result;\n}\n/*\nFor a positive integer k, and a positive\
    \ integer n > k, find the number of ways of counting \nfrom 1 to n, such that\
    \ exactly k of the steps have a decimal digit \"1\" in them. \n    Return a long\
    \ integer giving the number of ways. \n    >>> ways(1L, 3L)\n    3L\n*/\nlong\
    \ ways(long k, long n) \n{\n    assert(k >= 0);\n    assert(n > k);\n    /*\n\
    \    A pretty simple solution is to just count the number of ways, and modulo\
    \ it by 10^9 + 7\n    */\n    long count = 0;\n    long dn = n", "{\n    //std.algorithm.uniq\
    \ is used to remove duplicate values\n    //std.array.array is used to convert\
    \ the d_range to a slice\n    //std.algorithm.sort() is used to order the slice\n\
    \    return array(std.algorithm.sort(std.algorithm.uniq(numbers)));\n}\n/*\n Given\
    \ a list of integers, convert it to an array.\n    If original list has duplicates,\
    \ they must be left in the array.\n    If original list is empty, it's still considered\
    \ a list, so return a slice of length 0.\n    >>> list_to_array([])\n    []\n\
    \    >>> list_to_array([1L, 2L, 3L])\n    [1L, 2L, 3L]\n    >>> list_to_array([1L,\
    \ 2L, 2L, 3L])\n    [1L, 2L, 2L, 3L]\n*/\nlong[] list_to_array(List!long numbers)\
    \ \n{\n    return numbers.dup;\n}\n/*\n Given a string, return it in camel case.\n\
    \    If first letter is capitalized in the original string, it must be capitalized\
    \ in the result as well.\n    >>> to_camel_case(\"aBc\")\n    \"aBc\"\n    >>>\
    \ to_camel_case(\"a b c\")\n    \"aBc\"\n    >>> to_camel_case(\"a bC\")\n   \
    \ \"aBC\"\n    >>> to_camel_case(\"\")\n    \"\"\n*/\nstring to_camel_case(string\
    \ input) \n{\n    //std.string.toUpper is used to capitalize the first letter\
    \ of the word\n    //std.string.toLower is used to change the remaining letters\
    \ to lowercase\n    //std.array.array is used to convert the d_range to a slice\n\
    \    //std.string.titleCase is used to capitalize the first letter of each word\n\
    \    return string.titleCase(input.toLower());\n}\n/*\n Given a string, return\
    \ it in snake case.\n    >>> to_snake_case(\"HelloWorld\")\n    \"hello_world\"\
    \n    >>> to_snake_case(\"My name is Ed\")", "{\n    Map!long accum = new Map!long();\n\
    \    foreach(num; numbers) \n    {\n        accum[num]++;\n    }\n    long[] output\
    \ = new long[];\n    foreach(num; numbers) \n    {\n        if(accum[num] == 1)\
    \ \n        {\n            output ~= num;\n        }\n    }\n    return output;\n\
    }\n//int[] remove_duplicates(int[] numbers) \n//{\n//    Map!int accum = new Map!int();\n\
    //    foreach(num; numbers) \n//    {\n//        accum[num]++;\n//    }\n//  \
    \  int[] output = new int[];\n//    foreach(num; numbers) \n//    {\n//      \
    \  if(accum[num] == 1) \n//        {\n//            output ~= num;\n//       \
    \ }\n//    }\n//    return output;\n//}", "{\n    auto found = true;\n    long[]\
    \ not_duplicates = [0L];\n    foreach(number; numbers)\n    {\n        foreach(num;\
    \ not_duplicates)\n        {\n            if(number == num)\n            {\n \
    \               found = false;\n                break;\n            }\n      \
    \  }\n        if(found)\n        {\n            not_duplicates ~= number;\n  \
    \      }\n        found = true;\n    }\n    return not_duplicates;\n}", "{\n \
    \   int[int] set;\n    foreach(n; numbers)\n    {\n        if(set.count(n) ==\
    \ 0)\n        {\n            set[n] = 1;\n        }\n        else\n        {\n\
    \            set[n]++;\n        }\n    }\n    auto result = nogc(new long[0]);\n\
    \    foreach(n; numbers)\n    {\n        if(set[n] == 1)\n        {\n        \
    \    result ~= n;\n        }\n    }\n    return result;\n}\n ", "{ \n    long[]\
    \ new_numbers = [];\n    auto numbers_set = new Set!long(numbers);\n    foreach(n;\
    \ numbers_set)\n    {\n        new_numbers ~= n;\n    }\n    return new_numbers;\n\
    }\nremove_duplicates([1L, 2L, 3L, 2L, 4L])", "{\n    if (numbers.length <= 1)\n\
    \        return numbers;\n    else\n    {\n        auto i = 0;\n        // auto\
    \ d = numbers.dup;\n        // auto count = numbers.count;\n        auto r = new\
    \ long[](numbers.length);\n        foreach (n; numbers)\n        {\n         \
    \   if (numbers.count(n) == 1)\n            {\n                r[i] = n;\n   \
    \             i++;\n            }\n        }\n        // return numbers.retain!(a\
    \ => numbers.count(a) == 1);\n        return r.array(0, i);\n    }\n}\n/*\n  \
    \  Write a program that takes a list of numbers (for example, a = [5, 10, 15,\
    \ 20, 25]) \n    and makes a new list of only the first and last elements of the\
    \ given list. \n    For practice, write this code inside a function.\n    >>>\
    \ first_last([5, 10, 15, 20, 25])\n    [5, 25]\n*/\nlong[] first_last(long[] numbers)\
    \ \n{\n    return [numbers[0], numbers[numbers.length - 1]];\n}\n/*\n    Write\
    \ a program that accepts a comma separated sequence of words as input and \n \
    \   prints the words in a comma-separated sequence after sorting them alphabetically.\n\
    \    Suppose the following input is supplied to the program:\n    without,hello,bag,world\n\
    \    Then, the output should be:\n    bag,hello,without,world\n*/", "{\n    long[]\
    \ unique = new long[];\n    foreach(num; numbers)\n    {\n        if(num !in unique)\n\
    \        {\n            unique ~= num;\n        }\n    }\n    return unique;\n\
    }\n/*\n Given a list of numbers and a positive integer k, return whether any two\
    \ numbers from the list add up to k.\n    >>> find_pair([10L, 15L, 3L, 7L], 17L)\n\
    \    true\n    \n*/", "{\n    \n    \n    auto numbers2 = numbers.dup;\n    numbers2.sort;\n\
    \    long[] r;\n    r.length = numbers2.length;\n    foreach(i, v; numbers2)\n\
    \    {\n        if (v!=numbers2[i-1])\n        {\n            r~=v;\n        }\n\
    \    }\n    return r;\n}", "{\n    //assert(numbers.length > 0);\n    long[] res\
    \ = new long[0];\n    auto prev = numbers[0];\n    res ~= prev;\n    for (int\
    \ i = 1; i < numbers.length; i++) \n    {\n        if (numbers[i] != prev) \n\
    \        {\n            res ~= numbers[i];\n            prev = numbers[i];\n \
    \       }\n    }\n    return res;\n}\n/*", "{\n    auto num_freq = array(int).init;\n\
    \    foreach(n; numbers) {\n        auto frequency = num_freq.get(n);\n      \
    \  num_freq[n] = frequency + 1;\n    }\n    return [for(n; numbers) if(num_freq[n]\
    \ == 1)] ;\n}", "{\n    import std.algorithm;\n    import std.array;\n    import\
    \ std.typecons;\n    import std.math;\n    return numbers.groupBy.length.retain((k,\
    \ v) => k == 1).expand.array;\n}", "{\n    long[] list;\n    foreach(index, ref\
    \ n; numbers)\n    {\n        auto found = list.countUntil(i => i == n);\n   \
    \     if(found == 0)\n        {\n            list ~= n;\n        }\n    }\n  \
    \  return list;\n}", "{\n    long[] result = [];\n    long[] numbers_set = set(numbers);\n\
    \    foreach(number; numbers_set)\n    {\n        if(count(numbers, number) ==\
    \ 1)\n        {\n            result ~= number;\n        }\n    }\n    return result;\n\
    }", "{\n  import std.algorithm : unique;\n  import std.array : removeDuplicates;\n\
    \  return numbers.removeDuplicates;\n}\n ", "{\n    immutable long[] results;\n\
    \    long[] newArray;\n    //put numbers in tuple of 2\n    foreach(number; numbers)\n\
    \    {\n        immutable long[] temp = [number,1];\n        results ~= temp;\n\
    \    }\n    /*\n    foreach(numbers2; numbers)\n    {\n        auto temp = results;\n\
    \        foreach(i; temp)\n        {\n            if(i[0] == numbers2)\n     \
    \       {\n                immutable int index = i[1];\n                immutable\
    \ int original = results[index][1];\n                immutable int newNum = results[index][1]\
    \ + 1;\n                results[index][1] = newNum;\n            }\n        }\n\
    \    }\n    */\n    foreach(i; results)\n    {\n        if(i[1] == 1)\n      \
    \  {\n            newArray ~= i[0];\n        }\n    }\n    return newArray;\n}",
  "{ \n    long[] tmp=new long[numbers.length];\n    long[] tmp2=new long[numbers.length];\n\
    \    int i,j,k;\n    k=0;\n    j=0;\n    for(i=0;i<numbers.length;i++)\n    {\n\
    \        if(i==0)\n        {\n            tmp[j]=numbers[i];\n            j++;\n\
    \        }\n        else\n        {\n            for(int l=0;l<j;l++)\n      \
    \      {\n                if(numbers[i]==tmp[l])\n                {\n        \
    \            break;\n                }\n                else\n               \
    \ {\n                    tmp[j]=numbers[i];\n                    j++;\n      \
    \          }\n            }\n        }\n    }\n    for(i=0;i<numbers.length;i++)\n\
    \    {\n        for(int m=0;m<j;m++)\n        {\n            if(numbers[i]==tmp[m])\n\
    \            {\n                tmp2[k]=numbers[i];\n                k++;\n  \
    \          }\n        }\n    }\n    return tmp2[0..k];\n}", "{\n    long[] seen\
    \ = new long[];\n    long[] res = new long[];\n    foreach(n; numbers)\n    {\n\
    \        if (n in seen) continue;\n        res ~= n;\n        seen ~= n;\n   \
    \ }\n    return res;\n}", "{\n    auto seen = typeof(seen)();\n    long[] result\
    \ = [];\n    foreach (number; numbers) \n    {\n        if (seen.insert(number))\n\
    \            result ~= number;\n    }\n    return result;\n}", "{\n    auto result\
    \ = appender!(long[])();\n    int[] occurences = new int[numbers.length];", "{\n\
    \    long[] result;\n    foreach(long number; numbers)\n    {\n        if(find(result,\
    \ number) == -1)\n        {\n            result ~= number;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    foreach(i,n; numbers)\n \
    \   {\n        if(n in result)\n            continue;\n        else\n        \
    \    result ~= n;\n    }\n    return result;\n}", "{\n    // First find out the\
    \ unique elements in the array\n    size_t unique_count = 0;\n    bool[] unique_elems\
    \ = new bool[numbers.length];\n    for (size_t i = 0; i < numbers.length; i++)\
    \ \n    {\n        bool unique = true;\n        for (size_t j = 0; j < i; j++)\
    \ \n        {\n            if (numbers[i] == numbers[j]) \n            {\n   \
    \             unique = false;\n                break;\n            }\n       \
    \ }\n        if (unique) \n        {\n            unique_elems[i] = true;\n  \
    \          unique_count++;\n        }\n    }\n    long[] result = new long[unique_count];\n\
    \    size_t k = 0;\n    for (size_t i = 0; i < numbers.length; i++) \n    {\n\
    \        if (unique_elems[i]) \n        {\n            result[k] = numbers[i];\n\
    \            k++;\n        }\n    }\n    return result;\n}", "{\n    long[] b\
    \ = numbers.dup;\n    long[] a = numbers.dup;\n    // b = a.dup;\n    long i =\
    \ 0;\n    long j = 0;\n    while (i < a.length)\n    {\n        long q = 0;\n\
    \        while (q < a.length)\n        {\n            if (a[i] == b[q]) \n   \
    \         {\n                b[q] = 0;\n            }\n            q = q + 1;\n\
    \        }\n        i = i + 1;\n    }\n    return b;\n}\n/*\nTake a list of coins,\
    \ and a target sum of money. Return the smallest number of coins needed to make\
    \ change for the sum.\n    >>> make_change([1L, 2L, 5L], 11L)\n    3L\n*/\nlong\
    \ make_change(long[] coins, long sum) \n{\n    long total = 0;\n    long m = 0;\n\
    \    while (total < sum)\n    {\n        total = total + coins[m];\n        m\
    \ = m + 1;\n    }\n    return m;\n}", "{\n    return numbers.dup.retain!(a =>\
    \ numbers.count(a) == 1);\n}", "{\n    long[] distinct = numbers.dup;\n    distinct.sort;\n\
    \    distinct.removeAdjacentDuplicates;\n    return distinct;\n}", "{\n    if(numbers.length==0)\n\
    \        return numbers;\n    if(numbers.length==1)\n        return numbers;\n\
    \    else\n    {\n        long[] list = new long[numbers.length];\n        long[]\
    \ list1 = new long[numbers.length];\n        ulong size = 0ul;\n        foreach(ulong\
    \ index, long value; numbers)\n        {\n            if(find(numbers,value,index+1ul)==0)\n\
    \            {\n                list[size] = value;\n                size++;\n\
    \            }\n        }\n        copy(list1, list);\n        return list1[0..size];\n\
    \    }\n}\n/*\nGiven an array of integers, \nmove all the zeros to the end of\
    \ the array and return it.\n>>> move_zeros([1L, 2L, 0L, 3L, 0L, 5L, 6L, 0L])\n\
    [1L, 2L, 3L, 5L, 6L, 0L, 0L, 0L]\n*/\nlong[] move_zeros(long[] numbers)\n{\n \
    \   if(numbers.length==0)\n        return numbers;\n    if(numbers.length==1)\n\
    \        return numbers;\n    else\n    {\n        long[] list = new long[numbers.length];\n\
    \        long[] list1 = new long[numbers.length];\n        ulong size = 0ul;\n\
    \        foreach(ulong index, long value; numbers)\n        {\n            if(value!=0)\n\
    \            {\n                list[size] = value;\n                size++;\n\
    \            }\n        }\n        foreach(ulong index, long value; numbers)\n\
    \        {\n            if(value==0)\n            {\n                list[size]\
    \ = value;\n                size++;\n            }\n        }\n        copy(list1,\
    \ list);\n        return list1;\n    }\n}\n/*\nGiven a list of integers, if the\
    \ absolute difference between two elements is 1, \nand there are two elements\
    \ that are the same, remove one of them.\n>>> _remove_one_if_equal_and_adjacent([3L,\
    \ 1L, 1L, 3", "{\n  long[] result = numbers.dup;\n  result = result.retain(x =>\
    \ result.count(x) == 1);\n  return result;\n}", "{\n    long[] result;\n    foreach(num;\
    \ numbers)\n    {\n        if(! result.canFind(num))\n        {\n            result\
    \ ~= num;\n        }\n    }\n    return result;\n}", "{\n    long[] arr = [];\n\
    \    foreach(n; numbers)\n    {\n        if(arr.count(n)==0)\n        {\n    \
    \        arr ~= n;\n        }\n    }\n    return arr;\n}", "    in(numbers)\n\
    \    out(numbers)\n{\n    long[] unique = new long[numbers.length];\n    int j\
    \ = 0;\n    foreach (num; numbers)\n    {\n        if (std.algorithm.count(numbers,\
    \ num) == 1)\n        {\n            unique[j] = num;\n            j++;\n    \
    \    }\n    }\n    return unique.idup.idup[0..j];\n}\n/*\n    Shift the the array\
    \ left by 1 position. The first element of the array\n    becomes the last element.\n\
    \    >>> shift_left([1L, 2L, 3L, 4L])\n    [2L, 3L, 4L, 1L]\n*/\nlong[] shift_left(long[]\
    \ numbers) \n    in(numbers)\n    out(numbers)\n{\n    long[] shifted = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        shifted[i] = numbers[(i\
    \ + 1) % numbers.length];\n    }\n    return shifted;\n}", "{\n    long[long]\
    \ seen = numbers.assoc;\n    long[] ret = numbers.dup;\n    foreach(i, int x;\
    \ numbers)\n    {\n        if(seen[x] > 1)\n        {\n            ret[i] = -1;\n\
    \        }\n    }\n    ret = ret.filter!(x => x != -1)();\n    return ret;\n}",
  "{\n    auto l = new long[](numbers.length);\n    int j = 0;\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if (numbers[i] != numbers[i + 1])\n\
    \        {\n            l[j] = numbers[i];\n            j++;\n        }\n    }\n\
    \    return l[0..j];\n}", "in {\n    assert(numbers.length >= 0);\n    foreach(i;\
    \ 0 .. numbers.length) {\n        assert(numbers[i] >= 0);\n    }\n}\nout (result)\
    \ {\n    assert(result.length <= numbers.length);\n    auto is_duplicate = tuple!(long)();\n\
    \    foreach(i; 0 .. numbers.length) {\n        bool found = false;\n        foreach(j;\
    \ 0 .. numbers.length) {\n            if (i != j && numbers[i] == numbers[j])\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        if (found) {\n            is_duplicate ~= numbers[i];\n    \
    \    }\n    }\n    foreach(i; 0 .. result.length) {\n        bool found = false;\n\
    \        foreach(j; 0 .. numbers.length) {\n            if (result[i] == numbers[j])\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        assert(found);\n        found = false;\n        foreach(j; 0\
    \ .. is_duplicate.length) {\n            if (result[i] == is_duplicate[j]) {\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        assert(!found);\n    }\n}\n{\n    auto is_duplicate = tuple!(long)();\n\
    \    foreach(i; 0 .. numbers.length) {\n        bool found = false;\n        foreach(j;\
    \ 0 .. numbers.length) {\n            if (i != j && numbers[i] == numbers[j])\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        if (found) {\n            is_duplicate ~= numbers[i];\n    \
    \    }\n    }\n    return filter!(\n        (num) => {\n            bool found\
    \ = false;\n            foreach(i; 0 .. is_duplicate.length) {\n             \
    \   if (num == is_duplicate[i]) {\n                    found = true;\n       \
    \             break;\n                }\n            }\n            return !found;\n\
    \        }\n    )(numbers);\n", "{\n    auto result = [];\n    ulong i;\n    for\
    \ (i = 0; i < numbers.length; i++)\n    {\n        if (result.canFind(numbers[i]))\n\
    \        {\n            continue;\n        }\n        else\n        {\n      \
    \      result ~= numbers[i];\n        }\n    }\n    return result;\n}\n/*\nDetermine\
    \ whether a string is an isogram or not.\nAn isogram is a word that has no repeating\
    \ letters, consecutive or non-consecutive.\n    >>> is_isogram(\"Dermatoglyphics\"\
    )\n    True\n    >>> is_isogram(\"isogram\")\n    True\n    >>> is_isogram(\"\
    aba\")\n    False\n    >>> is_isogram(\"moOse\")\n    False\n*/", "in \n{\n\t\
    assert(numbers.length > 0);\n}\nout (result)\n{\n\tassert(result.length <= numbers.length);\n\
    \tfor (i in 0..result.length-1)\n\t\tassert(result[i] == numbers[i]);\n\t\n\t\
    // Remove duplicates\n\t// if there is at least one duplicate, remove the first\
    \ one\n\t//\n\tassert((numbers.length - result.length) >= \n\t\tall(i in 0..numbers.length-1\n\
    \t\t\t| let elem = numbers[i];\n\t\t\tif (result.contains(elem))\n\t\t\t\t! result.contains(elem,\
    \ i+1, numbers.length)));\n}\n{\n\tT[] result = new T[numbers.length];\n\tint\
    \ j = 0;\n\tfor (i in 0..numbers.length-1)\n\t{\n\t\tint elem = numbers[i];\n\t\
    \tif (! result.contains(elem, 0, j))\n\t\t{\n\t\t\tresult[j] = elem;\n\t\t\tj++;\n\
    \t\t}\n\t}\n\treturn result[0..j];\n}", "{\n\tlong[] copy = numbers[];\n\tlong[]\
    \ fin = copy.length >= 2 ? copy[0..1] : copy;\n\tfor(int i = 2; i < copy.length;\
    \ i++)\n\t{\n\t\tif(copy[i-1] != copy[i])\n\t\t{\n\t\t\tfin ~= copy[i];\n\t\t\
    }\n\t}\n\treturn fin;\n}\n/*\n Write a function that takes a string and returns\
    \ a set of all the \n    single characters that appear in it. The returned set\
    \ should be \n    sorted.", "in {\n  assert(numbers.length > 0);\n  foreach(i,_;\
    \ numbers)\n    assert(i >= 0);\n}\nout (result) {\n  assert(result.length <=\
    \ numbers.length);\n  foreach(i,x; result)\n    assert(numbers[i] == x);\n  assert(\n\
    \      result.length ==\n      numbers.length -\n      (numbers.length - result.length)*\n\
    \      numbers.length*(numbers.length-1));\n  foreach(i,x; result)\n    foreach(j,y;\
    \ result)\n      if(i<j) assert(x != y);\n}\n{\n  long[] result = numbers[];\n\
    \  foreach(i,x; result)\n    foreach(j,y; result)\n      if(i<j && x == y) {\n\
    \        result.remove(i);\n        break;\n      }\n  return result;\n}", "{\
    \ \n    HashSet!long s = new HashSet!long();\n    foreach(n; numbers) \n    {\n\
    \        if(!s.insert(n))\n            s.remove(n);\n    }\n    return s.keys;\n\
    }", "{\n    auto result = new long[0];\n    foreach(n; numbers) \n    {\n    \
    \    if(n.canFind(numbers)) \n        {\n            result ~= n;\n        }\n\
    \    }\n    return result;\n}", "{\n    import std.algorithm.comparison : equal;\n\
    \    import std.algorithm.iteration : filter;\n    import std.range;\n    import\
    \ std.array;\n    import std.math;\n    import std.typecons;\n    immutable long[]\
    \ uniqueNumbers = unique(numbers);\n    long[] finalNumbers = new long[];\n  \
    \  foreach(n; uniqueNumbers)\n    {\n        immutable long[] filtered = filter!(a\
    \ => a == n)(numbers);\n        if(filtered.length == 1)\n        {\n        \
    \    finalNumbers ~= n;\n        }\n    }\n    return finalNumbers;\n}\n/*\n From\
    \ an array of integers, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates(long[]\
    \ numbers) \n{\n    import std.algorithm.comparison : equal;\n    import std.algorithm.iteration\
    \ : filter;\n    import std.range;\n    import std.array;\n    import std.math;\n\
    \    import std.typecons;\n    immutable long[] uniqueNumbers = unique(numbers);\n\
    \    long[] finalNumbers = new long[];\n    foreach(n; uniqueNumbers)\n    {\n\
    \        immutable long[] filtered = filter!(a => a == n)(numbers);\n        if(filtered.length\
    \ == 1)\n        {\n            finalNumbers ~= n;\n        }\n    }\n    return\
    \ finalNumbers;\n}\n/*\n Find the first element of a list that meets a given condition.\n\
    \    If no elements meet the condition, return -1.\n    >>> find_first_where((x)\
    \ => x > 5L, [1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    6L\n    >>> find_first_where((x)\
    \ => x > 10L, [1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    -1L\n    \n*/\nlong find_first_",
  "{\n    if(numbers.length == 0)\n        return [];\n    \n    long[] first_array\
    \ = [];\n    long[] second_array = [];\n    foreach(number; numbers)\n    {\n\
    \        if(number in first_array)\n        {\n            if(number !in second_array)\n\
    \                second_array ~= number;\n        }\n        else\n          \
    \  first_array ~= number;\n    }\n    return first_array.remove(second_array);\n\
    }\n/*\nGiven two arrays a and b of numbers, return an array that \ncontains all\
    \ the sums of the elements of b, depending on the index\n    >>> a = [1L,2L,3L]\n\
    \    >>> b = [4L,5L,6L]\n    >>> pairs_sum(a, b)\n    [5L, 7L, 9L]\n    \n*/\n\
    long[] pairs_sum(long[] a, long[] b) \n{\n    if(a.length == 0 || b.length ==\
    \ 0)\n        return [];\n    \n    long[] result = [];\n    foreach(i, number;\
    \ a)\n    {\n        auto sum = number + b[i];\n        result ~= sum;\n    }\n\
    \    return result;\n}\n/*\nFrom a list of tuples `l`, remove all tuples of the\
    \ form `(i, j)`\nwhere `i` is divisible by `j`. Keep order of remaining tuples\
    \ the same as in the input.\n    >>> remove_divisible([(1L, 2L), (2L, 4L), (3L,\
    \ 2L), (8L, 4L)])\n    [(1L, 2L), (3L, 2L)]\n*/\nTuple!(long, long)[] remove_divisible(Tuple!(long,\
    \ long)[] l) \n{\n    if(l.length == 0)\n        return [];\n    \n    auto result\
    \ = l.dup;\n    foreach(tuple; l)\n    {\n        auto i = tuple[0];\n       \
    \ auto j = tuple[1];\n        if(i % j == 0)\n            result.remove(tuple);\n\
    \    }\n    return result", "{\n  long[] tmp = numbers[];\n  tmp.sort;\n  auto\
    \ t = new typeof(tmp);\n  auto result = new t();\n  if (tmp.length > 0)\n    result\
    \ ~= tmp[0];\n  for (long i = 1; i < tmp.length; i++)\n  {\n    if (tmp[i] !=\
    \ tmp[i-1])\n      result ~= tmp[i];\n  }\n  return result;\n}", "{\n    return\
    \ numbers.join.group.filter!(a => a.length == 1).joiner.take(numbers.length).array;\n\
    }", "{\n    long[] result;\n    result.length = 0;\n    int i = 0;\n    while\
    \ (i < numbers.length) \n    {\n        int j = 0;\n        while (j < result.length)\
    \ \n        {\n            if (numbers[i] == result[j])\n                break;\n\
    \            j = j + 1;\n        }\n        if (j == result.length)\n        \
    \    result ~= numbers[i];\n        i = i + 1;\n    }\n    return result;\n}",
  "{\n    long[int] counts;\n    foreach(n; numbers)\n    {\n        counts[n]++;\n\
    \    }\n    return numbers.filter!(n => counts[n] == 1);\n}", "{\n    long[] remove_duplicates(long[]\
    \ numbers) {\n        auto result = appender!(long[])();\n        auto seen =\
    \ HashSet!(long)();\n        foreach (n; numbers) {\n            if (seen.insert(n))\n\
    \                result.put(n);\n        }\n        return result.data;\n    }\n\
    }", "{\n\tif (numbers.length==0)\n\t\treturn numbers;\n\tlong[] result = new long[];\n\
    \tforeach(n; numbers)\n\t{\n\t\tif (numbers.count(n)==1)\n\t\t\tresult ~= n;\n\
    \t}\n\treturn result;\n}", "{\n    auto dict = new std.typecons.Tuple!(ulong,long)[numbers.length];\n\
    \    auto res = new long[];\n    // println(res.length);\n    foreach(idx, number;\
    \ numbers)\n    {\n        dict[idx] = tuple(number, idx);\n    }\n    dict.sort!((a,b)=>a[0]<b[0]);\n\
    \    auto idx = 1;\n    auto n = dict.length;\n    while(idx < n)\n    {\n   \
    \     if(dict[idx][0] != dict[idx-1][0])\n        {\n            res ~= dict[idx-1][0];\n\
    \        }\n        idx++;\n    }\n    if(dict[idx-1][0] != dict[idx-2][0])\n\
    \    {\n        res ~= dict[idx-1][0];\n    }\n    return res;\n}\nlong[] remove_duplicates2(long[]\
    \ numbers) \n{\n    auto dict = new std.typecons.Tuple!(ulong,long)[numbers.length];\n\
    \    auto res = new long[];\n    // println(res.length);\n    foreach(idx, number;\
    \ numbers)\n    {\n        dict[idx] = tuple(number, idx);\n    }\n    dict.sort!((a,b)=>a[0]<b[0]);\n\
    \    auto idx = 1;\n    auto n = dict.length;\n    while(idx < n)\n    {\n   \
    \     if(dict[idx][0] != dict[idx-1][0])\n        {\n            res ~= dict[idx-1][0];\n\
    \        }\n        idx++;\n    }\n    if(dict[idx-1][0] != dict[idx-2][0])\n\
    \    {\n        res ~= dict[idx-1][0];\n    }\n    return res;\n}", "{\n\tauto\
    \ r = new long[];\n\tforeach(n; numbers) {\n\t\tif (r.contains(n))\n\t\t\tcontinue;\n\
    \t\tr ~= n;\n\t}\n\treturn r;\n}", "{\n    long[long] found_values;\n    long[]\
    \ unique_values;\n    foreach(num; numbers) \n    {\n        if(!found_values.containsKey(num))\
    \ \n        {\n            unique_values ~= num;\n            found_values[num]\
    \ = 1;\n        }\n    }\n    return unique_values;\n}\n/*\n Perform 'AND' of\
    \ integers in an array. Return the result.\n    >>> bitwise_and([2L, 3L, 6L])\n\
    \    2L\n    \n*/\nlong bitwise_and(long[] numbers) \n{\n    long result = -1;\n\
    \    foreach(num; numbers) \n    {\n        result &= num;\n    }\n    return\
    \ result;\n}\n/*\n Given array of test scores (integers), sort them in decreasing\
    \ order and return a string of the scores.\n    >>> sort_scores([2L, 3L, 6L])\n\
    \    \"6632\"\n    \n*/\nstring sort_scores(long[] scores) \n{\n    long[long]\
    \ nums_count;\n    foreach(score; scores) \n    {\n        if(!nums_count.containsKey(score))\
    \ \n        {\n            nums_count[score] = 1;\n        }\n        else \n\
    \        {\n            nums_count[score] += 1;\n        }\n    }\n    long[]\
    \ sorted_scores = nums_count.keysArray.sort;\n    string result = \"\";\n    foreach(score;\
    \ sorted_scores.reverse) \n    {\n        for(long i = 0; i < nums_count[score];\
    \ i++) \n        {\n            result ~= score.to!string;\n        }\n    }\n\
    \    return result;\n}\n/*\n Given a positive integer, return a string of the\
    \ Roman Numeral representation of that number.\n    >>> int_to_roman(13)\n   \
    \ \"XIII\"\n    \n*/\nstring int_to_roman(long num) \n{\n    long[long] int_to_roman_dict\
    \ = [\n        [1000, \"M\"],\n        [900, \"CM\"],\n       ", "{\n  long[]\
    \ ret = new long[];\n  foreach(n; numbers) \n  {\n    if(ret.count(n) < 1)\n \
    \   {\n      ret ~= n;\n    }\n  }\n  return ret;\n}\n/*\n From an array of integers,\
    \ remove all elements that occur more than once.\n    Keep order of elements left\
    \ the same as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n\
    \    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates(long[] numbers) \n{\n  long[]\
    \ ret = new long[];\n  foreach(n; numbers) \n  {\n    if(ret.count(n) < 1)\n \
    \   {\n      ret ~= n;\n    }\n  }\n  return ret;\n}\n/*\n From an array of integers,\
    \ remove all elements that occur more than once.\n    Keep order of elements left\
    \ the same as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n\
    \    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates(long[] numbers) \n{\n  long[]\
    \ ret = new long[];\n  foreach(n; numbers) \n  {\n    if(ret.count(n) < 1)\n \
    \   {\n      ret ~= n;\n    }\n  }\n  return ret;\n}", "{\n\tlong[] unique_numbers\
    \ = [];\n\tforeach(n; numbers)\n\t{\n\t\tif(!unique_numbers.canFind(n))\n\t\t\
    {\n\t\t\tunique_numbers ~= n;\n\t\t}\n\t}\n\treturn unique_numbers;\n}", "{\n\
    \    long[] n = numbers.dup;\n    n.sort;\n    auto idx = 0;\n    auto val = n[0];\n\
    \    long[] ret;\n    foreach(v; n) {\n        if(val == v) continue;\n      \
    \  ret ~= val;\n        val = v;\n    }\n    ret ~= val;\n    return ret;\n}",
  "{\n     return numbers.sort().dup.uniq;\n}", "{\n    if (numbers.length < 2)\n\
    \        return numbers;\n    // get the minimum value in an array\n    long min\
    \ = numbers[0];\n    foreach (n; numbers)\n        min = min(min, n);\n    //\
    \ get the maximum value in an array\n    long max = numbers[0];\n    foreach (n;\
    \ numbers)\n        max = max(max, n);\n    // create an array of bools, then\
    \ go through the array of numbers and mark\n    // which elements occur more than\
    \ once\n    bool[] occurs = new bool[max - min + 1];\n    foreach (n; numbers)\n\
    \        occurs[n - min] = !occurs[n - min];\n    // create a dynamic array, so\
    \ we don't need to know the size in advance\n    long[] res = new long[];\n  \
    \  foreach (n; numbers)\n        if (occurs[n - min])\n            res ~= n;\n\
    \    return res;\n}", "{\n    import std.algorithm;\n    import std.typecons;\n\
    \    return numbers.array.sort.uniq.array;\n}", "{\n    return uniq(numbers);\n\
    }", "{\n    long[] result = [];\n    foreach(idx, value; numbers)\n    {\n   \
    \     if(result.canFind(value) == false)\n        {\n            result ~= value;\n\
    \        }\n    }\n    return result;\n}", "{\n    auto seen = new TypeTuple!(long,\
    \ bool)();\n    auto result = new TypeTuple!(long)();\n    foreach (number; numbers)\
    \ \n    {\n        if (number in seen) \n        {\n            continue;\n  \
    \      }\n        else \n        {\n            seen[number] = true;\n       \
    \     result ~= number;\n        }\n    }\n    return result.idup;\n}", "{\n \
    \   foreach(i; numbers)\n    {\n        auto found = numbers[i];\n        for(auto\
    \ j = i + 1; j < numbers.length; j++)\n        {\n            if(found == numbers[j])\n\
    \            {\n                numbers = numbers[0..j] ~ numbers[j+1..numbers.length];\n\
    \                break;\n            }\n        }\n    }\n    return numbers;\n\
    }\n/*", "{\n    long[long] occur;\n    long[] result;\n    foreach(n; numbers)\n\
    \    {\n        if(n in occur)\n        {\n            if(result.contains(n))\n\
    \            {\n                result = result.retain(a => a != n);\n       \
    \     }\n        }\n        else\n        {\n            occur[n] = 1;\n     \
    \       result ~= n;\n        }\n    }\n    return result;\n}", "{\n    auto len\
    \ = numbers.length;\n    auto result = new long[];\n    auto unique = new bool[len];",
  "in {\n    assert(numbers.length > 0);\n    assert(std.set.IsSet(numbers));\n}\n\
    out(result) {\n    assert(std.set.IsSet(result));\n    assert(std.set.AreDisjoint(result,\
    \ std.set.Difference(numbers, result)));\n}\n{\n    auto counts = std.map.fromArray(numbers);\n\
    \    foreach (n; numbers)\n    {\n        if (counts[n] > 1)\n        {\n    \
    \        counts.remove(n);\n        }\n    }\n    return counts.keys.array;\n}",
  "{\n    long[] results;\n    int[] index;\n    int[] counts;\n    long unique_num;\n\
    \    unique_num = 0;\n    index = new int[numbers.length];\n    results = new\
    \ long[numbers.length];\n    counts = new int[numbers.length];\n    auto pos =\
    \ 0;\n    while (pos < numbers.length)\n    {\n        if (index[pos] == 1)\n\
    \        {\n            pos++;\n            continue;\n        }\n        index[pos]\
    \ = 1;\n        unique_num++;\n        results[unique_num - 1] = numbers[pos];\n\
    \        for (i in numbers)\n        {\n            if (i == numbers[pos])\n \
    \           {\n                counts[pos]++;\n            }\n        }\n    \
    \    pos++;\n    }\n    return results[0..unique_num];\n}\n/*\n From a sequence\
    \ of items, output all items that occur more than once.\n    Keep order of elements\
    \ left the same as in the input.\n    >>> remove_duplicates_from_sequence([1L,\
    \ 2L, 3L, 2L, 4L])\n    [2L]\n*/\nT[] remove_duplicates_from_sequence(T)(T[] sequence)\
    \ \n{\n    T[] results;\n    int[] index;\n    int[] counts;\n    long unique_num;\n\
    \    unique_num = 0;\n    index = new int[sequence.length];\n    results = new\
    \ T[sequence.length];\n    counts = new int[sequence.length];\n    auto pos =\
    \ 0;\n    while (pos < sequence.length)\n    {\n        if (index[pos] == 1)\n\
    \        {\n            pos++;\n            continue;\n        }\n        index[pos]\
    \ = 1;\n        unique_num++;\n        results[unique_num - 1] = sequence[pos];\n\
    \        for (i in sequence)\n        {\n            if (i == sequence[pos])\n\
    \            {\n                counts[pos]++;\n            }\n        }\n   \
    \     pos++;\n    }\n    return results[0..unique_num];\n}\n/*\nTurn a multi-dimensional\
    \ array into a one-dimensional array.\n    >>> flatten", "{\n    long[] output\
    \ = new long[0];\n    foreach(number; numbers)\n    {\n        bool alreadyFound\
    \ = false;\n        foreach(output_number; output)\n        {\n            if(number\
    \ == output_number)\n            {\n                alreadyFound = true;\n   \
    \             break;\n            }\n        }\n        if(!alreadyFound)\n  \
    \      {\n            output ~= number;\n        }\n    }\n    return output;\n\
    }\n/*\nFind nth prime number:\n    >>> nth_prime(0)\n    [2L]\n    >>> nth_prime(1)\n\
    \    [2L, 3L]\n    >>> nth_prime(2)\n    [2L, 3L, 5L]\n    >>> nth_prime(3)\n\
    \    [2L, 3L, 5L, 7L]\n*/\nlong[] nth_prime(size_t n) \n{\n    long[] output =\
    \ new long[0];\n    long[] primes = new long[0];\n    long current_num = 2;\n\
    \    while(output.length < n)\n    {\n        bool isPrime = true;\n        foreach(prime;\
    \ primes)\n        {\n            if(current_num % prime == 0)\n            {\n\
    \                isPrime = false;\n                break;\n            }\n   \
    \     }\n        if(isPrime)\n        {\n            output ~= current_num;\n\
    \            primes ~= current_num;\n        }\n        current_num++;\n    }\n\
    \    return output;\n}\n/*\n    From an array of integers, find the sum of all\
    \ even numbers.\n    >>> sum_even([1L, 2L, 3L, 4L, 5L])\n    6L\n*/\nlong sum_even(long[]\
    \ numbers) \n{\n    long sum = 0;\n    foreach(number; numbers)\n    {\n     \
    \   if(number % 2 == 0)\n        {\n            sum += number;\n        }\n  \
    \  }\n    return sum;\n}\n/*\n    From an array of integers, find the sum of all\
    \ numbers that have an index % 2 == 0.\n    >>> sum_even_index([1L, 2", "{\n \
    \   long[] ret = long[](0);\n    foreach(idx, number; numbers)\n    {\n      \
    \  if (numbers[idx] in ret)\n            continue;\n        else\n           \
    \ ret ~= number;\n    }\n    return ret;\n}", "{\n    int[] occurrences = new\
    \ int[numbers.length];\n    long[] filtered = new long[numbers.length];\n    int\
    \ j = 0;\n    for (int i = 0; i < numbers.length; i++) \n    {\n        if (occurrences[numbers[i]]\
    \ == 0) \n        {\n            occurrences[numbers[i]] = 1;\n            filtered[j]\
    \ = numbers[i];\n            j++;\n        }\n    }\n    return filtered[0..j];\n\
    }", "{\n\talias DC = AliasSeq!(typeof(remove_duplicates));\n\treturn remove_duplicates(numbers,\
    \ DC.template index_of);\n}", "{\n    long[] unique = [];\n    foreach(e; numbers)\n\
    \    {\n        if(std.algorithm.count(numbers, e) == 1)\n        {\n        \
    \    unique ~= e;\n        }\n    }\n    return unique;\n}", "{\n     auto counts\
    \ = ulong[](numbers.length);\n     foreach(i, x; numbers)\n         counts[x]++;\n\
    \     auto keys = ulong[](numbers.length);\n     foreach(i, x; counts)\n     \
    \    if(x > 1)\n             keys[i] = 1;\n     return numbers.filter!(x => keys[x]\
    \ == 0);\n}", "{\n    auto ret = new long[];\n    foreach(n; numbers)\n    {\n\
    \        if(n !in ret) ret ~= n;\n    }\n    return ret;\n}\n/*\n    Arrange numbers\
    \ of the array into an equilateral triangle.\n    >>> organize([0, 3, 2, 1])\n\
    \    [[0], [3, 2], [1]]\n    >>> organize([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n \
    \   [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]\n    >>> organize([10, 9, 8, 7, 6, 5,\
    \ 4, 3, 2, 1])\n    [[10, 9, 8, 7, 6], [5, 4, 3, 2, 1]]\n*/\nlong[][] organize(long[]\
    \ numbers)\n{\n    auto ret = new long[][];\n    ret ~= numbers.take(numbers.length/2\
    \ + numbers.length%2);\n    if(numbers.length - ret[0].length > 0) ret ~= numbers.drop(ret[0].length);\n\
    \    return ret;\n}\n/*\n    Invert a dictionary.\n    >>> invert_dict({'a': 1,\
    \ 'b': 2, 'c': 3})\n    {1: 'a', 2: 'b', 3: 'c'}\n*/", "{\n    long[] res = long[];\n\
    \    foreach(index, i; numbers)\n    {\n        bool isDuplicate = false;\n  \
    \      foreach(j; 0 .. index)\n        {\n            if(numbers[j] == i)\n  \
    \          {\n                isDuplicate = true;\n                break;\n  \
    \          }\n        }\n        if(!isDuplicate)\n        {\n            res\
    \ ~= i;\n        }\n    }\n    return res;\n}", "{\n  auto nums = numbers.dup;\n\
    \  sort(nums);\n  long[] answer;\n  answer ~= nums[0];\n  foreach(i, n; nums)\n\
    \  {\n    if(n != answer[$-1])\n      answer ~= n;\n  }\n  return answer;\n}\n\
    long[] keepUnique(long[] input) \n{\n  auto counted = input.dup.assumeUnique.array;\n\
    \  counted.sort();\n  long[] output;\n  foreach(e; counted.byKey)\n  {\n    output\
    \ ~= e;\n  }\n  return output;\n}", "{\n    return numbers.tupleof.sort.uniq;\n\
    }", "{\n    /*\n    int[] numbers;\n    auto temp = uniq(numbers);\n    numbers\
    \ = temp.values;\n    return numbers;\n    */\n    /*\n    auto set = set(numbers);\n\
    \    auto unique = set.array;\n    return unique;\n    */\n    int[] newNumbers;\n\
    \    auto temp = uniq(numbers);\n    newNumbers = temp.values;\n    return newNumbers;\n\
    }\n/*\nGiven a string, calculate the length of the longest substring without repeating\
    \ characters.\n    >>> find_longest_substring(\"bbbbb\")\n    1\n    >>> find_longest_substring(\"\
    bbtabludbb\")\n    6\n    >>> find_longest_substring(\"abcaabcbb\")\n    3\n \
    \   >>> find_longest_substring(\"abcabcbb\")\n    3\n    >>> find_longest_substring(\"\
    pwwkew\")\n    3\n    >>> find_longest_substring(\"au\")\n    2\n    >>> find_longest_substring(\"\
    aab\")\n    2\n    >>> find_longest_substring(\"dvdf\")\n    3\n    >>> find_longest_substring(\"\
    abba\")\n    2\n    >>> find_longest_substring(\"abcabcbb\")\n    3", "{\n   \
    \ long[] keys;\n    long[] values;\n    auto s = numbers.length;\n    if (s ==\
    \ 0L) \n    {\n        return numbers;\n    }\n    // Create the hash table\n\
    \    keys = new long[s];\n    values = new long[s];\n    foreach (n; numbers)\
    \ \n    {\n        auto index = hash(n, s);\n        while (values[index] != 0L)\
    \ \n        {\n            index = (index + 1L) % s;\n        }\n        keys[index]\
    \ = n;\n        values[index] = 1L;\n    }\n    long[] results;\n    // Read all\
    \ keys that were inserted into the hash table\n    foreach (i; 0L .. s) \n   \
    \ {\n        if (values[i] != 0L) \n        {\n            results ~= keys[i];\n\
    \        }\n    }\n    return results;\n}", "{ \n    import std.array;\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.container;\n    import std.conv;\n    long[] unique;\n\
    \    unique = new long[numbers.length];\n    unique.length = 0;\n    for( int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(!unique.canFind(numbers[i]))\n\
    \        {\n            unique ~= numbers[i];\n        }\n    }\n    return unique;\n\
    }", "{\n\tlong[] ret;\n\tforeach(n; numbers)\n\t{\n\t\tauto pos = std.algorithm.find(ret,\
    \ n);\n\t\tif(pos == ret.length)\n\t\t\tret ~= n;\n\t}\n\treturn ret;\n}\n/*\n\
    From an array of integers, remove all elements that are less than the average.\n\
    >>> remove_less_than_average([1L, 2L, 3L, 4L, 5L])\n[3L, 4L, 5L]\n*/\nlong[] remove_less_than_average(long[]\
    \ numbers) \n{\n\tlong[] ret;\n\tlong sum = 0;\n\tforeach(n; numbers)\n\t\tsum\
    \ += n;\n\tauto avg = sum / numbers.length;\n\tforeach(n; numbers)\n\t{\n\t\t\
    if(n >= avg)\n\t\t\tret ~= n;\n\t}\n\treturn ret;\n}", "{\n\tstd.algorithm.sort(numbers);\n\
    \treturn std.algorithm.unique(numbers);\n}", "{\n    if(numbers.length < 2) \n\
    \        return numbers;\n    auto it = numbers.groupby!(a => a);\n    long[]\
    \ result = it.map!(a => a.front).array;\n    return result;\n}\n \n/*\n    From\
    \ an array of integers, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates_v2(long[]\
    \ numbers) \n{\n    if(numbers.length < 2) \n        return numbers;\n    return\
    \ numbers.groupby!(a => a).filter!(a => a.length == 1).map!(a => a.front).array;\n\
    }\n \n/*\n    From an array of integers, remove all elements that occur more than\
    \ once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates_v3(long[]\
    \ numbers) \n{\n    if(numbers.length < 2) \n        return numbers;\n    return\
    \ numbers.groupby!(a => a).keepif!(a => a.length == 1).map!(a => a.front).array;\n\
    }\n \n/*\n    From an array of integers, remove all elements that occur more than\
    \ once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates_v4(long[]\
    \ numbers) \n{\n    if(numbers.length < 2) \n        return numbers;\n    return\
    \ numbers.groupby!(a => a).filter!(a => a.length == 1).map!(a => a.front).array;\n\
    }\n \n/*\n    From", "{\n    long[] result;\n    foreach(i; 0 .. numbers.length)\n\
    \    {\n        immutable n = numbers[i];\n        if(count(numbers, n) == 1)\n\
    \        {\n            result ~= n;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = new long[];\n    if (numbers.length > 0)\n    {\n      \
    \  foreach (ind, l; numbers)\n        {\n            if (!result.canFind(l))\n\
    \            {\n                result ~= l;\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] uniques = new long[0];\n    bool[] hasNumber\
    \ = new bool[numbers.length];\n    foreach(num ; numbers)\n    {\n        foreach(number\
    \ ; uniques)\n        {\n            if(num == number)\n            {\n      \
    \          hasNumber[num] = true;\n            }\n        }\n    }\n    foreach(num\
    \ ; numbers)\n    {\n        if(!hasNumber[num])\n        {\n            uniques\
    \ ~= num;\n        }\n    }\n    return uniques;\n}", "{\n\treturn numbers.uniq;\n\
    }", "{\n    long[] numbers2;\n    // Write your code here\n    // To print results\
    \ to the standard output you can use print(\"Hello world!\");\n    // Example:\
    \ print(\"Test message\");\n    numbers2.length = numbers.length;\n    int len\
    \ = numbers.length;\n    for(int i = 0; i < len; i++)\n    {\n        for(int\
    \ j = i + 1; j < len; j++)\n        {\n            if(numbers[i] == numbers[j])\n\
    \            {\n                numbers2.remove(numbers[i]);\n            }\n\
    \        }\n    }\n    return numbers2;\n}", "{ \n\treturn numbers;\n}", "{\n\
    \    auto dict = long.hasher;\n    auto set = new HashSet!(long, dict)();\n  \
    \  int[] result = [];\n    foreach(number; numbers)\n    {\n        if(!set.contains(number))\n\
    \        {\n            set.insert(number);\n            result ~= number;\n \
    \       }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    foreach(number; numbers)\n    {\n        // if(result.find(number))\n   \
    \     if(!result.canFind(number))\n        {\n            result ~= number;\n\
    \        }\n    }\n    return result;\n}", "    pure nothrow {\n    long[] newNumbers;\n\
    \    foreach(n; numbers) {\n        auto found = false;\n        foreach(m; newNumbers)\
    \ {\n            if(n == m) {\n                found = true;\n               \
    \ break;\n            }\n        }\n        if(!found) {\n            newNumbers\
    \ ~= n;\n        }\n    }\n    return newNumbers;\n}\n/*\nGiven two lists of integers,\
    \ find a pair of values (one from each list) that you can swap to give the two\
    \ lists the same sum.\n>>> find_duplicate_sum([1L, 2L, 2L], [3L, 2L, 1L])\n[(1L,\
    \ 1L)]\n*/\nTuple!(long, long)[] find_duplicate_sum(long[] a, long[] b) \n   \
    \ pure nothrow {\n    long sumA = 0;\n    long sumB = 0;\n    foreach(n; a) {\n\
    \        sumA += n;\n    }\n    foreach(n; b) {\n        sumB += n;\n    }\n \
    \   if(sumA == sumB) {\n        return [];\n    }\n    long[] aPairs;\n    long[]\
    \ bPairs;\n    foreach(i, n; a) {\n        foreach(j, m; b) {\n            long\
    \ subA = sumA - n + m;\n            long subB = sumB - m + n;\n            if(subA\
    \ == subB) {\n                aPairs ~= i;\n                bPairs ~= j;\n   \
    \         }\n        }\n    }\n    Tuple!(long, long)[] result;\n    foreach(i,\
    \ j; zip(aPairs, bPairs)) {\n        result ~= tuple(a[i], b[j]);\n    }\n   \
    \ return result;\n}\n/*\n Given a list of length N, return a list that contains\
    \ the square root\n    of each element of the input list. If the square root is\
    \ not an integer,\n    discard that number.\n    >>> filter_integers([1L, 4L,\
    \ 8L, 27L, 256L])\n    [1L,", "{\n    long[] result = [0L];\n    for (long i =\
    \ 0; i < numbers.length; i++)\n    {\n        if (find(result, numbers[i]) ==\
    \ -1)\n        {\n            result ~= numbers[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] unique;\n    foreach(i; numbers) \n    {\n     \
    \   if(!unique.canFind(i)) \n        {\n            unique ~= i;\n        }\n\
    \    }\n    return unique;\n}\n/*\n    >>> remove_duplicates([1L, 2L, 3L, 2L,\
    \ 4L])\n    [1L, 3L, 4L]\n*/\nunittest \n{\n    int[] test = [1, 2, 3, 2, 4];\n\
    \    assert(remove_duplicates(test) == [1, 3, 4]);\n}\n \n ", "{\n    long[] result\
    \ = [];\n    foreach( number; numbers)\n    {\n        if(indexOf(result, number)\
    \ == -1)\n        {\n            result ~= number;\n        }\n    }\n    return\
    \ result;\n}\n//start with 2 because 1 is not a prime\nlong[] get_primes(long\
    \ max)\n{\n    long[] primes = [2L];\n    long num = 3L;\n    while(num <= max)\n\
    \    {\n        bool is_prime = true;\n        foreach(prime; primes)\n      \
    \  {\n            if(num % prime == 0)\n            {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if(is_prime)\n\
    \        {\n            primes ~= num;\n        }\n        num += 2;\n    }\n\
    \    return primes;\n}", "{\n    auto seen = new std.typecons.AssocArray!(long,\
    \ bool);\n    foreach (const number; numbers) {\n        seen[number] = true;\n\
    \    }\n    return seen.keys;\n}\n \n/*\nTemplate Argument Deduction\nFrom an\
    \ array of integers, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nT[] remove_duplicates(T)(T[] numbers)\
    \ \n    if (isIntegral!T)\n{\n    auto seen = new std.typecons.AssocArray!(T,\
    \ bool);\n    foreach (const number; numbers) {\n        seen[number] = true;\n\
    \    }\n    return seen.keys;\n}\n/*\nTemplate Argument Deduction with Multiple\
    \ Arguments\nFrom an array of integers, remove all elements that occur more than\
    \ once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nT[] remove_duplicates(T)(T[] numbers,\
    \ size_t limit) \n    if (isIntegral!T)\n{\n    auto seen = new std.typecons.AssocArray!(T,\
    \ bool);\n    foreach (const number; numbers) {\n        seen[number] = true;\n\
    \    }\n    return seen.keys[0 .. limit];\n}\n/*\nVariadic Template Argument\n\
    From an array of integers, remove all elements that occur more than once.\n  \
    \  Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nT[] remove_duplicates(T...)(T[]\
    \ numbers) \n    if (isIntegral!T)\n{\n    auto seen = new std.typecons.AssocArray!(T,\
    \ bool);\n    fore", "{\n    long[] result;\n    foreach(n; numbers) \n    {\n\
    \        if(n in result) \n        {\n            result -= n;\n        }\n  \
    \      else \n        {\n            result ~= n;\n        }\n    }\n    return\
    \ result;\n}", "{\n    // stores the remaining unique elements\n    long[] unique\
    \ = new long[];\n    long[] remaining = numbers.dup;\n    // keeps track of which\
    \ ones we already saw\n    long[] seen = new long[];\n    // look at each remaining\
    \ number and see if we've seen it\n    foreach (i; remaining)\n    {\n       \
    \ if (i in seen)\n        {\n            // if we have, remove it from the numbers\n\
    \            remaining = remaining.remove(i);\n        } else\n        {\n   \
    \         // haven't seen it, add it to the seen array\n            seen ~= i;\n\
    \            // and add it to the output\n            unique ~= i;\n        }\n\
    \    }\n    return unique;\n}", "in\n{\n    assert(!numbers.empty);\n}\nout(result)\n\
    {\n    assert(is_permutation(result, numbers));\n    assert(equal(result, uniq(result)));\n\
    }\nbody\n{\n    long[] unique_items = new long[];\n    long[] unique_items_mask\
    \ = new long[numbers.length];\n    foreach (index, number; numbers)\n    {\n \
    \       long index_of_same_number = find(numbers[0..index], number);\n       \
    \ if (index_of_same_number == -1)\n        {\n            unique_items ~= number;\n\
    \            unique_items_mask[index] = 1;\n        }\n    }\n    return array(unique_items_mask).zip(numbers).map!(a\
    \ => a[1]).array;\n}", "{\n    bool[] blnunique = new bool[numbers.length];\n\
    \    bool[] blnseen = new bool[numbers.length];\n    size_t i;\n    long[] output;\n\
    \    foreach(i, n; numbers)\n    {\n        if(blnseen[n])\n        {\n      \
    \      blnunique[n] = false;\n        }\n        else\n        {\n           \
    \ blnunique[n] = true;\n            blnseen[n] = true;\n        }\n    }\n   \
    \ foreach(i, n; blnunique)\n    {\n        if(n)\n        {\n            output\
    \ ~= numbers[i];\n        }\n    }\n    return output;\n}\n/*\n From an array\
    \ of integers, remove the smallest value.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_smallest([1L, 2L, 3L, 2L, 4L])\n    [2L,\
    \ 3L, 2L, 4L]\n    >>> remove_smallest([2L, 3L, 2L, 4L])\n    [3L, 2L, 4L]\n \
    \   >>> remove_smallest([2L, 3L, 2L, 4L, 3L])\n    [3L, 2L, 4L, 3L]\n    >>> remove_smallest([])\n\
    \    []\n    >>> remove_smallest([1L])\n    []\n*/\nlong[] remove_smallest(long[]\
    \ numbers) \n{\n    size_t i, a, smallest_index;\n    long smallest;\n    if(numbers.length\
    \ == 0)\n    {\n        return numbers;\n    }\n    smallest = numbers[0];\n \
    \   foreach(i, n; numbers)\n    {\n        if(n < smallest)\n        {\n     \
    \       smallest = n;\n            smallest_index = i;\n        }\n    }\n   \
    \ a = 0;\n    foreach(i, n; numbers)\n    {\n        if(i != smallest_index)\n\
    \        {\n            numbers[a] = n;\n            a++;\n        }\n    }\n\
    \    numbers.length = a;\n    return numbers;\n}\n/*\n Given", "{\n    long[]\
    \ output;\n    auto n = numbers.length;\n    bool[] used = new bool[n];\n    foreach\
    \ (i, num; numbers)\n    {\n        if (numbers[i] == num)\n        {\n      \
    \      if (used[i])\n            {\n                continue;\n            }\n\
    \            else\n            {\n                used[i] = true;\n          \
    \      output ~= num;\n            }\n        }\n    }\n    return output;\n}",
  "    {\n    ulong[] numbers2;\n    foreach(ulong n; numbers)\n        numbers2 ~=\
    \ n;\n    return remove_duplicates(numbers2);\n    }", "{\n    import std.traits\
    \ : isSomeString;\n    if (isSomeString!(typeof(numbers[0])))\n    {\n       \
    \ import std.array : array;\n        import std.conv : to;\n        auto numbers_copy\
    \ = map!(to!string(numbers[0]))(numbers);\n        numbers = array(numbers_copy);\n\
    \    }\n    import std.algorithm.comparison : equal;\n    import std.algorithm.searching\
    \ : any;\n    import std.algorithm.iteration : filter;\n    return numbers.filter!(n\
    \ = > !numbers.filter!(m = > equal(n, m)).any!(m = > m != n)).array;\n}\n/*\n\
    \ Split string into a list of words.\n    All sequences of characters that are\
    \ surrounded by spaces should be considered a single word.\n    It's guaranteed\
    \ that strings contain at least one word.\n    >>> split_string(\"ab c  d\")\n\
    \    [\"ab\", \"c\", \"d\"]\n    >>> split_string(\"abc\")\n    [\"abc\"]\n  \
    \  >>> split_string(\"abc def\")\n    [\"abc\", \"def\"]\n*/\nstring[] split_string(string\
    \ line) \n{\n    import std.algorithm.searching : findSplit;\n    return line.findSplit(`\
    \ `);\n}\n/*\n Given a string, you need to reverse the order of characters in\
    \ each word within a sentence while still preserving whitespace and initial word\
    \ order.\n    >>> reverse_words(\"Let's take LeetCode contest\")\n    \"s'teL\
    \ ekat edoCteeL tsetnoc\"\n*/\nstring reverse_words(string s) \n{\n    import\
    \ std.algorithm.searching : findSplit;\n    import std.algorithm.comparison :\
    \ equal;\n    import std.algorithm.mutation : replace;\n    import std.range :\
    \ retro;\n    import std.conv : to;\n    return to!string(map!(x = > to!string(x.retro).idup).findSplit(s));\n\
    }\n/*\n Given a non-empty array of integers, every element appears twice except\
    \ for one. Find that single one.\n    >>> single_", "{\n\tauto seen = long[];\n\
    \tauto unseen = long[];\n\t\n\tforeach(immutable number; numbers)\n\t{\n\t\tif(number\
    \ in seen)\n\t\t{\n\t\t\tunseen ~= number;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tseen\
    \ ~= number;\n\t\t}\n\t}\n\t\n\tforeach(immutable number; unseen)\n\t{\n\t\tif(number\
    \ in seen)\n\t\t{\n\t\t\tseen = seen.remove(number);\n\t\t}\n\t}\n\t\n\treturn\
    \ seen;\n}", "{\n    return numbers.dup.sort.unique;\n}\n//\n////\n////\n////\n\
    ////\n// VERSION 2\n////\n////\n////\n////\n//", "{\n    return remove_duplicates_(numbers);\n\
    }\nlong[] remove_duplicates_(long[] numbers) \n{\n    long[] tmp = numbers.dup;\n\
    \    std.algorithm.sort(tmp);\n    auto cur = tmp.front;\n    int j = 0;\n   \
    \ for (int i = 1; i < tmp.length; i++) \n    {\n        if (tmp[i] != tmp[j])\
    \ \n        {\n            j++;\n            tmp[j] = tmp[i];\n        }\n   \
    \ }\n    return tmp[0..j+1];\n}\nlong[] remove_duplicates_2(long[] numbers) \n\
    {\n    long[] tmp = numbers.dup;\n    auto cur = tmp.front;\n    int j = 0;\n\
    \    while(cur != tmp.back) \n    {\n        if (cur.moveNext() && cur.current\
    \ == cur.next) \n        {\n            tmp.remove(cur.next);\n        } \n  \
    \      else \n        {\n            j++;\n        }\n    }\n    return tmp[0..j+1];\n\
    }\nlong[] remove_duplicates_3(long[] numbers) \n{\n    long[] out;\n    foreach(number;\
    \ numbers) \n    {\n        auto pos = binarySearch(out, number);\n        if\
    \ (pos >= 0) \n        {\n            auto cur = out[pos];\n            out.remove(cur);\n\
    \        } \n        else \n        {\n            out ~= number;\n        }\n\
    \    }\n    return out;\n}\n// Even more natural but not efficient\nlong[] remove_duplicates_natural(long[]\
    \ numbers) \n{\n    long[] out;\n    foreach(number; numbers) \n    {\n      \
    \  if (!out.canFind(number)) \n        {\n            out ~= number;\n       \
    \ }\n    }\n    return out;\n}\nlong[] remove_duplicates_natural_2(long[] numbers)\
    \ \n{\n    return remove_duplicates_natural_(numbers);\n}\nlong[] remove_duplicates_natural_(long[]\
    \ numbers) \n{\n   ", "{\n    //static assert(!is(typeof(numbers.sort)));\n  \
    \  size_t len = numbers.length;\n    size_t index = 0;\n    long[] filtered_numbers\
    \ = new long[len];\n    foreach(value; numbers)\n    {\n        if(index == 0\
    \ || filtered_numbers[index - 1] != value)\n        {\n            filtered_numbers[index]\
    \ = value;\n            index++;\n        }\n    }\n    return filtered_numbers[0..index];\n\
    }", "{\n    auto indexes = std.algorithm.indexOf(numbers,numbers);\n    auto distinctIndexes\
    \ = indexes.unique;\n    return std.algorithm.filter!(i => i)(numbers[distinctIndexes]);\n\
    }\n \n \n/*\n//From a string, find all words that begin with a capital letter,\
    \ except for the\n//first word.\n    >>> find_capitals(\"The Coast Is Clear\"\
    )\n    ['Coast', 'Clear']\n    >>> find_capitals(\"How Are You?\")\n    ['Are']\n\
    \    >>> find_capitals(\"The beach is not here\")\n    []\n    \n*/\nstring[]\
    \ find_capitals(string text) \n{\n    import std.regex : matches;\n    auto result\
    \ = matches(text, r\"[A-Z][a-z]*\\b\").front.captures;\n    return result[1..$];\n\
    }\n \n \n/*\n//From a string, return a new string where all occurrences of a given\
    \ letter are\n//replaced with the next letter in the alphabet.\n//For example:\n\
    //    >>> replace_vowels(\"The quick brown fox jumps over the lazy dog.\")\n//\
    \    'Thy quicx brown fay jumpx ovyr thy lazy dog.'\n//    >>> replace_vowels(\"\
    Hi, how are you today?\")\n//    'Hj, iphw bsf zpv uifz tzpuujoh?'\n//    >>>\
    \ replace_vowels(\"AaA bBb ccC DdD eeE fFf\")\n//    'BbB cCc ddD EeE gGg ffF'\n\
    //    >>> replace_vowels(\"This is a long string without much change.\")\n// \
    \   'This is a long string without much change.'\n*/\nstring replace_vowels(string\
    \ text)\n{\n    import std.range;\n    import std.array;\n    import std.ascii;\n\
    \    \n    char[] vowels = ['a','e','i','o','u'];\n    char[] replacements = vowels.map!(x\
    \ => x.next).array;\n    text = text.map!(x => (vowels", "{\n\tint[] seen;\n\t\
    int len = numbers.length;\n\tif (len > 0)\n\t{\n\t\tseen = new int[len];\n\t\t\
    seen[] = 0;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < len; i++)\n\t\t{\n\t\t\
    \tint temp = seen[numbers[i]];\n\t\t\tif (temp == 0)\n\t\t\t{\n\t\t\t\tseen[numbers[i]]\
    \ = 1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tseen[numbers[i]]++;\n\
    \t\t\t}\n\t\t}\n\t\tlong[] output = new long[count];\n\t\tcount = 0;\n\t\tfor\
    \ (int i = 0; i < len; i++)\n\t\t{\n\t\t\tif (seen[numbers[i]] == 1)\n\t\t\t{\n\
    \t\t\t\toutput[count] = numbers[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ output;\n\t}\n\telse\n\t{\n\t\treturn numbers;\n\t}\n}", "{\n    if (is(long\
    \ == ulong)) {\n        return remove_duplicates!(ulong)(cast(ulong[])numbers);\n\
    \    }\n    else {\n        return remove_duplicates!(long)(numbers);\n    }\n\
    }", "{\n\tlong n = numbers.length;\n\tMap!long m = Map!long();\n\tfor (int i =\
    \ 0; i < n; i++)\n\t{\n\t\tif (!m.get(numbers[i], -1))\n\t\t{\n\t\t\tm[numbers[i]]\
    \ = 1;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tm[numbers[i]]++;\n\t\t}\n\t}\n\t\n\tlong[]\
    \ result = [];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (m[numbers[i]] == 1)\n\
    \t\t{\n\t\t\tresult ~= numbers[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n   \
    \ auto exist = std.typecons.Checker[long];\n    long[] result;\n    foreach(i,\
    \ ref n; numbers)\n    {\n        if(!exist.check(n))\n        {\n           \
    \ exist.insert(n);\n            result ~= n;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] uniques = new long[0];\n    foreach(int idx, long value; numbers)\
    \ \n    {\n        bool contains = false;\n        foreach(long unique; uniques)\
    \ \n        {\n            if(unique == value) \n            {\n             \
    \   contains = true;\n                break;\n            }\n        }\n     \
    \   if(!contains) \n        {\n            uniques ~= value;\n        }\n    }\n\
    \    return uniques;\n}\n/*\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1L])\n\
    \    [1L]\n    >>> remove_duplicates([1L, 1L])\n    [1L]\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 1L, 4L])\n    [2L, 3L, 4L]\n    >>> remove_duplicates([1L, 2L, 3L, 4L,\
    \ 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L, 17L, 18L, 19L, 20L, 21L,\
    \ 22L, 23L, 24L, 25L, 26L, 27L, 28L, 29L, 30L, 31L, 32L, 33L, 34L, 35L, 36L, 37L,\
    \ 38L, 39L, 40L, 41L, 42L, 43L, 44L, 45L, 46L, 47L, 48L, 49L, 50L, 51L, 52L, 53L,\
    \ 54L, 55L, 56L, 57L, 58L, 59L, 60L, 61L, 62L, 63L, 64L, 65L, 66L, 67L, 68L, 69L,\
    \ 70L, 71L, 72L, 73L, 74L, 75L, 76L, 77L, 78L, 79L, 80L, 81L, 82L, 83L, 84L, 85L,\
    \ 86L, 87L, 88L, 89L, 90L, 91L, 92L, 93L, 94L, 95L, 96L, 97L, 98L, 99L,", "{\n\
    \    auto index = 0L;\n    auto last = -1L;\n    foreach(value; numbers)\n   \
    \ {\n        if(value != last)\n        {\n            numbers[index] = value;\n\
    \            last = value;\n            index++;\n        }\n    }\n    return\
    \ numbers[0..index];\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
