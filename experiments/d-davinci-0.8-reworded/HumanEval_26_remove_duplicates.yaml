name: HumanEval_26_remove_duplicates
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n From an array of integers, remove\
  \ all elements that occur more than once.\n    Keep order of elements left the same\
  \ as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L,\
  \ 4L]\n    \n*/\nlong[] remove_duplicates(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = remove_duplicates;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 4L, 3L, 5L]) == [1L, 4L, 5L]);\n}\nvoid main(){}"
completions: ["{\n    int[] counts = numbers.dup.countmap();\n    long[] result =\
    \ [];\n    foreach(long number; numbers)\n    {\n        if(counts[number] ==\
    \ 1)\n        {\n            result ~= number;\n        }\n    }\n    return result;\n\
    }", "{\n  return uniq(numbers);\n}\n \n/*\n Re-order an array in a random order.\n\
    \    >>> random_order([1L, 2L, 3L, 4L, 5L])\n    [2L, 1L, 5L, 4L, 3L]\n    >>>\
    \ random_order([1L, 2L, 3L, 4L, 5L])\n    [5L, 3L, 2L, 4L, 1L]\n*/\nlong[] random_order(long[]\
    \ numbers) \n{\n  return numbers.random_shuffle();\n}\n \n/*\n From an array of\
    \ integers, output their sum.\n    >>> sum_numbers([1L, 2L, 3L, 4L, 5L])\n   \
    \ 15L\n*/\nlong sum_numbers(long[] numbers) \n{\n  return numbers.sum;\n}\n \n\
    /*\n From an array of integers, output the highest number.\n    >>> find_highest([1L,\
    \ 2L, 3L, 4L, 5L])\n    5L\n*/\nlong find_highest(long[] numbers) \n{\n  return\
    \ numbers.max;\n}\n \n/*\n From an array of strings, output an array that contains\
    \ the length of each string.\n    >>> find_lengths([\"Hello\", \"World\"])\n \
    \   [5L, 5L]\n*/\nlong[] find_lengths(string[] strings) \n{\n  return strings.map!(a\
    \ => a.length);\n}\n \n/*\n From an array of strings, output all strings that\
    \ contain another string.\n    >>> find_contains([\"Hello\", \"World\"], \"o\"\
    )\n    [\"Hello\", \"World\"]\n    >>> find_contains([\"Hello\", \"World\"], \"\
    M\")\n    []\n*/\nstring[] find_contains(string[] strings, string value) \n{\n\
    \  return strings.filter!(a => a.contains(value));\n}\n \n/*\n From an array of\
    \ strings, remove all strings that contain another string.\n    >>> remove_contains([\"\
    Hello\", \"World\"], \"o\")\n    []\n    >>> remove_contains([\"Hello\", \"World\"\
    ], \"M\")\n    [\"Hello\",", "{\n\tstruct Node\n\t{\n\t\tlong data;\n\t\tNode*\
    \ next;\n\t}\n\tstruct LinkedList \n\t{\n\t\tNode* head;\n\t\tNode* tail;\n\t\t\
    void add(long data)\n\t\t{\n\t\t\tif(head is null)\n\t\t\t{\n\t\t\t\thead = new\
    \ Node;\n\t\t\t\thead.data = data;\n\t\t\t\ttail = head;\n\t\t\t}\n\t\t\telse\n\
    \t\t\t{\n\t\t\t\ttail.next = new Node;\n\t\t\t\ttail = tail.next;\n\t\t\t\ttail.data\
    \ = data;\n\t\t\t}\n\t\t}\n\t\tvoid append(LinkedList list)\n\t\t{\n\t\t\tif(head\
    \ is null)\n\t\t\t{\n\t\t\t\thead = list.head;\n\t\t\t\ttail = list.tail;\n\t\t\
    \t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttail.next = list.head;\n\t\t\t\ttail = list.tail;\n\
    \t\t\t}\n\t\t}\n\t\tvoid remove(long data)\n\t\t{\n\t\t\tNode* current = head;\n\
    \t\t\tNode* prev = null;\n\t\t\twhile(current !is null)\n\t\t\t{\n\t\t\t\tif(current.data\
    \ == data)\n\t\t\t\t{\n\t\t\t\t\tif(prev is null)\n\t\t\t\t\t{\n\t\t\t\t\t\thead\
    \ = current.next;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev.next\
    \ = current.next;\n\t\t\t\t\t}\n\t\t\t\t\tif(current is tail)\n\t\t\t\t\t{\n\t\
    \t\t\t\t\ttail = prev;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev\
    \ = current;\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t}\n\t\tvoid remove_duplicates()\n\
    \t\t{\n\t\t\tlong[] seen = new long", "{\n\tlong[] result = new long[];\n\tforeach(i;\
    \ numbers)\n\t{\n\t\tif(count(numbers, i) == 1)\n\t\t{\n\t\t\tresult ~= i;\n\t\
    \t}\n\t}\n\treturn result;\n}", "{\n    auto tmp = new long[numbers.length];\n\
    \    auto itmp = 0L;\n    foreach(n ; numbers) \n    {\n        if (numbers.count(n)\
    \ == 1) \n        {\n            tmp[itmp] = n;\n            itmp++;\n       \
    \ }\n    }\n    return tmp[0..itmp];\n}", "{\n    if(numbers.length == 0)\n  \
    \      return new long[0];\n    auto nums = uniq(numbers);\n    nums.sort();\n\
    \    return nums;\n}", "{\n  auto results = appender!(long[])();\n  foreach(n;\
    \ numbers)\n  {\n    if (results.empty || results.data[$-1] != n)\n      results.put(n);\n\
    \  }\n  return results.data;\n}", "{ \n    auto numbers_set = std.set.Set!long(numbers);\n\
    \    return numbers_set.array;\n}\n/*\n    From an array of integers, remove all\
    \ elements that occur more than once.\n    >>> remove_duplicates([1L, 2L, 3L,\
    \ 2L, 4L])\n    [1L, 3L, 4L]\n*/\nlong[] remove_duplicates_std(long[] numbers)\
    \ \n{ \n    auto numbers_set = numbers.unique;\n    return numbers_set.array;\n\
    }", "{\n    long[] result = [];\n    int count = 0;\n    foreach(index, num; numbers)\n\
    \    {\n        if(count == 0)\n        {\n            count = 1;\n          \
    \  result ~= num;\n        }\n        else\n        {\n            if(result[$-1]\
    \ != num)\n            {\n                result ~= num;\n            }\n    \
    \    }\n    }\n    return result;\n}", "{\n    auto s = set!(typeof(numbers[0]))(numbers);\n\
    \    return (numbers.dup).retain(a => s.remove(a));\n}", "{\n    auto set = new\
    \ set!(long)();\n    foreach(n; numbers) {\n        set.insert(n);\n    }\n  \
    \  long[] unique;\n    unique.length = set.length;\n    long i = 0;\n    foreach(n;\
    \ set) {\n        unique[i] = n;\n        i++;\n    }\n    return unique;\n}",
  "{ \n    auto ulong_numbers = to!ulong[](numbers);\n    // auto gen_ones = map!(constant(1))(ulong_numbers);\n\
    \    // writeln(map!(constant(1))(ulong_numbers));\n    // writeln(gen_ones);\n\
    \    // writeln(zip(ulong_numbers, gen_ones));\n    // auto unique_numbers = zip(ulong_numbers,\
    \ gen_ones).reduce!(a,b=>a+b);\n    auto unique_numbers = zip(ulong_numbers, map!(constant(1))(ulong_numbers)).reduce!(a,b=>a+b);\n\
    \    // writeln(unique_numbers);\n    auto unique_numbers_keys = unique_numbers.keys;\n\
    \    // writeln(unique_numbers_keys);\n    auto diff = numbers ~ unique_numbers_keys;\n\
    \    // writeln(diff);\n    foreach(i; 0..diff.length)\n    {\n        // writeln(diff[i]);\n\
    \        if(diff[i] in unique_numbers)\n        {\n            unique_numbers[diff[i]]\
    \ +=1;\n        }\n    }\n    // writeln(unique_numbers);\n    auto unique_values\
    \ = unique_numbers.values;\n    // writeln(unique_values);\n    auto unique_numbers_keys_with_duplicates\
    \ = zip(unique_numbers_keys, unique_values).filter!(a=>a[1]==1);\n    // writeln(unique_numbers_keys_with_duplicates);\n\
    \    return to!long[](unique_numbers_keys_with_duplicates.map!(a=>a[0]));\n}",
  "{\n    long[] result = [];\n    foreach(int i, long n; numbers)\n    {\n      \
    \  if (n in result)\n            continue;\n        result ~= n;\n    }\n    return\
    \ result;\n}\n/*\n    Given an array of integers, return the sum of two numbers\
    \ that equal the value target. \n    >>> two_sum([1L, 2L, 4L, 4L], 8L)\n    [4L,\
    \ 4L]\n*/\nlong[] two_sum(long[] numbers, long target) \n{\n    long[] result\
    \ = [];\n    foreach(int i, long n; numbers)\n    {\n        if (target - n in\
    \ numbers)\n        {\n            result ~= n;\n            result ~= target\
    \ - n;\n            break;\n        }\n    }\n    return result;\n}\n/*\n    Given\
    \ a word, return an array with the indices of all capital letters.\n    >>> capitals(\"\
    qQuIckBrOwNfOx\")\n    [1L, 5L, 9L, 10L]\n*/\nlong[] capitals(string word) \n\
    {\n    long[] result = [];\n    foreach(int i, char c; word)\n    {\n        if\
    \ (c.isUpper)\n            result ~= i;\n    }\n    return result;\n}\n/*\n  \
    \  Given an array of integers and a target, find all possible combinations \n\
    \    of a, b, c, d, such that a + b + c + d = target.\n    >>> four_sum([1L, 2L,\
    \ 3L, 4L, 5L, 6L, 7L], 10L)\n    [[1L, 2L, 3L, 4L], [1L, 2L, 5L, 2L], [1L, 3L,\
    \ 4L, 2L], [1L, 4L, 3L, 2L], [1L, 5L, 2L, 2L], [2L, 3L, 5L, 0L], [2L, 4L, 4L,\
    \ 0L], [2L, 5L, 3L, 0L], [3L, 4L, 3L, 0L], [3L, 5L, 2L, 0L", "{\n    return numbers.dup.sort.dedup;\n\
    }", "{\n    long[] result = numbers.dup;\n    immutable(int)[] duplicates = std.array.uniq(numbers);\n\
    \    foreach(i; 0 .. duplicates.length)\n    {\n        immutable(int) dup = duplicates[i];\n\
    \        for(int j = 0; j < result.length; ++j)\n        {\n            if(result[j]\
    \ == dup)\n            {\n                result = std.array.remove(result, j);\n\
    \                j--;\n            }\n        }\n    }\n    return result;\n}",
  "{\n    import std.algorithm : uniq;\n    return numbers.uniq;\n}", "{ \n    long[]\
    \ result = [];\n    int[] temp = new int[numbers.length];", "{\n  long[] result\
    \ = new long[];\n  bool[] seen = new bool[numbers.length];\n  ulong i = 0UL;\n\
    \  foreach(long number; numbers) \n  {\n    if(!seen[i]) \n    {\n      auto j\
    \ = 0UL;\n      auto found = false;\n      while(j < i && !found) \n      {\n\
    \        if(numbers[j] == number) \n        {\n          found = true;\n     \
    \   }\n        j++;\n      }\n      if(!found) \n      {\n        result ~= number;\n\
    \      }\n    }\n    seen[i] = true;\n    i++;\n  }\n  return result;\n}\n// from\
    \ http://www.digitalmars.com/d/2.0/phobos/std_random.html\nstruct Random\n{\n\
    \    long int seed;\n    enum uint32_t Max = 2147483647L;", "{\n    long[]result;\n\
    \    immutable a = [];\n    immutable b = [];\n    foreach(n; numbers) \n    {\n\
    \        if(n in a) \n        {\n            b ~= n;\n        } \n        else\
    \ \n        {\n            a ~= n;\n        }\n    }\n    result = a.difference(b);\n\
    \    return result;\n}\n/*\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n\
    \    [1L, 3L, 4L]\n*/", "{\n    auto m_dict = std.typecons.makeHashMap!(long,\
    \ long)();\n    auto m_list = std.typecons.makeArray!(long)();\n    foreach(num;\
    \ numbers) \n    {\n        if(m_dict.count(num) == 0) \n        {\n         \
    \   m_dict[num] = num;\n            m_list ~= num;\n        }\n    }\n    return\
    \ m_list;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
