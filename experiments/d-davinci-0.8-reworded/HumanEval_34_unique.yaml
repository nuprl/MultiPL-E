name: HumanEval_34_unique
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique elements\
  \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
  \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n"
tests: "unittest\n{\n    alias candidate = unique;\n\n    assert(candidate([5L, 3L,\
  \ 5L, 2L, 3L, 3L, 9L, 0L, 123L]) == [0L, 2L, 3L, 5L, 9L, 123L]);\n}\nvoid main(){}"
completions: ["{\n    SortedSet!(typeof(l[0])) s = new SortedSet!(typeof(l[0]));\n\
    \    foreach(x; l)\n        s.insert(x);\n    return s.array;\n}\n/*\n    Given\
    \ an array of indices of constant length, return an array \n    of sorted unique\
    \ elements in the indexed array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L], [0L, 3L, 7L])\n    [5L, 2L, 0L]\n*/\nlong[] unique(long[] l, long[] i)\
    \ \n{\n    SortedSet!(typeof(l[0])) s = new SortedSet!(typeof(l[0]));\n    foreach(x;\
    \ i)\n        s.insert(l[x]);\n    return s.array;\n}\n/*\n    Given an array\
    \ of indices and a sorted array, return a sorted array of \n    unique elements\
    \ of the indexed array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L],\
    \ [0L, 3L, 7L], sort=true)\n    [0L, 2L, 5L]\n*/\nlong[] unique(long[] l, long[]\
    \ i, bool sort = false) \n{\n    SortedSet!(typeof(l[0])) s = new SortedSet!(typeof(l[0]));\n\
    \    foreach(x; i)\n        s.insert(l[x]);\n    if(sort)\n        return s.array;\n\
    \    else\n        return s.byKey;\n}\n/*\n    Given a sorted array, return a\
    \ sorted array of unique elements\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L], sort=true)\n    [0L, 2L, 3L, 5L, 9L, 123L]\n*/\nlong[] unique(long[]\
    \ l, bool sort = false) \n{\n    SortedSet!(typeof(l[0])) s = new", "{\n    int\
    \ n = l.length;\n    n = n.pow(2);\n    long[n] tmp;\n    int i = 0;\n    int\
    \ j = 0;\n    for (i in 0..n-1) \n    {\n        if (l[i] != l[i+1]) \n      \
    \  {\n            tmp[j] = l[i];\n            j++;\n        }\n    }\n    return\
    \ tmp;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique(['a',\
    \ 'b', 'a', 'd', 'b', 'b', 'z', 'A', 'D'])\n    ['A', 'D', 'a', 'b', 'd', 'z']\n\
    \    \n*/\nchar[] unique(char[] l) \n{\n    int n = l.length;\n    n = n.pow(2);\n\
    \    char[n] tmp;\n    int i = 0;\n    int j = 0;\n    for (i in 0..n-1) \n  \
    \  {\n        if (l[i] != l[i+1]) \n        {\n            tmp[j] = l[i];\n  \
    \          j++;\n        }\n    }\n    return tmp;\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([1.0, 2.0, 1.0, 9.0, 2.0, 9.0, 0.0, 123.0])\n\
    \    [0.0, 1.0, 2.0, 9.0, 123.0]\n    \n*/\ndouble[] unique(double[] l) \n{\n\
    \    int n = l.length;\n    n = n.pow(2);\n    double[n] tmp;\n    int i = 0;\n\
    \    int j = 0;\n    for (i in 0..n-1) \n    {\n        if (l[i] != l[i+1]) \n\
    \        {\n            tmp[j] = l[i];\n            j++;\n        }\n    }\n \
    \   return tmp;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([1,\
    \ 2, 1, 9, 2, 9, 0, 123", "{\n    int[] idx = array(l.sort).uniqIndices;\n   \
    \ return l[idx];\n}", "{\n    // https://rosettacode.org/wiki/Unique_elements#D\n\
    \    long[] d = unique(sort(l));\n    return d;\n}", "{\n\tauto a = l[0 .. l.length].dup;\
    \ // This avoids overwriting data during sorting\n\ta.sort;\n\treturn a.uniq;\n\
    }", "{\n\tif (l.length == 0) \n\t{\n\t\treturn [];\n\t}\n\tauto elems = set(l);\n\
    \treturn elems.array;\n}\n/*\nReturn sorted unique elements in an array\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nstring[] unique(string[] l) \n{\n\tif (l.length == 0) \n\t{\n\t\treturn\
    \ [];\n\t}\n\tauto elems = set(l);\n\treturn elems.array;\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/", "{\n\tlong[] tmp = new long[l.length];\n\
    \ttmp[] = l;\n\tsort(tmp);\n\treturn std.algorithm.unique(tmp);\n}", "{\n    return\
    \ unique(l, (a, b) => a < b);\n}", "{\n    assert(l);\n    auto r = to!(long[])([]);\n\
    \    foreach(e; l) \n    {\n        if(r.count(e) == 0) \n        {\n        \
    \    r ~= e;\n        }\n    }\n    return r.sort();\n}\n/*\nReturn a random element\n\
    */\nlong choice(long[] l) \n{\n    assert(l);\n    return l[uniform(0, l.length)];\n\
    }\n/*\nReturn a random element from the population and remove it from the population\n\
    \    >>> population = [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L]\n    >>> sample(population,\
    \ 1L)\n    [4L]\n    >>> population\n    [1L, 2L, 3L, 5L, 6L, 7L, 8L, 9L, 10L]\n\
    */\nlong[] sample(long[] l, long k) \n{\n    assert(l && k <= l.length);\n   \
    \ auto r = to!(long[])([]);\n    foreach(i; k.iota) \n    {\n        r ~= l.remove(uniform(0,\
    \ l.length));\n    }\n    return r;\n}\nlong[] range(long stop) \n{\n    return\
    \ range(0L, stop, 1L);\n}\nlong[] range(long start, long stop) \n{\n    return\
    \ range(start, stop, 1L);\n}\nlong[] range(long start, long stop, long step) \n\
    {\n    assert(start <= stop);\n    assert(step > 0L);\n    auto r = to!(long[])([]);\n\
    \    foreach(i; start.iota(stop-1L, step)) \n    {\n        r ~= i;\n    }\n \
    \   return r;\n}\n/*\nReturn the median of numeric data\n*/\nlong median(long[]\
    \ l) \n{\n    assert(l);\n    return l.sort()[cast(size_t)(l.length/2)];\n}\n\
    /*\nReturn the mean of numeric data\n*/\nlong mean(long", "{\n    long[] r;\n\
    \    int start = 0;\n    foreach(int i, long x; l) {\n        if (start == 0 ||\
    \ x != r[start - 1]) {\n            r ~= x;\n            start++;\n        }\n\
    \    }\n    return r;\n}\n \n \n/*\nReturn the number of unique elements in an\
    \ array\n    >>> unique_count([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    6L\n\
    */\nlong unique_count(long[] l) \n{\n    return unique(l).length;\n}", "{\n  \
    \  long[long] seen;\n    long[] res;\n    foreach (e; l)\n    {\n        if (e\
    \ in seen)\n            continue;\n        res ~= e;\n        seen[e] = 1;\n \
    \   }\n    res.sort;\n    return res;\n}\n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9,\
    \ 123]\n    \n*/", "{\n    int[] idx = sort!((a, b) => l[a] < l[b])(iota(l.length));\n\
    \    return idx.map!(i => l[i]).dedup;\n}", "{\n    return std.typecons.unique(l);\n\
    }", "{\n    l.sort();\n    return l.uniq;\n}", "{\n    l.sort();\n    return l.removeDups();\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique2(long[] l)\n{\n    l.sort();\n    l.popFront();\n    for(int i = 0; i\
    \ < l.length; i++)\n    {\n        if(l[i] == l[i + 1])\n        {\n         \
    \   l.remove(i);\n        }\n    }\n    return l;\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique3(long[] l)\n{\n    l.sort();\n\
    \    l.popFront();\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i]\
    \ == l[i + 1])\n        {\n            l.remove(i);\n        }\n    }\n    return\
    \ l;\n}", "{\n\tstd.sort(l);\n\treturn l.dup.uniq;\n}", "{\n    return unique(l,\
    \ (a, b) => a < b);\n}", "{\n    long[] res = [];\n    long n = l.length;\n  \
    \  bool[] was = new bool[n];\n    long idx = 0;\n    for (long i = 0; i < n; i++)\n\
    \    {\n        was[i] = false;\n    }\n    for (long i = 0; i < n; i++)\n   \
    \ {\n        if (!was[i])\n        {\n            res.append(l[i]);\n        \
    \    idx++;\n            for (long j = i + 1; j < n; j++)\n            {\n   \
    \             if (l[i] == l[j])\n                {\n                    was[j]\
    \ = true;\n                }\n            }\n        }\n    }\n    return res;\n\
    }", "{\n    version(all)\n    {\n        auto result = std.algorithm.sort.mergeSort(l).dup;\n\
    \        return result.length ? result.retain!(\"a == b[1]\")() : result;\n  \
    \  }\n    else\n    {\n        return std.algorithm.sort.mergeSort(l).uniq;\n\
    \    }\n}", "{\n    return sort(toSet(l));\n}\n/*\nGet duplicates in an array\n\
    \    >>> duplicate([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [3L, 5L]\n*/\n\
    long[] duplicate(long[] l) \n{\n    long[] ret = [];\n    long[] u = unique(l);\n\
    \    for (l1; l1=u) \n    {\n        if (count(l, l1) > 1)\n            ret ~=\
    \ l1;\n    }\n    return ret;\n}\n/*\nFind unique elements in an array\n    >>>\
    \ findUnique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [2L, 0L, 9L, 123L]\n\
    */\nlong[] findUnique(long[] l) \n{\n    long[] ret = [];\n    long[] u = unique(l);\n\
    \    for (l1; l1=l) \n    {\n        if (!l1 in u)\n            ret ~= l1;\n \
    \   }\n    return ret;\n}\n/*\nReturn a list of the indicies of all values that\
    \ are equal to the given value\n    >>> indexOfAll(0L, [5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [7L]\n*/\nlong[] indexOfAll(long l, long[] l1) \n{\n   \
    \ long[] ret = [];\n    foreach (i, l2; l1) \n    {\n        if (l2 == l)\n  \
    \          ret ~= i;\n    }\n    return ret;\n}\n/*\nGet the mean of an array\n\
    \    >>> mean([1.0, 2.0, 3.0, 4.0, 5.0])\n    3.0\n*/\nreal mean(real[] r) \n\
    {\n    return sum(r) / r.length;\n}\n/*\nGet the median of an array\n    >>> median([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    3", "{\n    return l.sort().join(l.sort().reverse()).unique();\n\
    }\n/*\nFind all pairs of points whose sum is 0\n    >>> pairs([-2L, -1L, 0L, 1L,\
    \ 2L])\n    [-1L, 1L, -2L, 2L]\n*/\nlong[] pairs(long[] l)\n{\n    long[] r1 =\
    \ l.map!(a => 0L - a);\n    long[] r2 = l.filter!(a => r1.canFind(a));\n    return\
    \ l.filter!(a => r2.canFind(0L - a));\n}\n/*\nCreate a vector of the first 10\
    \ integers, \nthen create a vector of their squares\n    >>> square(10L)\n   \
    \ [0L, 1L, 4L, 9L, 16L, 25L, 36L, 49L, 64L, 81L]\n*/\nlong[] square(long n)\n\
    {\n    return iota(n).map!(a => a*a);\n}\n/*\nCreate a vector of the first 10\
    \ integers, \nthen create a vector of their cubes\n    >>> cube(10L)\n    [0L,\
    \ 1L, 8L, 27L, 64L, 125L, 216L, 343L, 512L, 729L]\n*/\nlong[] cube(long n)\n{\n\
    \    return iota(n).map!(a => a*a*a);\n}\n/*\nFind the unique elements of an array\n\
    \    >>> unique([1L, 2L, 1L, 3L, 2L, 5L])\n    [1L, 2L, 3L, 5L]\n*/\nlong[] unique(long[]\
    \ l)\n{\n    return l.sort().join(l.sort().reverse()).unique();\n}\n/*\nReturn\
    \ the median of an odd-length vector\n    >>> oddmedian([3L, 5L, 1L, 9L, 4L])\n\
    \    4L\n*/\nlong oddmedian(long[] l)\n{\n    return l.sort[cast(int)(l.length/2)];\n\
    }\n/*\nReturn the median of an even-length vector\n    >>> evenmedian([3L", "{\n\
    \    long[] h;\n    h.reserve(__uniq(l));\n    auto t = tuple(l);\n    foreach(i;0..l.length)\n\
    \    {\n        if(t[i].length == 1)\n        {\n            h ~= l[i];\n    \
    \    }\n    }\n    return h;\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n   \
    \ \n*/", "{\n    int a1 = 0;\n    long[] a2 = new long[l.length];\n    auto a3\
    \ = new long[l.length];\n    foreach (elem; l)\n    {\n        if (elem !in a2)\n\
    \        {\n            a2[a1] = elem;\n            a1++;\n        }\n    }\n\
    \    a3 = a2[0..a1];\n    return a3;\n}", "{\n    auto seen = [false; l.length];\n\
    \    long[] out = void;\n    foreach (idx, value; l)\n    {\n        if (!seen[idx])\n\
    \        {\n            out ~= value;\n            seen[idx] = true;\n       \
    \ }\n    }\n    return out;\n}\n/*\nReturn the mean of an array of doubles\n \
    \   >>> mean([5.5, 6.5, 7.5])\n    6.5\n*/\ndouble mean(double[] d) \n{\n    double\
    \ sum = 0.0;\n    foreach (value; d)\n    {\n        sum += value;\n    }\n  \
    \  return sum / d.length;\n}\n/*\nReturn the standard deviation of an array of\
    \ doubles\n    >>> stddev([5.5, 6.5, 7.5])\n    1.0\n*/\ndouble stddev(double[]\
    \ d) \n{\n    double avg = mean(d);\n    double sum = 0.0;\n    foreach (value;\
    \ d)\n    {\n        sum += (value - avg) * (value - avg);\n    }\n    return\
    \ sqrt(sum / d.length);\n}\n/*\nReturn the dot product of two arrays of doubles\n\
    \    >>> dot([1.0, 2.0, 3.0], [4.0, 5.0, 6.0])\n    32.0\n*/\ndouble dot(double[]\
    \ a, double[] b) \n{\n    double sum = 0.0;\n    foreach (idx, value; a)\n   \
    \ {\n        sum += value * b[idx];\n    }\n    return sum;\n}\n/*\nReturn the\
    \ sum of a two-dimensional array\n    >>> sum([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n\
    \    21.0\n*/\ndouble sum(double[][] a) \n{\n    double sum = 0.0;\n    foreach\
    \ (value; a)\n    {\n        sum += sum(value);\n    }\n    return sum;\n}\n/*\n\
    Return the sum of a one-dimensional array\n    >>> sum([1.0,", "{\n    long[][]\
    \ seen;\n    long[] ret;\n    int j;\n    int i;\n    int len;\n    uint[2] s;\n\
    \    seen = new long[][](l.length);\n    seen[0] = l;\n    i = 0;\n    for (;\
    \ (i < seen.length); i++)\n    {\n        if (seen[i].length == 0)\n        {\n\
    \            continue;\n        }\n        j = 1;\n        len = seen[i].length;\n\
    \        while ((j < len))\n        {\n            if ((seen[i][j] == seen[i][(j\
    \ - 1)]))\n            {\n                seen[i].removeAt(j);\n             \
    \   len -= 1;\n            }\n            else\n            {\n              \
    \  j += 1;\n            }\n        }\n    }\n    ret = new long[](seen.length);\n\
    \    i = 0;\n    for (; (i < seen.length); i++)\n    {\n        if (seen[i].length\
    \ == 0)\n        {\n            continue;\n        }\n        ret[i] = seen[i][0];\n\
    \    }\n    ret = ret.idup;\n    for (; (i < ret.length); i++)\n    {\n      \
    \  s = binarySearch(ret, 0L, ret.length, ret[i]);\n        if ((s[0] == 0L))\n\
    \        {\n            ret.removeAt(i);\n            i -= 1;\n        }\n   \
    \ }\n    return ret;\n}", "{\n    std.algorithm.sort(l);\n    return l.dup.retain!(x\
    \ => x != l.front);\n}", "{\n\treturn c_unique(l);\n}", "{\n    //l = l.sort();\n\
    \    //return l.uniq;\n    return l.sort().uniq;\n}", "{\n\tlong[][] tupleL =\
    \ l.sort().enumerate().map!(x => tuple(x[0], x[1]));\n\tlong[] sorted = tupleL.map!(x\
    \ => x[1]).array;\n\tlong[] result = new long[l.length];\n\tresult[0] = sorted[0];\n\
    \tint resIndex = 1;\n\t\n\tforeach(int i, long a; sorted.enumerate())\n\t{\n\t\
    \tif(a != result[resIndex - 1])\n\t\t{\n\t\t\tresult[resIndex] = a;\n\t\t\tresIndex++;\n\
    \t\t}\n\t}\n\treturn result[0..resIndex];\n}", "{\n    long[] res = new long[0L];\n\
    \    foreach (long e; l)\n    {\n        if (std.algorithm.find(res, e) == null)\
    \ \n        {\n            res ~= e;\n        }\n    }\n    return std.algorithm.sort(res);\n\
    }\n/*\nReturn a sorted vector of unique indices that get you the same order in\
    \ a vector as you had in \na vector of tuples\n    >>> a = [5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L];\n    >>> b = to!(tuple(long, int))([(e, i) for (e, i) in\
    \ zip(a, iota(a.length))]);\n    >>> b[sort_indices(b)];\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n*/\nlong[] sort_indices(T[])(T[] arr) \n{\n    Tuple!(T, long)[]\
    \ b = zip(arr, iota(arr.length));\n    return std.algorithm.sort!((e1, e2) { return\
    \ e1[0] < e2[0]; })(b)[1L];\n}\n/*\nReturn a sorted vector of unique indices that\
    \ get you the same order in a vector as you had in \na vector of tuples\n    >>>\
    \ a = [5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L];\n    >>> b = to!(tuple(long, int))([(e,\
    \ i) for (e, i) in zip(a, iota(a.length))]);\n    >>> b[sort_indices(b)];\n  \
    \  [0L, 2L, 3L, 5L, 9L, 123L]\n*/\nlong[] sort_indices_i(T)(T[] arr) \n{\n   \
    \ struct SortMe \n    {\n        T x;\n        long i;\n    }\n    SortMe[] b\
    \ = [SortMe(x, i) for (x, i) in zip(arr, iota(arr.length))];\n   ", "{\n    size_t\
    \ n = l.length;\n    long[] res = new long[n];\n    size_t i = 0;\n    foreach\
    \ (long el; l)\n    {\n        if (!res.canFind(el))\n        {\n            res[i]\
    \ = el;\n            i++;\n        }\n    }\n    res.length = i;\n    res.sort;\n\
    \    return res;\n}", "{\n\tbool[] dup = new bool[l.length];\n\tlong[] unique\
    \ = new long[l.length];\n\tlong i;\n\tint j;\n\t\n\tif (l.length == 0)\n\t\treturn\
    \ l;\n\t\n\tfor (i = 0; i < l.length; i++) {\n\t\tfor (j = i + 1; j < l.length;\
    \ j++) {\n\t\t\tif (l[i] == l[j]) {\n\t\t\t\tdup[i] = true;\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t}\n\t\n\tunique[0] = l[0];\n\tint count = 1;\n\tfor (i = 1; i\
    \ < l.length; i++) {\n\t\tif (!dup[i]) {\n\t\t\tunique[count] = l[i];\n\t\t\t\
    count++;\n\t\t}\n\t}\n\t\n\treturn unique[0..count];\n}", "{\n    long[][] elemNum\
    \ = l[].enumerate;\n    long[][] unique = elemNum.assocArray;\n    unique = unique.values;\n\
    \    unique = unique.sort;\n    return unique;\n}\n/*\nSort by count of the number\
    \ of occurrences of each element\n    >>> sortByCount([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 9L, 123L, 5L, 3L]", "{\n    l = quicksort(l);\n\
    \    return l.dup.toSet().array;\n}", "{\n    sort(l);\n    return l.array.unique(l.array);\n\
    }\n \n \n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l) \n{\n    sort(l);\n    return l.array.unique(l.array);\n}\n\
    \ \n// Remove duplicate elements from array\nlong[] unique(long[] data) \n{\n\
    \    return data.array.removeDuplicates;\n}\n// Remove duplicate elements from\
    \ array\nlong[] unique(long[] data) \n{\n    return data.array.removeDuplicates;\n\
    }\n \n// Remove duplicate elements from array\nlong[] unique(long[] data) \n{\n\
    \    return data.array.removeDuplicates;\n}", "{\n    alias long[] tmp;\n    tmp[]\
    \ = [l[0]];\n    foreach(l.indices, idx; ref long lval) {\n        if ( lval !=\
    \ tmp[$-1] )\n            tmp ~= lval;\n    }\n    return tmp;\n}", "{\n    long[]\
    \ res = [];\n    foreach(uniq; l)\n    {\n        if(uniq !in res)\n        {\n\
    \            res ~= uniq;\n        }\n    }\n    return res;\n}\n//std.algorithm.unique(l)",
  "{\n    long[] res;\n    long i;\n    //bsearch(/*const(*/long[]/*)*/ l, long value)\n\
    \    immutable(long)[] sorted = sort(l);\n    foreach(element; sorted){\n    \
    \    if(!(i in res)){\n            res ~= element;\n        }\n    }\n    return\
    \ res;\n}", "{\n    ulong[] u = l.map!(x => cast(ulong)x);\n    u = sort(u);\n\
    \    u = u.retro;\n    u = u.retro.drop(1).retro;\n    u = u.retro.drop(1).retro;\n\
    \    auto result = u.map!(x => cast(long)x).array;\n    return result;\n}", "{\n\
    \    long[] y = to!(long[])(std.algorithm.uniq(l));\n    return sort(y);\n}",
  "{\n    int n = l.length;\n    if (n == 0) return l;\n    auto result = new long[];\n\
    \    foreach (e; l)\n    {\n        if (result.length==0) result ~= e;\n     \
    \   else if (e != result[$-1]) result ~= e;\n    }\n    return result;\n}\n \n\
    /*\nReturn sorted unique elements in an array\n    >>> unique([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n*/\nlong[] unique(int[] l) \n\
    {\n    int n = l.length;\n    if (n == 0) return l;\n    auto result = new long[];\n\
    \    foreach (e; l)\n    {\n        if (result.length==0) result ~= e;\n     \
    \   else if (e != result[$-1]) result ~= e;\n    }\n    return result;\n}\n \n\
    /*\nReturn sorted unique elements in an array\n    >>> unique([5.0, 3.0, 5.0,\
    \ 2.0, 3.0, 3.0, 9.0, 0.0, 123.0])\n    [0.0, 2.0, 3.0, 5.0, 9.0, 123.0]\n   \
    \ \n*/\ndouble[] unique(double[] l) \n{\n    int n = l.length;\n    if (n == 0)\
    \ return l;\n    auto result = new double[];\n    foreach (e; l)\n    {\n    \
    \    if (result.length==0) result ~= e;\n        else if (e != result[$-1]) result\
    \ ~= e;\n    }\n    return result;\n}\n \n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([\"a\", \"a\", \"b\", \"a\", \"b\", \"c\"])\n    [\"\
    a\", \"b\", \"c\"]\n    \n*/\nstring[] unique(string[] l) \n{\n    int n = l.length;\n\
    \    if (n == 0) return l;\n    auto result = new string[];\n    foreach", "{\n\
    \     auto[u,v] = uniq(l);\n     return u;\n}", "{\n    long[long] m;\n    foreach(i;\
    \ l) m[i] = i;\n    return m.values;\n}", "{\n    auto a = l[];\n    a.sort();\n\
    \    return a.uniq;\n}\n/*\nReturn sorted unique elements in an array\n    >>>\
    \ unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n*/",
  "{\n    return std.algorithm.sort!((a, b) => a > b)(std.algorithm.uniq(l.idup));\n\
    }\n/*\nCreate an array of zeros or ones\n    >>> zerosOrOnes(4, 1)\n    [1L, 1L,\
    \ 1L, 1L]\n    >>> zerosOrOnes(4, 0)\n    [0L, 0L, 0L, 0L]\n    \n*/\nlong[] zerosOrOnes(size_t\
    \ n, int v)\n{\n    long[] res = new long[](n);\n    foreach (i; 0 .. n)\n   \
    \     res[i] = v;\n    return res;\n}\n/*\nCreate an array of a given shape and\
    \ populate it with a fill value.\n    >>> repeat(3, 4, 1)\n    [[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L], [1L, 1L, 1L, 1L]]\n    \n*/\nlong[][] repeat(size_t n, size_t\
    \ m, long v)\n{\n    long[][] res = new long[](n);\n    foreach (i; 0 .. n)\n\
    \        res[i] = new long[](m);\n    foreach (i; 0 .. n)\n        foreach (j;\
    \ 0 .. m)\n            res[i][j] = v;\n    return res;\n}\n/*\nTest whether any\
    \ array element along a given axis evaluates to True.\n    >>> any(true, false,\
    \ true)\n    true\n    >>> any(false, false, false)\n    false\n    \n*/", "{\n\
    \     auto res = [];\n     sort(l);\n     // for each unique value\n     for (i,v;\
    \ l) \n     {\n         if (i == 0 || v != l[i-1]) \n         {\n            \
    \ res ~= v;\n         }\n     }\n     return res;\n}", "{\n\tsize_t n = l.length;\n\
    \tlong[] result = new long[n];\n\tsize_t j = 0;\n\tfor (size_t i = 0; i < n; i++)\
    \ \n\t{\n\t\tif (result.length == 0 || result[$-1] != l[i]) \n\t\t{\n\t\t\tresult\
    \ ~= l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5,\
    \ 9, 123]\n*/", "{\n    long[] r = to!(long[])([])~[];\n    bool[] f = new bool[l.length];\n\
    \    for (size_t i = 0; i < l.length; i++) \n    {\n        bool b = false;\n\
    \        for (size_t j = 0; j < i; j++) \n        {\n            if (l[i] == l[j])\
    \ \n            {\n                b = true;\n                break;\n       \
    \     }\n        }\n        if (!b) \n        {\n            r.push(l[i]);\n \
    \       }\n    }\n    sort(r);\n    return r;\n}\n/*\nReturn the indices of the\
    \ maximum values along an axis.\n    >>> argmax([0L, 3L, 2L, 1L, 1L, 2L, 0L])\n\
    \    1L\n    \n*/\nlong argmax(long[] l) \n{\n    long i = 0;\n    for (size_t\
    \ j = 0; j < l.length; j++) \n    {\n        if (l[j] > l[i]) \n        {\n  \
    \          i = j;\n        }\n    }\n    return i;\n}", "{\n    Tuple2!(long[],\
    \ bool[]) t = std.algorithm.uniq(l);\n    return t.length > 0 ? t[0] : l;\n}",
  "{\n\tauto i = 1L;\n\tlong[] n = [l[0]];\n\twhile (i < l.length)\n\t{\n\t\tif (n.length\
    \ == 0 || n[$-1] != l[i])\n\t\t{\n\t\t\tn ~= l[i];\n\t\t}\n\t\ti++;\n\t}\n\tn.sort;\n\
    \treturn n;\n}", "{\n    long[] a = new long[0];\n    foreach(el; l)\n    {\n\
    \        if(!a.contains(el))\n        {\n            a ~= el;\n        }\n   \
    \ }\n    a.sort;\n    return a;\n}", "{\n    long[] a = sort(l);\n    long[] res\
    \ = [];\n    foreach(e; a) {\n        if(res.length == 0 || res[$-1] != e) res\
    \ ~= e;\n    }\n    return res;\n}", "{\n    long[] r;\n    assert(l.length ==\
    \ r.length);\n    return r;\n}", "{\n    /*\n        O(n logn)\n    */\n    l\
    \ = sort(l);\n    return filter!((prev, curr) => prev != curr)(l);\n}\nlong[]\
    \ unique(long[] l, alias pred = \"a < b\") \n{\n    /*\n        O(n logn)\n  \
    \  */\n    l = sort!pred(l);\n    return filter!((prev, curr) => prev != curr)(l);\n\
    }\nT[] unique(T)(T[] l) if (is(T == class)) \n{\n    /*\n        O(n logn)\n \
    \   */\n    l = sort(l);\n    return filter!((prev, curr) => prev != curr)(l);\n\
    }\nT[] unique(T)(T[] l, alias pred = \"a < b\") if (is(T == class)) \n{\n    /*\n\
    \        O(n logn)\n    */\n    l = sort!pred(l);\n    return filter!((prev, curr)\
    \ => prev != curr)(l);\n}", "{\n    int[] seen;\n    long[] res;\n    foreach(lval;\
    \ l)\n    {\n        if(!seen[lval])\n        {\n            res ~= lval;\n  \
    \          seen[lval] = 1;\n        }\n    }\n    return res;\n}", "{\n    auto\
    \ v = l[].array.array(dtype=int);\n    long[] result = long[v.size];\n    foreach(i,idx;\
    \ typeof(v)){\n        result[i] = idx;\n    }\n    return result;\n}", "{\n \
    \   auto m = l[];\n    auto size = 0;\n    foreach(val; l) \n    {\n        if(!m.contains(val))\
    \ \n        {\n            m ~= val;\n            size++;\n        }\n    }\n\
    \    auto r = new long[size];\n    std.array.copy(std.array.sort(m), r);\n   \
    \ return r;\n}\n/*\nReturn the unique elements in an array.\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(in long[] l) \n{\n    return std.algorithm.uniq(l);\n}\n/*\nReturn\
    \ the unique elements in an array.\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(ref long[]\
    \ l) \n{\n    return std.algorithm.uniq(l);\n}\n/*\nReturn the unique elements\
    \ in an array.\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(shared(long)[] l) \n{\n    return\
    \ std.algorithm.uniq(l);\n}\n/*\nReturn sorted unique elements in an array\n \
    \   >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n\
    */", "{\n    auto tmp = new long[$];\n    foreach(e; l)\n    {\n        bool found\
    \ = false;\n        foreach(t; tmp)\n        {\n            if(e == t)\n     \
    \       {\n                found = true;\n                break;\n           \
    \ }\n        }\n        if(!found) tmp ~= e;\n    }\n    tmp.sort;\n    return\
    \ tmp;\n}", "{\n    long[long] seen;\n    foreach (e; l)\n        seen[e] = 1;\n\
    \    return sort(seen.keys);\n}", "{\n    immutable void*[size_t] h = new void*[size_t][];\n\
    \    h[typeid(l).getHash()] = l;\n    immutable auto s = sort!(\"a < b\")(l);\n\
    \    immutable auto e = s.dup;\n    foreach (j; 0 .. s.length)\n    {\n      \
    \  if (j > 0 && e[j] == e[j - 1])\n        {\n            h[typeid(e).getHash()]\
    \ = e.remove(j);\n            j--;\n        }\n    }\n    return e;\n}", "{\n\
    \    \n    long[] res = new long[];\n    foreach(d;l)\n    {\n        if( d in\
    \ res ) continue;\n        res ~= d;\n    }\n    return res.sort;\n}", "{\n  \
    \   if (l.length == 0)\n     {\n         return null;\n     }\n     else\n   \
    \  {\n         return l.front.uniqRetain.sort.array;\n     }\n }", "{\n    return\
    \ uniqueResult!(l[])(l);\n}", "{\n    return uniquer!(a => a)(l);\n}", "{\n\t\
    long[][] r;\n\tr[0] = l[0];\n\tforeach(n; 1..l.length)\n\t{\n\t\tint[] p;\n\t\t\
    foreach(i; 0..n)\n\t\t{\n\t\t\tif(l[n] == l[i])\n\t\t\t{\n\t\t\t\tp ~= 1;\n\t\t\
    \t}\n\t\t}\n\t\tif(p.length == 0)\n\t\t{\n\t\t\tr ~= l[n];\n\t\t}\n\t}\n\treturn\
    \ r;\n}", "{\n    long[][] a;\n    long res[];\n    int[] elemIndexes;\n    int\
    \ i;\n    int indexInRes;\n    int lastIndex;\n    long[] elem;\n    long s;\n\
    \    long[] sorted;\n    sorted = l.dup.sort;\n    lastIndex = 0;\n    i = 0;\n\
    \    a = new long[sorted.length][2];\n    for (elem; sorted;)\n    {\n       \
    \ if (i == 0)\n        {\n            a[i][0] = elem;\n            a[i][1] = 1;\n\
    \            i = i + 1;\n        }\n        else\n        {\n            s = sorted[lastIndex];\n\
    \            if (s == elem)\n            {\n                a[i - 1][1] = a[i\
    \ - 1][1] + 1;\n            }\n            else\n            {\n             \
    \   a[i][0] = elem;\n                a[i][1] = 1;\n                i = i + 1;\n\
    \            }\n        }\n        lastIndex = lastIndex + 1;\n    }\n    res\
    \ = new long[];\n    elemIndexes = new int[];\n    for (indexInRes = 0; indexInRes\
    \ < a.length; indexInRes++)\n    {\n        if (a[indexInRes][1] == 1)\n     \
    \   {\n            elemIndexes ~= indexInRes;\n        }\n    }\n    res = getElemsAtIndexes(a,\
    \ elemIndexes);\n    return res;\n}\nlong[] getElemsAtIndexes(long[][] l, int[]\
    \ indexes) \n{\n    long[] res;\n    int i;\n    res = new long[];\n    for (i;\
    \ indexes;)\n    {\n        res ~= l[i][0];\n    }\n    return res;\n}\nlong[]\
    \ getColumn(long[][] l, int index) \n{\n    long[] res;\n    res = new long[];\n\
    \    for (long[] row; l;)\n    {\n        res ~= row[index];\n    }\n    return\
    \ res;\n}", "{\n    int[] tmp=unique(cast(int[])l);\n    long[] res=new long[tmp.length];\n\
    \    foreach(int i,long x;tmp)\n    {\n        res[i]=x;\n    }\n    return res;\n\
    }", "{\n    auto d = new long[0L];\n    foreach(i; l)\n    {\n        if(i !in\
    \ d) d ~= i;\n    }\n    d.sort;\n    return d;\n}", "{\n    return l.unique.sort;\n\
    }\n/*\nFind first element after current time in a sorted list of time values\n\
    \    >>> later([1.0, 2.0, 3.0, 4.0], 2.5)\n    3.0\n    \n*/\ndouble later(double[]\
    \ times, double current_time) \n{\n    if (times.empty)\n    {\n        throw\
    \ new std.range_error(\"Empty array!\");\n    }\n    foreach (idx, time; times[0..$\
    \ - 1])\n    {\n        if (current_time < time)\n        {\n            return\
    \ time;\n        }\n    }\n    throw new std.range_error(\"No later times!\");\n\
    }\n/*\nFind index of first element after current time in a sorted list of time\
    \ values\n    >>> later([1.0, 2.0, 3.0, 4.0], 2.5)\n    2\n    \n*/\nsize_t later_idx(double[]\
    \ times, double current_time) \n{\n    if (times.empty)\n    {\n        throw\
    \ new std.range_error(\"Empty array!\");\n    }\n    foreach (idx, time; times[0..$\
    \ - 1])\n    {\n        if (current_time < time)\n        {\n            return\
    \ idx;\n        }\n    }\n    throw new std.range_error(\"No later times!\");\n\
    }\n/*\nFind previous element before current time in a sorted list of time values\n\
    \    >>> earlier([1.0, 2.0, 3.0, 4.0], 2.5)\n    2.0\n    \n*/\ndouble earlier(double[]\
    \ times, double current_time) \n{\n    if (times.empty)\n    {\n        throw\
    \ new std.range_error(\"Empty array!\");\n    }\n    foreach (idx, time; times[1..$])\n\
    \    {\n        if (current_time <= time)\n        {\n            return times[idx\
    \ - 1];\n        }\n    }\n    throw new std.range_error(\"No earlier times!\"\
    );\n}\n/*\nFind index of previous element before current time in a sorted list\
    \ of time values\n    >>> earlier", "{\n    return sort(toSet(l)).array();\n}\n\
    /*\nReturn sorted unique elements in an array\n    >>> unique([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n*/", "{\n    std.typecons.Tuple!(ulong,\
    \ int)[][] tl = new typecons.Tuple!(ulong, int)[][](l.length);\n    foreach(ind,\
    \ elem; l)\n    {\n        tl[ind] = typecons.tuple(cast(ulong)elem, ind);\n \
    \   }\n    tl.sort!(\"a[0] < b[0]\");\n    long[] unique = new long[l.length];\n\
    \    int c = 0;\n    foreach(ind, elem; tl)\n    {\n        if(ind == 0 || elem[0]\
    \ != tl[ind-1][0])\n        {\n            unique[c] = cast(long)elem[0];\n  \
    \          c++;\n        }\n    }\n    unique = unique[0..c];\n    return unique;\n\
    }", "{\n    return  (l.byValue.sort).uniq;\n}", "{\n    auto r = sort(l);\n  \
    \  return (unique(r));\n}", "{\n\tlong[] nl;\n\tlong n;\n\t\n\tn = l.length;\n\
    \tnl = new long[n];\n\tnl[0] = l[0];\n\tforeach(i; 1..n) {\n\t\tif (l[i] != l[i-1])\
    \ {\n\t\t\tnl ~= l[i];\n\t\t}\n\t}\n\treturn nl;\n}\n/*\nReturn true if item is\
    \ in an array\n    >>> in([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], 2L)\n    true\n\
    */", "{\n    long[] u = new long[l.length];\n    size_t n = l.length;\n    size_t\
    \ j = 0;\n    for (size_t i = 0; i < n; i++) \n    {\n        if (i == 0 || l[i]\
    \ != l[i - 1]) \n        {\n            u[j] = l[i];\n            j += 1;\n  \
    \      }\n    }\n    u = u[0..j];\n    return u;\n}", "{\n    auto res = array();\n\
    \    foreach(a; l) \n    {\n        if (a in res) \n        {\n            continue;\n\
    \        }\n        res ~= a;\n    }\n    res.sort;\n    return res;\n}", "{\n\
    \t\n\tlong[] n = l.dup;\n\tn.sort;\n\treturn n.unique;\n}", "{\n\tlong[] u;\n\t\
    std.algorithm.sort(l);\n\t\n\tu = iota(1L);\n\tforeach(v; l)\n\t{\n\t\tif (u[$-1]\
    \ != v)\n\t\t\tu ~= v;\n\t}\n\treturn u[1..$];\n}\n/*\nUnique elements in an array,\
    \ keeping order\n    >>> unique2([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n   \
    \ [5L, 3L, 2L, 9L, 0L, 123L]\n*/\nlong[] unique2(long[] l) \n{\n\tlong[] u;\n\t\
    u = [];\n\tforeach(v; l)\n\t{\n\t\tif (!std.algorithm.any!\"(a==b)\"(u, v))\n\t\
    \t\tu ~= v;\n\t}\n\treturn u;\n}", "{\n  size_t[] unique_indexes;\n  unique_indexes.length\
    \ = l.length;\n  size_t i;\n  i = 0;\n  while (i < l.length) \n  {\n    if (!(in(l[i],\
    \ l[0..i]))) \n    {\n      unique_indexes[i] = i;\n    }\n    i += 1;\n  }\n\
    \  unique_indexes = unique_indexes.array.remove(null);\n  return l[unique_indexes];\n\
    }\n// Function to return the hash of a string\n// http://stackoverflow.com/questions/4288253/how-to-calculate-a-hash-from-a-string-in-d\n\
    private long getHash(string s) \n{\n  long hash = 0L;\n  long x    = 0L;\n  foreach\
    \ (x; s) \n  {\n    hash = ((hash * 1664525L) + (x * 1013904223L)) % ((long)math.pow(2L,\
    \ 32L) - 1L);\n  }\n  return hash;\n}\n// Function to return a list of the hash\
    \ of all the permutations of a string\n// http://stackoverflow.com/questions/4288253/how-to-calculate-a-hash-from-a-string-in-d\n\
    long[] getHashFromPermutations(string s) \n{\n  size_t len = s.length;\n  long[]\
    \ hashes;\n  hashes.length = len;\n  string[] tmp_str;\n  tmp_str.length = len;\n\
    \  for (long i = 0L; i < (len); i++) \n  {\n    tmp_str[i] = s[i .. i];\n  }\n\
    \  string tmp;\n  while (tmp_str != std.algorithm.nextPermutation(tmp_str)) \n\
    \  {\n    tmp = \"\";\n    foreach (tmp; tmp_str) \n    {\n      tmp ~= tmp;\n\
    \    }\n    hashes ~= getHash(tmp);\n  }\n  return unique(hashes);\n}\n// Function",
  "{\n    std.algorithm.sort(l);\n    return l.uniq;\n}\n/*\nInsert a number in a\
    \ binary search tree\n    >>> auto tree = BST(\n            7L,\n            BST(6L,\
    \ null, null),\n            BST(8L,\n                BST(5L, null, null),\n  \
    \              BST(9L, null, null)));\n    >>> tree.insert(4L);\n    >>> tree.insert(10L);\n\
    \    >>> tree.inorder().array;\n    [4L, 5L, 6L, 7L, 8L, 9L, 10L]\n    >>> tree.insert(8L);\n\
    \    >>> tree.inorder().array;\n    [4L, 5L, 6L, 7L, 8L, 8L, 9L, 10L]\n*/\nstruct\
    \ BST \n{\n    long node;\n    BST* left;\n    BST* right;\n    \n    BST* insert(long\
    \ value) \n    {\n        if (value <= node) \n        {\n            if (left)\
    \ \n            {\n                left.insert(value);\n            } \n     \
    \       else \n            {\n                left = BST(value, null, null);\n\
    \            }\n        } \n        else \n        {\n            if (right) \n\
    \            {\n                right.insert(value);\n            } \n       \
    \     else \n            {\n                right = BST(value, null, null);\n\
    \            }\n        }\n        return this;\n    }\n    \n    Tuple!(BST*,\
    \ bool) search(long value) \n    {\n        if (value == node) \n        {\n \
    \           return tuple(this, true);\n        } \n        else if (value < node)\
    \ \n        {\n            if (left) \n            {\n                return left.search(value);\n\
    \            } \n            else \n            {\n                return tuple(this,\
    \ false);\n            }\n        } \n        else \n        {\n            if\
    \ (right) \n            {\n                return right.search(value);\n     \
    \       } \n            else \n            {\n                return tuple(this,\
    \ false);\n            }\n        }\n    }", "{\n    long[] result = [];", "{\n\
    \    long[] ul = new long[];\n    foreach(i; l)\n    {\n        if(ul.canFind(i))\n\
    \            continue;\n        ul ~= i;\n    }\n    ul.sort;\n    return ul;\n\
    }", "{\n\timmutable HashSet!(long) h = new HashSet!(long)();\n\tforeach(e; l)\n\
    \t{\n\t\th.insert(e);\n\t}\n\tl = to!(long[])(h.keys);\n\tsort(l);\n\treturn l;\n\
    }", "{\n    auto u = array(sort(l));\n    long[] r = new long[];\n    int i =\
    \ 0;\n    foreach(e; u) \n    {\n        if (i == 0 || r[$-1] != e) \n       \
    \ {\n            r ~= e;\n            i++;\n        }\n    }\n    return r;\n}",
  "{\n    long[] _ = l.dup;\n    sort(_);\n    return _.uniq;\n}\n/*\nreturn number\
    \ of elements in array\n    >>> length([1, 2, 3, 4, 5])\n    5\n*/\nsize_t length(T[]\
    \ arr)\n{\n    return arr.length;\n}\n/*\nSum of an array\n    >>> sum([1, 2,\
    \ 3, 4, 5])\n    15\n*/\nlong sum(long[] l) \n{\n    return l.sum;\n}\n/*\nCompute\
    \ sum over array\n    >>> sum([1, 2, 3, 4, 5])\n    15\n*/\nlong sum(T)(T[] arr)\n\
    {\n    long sum = 0;\n    foreach(i; arr) {\n        sum += i;\n    }\n    return\
    \ sum;\n}\n/*\nCompute product over array\n    >>> product([1, 2, 3, 4, 5])\n\
    \    120\n*/\nlong product(T)(T[] arr)\n{\n    long product = 1;\n    foreach(i;\
    \ arr) {\n        product *= i;\n    }\n    return product;\n}\n/*\nReturn minimum\
    \ value of array\n    >>> minimum([1, 3, 2, 5, 4])\n    1\n*/\nlong minimum(long[]\
    \ l) \n{\n    return l.min;\n}\n/*\nReturn maximum value of array\n    >>> maximum([1,\
    \ 3, 2, 5, 4])\n    5\n*/\nlong maximum(long[] l) \n{\n    return l.max;\n}\n\
    /*\nReturn mean value of array\n    >>> mean([1, 3, 2, 5, 4])\n    3\n*/\ndouble\
    \ mean(long[] l) \n{\n    return l.mean;\n}\n/*\nReturn median value of array\n\
    \    >>> median([1, 3, 2, 5, 4])\n    3\n*/\ndouble median(long[] l) \n{\n   \
    \ return l.median;\n}\n/*\nReturn variance of array\n    >>> variance([1, 3, 2,\
    \ 5, 4])\n    2.666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666",
  "{\n    long[] ul = typeof(ul).init;\n    long i = 0;\n    for (; i < l.length;\
    \ ++i)\n    {\n        long j = 0;\n        for (; j < ul.length; ++j)\n     \
    \   {\n            if (l[i] == ul[j])\n            {\n                break;\n\
    \            }\n        }\n        if (j == ul.length)\n        {\n          \
    \  ul ~= l[i];\n        }\n    }\n    return sort(ul);\n}\n/*\nReturn min/max\
    \ value and it's index in given array\n    >>> minmax([5L, 3L, 9L, 1L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    (0L, 123L, 8L, 0L)\n*/\nTuple!(long, long, long, long) minmax(long[]\
    \ l) \n{\n    if (l.length == 0)\n    {\n        throw new Exception(\"Can't compute\
    \ min/max on empty array\");\n    }\n    long minv = l[0];\n    long maxv = l[0];\n\
    \    long mini = 0;\n    long maxi = 0;\n    long i = 1;\n    for (; i < l.length;\
    \ ++i)\n    {\n        if (l[i] < minv)\n        {\n            minv = l[i];\n\
    \            mini = i;\n        }\n        if (l[i] > maxv)\n        {\n     \
    \       maxv = l[i];\n            maxi = i;\n        }\n    }\n    return tuple(minv,\
    \ maxv, mini, maxi);\n}\n/*\nReturn all permutations of given list\n    >>> permutations([1L,\
    \ 2L, 3L])\n    [[1L, 2L, 3L], [1L, 3L, 2L], [2L, 1L, 3L], [2L, 3L, 1L], [3L,\
    \ 1L, 2L], [3L, 2L, 1L]]\n*/\nlong[][] permutations(long[] l) \n{\n    long[][]\
    \ perms = typeof(perms).", "{\n    struct wrapper\n    {\n\tlong x;\n\tbool operator==(wrapper\
    \ rhs) const { return x == rhs.x; }\n\tbool operator!=(wrapper rhs) const { return\
    \ x != rhs.x; }\n\tbool operator<(wrapper rhs) const { return x < rhs.x; }\n \
    \   }\n    auto wrapped = l.map!(w => wrapper(w));\n    return wrapped.uniq.map!(w\
    \ => w.x).sort.array;\n}\n/*\nReturn sorted unique elements in an array\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l) \n{\n    return l.uniq.sort.array;\n}\n/*\n\
    Return sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l) \n{\n    auto sorted = l.sort;\n    long[] unique;\n    unique ~= sorted[0];\n\
    \    foreach(i, x; sorted[1..$])\n    {\n\tif(x != sorted[i])\n\t    unique ~=\
    \ x;\n    }\n    return unique;\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n{\n    auto sorted = l.sort;\n\
    \    long[] unique;\n    long last = sorted[0];\n    unique ~= last;\n    foreach(x;\
    \ sorted[1..$])\n    {\n\tif(x != last)\n\t{\n\t    unique ~= x;\n\t    last =\
    \ x", "{\n    long[] result = [];\n    foreach(i;l)\n    {\n        if(i in result)\n\
    \            continue;\n        result ~= i;\n    }\n    return result;\n}\nlong[]\
    \ unique(T)(T[] l) \n{\n    long[] result = [];\n    foreach(i;l)\n    {\n   \
    \     if(i in result)\n            continue;\n        result ~= i;\n    }\n  \
    \  return result;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([\"\
    abc\", \"abc\", \"def\", \"xyz\", \"abc\"])\n    [\"abc\", \"def\", \"xyz\"]\n\
    */\nstring[] unique(string[] l) \n{\n    string[] result = [];\n    foreach(i;l)\n\
    \    {\n        if(i in result)\n            continue;\n        result ~= i;\n\
    \    }\n    return result;\n}\n/*\nRemove instances of an element in an array\n\
    \    >>> remove([\"abc\", \"def\", \"xyz\", \"abc\"], \"abc\")\n    [\"def\",\
    \ \"xyz\"]\n*/\nT[] remove(T)(T[] l, T o) \n{\n    auto result = l;\n    while(o\
    \ in result)\n        result = result[0..$-1];\n    return result;\n}\n/*\nReturn\
    \ the index of the first occurence of an element in an array\n    >>> indexof([\"\
    abc\", \"def\", \"xyz\", \"abc\"], \"abc\")\n    0\n    >>> indexof([\"abc\",\
    \ \"def\", \"xyz\", \"abc\"], \"def\")\n    1\n    >>> indexof([\"abc\", \"def\"\
    , \"xyz\", \"abc\"], \"xyz\")\n    2\n    >>> indexof([\"abc\", \"def\", \"xyz\"\
    , \"abc\"], \"zyx\")\n    -1\n*/", "{\n    // sort array\n    sort(l);\n    //\
    \ remove duplicate\n    l = array(remove(l, 1u));\n    return l;\n}", "{\n\tauto\
    \ a = array(l);\n\ta.sort();\n\treturn a.dup.unique();\n}", "{\n    const(ubyte)[]\
    \ r=to!(const(ubyte)[]) l;\n    std.array.sort(r);\n    return r.unique();\n}",
  "{\n    return l[$-uniq];\n}", "{\n\tbool[] has = new bool[__MAX_LONG];\n\t\n\t\
    foreach(l0; l) {\n\t\thas[l0] = true;\n\t}\n\tlong[] r;\n\tforeach(l0; l) {\n\t\
    \tif(has[l0])\n\t\t\tr ~= l0;\n\t\thas[l0] = false;\n\t}\n\treturn r;\n}", "{\n\
    \    return sort(l).uniq();\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([0L, 1L, 2L, 3L, 4L, 5L, 0L, 1L, 2L, 3L, 4L, 5L])\n    [0L, 1L,\
    \ 2L, 3L, 4L, 5L]\n    \n*/\nlong[] unique(long[] l, long[] l1) \n{\n    l ~=\
    \ l1;\n    return sort(l).uniq();\n}\n/*\nReturn sorted unique elements in an\
    \ array\n    >>> unique([0L, 1L, 2L, 3L, 4L, 5L, 0L, 1L, 2L, 3L, 4L, 5L, 0L, 1L,\
    \ 2L, 3L, 4L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    \n*/\nlong[] unique(long[]\
    \ l, long[] l1, long[] l2) \n{\n    l ~= l1;\n    l ~= l2;\n    return sort(l).uniq();\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([0L, 1L, 2L,\
    \ 3L, 4L, 5L, 0L, 1L, 2L, 3L, 4L, 5L, 0L, 1L, 2L, 3L, 4L, 5L, 0L, 1L, 2L, 3L,\
    \ 4L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    \n*/\nlong[] unique(long[] l, long[]\
    \ l1, long[] l2, long[] l3) \n{\n    l ~= l1;\n    l ~= l2;\n    l ~= l3;\n  \
    \  return sort(l).uniq();\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([0L, 1L, 2L, 3L, 4L, 5L, 0L, 1L, 2L, 3L, 4L, 5L, 0L, 1L, 2L, 3L,\
    \ 4L,", "{\n    auto ret = new long[0L];\n    foreach(ind, el; l)\n    {\n   \
    \     if(el !in ret)\n        {\n            ret ~= el;\n        }\n    }\n  \
    \  ret.sort;\n    return ret;\n}", "{\n    return to!(long[])(unique(l.map!(a\
    \ => to!string(a))));\n}", "{\n    size_t[] uniqueIndex = new size_t[l.length];\n\
    \    size_t uniqueCount = 0;\n    foreach (e; l)\n    {\n        if (uniqueCount\
    \ == 0 || e != l[uniqueIndex[uniqueCount - 1]])\n        {\n            uniqueIndex[uniqueCount]\
    \ = e;\n            uniqueCount++;\n        }\n    }\n    return uniqueIndex[0\
    \ .. uniqueCount];\n}", "{\n    if (l.length == 0)\n    {\n        return l;\n\
    \    }\n    auto uniqueElements = new long[][]();\n    uniqueElements ~= l[0];\n\
    \    for (auto i = 1; i < l.length; i++)\n    {\n        if (!uniqueElements.canFind(l[i]))\n\
    \        {\n            uniqueElements ~= l[i];\n        }\n    }\n    return\
    \ uniqueElements.sort();\n}", "{\n    return array(std.algorithm.uniq(l));\n}",
  "{\n    if (l.length == 0)\n        return new long[0];\n    long[] result = new\
    \ long[1];\n    result[0] = l[0];\n    foreach (elem; l[1..$])\n    {\n      \
    \  if (result.length == 0 || result[$-1] != elem)\n            result ~= elem;\n\
    \    }\n    return result;\n}", "{\n    long[] l2;", "{\n    uint[] counter =\
    \ [std.uni.sort(l)]\n    return [counter];\n}", "{\n  long[] r = new long[std.common.min(l.length,\
    \ std.common.max(1L, (long)l.length / 2L))];\n  long p = 0L;\n  const long n =\
    \ l.length;\n  long i = 0L;\n  for (; i < n; ++i)\n  {\n    for (long j = 0L;\
    \ j < p; ++j)\n    {\n      if (l[i] == r[j])\n      {\n        break;\n     \
    \ }\n    }\n    if (i != j)\n    {\n      continue;\n    }\n    r[p] = l[i];\n\
    \    ++p;\n  }\n  return r[0L..p];\n}", "    if (l.length == 0)\n    {\n     \
    \   return new long[0];\n    } \n    else \n    {\n        l.sort;\n        return\
    \ l.filter!((a, b) => a != b)();\n    }", "{\n    auto s = set(l);\n    l = immutable(long[])(s.byKey().map!(a\
    \ => a.key));\n    return l;\n}", "{\n    long[] temp = new long[l.length];\n\
    \    int length = 0;\n    for (int i = 0; i < l.length; i++) \n    {\n       \
    \ if (temp.indexOf(l[i]) == -1) \n        {\n            temp[length] = l[i];\n\
    \            length++;\n        }\n    }\n    temp.truncate(length);\n    return\
    \ std.algorithm.sort(temp);\n}", "{\n    long[] uniq = [] ;\n    foreach(item;\
    \ l)\n    {\n        if(!uniq.canFind(item))\n        {\n            uniq ~= item;\n\
    \        }\n    }\n    return uniq.sort();\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5,\
    \ 9, 123]\n    \n*/", "{\n    import std.algorithm.sorting;\n    return l.uniq.sort;\n\
    }\n/*\nProvide the number of unique elements in an array.\n    >>> uniqueNum([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    6L\n    \n*/\nlong uniqueNum(long[]\
    \ l) \n{\n    return unique(l).length;\n}\n/*\nCalculate the mean of an array.\n\
    \    >>> mean([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    20.444444444444443\n\
    \    \n*/\ndouble mean(long[] l) \n{\n    return l.sum / l.length;\n}\n/*\nCalculate\
    \ the median of an array.\n    >>> median([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    3.0\n    \n*/\ndouble median(long[] l) \n{\n    import std.algorithm.sorting;\n\
    \    double[] copy = l.dup;\n    copy.sort;\n    if (l.length % 2 == 0) {\n  \
    \      return (copy[l.length / 2 - 1] + copy[l.length / 2]) / 2;\n    }\n    else\
    \ {\n        return copy[l.length / 2];\n    }\n}\n/*\nCalculate the min of an\
    \ array.\n    >>> min([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    0L\n    \n\
    */\nlong min(long[] l) \n{\n    import std.algorithm.sorting;\n    return l.sort[0];\n\
    }\n/*\nCalculate the max of an array.\n    >>> max([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n    123L\n    \n*/\nlong max(long[] l) \n{\n    import std.algorithm.sorting;\n\
    \    return l.sort[l.length - 1];", "{\n    //std.algorithm.sort(l);\n    return\
    \ std.algorithm.uniq(l);\n}", "{\n    return [uniq(sort(l))];\n}", "{\n    long[]\
    \ out = sort(l);\n    return ret(out[0..1] ~ out[1..$].filter!(a => a != out[$-1]));\n\
    }", "{\n    return std.algorithm.sort.uniq(l);\n}", "{\n    inout(l);\n    l.sort;\n\
    \    return l.dedup;\n}\n \n/*\n  Return sorted unique elements in an array\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n*/", "{\n    long n = l.length;\n    long[] temp = new long[(int)n];\n\
    \    temp[0] = l[0];\n    long j = 0;\n    for (long i = 1; i < n; i++) \n   \
    \ {\n        if (l[(int)i] != temp[(int)j]) \n        {\n            j++;\n  \
    \          temp[(int)j] = l[(int)i];\n        }\n    }\n    return temp[0..(int)(j\
    \ + 1)];\n}\n/*\nRun one-way ANOVA\n    >>> ANOVA([[12,11,14,9,13,13], [11,10,13,12,14,15],\
    \ [12,14,10,11,12,13]])\n    (1.5555555555555556, 0.22264499790773298)\n    \n\
    */\nTuple!(double, double) ANOVA(long[][] data) \n{\n    long n = data.length;\n\
    \    long[] N = new long[n];\n    long[] y_bar = new long[n];\n    for (long i\
    \ = 0; i < n; i++) \n    {\n        N[(int)i] = data[(int)i].length;\n       \
    \ y_bar[(int)i] = 0;\n        for (long j = 0; j < N[(int)i]; j++) \n        {\n\
    \            y_bar[(int)i] += data[(int)i][(int)j];\n        }\n        y_bar[(int)i]\
    \ /= N[(int)i];\n    }\n    long y_bar_bar = 0;\n    long total = 0;\n    for\
    \ (long i = 0; i < n; i++) \n    {\n        y_bar_bar += N[(int)i] * y_bar[(int)i];\n\
    \        total += N[(int)i];\n    }\n    y_bar_bar /= total;\n    double SSbetween\
    \ = 0;\n    for (long i = 0; i < n; i++) \n    {\n        SSbetween +=", "{\n\
    \    long[] res;\n    foreach(e; algo.uniq(l))\n        res ~= e;\n    return\
    \ res;\n}", "{\n    long[] ret;\n    auto a = to!Array(ret);\n    auto b = to!Array(l);\n\
    \    a = sort(unique(b));\n    return ret;\n}\n/*\nReturn intersection of arrays.\n\
    \    >>> intersect([5L, 3L, 9L, 1L, 2L, 3L, 0L, 0L, 9L, 3L, 123L], [9L, 0L, 9L,\
    \ 2L, 4L, 7L, 123L, 0L, 5L, 4L, 9L])\n    [0L, 9L, 123L]\n*/\nlong[] intersect(long[]\
    \ l1, long[] l2)\n{\n    long[] ret;\n    auto a = to!Array(ret);\n    auto b\
    \ = to!Array(l1);\n    auto c = to!Array(l2);\n    a = intersect(sort(unique(b)),\
    \ sort(unique(c)));\n    return ret;\n}\n/*\n    Return sum of the elements in\
    \ array.\n    >>> sum([5L, 3L, 9L, 1L, 2L, 3L, 0L, 0L, 9L, 3L, 123L])\n    158L\n\
    */\nlong sum(long[] l)\n{\n    auto a = to!Array(l);\n    return reduce!\"a +\
    \ b\"(a);\n}\n/*\n    Return mean of the elements in array.\n    >>> mean([5L,\
    \ 3L, 9L, 1L, 2L, 3L, 0L, 0L, 9L, 3L, 123L])\n    14L\n*/\nlong mean(long[] l)\n\
    {\n    auto a = to!Array(l);\n    return sum(a) / a.length;\n}\n/*\n    Return\
    \ median of the elements in array.\n    >>> median([5L, 3L, 9L, 1L, 2L, 3L, 0L,\
    \ 0L, 9L, 3L, 123L])\n    3L\n*/\nlong median(long[] l)\n{\n    auto a = to!Array(l);\n\
    \    auto b = sort(a);\n    if (b.length % 2 == 0)\n    {\n        return (b",
  "{\n    int[] pos = std.algorithm.sort.sort!((a, b) => a > b)(l);\n    long[] res\
    \ = new long[l.length];\n    res[0] = l[pos[0]];\n    int count = 1;\n    foreach(i;\
    \ 1..l.length) \n    {\n        if(l[pos[i]] != l[pos[i-1]]) \n        {\n   \
    \         res[count] = l[pos[i]];\n            count++;\n        }\n    }\n  \
    \  return res[0..count];\n}\n/*\nReturn an array with unique elements from two\
    \ arrays\n    >>> unique([1L, 2L, 3L], [4L, 5L, 6L])\n    [1L, 2L, 3L, 4L, 5L,\
    \ 6L]\n    >>> unique([1L, 2L, 3L], [1L, 2L, 3L])\n    [1L, 2L, 3L]\n*/\nlong[]\
    \ unique(long[] a, long[] b) \n{\n    long[] res = new long[a.length + b.length];\n\
    \    foreach(i; 0..a.length) \n    {\n        res[i] = a[i];\n    }\n    foreach(i;\
    \ 0..b.length) \n    {\n        res[i + a.length] = b[i];\n    }\n    return unique(res);\n\
    }", "{\n    return std.algorithm.uniq(std.algorithm.sort(l));\n}", "{\n    auto\
    \ s = set!(ElementType!(l))(l);\n    return to!(long[])(s);\n}\n/*\nPrint a 2D-array\n\
    \    >>> auto g = grid(10L, 10L);\n    >>> printGrid(g);\n    00000\n    00000\n\
    \    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n\
    \    00000\n*/", "{\n    return [min(l), max(l)];\n}", "{\n    long[] sorted=sort(l);\n\
    \    return sort(uniq(sorted));\n}\n/*\nGet the sum of elements in an array\n\
    \    >>> sum([5L, 3L, 2L, 3L, 3L, 9L, 0L, 123L])\n    148L\n    \n*/\nlong sum(long[]\
    \ l) \n{\n    long result=0L;\n    foreach(i; l) \n    {\n        result+=i;\n\
    \    }\n    return result;\n}\n/*\nGet the max value of elements in an array\n\
    \    >>> max([5L, 3L, 2L, 3L, 3L, 9L, 0L, 123L])\n    123L\n    \n*/\nlong max(long[]\
    \ l) \n{\n    long result=l[0];\n    foreach(i; l) \n    {\n        if(i>result)\
    \ \n        {\n            result=i;\n        }\n    }\n    return result;\n}\n\
    /*\nGet the min value of elements in an array\n    >>> min([5L, 3L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    0L\n    \n*/\nlong min(long[] l) \n{\n    long result=l[0];\n\
    \    foreach(i; l) \n    {\n        if(i<result) \n        {\n            result=i;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn the product of all the elements\
    \ in an array\n    >>> prod([5L, 3L, 2L, 3L, 3L, 9L, 0L, 123L])\n    0L\n    \n\
    */\nlong prod(long[] l) \n{\n    long result=1L;\n    foreach(i; l) \n    {\n\
    \        result*=i;\n    }\n    return result;\n}\n/*\nReturn the number of elements\
    \ in an array\n    >>> count([5L, 3L, 2L, 3L, 3L, 9L, 0L, 123L])\n    8L\n   \
    \ \n*/\nlong count(long[] l) \n{\n    return l.length;", "{\n    long[] r;\n \
    \   foreach(w; l) \n    {\n        r ~= w;\n    }\n    r.sort;\n    return std.algorithm.uniq(r);\n\
    }", "{\n     /*\n     * D.Sheta\n     * 09/24/2018\n     * To find unique elements\
    \ in an array\n     */\n    long[] tmp = new long[0L];\n    bool found = false;\n\
    \    foreach(long v; l)\n    {\n        foreach(long vv; tmp)\n        {\n   \
    \         if(v == vv)\n            {\n                found = true;\n        \
    \        break;\n            }\n        }\n        if(!found)\n        {\n   \
    \         tmp ~= v;\n        }\n        found = false;\n    }\n    return tmp;\n\
    }", "{\n    return\n    //[\n    //    to!(long[])(unique(to!(int[])(l))),\n \
    \   //    to!(long[])(unique(to!(uint[])(l))),\n    //    to!(long[])(unique(to!(ulong[])(l)))\n\
    \    //];\n    to!(long[])(\n        unique(\n            chain(\n           \
    \     [\n                    to!(int[])(l),\n                    to!(uint[])(l),\n\
    \                    to!(ulong[])(l)\n                ]\n            )\n     \
    \   )\n    );\n}", "{\n    immutable dg = l.dup;\n    return dg.sort.uniq;\n}\n\
    /*\nReturn sorted unique elements in an array\n    >>> unique([0.6, 0.3, 0.6,\
    \ 0.2, 0.3, 0.3, 0.9, 0.0, 1.23])\n    [0.0, 0.2, 0.3, 0.6, 0.9, 1.23]\n    \n\
    */\nreal[] unique(real[] r) \n{\n    immutable dg = r.dup;\n    return dg.sort.uniq;\n\
    }\n// import std.algorithm;\n/*\nReturn the index of the requested element\nor\
    \ if the element is not found return -1.\n    >>> indexof([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L], 5L)\n    0\n    \n*/\nlong indexof(long[] l, long e) \n{\n\
    \    immutable dg = l.dup;\n    immutable r = dg.indexOf(e);\n    return r;\n\
    }\n/*\nReturn the index of the requested element\nor if the element is not found\
    \ return -1.\n    >>> indexof([0.6, 0.3, 0.6, 0.2, 0.3, 0.3, 0.9, 0.0, 1.23],\
    \ 0.2)\n    3\n    \n*/\nlong indexof(real[] r, real e) \n{\n    immutable dg\
    \ = r.dup;\n    immutable res = dg.indexOf(e);\n    return res;\n}\n/*\nReturn\
    \ the list of the indexes of the requested element\nor if the element is not found\
    \ return [].\n    >>> allindexes([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], 5L)\n\
    \    [0L, 2L]\n    \n*/\nlong[] allindexes(long[] l, long e) \n{\n    immutable\
    \ dg = l.dup;\n    immutable r = dg.indexOf(e);\n    if (r != -1) \n    {", "{\n\
    \    return array(newTreeSet(l).toArray);\n}\n/*\n \nReturn sorted unique elements\
    \ in an array\n    >>> unique([5., 3., 5., 2., 3., 3., 9., 0., 123.])\n    [0.0,\
    \ 2.0, 3.0, 5.0, 9.0, 123.0]\n    \n*/\ndouble[] unique(double[] l) \n{\n    return\
    \ array(newTreeSet(l).toArray);\n}\n/*\n \nReturn sorted unique elements in an\
    \ array\n    >>> unique([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"d\"])\n \
    \   [\"a\", \"b\", \"c\", \"d\"]\n    \n*/\nstring[] unique(string[] l) \n{\n\
    \    return array(newTreeSet(l).toArray);\n}\n/*\n \nReturn sorted unique elements\
    \ in an array\n    >>> unique([1L, 2L, 3L, \"a\", \"b\", \"c\", \"d\"])\n    [1L,\
    \ 2L, 3L, \"a\", \"b\", \"c\", \"d\"]\n    \n*/\nObject[] unique(Object[] l) \n\
    {\n    return array(newTreeSet(l).toArray);\n}\n/*\n \nReturn sorted unique elements\
    \ in an array\n    >>> unique([1, 2, 3, \"a\", \"b\", \"c\", \"d\"])\n    [1,\
    \ 2, 3, \"a\", \"b\", \"c\", \"d\"]\n    \n*/\nT[] unique(T)(T[] l) \n{\n    return\
    \ array(newTreeSet(l).toArray);\n}\n/*\n \nReturn the intersection of two arrays.\n\
    \    >>> intersect([1L, 2L, 3L, \"a\", \"b\", \"c\", \"d\"], [3L, 2L, 1L, \"d\"\
    , \"c\", \"b\", \"a\"])\n    [1L, 2L, 3L, \"a\", \"b\", \"c\", \"d\"]\n    \n\
    */\nObject[] intersect(Object[] a, Object[] b) \n{\n    auto intersection = newTreeSet(a);\n\
    \    intersection.retainAll(b);\n   ", "{\n    long[] ret = new long[0];\n   \
    \ foreach(v; l)\n    {\n        if(!v in ret)\n        {\n            ret ~= v;\n\
    \        }\n    }\n    ret.sort;\n    return ret;\n}\n/*\nReturn an array with\
    \ only the selected columns, in a new arrangement\n    >>> select([\"a\", \"b\"\
    , \"c\", \"d\"], [1, 2, 0])\n    [\"b\", \"c\", \"a\"]\n*/\nstring[] select(string[]\
    \ haystack, int[] desired_columns) \n{\n    string[] ret = new string[desired_columns.length];\n\
    \    foreach(v; desired_columns)\n    {\n        ret[v] = haystack[v];\n    }\n\
    \    return ret;\n}", "{\n    long[] r = std.range(l.length).map!(i => l[i]).array;\n\
    \    r = std.algorithm.sort(r);\n    return r.dup.joined.retro.array;\n}\n/*\n\
    \   Return the largest value in an array\n    >>> max([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    123L\n*/\nlong max(long[] l)\n{\n    return l.reduce!max;\n\
    }\n/*\n   Return the smallest value in an array\n    >>> min([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    0L\n*/\nlong min(long[] l)\n{\n    return l.reduce!min;\n\
    }\n/*\n   Return the sum of all values in an array\n    >>> sum([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    154L\n*/\nlong sum(long[] l)\n{\n    return l.reduce!((a,\
    \ b) => a + b);\n}\n/*\n   Return the average value in an array\n    >>> avg([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    17L\n*/\nlong avg(long[] l)\n{\n   \
    \ return sum(l) / l.length;\n}\n/*\n   Return the median value in an array\n \
    \   >>> median([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    3L\n*/\nlong median(long[]\
    \ l)\n{\n    long[] n = unique(l);\n    return n[(l.length / 2)];\n}\n/*\n   Return\
    \ the mode value in an array\n    >>> mode([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    3L\n*/\nlong mode(long[] l)\n{\n    long[] n = unique(l);\n    long m = std",
  "{\n    /*\n    l.sort\n    _.uniq\n    */\n    auto res = l.sort;\n    res = res.uniq;\n\
    \    return res;\n}\n \n \n/*\nReturn sorted unique elements in an array\n   \
    \ >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n\
    */", "{\n    int[] r = l.array();\n    return sort(r.unique).array();\n}", "{\n\
    \    return to!(long[])(distinct(l));\n}", "{\n    auto s = new std.set.HashSet!long();\n\
    \    auto r = new long[](0);\n    foreach(i; l) {\n        if(s.insert(i))\n \
    \           r ~= i;\n    }\n    return r;\n}\n/*\n    Returns the unique elements\
    \ of the given array.", "{\n    size_t length = l.length;\n    auto dgUnique =\
    \ new long[length];\n    dgUnique.length = length;\n    size_t j = 0L;\n    foreach(int\
    \ i, long l_i; l)\n    {\n        if(i == 0) {\n            dgUnique[0] = l_i;\n\
    \            j = 1L;\n        }\n        else {\n            bool add = true;\n\
    \            foreach(int k, long dgUnique_k; dgUnique[0 .. j])\n            {\n\
    \                if(l_i == dgUnique_k) {\n                    add = false;\n \
    \                   break;\n                }\n            }\n            if(add)\
    \ {\n                dgUnique[j] = l_i;\n                j = j + 1L;\n       \
    \     }\n        }\n    }\n    dgUnique.length = j;\n    return dgUnique;\n}\n\
    long[] unique(long[] l, int l_length) \n{\n    size_t length = l_length;\n   \
    \ auto dgUnique = new long[length];\n    dgUnique.length = length;\n    size_t\
    \ j = 0L;\n    foreach(int i, long l_i; l)\n    {\n        if(i == 0) {\n    \
    \        dgUnique[0] = l_i;\n            j = 1L;\n        }\n        else {\n\
    \            bool add = true;\n            foreach(int k, long dgUnique_k; dgUnique[0\
    \ .. j])\n            {\n                if(l_i == dgUnique_k) {\n           \
    \         add = false;\n                    break;\n                }\n      \
    \      }\n            if(add) {\n                dgUnique[j] = l_i;\n        \
    \        j = j + 1L;\n            }\n        }\n    }\n    dgUnique.length = j;\n\
    \    return dgUnique;\n}\nlong[] unique(ref long[] l) \n{\n    size_t length =\
    \ l.length;\n    auto dgUnique = new long[length];\n    dgUnique.length = length;\n\
    \    size_t j = 0L;\n", "{\n    auto m = newMap!(long, Nullable!long);\n    foreach(l1;\
    \ l) \n    {\n        m[l1] = 1;\n    }\n    long[] ret = new long[];\n    foreach(l1;\
    \ m.keys)\n    {\n        ret ~= l1;\n    }\n    sort(ret);\n    return ret;\n\
    }", "{\n  return (cast(long[])std.algorithm.sort.unique(l)).dup;\n}", "{\n   \
    \ long[] ret;\n    auto m = new HashMap!(typeof(l[0]), typeof(ret))();\n    foreach(a;\
    \ l)\n    {\n        if(!m.containsKey(a))\n        {\n            m[a] = a;\n\
    \        }\n    }\n    foreach(a; m.values)\n    {\n        ret ~= a;\n    }\n\
    \    return ret;\n}", "{\n    long[] r = [];\n    if(l.length==0) \n    {\n  \
    \      return r;\n    }\n    long head = l[0];\n    long[] tail = l[1..$];\n \
    \   for(long i = 0; i < tail.length; ++i) \n    {\n        if(head != tail[i])\
    \ \n        {\n            r ~= head;\n            head = tail[i];\n        }\n\
    \    }\n    r ~= head;\n    return r;\n}\n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n{\n    long[] r = [];\n\
    \    if(l.length==0) \n    {\n        return r;\n    }\n    long head = l[0];\n\
    \    long[] tail = l[1..$];\n    for(long i = 0; i < tail.length; ++i) \n    {\n\
    \        if(head != tail[i]) \n        {\n            r ~= head;\n           \
    \ head = tail[i];\n        }\n    }\n    r ~= head;\n    return r;\n}\n/*\nReturn\
    \ sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l) \n{\n    long[] r = [];\n    if(l.length==0) \n    {\n        return r;\n\
    \    }\n    long head = l[0];\n    long[] tail = l[1..$];\n    for(long i = 0;\
    \ i < tail.length; ++i) \n    {\n        if(head != tail[i]) \n        {\n   \
    \         r ~= head;\n            head = tail[i];\n        }\n    }\n    r", "{\n\
    \    if (l.length == 0) \n    {\n        return l;\n    }\n    auto result = [];\n\
    \    auto last_value = l[0];\n    result ~= last_value;\n    foreach (value; l[1\
    \ .. $]) \n    {\n        if (value != last_value) \n        {\n            result\
    \ ~= value;\n            last_value = value;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] res = sort(l);\n    res = array(res[0..0]);\n    foreach(idx,\
    \ value; res)\n    {\n        if(res[$-1] != value)\n            res ~= value;\n\
    \    }\n    return res;\n}\n ", "{\n  if (l.length == 0) \n  {\n    return l;\n\
    \  }", "{\n    return unique!q{a < b}(l);\n}", "{\n    import std.algorithm.sorting;\n\
    \    import std.algorithm.searching;\n    //auto x = l.sort().uniq;\n    auto\
    \ x = l.uniq;\n    return x;\n}\n ", "{\n    long[] result = [l[0]];\n    foreach(e;l)\
    \ \n    {\n        if (e != result[$-1]) \n        {\n            result ~= e;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9,\
    \ 123]\n    \n*/", "{\n\tstring[] str = cast(string[]) l;\n\treturn cast(long[])\
    \ std.algorithm.uniq(str).array;\n}", "{\n    return unique(sort(l));\n}", "{\n\
    \treturn to!(long[])(uniq(to!(ElementTypeTuple!(l))(l)));\n}", "{\n    long[long]\
    \ tmp = [l[0L]: 1L];\n    foreach (i; 1 .. l.length)\n    {\n        if (tmp.find(l[i])\
    \ is null) \n        {\n            tmp[l[i]] = 1L;\n        }\n    }\n    return\
    \ sort(keys(tmp));\n}", "{\n\tauto u = [];\n\tforeach(i;l)\n\t{\n\t\tif(u.canFind(i))\n\
    \t\t\tcontinue;\n\t\tu ~= i;\n\t}\n\treturn u;\n}", "{\n    return std.typecons.tuple(l).array.uniq.array;\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n*/", "in{\n  assert(l.length\
    \ > 0);\n}\nout(result)\n{\n  for(int i = 0; i < result.length; i++)\n    for(int\
    \ j = i + 1; j < result.length; j++)\n      assert(result[i] != result[j]);\n\
    \  assert(l.length <= result.length);\n}\n{\n  bool[] seen = new bool[l.length];\n\
    \  long[] result = new long[l.length];\n  long j = 0;\n  for(long i = 0; i < l.length;\
    \ i++)\n  {\n    if(!seen[i])\n    {\n      result[j] = l[i];\n      j = j + 1;\n\
    \      seen[i] = true;\n      foreach(k; 1 .. l.length)\n      {\n        if(l[i]\
    \ == l[i + k])\n        {\n          seen[i + k] = true;\n        }\n      }\n\
    \    }\n  }\n  return result[0 .. j];\n}", "{\n    long[] unique = new long[];\n\
    \    foreach(l_val; l) \n    {\n        if(l_val in unique)\n            continue;\n\
    \        unique ~= l_val;\n    }\n    unique.sort;\n    return unique;\n}", "{\n\
    \    long[] t = l[];\n    sort(t);\n    return (long[])t[0..uniq(t)];\n}\n \n\
    \ \n \n/*\nReturn the index of the first occurence of an element\n    >>> find([\"\
    foo\", \"bar\", \"baz\"], \"bar\")\n    1\n*/\nlong find(T)(T[] l, T e) \n{\n\
    \    long idx = 0;\n    foreach(elem; l) \n    {\n        if(elem == e) \n   \
    \     {\n            return idx;\n        }\n        idx++;\n    }\n    return\
    \ -1;\n}\n \n \n \n/*\nReturn the index of the first occurence of an element,\
    \ or -1 if not found\n    >>> indexOf([\"foo\", \"bar\", \"baz\"], \"bar\")\n\
    \    1\n*/\nlong indexOf(T)(T[] l, T e) \n{\n    return find(l, e);\n}\n \n \n\
    \ \n/*\nReturn the index of the last occurence of an element\n    >>> rfind([\"\
    foo\", \"bar\", \"baz\", \"bar\"], \"bar\")\n    3\n*/\nlong rfind(T)(T[] l, T\
    \ e) \n{\n    long idx = l.length;\n    foreach_reverse(elem; l) \n    {\n   \
    \     if(elem == e) \n        {\n            return idx;\n        }\n        idx--;\n\
    \    }\n    return -1;\n}\n \n \n \n/*\nReturn the index of the last occurence\
    \ of an element, or -1 if not found\n    >>> lastIndexOf([\"foo\", \"bar\", \"\
    baz\", \"bar\"], \"bar\")\n    3\n*/\nlong lastIndexOf(T)(T[] l, T e) \n{\n  \
    \  return rfind(l, e);\n}\n \n \n \n/*\nCount the number of occurences of an element\n\
    \    >>> count([\"foo\", \"bar\", \"foo\", \"bar\"], \"bar\")\n    2\n*/\nlong\
    \ count(T)(T[] l, T e) \n{", "{\n    long[] r;\n    foreach(ulong e; array(l))\
    \ \n    {\n        if(!e in r) \n        {\n            r ~= e;\n        }\n \
    \   }\n    r.sort;\n    return r;\n}", "{\n    // make an associative array\n\
    \    auto seen = new Appender!(long[])();\n    long[] result;\n    // sort array\n\
    \    l.sort;\n    foreach(i; l)\n    {\n        // if element is seen, skip\n\
    \        if(seen.arrayof.count(i) > 0)\n            continue;\n        // else,\
    \ append to result\n        seen.put(i);\n    }\n    // make the associative array\
    \ into an array\n    result = seen.data;\n    return result;\n}\n/*\n  Return\
    \ true if element found in array, false otherwise\n  >>> in_array(4L, [4L, 2L,\
    \ 3L, 12L])\n  true\n  >>> in_array(3L, [4L, 2L, 3L, 12L])\n  false\n*/", "{\n\
    \    return _unique(l);\n}\n/*\nReturn sorted unique elements in an array\n  \
    \  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n\
    */", "{\n    long[][] dupes = l.groupby!((d, i) => l[i]);\n    return dupes.map!(m\
    \ => m[0]).array;\n}", "    {\n        auto it = l.sort.uniq;\n        return\
    \ it.array;\n    }", "{\n    int size = l.length;\n    if (size == 0)\n    {\n\
    \        return new long[0];\n    }\n    else\n    {\n        long[] s = sort(l);\n\
    \        long[] result = new long[s.length];\n        result[0] = s[0];\n    \
    \    int i = 1;\n        foreach (num; s[1..$])\n        {\n            if (num\
    \ != result[i - 1])\n            {\n                result[i] = num;\n       \
    \         i++;\n            }\n        }\n        return result[0..i];\n    }\n\
    }", "{\n    long[] s = sort(l);\n    s = s.dup;\n    return uniq(s);\n}\n/*\n\
    Return sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(int[]\
    \ l) \n{\n    long[] s = sort(l);\n    s = s.dup;\n    return uniq(s);\n}\n/*\n\
    Return sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\ndouble[] unique(double[]\
    \ l) \n{\n    double[] s = sort(l);\n    s = s.dup;\n    return uniq(s);\n}\n\
    /*\n    Return an index of unique elements in an array.\n    \n    Parameters\n\
    \    ----------\n    s : array of float, int or str\n        Input array.\n  \
    \  return_index : bool, optional\n        If True, also return the indices of\
    \ s that result in the unique array.\n    return_inverse : bool, optional\n  \
    \      If True, also return the indices of the unique array that can be used\n\
    \        to reconstruct s.\n    return_counts : bool, optional\n        If True,\
    \ also return the number of times each unique value comes up\n        in s.\n\
    \    \n    Returns\n    -------\n    unique : array of float, int or str\n   \
    \     The sorted unique values.\n    unique_indices : array of ints, optional\n\
    \        The indices of the first occurrences of the unique values in the\n  \
    \      (flattened) original array. Only provided if `return_index` is True.\n\
    \    unique_inverse : array of ints, optional\n        The indices to reconstruct\
    \ the (flattened) original array from the\n        unique array. Only provided\
    \ if `return_inverse` is True.\n    unique_counts : array of ints, optional\n\
    \       ", "{\n    long[] result;\n    foreach(v; l) \n    {\n        if (result.count(v)\
    \ == 0) \n        {\n            result ~= v;\n        }\n    }\n    return sort(result);\n\
    }", "{\n    return _unique(l);\n}\nlong[] _unique(long[] l) \n{\n    double[]\
    \ r = std.array.array(l);\n    r = r.uniq;\n    l = std.array.array(r);\n    return\
    \ l;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\ndouble[]\
    \ unique(double[] l) \n{\n    return _unique(l);\n}\ndouble[] _unique(double[]\
    \ l) \n{\n    double[] r = std.array.array(l);\n    r = r.uniq;\n    l = std.array.array(r);\n\
    \    return l;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    @nogc pure nothrow unittest \n{\n    import std.conv;\n    assert(to!string(unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])) == \"[0L, 2L, 3L, 5L, 9L, 123L]\");\n}",
  "{\n    long[] ret = new long[l.length];\n    int idx = 0;\n    for (int i = 0;\
    \ i < l.length; i++) \n    {\n        if (idx == 0 || ret[idx - 1] != l[i]) \n\
    \        {\n            ret[idx] = l[i];\n            idx++;\n        }\n    }\n\
    \    return ret[0..idx];\n}\n/*", "{\n\tl.sort();\n\tlong[] res = l[0..1];\n\t\
    for (size_t i = 1; i < l.length; i++) \n\t{\n\t\tif (l[i] != l[i-1]) \n\t\t{\n\
    \t\t\tres ~= l[i];\n\t\t}\n\t}\n\treturn res;\n}", "{\n    long[] r = [];\n  \
    \  foreach(e; l)\n    {\n        if (e in r)\n            continue;\n        r\
    \ ~= e;\n    }\n    r.sort;\n    return r;\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5,\
    \ 9, 123]\n*/\nlong[] unique(int[] l) \n{\n    long[] r = [];\n    foreach(e;\
    \ l)\n    {\n        if (e in r)\n            continue;\n        r ~= e;\n   \
    \ }\n    r.sort;\n    return r;\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([5.0, 3.0, 5.0, 2.0, 3.0, 3.0, 9.0, 0.0, 123.0])\n    [0.0, 2.0,\
    \ 3.0, 5.0, 9.0, 123.0]\n*/\ndouble[] unique(double[] l) \n{\n    double[] r =\
    \ [];\n    foreach(e; l)\n    {\n        if (e in r)\n            continue;\n\
    \        r ~= e;\n    }\n    r.sort;\n    return r;\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([\"C\", \"CC\", \"CCC\", \"CC\", \"CC\"\
    ])\n    [\"C\", \"CC\", \"CCC\"]\n*/\nstring[] unique(string[] l) \n{\n    string[]\
    \ r = [];\n    foreach(e; l)\n    {\n        if (e in r)\n            continue;\n\
    \        r ~= e;\n    }\n    r.sort;\n    return r;\n}\n/*\nReturn union of two\
    \ arrays\n    >>> union([1, 2, 3], [2, 3, 4])\n    [1, 2, 3, 4]\n*/\nlong[] union(long[]\
    \ a, long[] b)\n{\n    long[] r = a;\n    foreach(e; b)\n    {\n        if (e\
    \ in r)\n           ", "{\n    return quicksort(uniq(l));\n}\n \n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n\
    {\n    return quicksort(uniq(l));\n}\n \n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n{\n    return quicksort(uniq(l));\n\
    }\n \n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l) \n{\n    return quicksort(uniq(l));\n}\n \n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n\
    {\n    return quicksort(uniq(l));\n}\n \n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n{\n    return quicksort(uniq(l));\n\
    }\n \n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3", "{\n\
    \    if (l.length == 0) return l;\n    l = sort(l);\n    long[] tmparr = [l[0]];\n\
    \    foreach (idx, val; l)\n    {\n        if (idx != 0)\n        {\n        \
    \    if (val != l[idx-1])\n            {\n                tmparr ~= val;\n   \
    \         }\n        }\n    }\n    return tmparr;\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0,\
    \ 2, 3, 5, 9, 123]\n*/", "{\n    auto  res = new long[0L];\n    for (auto i =\
    \ 0L; i < l.length; i++) \n    {\n        if (i != 0L && l[i] == l[i - 1L])\n\
    \        {\n            continue;\n        }\n        res ~= l[i];\n    }\n  \
    \  return res;\n}\n// unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n// [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\nauto set_union(auto a, auto b) \n{\n    auto concat =\
    \ a ~ b;\n    return unique(concat);\n}\n/*\nFind the intersection of unique elements\
    \ of two arrays\n    >>> set_intersection([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L],\
    \ [1L, 3L, 3L, 3L, 1L, 5L, 2L, 1L, 0L])\n    [2L, 3L, 5L, 0L]\n*/\nauto set_intersection(auto\
    \ a, auto b) \n{\n    a = unique(a);\n    b = unique(b);\n    auto res = new long[0L];\n\
    \    for (auto i = 0L; i < a.length; i++) \n    {\n        for (auto j = 0L; j\
    \ < b.length; j++) \n        {\n            if (a[i] == b[j])\n            {\n\
    \                res ~= a[i];\n            }\n        }\n    }\n    return res;\n\
    }\n// set_intersection([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], [1L, 3L, 3L, 3L,\
    \ 1L, 5L, 2L, 1L, 0L])\n// [2L, 3L, 5L, 0L]\n/*\nFind the difference of two arrays\n\
    \    >>> set_difference([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123", "{\n\treturn std.algorithm.uniq(l);\n\
    }\n/*\nReturn the rotation of the input list\n    >>> rotations([1, 2, 3, 4, 5,\
    \ 6])\n    [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 1], [3, 4, 5, 6, 1, 2], [4, 5,\
    \ 6, 1, 2, 3], [5, 6, 1, 2, 3, 4], [6, 1, 2, 3, 4, 5]]\n*/\nlong[][] rotations(long[]\
    \ l) \n{\n\tlong[][] rots = new long[l.length][];\n\tfor (size_t i = 0; i < l.length;\
    \ i++)\n\t{\n\t\trotate(l);\n\t\trots[i] = l.dup;\n\t}\n\treturn rots;\n}\n/*\n\
    Rotate the elements of an array in-place by one element.\n    >>> l = [1, 2, 3,\
    \ 4, 5, 6]\n    >>> rotate(l)\n    >>> l\n    [2, 3, 4, 5, 6, 1]\n*/", "{\n  \
    \  return sort(keys(amap(x => true, l)));\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5,\
    \ 9, 123]\n    \n*/", "    out (result) for (int i = 0; i < result.length; i++)\
    \ \n        result[i] <= result[i+1];\n{\n    // hash of unique elements in the\
    \ array\n    HashMap!(long, int) hash = new HashMap!(long, int)();\n    int counter\
    \ = 0;\n    foreach (elem; l) {\n        hash[elem] = counter++;\n    }\n    return\
    \ hash.keys;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l) {\n    // hash of unique elements in the array\n    HashMap!(long,\
    \ int) hash = new HashMap!(long, int)();\n    int counter = 0;\n    foreach (elem;\
    \ l) {\n        hash[elem] = counter++;\n    }\n    return hash.keys;\n}\n \n\
    /*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l) \n    out (result) for (int i = 0; i < result.length; i++) \n        result[i]\
    \ <= result[i+1];\n{\n    // hash of unique elements in the array\n    HashMap!(long,\
    \ int) hash = new HashMap!(long, int)();\n    int counter = 0;\n    foreach (elem;\
    \ l) {\n        hash[elem] = counter++;\n    }\n    return hash.keys;\n}\n \n\
    // unittest {\n//     long[] test = [5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L];\n\
    //     long[] result = unique(test);\n//     assert(result.length == 6);\n", "{\n\
    \  if (l.length == 0) return l;\n  ulong[] counts = new ulong[l.length];\n  const\
    \ lsize = l.length;\n  const counts_size = counts.length;\n  foreach (immutable\
    \ c; 0 .. counts_size) {\n    if (c == 0) {\n      counts[c] = 1;\n    } else\
    \ {\n      if (l[c] == l[c - 1]) {\n        counts[c] = counts[c - 1] + 1;\n \
    \     } else {\n        counts[c] = 1;\n      }\n    }\n  }\n  long[] unique;\n\
    \  immutable c = 0;\n  for (immutable i = 0; i < lsize; i += 1) {\n    if (i ==\
    \ 0) {\n      unique ~= l[i];\n    } else {\n      if (l[i] != l[i - 1]) {\n \
    \       unique ~= l[i];\n      }\n    }\n  }\n  return unique;\n}", "    if (l.length\
    \ == 0) return l;\n    else {\n        long[] ret = new long[l.length];\n    \
    \    ret[0] = l[0];\n        size_t n = 1;\n        for (size_t i = 1; i < l.length;\
    \ i++) \n            if (l[i] != l[i-1]) \n                ret[n++] = l[i];\n\
    \        ret.length = n;\n        return ret;\n    }\n    \n/*\nReturn the product\
    \ of all elements in an array\n    >>> product([1L, 2L, 3L, 4L])\n    24L\n*/\n\
    long product(long[] l) {\n    long ret = 1L;\n    foreach (item; l) \n       \
    \ ret *= item;\n    return ret;\n}\n/*\nReturn the maximum element in an array\n\
    \    >>> max([1L, 2L, 3L, 4L])\n    4L\n*/\nlong max(long[] l) {\n    long ret\
    \ = l[0];\n    foreach (item; l) \n        ret = max(ret, item);\n    return ret;\n\
    }\n/*\nReturn the minimum element in an array\n    >>> min([1L, 2L, 3L, 4L])\n\
    \    1L\n*/\nlong min(long[] l) {\n    long ret = l[0];\n    foreach (item; l)\
    \ \n        ret = min(ret, item);\n    return ret;\n}\n/*\nReturn the sum of all\
    \ elements in an array\n    >>> sum([1L, 2L, 3L, 4L])\n    10L\n*/\nlong sum(long[]\
    \ l) {\n    long ret = 0L;\n    foreach (item; l) \n        ret += item;\n   \
    \ return ret;\n}", "{\n    size_t length = l.length;\n    long[] output = [];\n\
    \    foreach(key, val; l)\n    {\n        size_t x = 0;\n        foreach(k, v;\
    \ output)\n        {\n            if(v == val)\n            {\n              \
    \  x++;\n            }\n        }\n        if(x == 0)\n        {\n           \
    \ output ~= val;\n        }\n    }\n    output.sort;\n    return output;\n}",
  "{\n    long[] l2 = l.dup;\n    l2.sort;\n    long[] output;\n    foreach(e; l2.unique)\n\
    \    {\n        output ~= e;\n    }\n    return output;\n}", "{\n    long[] ret;\n\
    \    ret.put(ret.length++, l[0]);\n    foreach(idx, elem; l)\n    {\n        long\
    \ res = binarySearch(ret, elem);\n        if(res < 0)\n        {\n           \
    \ ret.put(ret.length++, elem);\n        }\n    }\n    ret.sort();\n    return\
    \ ret;\n}", "{\n     long[] lu = std.algorithm.set(l).array;\n     lu.sort();\n\
    \     return lu;\n}", "{\n    int[] p = sort(l);\n    //printf(\"%s\\n\",p);\n\
    \    int num_p = p.length;\n    int num_n = 0;\n    for (int i = 0; i < num_p;\
    \ i++){\n        if (i == 0){\n            num_n = num_n + 1;\n        }\n   \
    \     else if (p[i] != p[i-1]){\n            num_n = num_n + 1;\n        }\n \
    \   }\n    //printf(\"num_n = %s\\n\",num_n);\n    long[] n = new long[num_n];\n\
    \    //printf(\"num_n = %s\\n\",n);\n    n[0] = p[0];\n    int j = 1;\n    for\
    \ (int i = 1; i < num_p; i++){\n        if (p[i] != p[i-1]){\n            n[j]\
    \ = p[i];\n            j = j + 1;\n        }\n    }\n    return n;\n}", "{\n \
    \   long[string] present;\n    foreach(l2; l)\n        present[l2] = 1;\n    return\
    \ present.keys.sort;\n}", "{\n    alias long[] ar = l; \n    auto ar_result =\
    \ ar.array;\n    auto ar_end = ar.array + ar.length;\n    auto result = ar_result;\n\
    \    foreach(ar_element; ar)\n    {\n        if (ar_result == ar_end) \n     \
    \   {\n            return ar_result.array;\n        }\n        if (ar_element\
    \ != ar_result[0]) \n        {\n            ar_result[1] = ar_element;\n     \
    \       ar_result++;\n        }\n    }\n    return ar_result.array;\n}\nunittest\n\
    {\n    assert (unique([]) == []);\n    assert (unique([1L, 2L, 3L, 4L, 5L]) ==\
    \ [1L, 2L, 3L, 4L, 5L]);\n    assert (unique([1L, 1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 2L, 3L, 4L, 5L]);\n    assert (unique([1L, 2L, 2L, 3L, 4L, 5L]) == [1L, 2L,\
    \ 3L, 4L, 5L]);\n    assert (unique([1L, 2L, 3L, 3L, 4L, 5L]) == [1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert (unique([1L, 2L, 3L, 4L, 4L, 5L]) == [1L, 2L, 3L, 4L,\
    \ 5L]);\n    assert (unique([1L, 2L, 3L, 4L, 5L, 5L]) == [1L, 2L, 3L, 4L, 5L]);\n\
    \    assert (unique([1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L, 5L, 5L]) == [1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert (unique([1L, 2L, 3L, 4L, 5L, 1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 2L, 3L, 4L, 5L]);\n    assert (", "{\n    return l.uniq;\n}", "{\n    size_t\
    \ n = l.length;\n    long[] res = new long[n];\n    long[] ind = new long[n];\n\
    \    size_t[] idx = new size_t[n];\n    size_t j=0;\n    size_t ai=0;\n    for\
    \ (size_t i=0; i<n; i++)\n    {\n        if (i==0 || l[i]!=l[i-1])\n        {\n\
    \            res[j] = l[i];\n            ind[j] = ai;\n            idx[j] = i;\n\
    \            j++;\n        }\n        ai++;\n    }\n    return res[0..j];\n}",
  "{\n    return sort(set(l));\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([5UL, 3UL, 5UL, 2UL, 3UL, 3UL, 9UL, 0UL, 123UL])\n    [0UL, 2UL,\
    \ 3UL, 5UL, 9UL, 123UL]\n    \n*/\nulong[] unique(ulong[] l) \n{\n    return sort(set(l));\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5.5, 3.5, 5.5,\
    \ 2.5, 3.5, 3.5, 9.5, 0.5, 123.5])\n    [0.5, 2.5, 3.5, 5.5, 9.5, 123.5]\n   \
    \ \n*/\ndouble[] unique(double[] l) \n{\n    return sort(set(l));\n}\n/*\nReturn\
    \ sorted unique elements in an array\n    >>> unique([5f, 3f, 5f, 2f, 3f, 3f,\
    \ 9f, 0f, 123f])\n    [0f, 2f, 3f, 5f, 9f, 123f]\n    \n*/\nfloat[] unique(float[]\
    \ l) \n{\n    return sort(set(l));\n}\n/*\nReturn sorted unique elements in an\
    \ array\n    >>> unique([\"aaa\", \"bbb\", \"aaa\", \"aaa\", \"ccc\", \"bbb\"\
    , \"ccc\", \"ddd\"])\n    [\"aaa\", \"bbb\", \"ccc\", \"ddd\"]\n    \n*/\nstring[]\
    \ unique(string[] l) \n{\n    return sort(set(l));\n}\n/*", "{\n    auto r = sort(l);\n\
    \    return r[0..1] ~= r[1..$];\n}", "{\n\tl = sort(l);\n\tlong[] u = new long[0];\n\
    \tforeach(long i; l)\n\t{\n\t\tif(count(l, i) == 1)\n\t\t{\n\t\t\tu ~= i;\n\t\t\
    }\n\t}\n\treturn u;\n}", "{\n\tuint i;\n\tint j;\n\tlong[] tmp = new long[l.length];\n\
    \tuint a = 0;\n\tforeach(i,k; l) \n\t{\n\t\tif(i == 0)\n\t\t{\n\t\t\ttmp[a] =\
    \ k;\n\t\t\ta++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach(j,v; tmp)\n\t\t\t{\n\t\
    \t\t\tif(v == k) break;\n\t\t\t\tif(j == (tmp.length - 1)) \n\t\t\t\t{\n\t\t\t\
    \t\ttmp[a] = k;\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn tmp[0..a];\n\
    }", "{\n    if(l.length == 0)\n        return l;\n    immutable Type t = typeof(l[0]);\n\
    \    auto r = initSortedArray!(Type)();\n    long[] res = cast(long[])r;\n   \
    \ res.length = 1;\n    res[0] = l[0];\n    int k = 1;\n    for(int i = 1; i <\
    \ l.length; i++)\n    {\n        if(l[i] != res[k-1])\n        {\n           \
    \ res.length = k+1;\n            res[k] = l[i];\n            k++;\n        }\n\
    \    }\n    return res;\n}", "{\n\tlong[] res = [];\n\tforeach(a;l)\n\t{\n\t\t\
    if(a in res) continue;\n\t\tres ~= a;\n\t}\n\tres.sort;\n\treturn res;\n}", "{\n\
    \    int[] counts = new int[max(l) + 1];\n    for (int i = 0; i < l.length; i++)\n\
    \        counts[l[i]]++;\n    \n    int[] p = array(0L, length=0);\n    foreach\
    \ (i; array(0L, length=0))\n        if (counts[i] > 0)\n            p ~= i;\n\
    \    \n    return p;\n}", "{\n    return std.algorithm.set(l).array;\n}\n/*\n\
    Return sorted unique elements in an array\n    >>> unique([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n*/", "{\n    long[] s;\n    foreach(x;\
    \ l)\n    {\n        auto t = binarySearch(s, x);\n        if(t == 0)\n      \
    \  {\n            s ~= x;\n        }\n    }\n    std.algorithm.sort(s);\n    return\
    \ s;\n}\n \n/*\nReturn sorted unique elements in an array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(string[] l) \n{\n    long[] s;\n    foreach(x; l)\n    {\n     \
    \   auto t = binarySearch(s, x);\n        if(t == 0)\n        {\n            s\
    \ ~= x;\n        }\n    }\n    std.algorithm.sort(s);\n    return s;\n}\n \n/*\n\
    Return cumulative sum of elements in an array\n    >>> cumsum([3L, 7L, 6L, 5L,\
    \ 2L, 8L, 4L, 7L, 5L, 1L])\n    [3L, 10L, 16L, 21L, 23L, 31L, 35L, 42L, 47L, 48L]\n\
    */\nlong[] cumsum(long[] l) \n{\n    long[] s;\n    long v = 0;\n    foreach(x;\
    \ l)\n    {\n        v += x;\n        s ~= v;\n    }\n    return s;\n}\n \n/*\n\
    Return the input array with all elements multiplied by factor\n    >>> multiply([3L,\
    \ 7L, 6L, 5L, 2L, 8L, 4L, 7L, 5L, 1L], 10L)\n    [30L, 70L, 60L, 50L, 20L, 80L,\
    \ 40L, 70L, 50L, 10L]\n*/\nlong[] multiply(long[] l, long factor) \n{\n    long[]\
    \ s;\n    foreach(x; l)\n    {\n        s ~= x * factor;\n    }\n    return s;",
  "{\n    if (l.length == 0) return l;\n    l.sort;\n    long[] result = [l[0]];\n\
    \    foreach (idx, elem; l) {\n        if (elem != result[$-1]) {\n          \
    \  result ~= elem;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\n/*\nReturn sorted unique elements in an array\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l) \n{\n    if (l.length == 0) return l;\n   \
    \ l.sort;\n    long[] result = [l[0]];\n    foreach (idx, elem; l) {\n       \
    \ if (elem != result[$-1]) {\n            result ~= elem;\n        }\n    }\n\
    \    return result;\n}\n/*\nReturn sorted unique elements in an array\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[]", "{\n    long[] h = new long[l.length];\n    long[] b = new\
    \ long[l.length];\n    long[] temp = new long[l.length];\n    int h_index = 0;\n\
    \    int b_index = 0;\n    for (int i = 0; i < l.length; i++)\n    {\n       \
    \ if (h_index == 0)\n        {\n            h[h_index] = l[i];\n            h_index\
    \ += 1;\n        }\n        else\n        {\n            for (int j = 0; j < h_index;\
    \ j++)\n            {\n                if (l[i] == h[j])\n                {\n\
    \                    b[b_index] = l[i];\n                    b_index += 1;\n \
    \                   break;\n                }\n                else if (j == h_index\
    \ - 1)\n                {\n                    h[h_index] = l[i];\n          \
    \          h_index += 1;\n                }\n            }\n        }\n    }\n\
    \    sort(h);\n    int temp_index = 0;\n    for (int k = 0; k < l.length; k++)\n\
    \    {\n        if (k < h_index)\n        {\n            temp[temp_index] = h[k];\n\
    \            temp_index += 1;\n        }\n        else\n        {\n          \
    \  break;\n        }\n    }\n    return temp;\n}", "{\n    int last_count = 0;\n\
    \    int l_len = l.length;\n    long[] ret;\n    foreach(i;0..l_len) \n    {\n\
    \        foreach(j;0..l_len) \n        {\n            if(i == j) \n          \
    \  {\n                continue;\n            }\n            if(l[i] == l[j]) \n\
    \            {\n                last_count++;\n            }\n        }\n    }\n\
    \    //writeln(last_count);\n    ret = new long[l_len - last_count];\n    foreach(i;0..l_len)\
    \ \n    {\n        if(i == 0) \n        {\n            ret[0] = l[0];\n      \
    \      continue;\n        }\n        foreach(j;0..ret.length) \n        {\n  \
    \          if(l[i] == ret[j]) \n            {\n                break;\n      \
    \      }\n            if(j == ret.length - 1) \n            {\n              \
    \  ret[j + 1] = l[i];\n            }\n        }\n    }\n    return ret;\n}\n/*\n\
    Return sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l) \n{\n    int last_count = 0;\n    int l_len = l.length;\n    long[] ret;\n\
    \    foreach(i;0..l_len) \n    {\n        foreach(j;0..l_len) \n        {\n  \
    \          if(i == j) \n            {\n                continue;\n           \
    \ }\n            if(l[i] == l[j]) \n            {\n                last_count++;\n\
    \            }\n        }\n    }\n    //writeln(last_count);\n    ret = new long[l_len\
    \ - last_count];\n    foreach(i;0..l_len) \n    {\n        if(i == 0) ", "{\n\
    \    long max = max(l);\n    long[] count = new long[max+1];\n    foreach(i; l)\
    \ count[i]++;\n    return array(filter!(x => x[1] != 0L)(zip(count,iota(max+1))));\n\
    }\nunittest\n{\n    writeln(unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L]));\n\
    }", "{\n\tlong[] u = new long[];\n\tfor (long n; l.popFront(n))\n\t{\n\t\tif (u.indexOf(n)\
    \ == -1)\n\t\t\tu ~= n;\n\t}\n\tu.sort();\n\treturn u;\n}\nlong[] unique(long[]\
    \ l)\n{\n\tl.sort();\n\treturn l.dup.retain(n => l.indexOf(n) == l.indexOfBack(n));\n\
    }", "{\n    long[] result;\n    foreach(n; l)\n    {\n\tauto d = n in result;\n\
    \tif(!d)\n\t{\n\t    result ~= n;\n\t}\n    }\n    return result;\n}", "{\n  \
    \  import std.algorithm.comparison : equal;\n    long[] ret;\n    foreach( x;l)\n\
    \    {\n       if(!ret.equal!(a => a == x) (x))\n           ret ~= x;\n    }\n\
    \    ret.sort;\n    return ret;\n}\n \n \n \n \n/*\n    Return sorted unique elements\
    \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n*/", "{\n    long[] uniq = new long[0L];\n    foreach\
    \ (i; l)\n    {\n        if (i in uniq)\n        {\n            continue;\n  \
    \      }\n        uniq ~= i;\n    }\n    uniq.sort();\n    return uniq;\n}", "{\n\
    \    long n = l.length;\n    long[] ret = new long[];\n    if (n == 0) \n    {\n\
    \        return ret;\n    }\n    std.algorithm.sort(l);\n    ret ~= l[0];\n  \
    \  for (long i = 1; i < n; i++) \n    {\n        if (l[i] != l[i - 1]) \n    \
    \    {\n            ret ~= l[i];\n        }\n    }\n    return ret;\n}\n/*\nRound\
    \ a float to number of decimals.\n    >>> round_float(1.234, 1)\n    1.2\n   \
    \ \n*/\ndouble round_float(double x, long decimals) \n{\n    return floor(x *\
    \ pow(10.0, decimals) + 0.5) / pow(10.0, decimals);\n}\n/*\nReturns the mean value\
    \ of an array of numbers.\n    >>> mean([1.0, 2.0, 3.0])\n    2.0\n    >>> mean([1.0,\
    \ 2.0, 3.0, 4.0])\n    2.5\n*/\ndouble mean(double[] l) \n{\n    double sum =\
    \ 0.0;\n    for (double x = 0; x < l.length; x++) \n    {\n        sum += l[x];\n\
    \    }\n    return sum / l.length;\n}\n/*\nReturns the median value of an array\
    \ of numbers.\n    >>> median([1.0, 2.0, 3.0])\n    2.0\n    >>> median([1.0,\
    \ 2.0, 3.0, 4.0])\n    2.5\n*/\ndouble median(double[] l) \n{\n    double[] r\
    \ = l[0 .. $].dup;\n    std.algorithm.sort(r);\n    return r[cast(long)(l.length\
    \ / 2)];\n}\n/*\nReturns the median value of an array of numbers.\n    >>> mode([1,\
    \ 2, 3, 3, 3, 5])\n    3\n*/\nlong mode(long[] l) \n{\n    long n = l.length;\n\
    \    if (n", "{\n\tlong[][] temp = sort(l);\n\tlong[] output = new long[temp.length];\n\
    \tforeach(i, v; temp)\n\t\toutput[i] = v[0];\n\treturn output;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
