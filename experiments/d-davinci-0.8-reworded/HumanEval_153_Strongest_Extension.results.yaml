name: HumanEval_153_Strongest_Extension
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest)\n        {\n            strongest\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbkd9m9nl.d(31): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmpbkd9m9nl.d(33): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbkd9m9nl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    double strength\
    \ = -1.0;\n    foreach(string s; extensions) {\n        int caps = 0;\n      \
    \  int sms = 0;\n        foreach(char c; s) {\n            if(c >= 'A' && c <=\
    \ 'Z')\n                caps++;\n            else if(c >= 'a' && c <= 'z')\n \
    \               sms++;\n        }\n        double cur_strength = double(caps)/double(sms);\n\
    \        if(cur_strength > strength) {\n            strength = cur_strength;\n\
    \            strongest = s;\n        }\n    }\n    return class_name~\".\"~strongest;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpoxld3gux.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429225]\\n??:? void tmpoxld3gux.__unittest_L43_C1()\
    \ [0x427d85]\\n??:? void tmpoxld3gux.__modtest() [0x42848c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42daff]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428f7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9ad]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa3c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a939]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428f55]\\n??:? runModuleUnitTests [0x42d8d5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429674]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295fb]\\n??:? _d_run_main [0x429566]\\n??:? main [0x42849f]\\\
    n??:? __libc_start_main [0xf172e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = null;\n    float\
    \ highest_strength = 0;\n    float strength = 0;\n    foreach(string extension;\
    \ extensions)\n    {\n        strength = 0;\n        float CAP = 0;\n        float\
    \ SM = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper())\n\
    \            {\n                CAP++;\n            }\n            else\n    \
    \        {\n                SM++;\n            }\n        }\n        strength\
    \ = CAP - SM;\n        if(strength > highest_strength)\n        {\n          \
    \  highest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return (class_name ~ \".\" ~ strongest_extension);\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0ncf2ytu.d(34): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ncf2ytu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    if (extensions.length == 0)\n        return class_name;\n\
    \    ulong i = 0;\n    double str = 0;\n    double temp = 0;\n    foreach (ext;\
    \ extensions)\n    {\n        temp = 0;\n        foreach (t; ext)\n        {\n\
    \            if (t.isUpper)\n                temp++;\n            else\n     \
    \           temp--;\n        }\n        if (temp > str)\n        {\n         \
    \   str = temp;\n            i = extensions.indexOf(ext);\n        }\n    }\n\
    \    return class_name ~ \".\" ~ extensions[i];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdin4k70o.d(34): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmpdin4k70o.d(42): Error: no property `indexOf` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdin4k70o.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return (class_name ~ \".\" ~ extensions[0]);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpev6kfi9q.d(30): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290cd]\\n??:? void tmpev6kfi9q.__unittest_L26_C1()\
    \ [0x427c31]\\n??:? void tmpev6kfi9q.__modtest() [0x428338]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8c9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a958]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a855]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dfd]\\n??:? runModuleUnitTests [0x42d7f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429590]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429517]\\n??:? _d_run_main [0x429482]\\n??:? main [0x42834b]\\\
    n??:? __libc_start_main [0x47c47554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float maxStrength = 0.0f;\n    int maxStrengthIndex\
    \ = 0;\n    float currentStrength = 0.0f;\n    int lowerCaseAmount = 0;\n    int\
    \ upperCaseAmount = 0;\n    foreach(index, extension; extensions)\n    {\n   \
    \     foreach(character; extension)\n        {\n            if(character.isUpper)\n\
    \            {\n                upperCaseAmount++;\n            }\n          \
    \  else\n            {\n                lowerCaseAmount++;\n            }\n  \
    \      }\n        currentStrength = (upperCaseAmount / (float)lowerCaseAmount);\n\
    \        if(currentStrength > maxStrength)\n        {\n            maxStrength\
    \ = currentStrength;\n            maxStrengthIndex = index;\n        }\n     \
    \   lowerCaseAmount = 0;\n        upperCaseAmount = 0;\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[maxStrengthIndex];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz4djyh_f.d(42): Error: C style cast illegal, use `cast(float)lowerCaseAmount`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz4djyh_f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //TODO: Add code here\n    int current_max_strength\
    \ = -1;\n    string current_max_extension = \"\";\n    foreach(string ext; extensions)\n\
    \    {\n        int new_strength = 0;\n        foreach(char c; ext)\n        {\n\
    \            if(isupper(c))\n                new_strength++;\n            else\
    \ if(islower(c))\n                new_strength--;\n        }\n        if(new_strength\
    \ > current_max_strength)\n        {\n            current_max_strength = new_strength;\n\
    \            current_max_extension = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ current_max_extension;\n}\n/*\n    You are given an integer array\
    \ which represents the height of a histogram,\n    where the width of each bar\
    \ is 1. For example, if the array is [2, 3, 1, 2, 4],\n    then here is the histogram\
    \ that it represents:\n    *\n    * *\n    * *\n    * * *\n    * * *\n    Write\
    \ a function that takes in such an array and return the size of the largest\n\
    \    rectangle that can be made out of the histogram. For the histogram above,\n\
    \    the largest rectangle would be the 4x3 rectangle with the top-left corner\
    \ at (1, 2).\n    If the array is [2, 3, 1, 2, 4, 3], then here is the histogram\
    \ that it represents:\n    *\n    * *\n    * *\n    * * *\n    * * *\n    * *\
    \ *\n    The largest rectangle would be the 3x2 rectangle with the top-left corner\
    \ at (2, 3).\n    If the array is [5, 4, 3, 2, 1], then here is the histogram\
    \ that it represents:\n    * * * * *\n    * * * * *\n    * * * * *\n    * * *\
    \ * *\n    * * * * *\n    The largest rectangle would be the 5x1 rectangle with\
    \ the top-left corner at (0, 0).\n    If the array is [5, 4, 3, 2, 1, 6], then\
    \ here is the histogram that it represents:\n    * * *\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp433fht49.d(45): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp433fht49.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    uint max = 0;\n    foreach(ref string s; extensions)\n\
    \    {\n        uint count = 0;\n        foreach(c; s)\n        {\n          \
    \  if(isUpper(c))\n                count++;\n        }\n        if(count > max)\n\
    \            max = count;\n    }\n    return class_name ~ \".\" ~ extensions[max];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe0rqc9vj.d(30): Error: undefined identifier `isUpper`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe0rqc9vj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n     int strength = -1;\n     int uppercase = 0;\n\
    \     int lowercase = 0;\n     string strongest_extension = \"\";\n     foreach(string\
    \ s; extensions)\n     {\n         foreach(char c; s)\n         {\n          \
    \   if(c.isUpper)\n             {\n                 uppercase++;\n           \
    \  }\n             else\n             {\n                 lowercase++;\n     \
    \        }\n         }\n         if(uppercase - lowercase > strength)\n      \
    \   {\n             strength = uppercase - lowercase;\n             strongest_extension\
    \ = s;\n         }\n         uppercase = 0;\n         lowercase = 0;\n     }\n\
    \     return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk0cuubsw.d(32): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk0cuubsw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // 1. Take string class_name and string[] extensions\n\
    \    // 2. Loop through extensions and calculate strength (total_upper - total_lower)\n\
    \    // 3. Return \"class_name.extension_with_highest_strength\"\n    //\n   \
    \ //  loop-extensions -> get-total-upper -> get-total-lower -> calculate-strength\
    \ ->\n    //  check-if-highest -> return-string\n    //  \n    //  loop-extensions\
    \ -> get-total-upper -> get-total-lower -> calculate-strength ->\n    //  check-if-highest\
    \ -> return-string\n    //  \n    //  loop-extensions -> get-total-upper -> get-total-lower\
    \ -> calculate-strength ->\n    //  check-if-highest -> return-string\n    //\
    \  \n    //  loop-extensions -> get-total-upper -> get-total-lower -> calculate-strength\
    \ ->\n    //  check-if-highest -> return-string\n    //  \n    //  return \"class_name.extension_with_highest_strength\"\
    \n    //  \n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n \
    \   //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy6nvqy1k.d(130): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy6nvqy1k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\t// your code goes here\n\tint c_count = 0;\n\tint\
    \ l_count = 0;\n\tfloat max_strength = -100;\n\tstring strongest_extension = \"\
    \";\n\tforeach(string extension; extensions)\n\t{\n\t\tforeach(char c; extension)\n\
    \t\t{\n\t\t\tif(isupper(c)) c_count++;\n\t\t\telse if(islower(c)) l_count++;\n\
    \t\t}\n\t\tfloat strength = (float)c_count - (float)l_count;\n\t\tif(strength\
    \ > max_strength)\n\t\t{\n\t\t\tmax_strength = strength;\n\t\t\tstrongest_extension\
    \ = extension;\n\t\t}\n\t\tc_count = 0;\n\t\tl_count = 0;\n\t}\n\treturn class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpepqgb6yl.d(36): Error: C style cast illegal, use `cast(float)c_count`\\\
    n/tmp/tmpepqgb6yl.d(36): Error: C style cast illegal, use `cast(float)l_count`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpepqgb6yl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.typecons;\n    // sort the array in\
    \ order\n    sort(extensions);\n    int[] strengths = new int[extensions.length];\n\
    \    for (int i = 0; i < extensions.length; i++) {\n        int cap_count = 0;\n\
    \        int small_count = 0;\n        for (int j = 0; j < extensions[i].length;\
    \ j++) {\n            char c = extensions[i][j];\n            if (c.isUpper) {\n\
    \                cap_count++;\n            } else {\n                small_count++;\n\
    \            }\n        }\n        strengths[i] = cap_count - small_count;\n \
    \   }\n    int best_strength = strengths[0];\n    int best_index = 0;\n    for\
    \ (int i = 1; i < strengths.length; i++) {\n        if (strengths[i] > best_strength)\
    \ {\n            best_strength = strengths[i];\n            best_index = i;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ extensions[best_index];\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgrsquuz1.d(26): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpgrsquuz1.d(33): Error: no property `isUpper` for\
    \ type `char`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgrsquuz1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = -9;\n    string Max = \"\";\n    foreach(string\
    \ val; extensions)\n    {\n        int up = 0;\n        int low = 0;\n       \
    \ foreach(char c; val)\n        {\n            if(c.isUpper)\n               \
    \ up++;\n            else\n                low++;\n        }\n        if(up -\
    \ low > max)\n        {\n            max = up - low;\n            Max = val;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ Max;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1ddki68x.d(32): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1ddki68x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    if (extensions.length == 0)\n        return class_name;\n\
    \    string greatest = extensions[0];\n    int greatest_strength = 0;\n    foreach\
    \ (string extension; extensions)\n    {\n        int strength = 0;\n        foreach\
    \ (char c; extension)\n        {\n            if (isUpper(c))\n              \
    \  strength++;\n            else if (isLower(c))\n                strength--;\n\
    \        }\n        if (strength > greatest_strength)\n        {\n           \
    \ greatest_strength = strength;\n            greatest = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ greatest;\n}\n/*\nA square matrix of integers\
    \ is given as input. Your task is to determine\nif the matrix is magic square.\
    \ You must follow the definition of\nmagic square which is:\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp41tzrc9j.d(46): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp41tzrc9j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct ExtensionStrength\n    {\n        size_t\
    \ index;\n        float strength;\n        bool operator<(ExtensionStrength other)\
    \ const\n        {\n            if (this.strength != other.strength)\n       \
    \         return this.strength < other.strength;\n            return this.index\
    \ < other.index;\n        }\n    }\n    auto strengths = extensions.map!(ext =>\
    \ {\n        int sm = 0;\n        int cap = 0;\n        foreach (immutable char\
    \ c; ext)\n        {\n            if (isUpper(c))\n                cap++;\n  \
    \          else\n                sm++;\n        }\n        return ExtensionStrength(ext.indexOf,\
    \ cast(float)cap / (sm+1));\n    });\n    auto strongest = strengths.max;\n  \
    \  return class_name ~ \".\" ~ extensions[strongest.index];\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpima8k_bo.d(28): Error: semicolon expected, not `<`\\n/tmp/tmpima8k_bo.d(28):\
    \ Error: declaration expected, not `<`\\n/tmp/tmpima8k_bo.d(32): Error: declaration\
    \ expected, not `return`\\n/tmp/tmpima8k_bo.d(48): Error: declaration expected,\
    \ not `return`\\n/tmp/tmpima8k_bo.d(49): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpima8k_bo.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = 0;\n    string strongest_name = extensions[0];\n\
    \    foreach(string e; extensions)\n    {\n        int curr = countUp(e) - countDown(e);\n\
    \        if(curr > max)\n        {\n            max = curr;\n            strongest_name\
    \ = e;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_name;\n}\n\
    private int countUp(string name)\n{\n    int count = 0;\n    foreach(char c; name)\n\
    \    {\n        if(c.isUpper)\n            count++;\n    }\n    return count;\n\
    }\nprivate int countDown(string name)\n{\n    int count = 0;\n    foreach(char\
    \ c; name)\n    {\n        if(c.isLower)\n            count++;\n    }\n    return\
    \ count;\n}\n/*\n    Write a function that takes a number and returns all of its\
    \ prime factors.\n    The result should be a tuple of numbers arranged from smallest\
    \ to largest.\n    For example, if the input is 120, the output should be (2,\
    \ 2, 2, 3, 5).\n    Example:\n    >>> prime_factors(120)\n    (2, 2, 2, 3, 5)\n\
    \    \n*/\nTuple!(int[]) prime_factors(int n)\n{\n    Tuple!(int[]) factors;\n\
    \    int[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    foreach(int prime; primes)\n    {\n\
    \        while(n % prime == 0)\n        {\n            n /= prime;\n         \
    \   factors ~= prime;\n        }\n    }\n    return factors;\n}\n/*\n    You are\
    \ given a list of integers. You should count the smallest number of \n    swaps\
    \ needed to sort the list in non-decreasing order.\n    A swap is defined as a\
    \ pair of elements being swapped. Each element can \n    only be swapped once.\n\
    \    The list is always sorted in non-\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpykdbzv8b.d(80): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpykdbzv8b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strong = 0;\n    int strong_pos = 0;\n   \
    \ int i;\n    int sm;\n    int cap;\n    string result;\n    if (extensions.length\
    \ == 0) \n    {\n        return class_name;\n    }\n    foreach (auto extension;\
    \ extensions) \n    {\n        int sm = 0;\n        int cap = 0;\n        i =\
    \ 0;\n        while (i < extension.length) \n        {\n            if (extension[i]\
    \ > 64 && extension[i] < 91) \n            {\n                cap++;\n       \
    \     }\n            else if (extension[i] > 96 && extension[i] < 123) \n    \
    \        {\n                sm++;\n            }\n            i++;\n        }\n\
    \        int s = cap - sm;\n        if (s > strong) \n        {\n            strong\
    \ = s;\n            strong_pos = i;\n        }\n    }\n    result = class_name\
    \ ~ \".\" ~ extensions[strong_pos];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpas6hcfix.d(34): Error: basic type expected, not `auto`\\n/tmp/tmpas6hcfix.d(34):\
    \ Error: no identifier for declarator `_error_`\\n/tmp/tmpas6hcfix.d(34): Error:\
    \ found `auto` when expecting `;`\\n/tmp/tmpas6hcfix.d(34): Error: found `;` when\
    \ expecting `)`\\n/tmp/tmpas6hcfix.d(34): Error: found `)` when expecting `;`\
    \ following statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpas6hcfix.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = class_name;\n    double max_strength\
    \ = 0;\n    foreach(string ext; extensions) {\n        double strength = 0;\n\
    \        foreach(char c; ext) {\n            if (c >= 'A' && c <= 'Z') {\n   \
    \             strength += 1;\n            } else if (c >= 'a' && c <= 'z') {\n\
    \                strength -= 1;\n            }\n        }\n        if (strength\
    \ > max_strength) {\n            max_strength = strength;\n            result\
    \ = class_name ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4rgn3gtl.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42925d]\\n??:? void tmp4rgn3gtl.__unittest_L42_C1()\
    \ [0x427f93]\\n??:? void tmp4rgn3gtl.__modtest() [0x4284c4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db37]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428fb6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9e5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa74]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a971]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428f8d]\\n??:? runModuleUnitTests [0x42d90d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4296ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429633]\\n??:? _d_run_main [0x42959e]\\n??:? main [0x4284d7]\\\
    n??:? __libc_start_main [0xea7a5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strength_of_extension = 0.0;\n    float[]\
    \ strength_of_all_extensions = new float[extensions.length];\n    for (int i =\
    \ 0; i < extensions.length; i++)\n    {\n        for (int j = 0; j < extensions[i].length;\
    \ j++)\n        {\n            if (isupper(extensions[i][j]))\n            {\n\
    \                strength_of_extension += 1;\n            }\n            else\n\
    \            {\n                strength_of_extension -= 1;\n            }\n \
    \       }\n        strength_of_all_extensions[i] = strength_of_extension;\n  \
    \      strength_of_extension = 0;\n    }\n    uint pos_of_strongest_extension\
    \ = max_element_index(strength_of_all_extensions);\n    return class_name + \"\
    .\" + extensions[pos_of_strongest_extension];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgfkqkcrp.d(30): Error: undefined identifier `isupper`\\n/tmp/tmpgfkqkcrp.d(42):\
    \ Error: undefined identifier `max_element_index`\\n/tmp/tmpgfkqkcrp.d(43): Error:\
    \ invalid array operation `class_name + \".\"` (possible missing [])\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgfkqkcrp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real max_strength = real.min;\n    string max_ext;\n\
    \    foreach(ext; extensions)\n    {\n        int caps = 0;\n        int sms =\
    \ 0;\n        foreach(c; ext)\n        {\n            if(c.isUpper)\n        \
    \        caps++;\n            else\n                sms++;\n        }\n      \
    \  real strength = cast(real)caps - cast(real)sms;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            max_ext = ext;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ max_ext;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf9zdtcqq.d(24): Error: no property `min` for type `real`\\n/tmp/tmpf9zdtcqq.d(32):\
    \ Error: no property `isUpper` for type `immutable(char)`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf9zdtcqq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
