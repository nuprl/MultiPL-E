language: d
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest)\n        {\n            strongest\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnqiz_67a.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpnqiz_67a.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnqiz_67a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    double strength\
    \ = -1.0;\n    foreach(string s; extensions) {\n        int caps = 0;\n      \
    \  int sms = 0;\n        foreach(char c; s) {\n            if(c >= 'A' && c <=\
    \ 'Z')\n                caps++;\n            else if(c >= 'a' && c <= 'z')\n \
    \               sms++;\n        }\n        double cur_strength = double(caps)/double(sms);\n\
    \        if(cur_strength > strength) {\n            strength = cur_strength;\n\
    \            strongest = s;\n        }\n    }\n    return class_name~\".\"~strongest;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt116qnki.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x429225]

    ??:? void tmpt116qnki.__unittest_L43_C1() [0x427d85]

    ??:? void tmpt116qnki.__modtest() [0x42848c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42daff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a939]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f55]

    ??:? runModuleUnitTests [0x42d8d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429674]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = null;\n    float\
    \ highest_strength = 0;\n    float strength = 0;\n    foreach(string extension;\
    \ extensions)\n    {\n        strength = 0;\n        float CAP = 0;\n        float\
    \ SM = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper())\n\
    \            {\n                CAP++;\n            }\n            else\n    \
    \        {\n                SM++;\n            }\n        }\n        strength\
    \ = CAP - SM;\n        if(strength > highest_strength)\n        {\n          \
    \  highest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return (class_name ~ \".\" ~ strongest_extension);\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl6su_gen.d(34): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl6su_gen.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    if (extensions.length == 0)\n        return class_name;\n\
    \    ulong i = 0;\n    double str = 0;\n    double temp = 0;\n    foreach (ext;\
    \ extensions)\n    {\n        temp = 0;\n        foreach (t; ext)\n        {\n\
    \            if (t.isUpper)\n                temp++;\n            else\n     \
    \           temp--;\n        }\n        if (temp > str)\n        {\n         \
    \   str = temp;\n            i = extensions.indexOf(ext);\n        }\n    }\n\
    \    return class_name ~ \".\" ~ extensions[i];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp09gyei16.d(34): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmp09gyei16.d(42): Error: no property `indexOf` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp09gyei16.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return (class_name ~ \".\" ~ extensions[0]);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpigxql8la.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290cd]

    ??:? void tmpigxql8la.__unittest_L26_C1() [0x427c31]

    ??:? void tmpigxql8la.__modtest() [0x428338]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a958]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a855]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dfd]

    ??:? runModuleUnitTests [0x42d7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429590]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float maxStrength = 0.0f;\n    int maxStrengthIndex\
    \ = 0;\n    float currentStrength = 0.0f;\n    int lowerCaseAmount = 0;\n    int\
    \ upperCaseAmount = 0;\n    foreach(index, extension; extensions)\n    {\n   \
    \     foreach(character; extension)\n        {\n            if(character.isUpper)\n\
    \            {\n                upperCaseAmount++;\n            }\n          \
    \  else\n            {\n                lowerCaseAmount++;\n            }\n  \
    \      }\n        currentStrength = (upperCaseAmount / (float)lowerCaseAmount);\n\
    \        if(currentStrength > maxStrength)\n        {\n            maxStrength\
    \ = currentStrength;\n            maxStrengthIndex = index;\n        }\n     \
    \   lowerCaseAmount = 0;\n        upperCaseAmount = 0;\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[maxStrengthIndex];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuuwcstnz.d(42): Error: C style cast illegal, use `cast(float)lowerCaseAmount`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuuwcstnz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164343
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //TODO: Add code here\n    int current_max_strength\
    \ = -1;\n    string current_max_extension = \"\";\n    foreach(string ext; extensions)\n\
    \    {\n        int new_strength = 0;\n        foreach(char c; ext)\n        {\n\
    \            if(isupper(c))\n                new_strength++;\n            else\
    \ if(islower(c))\n                new_strength--;\n        }\n        if(new_strength\
    \ > current_max_strength)\n        {\n            current_max_strength = new_strength;\n\
    \            current_max_extension = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ current_max_extension;\n}\n/*\n    You are given an integer array\
    \ which represents the height of a histogram,\n    where the width of each bar\
    \ is 1. For example, if the array is [2, 3, 1, 2, 4],\n    then here is the histogram\
    \ that it represents:\n    *\n    * *\n    * *\n    * * *\n    * * *\n    Write\
    \ a function that takes in such an array and return the size of the largest\n\
    \    rectangle that can be made out of the histogram. For the histogram above,\n\
    \    the largest rectangle would be the 4x3 rectangle with the top-left corner\
    \ at (1, 2).\n    If the array is [2, 3, 1, 2, 4, 3], then here is the histogram\
    \ that it represents:\n    *\n    * *\n    * *\n    * * *\n    * * *\n    * *\
    \ *\n    The largest rectangle would be the 3x2 rectangle with the top-left corner\
    \ at (2, 3).\n    If the array is [5, 4, 3, 2, 1], then here is the histogram\
    \ that it represents:\n    * * * * *\n    * * * * *\n    * * * * *\n    * * *\
    \ * *\n    * * * * *\n    The largest rectangle would be the 5x1 rectangle with\
    \ the top-left corner at (0, 0).\n    If the array is [5, 4, 3, 2, 1, 6], then\
    \ here is the histogram that it represents:\n    * * *\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps_vhl0w5.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps_vhl0w5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164343
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    uint max = 0;\n    foreach(ref string s; extensions)\n\
    \    {\n        uint count = 0;\n        foreach(c; s)\n        {\n          \
    \  if(isUpper(c))\n                count++;\n        }\n        if(count > max)\n\
    \            max = count;\n    }\n    return class_name ~ \".\" ~ extensions[max];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprxpy2u57.d(30): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprxpy2u57.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n     int strength = -1;\n     int uppercase = 0;\n\
    \     int lowercase = 0;\n     string strongest_extension = \"\";\n     foreach(string\
    \ s; extensions)\n     {\n         foreach(char c; s)\n         {\n          \
    \   if(c.isUpper)\n             {\n                 uppercase++;\n           \
    \  }\n             else\n             {\n                 lowercase++;\n     \
    \        }\n         }\n         if(uppercase - lowercase > strength)\n      \
    \   {\n             strength = uppercase - lowercase;\n             strongest_extension\
    \ = s;\n         }\n         uppercase = 0;\n         lowercase = 0;\n     }\n\
    \     return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp57eswpbm.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp57eswpbm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // 1. Take string class_name and string[] extensions\n\
    \    // 2. Loop through extensions and calculate strength (total_upper - total_lower)\n\
    \    // 3. Return \"class_name.extension_with_highest_strength\"\n    //\n   \
    \ //  loop-extensions -> get-total-upper -> get-total-lower -> calculate-strength\
    \ ->\n    //  check-if-highest -> return-string\n    //  \n    //  loop-extensions\
    \ -> get-total-upper -> get-total-lower -> calculate-strength ->\n    //  check-if-highest\
    \ -> return-string\n    //  \n    //  loop-extensions -> get-total-upper -> get-total-lower\
    \ -> calculate-strength ->\n    //  check-if-highest -> return-string\n    //\
    \  \n    //  loop-extensions -> get-total-upper -> get-total-lower -> calculate-strength\
    \ ->\n    //  check-if-highest -> return-string\n    //  \n    //  return \"class_name.extension_with_highest_strength\"\
    \n    //  \n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n \
    \   //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1_vffm66.d(130): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_vffm66.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164343
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\t// your code goes here\n\tint c_count = 0;\n\tint\
    \ l_count = 0;\n\tfloat max_strength = -100;\n\tstring strongest_extension = \"\
    \";\n\tforeach(string extension; extensions)\n\t{\n\t\tforeach(char c; extension)\n\
    \t\t{\n\t\t\tif(isupper(c)) c_count++;\n\t\t\telse if(islower(c)) l_count++;\n\
    \t\t}\n\t\tfloat strength = (float)c_count - (float)l_count;\n\t\tif(strength\
    \ > max_strength)\n\t\t{\n\t\t\tmax_strength = strength;\n\t\t\tstrongest_extension\
    \ = extension;\n\t\t}\n\t\tc_count = 0;\n\t\tl_count = 0;\n\t}\n\treturn class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9tu5wpp2.d(36): Error: C style cast illegal, use `cast(float)c_count`

    /tmp/tmp9tu5wpp2.d(36): Error: C style cast illegal, use `cast(float)l_count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9tu5wpp2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.typecons;\n    // sort the array in\
    \ order\n    sort(extensions);\n    int[] strengths = new int[extensions.length];\n\
    \    for (int i = 0; i < extensions.length; i++) {\n        int cap_count = 0;\n\
    \        int small_count = 0;\n        for (int j = 0; j < extensions[i].length;\
    \ j++) {\n            char c = extensions[i][j];\n            if (c.isUpper) {\n\
    \                cap_count++;\n            } else {\n                small_count++;\n\
    \            }\n        }\n        strengths[i] = cap_count - small_count;\n \
    \   }\n    int best_strength = strengths[0];\n    int best_index = 0;\n    for\
    \ (int i = 1; i < strengths.length; i++) {\n        if (strengths[i] > best_strength)\
    \ {\n            best_strength = strengths[i];\n            best_index = i;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ extensions[best_index];\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps7jduvio.d(26): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmps7jduvio.d(33): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps7jduvio.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = -9;\n    string Max = \"\";\n    foreach(string\
    \ val; extensions)\n    {\n        int up = 0;\n        int low = 0;\n       \
    \ foreach(char c; val)\n        {\n            if(c.isUpper)\n               \
    \ up++;\n            else\n                low++;\n        }\n        if(up -\
    \ low > max)\n        {\n            max = up - low;\n            Max = val;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ Max;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo9qnnm8f.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo9qnnm8f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    if (extensions.length == 0)\n        return class_name;\n\
    \    string greatest = extensions[0];\n    int greatest_strength = 0;\n    foreach\
    \ (string extension; extensions)\n    {\n        int strength = 0;\n        foreach\
    \ (char c; extension)\n        {\n            if (isUpper(c))\n              \
    \  strength++;\n            else if (isLower(c))\n                strength--;\n\
    \        }\n        if (strength > greatest_strength)\n        {\n           \
    \ greatest_strength = strength;\n            greatest = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ greatest;\n}\n/*\nA square matrix of integers\
    \ is given as input. Your task is to determine\nif the matrix is magic square.\
    \ You must follow the definition of\nmagic square which is:\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbd22isae.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbd22isae.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164343
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct ExtensionStrength\n    {\n        size_t\
    \ index;\n        float strength;\n        bool operator<(ExtensionStrength other)\
    \ const\n        {\n            if (this.strength != other.strength)\n       \
    \         return this.strength < other.strength;\n            return this.index\
    \ < other.index;\n        }\n    }\n    auto strengths = extensions.map!(ext =>\
    \ {\n        int sm = 0;\n        int cap = 0;\n        foreach (immutable char\
    \ c; ext)\n        {\n            if (isUpper(c))\n                cap++;\n  \
    \          else\n                sm++;\n        }\n        return ExtensionStrength(ext.indexOf,\
    \ cast(float)cap / (sm+1));\n    });\n    auto strongest = strengths.max;\n  \
    \  return class_name ~ \".\" ~ extensions[strongest.index];\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfiyjgtno.d(28): Error: semicolon expected, not `<`

    /tmp/tmpfiyjgtno.d(28): Error: declaration expected, not `<`

    /tmp/tmpfiyjgtno.d(32): Error: declaration expected, not `return`

    /tmp/tmpfiyjgtno.d(48): Error: declaration expected, not `return`

    /tmp/tmpfiyjgtno.d(49): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfiyjgtno.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = 0;\n    string strongest_name = extensions[0];\n\
    \    foreach(string e; extensions)\n    {\n        int curr = countUp(e) - countDown(e);\n\
    \        if(curr > max)\n        {\n            max = curr;\n            strongest_name\
    \ = e;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_name;\n}\n\
    private int countUp(string name)\n{\n    int count = 0;\n    foreach(char c; name)\n\
    \    {\n        if(c.isUpper)\n            count++;\n    }\n    return count;\n\
    }\nprivate int countDown(string name)\n{\n    int count = 0;\n    foreach(char\
    \ c; name)\n    {\n        if(c.isLower)\n            count++;\n    }\n    return\
    \ count;\n}\n/*\n    Write a function that takes a number and returns all of its\
    \ prime factors.\n    The result should be a tuple of numbers arranged from smallest\
    \ to largest.\n    For example, if the input is 120, the output should be (2,\
    \ 2, 2, 3, 5).\n    Example:\n    >>> prime_factors(120)\n    (2, 2, 2, 3, 5)\n\
    \    \n*/\nTuple!(int[]) prime_factors(int n)\n{\n    Tuple!(int[]) factors;\n\
    \    int[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    foreach(int prime; primes)\n    {\n\
    \        while(n % prime == 0)\n        {\n            n /= prime;\n         \
    \   factors ~= prime;\n        }\n    }\n    return factors;\n}\n/*\n    You are\
    \ given a list of integers. You should count the smallest number of \n    swaps\
    \ needed to sort the list in non-decreasing order.\n    A swap is defined as a\
    \ pair of elements being swapped. Each element can \n    only be swapped once.\n\
    \    The list is always sorted in non-\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwyi1ek3c.d(80): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwyi1ek3c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strong = 0;\n    int strong_pos = 0;\n   \
    \ int i;\n    int sm;\n    int cap;\n    string result;\n    if (extensions.length\
    \ == 0) \n    {\n        return class_name;\n    }\n    foreach (auto extension;\
    \ extensions) \n    {\n        int sm = 0;\n        int cap = 0;\n        i =\
    \ 0;\n        while (i < extension.length) \n        {\n            if (extension[i]\
    \ > 64 && extension[i] < 91) \n            {\n                cap++;\n       \
    \     }\n            else if (extension[i] > 96 && extension[i] < 123) \n    \
    \        {\n                sm++;\n            }\n            i++;\n        }\n\
    \        int s = cap - sm;\n        if (s > strong) \n        {\n            strong\
    \ = s;\n            strong_pos = i;\n        }\n    }\n    result = class_name\
    \ ~ \".\" ~ extensions[strong_pos];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphcy55qpg.d(34): Error: basic type expected, not `auto`

    /tmp/tmphcy55qpg.d(34): Error: no identifier for declarator `_error_`

    /tmp/tmphcy55qpg.d(34): Error: found `auto` when expecting `;`

    /tmp/tmphcy55qpg.d(34): Error: found `;` when expecting `)`

    /tmp/tmphcy55qpg.d(34): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphcy55qpg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164343
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = class_name;\n    double max_strength\
    \ = 0;\n    foreach(string ext; extensions) {\n        double strength = 0;\n\
    \        foreach(char c; ext) {\n            if (c >= 'A' && c <= 'Z') {\n   \
    \             strength += 1;\n            } else if (c >= 'a' && c <= 'z') {\n\
    \                strength -= 1;\n            }\n        }\n        if (strength\
    \ > max_strength) {\n            max_strength = strength;\n            result\
    \ = class_name ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprew__3iv.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x42925d]

    ??:? void tmprew__3iv.__unittest_L42_C1() [0x427f93]

    ??:? void tmprew__3iv.__modtest() [0x4284c4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db37]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428fb6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9e5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a971]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f8d]

    ??:? runModuleUnitTests [0x42d90d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strength_of_extension = 0.0;\n    float[]\
    \ strength_of_all_extensions = new float[extensions.length];\n    for (int i =\
    \ 0; i < extensions.length; i++)\n    {\n        for (int j = 0; j < extensions[i].length;\
    \ j++)\n        {\n            if (isupper(extensions[i][j]))\n            {\n\
    \                strength_of_extension += 1;\n            }\n            else\n\
    \            {\n                strength_of_extension -= 1;\n            }\n \
    \       }\n        strength_of_all_extensions[i] = strength_of_extension;\n  \
    \      strength_of_extension = 0;\n    }\n    uint pos_of_strongest_extension\
    \ = max_element_index(strength_of_all_extensions);\n    return class_name + \"\
    .\" + extensions[pos_of_strongest_extension];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpptfo9tds.d(30): Error: undefined identifier `isupper`

    /tmp/tmpptfo9tds.d(42): Error: undefined identifier `max_element_index`

    /tmp/tmpptfo9tds.d(43): Error: invalid array operation `class_name + "."` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpptfo9tds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real max_strength = real.min;\n    string max_ext;\n\
    \    foreach(ext; extensions)\n    {\n        int caps = 0;\n        int sms =\
    \ 0;\n        foreach(c; ext)\n        {\n            if(c.isUpper)\n        \
    \        caps++;\n            else\n                sms++;\n        }\n      \
    \  real strength = cast(real)caps - cast(real)sms;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            max_ext = ext;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ max_ext;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnnz8ehdx.d(24): Error: no property `min` for type `real`

    /tmp/tmpnnz8ehdx.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnnz8ehdx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string current_strongest = \"\";\n    double strongest_strength\
    \ = 0;\n    foreach(string ext; extensions) {\n        int upper = count_if!(\"\
    a >= 'A' && a <= 'Z'\")(ext);\n        int lower = count_if!(\"a >= 'a' && a <=\
    \ 'z'\")(ext);\n        double strength = to!double(upper) - to!double(lower);\n\
    \        if(strength > strongest_strength) {\n            strongest_strength =\
    \ strength;\n            current_strongest = ext;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ current_strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcpux84sj.d(27): Error: template instance `count_if!"a >= ''A''
    && a <= ''Z''"` template `count_if` is not defined

    /tmp/tmpcpux84sj.d(28): Error: template instance `count_if!"a >= ''a'' && a <=
    ''z''"` template `count_if` is not defined

    /tmp/tmpcpux84sj.d(29): Error: template instance `to!double` template `to` is
    not defined, did you mean No?

    /tmp/tmpcpux84sj.d(29): Error: template instance `to!double` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcpux84sj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto caps = extension => extension.countif!(c\
    \ => c.isUpper);\n    auto sm = extension => extension.countif!(c => c.isLower);\n\
    \    auto strongest = extensions.min!\"a.count - b.count\"(a, b) => a.count >\
    \ b.count ? a : b;\n    return strongest.count > 0 ? $\"{class_name}.{strongest}\"\
    \ : class_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo0zgqolt.d(26): Error: semicolon expected following auto declaration,
    not `=>`

    /tmp/tmpo0zgqolt.d(26): Error: found `=>` instead of statement

    /tmp/tmpo0zgqolt.d(27): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpo0zgqolt.d(27): Error: found `"{class_name}.{strongest}"` when expecting
    `:`

    /tmp/tmpo0zgqolt.d(27): Error: expression expected, not `:`

    /tmp/tmpo0zgqolt.d(27): Error: found `class_name` when expecting `;` following
    `return` statement

    /tmp/tmpo0zgqolt.d(27): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo0zgqolt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_extension_strength = 0;\n    string\
    \ strongest_extension = \"\";\n    foreach(string extension; extensions)\n   \
    \ {\n        double extension_strength = 0;\n        extension_strength = extension.count!(\"\
    A-Z\") - extension.count!(\"a-z\");\n        if(extension_strength > max_extension_strength)\n\
    \        {\n            max_extension_strength = extension_strength;\n       \
    \     strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ycklhyy.d(29): Error: no property `count` for type `string`

    /tmp/tmp2ycklhyy.d(29): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ycklhyy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tint i = 0;\n\tint CAP = 0;\n\tint SM = 0;\n\tfloat\
    \ strength = 0;\n\tfloat StrengthTest = 0;\n\tstring ChosenOne = \"\";\n\twhile\
    \ (i < extensions.length)\n\t{\n\t\tCAP = 0;\n\t\tSM = 0;\n\t\tint j = 0;\n\t\t\
    while (j < extensions[i].length)\n\t\t{\n\t\t\tif (extensions[i][j] >= 'A' &&\
    \ extensions[i][j] <= 'Z')\n\t\t\t{\n\t\t\t\tCAP++;\n\t\t\t}\n\t\t\telse if (extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z')\n\t\t\t{\n\t\t\t\tSM++;\n\t\t\t}\n\t\t\t\
    j++;\n\t\t}\n\t\tstrength = CAP - SM;\n\t\tif (strength > StrengthTest)\n\t\t\
    {\n\t\t\tStrengthTest = strength;\n\t\t\tChosenOne = extensions[i];\n\t\t}\n\t\
    \ti++;\n\t}\n\treturn class_name + \".\" + ChosenOne;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptg519y4c.d(55): Error: invalid array operation `class_name + "."`
    (possible missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptg519y4c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string a = \"\";\n    float max = 0;\n    foreach(string\
    \ i; extensions)\n    {\n        float CAP = 0;\n        float SM = 0;\n     \
    \   float strenght = 0;\n        foreach(char j; i)\n        {\n            if(j\
    \ >= 'A' && j <= 'Z')\n            {\n                CAP = CAP + 1;\n       \
    \     }\n            else\n            {\n                SM = SM + 1;\n     \
    \       }\n        }\n        strenght = CAP - SM;\n        if(strenght > max)\n\
    \        {\n            max = strenght;\n            a = i;\n        }\n    }\n\
    \    return class_name + \".\" + a;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnm5tal_d.d(49): Error: invalid array operation `class_name + "."`
    (possible missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnm5tal_d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto extension_strength = (ext) { \n        num(std.string.countif(ext,\
    \ (c) => std.char.isUpper(c))) \n        - num(std.string.countif(ext, (c) =>\
    \ std.char.isLower(c))) \n    };\n    auto strongest_extension = std.algorithm.reduce!(extension_strength)(extensions);\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp90ckiyl8.d(25): Error: identifier expected following `.`, not `char`

    /tmp/tmp90ckiyl8.d(26): Error: identifier expected following `.`, not `char`

    /tmp/tmp90ckiyl8.d(27): Error: found `}` when expecting `;` following statement

    /tmp/tmp90ckiyl8.d(27): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp90ckiyl8.d(31): Error: semicolon expected following auto declaration,
    not `unittest`

    /tmp/tmp90ckiyl8.d(31): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp90ckiyl8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strength = 0;\n    int value = 0;\n    string\
    \ strongest_extension = \"\";\n    foreach(string ext; extensions)\n    {\n  \
    \      foreach(char c; ext)\n        {\n            if(c.isUpper)\n          \
    \  {\n                value++;\n            }\n            else if(c.isLower)\n\
    \            {\n                strength++;\n            }\n        }\n      \
    \  if(value - strength > 0)\n        {\n            if(strongest_extension ==\
    \ \"\")\n            {\n                strongest_extension = ext;\n         \
    \   }\n            else if(value - strength > (value - strength)(strongest_extension))\n\
    \            {\n                strongest_extension = ext;\n            }\n  \
    \      }\n        strength = 0;\n        value = 0;\n    }\n    if(strongest_extension\
    \ == \"\")\n    {\n        return class_name;\n    }\n    return class_name ~\
    \ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_9fh_qvw.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmp_9fh_qvw.d(35): Error: no property `isLower` for type `char`

    /tmp/tmp_9fh_qvw.d(46): Error: function expected before `()`, not `value - strength`
    of type `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_9fh_qvw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strength = 0.0;\n    string strongest =\
    \ \"\";\n    foreach(string s; extensions) {\n        int lower = 0;\n       \
    \ int upper = 0;\n        foreach(char c; s) {\n            if(isUpper(c))\n \
    \               upper++;\n            else\n                lower++;\n       \
    \ }\n        if((double)upper / (double)lower > strength) {\n            strength\
    \ = (double)upper / (double)lower;\n            strongest = s;\n        }\n  \
    \  }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd8gfqzbq.d(35): Error: C style cast illegal, use `cast(double)upper`

    /tmp/tmpd8gfqzbq.d(35): Error: C style cast illegal, use `cast(double)lower`

    /tmp/tmpd8gfqzbq.d(36): Error: C style cast illegal, use `cast(double)upper`

    /tmp/tmpd8gfqzbq.d(36): Error: C style cast illegal, use `cast(double)lower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd8gfqzbq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //use built in methods\n    int max_strength =\
    \ extensions[0].count('A') - extensions[0].count('a');\n    string strongest_extension\
    \ = extensions[0];\n    foreach(i, extension; extensions)\n    {\n        int\
    \ local_strength = extension.count('A') - extension.count('a');\n        if(local_strength\
    \ > max_strength)\n        {\n            max_strength = local_strength;\n   \
    \         strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\n/*\n    You are given a list of numbers and\
    \ a target number. You should write a \n    function that returns a tuple that\
    \ contains the index of two numbers that\n    add up to the target number.\n \
    \   If a pair of numbers is found, the function should return a tuple that\n \
    \   contains their indices. The indices of the numbers should be 1-based, and\n\
    \    their order does not matter.\n    Example:\n    >>> FindIndices([1, 3, 5,\
    \ 7, 11], 4)\n    (1, 3)\n    >>> FindIndices([1, 3, 5, 7, 11], 1)\n    (-1, -1)\n\
    */\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5eg0xdvt.d(25): Error: no property `count` for type `string`

    /tmp/tmp5eg0xdvt.d(25): Error: no property `count` for type `string`

    /tmp/tmp5eg0xdvt.d(29): Error: no property `count` for type `string`

    /tmp/tmp5eg0xdvt.d(29): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5eg0xdvt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = class_name;\n    float best_strength\
    \ = 0;\n    int i = 0;\n    foreach(extension; extensions)\n    {\n        auto\
    \ smalls = extension.filter!(a => a.isLower);\n        auto caps = extension.filter!(a\
    \ => a.isUpper);\n        float current_strength = float(caps.length) - float(smalls.length);\n\
    \        if(current_strength > best_strength)\n        {\n            best_strength\
    \ = current_strength;\n            result ~= \".\" ~ extension;\n        }\n \
    \       else if(current_strength == best_strength)\n        {\n            float\
    \ first_index = extensions.indexOf(result.split(\".\")[1]);\n            float\
    \ second_index = extensions.indexOf(extension);\n            if(second_index <\
    \ first_index)\n            {\n                result = class_name ~ \".\" ~ extension;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpugx4dpc6.d(29): Error: no property `filter` for type `string`

    /tmp/tmpugx4dpc6.d(30): Error: no property `filter` for type `string`

    /tmp/tmpugx4dpc6.d(39): Error: no property `indexOf` for type `string[]`

    /tmp/tmpugx4dpc6.d(40): Error: no property `indexOf` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpugx4dpc6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_8wucjww.d(22): Error: function `tmp_8wucjww.Strongest_Extension`
    has no `return` statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_8wucjww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return class_name + \".\" +\n    extensions.max(0,\
    \ a, b => {\n        auto nCapsA = a.count(c => c.isUpper);\n        auto nCapsB\
    \ = b.count(c => c.isUpper);\n        auto nSmallsA = a.count(c => c.isLower);\n\
    \        auto nSmallsB = b.count(c => c.isLower);\n        return float(nCapsA\
    \ - nSmallsA) - float(nCapsB - nSmallsB);\n    });\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcci2x5cg.d(24): Error: invalid array operation `class_name + "."`
    (possible missing [])

    /tmp/tmpcci2x5cg.d(25): Error: no property `max` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcci2x5cg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real best_strength = 1.0f;\n    string best_extension\
    \ = \"\";\n    foreach(extension; extensions) {\n        int upper_case_count\
    \ = 0;\n        int lower_case_count = 0;\n        foreach(ch; extension) {\n\
    \            if(ch.isUpper) {\n                upper_case_count++;\n         \
    \   } else if(ch.isLower) {\n                lower_case_count++;\n           \
    \ }\n        }\n        real strength = cast(real)upper_case_count / cast(real)lower_case_count;\n\
    \        if(strength < best_strength) {\n            best_strength = strength;\n\
    \            best_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ best_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxln5mb6s.d(30): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpxln5mb6s.d(32): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxln5mb6s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  string str_class_name = class_name.toLower();\n\
    \  string temp = extensions[0];\n  double max_strength = 0.0;\n  double temp_strength\
    \ = 0.0;\n  foreach(i, element; extensions)\n  {\n    temp_strength = 0.0;\n \
    \   foreach(x, ite; element)\n    {\n      if(isUpper(ite))\n      {\n       \
    \ temp_strength++;\n      }\n      else\n      {\n        temp_strength--;\n \
    \     }\n    }\n    if(temp_strength > max_strength)\n    {\n      max_strength\
    \ = temp_strength;\n      temp = element;\n    }\n  }\n  return class_name + \"\
    .\" + temp;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n  \
    \  assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgn_v_8y.d(24): Error: no property `toLower` for type `string`

    /tmp/tmpwgn_v_8y.d(33): Error: undefined identifier `isUpper`

    /tmp/tmpwgn_v_8y.d(48): Error: invalid array operation `class_name + "."` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgn_v_8y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = extensions[0];\n    float strong_strength\
    \ = 0;\n    foreach(ext; extensions)\n    {\n        int upper = 0;\n        int\
    \ lower = 0;\n        foreach(i; ext)\n        {\n            if(isUpper(i)) \n\
    \            {\n                upper++;\n            }\n            else\n  \
    \          {\n                lower++;\n            }\n        }\n        float\
    \ temp = (float)upper / (float)lower;\n        if(temp >= strong_strength)\n \
    \       {\n            strong_strength = temp;\n            strongest = ext;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpout6v9u3.d(41): Error: C style cast illegal, use `cast(float)upper`

    /tmp/tmpout6v9u3.d(41): Error: C style cast illegal, use `cast(float)lower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpout6v9u3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  struct Extension\n  {\n    int Strength;\n    string\
    \ Name;\n  }\n  int max_strength = 0;\n  string strongest_extension = \"\";\n\
    \  foreach(index, value; extensions)\n  {\n    int CAP = 0;\n    int SM = 0;\n\
    \    foreach(ch; value)\n    {\n      if (ch in ['A' .. 'Z'])\n        CAP++;\n\
    \      else if (ch in ['a' .. 'z'])\n        SM++;\n    }\n    if (max_strength\
    \ < CAP - SM)\n    {\n      max_strength = CAP - SM;\n      strongest_extension\
    \ = value;\n    }\n  }\n  return class_name ~ \".\" ~ strongest_extension;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdo0ttjv6.d(37): Error: found `..` when expecting `,`

    /tmp/tmpdo0ttjv6.d(39): Error: found `..` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdo0ttjv6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest_extension = tuple(0.0, \"nothing\"\
    );\n    int i = 0;\n    foreach(extension; extensions)\n    {\n        auto strength\
    \ = extension.filter!(x => x.isUpperCase).length - extension.filter!(x => x.isLowerCase).length;\n\
    \        if(strength > strongest_extension[0])\n        {\n            strongest_extension\
    \ = tuple(strength, extension);\n        }\n        else if(strength == strongest_extension[0])\n\
    \        {\n            if(i < extensions.indexOf(strongest_extension[1]))\n \
    \           {\n                strongest_extension = tuple(strength, extension);\n\
    \            }\n        }\n        i++;\n    }\n    return class_name ~ \".\"\
    \ ~ strongest_extension[1];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmfbj8e29.d(28): Error: no property `filter` for type `string`

    /tmp/tmpmfbj8e29.d(28): Error: no property `filter` for type `string`

    /tmp/tmpmfbj8e29.d(35): Error: no property `indexOf` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmfbj8e29.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //write your code here\n    class strength\n \
    \   {\n        int capital;\n        int small;\n        public:\n        strength(string\
    \ s)\n        {\n            capital = 0;\n            small = 0;\n          \
    \  for(char c : s)\n            {\n                if(c.isUpper)\n           \
    \         capital++;\n                else if(c.isLower)\n                   \
    \ small++;\n            }\n        }\n        int getStrength()\n        {\n \
    \           return capital - small;\n        }\n    }\n    auto charFunc = function(char\
    \ c)\n    {\n        if(c.isUpper)\n            return 1;\n        else if(c.isLower)\n\
    \            return -1;\n        else\n            return 0;\n    }\n    /*\n\
    \    auto func = function(string s)\n    {\n        int capital = count(s.filter!(a\
    \ => a.isUpper));\n        int small = count(s.filter!(a => a.isLower));\n   \
    \     int strength = capital - small;\n        return strength;\n    }\n    */\n\
    \    auto func = function(string s)\n    {\n        int capital = count(s.filter!(a\
    \ => a.isUpper));\n        int small = count(s.filter!(a => a.isLower));\n   \
    \     int strength = capital - small;\n        return strength;\n    }\n    //auto\
    \ max = extensions.map!(c => strength(c).getStrength).max;\n    auto max = extensions.map!(func).max;\n\
    \    //auto max = extensions.map!(c => c.map!(charFunc).sum).max;\n    /*\n  \
    \  auto max = extensions.map!(c => {\n        int capital = count(c.filter!(a\
    \ => a.isUpper));\n        int small = count(c.filter!(a => a.isLower));\n   \
    \     int strength = capital - small;\n        return strength;\n    }).max;\n\
    \    */\n    auto result = extensions.map!(c => tuple(func(c), c)).filter!(c =>\
    \ c[0] == max).take(1)[0][1];\n    //auto result = extensions.map!(\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq_17tz04.d(30): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpq_17tz04.d(31): Error: no identifier for declarator `strength(string s)`

    /tmp/tmpq_17tz04.d(34): Error: semicolon expected, not `:`

    /tmp/tmpq_17tz04.d(34): Error: expression expected, not `:`

    /tmp/tmpq_17tz04.d(34): Error: found `s` when expecting `;` following `for` condition

    /tmp/tmpq_17tz04.d(65): Error: semicolon expected following auto declaration,
    not `auto`

    /tmp/tmpq_17tz04.d(73): Error: semicolon expected following auto declaration,
    not `auto`

    /tmp/tmpq_17tz04.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_17tz04.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n    auto ext_info =  zip(extensions, map!(a\
    \ => tuple(a.filter!(c => c.isUpper).length, a.filter!(c => c.isLower).length),\
    \ extensions));\n    auto ext_sorted = ext_info.sort!(a => a[1][0] - a[1][1]);\n\
    \    return format(\"%s.%s\", class_name, ext_sorted[$-1][0]);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnmlop7_k.d(25): Error: undefined identifier `zip`

    /tmp/tmpnmlop7_k.d(27): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnmlop7_k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest = 0;\n    int index_of_strongest\
    \ = 0;\n    int strength;\n    foreach(int i, string ext; extensions)\n    {\n\
    \        strength = to!int(std.algorithm.count_if!(t => islower(t))(ext));\n \
    \       if(strength > strongest)\n        {\n            strongest = strength;\n\
    \            index_of_strongest = i;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[index_of_strongest];\n}\n/*\nYou are given an array of\
    \ integers and a number, k. \nYou should find the sum of all numbers that are\
    \ greater than \ntheir k-th successor.\nExample:\n>>> Solution([1,2,3,4,5,6,7,8,9,10],\
    \ 3)\n40\n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm77mi_hk.d(29): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm77mi_hk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    alias strongest_extension = Tuple!(string, double);\n\
    \    const strongest_extension zero = tuple(\"\", 0.0);\n    // The reduce function\
    \ will return the tuple that holds the name and the strength\n    // of the strongest\
    \ extension.\n    return class_name ~ \".\" ~ reduce!((a, b) => a[1] > b[1] ?\
    \ a : b)(zero, map!((extension) => {\n        int big = 0;\n        int small\
    \ = 0;\n        foreach(char c; extension) {\n            if (c.isUpper) big++;\n\
    \            else if (c.isLower) small++;\n        }\n        return tuple(extension,\
    \ double(big - small));\n    })(extensions))[0];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj5feyo00.d(28): Error: template instance `reduce!((a, b) => a[1]
    > b[1] ? a : b)` template `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj5feyo00.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  //write code here\n  int value = 0;\n  int diff\
    \ = 0;\n  foreach(element; extensions)\n  {\n    int cap = 0;\n    int sm = 0;\n\
    \    foreach(ch; element)\n    {\n      if(ch.isUpper)\n        cap++;\n     \
    \ else if(ch.isLower)\n        sm++;\n    }\n    int dif = cap - sm;\n    if(dif\
    \ > diff)\n    {\n      diff = dif;\n      value = extensions.indexOf(element);\n\
    \    }\n  }\n  return class_name ~ \".\" ~ extensions[value];\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoolchsw6.d(33): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpoolchsw6.d(35): Error: no property `isLower` for type `immutable(char)`

    /tmp/tmpoolchsw6.d(42): Error: no property `indexOf` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoolchsw6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest = -1000;\n    string strongest_ext\
    \ = \"\";\n    foreach(string ext; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(dchar c; ext)\n        {\n            if(c.isUpper)\n\
    \                strength += 1;\n            else\n                strength -=\
    \ 1;\n        }\n        if(abs(strength) > abs(strongest))\n        {\n     \
    \       strongest = strength;\n            strongest_ext = ext;\n        }\n \
    \   }\n    return to!string(class_name ~ \".\" ~ strongest_ext);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1zbhppdv.d(31): Error: no property `isUpper` for type `dchar`

    /tmp/tmp1zbhppdv.d(42): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1zbhppdv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string myExt = \"\";\n    float myExtStrength\
    \ = 1;\n    foreach(string ext; extensions)\n    {\n        float extStrength\
    \ = 0;\n        for(int i = 0; i < ext.length; i++)\n        {\n            if(ext[i]\
    \ > 64 && ext[i] < 91)\n            {\n                extStrength++;\n      \
    \      }\n            else if(ext[i] > 96 && ext[i] < 123)\n            {\n  \
    \              extStrength--;\n            }\n        }\n        if(extStrength\
    \ < myExtStrength)\n        {\n            myExt = ext;\n            myExtStrength\
    \ = extStrength;\n        }\n    }\n    return class_name ~ \".\" ~ myExt;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpca04mct0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x429295]

    ??:? void tmpca04mct0.__unittest_L48_C1() [0x427df9]

    ??:? void tmpca04mct0.__modtest() [0x428500]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dbe3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428fee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aa91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ab20]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aa1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fc5]

    ??:? runModuleUnitTests [0x42d9b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429758]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // your code\n    double strength_cap = 0;\n \
    \   double strength_sm = 0;\n    double strong_ext = 0;\n    string strong_ext_name\
    \ = \"\";\n    foreach(ext; extensions)\n    {\n        strength_cap = 0;\n  \
    \      strength_sm = 0;\n        foreach(i; 0 .. ext.length)\n        {\n    \
    \        if(ext[i] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n            {\n       \
    \         strength_cap++;\n            }\n            else\n            {\n  \
    \              strength_sm++;\n            }\n        }\n        if(strong_ext\
    \ < strength_cap - strength_sm)\n        {\n            strong_ext = strength_cap\
    \ - strength_sm;\n            strong_ext_name = ext;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strong_ext_name;\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp88ndv87q.d(35): Error: incompatible types for `(ext[i]) in ("ABCDEFGHIJKLMNOPQRSTUVWXYZ")`:
    `immutable(char)` and `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp88ndv87q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = extensions[0];\n    float maxStrength\
    \ = (Strongest_Extension_Strength(extensions[0]));\n    foreach(extension; extensions[1..$])\n\
    \    {\n        float strength = Strongest_Extension_Strength(extension);\n  \
    \      if(strength > maxStrength)\n        {\n            maxStrength = strength;\n\
    \            strongest = extension;\n        }\n    }\n    return class_name ~\
    \ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2atsjcg0.d(25): Error: undefined identifier `Strongest_Extension_Strength`

    /tmp/tmp2atsjcg0.d(28): Error: undefined identifier `Strongest_Extension_Strength`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2atsjcg0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = -1;\n    auto strongest_ext =\
    \ \"\";\n    foreach(ext; extensions)\n    {\n        auto upcases = ext.count!(c\
    \ => c.isUpper);\n        auto locases = ext.count!(c => c.isLower);\n       \
    \ auto strength = cast(double)upcases / (upcases + locases);\n        if(strength\
    \ > strongest)\n        {\n            strongest = strength;\n            strongest_ext\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_ext;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3rfcslwt.d(28): Error: no property `count` for type `string`

    /tmp/tmp3rfcslwt.d(29): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3rfcslwt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = extensions[0];\n\
    \    real strength = Count(strongest_extension);\n    for (int i = 1; i < extensions.length;\
    \ i++)\n    {\n        int current_strength = Count(extensions[i]);\n        if\
    \ (current_strength > strength)\n        {\n            strength = current_strength;\n\
    \            strongest_extension = extensions[i];\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp4mcpilx.d(25): Error: undefined identifier `Count`

    /tmp/tmpp4mcpilx.d(28): Error: undefined identifier `Count`

    /tmp/tmpp4mcpilx.d(35): Error: invalid array operation `class_name + "."` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp4mcpilx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    float strongest_strength\
    \ = -FLT_MAX;\n    foreach(ext; extensions)\n    {\n        float strength = 0;\n\
    \        foreach(c; ext)\n        {\n            if(c >= 'A' && c <= 'Z')\n  \
    \              strength++;\n            else if(c >= 'a' && c <= 'z')\n      \
    \          strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcbc64evu.d(25): Error: undefined identifier `FLT_MAX`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbc64evu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest;\n    float strength = 0;\n \
    \   foreach(extension; extensions) \n    {\n        int upper = 0;\n        int\
    \ lower = 0;\n        foreach(char; extension) \n        {\n            if(isUpper(char))\
    \ upper++;\n            else lower++;\n        }\n        float cur_strength =\
    \ (upper-lower);\n        if(cur_strength > strength)\n        {\n           \
    \ strength = cur_strength;\n            strongest = extension;\n        }\n  \
    \  }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcasi7qq7.d(30): Error: no identifier for declarator `char`

    /tmp/tmpcasi7qq7.d(32): Error: found `)` when expecting `.` following char

    /tmp/tmpcasi7qq7.d(32): Error: found `)` when expecting identifier following `char`.

    /tmp/tmpcasi7qq7.d(32): Error: found `upper` when expecting `,`

    /tmp/tmpcasi7qq7.d(32): Error: expression expected, not `;`

    /tmp/tmpcasi7qq7.d(33): Error: found `else` when expecting `,`

    /tmp/tmpcasi7qq7.d(33): Error: found `;` when expecting `,`

    /tmp/tmpcasi7qq7.d(34): Error: expression expected, not `}`

    /tmp/tmpcasi7qq7.d(35): Error: found `float` when expecting `,`

    /tmp/tmpcasi7qq7.d(35): Error: found `;` when expecting `,`

    /tmp/tmpcasi7qq7.d(36): Error: expression expected, not `if`

    /tmp/tmpcasi7qq7.d(37): Error: found `{` when expecting `,`

    /tmp/tmpcasi7qq7.d(38): Error: found `;` when expecting `,`

    /tmp/tmpcasi7qq7.d(39): Error: found `;` when expecting `,`

    /tmp/tmpcasi7qq7.d(40): Error: expression expected, not `}`

    /tmp/tmpcasi7qq7.d(41): Error: found `}` when expecting `,`

    /tmp/'
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongestStrength = 0;\n    string strongestExtension\
    \ = \"\";\n    double lowerCaseCount;\n    double upperCaseCount;\n    double\
    \ extensionStrength;\n    for (string extension : extensions)\n    {\n       \
    \ lowerCaseCount = 0;\n        upperCaseCount = 0;\n        for (char letter :\
    \ extension)\n        {\n            if (letter.isUpper())\n            {\n  \
    \              upperCaseCount += 1;\n            }\n            else if (letter.isLower())\n\
    \            {\n                lowerCaseCount += 1;\n            }\n        }\n\
    \        extensionStrength = upperCaseCount - lowerCaseCount;\n        if (extensionStrength\
    \ > strongestStrength)\n        {\n            strongestStrength = extensionStrength;\n\
    \            strongestExtension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongestExtension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6sfp9v2p.d(29): Error: found `extension` when expecting `;` following
    statement

    /tmp/tmp6sfp9v2p.d(29): Error: expression expected, not `:`

    /tmp/tmp6sfp9v2p.d(29): Error: found `extensions` when expecting `;` following
    `for` condition

    /tmp/tmp6sfp9v2p.d(33): Error: semicolon expected, not `:`

    /tmp/tmp6sfp9v2p.d(33): Error: expression expected, not `:`

    /tmp/tmp6sfp9v2p.d(33): Error: found `extension` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6sfp9v2p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto len = extensions.length;\n    auto first\
    \ = true;\n    auto max_strength = -1.0;\n    auto strongest_extension = \"\"\
    ;\n    foreach(extension; extensions)\n    {\n        auto cap = count_if!((c){return\
    \ isUpper(c);})(extension);\n        auto sm = count_if!((c){return isLower(c);})(extension);\n\
    \        auto strength = cast(double)cap / sm;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy27wavtg.d(30): Error: template instance `count_if!((c)

    {

    return isUpper(c);

    }

    )` template `count_if` is not defined

    /tmp/tmpy27wavtg.d(31): Error: template instance `count_if!((c)

    {

    return isLower(c);

    }

    )` template `count_if` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy27wavtg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    Tuple!(\"name\", \"strength\")[] ext_list = new\
    \ Tuple!(\"name\", \"strength\")[extensions.length];\n    for (int i = 0; i <\
    \ extensions.length; i++)\n    {\n        ext_list[i] = tuple(\"name\" => extensions[i],\
    \ \"strength\" => extensions[i].countUpper - extensions[i].countLower);\n    }\n\
    \    ext_list.sort!((a, b) => a.strength > b.strength);\n    return format(\"\
    %s.%s\", class_name, ext_list[0].name);\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkx4ufcan.d(27): Error: found `=>` when expecting `,`

    /tmp/tmpkx4ufcan.d(27): Error: found `=>` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkx4ufcan.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            strength += (c.isUpper\
    \ && c != '-') ? 1 : -1;\n        }\n        if(strength >= max_strength)\n  \
    \      {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdwtd3uxt.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdwtd3uxt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tstatic bool isUpper(dchar c) \n\t{\n\t\treturn c\
    \ >= 'A' && c <= 'Z';\n\t}\n\t\n\tstatic bool isLower(dchar c) \n\t{\n\t\treturn\
    \ c >= 'a' && c <= 'z';\n\t}\n\t\n\tauto ext = extensions.map!(ext => \n\t{\n\t\
    \treturn tuple(ext, ext.count!(isUpper) - ext.count!(isLower));\n\t}).max!((a,\
    \ b) => {\n\t\treturn (a[1] > b[1]) || (a[1] == b[1] && a[0] < b[0]);\n\t});\n\
    \t\n\treturn format(\"%s.%s\", class_name, ext[0]);\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwlvyc9zy.d(34): Error: no property `map` for type `string[]`

    /tmp/tmpwlvyc9zy.d(41): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwlvyc9zy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    foreach(e; extensions)\n    {\n        int upper\
    \ = 0;\n        int lower = 0;\n        foreach(c; e)\n        {\n           \
    \ if(c.isUpper) upper++;\n            else lower++;\n        }\n        e ~= \"\
    ,\" ~ to!string(upper - lower);\n    }\n    assert(extensions.length);\n    auto\
    \ tuple = max(extensions);\n    assert(tuple[0].find(\",\"));\n    string[] parts\
    \ = tuple[0].split(\",\");\n    assert(parts.length == 2);\n    return class_name\
    \ ~ \".\" ~ parts[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvzwrooje.d(30): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpvzwrooje.d(33): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpvzwrooje.d(36): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzwrooje.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength_list = [];\n    string[] sliced_extensions\
    \ = [];\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int upper_case_letters\
    \ = 0;\n        int lower_case_letters = 0;\n        foreach (c; extensions[i])\n\
    \        {\n            if (c.isUpper)\n            {\n                upper_case_letters++;\n\
    \            }\n            else\n            {\n                lower_case_letters++;\n\
    \            }\n        }\n        strength_list ~= cast(int)(upper_case_letters\
    \ - lower_case_letters);\n        sliced_extensions ~= extensions[i];\n    }\n\
    \    return class_name ~ \".\" ~ sliced_extensions[indexOf(strength_list, max(strength_list))];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcrh8y227.d(32): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpcrh8y227.d(44): Error: undefined identifier `indexOf`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcrh8y227.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double highest_value = -9999;\n    string strongest_extension;\n\
    \    foreach(string extension; extensions) {\n        int cap = 0;\n        int\
    \ sm = 0;\n        foreach(char c; extension) {\n            if(isupper(c)) cap++;\n\
    \            else sm++;\n        }\n        double strength = cap - sm;\n    \
    \    if(strength > highest_value) {\n            highest_value = strength;\n \
    \           strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjp26lg90.d(30): Error: undefined identifier `isupper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjp26lg90.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    const int min_strength = -2;\n    real max_strength\
    \ = min_strength;\n    string strongest = \"\";\n    string candidate = \"\";\n\
    \    foreach(ext; extensions)\n    {\n        real cur_strength = real(countUpper(ext)\
    \ - countLower(ext));\n        if(cur_strength == max_strength)\n        {\n \
    \           // Choose the one that comes first in the array\n            if(ext\
    \ < candidate)\n            {\n                strongest = ext;\n            }\n\
    \        }\n        else if(cur_strength > max_strength)\n        {\n        \
    \    max_strength = cur_strength;\n            strongest = ext;\n        }\n \
    \   }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv97059jx.d(30): Error: undefined identifier `countUpper`

    /tmp/tmpv97059jx.d(30): Error: undefined identifier `countLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv97059jx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    int strongest_strength\
    \ = 0;\n    string current_extension = \"\";\n    int current_strength = 0;\n\
    \    foreach(extension; extensions)\n    {\n        current_extension = extension;\n\
    \        current_strength = 0;\n        foreach(char a; current_extension)\n \
    \       {\n            if(isUpper(a))\n            {\n                current_strength++;\n\
    \            }\n            else\n            {\n                current_strength--;\n\
    \            }\n        }\n        if(current_strength >= strongest_strength)\n\
    \        {\n            strongest_strength = current_strength;\n            strongest_extension\
    \ = current_extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nstatic assert(Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) ==\
    \ \"my_class.AA\");\nstatic assert(Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"Cc\"]) == \"my_class.AA\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Be\", \"CC\"]) == \"my_class.CC\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"aa\", \"Be\", \"CC\"]) == \"my_class.CC\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.AA\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.AA\");\nstatic\
    \ assert(Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"\
    ]) == \"Slices.SErviNGSliCes\");\nstatic assert(Strongest_Extension(\"my_class\"\
    , [\"NeW\", \"clasS\", \"For\", \"You\"]) == \"my_class.NeW\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"NWe\", \"clasS\", \"For\", \"You\"]) == \"my\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv1o3wkup.d(64): Error: found `Watashi` when expecting `)`

    /tmp/tmpv1o3wkup.d(64): Error: found `", ["` when expecting `;`

    /tmp/tmpv1o3wkup.d(64): Error: no identifier for declarator `tEN`

    /tmp/tmpv1o3wkup.d(64): Error: declaration expected, not `", "`

    /tmp/tmpv1o3wkup.d(72): Error: unterminated string constant starting at /tmp/tmpv1o3wkup.d(72)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv1o3wkup.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct Ext {\n        int cap;\n        int small;\n\
    \        string name;\n    }\n    Ext strongest;\n    Ext[] extension = new Ext[];\n\
    \    extension.length = extensions.length;\n    foreach(i, e; extensions) {\n\
    \        extension[i].name = e;\n        extension[i].cap = count(e.filter!(x\
    \ => x.isUpper));\n        extension[i].small = count(e.filter!(x => x.isLower));\n\
    \    }\n    strongest = extension[0];\n    foreach(i, e; extension) {\n      \
    \  if (strongest.cap - strongest.small < e.cap - e.small) {\n            strongest\
    \ = e;\n        }\n    }\n    return class_name ~ \".\" ~ strongest.name;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm2u135aj.d(30): Error: new can only create structs, dynamic arrays
    or class objects, not `Ext[]`''s

    /tmp/tmpm2u135aj.d(34): Error: undefined identifier `count`

    /tmp/tmpm2u135aj.d(35): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm2u135aj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return cast(string)std.algorithm.maxElement(extensions,\
    \ (a, b) => score(a) > score(b));\n}\nalias score = (string ext) => {\n    return\
    \ ext.filter!(c => isUpper(c)).length - ext.filter!(c => isLower(c)).length;\n\
    };\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqamx_a_w.d(27): Error: no property `filter` for type `string`

    /tmp/tmpqamx_a_w.d(27): Error: no property `filter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqamx_a_w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = \"\";\n    double strength = 0;\n\
    \    string best = \"\";\n    string a = \"\";\n    bool cap = false;\n    bool\
    \ sm = false;\n    int count = 0;\n    foreach(string ext; extensions)\n    {\n\
    \        foreach(char c; ext)\n        {\n            if(c.isUpper)\n        \
    \    {\n                cap = true;\n            }\n            else if(c.isLower)\n\
    \            {\n                sm = true;\n            }\n        }\n       \
    \ if(cap && sm)\n        {\n            result = class_name ~ \".\" ~ ext;\n \
    \           strength = (ext.countUpper - ext.countLower) / ext.length;\n     \
    \       if(strength > 0)\n            {\n                a = class_name ~ \".\"\
    \ ~ ext;\n                best = a;\n            }\n            else if(strength\
    \ < 0)\n            {\n                a = class_name ~ \".\" ~ ext;\n       \
    \         best = a;\n            }\n            else if(strength == 0)\n     \
    \       {\n                a = class_name ~ \".\" ~ ext;\n                best\
    \ = a;\n            }\n        }\n        else\n        {\n            result\
    \ = class_name;\n        }\n    }\n    return best;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxbo53zdc.d(35): Error: no property `isUpper` for type `char`

    /tmp/tmpxbo53zdc.d(39): Error: no property `isLower` for type `char`

    /tmp/tmpxbo53zdc.d(47): Error: no property `countUpper` for type `string`

    /tmp/tmpxbo53zdc.d(47): Error: no property `countLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbo53zdc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    class strong\n    {\n        int strength;\n \
    \       string ext;\n        this(string ext) {\n            this.ext = ext;\n\
    \            int CAP = 0;\n            int SM = 0;\n            foreach(c; ext)\
    \ {\n                c.isUpper\n                ? CAP += 1\n                :\
    \ SM += 1;\n            }\n            this.strength = CAP - SM;\n        }\n\
    \        bool opEquals(strong s) {\n            return this.strength == s.strength;\n\
    \        }\n        bool opCmp(strong s) {\n            return this.strength >\
    \ s.strength;\n        }\n    }\n    strong strong_ext;\n    strong_ext.strength\
    \ = -99999;\n    int index = 0;\n    foreach(ext; extensions) {\n        strong\
    \ s = strong(ext);\n        if(s.strength > strong_ext.strength) {\n         \
    \   strong_ext = s;\n            index = indexOf(extensions, ext);\n        }\n\
    \    }\n    return class_name ~ \".\" ~ extensions[index];\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpte3s_o04.d(33): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpte3s_o04.d(50): Error: no property `opCall` for type `tmpte3s_o04.Strongest_Extension.strong`,
    did you mean `new strong`?

    /tmp/tmpte3s_o04.d(53): Error: undefined identifier `indexOf`, did you mean variable
    `index`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpte3s_o04.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strength = (string s) => s.count(\"a..z\"\
    ) - s.count(\"A..Z\");\n    return format(\"%s.%s\", class_name, extensions.max!(strength)[0]);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzpub4wem.d(24): Error: no property `count` for type `string`

    /tmp/tmpzpub4wem.d(24): Error: no property `count` for type `string`

    /tmp/tmpzpub4wem.d(25): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzpub4wem.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.algorithm;\n    import std.math;\n\
    \    import std.range;\n    import std.stdio;\n    import std.typecons;\n    auto\
    \ countUpper =(string s) => s.filter!(c => c.isUpper).length;\n    auto countLower\
    \ =(string s) => s.filter!(c => c.isLower).length;\n    struct Strength{string\
    \ strength; string name;}\n    auto strong = map!(e => Strength(to!string(countUpper(e)\
    \ - countLower(e)), e))(extensions);\n    strong.sort!((a, b) => a.strength.compare(b.strength));\n\
    \    return class_name ~ \".\" ~ strong[$-1].name;\n}\n//\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpce83dgwn.d(29): Error: no property `isUpper` for type `dchar`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):        instantiated
    from here: `FilterResult!(__lambda2, string)`

    /tmp/tmpce83dgwn.d(29):        instantiated from here: `filter!string`

    /tmp/tmpce83dgwn.d(30): Error: no property `isLower` for type `dchar`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):        instantiated
    from here: `FilterResult!(__lambda2, string)`

    /tmp/tmpce83dgwn.d(30):        instantiated from here: `filter!string`

    /tmp/tmpce83dgwn.d(32): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm'
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions) {\n        int strength =\
    \ extension.count!(char.isUpper) - extension.count!(char.isLower);\n        if(strength\
    \ > max_strength) {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfhotmvqt.d(27): Error: no property `count` for type `string`

    /tmp/tmpfhotmvqt.d(27): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfhotmvqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strenght = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = countUntil!(extension[],\
    \ char c => c.isUpper);\n        int sm = countUntil!(extension[], char c => c.isLower);\n\
    \        int st = cap - sm;\n        if(max_strenght < st)\n        {\n      \
    \      max_strenght = st;\n            strongest_extension = extension;\n    \
    \    }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1pb1b8yy.d(28): Error: found `c` when expecting `.` following char

    /tmp/tmp1pb1b8yy.d(28): Error: found `=>` when expecting identifier following
    `char`.

    /tmp/tmp1pb1b8yy.d(28): Error: found `c` when expecting `)` following template
    argument list

    /tmp/tmp1pb1b8yy.d(28): Error: semicolon expected, not `)`

    /tmp/tmp1pb1b8yy.d(28): Error: found `)` instead of statement

    /tmp/tmp1pb1b8yy.d(29): Error: found `c` when expecting `.` following char

    /tmp/tmp1pb1b8yy.d(29): Error: found `=>` when expecting identifier following
    `char`.

    /tmp/tmp1pb1b8yy.d(29): Error: found `c` when expecting `)` following template
    argument list

    /tmp/tmp1pb1b8yy.d(29): Error: semicolon expected, not `)`

    /tmp/tmp1pb1b8yy.d(29): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1pb1b8yy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    int strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        int curr_strength =\
    \ 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n  \
    \              curr_strength++;\n            else\n                curr_strength--;\n\
    \        }\n        if(curr_strength > strength)\n        {\n            strength\
    \ = curr_strength;\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbf6kkqtq.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbf6kkqtq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = 0;\n    string strongest_ext\
    \ = \"\";\n    foreach(string e; extensions) {\n        float ext_strength = float(std.regex.matchAll(e,\
    \ `[A-Z]`).length) - \n                             float(std.regex.matchAll(e,\
    \ `[a-z]`).length);\n        if(ext_strength > strongest) {\n            strongest\
    \ = ext_strength;\n            strongest_ext = e;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv_p0rr9w.d(27): Error: undefined identifier `regex` in package
    `std`

    /tmp/tmpv_p0rr9w.d(28): Error: undefined identifier `regex` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv_p0rr9w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto s = extensions.sort!(\n                (string\
    \ x, string y) => \n                {\n                    int nx = x.length;\n\
    \                    int ny = y.length;\n                    int cx = 0;\n   \
    \                 int cy = 0;\n                    int sx = 0;\n             \
    \       int sy = 0;\n                    foreach(char ch; x)\n               \
    \     {\n                        if (std.ctype.isupper(ch))\n                \
    \            cx++;\n                        else if (std.ctype.islower(ch))\n\
    \                            sx++;\n                    }\n                  \
    \  foreach(char ch; y)\n                    {\n                        if (std.ctype.isupper(ch))\n\
    \                            cy++;\n                        else if (std.ctype.islower(ch))\n\
    \                            sy++;\n                    }\n                  \
    \  double dx = cx - sx;\n                    double dy = cy - sy;\n          \
    \          if (dx > dy)\n                        return 1;\n                 \
    \   else if (dx < dy)\n                        return -1;\n                  \
    \  else\n                        return 0;\n                }\n            );\n\
    \    return class_name ~ \".\" ~ s[$-1];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr0ahu4nx.d(24): Error: no property `sort` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr0ahu4nx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto res = tuple(extensions.map!(a => tuple(a,\
    \ a.count!\"isUpper\".curried, a.count!\"isLower\".curried)));\n    res = res.sort!((a,\
    \ b) => b[1] - b[2] > a[1] - a[2]);\n    return class_name ~ \".\" ~ res[0][0];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeyxpwskq.d(24): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeyxpwskq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strong = \"\";\n    double strong_len =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double cap_len = 0;\n\
    \        double sm_len = 0;\n        foreach(ch; extension)\n        {\n     \
    \       if(ch.isUpper)\n                cap_len++;\n            else\n       \
    \         sm_len++;\n        }\n        if(cap_len - sm_len > strong_len)\n  \
    \      {\n            strong_len = cap_len - sm_len;\n            strong = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strong;\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0icn7cud.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0icn7cud.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float max_strength = 0.0;\n    int pos = 0;\n\
    \    float strength = 0.0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        strength = 0.0;\n        foreach (x; extensions[i])\n        {\n\
    \            if (isUpper(x))\n                strength++;\n            else\n\
    \                strength--;\n        }\n        if (strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            pos = i;\n     \
    \   }\n    }\n    return class_name ~ \".\" ~ extensions[pos];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw7elt0ss.d(32): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7elt0ss.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Get the strength of the extensions\n    string[]\
    \ strengths = new string[extensions.length];\n    foreach(i, ex; extensions)\n\
    \    {\n        int lower = 0;\n        int upper = 0;\n        foreach(c; ex)\n\
    \        {\n            if(std.ascii.isUpper(c))\n                upper++;\n \
    \           else\n                lower++;\n        }\n        auto temp = format(\"\
    %s.%d\", ex, (upper - lower));\n        strengths[i] = temp;\n    }\n    std.algorithm.sort(strengths);\n\
    \    // Get the strongest extension\n    string strongest = strengths[0];\n  \
    \  return format(\"%s.%s\", class_name, strongest[0..$-3]);\n}\n/*\nYou are given\
    \ an array of people's names. You should return a string which \nconsists of the\
    \ last names of each of the people in the array.\n    The last name of each person\
    \ is separated by a comma.\n    Example:\n    >>> Names_To_String([\"Jake\", \"\
    Bruce\", \"Cameron\"])\n    \"Jake,Bruce,Cameron\"\n*/\nstring Names_To_String(string[]\
    \ names) \n{\n    string name_string = \"\";\n    foreach(n; names)\n    {\n \
    \       auto pos = n.find(\" \");\n        if(pos > 0)\n            name_string\
    \ ~= format(\"%s,\", n[(pos+1)..$]);\n        else\n            name_string ~=\
    \ format(\"%s,\", n);\n    }\n    return name_string[0..$-1];\n}\n/*\nYou are\
    \ given a string, write a function that would reverse the words in it,\n    but\
    \ not the characters. For example, if the string is \"Bob likes Alice\",\n   \
    \ then the function should return \"Alice likes Bob\".\n    Example:\n    >>>\
    \ Reverse_Words(\"Bob likes Alice\")\n    \"Alice likes Bob\"\n*/\nstring Reverse_Words(string\
    \ words) \n{\n    return words.split(' ').reverse().join(' ');\n}\n/*\nYou are\
    \ given a string consisting of two or more words separated by \nwhitespace. You\
    \ are to return a\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpukd7uo98.d(78): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpukd7uo98.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double maxStrength = 0;\n    string strongest\
    \ = \"\";\n    foreach(ext; extensions)\n    {\n        double capNum = ext.count!(x\
    \ => x.isUpper);\n        double smNum = ext.count!(x => x.isLower);\n       \
    \ double strength = capNum - smNum;\n        if(strength > maxStrength)\n    \
    \    {\n            maxStrength = strength;\n            strongest = ext;\n  \
    \      }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2x2kp09u.d(28): Error: no property `count` for type `string`

    /tmp/tmp2x2kp09u.d(29): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2x2kp09u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return class_name+\".\"+highest.sort!((a,b) =>\
    \ a.strength>b.strength)(map!(extension => tuple(extension, (to!(int)(filter!(c\
    \ => isUpper(c))(extension)).length)-(to!(int)(filter!(c => isLower(c))(extension)).length)))(extensions))[0][0];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp87ihe8i4.d(24): Error: invalid array operation `class_name + "."`
    (possible missing [])

    /tmp/tmp87ihe8i4.d(24): Error: undefined identifier `highest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp87ihe8i4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongestExtension = \"\";\n    double\
    \ strongestStrength = double.min;\n    foreach(string extension; extensions)\n\
    \    {\n        double strength = (cap(extension) - lc(extension));\n        if(strength\
    \ > strongestStrength)\n        {\n            strongestStrength = strength;\n\
    \            strongestExtension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongestExtension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdtoz7pvl.d(25): Error: no property `min` for type `double`

    /tmp/tmpdtoz7pvl.d(28): Error: undefined identifier `cap`, did you mean template
    `cmp(T)(const(T) x, const(T) y) if (isFloatingPoint!T)`?

    /tmp/tmpdtoz7pvl.d(28): Error: undefined identifier `lc`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdtoz7pvl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double[] strengths = extensions.map!(extension\
    \ => to!double(extension.count!(a => a.isUpper) - extension.count!(a => a.isLower))).array;\n\
    \    int strongest_idx = strengths.maxIndex;\n    return class_name ~ \".\" ~\
    \ extensions[strongest_idx];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_s1ic17u.d(24): Error: no property `map` for type `string[]`

    /tmp/tmp_s1ic17u.d(25): Error: no property `maxIndex` for type `double[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_s1ic17u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int str_ext = 0;\n    int sm_ext = 0;\n    string\
    \ strongest_extension = \"\";\n    foreach(string ext; extensions)\n    {\n  \
    \      int strength = 0;\n        int str_count = 0;\n        int sm_count = 0;\n\
    \        foreach(char ch; ext)\n        {\n            if(isupper(ch))\n     \
    \       {\n                str_count++;\n            }\n            else\n   \
    \         {\n                sm_count++;\n            }\n        }\n        strength\
    \ = str_count - sm_count;\n        if(strength > str_ext)\n        {\n       \
    \     str_ext = strength;\n            strongest_extension = ext;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hidobiv.d(34): Error: undefined identifier `isupper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hidobiv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  double strength = 0;\n  string strongest_extension\
    \ = extensions[0];\n  foreach(extension; extensions)\n  {\n    double curr_strength\
    \ = 0;\n    foreach(letter; extension)\n    {\n      if(letter.isUpper) curr_strength++;\n\
    \      else curr_strength--;\n    }\n    if(curr_strength > strength)\n    {\n\
    \      strength = curr_strength;\n      strongest_extension = extension;\n   \
    \ }\n  }\n  return class_name ~ \".\" ~ strongest_extension;\n}\n//-----------------------------------------------------\n\
    /*\nYou will be given an array of alphanumeric characters. Your task is to\n \
    \   perform the following actions:\n    1. Go through the string and add all letters\
    \ to a new array. All letters\n    should be in lowercase and no duplicates allowed.\n\
    \    2. Go through the string and add all digits to a new array.\n    3. Sort\
    \ the letters alphabetically.\n    4. Sort the digits in order from smallest to\
    \ largest.\n    5. Take the first element from the letters array, add it to the\
    \ result\n    string and then delete it from the array. Take the first element\
    \ from the\n    digits array, add it to the result string and then delete it from\
    \ the array.\n    Keep doing this until you have exhausted either one of the two\
    \ arrays.\n    6. Return the result string.\n    Example:\n    >>> Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Code_Me(string[]\
    \ alphanumeric) \n{\n  string[] digits = [];\n  string[] letters = [];\n  foreach(symbol;\
    \ alphanumeric)\n  {\n    if(symbol.isAlpha) letters ~= symbol.toLower;\n    else\
    \ digits ~= symbol;\n  }\n  letters = sort(letters);\n  digits = sort(digits);\n\
    \  string result = \"\";\n  while(letters.length > 0 || digits.length > 0)\n \
    \ {\n    if(letters.length > 0)\n    {\n      result ~= letters[0];\n      letters\
    \ = letters[1..$];\n    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2xtqxenn.d(80): Error: found `unittest` instead of statement

    /tmp/tmp2xtqxenn.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2xtqxenn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap = 0;\n    int sm = 0;\n    double max\
    \ = 0;\n    string max_ext = \"\";\n    for (int i = 0; i < extensions.length;\
    \ i++) {\n        foreach (char c; extensions[i]) {\n            if (c.isUpper())\
    \ {\n                cap++;\n            } else {\n                sm++;\n   \
    \         }\n        }\n        if (cap - sm > max) {\n            max = cap -\
    \ sm;\n            max_ext = extensions[i];\n        }\n        cap = 0;\n   \
    \     sm = 0;\n    }\n    return class_name ~ \".\" ~ max_ext;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplia4vtwx.d(30): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplia4vtwx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return extensions.length == 0 \n        ? class_name\
    \ \n        : class_name ~ \".\" ~ extensions.filter!((string elt) { \n      \
    \      return elt.count!isUpper == abs(elt.count!isUpper - elt.count!isLower);\
    \ \n        }).min;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9qswag32.d(26): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9qswag32.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string name = \"\";\n    double strength = 0;\n\
    \    double strong = 0;\n    foreach(e; extensions)\n    {\n        name = e;\n\
    \        strength = 0;\n        foreach(i; name)\n        {\n            if(isUpper(i))\n\
    \            {\n                strength++;\n            }\n            else\n\
    \            {\n                strength--;\n            }\n        }\n      \
    \  if(strong < strength)\n        {\n            strong = strength;\n        \
    \    name = e;\n        }\n    }\n    return class_name ~ \".\" ~ name;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm4q_k7_u.d(33): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm4q_k7_u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real maxStrength = 0;\n    string result;\n  \
    \  string currentExtension;\n    int CAP;\n    int SM;\n    foreach(currentExtension;\
    \ extensions)\n    {\n        CAP = std.string.countChars(currentExtension, (x){return\
    \ x.isUpper();});\n        SM = std.string.countChars(currentExtension, (x){return\
    \ x.isLower();});\n        if(CAP - SM > maxStrength)\n        {\n           \
    \ maxStrength = CAP - SM;\n            result = format(\"%s.%s\", class_name,\
    \ currentExtension);\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplhm94mgy.d(29): Error: variable `currentExtension` is shadowing
    variable `tmplhm94mgy.Strongest_Extension.currentExtension`

    /tmp/tmplhm94mgy.d(31): Error: undefined identifier `string` in package `std`

    /tmp/tmplhm94mgy.d(32): Error: undefined identifier `string` in package `std`

    /tmp/tmplhm94mgy.d(36): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplhm94mgy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string best_extension = \"\";\n    double best_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        int cap = 0;\n\
    \        int sm = 0;\n        foreach(char c; extension)\n        {\n        \
    \    if(c.isUpper)\n                cap++;\n            else\n               \
    \ sm++;\n        }\n        double strength = cast(double)cap - sm;\n        if(strength\
    \ > best_extension_strength)\n        {\n            best_extension_strength =\
    \ strength;\n            best_extension = extension;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ best_extension;\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2phi61ct.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2phi61ct.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest_extension_strength = -1;\n    string\
    \ strongest_extension_name = \"\";\n    int extension_strength = 0;\n    foreach(extension;\
    \ extensions)\n    {\n        extension_strength = extension.countOf!(ch => ch.isUpper)\
    \ - extension.countOf!(ch => ch.isLower);\n        if(extension_strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = extension_strength;\n \
    \           strongest_extension_name = extension;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest_extension_name;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpki5qvhg9.d(29): Error: no property `countOf` for type `string`

    /tmp/tmpki5qvhg9.d(29): Error: no property `countOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpki5qvhg9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = -1.1f;\n    string strongest_extension\
    \ = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        float\
    \ strength = 0.0f;\n        for (int j = 0; j < extensions[i].length; j++)\n \
    \       {\n            if (extensions[i][j] <= 'Z')\n                strength\
    \ += 1.0f;\n            else\n                strength -= 1.0f;\n        }\n \
    \       if (strength > strongest)\n        {\n            strongest = strength;\n\
    \            strongest_extension = extensions[i];\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoiw9wu1b.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x42925d]

    ??:? void tmpoiw9wu1b.__unittest_L44_C1() [0x427f97]

    ??:? void tmpoiw9wu1b.__modtest() [0x4284c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dbab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428fb6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aa59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aae8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a9e5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f8d]

    ??:? runModuleUnitTests [0x42d981]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429720]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result;\n    real strongest = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        real cap = 0;\n        real sm = 0;\n\
    \        foreach(char letter; extension)\n        {\n            if(letter >=\
    \ 'A' && letter <= 'Z')\n            {\n                cap += 1;\n          \
    \  }\n            else if(letter >= 'a' && letter <= 'z')\n            {\n   \
    \             sm += 1;\n            }\n        }\n        real strength = cap\
    \ - sm;\n        if(strength > strongest)\n        {\n            strongest =\
    \ strength;\n            result = class_name ~ \".\" ~ extension;\n        }\n\
    \    }\n    return result;\n}\n/*\nYou will be given an array of integers and\
    \ a target value.\n    You should find the number of pairs of integers in the\
    \ array that has the\n    difference equal to the target value. A pair is considered\
    \ a single pair,\n    the order of the values doesn't matter.\n    For example,\
    \ if you are given the array [1, 2, 3, 4] and the target value\n    is 1 then\
    \ you should return 3 because there are three pairs of integers\n    that have\
    \ a difference of 1 in the array: (1, 2), (2, 3) and (3, 4).\n    Example:\n \
    \   >>> target_difference([1, 2, 3, 4], 1)\n    3\n*/\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string output = \"\";\n    double max_strength\
    \ = double.min;\n    string max_extension = \"\";\n    foreach(e; extensions)\n\
    \    {\n        double upper = 0;\n        double lower = 0;\n        foreach(c;\
    \ e)\n        {\n            if(c.isUpper)\n            {\n                upper++;\n\
    \            }\n            else\n            {\n                lower++;\n  \
    \          }\n        }\n        double strength = upper / lower;\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   max_extension = e;\n        }\n    }\n    return format(\"%s.%s\", class_name,\
    \ max_extension);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl4ju6zi1.d(25): Error: no property `min` for type `double`

    /tmp/tmpl4ju6zi1.d(33): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpl4ju6zi1.d(49): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl4ju6zi1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int CAP = 0;\n    int SM = 0;\n    string rv =\
    \ \"\";\n    double [string] strength = [];\n    foreach(item; extensions) \n\
    \    {\n        item = item.toLower();\n        CAP = 0;\n        SM = 0;\n  \
    \      foreach(i; item)\n        {\n            if(i >= 'A' && i <= 'Z')\n   \
    \         {\n                CAP++;\n            }\n            else\n       \
    \     {\n                SM++;\n            }\n        }\n        //writefln(\"\
    item: %s, CAP: %d, SM: %d\", item, CAP, SM);\n        strength[item] = double(CAP)\
    \ - double(SM);\n    }\n    double max_strength = -INFINITY;\n    foreach(item;\
    \ strength)\n    {\n        if(item.value > max_strength)\n        {\n       \
    \     max_strength = item.value;\n            rv = item.key;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ rv;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmporp5kl_e.d(27): Error: cannot have associative array key of `void`

    /tmp/tmporp5kl_e.d(30): Error: no property `toLower` for type `string`

    /tmp/tmporp5kl_e.d(47): Error: undefined identifier `INFINITY`

    /tmp/tmporp5kl_e.d(50): Error: no property `value` for type `double`

    /tmp/tmporp5kl_e.d(52): Error: no property `value` for type `double`

    /tmp/tmporp5kl_e.d(53): Error: no property `key` for type `double`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmporp5kl_e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n    auto exts = extensions.map!((x) => mixin(\"\
    x.length\")).array;\n    auto strength = extensions.map!((x) => x.filter!((y)\
    \ => y.isUpper).length - x.filter!((y) => y.isLower).length).array;\n    int i\
    \ = 0;\n    int max = strength[0];\n    int index = 0;\n    foreach(ex; extensions)\n\
    \    {\n        if(max < strength[i])\n        {\n            max = strength[i];\n\
    \            index = i;\n        }\n        i++;\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ohzqvhw.d(25): Error: no property `map` for type `string[]`

    /tmp/tmp8ohzqvhw.d(26): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ohzqvhw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //Parameters: \n    //class_name(string): the\
    \ name of the class.\n    //extensions(string[]): the list of extensions.\n  \
    \  //Returns: string\n    // the strongest extension.\n    // Constraints: \n\
    \    //   \u2022 All names consist of letters, there are no numbers and no symbols.\n\
    \    //   \u2022 The extension name can be longer than the class name.\n    //\
    \   \u2022 class_name and extensions are not empty and they contain at least one\
    \ \n    //   element.\n    auto extension_strength = [](string extension) {\n\
    \        int CAP = 0;\n        int SM = 0;\n        for (char ch : extension)\
    \ {\n            if (isUpper(ch)) {\n                CAP++;\n            } else\
    \ {\n                SM++;\n            }\n        }\n        return tuple(CAP,\
    \ SM);\n    };\n    tuple best_extension = tuple(0,0);\n    string best_extension_name\
    \ = \"\";\n    foreach (extension; extensions) {\n        tuple current_extension\
    \ = extension_strength(extension);\n        if (current_extension[0] > best_extension[0])\
    \ {\n            best_extension = current_extension;\n            best_extension_name\
    \ = extension;\n        } else if (current_extension[0] == best_extension[0])\
    \ {\n            if (current_extension[1] < best_extension[1]) {\n           \
    \     best_extension = current_extension;\n                best_extension_name\
    \ = extension;\n            }\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ best_extension_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpovblacp2.d(34): Error: found `extension` when expecting `,`

    /tmp/tmpovblacp2.d(34): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpovblacp2.d(37): Error: semicolon expected, not `:`

    /tmp/tmpovblacp2.d(37): Error: expression expected, not `:`

    /tmp/tmpovblacp2.d(37): Error: found `extension` when expecting `;` following
    `for` condition

    /tmp/tmpovblacp2.d(45): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpovblacp2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto cmp1 = cmp(a, b) { return a > b; };\n   \
    \ auto cmp2 = cmp(a, b) { return a < b; };\n    auto ext2strength = ext =>\n \
    \   {\n        ext.toUpper().filter!((x) => x.isUpper).length \n            -\
    \ ext.toLower().filter!((x) => x.isLower).length;\n    };\n    return format(\"\
    %s.%s\", class_name, extensions.sort!(cmp1, cmp2, ext2strength)[0]);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc8mgcf86.d(24): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpc8mgcf86.d(24): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpc8mgcf86.d(25): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpc8mgcf86.d(25): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc8mgcf86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    int current_strength\
    \ = 0;\n    string max_extension = \"\";\n    foreach(string extension; extensions)\n\
    \    {\n        current_strength = 0;\n        foreach(char letter; extension)\n\
    \        {\n            if(isUpper(letter))\n            {\n                current_strength\
    \ += 1;\n            }\n            else if(isLower(letter))\n            {\n\
    \                current_strength -= 1;\n            }\n        }\n        if(current_strength\
    \ > max_strength)\n        {\n            max_strength = current_strength;\n \
    \           max_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpep5w8fyp.d(32): Error: undefined identifier `isUpper`

    /tmp/tmpep5w8fyp.d(36): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpep5w8fyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto x = zip(extensions,map!(x => countUntil!(isUpper,true)(x.idup),extensions)).enumerate;\n\
    \    auto y = x.filter!(a => a[1][1] != 0).sort!(b => b[1][1]).array;\n    return\
    \ class_name ~ \".\" ~ y[$-1][1][0];\n}\nstatic struct Point{\n\tfloat x;\n\t\
    float y;\n\t\n\tthis(float x, float y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\
    }\n\t\n\tint hashof(){\n\t\treturn x.hashof ^ y.hashof;\n\t}\n\t\n\tbool opEquals(Point\
    \ p){\n\t\treturn this.x == p.x && this.y == p.y;\n\t}\n\t\n\tfloat getDistance(Point\
    \ p){\n\t\treturn sqrt((this.x - p.x)^2 + (this.y - p.y)^2);\n\t}\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcwy8izx2.d(24): Error: undefined identifier `zip`

    /tmp/tmpcwy8izx2.d(38): Error: no property `hashof` for type `float`

    /tmp/tmpcwy8izx2.d(38): Error: no property `hashof` for type `float`

    /tmp/tmpcwy8izx2.d(46): Error: `this.x - p.x` is not of integral type, it is a
    `float`

    /tmp/tmpcwy8izx2.d(46): Error: `cast(float)2 + (this.y - p.y)` is not of integral
    type, it is a `float`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcwy8izx2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strength;\n    float best_strength = -1000.0f;\n\
    \    string best_extension = \"\";\n    foreach(extension; extensions)\n    {\n\
    \        strength = 0.0f;\n        foreach(char ch; extension)\n        {\n  \
    \          if(ch >= 'A' && ch <= 'Z')\n            {\n                strength\
    \ += 1.0f;\n            }\n            else if(ch >= 'a' && ch <= 'z')\n     \
    \       {\n                strength -= 1.0f;\n            }\n        }\n     \
    \   if(strength > best_strength)\n        {\n            best_strength = strength;\n\
    \            best_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ best_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension;\n\
    \    foreach(string ext; extensions)\n    {\n        int strength = 0;\n     \
    \   foreach(char c; ext)\n        {\n            if(isupper(c)) strength++;\n\
    \            else if(islower(c)) strength--;\n        }\n        if(strength >\
    \ max_strength)\n        {\n            max_strength = strength;\n           \
    \ strongest_extension = ext;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe7_x_axo.d(31): Error: undefined identifier `isupper`

    /tmp/tmpe7_x_axo.d(32): Error: undefined identifier `islower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe7_x_axo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest_strength;\n    string strongest_extension;\n\
    \    foreach(e; extensions)\n    {\n        double cap = 0;\n        double sm\
    \ = 0;\n        foreach(c; e)\n        {\n            if (toUpper(c) == c)\n \
    \               cap++;\n            else\n                sm++;\n        }\n \
    \       double strength = cap - sm;\n        if (strongest_strength < strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = e;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\n/*\nYou will be given 3 positive integers: a, b and n.\n    You have to output\
    \ an array of integers, each of which is formed by multiplying\n    a by b n-1\
    \ times, (i.e. a, a*b, a*b*b, a*b*b*b, ...).\n    You have to print the array\
    \ from the smallest value to the largest one.\n    If any of these elements is\
    \ greater than or equal to 2^32, then you should \n    output 'Overflow' in place\
    \ of that element.\n    Example:\n    >>> overflow(1, 2, 10)\n    [1, 2, 4, 8,\
    \ 16, 32, 64, 128, 256, 512]\n    >>> overflow(1, 1, 20)\n    [1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> overflow(3, 2, 32)\n \
    \   [3, 6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144, 12288, 24576, 49152,\n\
    \     98304, 196608, 393216, 786432, 1572864, 3145728, 6291456, 12582912, 25165824,\n\
    \     50331648, 100663296, 201326592, 402653184, 805306368, 1610612736, 3221225472,\n\
    \     'Overflow']\n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplrrod0ft.d(32): Error: undefined identifier `toUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrrod0ft.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = -1000;\n    string max_strength_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = \n            cast(double)sum(filter!(ch => ch.isUpper())(extension)) -\n\
    \            cast(double)sum(filter!(ch => ch.isLower())(extension));\n      \
    \  if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            max_strength_extension = extension;\n        }\n    }\n    return\
    \ format(\"%s.%s\", class_name, max_strength_extension);\n}\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpft01d_pr.d(29): Error: undefined identifier `sum`

    /tmp/tmpft01d_pr.d(30): Error: undefined identifier `sum`

    /tmp/tmpft01d_pr.d(37): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpft01d_pr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = 0;\n    string strongest_ext\
    \ = \"\";\n    foreach(string ext; extensions)\n    {\n        int uppercase =\
    \ 0;\n        int lowercase = 0;\n        for(int i = 0; i < ext.length; i++)\n\
    \        {\n            if(ext[i] == toupper(ext[i]))\n            {\n       \
    \         uppercase++;\n            }\n            else\n            {\n     \
    \           lowercase++;\n            }\n        }\n        double strength =\
    \ uppercase - lowercase;\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_ext = ext;\n       \
    \ }\n    }\n    return class_name ~ \".\" ~ strongest_ext;\n}\n/*\nYou are given\
    \ a string of positive integers. Your task is to return a string \nthat shows\
    \ how many times each digit was used in the original string.\n    For example:\n\
    \    >>> Histogram(\"0123456789\")\n    \"0000000000: 1 | 000000000: 0 | 00000000:\
    \ 0 | 0000000: 0 | 000000: 0 | 00000: 0 | 0000: 0 | 000: 0 | 00: 0 | 0: 0\"\n\
    \    >>> Histogram(\"1122\")\n    \"0000000000: 0 | 000000000: 0 | 00000000: 0\
    \ | 0000000: 0 | 000000: 0 | 00000: 0 | 0000: 0 | 000: 0 | 00: 1 | 0: 1\"\n  \
    \  >>> Histogram(\"11000110000\")\n    \"0000000000: 2 | 000000000: 0 | 00000000:\
    \ 1 | 0000000: 0 | 000000: 0 | 00000: 0 | 0000: 2 | 000: 0 | 00: 1 | 0: 1\"\n\
    \    The string should be formatted in this way:\n    \"<digit>: <count> | <digit>:\
    \ <count> | <digit>: <count> | ... | <digit>: <count>\"\n*/\nstring Histogram(string\
    \ input) \n{\n    string result = \"\";\n    int[] counts = new int[10];\n   \
    \ for(int i = 0; i < input.length; i++)\n    {\n        counts[to!int(input[i])]++;\n\
    \    }\n    for(int i = 0; i <\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyckilu_g.d(72): Error: expression expected, not `unittest`

    /tmp/tmpyckilu_g.d(73): Error: found `{` when expecting `;` following `for` condition

    /tmp/tmpyckilu_g.d(74): Error: expression expected, not `alias`

    /tmp/tmpyckilu_g.d(74): Error: found `candidate` when expecting `)`

    /tmp/tmpyckilu_g.d(74): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyckilu_g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strength = 0.0;\n    int curr_strength\
    \ = 0;\n    int x = 0;\n    foreach(ext; extensions)\n    {\n        int counter_upper\
    \ = 0;\n        int counter_lower = 0;\n        foreach(c; ext)\n        {\n \
    \           if(isLower(c))\n                counter_lower++;\n            else\
    \ if(isUpper(c))\n                counter_upper++;\n        }\n        double\
    \ tmp = counter_upper - counter_lower;\n        if(tmp > strength)\n        {\n\
    \            strength = tmp;\n            x = curr_strength;\n        }\n    \
    \    curr_strength++;\n    }\n    return class_name ~ \".\" ~ extensions[x];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpovbs0so7.d(33): Error: undefined identifier `isLower`

    /tmp/tmpovbs0so7.d(35): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpovbs0so7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string extension = extensions[0];\n    int strength\
    \ = (extension.count('A', 'Z') - extension.count('a', 'z'));\n    foreach(string\
    \ e; extensions)\n    {\n        int str = (e.count('A', 'Z') - e.count('a', 'z'));\n\
    \        if(str > strength)\n        {\n            strength = str;\n        \
    \    extension = e;\n        }\n    }\n    return class_name ~ \".\" ~ extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp344lwid2.d(25): Error: no property `count` for type `string`

    /tmp/tmp344lwid2.d(25): Error: no property `count` for type `string`

    /tmp/tmp344lwid2.d(28): Error: no property `count` for type `string`

    /tmp/tmp344lwid2.d(28): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp344lwid2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Code here\n    double s = 0;\n    int strongest\
    \ = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int sm\
    \ = extensions[i].count('a') + extensions[i].count('b') + extensions[i].count('c')\
    \ + extensions[i].count('d') + extensions[i].count('e') + extensions[i].count('f')\
    \ + extensions[i].count('g') + extensions[i].count('h') + extensions[i].count('i')\
    \ + extensions[i].count('j') + extensions[i].count('k') + extensions[i].count('l')\
    \ + extensions[i].count('m') + extensions[i].count('n') + extensions[i].count('o')\
    \ + extensions[i].count('p') + extensions[i].count('q') + extensions[i].count('r')\
    \ + extensions[i].count('s') + extensions[i].count('t') + extensions[i].count('u')\
    \ + extensions[i].count('v') + extensions[i].count('w') + extensions[i].count('x')\
    \ + extensions[i].count('y') + extensions[i].count('z');\n        int cap = extensions[i].count('A')\
    \ + extensions[i].count('B') + extensions[i].count('C') + extensions[i].count('D')\
    \ + extensions[i].count('E') + extensions[i].count('F') + extensions[i].count('G')\
    \ + extensions[i].count('H') + extensions[i].count('I') + extensions[i].count('J')\
    \ + extensions[i].count('K') + extensions[i].count('L') + extensions[i].count('M')\
    \ + extensions[i].count('N') + extensions[i].count('O') + extensions[i].count('P')\
    \ + extensions[i].count('Q') + extensions[i].count('R') + extensions[i].count('S')\
    \ + extensions[i].count('T') + extensions[i].count('U') + extensions[i].count('V')\
    \ + extensions[i].count('W') + extensions[i].count('X') + extensions[i].count('Y')\
    \ + extensions[i\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpumsdt52x.d(31): Error: found `unittest` when expecting `,`

    /tmp/tmpumsdt52x.d(45): Error: found `void` when expecting `,`

    /tmp/tmpumsdt52x.d(45): Error: found `{` when expecting `,`

    /tmp/tmpumsdt52x.d(45): Error: expression expected, not `}`

    /tmp/tmpumsdt52x.d(45): Error: found `End of File` when expecting `,`

    /tmp/tmpumsdt52x.d(45): Error: found `End of File` when expecting `]`

    /tmp/tmpumsdt52x.d(45): Error: semicolon expected, not `End of File`

    /tmp/tmpumsdt52x.d(45): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpumsdt52x.d(45): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpumsdt52x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float highestStrength = float.min;\n    string\
    \ strongestExtension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        int upper = 0;\n        int lower = 0;\n        for (int j = 0;\
    \ j < extensions[i].length; j++)\n        {\n            if (extensions[i][j]\
    \ == extensions[i].toupper())\n            {\n                upper++;\n     \
    \       }\n            else\n            {\n                lower++;\n       \
    \     }\n        }\n        float currentStrength = float(upper) - float(lower);\n\
    \        if (currentStrength > highestStrength)\n        {\n            highestStrength\
    \ = currentStrength;\n            strongestExtension = extensions[i];\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongestExtension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphucnf886.d(24): Error: no property `min` for type `float`

    /tmp/tmphucnf886.d(32): Error: no property `toupper` for type `string`

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tint max_strength = 0;\n\tstring strongest = \"\"\
    ;\n\t\n\tforeach(string extension; extensions)\n\t{\n\t\tint strength = 0;\n\t\
    \tforeach(char letter; extension)\n\t\t{\n\t\t\tif(isUpper(letter))\n\t\t\t\t\
    strength++;\n\t\t\telse\n\t\t\t\tstrength--;\n\t\t}\n\t\tif(strength > max_strength)\n\
    \t\t{\n\t\t\tmax_strength = strength;\n\t\t\tstrongest = extension;\n\t\t}\n\t\
    }\n\treturn class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_mu25sm.d(32): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_mu25sm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongestExtension;\n    float maximumStrength\
    \ = 0;\n    float currentStrength = 0;\n    foreach(extension; extensions)\n \
    \   {\n        currentStrength = to!float(countUpper(extension)) - to!float(countLower(extension));\n\
    \        if(currentStrength > maximumStrength)\n        {\n            maximumStrength\
    \ = currentStrength;\n            strongestExtension = extension;\n        }\n\
    \    }\n    return strongestExtension;\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsldb7c56.d(29): Error: template instance `to!float` template `to`
    is not defined, did you mean No?

    /tmp/tmpsldb7c56.d(29): Error: template instance `to!float` template `to` is not
    defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsldb7c56.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest_extension = double.max;\n   \
    \ string extension_name = \"\";\n    foreach(string extension; extensions) {\n\
    \        uint uppercase_count = countUntil((cast(const(char)*)extension)[], \n\
    \            isLower);\n        uint lowercase_count = countUntil((cast(const(char)*)extension)[],\
    \ \n            isUpper);\n        double extension_strength = uppercase_count\
    \ - lowercase_count;\n        if(extension_strength < strongest_extension) {\n\
    \            strongest_extension = extension_strength;\n            extension_name\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ extension_name;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa2409c8n.d(27): Error: undefined identifier `countUntil`

    /tmp/tmpa2409c8n.d(29): Error: undefined identifier `countUntil`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa2409c8n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max = 0;\n    int idx = 0;\n    string\
    \ result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n   \
    \     int cap = count(extensions[i].filter!isUpper);\n        int sm = count(extensions[i].filter!isLower);\n\
    \        if (cap - sm > max)\n        {\n            max = cap - sm;\n       \
    \     idx = i;\n        }\n    }\n    result = class_name ~ \".\" ~ extensions[idx];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdhx8v5r8.d(29): Error: undefined identifier `count`

    /tmp/tmpdhx8v5r8.d(30): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdhx8v5r8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = std.min(int.min, 1);\n    string\
    \ result = \"\";\n    foreach(string ext; extensions)\n    {\n        int CAP\
    \ = 0;\n        int SM = 0;\n        foreach(char c; ext)\n        {\n       \
    \     CAP += c.isUpper;\n            SM += c.isLower;\n        }\n        int\
    \ strength = CAP - SM;\n        if(strength > max_strength)\n        {\n     \
    \       max_strength = strength;\n            result = ext;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl6i5xwsj.d(24): Error: undefined identifier `min` in package `std`

    /tmp/tmpl6i5xwsj.d(32): Error: no property `isUpper` for type `char`

    /tmp/tmpl6i5xwsj.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl6i5xwsj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Write your code here.\n    int l = extensions.length;\n\
    \    string res = \"\";\n    int maxStrength = 0;\n    for (int i = 0; i < l;\
    \ i++) {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j\
    \ < extensions[i].length; j++) {\n            if (extensions[i][j] == toUpper(extensions[i][j]))\
    \ {\n                cap++;\n            } else {\n                sm++;\n   \
    \         }\n        }\n        if (cap - sm > maxStrength) {\n            maxStrength\
    \ = cap - sm;\n            res = extensions[i];\n        }\n    }\n    return\
    \ class_name + \".\" + res;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7p9wikw9.d(25): Error: cannot implicitly convert expression `extensions.length`
    of type `ulong` to `int`

    /tmp/tmp7p9wikw9.d(32): Error: undefined identifier `toUpper`

    /tmp/tmp7p9wikw9.d(43): Error: invalid array operation `class_name + "."` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7p9wikw9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float previous_strength = 0.0f;\n    int previous_index\
    \ = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int upper_case_count\
    \ = 0;\n        int lower_case_count = 0;\n        for (int j = 0; j < extensions[i].length;\
    \ j++)\n        {\n            if (is_upper(extensions[i][j]))\n            {\n\
    \                upper_case_count++;\n            }\n            else\n      \
    \      {\n                lower_case_count++;\n            }\n        }\n    \
    \    float current_strength = float(upper_case_count) - float(lower_case_count);\n\
    \        if (current_strength > previous_strength)\n        {\n            previous_strength\
    \ = current_strength;\n            previous_index = i;\n        }\n    }\n   \
    \ return class_name ~ \".\" ~ extensions[previous_index];\n}\nunittest\n{\n  \
    \  alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr_rq42zj.d(32): Error: undefined identifier `is_upper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_rq42zj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float[] strength = new float[0];\n    int[] caps\
    \ = new int[0];\n    int[] sms = new int[0];\n    float stren;\n    int cap;\n\
    \    int sm;\n    string result;\n    int i;\n    int ctr = 0;\n    foreach(var\
    \ ext in extensions)\n    {\n        strength ~= stren = 0;\n        caps ~= cap\
    \ = 0;\n        sms ~= sm = 0;\n        foreach(var c in ext)\n        {\n   \
    \         if(c >= 'A' && c <= 'Z')\n            {\n                stren++;\n\
    \                cap++;\n            }\n            else if(c >= 'a' && c <= 'z')\n\
    \            {\n                stren--;\n                sm++;\n            }\n\
    \        }\n        strength[ctr] = stren;\n        caps[ctr] = cap;\n       \
    \ sms[ctr] = sm;\n        ctr++;\n    }\n    float strongest = max(strength);\n\
    \    int index = strength.indexOf(strongest);\n    result = class_name ~ \".\"\
    \ ~ extensions[index];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgw421uqr.d(33): Error: found `in` when expecting `;`

    /tmp/tmpgw421uqr.d(38): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgw421uqr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  float strngth = 0;\n  int strngth_cap = 0;\n  int\
    \ strngth_sm = 0;\n  float strngth_result = 0;\n  string result = \"\";\n  string\
    \ result_class_name = \"\";\n  string result_extension_name = \"\";\n  foreach(i;\
    \ 0 .. extensions.length)\n  {\n    foreach(j; 0 .. extensions[i].length)\n  \
    \  {\n      if (extensions[i][j] <= 90)\n      {\n        strngth_cap = strngth_cap\
    \ + 1;\n      }\n      else\n      {\n        strngth_sm = strngth_sm + 1;\n \
    \     }\n    }\n    strngth = strngth_cap - strngth_sm;\n    if (strngth == strngth_result)\n\
    \    {\n      if (result_extension_name > extensions[i])\n      {\n        result_extension_name\
    \ = extensions[i];\n      }\n    }\n    if (strngth > strngth_result)\n    {\n\
    \      strngth_result = strngth;\n      result_extension_name = extensions[i];\n\
    \    }\n    strngth_cap = 0;\n    strngth_sm = 0;\n  }\n  result_class_name =\
    \ class_name;\n  result = result_class_name ~ \".\" ~ result_extension_name;\n\
    \  return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwymyex3e.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x4293cd]

    ??:? void tmpwymyex3e.__unittest_L64_C1() [0x4280c3]

    ??:? void tmpwymyex3e.__modtest() [0x428634]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dd6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x429126]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ac1d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42acac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aba9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4290fd]

    ??:? runModuleUnitTests [0x42db45]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4298e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string[] temp;\n    class strongest\n    {\n \
    \       string name;\n        int strength;\n    }\n    strongest test = new strongest;\n\
    \    test.name = extensions[0];\n    test.strength = to!int((count(class_name,\
    \ isupper) - count(class_name, islower)));\n    foreach(string i; extensions)\n\
    \    {\n        temp = i.split(\"_\");\n        if(test.strength <= to!int((count(i,\
    \ isupper) - count(i, islower))))\n        {\n            test.name = i;\n   \
    \         test.strength = to!int((count(i, isupper) - count(i, islower)));\n \
    \       }\n    }\n    return class_name + \".\" + test.name;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpynay5ite.d(32): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    /tmp/tmpynay5ite.d(35): Error: no property `split` for type `string`

    /tmp/tmpynay5ite.d(36): Error: template instance `to!int` template `to` is not
    defined, did you mean No?

    /tmp/tmpynay5ite.d(39): Error: template instance `to!int` template `to` is not
    defined, did you mean No?

    /tmp/tmpynay5ite.d(42): Error: invalid array operation `class_name + "."` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpynay5ite.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n}\n/*\nThe value of a positive integer n is\
    \ defined to be the sum of all the positive divisors of n. \n    We define N(n)\
    \ to be the sum of all values of n. You are given an array of positive integers\
    \ A. \n    For each element in the array find the sum of all values which are\
    \ less than or equal to that element. \n    For example if A[i] = 5 then N(A[i])\
    \ = 1 + 2 + 3 + 4 + 5 = 15. You should return an array containing \n    the values\
    \ N(A[0]), N(A[1]), ..., N(A[N-1]).\n    Example:\n    >>> Divisor_Sum_Array([1,\
    \ 5, 10])\n    [1, 15, 55]\n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4how_euw.d(22): Error: function `tmp4how_euw.Strongest_Extension`
    has no `return` statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4how_euw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = 0.0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions) {\n        float cap = countUntil!((x)\
    \ => (x >= 'A' && x <= 'Z'))(extension.sli\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpodwc2iks.d(28): Error: found `unittest` when expecting `,`

    /tmp/tmpodwc2iks.d(42): Error: found `void` when expecting `,`

    /tmp/tmpodwc2iks.d(42): Error: found `{` when expecting `,`

    /tmp/tmpodwc2iks.d(42): Error: expression expected, not `}`

    /tmp/tmpodwc2iks.d(42): Error: found `End of File` when expecting `,`

    /tmp/tmpodwc2iks.d(42): Error: found `End of File` when expecting `)`

    /tmp/tmpodwc2iks.d(42): Error: semicolon expected, not `End of File`

    /tmp/tmpodwc2iks.d(42): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpodwc2iks.d(42): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpodwc2iks.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongness = 0;\n    string strongest =\
    \ \"\";\n    foreach(string extension; extensions)\n    {\n        double tmp\
    \ = 0;\n        foreach(char ch; extension)\n        {\n            if (isupper(ch))\
    \ tmp += 1;\n            else tmp -= 1;\n        }\n        if (tmp > strongness)\
    \ \n        {\n            strongness = tmp;\n            strongest = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\n/*\n    This\
    \ is a one-dimensional version of the Lights Out puzzle. You will be given\n \
    \   an array (a) which contains a boolean value in each position. Every light\
    \ can \n    be either on or off. The goal is to turn all of the lights off. Every\
    \ light has\n    a switch which can be flipped to turn that light either on or\
    \ off. When you flip\n    a switch all of the lights to the right of the switch's\
    \ position flip their \n    states. You must return the minimum number of switches\
    \ that need to be flipped\n    to turn all of the lights off.\n    Example:\n\
    \    >>> Light_Out([1,1,1,1,1,1,1,1,1,1])\n    4\n*/\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3cu_o8ed.d(31): Error: undefined identifier `isupper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3cu_o8ed.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    ulong max = 0;\n    string extension = \"\";\n\
    \    foreach(e; extensions)\n    {\n        uint upper = 0;\n        uint lower\
    \ = 0;\n        foreach(c; e)\n        {\n            if(isUpper(c)) upper++;\n\
    \            else lower++;\n        }\n        long strength = (long)upper - (long)lower;\n\
    \        if(strength > max)\n        {\n            max = strength;\n        \
    \    extension = e;\n        }\n    }\n    return class_name ~ \".\" ~ extension;\n\
    }\n/*\nYou have an array of integers. You should find the smallest positive integer\n\
    \    that is not present in the array. The array may contain negative numbers,\
    \ \n    zeros and positive numbers.\n    For example, in the array [1, 2, 3] the\
    \ smallest positive integer not\n    present is 4. In the array [-1, -3] the smallest\
    \ positive integer not\n    present is 1.\n    Example:\n    >>> Find_The_Smallest_Positive_Integer_Missing([1,\
    \ 2, 3])\n    4\n    >>> Find_The_Smallest_Positive_Integer_Missing([-1, -3])\n\
    \    1\n    >>> Find_The_Smallest_Positive_Integer_Missing([0, 5, -1, 1, 2, 5,\
    \ 3])\n    4\n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyhsb7euj.d(35): Error: C style cast illegal, use `cast(long)upper`

    /tmp/tmpyhsb7euj.d(35): Error: C style cast illegal, use `cast(long)lower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhsb7euj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164344
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tdouble maxStrength = -100;\n\tint indx = 0;\n\t\
    for (int i = 0; i < extensions.length; i++) {\n\t\tdouble strength = 0;\n\t\t\
    for (int j = 0; j < extensions[i].length; j++) {\n\t\t\tif (extensions[i][j] >=\
    \ 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\tstrength += 1;\n\t\t\t} else {\n\t\
    \t\t\tstrength -= 1;\n\t\t\t}\n\t\t}\n\t\tif (strength > maxStrength) {\n\t\t\t\
    maxStrength = strength;\n\t\t\tindx = i;\n\t\t}\n\t}\n\treturn class_name + \"\
    .\" + extensions[indx];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_zhosao_.d(40): Error: invalid array operation `class_name + "."`
    (possible missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_zhosao_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result;\n    int max_cap = 0;\n    string\
    \ max_string = extensions[0];\n    int cap_count;\n    int sm_count;\n    foreach(string\
    \ item; extensions)\n    {\n        cap_count = 0;\n        sm_count = 0;\n  \
    \      foreach(char c; item)\n        {\n            if(isUpper(c))\n        \
    \        cap_count++;\n            else\n                sm_count++;\n       \
    \ }\n        if(cap_count - sm_count > max_cap)\n        {\n            max_cap\
    \ = cap_count - sm_count;\n            max_string = item;\n        }\n    }\n\
    \    result = class_name ~ \".\" ~ max_string;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1lsm63cv.d(35): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1lsm63cv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct Extension \n    {\n        //string name;\n\
    \        int strength;\n    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxoci2jw9.d(29): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxoci2jw9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return class_name + \".\" + std.max(extensions,ext\
    \ => \n    {\n        return (ext.countif!(x => x.isupper()) - ext.countif!(x\
    \ => x.islower()));\n    });\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplezs4hm7.d(24): Error: invalid array operation `class_name + "."`
    (possible missing [])

    /tmp/tmplezs4hm7.d(24): Error: undefined identifier `max` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplezs4hm7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto rtn = class_name ~ \".\" ~ extensions[0];\n\
    \    int strongest_value = 0;\n    foreach(i, v; extensions)\n    {\n        auto\
    \ tmp = v.filter!(a => 'A' <= a && a <= 'Z').length;\n        tmp -= v.filter!(a\
    \ => 'a' <= a && a <= 'z').length;\n        if(tmp > strongest_value)\n      \
    \  {\n            strongest_value = tmp;\n            rtn = class_name ~ \".\"\
    \ ~ v;\n        }\n    }\n    return rtn;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmparkimnc0.d(28): Error: no property `filter` for type `string`

    /tmp/tmparkimnc0.d(29): Error: no property `filter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmparkimnc0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest_streng = 0;\n    string Strongest_Extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double upp\
    \ = extension.count!(a => a.isUpper);\n        double low = extension.count!(a\
    \ => a.isLower);\n        double strength = upp - low;\n        if(strength >\
    \ strongest_streng)\n        {\n            strongest_streng = strength;\n   \
    \         Strongest_Extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ Strongest_Extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9_t7ldvs.d(28): Error: no property `count` for type `string`

    /tmp/tmp9_t7ldvs.d(29): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_t7ldvs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    ulong index = 0, max = 0;\n    foreach(int i,\
    \ string ext; extensions)\n    {\n        ulong sum = count(ext.lowercase);\n\
    \        if (ext.length - sum > max)\n        {\n            max = ext.length\
    \ - sum;\n            index = i;\n        }\n    }\n    return class_name ~ \"\
    .\" ~ extensions[index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_2z5pujj.d(27): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_2z5pujj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double min_val = 1.1;\n    int min_ind = 0;\n\
    \    for (int i = 0; i < extensions.length; i++) {\n        double upper = 0.0;\n\
    \        double lower = 0.0;\n        foreach (c; extensions[i]) {\n         \
    \   if ('A' <= c && c <= 'Z')\n                upper += 1.0;\n            else\n\
    \                lower += 1.0;\n        }\n        double val = upper / lower;\n\
    \        if (val < min_val) {\n            min_val = val;\n            min_ind\
    \ = i;\n        }\n    }\n    return format(\"%s.%s\", class_name, extensions[min_ind]);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphnokzyr6.d(41): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphnokzyr6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real strongest = -real.max;\n    int strongest_i\
    \ = 0;\n    real temp = 0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        temp = 0;\n        foreach (char c; extensions[i])\n        {\n\
    \            if (toUpper(c) == c) temp += 1;\n            else temp -= 1;\n  \
    \      }\n        if (temp > strongest)\n        {\n            strongest = temp;\n\
    \            strongest_i = i;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ extensions[strongest_i];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double class_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    // For each extension, calculate the strength and return the strongest.\n\
    \    foreach(string ext; extensions) {\n        double upper_case = 0;\n     \
    \   double lower_case = 0;\n        // Check each character of each extension\
    \ to calculate the strength.\n        foreach(char c; ext) {\n            if(c\
    \ >= 'A' && c <= 'Z') {\n                upper_case++;\n            } else if(c\
    \ >= 'a' && c <= 'z') {\n                lower_case++;\n            }\n      \
    \  }\n        // Get the strength of the current extension.\n        double current_strength\
    \ = upper_case - lower_case;\n        // If the strength of the current extension\
    \ is greater than the\n        // strength of the previous extension, update the\
    \ name of the\n        // strongest extension.\n        if(current_strength >\
    \ class_strength) {\n            class_strength = current_strength;\n        \
    \    strongest_extension = ext;\n        }\n    }\n    return class_name + \"\
    .\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedz3g345.d(48): Error: invalid array operation `class_name + "."`
    (possible missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedz3g345.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto t = (auto x) {\n        int upper = 0;\n\
    \        int lower = 0;\n        foreach(i;0..x.length) {\n            if(x[i]\
    \ == 'a' || x[i] == 'b' || x[i] == 'c' || x[i] == 'd' || x[i] == 'e' || x[i] ==\
    \ 'f' || x[i] == 'g' || x[i] == 'h' || x[i] == 'i' || x[i] == 'j' || x[i] == 'k'\
    \ || x[i] == 'l' || x[i] == 'm' || x[i] == 'n' || x[i] == 'o' || x[i] == 'p' ||\
    \ x[i] == 'q' || x[i] == 'r' || x[i] == 's' || x[i] == 't' || x[i] == 'u' || x[i]\
    \ == 'v' || x[i] == 'w' || x[i] == 'x' || x[i] == 'y' || x[i] == 'z') {\n    \
    \            lower++;\n            } else {\n                upper++;\n      \
    \      }\n        }\n        return double(upper) - double(lower);\n    };\n \
    \   double strength = 0;\n    string name = \"\";\n    foreach(ext;extensions)\
    \ {\n        if(t(ext) > strength) {\n            strength = t(ext);\n       \
    \     name = ext;\n        }\n    }\n    string result = class_name ~ \".\" ~\
    \ name;\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptzvuplll.d(24): Error: variable `tmptzvuplll.Strongest_Extension.t`
    type `void` is inferred from initializer `(auto x)

    {

    int upper = 0;

    int lower = 0;

    foreach (i; 0 .. x.length)

    {

    if (x[i] == ''a'' || x[i] == ''b'' || x[i] == ''c'' || x[i] == ''d'' || x[i] ==
    ''e'' || x[i] == ''f'' || x[i] == ''g'' || x[i] == ''h'' || x[i] == ''i'' || x[i]
    == ''j'' || x[i] == ''k'' || x[i] == ''l'' || x[i] == ''m'' || x[i] == ''n'' ||
    x[i] == ''o'' || x[i] == ''p'' || x[i] == ''q'' || x[i] == ''r'' || x[i] == ''s''
    || x[i] == ''t'' || x[i] == ''u'' || x[i] == ''v'' || x[i] == ''w'' || x[i] ==
    ''x'' || x[i] == ''y'' || x[i] == ''z'')

    {

    lower++;

    }

    else

    {

    upper++;

    }

    }

    return double(upper) - double(lower);

    }

    `, and variables cannot be of type `void`

    /tmp/tmptzvuplll.d(24): Error: template lambda has no value

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptzvuplll.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.math : abs;\n    struct Ext { \n  \
    \      string name;\n        double strength;\n    }\n    Ext max_strength = null;\n\
    \    foreach(ext; extensions) {\n        int caps = 0;\n        int sms = 0;\n\
    \        foreach(c; ext) {\n            if(isupper(c)) caps++;\n            else\
    \ if(islower(c)) sms++;\n        }\n        if(max_strength.strength < (caps -\
    \ sms)) {\n            max_strength = Ext(ext, caps - sms);\n        }\n    }\n\
    \    return max_strength == null ? \"\" : class_name ~ \".\" ~ max_strength.name;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqs1sncqv.d(29): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Ext`

    /tmp/tmpqs1sncqv.d(34): Error: undefined identifier `isupper`

    /tmp/tmpqs1sncqv.d(35): Error: undefined identifier `islower`

    /tmp/tmpqs1sncqv.d(41): Error: incompatible types for `(max_strength) == (null)`:
    `Ext` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqs1sncqv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double maxStrength = -10000;\n    string answer\
    \ = class_name;\n    foreach(string ext; extensions)\n    {\n        double currentStrength\
    \ = 0;\n        foreach(char c; ext)\n        {\n            if(isUpper(c))\n\
    \                currentStrength++;\n            else if(isLower(c))\n       \
    \         currentStrength--;\n        }\n        if(currentStrength > maxStrength)\n\
    \        {\n            maxStrength = currentStrength;\n            answer = format(\"\
    %s.%s\", class_name, ext);\n        }\n    }\n    return answer;\n}\n/*\n    The\
    \ function first assigns value to -10000 to maxStrength and assigns \n    class_name\
    \ to answer.\n    Then it goes through each item of the array extensions.\n  \
    \  Then it goes through each character of each item of the array extensions.\n\
    \    If the character is an uppercase letter then currentStrength++.\n    If the\
    \ character is a lowercase letter then currentStrength--.\n    If currentStrength\
    \ is greater than maxStrength then maxStrength is assigned the \n    value of\
    \ currentStrength and answer is assigned the value of the format string.\n   \
    \ Answer is then returned.\n    \n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzwhxg1al.d(31): Error: undefined identifier `isUpper`

    /tmp/tmpzwhxg1al.d(33): Error: undefined identifier `isLower`

    /tmp/tmpzwhxg1al.d(39): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzwhxg1al.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string ret = class_name;\n    double max_str =\
    \ 0;\n    foreach(ext; extensions)\n    {\n        double str = 1.0 * count(ext.filter!(c\
    \ => c.isUpperCase())) -\n                     1.0 * count(ext.filter!(c => c.isLowerCase()));\n\
    \        if(str > max_str)\n        {\n            max_str = str;\n          \
    \  ret ~= \".\" ~ ext;\n        }\n    }\n    return ret;\n}\nunittest\n{\n  \
    \  alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8kn2dgq7.d(28): Error: undefined identifier `count`

    /tmp/tmp8kn2dgq7.d(29): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8kn2dgq7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest;\n    float value = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        float ext_value = 0;\n        foreach(wchar\
    \ t; ext)\n        {\n            if(isUpper(t))\n                ext_value++;\n\
    \            else\n                ext_value--;\n        }\n        if(ext_value\
    \ > value)\n        {\n            value = ext_value;\n            strongest =\
    \ ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpztaf731y.d(31): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztaf731y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double maxStrenght = 0;\n    string ans = \"\"\
    ;\n    foreach(string ext; extensions)\n    {\n        int CAP = 0;\n        int\
    \ SM = 0;\n        foreach(char a; ext)\n        {\n            if(isupper(a))\n\
    \                CAP++;\n            else\n                SM++;\n        }\n\
    \        double strenght = (double)CAP - SM;\n        if(strenght > maxStrenght)\n\
    \        {\n            maxStrenght = strenght;\n            ans = ext;\n    \
    \    }\n    }\n    return class_name ~ \".\" ~ ans;\n}\n/*\nYou are given a string\
    \ array, whose elements represent your current name and\n    surname. Your new\
    \ name should be created in this way:\n    Your surname becomes your first name;\n\
    \    Your first name becomes your middle name;\n    Your middle name becomes your\
    \ surname;\n    Example:\n    >>> rename(\"Fred\", \"Smith\")\n    [\"Smith\"\
    , \"Fred\", \"\"]\n    >>> rename(\"Alex\", \"Dowd\")\n    [\"Dowd\", \"\", \"\
    Alex\"]\n    >>> rename(\"James\", \"Earl Jones\")\n    [\"Jones\", \"James\"\
    , \"Earl\"]\n*/\nstring[] rename(string name, string surname) \n{\n    string[]\
    \ ans = {surname, name, \"\"};\n    if(surname.length > 2)\n    {\n        string\
    \ middle = surname[1..$-1];\n        ans[1] = surname[0..0];\n        ans[2] =\
    \ middle;\n    }\n    return ans;\n}\n/*\nYou are given a string array and a string.\
    \ The goal is to rearrange the order\n    of the elements in the array in such\
    \ a way that all occurrences of the\n    string find are in the beginning of the\
    \ array. The remaining elements in\n    the array should be in their original\
    \ order. Return the rearranged array.\n    Example:\n    >>> find_and_sort([\"\
    somethi\", \"notthing\", \"find\", \"find\"], \"find\")\n    [\"find\", \"find\"\
    , \"somethi\", \"notthing\"]\n*/\nstring[] find_and_sort(string[] array, string\
    \ find)\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6j07061x.d(37): Error: C style cast illegal, use `cast(double)CAP`

    /tmp/tmp6j07061x.d(81): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6j07061x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real strength = 0;\n    string result = \"\";\n\
    \    foreach(string str; extensions)\n    {\n        string temp = str;\n    \
    \    temp = temp.toLower();\n        //count lower case letters\n        real\
    \ small = temp.count(\"[a-z]\");\n        //count CAP case letters\n        real\
    \ CAP = str.count(\"[A-Z]\");\n        real temp_strength = CAP - small;\n   \
    \     if(temp_strength >= strength)\n        {\n            strength = temp_strength;\n\
    \            result = str;\n        }\n    }\n    return class_name ~ \".\" ~\
    \ result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbsipzvl1.d(29): Error: no property `toLower` for type `string`

    /tmp/tmpbsipzvl1.d(31): Error: no property `count` for type `string`

    /tmp/tmpbsipzvl1.d(33): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbsipzvl1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto temp = class_name;\n    double max_strength\
    \ = -1000;\n    int index = 0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        double strength = to!double(extensions[i].filter!(a => a.isUpper).length)\
    \ \n                            - to!double(extensions[i].filter!(a => a.isLower).length);\n\
    \        if (strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            index = i;\n        }\n    }\n    return temp ~ \".\" ~ extensions[index];\n\
    }\n/*\nYou will be given two integers, x and y. \n    You will be given a list\
    \ of strings, each string has a length of x + y. \n    Find the shortest substring\
    \ in the strings that has a length of x and a \n    length of y. \n    For example:\
    \ Given a string 'AABBABBABAABBBA' and x = 2 and y = 3, \n    the shortest substring\
    \ is 'BBB'. \n    Example:\n    >>> Shortest_Substring(2, 3, [\"AABBABBABAABBBA\"\
    , \"AABBABBABAABBB\"])\n    \"BBB\"\n*/\nstring Shortest_Substring(int x, int\
    \ y, string[] arr) \n{\n    string result = \"\";\n    auto temp = arr.front;\n\
    \    bool found = false;\n    while (temp.length >= x + y)\n    {\n        if\
    \ (temp.contains(result))\n        {\n            temp = temp[temp.indexOf(result)\
    \ + result.length .. temp.length];\n        }\n        if (temp.length < x + y)\n\
    \        {\n            temp = temp[0 .. temp.length];\n        }\n        else\n\
    \        {\n            temp = temp[0 .. x + y];\n        }\n        if (temp.length\
    \ == x + y)\n        {\n            found = true;\n            break;\n      \
    \  }\n    }\n    return temp;\n}\n/*\nYou will be given a list of points (x and\
    \ y coordinates) and a radius. \n    You\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp90jn7biq.d(77): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp90jn7biq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n    auto strengts = new int[](extensions.length);\n\
    \    foreach(int i, string extension; zip(i,extension; extensions))\n    {\n \
    \       auto caps = 0;\n        auto smalls = 0;\n        foreach(char c; extension)\n\
    \        {\n            if (isUpper(c)) caps++;\n            else smalls++;\n\
    \        }\n        strengts[i] = caps - smalls;\n    }\n    import std.conv;\n\
    \    auto max = strengts.max;\n    auto strongest_ext = to!string(max);\n    return\
    \ class_name ~ \".\" ~ extensions[strongest_ext];\n    \n    \n    \n    \n  \
    \  \n}\n \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvbso640t.d(26): Error: found `;` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvbso640t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    int max_idx = 0;\n\
    \    for (int i = 0; i < extensions.length; i++)\n    {\n        int CAP = extensions[i].count(\"\
    [A-Z]\");\n        int SM = extensions[i].count(\"[a-z]\");\n        int strength\
    \ = CAP - SM;\n        if (strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            max_idx = i;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[max_idx];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn65xzyqd.d(28): Error: no property `count` for type `string`

    /tmp/tmpn65xzyqd.d(29): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn65xzyqd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct my_extension{\n        string name;\n \
    \       int strength;\n    }\n    auto my_extensions = appender!(my_extension[])();\n\
    \    foreach(extension; extensions) {\n        int count_cap = 0;\n        int\
    \ count_small = 0;\n        foreach(ch; extension) {\n            if(ch.isUpper)\
    \ {\n                count_cap += 1;\n            }\n            else {\n    \
    \            count_small += 1;\n            }\n        }\n        my_extensions.put(my_extension(extension,\
    \ count_cap - count_small));\n    }\n    my_extension max_extension = max(my_extensions.data);\n\
    \    return class_name ~ \".\" ~ max_extension.name;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmhp44j4e.d(28): Error: template instance `appender!(my_extension[])`
    template `appender` is not defined

    /tmp/tmpmhp44j4e.d(33): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpmhp44j4e.d(42): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmhp44j4e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  int N = extensions.length;\n  int[] strength = new\
    \ int[N];\n  int max_strength = 0;\n  int max_strength_index = 0;\n  foreach(int\
    \ i, string ext; extensions)\n  {\n    int CAP = countUntil!(x => isUpper(x),\
    \ ext);\n    int SM = countUntil!(x => isLower(x), ext);\n    strength[i] = CAP\
    \ - SM;\n    if(strength[i] > max_strength)\n    {\n      max_strength = strength[i];\n\
    \      max_strength_index = i;\n    }\n  }\n  return class_name ~ \".\" ~ extensions[max_strength_index];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpawhh0kx1.d(24): Error: cannot implicitly convert expression `extensions.length`
    of type `ulong` to `int`

    /tmp/tmpawhh0kx1.d(30): Error: template instance `countUntil!((x) => isUpper(x),
    ext)` template `countUntil` is not defined

    /tmp/tmpawhh0kx1.d(31): Error: template instance `countUntil!((x) => isLower(x),
    ext)` template `countUntil` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpawhh0kx1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // your code here\n    import std.stdio;\n   \
    \ writefln(\"Class name : %s\", class_name);\n    foreach(e; extensions)\n   \
    \ {\n        writefln(\"Extensions : %s\", e);\n    }\n    return \"\";\n}\n/*\n\
    The \"Drones\" are coming! And they are ready to do some nasty things, \nyour\
    \ job is to stop them before they do it!\n    \nThe drone can only move in the\
    \ following directions: up, down, left, right.\n    \nThe drone finds its current\
    \ position on a map which is in the form of a 2D array, \nit then checks the array\
    \ for one of these characters: / - \\\n    If the drone sees any of those, it\
    \ makes a decision on which direction it should fly next.\n    We will be given\
    \ a string array which will contain the map and a drone starting position \n \
    \   as a tuple of two integers (x, y) where x is the horizontal position and y\
    \ is the vertical.\n    You should return the direction the drone will take next.\n\
    \    The order of priority for direction is: down, up, left, right.\n    For example,\
    \ if the array is:\n    <<<\n    [[' ', ' ', ' ', ' ', ' ', ' ', ' '],\n     ['\
    \ ', ' ', ' ', ' ', ' ', ' ', ' '],\n     [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n\
    \     [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n     [' ', ' ', ' ', ' ', ' ', ' ',\
    \ ' '],\n     [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n     [' ', ' ', ' ', ' ',\
    \ ' ', ' ', ' ']]\n    >>>\n    And the drone's current position is: (1, 1)\n\
    \    Then the drone will return 'right' (since it can't go up or down).\n    Example:\n\
    \    >>> Drone_Flight_Plan([[' ', ' ', ' ', ' ', ' ', ' ', ' '],\n           \
    \                [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n                      \
    \     [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n                           [' ', '\
    \ ', ' ', ' ', ' ', ' ', '\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkrs93znx.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkrs93znx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest = extensions[0].count('A') -\
    \ extensions[0].count('a');\n    string strongest_extension = extensions[0];\n\
    \    foreach(extension; extensions)\n    {\n        double strength = extension.count('A')\
    \ - extension.count('a');\n        if(strength > strongest)\n        {\n     \
    \       strongest = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv_i9339z.d(24): Error: no property `count` for type `string`

    /tmp/tmpv_i9339z.d(24): Error: no property `count` for type `string`

    /tmp/tmpv_i9339z.d(28): Error: no property `count` for type `string`

    /tmp/tmpv_i9339z.d(28): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv_i9339z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string answer = \"\";\n    float current_strength\
    \ = 0;\n    float strength = 0;\n    foreach(string extension; extensions)\n \
    \   {\n        strength = 0;\n        foreach(char ch; extension)\n        {\n\
    \            if(isUpper(ch))\n            {\n                strength += 1;\n\
    \            }\n            else\n            {\n                strength -= 1;\n\
    \            }\n        }\n        if(abs(strength) > abs(current_strength))\n\
    \        {\n            current_strength = strength;\n            answer = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ answer;\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc0ks9dji.d(32): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc0ks9dji.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double[] extension_strength = extensions.map!(x\
    \ => (x.count!(char.isUpper) - x.count!(char.isLower)) / double(x.length)).array;\n\
    \    string strongest_extension = extensions[extension_strength.indexOf(max(extension_strength))];\n\
    \    return $\"{class_name}.{strongest_extension}\";\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppw471vcr.d(26): Error: `$` is valid only inside [] of index or
    slice

    /tmp/tmppw471vcr.d(26): Error: found `"{class_name}.{strongest_extension}"` when
    expecting `;` following `return` statement

    /tmp/tmppw471vcr.d(26): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppw471vcr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int bestStrength = 0;\n    string strongestExtension\
    \ = \"\";\n    foreach(string ext; extensions)\n    {\n        int upperCase =\
    \ 0;\n        int lowerCase = 0;\n        foreach(wchar ch; ext)\n        {\n\
    \            if(ch.isUpper)\n                upperCase++;\n            else\n\
    \                lowerCase++;\n        }\n        int strength = upperCase - lowerCase;\n\
    \        if(strength > bestStrength)\n        {\n            bestStrength = strength;\n\
    \            strongestExtension = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongestExtension;\n}\n/*\nYou will be given the names of two classes\
    \ and a list of dependencies. Dependencies\nare the items that need to be initialized\
    \ before the given item. The function should\nreturn a sorted list of all the\
    \ given classes.\nExample:\n>>> Get_Sorted_Classes([\"A\", \"B\", \"C\"], [[\"\
    C\", \"A\"], [\"B\", \"A\"]])\n[\"A\", \"B\", \"C\"]\n*/\nstring[] Get_Sorted_Classes(string[]\
    \ classes, string[][] dependencies) \n{\n    auto classesMap = classes.map!(s\
    \ => s.toLower() => 0);\n    classes.each!(s => s.toLower() => 0);\n    foreach(string[]\
    \ dep; dependencies)\n    {\n        if(classesMap.contains(dep[0].toLower())\
    \ && classesMap.contains(dep[1].toLower()))\n        {\n            classesMap[dep[0].toLower()]++;\n\
    \            classesMap[dep[1].toLower()]--;\n        }\n    }\n    auto sortedClasses\
    \ = classesMap.map!(t => t.key)();\n    sortedClasses.sort!((a, b) => classesMap[a]\
    \ > classesMap[b]);\n    return sortedClasses;\n}\n/*\nYou will be given an array\
    \ of numbers and a value n. You should find the n-th \n    highest number in the\
    \ array and return it. If n is 0 or negative or larger\n    than the size of the\
    \ array, return 0.\n    Example:\n    >>> Find_Nth_Hig\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx6x6bukq.d(56): Error: found `=>` when expecting `)` following
    template argument list

    /tmp/tmpx6x6bukq.d(56): Error: semicolon expected following auto declaration,
    not `0`

    /tmp/tmpx6x6bukq.d(56): Error: found `)` when expecting `;` following statement

    /tmp/tmpx6x6bukq.d(56): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpx6x6bukq.d(57): Error: found `=>` when expecting `)` following template
    argument list

    /tmp/tmpx6x6bukq.d(57): Error: found `0` when expecting `;` following statement

    /tmp/tmpx6x6bukq.d(57): Error: found `)` instead of statement

    /tmp/tmpx6x6bukq.d(70): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx6x6bukq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return class_name ~ \".\" ~ maxExtension(extensions);\n\
    }\nprivate string maxExtension(string[] extensions)\n{\n    string max = extensions[0];\n\
    \    real maxStrength = Strength(max);\n    foreach(string extension; extensions)\n\
    \    {\n        real currStrength = Strength(extension);\n        if(currStrength\
    \ > maxStrength)\n        {\n            maxStrength = currStrength;\n       \
    \     max = extension;\n        }\n    }\n    return max;\n}\nprivate real Strength(string\
    \ extension)\n{\n    uint cap = 0;\n    uint sm = 0;\n    foreach(char c; extension)\n\
    \    {\n        if(isUpper(c))\n            cap++;\n        else\n           \
    \ sm++;\n    }\n    return (cap - sm) / extension.length;\n}\nprivate bool isUpper(char\
    \ c)\n{\n    return c >= 'A' && c <= 'Z';\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpugzp4p46.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x429345]

    ??:? void tmpugzp4p46.__unittest_L58_C1() [0x427ea5]

    ??:? void tmpugzp4p46.__modtest() [0x4285ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dc93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42909e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ab41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42abd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aacd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429075]

    ??:? runModuleUnitTests [0x42da69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429808]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return extensions.front;\n}\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp85b46bb1.d(24): Error: no property `front` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp85b46bb1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tint max_score = int.min;\n\tint cur_score = 0;\n\
    \tstring tmp_str;\n\tstring result = class_name;\n\tforeach(i,ext)\n\t{\n\t\t\
    tmp_str = ext;\n\t\tforeach(tmp_char;tmp_str)\n\t\t{\n\t\t\tif(tmp_char.isUpper)\n\
    \t\t\t\tcur_score++;\n\t\t\telse\n\t\t\t\tcur_score--;\n\t\t}\n\t\tif(cur_score\
    \ > max_score)\n\t\t{\n\t\t\tmax_score = cur_score;\n\t\t\tresult ~= \".\" ~ ext;\n\
    \t\t}\n\t\tcur_score = 0;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprv5aa2q2.d(28): Error: no identifier for declarator `ext`

    /tmp/tmprv5aa2q2.d(28): Error: found `)` when expecting `;`

    /tmp/tmprv5aa2q2.d(45): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprv5aa2q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.stdio;\n    int current_strength =\
    \ 0;\n    int current_index = 0;\n    float current_value = 0.0;\n    for (int\
    \ i = 0; i < extensions.length; i++)\n    {\n        foreach (ext; extensions[i])\n\
    \        {\n            if (ext >= 'A' && ext <= 'Z')\n            {\n       \
    \         current_strength++;\n            }\n            else if (ext >= 'a'\
    \ && ext <= 'z')\n            {\n                current_strength--;\n       \
    \     }\n        }\n        current_value = cast(float)current_strength / extensions[i].length;\n\
    \        if (current_value < 0)\n        {\n            current_value = current_value\
    \ * -1;\n        }\n        if (current_value > current_strength)\n        {\n\
    \            current_strength = cast(int)current_value;\n            current_index\
    \ = i;\n        }\n        current_strength = 0;\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[current_index];\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp76psmtz5.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x429265]

    ??:? void tmp76psmtz5.__unittest_L55_C1() [0x427dc5]

    ??:? void tmp76psmtz5.__modtest() [0x4284cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428fbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aa61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aaf0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a9ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f95]

    ??:? runModuleUnitTests [0x42d989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429728]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tstring final_str = class_name;\n\tfloat strength_array[]\
    \ = new float[extensions.length];\n\tfloat strength = 0.0;\n\tint cap = 0;\n\t\
    int sm = 0;\n\tint min = 0;\n\tfor(int i = 0; i < extensions.length; i++)\n\t\
    {\n\t\tfor(int j = 0; j < extensions[i].length; j++)\n\t\t{\n\t\t\tif(extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z')\n\t\t\t{\n\t\t\t\tcap++;\n\t\t\t}\n\t\t\t\
    else if(extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n\t\t\t{\n\t\t\t\t\
    sm++;\n\t\t\t}\n\t\t}\n\t\tstrength = (float)cap - (float)sm;\n\t\tstrength_array[i]\
    \ = strength;\n\t\tcap = 0;\n\t\tsm = 0;\n\t}\n\tmin = -1;\n\tfor(int i = 0; i\
    \ < strength_array.length; i++)\n\t{\n\t\tif(min == -1)\n\t\t{\n\t\t\tmin = 0;\n\
    \t\t}\n\t\telse if(strength_array[i] > strength_array[min])\n\t\t{\n\t\t\tmin\
    \ = i;\n\t\t}\n\t}\n\tfinal_str += '.';\n\tfinal_str += extensions[min];\n\treturn\
    \ final_str;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n \
    \   assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwbgosoqp.d(25): Deprecation: instead of C-style syntax, use D-style
    syntax `float[] strength_array`

    /tmp/tmpwbgosoqp.d(43): Error: C style cast illegal, use `cast(float)cap`

    /tmp/tmpwbgosoqp.d(43): Error: C style cast illegal, use `cast(float)sm`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwbgosoqp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string str_strongest_extension = \"\";\n    float\
    \ fl_strongest_extension = 0.0;\n    float fl_strength = 0.0;\n    float fl_num_upper\
    \ = 0.0;\n    float fl_num_lower = 0.0;\n    string extension;\n    foreach(extension;\
    \ extensions)\n    {\n        foreach(char ch; extension)\n        {\n       \
    \     if(isUpper(ch))\n            {\n                fl_num_upper += 1.0;\n \
    \           }\n            else\n            {\n                fl_num_lower +=\
    \ 1.0;\n            }\n        }\n        fl_strength = fl_num_upper - fl_num_lower;\n\
    \        if(fl_strength > fl_strongest_extension)\n        {\n            fl_strongest_extension\
    \ = fl_strength;\n            str_strongest_extension = extension;\n        }\n\
    \        else if(fl_strength == fl_strongest_extension)\n        {\n         \
    \   str_strongest_extension = extension;\n        }\n        fl_num_upper = 0.0;\n\
    \        fl_num_lower = 0.0;\n    }\n    return class_name ~ \".\" ~ str_strongest_extension;\n\
    }\n/*\nYou are given an array of arrays of strings.\n    Your task is to return\
    \ the number of times the smallest array is present.\n    Example:\n    >>> number_of_smallest_arrays([[\"\
    A\", \"B\"], [\"A\", \"B\", \"C\"], [\"A\"]])\n    2\n*/\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnxjca7qa.d(30): Error: variable `extension` is shadowing variable
    `tmpnxjca7qa.Strongest_Extension.extension`

    /tmp/tmpnxjca7qa.d(34): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnxjca7qa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int n = extensions.length;\n    double maxStrength\
    \ = 0;\n    string classString = \"\";\n    string extensionString = \"\";\n \
    \   for (int i = 0; i < n; i++)\n    {\n        string[] tmp = extensions[i].split();\n\
    \        int CAP = tmp[0].length;\n        int SM = tmp[1].length;\n        double\
    \ strength = double(CAP) - double(SM);\n        if (strength > maxStrength)\n\
    \        {\n            maxStrength = strength;\n            extensionString =\
    \ extensions[i];\n        }\n    }\n    classString = class_name + \".\" + extensionString;\n\
    \    return classString;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfhbanngg.d(24): Error: cannot implicitly convert expression `extensions.length`
    of type `ulong` to `int`

    /tmp/tmpfhbanngg.d(30): Error: no property `split` for type `string`

    /tmp/tmpfhbanngg.d(31): Error: cannot implicitly convert expression `tmp[0].length`
    of type `ulong` to `int`

    /tmp/tmpfhbanngg.d(32): Error: cannot implicitly convert expression `tmp[1].length`
    of type `ulong` to `int`

    /tmp/tmpfhbanngg.d(40): Error: invalid array operation `class_name + "."` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfhbanngg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //cout << extensions.length << endl;\n    size_t\
    \ extension_length = extensions.length;\n    if (extension_length == 0) return\
    \ class_name;\n    double[] strengths = new double[extension_length];\n    double[]\
    \ strengths_2 = new double[extension_length];\n    size_t extension_index = 0;\n\
    \    double strongest_strength = 0;\n    double strongest_index = 0;\n    for\
    \ (string extension : extensions) {\n        double strength = 0;\n        size_t\
    \ extension_length = extension.length;\n        size_t upper_count = 0;\n    \
    \    size_t lower_count = 0;\n        for (size_t j = 0; j < extension_length;\
    \ j++) {\n            char character = extension[j];\n            //cout << character\
    \ << endl;\n            if (character.isUpper) upper_count++;\n            else\
    \ lower_count++;\n        }\n        strength = upper_count - lower_count;\n \
    \       strengths[extension_index] = strength;\n        strengths_2[extension_index]\
    \ = strength;\n        if (strength > strongest_strength) {\n            strongest_strength\
    \ = strength;\n            strongest_index = extension_index;\n        }\n   \
    \     extension_index++;\n    }\n    //cout << strongest_index << endl;\n    sort(strengths);\n\
    \    //cout << strongest_strength << endl;\n    //cout << lengths[strengths.length\
    \ - 1] << endl;\n    size_t strongest_indexes_length = 0;\n    for (double strength\
    \ : strengths) {\n        if (strength == strongest_strength) {\n            strongest_indexes_length++;\n\
    \        }\n    }\n    size_t[] strongest_indexes = new size_t[strongest_indexes_length];\n\
    \    size_t i = 0;\n    size_t index = 0;\n    for (double strength : strengths_2)\
    \ {\n        if (strength == strongest_strength) {\n            strongest_indexes[index]\
    \ = i;\n            index++;\n        }\n        i++;\n    }\n    //cout << strongest_indexes[0]\
    \ << endl;\n   \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n \
    \   assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpflc21bek.d(32): Error: found `extension` when expecting `;` following
    statement

    /tmp/tmpflc21bek.d(32): Error: expression expected, not `:`

    /tmp/tmpflc21bek.d(32): Error: found `extensions` when expecting `;` following
    `for` condition

    /tmp/tmpflc21bek.d(57): Error: semicolon expected, not `:`

    /tmp/tmpflc21bek.d(57): Error: expression expected, not `:`

    /tmp/tmpflc21bek.d(57): Error: found `strengths` when expecting `;` following
    `for` condition

    /tmp/tmpflc21bek.d(65): Error: semicolon expected, not `:`

    /tmp/tmpflc21bek.d(65): Error: expression expected, not `:`

    /tmp/tmpflc21bek.d(65): Error: found `strengths_2` when expecting `;` following
    `for` condition

    /tmp/tmpflc21bek.d(74): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpflc21bek.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max = 0;\n    string result = class_name;\n\
    \    string max_ext = extensions[0];\n    foreach(string ext; extensions)\n  \
    \  {\n        double s = 0;\n        foreach(c; ext)\n        {\n            if\
    \ (c >= 'A' && c <= 'Z')\n                s++;\n            else if (c >= 'a'\
    \ && c <= 'z')\n                s--;\n        }\n        if (s > max)\n      \
    \  {\n            max = s;\n            max_ext = ext;\n        }\n    }\n   \
    \ return result ~ \".\" ~ max_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7rqofpx3.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x42928d]

    ??:? void tmp7rqofpx3.__unittest_L45_C1() [0x427fc7]

    ??:? void tmp7rqofpx3.__modtest() [0x4284f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dbdb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428fe6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aa89]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ab18]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aa15]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fbd]

    ??:? runModuleUnitTests [0x42d9b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429750]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string ret_val = class_name;\n    double strongest_strength\
    \ = 0;\n    foreach(string s; extensions)\n    {\n        double strength = (double)count(s.split(std.regex.alnum),\
    \ \"isUpper\") -\n                          (double)count(s.split(std.regex.alnum),\
    \ \"isLower\");\n        if(strength > strongest_strength)\n        {\n      \
    \      strongest_strength = strength;\n            ret_val = class_name ~ \".\"\
    \ ~ s;\n        }\n    }\n    return ret_val;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp53h_uflx.d(28): Error: C style cast illegal, use `cast(double)count(s.split(std.regex.alnum),
    "isUpper")`

    /tmp/tmp53h_uflx.d(29): Error: C style cast illegal, use `cast(double)count(s.split(std.regex.alnum),
    "isLower")`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp53h_uflx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    uint strongest = 0;\n    int strongest_index =\
    \ 0;\n    for (uint i = 0; i < extensions.length; i++)\n    {\n        uint strong\
    \ = extensions[i].count!(a => a.isUpper) - extensions[i].count!(a => a.isLower);\n\
    \        if (strong > strongest)\n        {\n            strongest = strong;\n\
    \            strongest_index = i;\n        }\n    }\n    return class_name ~ \"\
    .\" ~ extensions[strongest_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmbeg2exc.d(28): Error: no property `count` for type `string`

    /tmp/tmpmbeg2exc.d(28): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmbeg2exc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = class_name;\n    float strongest_extension\
    \ = 0.0f;\n    foreach(string extension; extensions)\n    {\n        float uppercase_letters\
    \ = 0.0f;\n        float lowercase_letters = 0.0f;\n        foreach(dchar ch;\
    \ extension)\n        {\n            if(ch.isUpper)\n                uppercase_letters\
    \ += 1.0f;\n            else if(ch.isLower)\n                lowercase_letters\
    \ += 1.0f;\n        }\n        if(strongest_extension < uppercase_letters - lowercase_letters)\n\
    \        {\n            strongest_extension = uppercase_letters - lowercase_letters;\n\
    \            result ~= \".\" ~ extension;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp72qeapy1.d(32): Error: no property `isUpper` for type `dchar`

    /tmp/tmp72qeapy1.d(34): Error: no property `isLower` for type `dchar`

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string winner = \"\";\n    double strength = double.min;\n\
    \    extensions.each!(ext => {\n        writeln(ext);\n        if(ext.filter!(c\
    \ => c.isUpper).length - ext.filter!(c => c.isLower).length > strength)\n    \
    \    {\n            winner = ext;\n            strength = ext.filter!(c => c.isUpper).length\
    \ - ext.filter!(c => c.isLower).length;\n        }\n    });\n    return class_name\
    \ ~ \".\" ~ winner;\n}\n/*\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdg88mxev.d(36): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdg88mxev.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    class_name += \".\";\n    foreach(string ext,\
    \ int i; extensions)\n    {\n        class_name += getStrongestExtension(extensions,\
    \ i);\n        break;\n    }\n    return class_name;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo5h5qmcc.d(24): Error: slice `class_name` is not mutable

    /tmp/tmpo5h5qmcc.d(25): Error: integral constant must be scalar type, not `string`

    /tmp/tmpo5h5qmcc.d(25): Error: integral constant must be scalar type, not `string`

    /tmp/tmpo5h5qmcc.d(25): Error: incompatible types for `(__key73) < (__r74.length)`:
    `string` and `ulong`

    /tmp/tmpo5h5qmcc.d(25): Error: cannot implicitly convert expression `__key73`
    of type `string` to `ulong`

    /tmp/tmpo5h5qmcc.d(27): Error: undefined identifier `getStrongestExtension`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo5h5qmcc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strong = float.min;\n    string strongest;\n\
    \    foreach(i, ext; extensions)\n    {\n        int caps = 0;\n        int smalls\
    \ = 0;\n        foreach(j, char_in_ext; ext)\n        {\n            if(isUpper(char_in_ext))\n\
    \                caps++;\n            else if(isLower(char_in_ext))\n        \
    \        smalls++;\n        }\n        auto temp = (float) caps - smalls;\n  \
    \      if(temp > strong)\n        {\n            strong = temp;\n            strongest\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\n//\
    \ auto result = Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]);\n\
    // assert(result == \"my_class.AA\");\n// auto result = Strongest_Extension(\"\
    Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"]);\n// assert(result ==\
    \ \"Slices.SErviNGSliCes\");\n// auto result = Strongest_Extension(\"Slices\"\
    , [\"SErviNGSliCes\", \"Be\", \"CC\"]);\n// assert(result == \"Slices.SErviNGSliCes\"\
    );\n// auto result = Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"SA\"\
    , \"CC\"]);\n// assert(result == \"Slices.SErviNGSliCes\");\n// auto result =\
    \ Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"SA\", \"SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf56twq0o.d(37): Error: C style cast illegal, use `cast(float)caps`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf56twq0o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Check if the array is empty, if not then continue\
    \ with\n    // finding the strongest extension.\n    if (extensions.length !=\
    \ 0)\n    {\n        // Find the strongest extension and save it in the variable\n\
    \        // strongest_extension.\n        string strongest_extension = extensions[0];\n\
    \        float strongest_strength = Calculate_Strength(strongest_extension);\n\
    \        foreach (extension; extensions)\n        {\n            float extension_strength\
    \ = Calculate_Strength(extension);\n            if (extension_strength > strongest_strength)\n\
    \            {\n                strongest_extension = extension;\n           \
    \     strongest_strength = extension_strength;\n            }\n        }\n   \
    \     // Return the string of the class name and strongest extension.\n      \
    \  return class_name ~ \".\" ~ strongest_extension;\n    }\n    // If the array\
    \ is empty, return a message.\n    else\n    {\n        return \"No extensions\
    \ given.\";\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe350_s4r.d(31): Error: undefined identifier `Calculate_Strength`

    /tmp/tmpe350_s4r.d(34): Error: undefined identifier `Calculate_Strength`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe350_s4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest_strength = 0;\n    string strongest_name\
    \ = \"\";\n    double strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        strength = getStrength(extension);\n        if(strongest_strength\
    \ < strength)\n        {\n            strongest_strength = strength;\n       \
    \     strongest_name = extension;\n        }\n    }\n    return class_name ~ \"\
    .\" ~ strongest_name;\n}\ndouble getStrength(string extension)\n{\n    return\
    \ extension.count!(char[](\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")) - extension.count!(char[](\"\
    abcdefghijklmnopqrstuvwxyz\"));\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2os91upc.d(40): Error: found `[` when expecting `.` following char

    /tmp/tmp2os91upc.d(40): Error: found `]` when expecting identifier following `char`.

    /tmp/tmp2os91upc.d(40): Error: found `[` when expecting `.` following char

    /tmp/tmp2os91upc.d(40): Error: found `]` when expecting identifier following `char`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2os91upc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\
    \u0432\u043E \u0437\u0430\u0433\u043B\u0430\u0432\u043D\u044B\u0445 \u0431\u0443\
    \u043A\u0432 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0438 \u0440\u0430\
    \u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F\n    uint cap_num(string x) {\n\
    \        uint s = 0;\n        for (i, c; x)\n            if (c > 'A' && c < 'Z')\n\
    \                s++;\n        return s;\n    }\n    // \u043A\u043E\u043B\u0438\
    \u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0442\u0440\u043E\u0447\u043D\u044B\
    \u0445 \u0431\u0443\u043A\u0432 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\
    \u0438 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F\n    uint\
    \ sm_num(string x) {\n        uint s = 0;\n        for (i, c; x)\n           \
    \ if (c > 'a' && c < 'z')\n                s++;\n        return s;\n    }\n  \
    \  // \u0441\u0438\u043B\u0430 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\
    \u0438\u044F\n    real strength(string x) {\n        return real(cap_num(x) -\
    \ sm_num(x));\n    }\n    // \u0441\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\
    \u0430 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u0439 \u043F\u043E\
    \ \u0441\u0438\u043B\u0435\n    string[] sort_ext(string[] ex) {\n        string[]\
    \ tmp = ex.dup;\n        ex.sort!(a, b => (strength(a) > strength(b)));\n    \
    \    return ex;\n    }\n    // \u043D\u0430\u0439\u0442\u0438 \u0441\u0430\u043C\
    \u043E\u0435 \u0441\u0438\u043B\u044C\u043D\u043E\u0435 \u0440\u0430\u0441\u0448\
    \u0438\u0440\u0435\u043D\u0438\u0435\n    string find_strongest(string[] ex) {\n\
    \        auto str = strength(ex[0]);\n        foreach (e; ex)\n            if\
    \ (strength(e) > str)\n                str = strength(e);\n        return str;\n\
    \    }\n    // \u043D\u0430\u0439\u0442\u0438 \u0438\u043D\u0434\u0435\u043A\u0441\
    \ \u0441\u0430\u043C\u043E\u0433\u043E \u0441\u0438\u043B\u044C\u043D\u043E\u0433\
    \u043E \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F\n    int index_strongest(string\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeikltnil.d(27): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmpeikltnil.d(28): Error: expression expected, not `if`

    /tmp/tmpeikltnil.d(29): Error: found `s` when expecting `)`

    /tmp/tmpeikltnil.d(29): Error: expression expected, not `;`

    /tmp/tmpeikltnil.d(30): Error: found `return` when expecting `;` following statement

    /tmp/tmpeikltnil.d(35): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpeikltnil.d(36): Error: expression expected, not `if`

    /tmp/tmpeikltnil.d(37): Error: found `s` when expecting `)`

    /tmp/tmpeikltnil.d(37): Error: expression expected, not `;`

    /tmp/tmpeikltnil.d(38): Error: found `return` when expecting `;` following statement

    /tmp/tmpeikltnil.d(60): Error: found `unittest` when expecting `)`

    /tmp/tmpeikltnil.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeikltnil.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // we will use a tuple to store the CAP and SM\
    \ values and the index\n    // position in the array\n    Tuple!(int, int, int)[]\
    \ strength;\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpps3yy6ek.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpps3yy6ek.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto len = extensions.length;\n    string[] caps\
    \ = new string[len];\n    string[] lowercases = new string[len];\n    string[]\
    \ results = new string[len];\n    foreach(i, item; extensions)\n    {\n      \
    \  int cap = 0;\n        int lowercase = 0;\n        foreach(char c; item)\n \
    \       {\n            if(isupper(c))\n                cap++;\n            else\
    \ if(islower(c))\n                lowercase++;\n        }\n        double result\
    \ = (double)cap - (double)lowercase;\n        results[i] = result.to!string;\n\
    \        caps[i] = to!string(cap);\n        lowercases[i] = to!string(lowercase);\n\
    \    }\n    //we have values of caps and lowercases and results, now we sort.\n\
    \    foreach(i, x; results)\n    {\n        writeln(x);\n    }\n    string[] results_capped\
    \ = results.dup;\n    string[] results_lowercased = results.dup;\n    sort!((a,\
    \ b) => a > b)(results);\n    sort!((a, b) => a > b)(results_capped);\n    sort!((a,\
    \ b) => a > b)(results_lowercased);\n    writeln(results[0]);\n    writeln(results_capped[0]);\n\
    \    writeln(results_lowercased[0]);\n    //we have sorted arrays, now find the\
    \ greatest result\n    int index = results.length - 1;\n    int index_capped =\
    \ results_capped.length - 1;\n    int index_lowercased = results_lowercased.length\
    \ - 1;\n    string[] greatest_results = new string[3];\n    foreach(i, x; results)\n\
    \    {\n        if(x == results[index])\n            greatest_results[0] = x;\n\
    \    }\n    foreach(i, x; results_capped)\n    {\n        if(x == results_capped[index_capped])\n\
    \            greatest_results[1] = x;\n    }\n    foreach(i, x; results_lowercased)\n\
    \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe_gr3pas.d(39): Error: C style cast illegal, use `cast(double)cap`

    /tmp/tmpe_gr3pas.d(39): Error: C style cast illegal, use `cast(double)lowercase`

    /tmp/tmpe_gr3pas.d(74): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_gr3pas.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengths = extensions.map!((string x) =>\
    \ \n                        x.countUntil!(a => !char.isUpper(a)) - \n        \
    \                x.countUntil!(a => !char.isLower(a))).array;\n    int max = strengths.max;\n\
    \    int index = strengths.indexOf(max);\n    return class_name ~ \".\" ~ extensions[index];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3xez2db1.d(24): Error: no property `map` for type `string[]`

    /tmp/tmp3xez2db1.d(27): Error: no property `max` for type `int[]`

    /tmp/tmp3xez2db1.d(28): Error: no property `indexOf` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3xez2db1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    if (extensions.length == 0) \n        return class_name;\n\
    \    double strength = DBL_MIN;\n    int index = 0;\n    for (int i = 0; i < extensions.length;\
    \ i++) \n    {\n        string extension = extensions[i];\n        double tmp\
    \ = double(extension.filter!(x => x.isUpper).length) - double(extension.filter!(x\
    \ => x.isLower).length);\n        if (tmp > strength) \n        {\n          \
    \  strength = tmp;\n            index = i;\n        }\n    }\n    return format(\"\
    %s.%s\", class_name, extensions[index]);\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp41jpn2pa.d(26): Error: undefined identifier `DBL_MIN`

    /tmp/tmp41jpn2pa.d(31): Error: no property `filter` for type `string`

    /tmp/tmp41jpn2pa.d(31): Error: no property `filter` for type `string`

    /tmp/tmp41jpn2pa.d(38): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp41jpn2pa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float highest = -1;\n    int index = 0;\n    float\
    \ s;\n    foreach(int i,string extension; extensions){\n        s = (float)extension.filter!((a)=>a.isUpper).length\
    \ - extension.filter!((a)=>a.isLower).length;\n        if(s > highest){\n    \
    \        highest = s;\n            index = i;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[index];\n}\n/*\n    You are given a 2D array, coordinates\
    \ and a color. A cell can be colored\n    by its coordinates.\n    For example:\
    \ coordinates = [[1,1], [2,5], [3,3]] and color = 'red'\n    means: you have to\
    \ color the cell with the coordinates [1,1] with the color\n    'red', the cell\
    \ with the coordinates [2,5] with the color 'red' and\n    the cell with the coordinates\
    \ [3,3] with the color 'red'.\n    Example:\n    >>> color_coordinates([[1,2],[3,4],[5,6]],\
    \ 'red')\n    [['red', 2], [3, 4], [5, 6]]\n    >>> color_coordinates([[1,2],[3,4],[5,6]],\
    \ 'blue')\n    [[1, 2], [3, 4], ['blue', 6]]\n    >>> color_coordinates([[1,2],[3,4],[5,6]],\
    \ 'white')\n    [[1, 2], [3, 4], [5, 6]]\n*/\nstring[][] color_coordinates(int[][]\
    \ coordinates, string color) \n{\n    string[][] result = new string[][](coordinates.length);\n\
    \    foreach(int i, int[] c; coordinates){\n        result[i] = new string[](2);\n\
    \        result[i][0] = c[0].to!string;\n        result[i][1] = c[1].to!string;\n\
    \    }\n    foreach(int i, int[] c; coordinates){\n        if(c[0] == c[1]){\n\
    \            result[i][c[0]-1] = color\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp08514y13.d(28): Error: C style cast illegal, use `cast(float)extension.filter!((a)
    => a.isUpper).length`

    /tmp/tmp08514y13.d(62): Error: found `unittest` when expecting `;` following statement

    /tmp/tmp08514y13.d(76): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp08514y13.d(76): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp08514y13.d(76): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp08514y13.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = extensions[0];\n\
    \    float strongest_extension_strength = 0;\n    float extension_strength = 0;\n\
    \    int number_of_uppercase_letters = 0;\n    int number_of_lowercase_letters\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        number_of_uppercase_letters\
    \ = 0;\n        number_of_lowercase_letters = 0;\n        foreach(letter; extension)\n\
    \        {\n            if(letter.isUpper)\n            {\n                number_of_uppercase_letters++;\n\
    \            }\n            else\n            {\n                number_of_lowercase_letters++;\n\
    \            }\n        }\n        extension_strength = float(number_of_uppercase_letters)/number_of_lowercase_letters;\n\
    \        if(extension_strength > strongest_extension_strength)\n        {\n  \
    \          strongest_extension_strength = extension_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name~\".\"~strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp44zwfrga.d(35): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp44zwfrga.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strong = 0.0;\n    string strongest = \"\"\
    ;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        auto sm = 0.0;\n\
    \        auto cap = 0.0;\n        for (int j = 0; j < extensions[i].length; j++)\n\
    \        {\n            if(extensions[i][j] >= 65 && extensions[i][j] <= 90)\n\
    \            {\n                cap++;\n            }\n            else if(extensions[i][j]\
    \ >= 97 && extensions[i][j] <= 122)\n            {\n                sm++;\n  \
    \          }\n        }\n        auto strength = cap - sm;\n        if(strength\
    \ > strong)\n        {\n            strong = strength;\n            strongest\
    \ = extensions[i];\n        }\n    }\n    return format(\"%s.%s\", class_name,\
    \ strongest);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv4037ti8.d(48): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv4037ti8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.math;\n    import std.conv;\n    import\
    \ std.typecons;\n    int tmp = 0;\n    int ext_strength = 0;\n    int max_strength\
    \ = 0;\n    string final_ext = \"\";\n    foreach(ext; extensions)\n    {\n  \
    \      auto tmp_strength = 0;\n        foreach(cc; ext)\n        {\n         \
    \   if (cc.isUpper)\n                tmp_strength++;\n            else\n     \
    \           tmp_strength--;\n        }\n        if (tmp_strength > max_strength)\n\
    \        {\n            max_strength = tmp_strength;\n            final_ext =\
    \ ext;\n        }\n    }\n    return class_name ~ \".\" ~ final_ext;\n}\n/*\n\
    The function should find the first place where the two arrays have \n    common\
    \ elements and return the index of the first common element in \n    the second\
    \ array. The arrays are expected to have the same length and\n    their length\
    \ is always at least 1.\n    Example:\n    >>> Find_Common_Element([1,2,3,4,5,6],\
    \ [1,3,5,8,11,12])\n    0\n    >>> Find_Common_Element([1,2,3,4,5,6], [8,11,12,9,10,7])\n\
    \    -1\n    >>> Find_Common_Element([1,2,3,4,5,6], [9,10,7,1,2,3])\n    3\n \
    \   >>> Find_Common_Element([1,2,3,4,5,6], [1,2,3,4,5,6])\n    0\n*/\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6mvsb3tc.d(36): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6mvsb3tc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double tmp1 = 0;\n    string tmp2 = \"\";\n  \
    \  foreach(string x; extensions)\n    {\n        double tmp = 0;\n        foreach(char\
    \ c; x)\n        {\n            if(isUpper(c))\n                tmp += 1;\n  \
    \          else if(isLower(c))\n                tmp -= 1;\n        }\n       \
    \ if(tmp > tmp1)\n        {\n            tmp1 = tmp;\n            tmp2 = x;\n\
    \        }\n    }\n    return format(\"%s.%s\", class_name, tmp2);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpma43ha1b.d(31): Error: undefined identifier `isUpper`

    /tmp/tmpma43ha1b.d(33): Error: undefined identifier `isLower`

    /tmp/tmpma43ha1b.d(42): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpma43ha1b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string s = \"\";\n    double max = double.min;\n\
    \    foreach(string extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(isUpper(c))\n \
    \               strength += 1;\n            else if(isLower(c))\n            \
    \    strength -= 1;\n        }\n        if(strength > max)\n        {\n      \
    \      max = strength;\n            s = extension;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ s;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiz36ealb.d(25): Error: no property `min` for type `double`

    /tmp/tmpiz36ealb.d(31): Error: undefined identifier `isUpper`

    /tmp/tmpiz36ealb.d(33): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiz36ealb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // initialisation :\n    double strength = -DBL_MAX;\n\
    \    string strongest_extension = \"\";\n    // for each extension in the list\
    \ :\n    foreach(extension; extensions)\n    {\n        double extension_strength\
    \ = (count!(\"A\")(extension) + count!(\"B\")(extension) +\n                 \
    \                   count!(\"C\")(extension) + count!(\"D\")(extension) +\n  \
    \                                  count!(\"E\")(extension) + count!(\"F\")(extension)\
    \ +\n                                    count!(\"G\")(extension) + count!(\"\
    H\")(extension) +\n                                    count!(\"I\")(extension)\
    \ + count!(\"J\")(extension) +\n                                    count!(\"\
    K\")(extension) + count!(\"L\")(extension) +\n                               \
    \     count!(\"M\")(extension) + count!(\"N\")(extension) +\n                \
    \                    count!(\"O\")(extension) + count!(\"P\")(extension) +\n \
    \                                   count!(\"Q\")(extension) + count!(\"R\")(extension)\
    \ +\n                                    count!(\"S\")(extension) + count!(\"\
    T\")(extension) +\n                                    count!(\"U\")(extension)\
    \ + count!(\"V\")(extension) +\n                                    count!(\"\
    W\")(extension) + count!(\"X\")(extension) +\n                               \
    \     count!(\"Y\")(extension) + count!(\"Z\")(extension)) -\n               \
    \                     (count!(\"a\")(extension) + count!(\"b\")(extension) +\n\
    \                                    count!(\"c\")(extension) + count!(\"d\")(extension)\
    \ +\n                                    count!(\"e\")(extension) + count!(\"\
    f\")(extension) +\n                                    count!(\"g\")(extension)\
    \ + count!(\"h\")(extension) +\n                                    count!(\"\
    i\")(extension) + count!(\"j\")(extension) +\n                               \
    \     count!(\"k\")(extension) + count!(\"l\")(extension) +\n                \
    \                    count!(\"m\")(extension) + count!(\"n\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdapjrh8d.d(43): Error: unterminated string constant starting at
    /tmp/tmpdapjrh8d.d(62)

    /tmp/tmpdapjrh8d.d(54): Error: found `Watashi` when expecting `)` following template
    argument list

    /tmp/tmpdapjrh8d.d(43): Error: found `", ["` when expecting `)`

    /tmp/tmpdapjrh8d.d(54): Error: semicolon expected, not `tEN`

    /tmp/tmpdapjrh8d.d(54): Error: found `", "` when expecting `;` following statement

    /tmp/tmpdapjrh8d.d(54): Error: found `", "` when expecting `;` following statement

    /tmp/tmpdapjrh8d.d(54): Error: found `"]) == "` when expecting `;` following statement

    /tmp/tmpdapjrh8d.d(54): Error: found `");\x0a    assert(candidate("` when expecting
    `;` following statement

    /tmp/tmpdapjrh8d.d(55): Error: found `", ["` when expecting `;` following statement

    /tmp/tmpdapjrh8d.d(55): Error: found `", "` when expecting `;` following statement

    /tmp/tmpdapjrh8d.d(55): Error: found `", "` when expecting `;` following statement

    /tmp/tmpdapjrh8d.d(55): Error: found `", "` when expecting `;` following statement

    /tmp/tmpdap'
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    size_t\
    \ strength = 0;\n    foreach(string extension; extensions)\n    {\n        size_t\
    \ cap = 0;\n        size_t sm = 0;\n        foreach(char ch; extension)\n    \
    \    {\n            if(ch >= 'A' && ch <= 'Z') cap++;\n            else if(ch\
    \ >= 'a' && ch <= 'z') sm++;\n        }\n        if(cap - sm > strength)\n   \
    \     {\n            strength = cap - sm;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzranvr9t.d(41): Error: invalid array operation `class_name + "."`
    (possible missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzranvr9t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float[] strengths = extensions.map!((ext) => float(ext.count!isUpper)\
    \ - ext.count!isLower)();\n    return class_name ~ \".\" ~ extensions[strengths.indexOf(strengths.max)];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph6o602qa.d(24): Error: no property `map` for type `string[]`

    /tmp/tmph6o602qa.d(25): Error: no property `indexOf` for type `float[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6o602qa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest_value = 0;\n    string strongest_name\
    \ = extensions[0];\n    int c_cap, c_sm;\n    foreach(s; extensions)\n    {\n\
    \        c_cap = countUntil!(isUpper)(s);\n        c_sm = countUntil!(isLower)(s);\n\
    \        if(strongest_value < float(c_cap - c_sm))\n        {\n            strongest_value\
    \ = float(c_cap - c_sm);\n            strongest_name = s;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_name;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp508z6gq2.d(29): Error: template instance `countUntil!isUpper` template
    `countUntil` is not defined

    /tmp/tmp508z6gq2.d(30): Error: template instance `countUntil!isLower` template
    `countUntil` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp508z6gq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    class Ext {\n        string name;\n        string\
    \ class_name;\n        int strength;\n        \n        this(string name, string\
    \ class_name) {\n            this.name = name;\n            this.class_name =\
    \ class_name;\n            this.strength = countOfUpper(name) - countOfLower(name);\n\
    \        }\n        \n        int countOfUpper(string name) {\n            int\
    \ count = 0;\n            foreach(ch; name)\n                if(isUpper(ch))\n\
    \                    count++;\n            return count;\n        }\n        \n\
    \        int countOfLower(string name) {\n            int count = 0;\n       \
    \     foreach(ch; name)\n                if(isLower(ch))\n                   \
    \ count++;\n            return count;\n        }\n        \n        int opCmp(Ext\
    \ other) {\n            return strength - other.strength;\n        }\n    }\n\
    \    \n    string[] result = class_name.split('.');\n    class_name = result[0];\n\
    \    Ext[] exts = [Ext(ext, class_name) for ext in extensions];\n    Ext maxExt\
    \ = max(exts);\n    return class_name ~ \".\" ~ maxExt.name;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3g_ri6u1.d(58): Error: comma expected separating array initializers,
    not `for`

    /tmp/tmp3g_ri6u1.d(58): Error: semicolon expected, not `ext`

    /tmp/tmp3g_ri6u1.d(58): Error: found `]` when expecting `;` following statement

    /tmp/tmp3g_ri6u1.d(58): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3g_ri6u1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tforeach(inout string x; extensions)\n\t{\n\t\tint\
    \ cnt = 0;\n\t\tforeach(immutable char x1; x)\n\t\t{\n\t\t\tif(isupper(x1)) cnt++;\n\
    \t\t}\n\t\tif(x.length > 0)\n\t\t\tx = format(\"%s.%s\",class_name,x);\n\t\telse\n\
    \t\t\tx = class_name;\n\t\tx ~= to!string(cnt-x.length);\n\t}\n\tstring result\
    \ = class_name;\n\tforeach(immutable auto x; extensions)\n\t{\n\t\tif(to!double(x[$-1..$])\
    \ > to!double(result[$-1..$]))\n\t\t\tresult = x;\n\t}\n\treturn result;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpycrsqe7w.d(38): Error: basic type expected, not `auto`

    /tmp/tmpycrsqe7w.d(38): Error: no identifier for declarator `_error_`

    /tmp/tmpycrsqe7w.d(38): Error: found `auto` when expecting `;`

    /tmp/tmpycrsqe7w.d(38): Error: found `;` when expecting `)`

    /tmp/tmpycrsqe7w.d(38): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpycrsqe7w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    Tuple!(int, int, string)[] extensionStrength =\
    \ extensions.map!(extension => {\n        uint numberOfUpperCaseLetters = extension.filter!(char\
    \ => char.isUpper).length;\n        uint numberOfLowerCaseLetters = extension.filter!(char\
    \ => char.isLower).length;\n        return tuple(numberOfUpperCaseLetters - numberOfLowerCaseLetters,\
    \ numberOfUpperCaseLetters, extension);\n    });\n    extensionStrength.sort!((a,\
    \ b) => a[0] > b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return class_name\
    \ ~ \".\" ~ extensionStrength[0][2];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn464t8sk.d(25): Error: found `=>` when expecting `.` following
    char

    /tmp/tmpn464t8sk.d(25): Error: found `char` when expecting identifier following
    `char`.

    /tmp/tmpn464t8sk.d(26): Error: found `=>` when expecting `.` following char

    /tmp/tmpn464t8sk.d(26): Error: found `char` when expecting identifier following
    `char`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn464t8sk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions) {\n        int lower = count(extension.lowercased,\
    \ 'a');\n        int upper = count(extension.uppercased, 'A');\n        double\
    \ strength = (upper - lower) / extension.length;\n        if(strength > strongest)\
    \ {\n            strongest = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\n/*\n\
    You're given a list of n strings each of length n, words.\nLet's define a word\
    \ as a diagonal word if it's possible to draw a diagonal line \ninside a grid\
    \ of letters of size n x n such that all the letters on this line are \nthe same.\n\
    It is possible to draw a diagonal line only if all the characters in the word\
    \ are\nthe same.\nReturn the number of diagonal words in the given list.\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ic9uv6_.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ic9uv6_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    double strongest_strength\
    \ = 0;\n    foreach(ext; extensions) {\n        int caps = 0;\n        int smalls\
    \ = 0;\n        foreach(c; ext) {\n            if(isUpper(c)) {\n            \
    \    caps++;\n            } else {\n                smalls++;\n            }\n\
    \        }\n        double strength = caps - smalls;\n        if(strength > strongest_strength)\
    \ {\n            strongest = ext;\n            strongest_strength = strength;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nstring Strongest_Extension2(string\
    \ class_name, string[] extensions) {\n    // make a tuple with the strength and\
    \ the class name\n    auto make_tuple(string extension) {\n        int caps =\
    \ 0;\n        int smalls = 0;\n        foreach(c; extension) {\n            if(isUpper(c))\
    \ {\n                caps++;\n            } else {\n                smalls++;\n\
    \            }\n        }\n        return tuple(caps - smalls, extension);\n \
    \   }\n    // sort them by the strength, then by the names\n    auto tuples =\
    \ extensions.map!make_tuple.sort!((t1, t2) => t1[0] < t2[0] || (t1[0] == t2[0]\
    \ && t1[1] < t2[1]));\n    // return the name\n    return class_name ~ \".\" ~\
    \ tuples[0][1];\n}\nstring Strongest_Extension3(string class_name, string[] extensions)\
    \ {\n    auto tuples = extensions.map!(ext => tuple(ext.count!(c => isUpper(c))\
    \ - ext.count!(c => isLower(c)), ext)).sort!((t1, t2) => t1[0] < t2[0] || (t1[0]\
    \ == t2[0] && t1[1] < t2[1]));\n    return class_name ~ \".\" ~ tuples[0][1];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp36ggsui_.d(30): Error: undefined identifier `isUpper`

    /tmp/tmp36ggsui_.d(50): Error: undefined identifier `isUpper`

    /tmp/tmp36ggsui_.d(59): Error: no property `map` for type `string[]`

    /tmp/tmp36ggsui_.d(64): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp36ggsui_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.math;\n    import std.conv;\n    int[]\
    \ strength = [extensions.length];\n    foreach(i, e; extensions)\n    {\n    \
    \    int cap = 0;\n        int sm = 0;\n        foreach(c; e)\n        {\n   \
    \         cap += cast(bool)(c >= 'A' && c <= 'Z');\n            sm += cast(bool)(c\
    \ >= 'a' && c <= 'z');\n        }\n        strength[i] = abs(cap - sm);\n    }\n\
    \    int max_strength = 0;\n    int s_idx = 0;\n    foreach(i, s; strength)\n\
    \    {\n        if(s > max_strength)\n        {\n            max_strength = s;\n\
    \            s_idx = i;\n        }\n    }\n    return class_name ~ \".\" ~ extensions[s_idx];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk2trbag6.d(26): Error: cannot implicitly convert expression `[extensions.length]`
    of type `ulong[]` to `int[]`

    /tmp/tmpk2trbag6.d(45): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk2trbag6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_score = 0;\n    foreach(extension; extensions)\n    {\n\
    \        double upper_case_count = 0;\n        double lower_case_count = 0;\n\
    \        foreach(c; extension)\n        {\n            if(isUpper(c))\n      \
    \      {\n                upper_case_count++;\n            }\n            else\n\
    \            {\n                lower_case_count++;\n            }\n        }\n\
    \        double score = (upper_case_count / lower_case_count);\n        if(score\
    \ > strongest_extension_score)\n        {\n            strongest_extension_score\
    \ = score;\n            strongest_extension = extension;\n        }\n    }\n \
    \   return class_name ~ \".\" ~ strongest_extension;\n}\n//you can also use import(\"\
    dietstdio.d\");\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n \
    \   assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqkm_67xs.d(32): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqkm_67xs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest_index = 0;\n    double strongest_strength\
    \ = 0;\n    foreach(idx, extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(ch; extension)\n        {\n            if (ch.isUpper)\
    \ strength++;\n            else strength--;\n        }\n        if (strength >\
    \ strongest_strength)\n        {\n            strongest_index = idx;\n       \
    \     strongest_strength = strength;\n        }\n    }\n    return format(\"%s.%s\"\
    , class_name, extensions[strongest_index]);\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo54ba94n.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpo54ba94n.d(36): Error: cannot implicitly convert expression `idx` of type
    `ulong` to `int`

    /tmp/tmpo54ba94n.d(40): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo54ba94n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real max_strength;\n    string best_extension;\n\
    \    foreach(extension; extensions) \n    {\n        int lower_count;\n      \
    \  int upper_count;\n        for(i;0..extension.length) \n        {\n        \
    \    if(extension[i].isUpper) upper_count++;\n            else lower_count++;\n\
    \        }\n        if(upper_count==0) continue;\n        real strength = (upper_count\
    \ - lower_count) / real(upper_count);\n        if(max_strength < strength) \n\
    \        {\n            max_strength = strength;\n            best_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ best_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe95c6hfe.d(30): Error: found `..` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe95c6hfe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\t// First make sure the extensions array is sorted\n\
    \tsort(extensions);\n\t// Take the length of the extensions array\n\tsize_t ext_len\
    \ = extensions.length;\n\tint ext_cap = 0;\n\tint ext_sm = 0;\n\tint max_cap =\
    \ 0;\n\tint max_sm = 0;\n\tstring strongest_ext = \"\";\n\tfor (size_t i = 0;\
    \ i < ext_len; i++)\n\t{\n\t\text_cap = extensions[i].count_if!(a => a >= 'A'\
    \ && a <= 'Z');\n\t\text_sm = extensions[i].count_if!(a => a >= 'a' && a <= 'z');\n\
    \t\t\n\t\tif (ext_cap > max_cap)\n\t\t{\n\t\t\tmax_cap = ext_cap;\n\t\t\tmax_sm\
    \ = ext_sm;\n\t\t\tstrongest_ext = extensions[i];\n\t\t}\n\t\telse if (ext_cap\
    \ == max_cap)\n\t\t{\n\t\t\tif (ext_sm < max_sm)\n\t\t\t{\n\t\t\t\tmax_cap = ext_cap;\n\
    \t\t\t\tmax_sm = ext_sm;\n\t\t\t\tstrongest_ext = extensions[i];\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn class_name ~ \".\" ~ strongest_ext;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjf1x6nfn.d(25): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpjf1x6nfn.d(35): Error: no property `count_if` for type `string`

    /tmp/tmpjf1x6nfn.d(36): Error: no property `count_if` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjf1x6nfn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = extensions[0].length;\n    int min =\
    \ extensions[0].length;\n    int imax = 0;\n    int imin = 0;\n    int k = 0;\n\
    \    int temp_max = 0;\n    int temp_min = 0;\n    string result;\n    foreach(i,extension;extensions)\n\
    \    {\n        temp_max = 0;\n        temp_min = 0;\n        foreach(ch;extension)\n\
    \        {\n            if(std.ctype.isupper(ch))\n            {\n           \
    \     temp_max++;\n            }\n            else if(std.ctype.islower(ch))\n\
    \            {\n                temp_min++;\n            }\n        }\n      \
    \  if(temp_max - temp_min > max - min)\n        {\n            max = temp_max;\n\
    \            min = temp_min;\n            imax = i;\n        }\n        else if(temp_max\
    \ - temp_min == max - min)\n        {\n            if(i < imax)\n            {\n\
    \                imax = i;\n            }\n        }\n    }\n    result = class_name\
    \ ~ \".\" ~ extensions[imax];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmd2n0g_b.d(24): Error: cannot implicitly convert expression `extensions[0].length`
    of type `ulong` to `int`

    /tmp/tmpmd2n0g_b.d(25): Error: cannot implicitly convert expression `extensions[0].length`
    of type `ulong` to `int`

    /tmp/tmpmd2n0g_b.d(38): Error: undefined identifier `ctype` in package `std`

    /tmp/tmpmd2n0g_b.d(42): Error: undefined identifier `ctype` in package `std`

    /tmp/tmpmd2n0g_b.d(51): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpmd2n0g_b.d(57): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmd2n0g_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = -1;\n    string extension\
    \ = extensions[0];\n    int n = extensions.length;\n    foreach(string ex; extensions)\
    \ {\n        int uppercase = 0;\n        int lowercase = 0;\n        foreach(char\
    \ c; ex) {\n            if (isupper(c)) uppercase++;\n            else lowercase++;\n\
    \        }\n        double strength = double(uppercase) - double(lowercase);\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            extension = ex;\n        }\n    }\n    return format(\"%s.%s\", class_name,\
    \ extension);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3pji7lqm.d(26): Error: cannot implicitly convert expression `extensions.length`
    of type `ulong` to `int`

    /tmp/tmp3pji7lqm.d(31): Error: undefined identifier `isupper`

    /tmp/tmp3pji7lqm.d(40): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3pji7lqm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    immutable wchar[] letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    int count_upper = 0;\n    int count_lower = 0;\n    int strongest_ext =\
    \ 0;\n    int strongest_index = 0;\n    foreach(ext; extensions)\n    {\n    \
    \    count_upper = 0;\n        count_lower = 0;\n        foreach(ch; ext)\n  \
    \      {\n            if(ch.toUpper.canFind(ch))\n            {\n            \
    \    count_upper++;\n            }\n            else\n            {\n        \
    \        count_lower++;\n            }\n        }\n        if(count_upper - count_lower\
    \ > strongest_ext)\n        {\n            strongest_ext = count_upper - count_lower;\n\
    \            strongest_index = cast(int)indexOf(extensions, ext);\n        }\n\
    \    }\n    return class_name ~ \".\" ~ extensions[strongest_index];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmx8p1jgu.d(35): Error: no property `toUpper` for type `immutable(char)`

    /tmp/tmpmx8p1jgu.d(47): Error: undefined identifier `indexOf`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmx8p1jgu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string[] class_words = class_name.split('_');\n\
    \    string class_cap = class_words.map!(w => w.toUpper).join;\n    int class_cap_count\
    \ = class_cap.count!(c => c.isUpper);\n    int class_sm_count = class_cap.count!(c\
    \ => c.isLower);\n    string class_str = class_cap.retro.replace('_', '');\n \
    \   int class_strength = class_cap_count - class_sm_count;\n    int current_strength\
    \ = class_strength;\n    int index = -1;\n    foreach(i, extension; extensions)\n\
    \    {\n        int cap_count = extension.count!(c => c.isUpper);\n        int\
    \ sm_count = extension.count!(c => c.isLower);\n        int strength = cap_count\
    \ - sm_count;\n        if(strength > current_strength)\n        {\n          \
    \  current_strength = strength;\n            index = i;\n        }\n    }\n  \
    \  if(index == -1) return format(\"%s.%s\", class_str, class_str);\n    else return\
    \ format(\"%s.%s\", class_str, extensions[index]);\n}\n// Test Cases\nunittest\n\
    {\n    string[] arr1 = [\"AA\", \"Be\", \"CC\"];\n    string[] arr2 = [\"CHeese\"\
    , \"Toast\"];\n    string[] arr3 = [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"\
    ];\n    string[] arr4 = [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"];\n    string[]\
    \ arr5 = [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"];\n    string[] arr6 = [\"\
    SErviNGSliCes\", \"Cheese\", \"StuFfed\"];\n    string[] arr7 = [\"SErviNGSliCes\"\
    , \"Cheese\", \"StuFfed\"];\n    string[] arr8 = [\"SErviNGSliCes\", \"Cheese\"\
    , \"StuFfed\"];\n    string[] arr9\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppq7wr8hh.d(28): Error: unterminated character constant

    /tmp/tmppq7wr8hh.d(57): Error: found `arr9` when expecting `;` following statement

    /tmp/tmppq7wr8hh.d(58): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppq7wr8hh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = tuple(0, \"\") ;\n    foreach(ext;\
    \ extensions)\n    {\n        auto n = count(ext, (c) { return 'A' <= c && c <=\
    \ 'Z'; } )\n              - count(ext, (c) { return 'a' <= c && c <= 'z'; } );\n\
    \        if(n > strongest[0])\n            strongest = tuple(n, ext);\n    }\n\
    \    return format(\"%s.%s\", class_name, strongest[1]);\n}\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl8nybnp_.d(27): Error: undefined identifier `count`

    /tmp/tmpl8nybnp_.d(28): Error: undefined identifier `count`

    /tmp/tmpl8nybnp_.d(32): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl8nybnp_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string s = \"\";\n    float max = -10000000;\n\
    \    int i = 0;\n    float cur;\n    foreach(string ex; extensions)\n    {\n \
    \       cur = float(ex.filter!(a => a.isUpper).length) - float(ex.filter!(a =>\
    \ a.isLower).length);\n        if(cur > max)\n        {\n            max = cur;\n\
    \            s = class_name ~ \".\" ~ ex;\n        }\n    }\n    return s;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphtbl123c.d(30): Error: no property `filter` for type `string`

    /tmp/tmphtbl123c.d(30): Error: no property `filter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphtbl123c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max = 0;\n    string result = class_name;\n\
    \    foreach(string extension; extensions)\n    {\n        double caps = 0, smalls\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c >= 'A'\
    \ && c <= 'Z')\n                caps += 1;\n            else if(c >= 'a' && c\
    \ <= 'z')\n                smalls += 1;\n        }\n        if(max < caps - smalls)\n\
    \        {\n            max = caps - smalls;\n            result = class_name\
    \ ~ \".\" ~ extension;\n        }\n    }\n    return result;\n}\n/*\nYou are given\
    \ a text string and a list of keywords. To make the text string\n    more secure\
    \ you want to remove all the keywords from the text string. \n    We will use\
    \ a very basic way of removal, by replacing the keywords in the \n    text string\
    \ by a space.\n    For example, if the text string is \"I really like really red\
    \ apples\" \n    and the keywords are [\"really\", \"red\"], we get \"I like apples\"\
    .\n    Create a function that takes a text string and a list of keywords and \n\
    \    returns the text string with the keywords removed.\n    Example:\n    >>>\
    \ Secure_Text(\"I really like really red apples\", [\"really\", \"red\"])\n  \
    \  \"I like apples\"\n*/\nstring Secure_Text(string text, string[] keywords) \n\
    {\n    text = text.toLower();\n    foreach(string s; keywords)\n    {\n      \
    \  int index = 0;\n        for(; index >= 0;)\n        {\n            index =\
    \ text.find(s);\n            if(index >= 0)\n                text = text[0..index]\
    \ ~ text[index+s.length..$];\n        }\n    }\n    return text;\n}\n/*\nArrays\
    \ of arrays are a useful data structure for many types of games and other applications.\n\
    \    They are also known as tables or grids. To keep things simple, we will be\
    \ using a 2D array.\n    Write a function that, given a 2D array, checks if it\
    \ contains a 2x2\n    block of the same values.\n    Example:\n    >>> Block_Check([\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiyfd0lpj.d(72): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiyfd0lpj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengs = extensions.map!(e => e.count!(c\
    \ => c.isUpperCase) - e.count!(c => c.isLowerCase));\n    int[] idx = iota(extensions.length);\n\
    \    idx.sort!((a, b) => strengs[a] < strengs[b] || strengs[a] == strengs[b] &&\
    \ a > b);\n    return format(\"%s.%s\", class_name, extensions[idx[0]]);\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxrog793q.d(24): Error: no property `map` for type `string[]`

    /tmp/tmpxrog793q.d(25): Error: undefined identifier `iota`

    /tmp/tmpxrog793q.d(26): Error: no property `sort` for type `int[]`

    /tmp/tmpxrog793q.d(27): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxrog793q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Your code goes here\n    real maxStrength =\
    \ 0;\n    string strongestExtension = \"\";\n    foreach(extension; extensions)\n\
    \    {\n        size_t uppers = 0;\n        size_t lowers = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(isUpper(c))\n                uppers++;\n\
    \            else\n                lowers++;\n        }\n        real strength\
    \ = cast(real)uppers - cast(real)lowers;\n        if(strength > maxStrength)\n\
    \        {\n            maxStrength = strength;\n            strongestExtension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongestExtension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_6xk616r.d(33): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_6xk616r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int CAP = 0;\n    int SM = 0;\n    double strongest\
    \ = 0;\n    int strongest_i = 0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length;\
    \ j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j]\
    \ <= 'Z')\n            {\n                CAP++;\n            }\n            else\
    \ if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n            {\n   \
    \             SM++;\n            }\n        }\n        if (CAP - SM > strongest)\n\
    \        {\n            strongest = CAP - SM;\n            strongest_i = i;\n\
    \        }\n    }\n    return class_name + \".\" + extensions[strongest_i];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu_367rmr.d(49): Error: invalid array operation `class_name + "."`
    (possible missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu_367rmr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int uppercase_count\
    \ = 0;\n        int lowercase_count = 0;\n        foreach(in char ch; extension)\n\
    \        {\n            if(isLower(ch))\n            {\n                lowercase_count++;\n\
    \            }\n            else if(isUpper(ch))\n            {\n            \
    \    uppercase_count++;\n            }\n        }\n        int temp_strength =\
    \ uppercase_count - lowercase_count;\n        if(temp_strength > strength)\n \
    \       {\n            strength = temp_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ldtzyy8.d(30): Error: basic type expected, not `in`

    /tmp/tmp1ldtzyy8.d(30): Error: no identifier for declarator `_error_`

    /tmp/tmp1ldtzyy8.d(30): Error: found `in` when expecting `;`

    /tmp/tmp1ldtzyy8.d(30): Error: found `ch` when expecting `.` following char

    /tmp/tmp1ldtzyy8.d(30): Error: found `;` when expecting identifier following `char`.

    /tmp/tmp1ldtzyy8.d(30): Error: found `extension` when expecting `)`

    /tmp/tmp1ldtzyy8.d(30): Error: found `)` instead of statement

    /tmp/tmp1ldtzyy8.d(36): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmp1ldtzyy8.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ldtzyy8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct Class_Extensions\n    {\n        string\
    \ class_name;\n        string strongest_extension;\n        int extension_strength;\n\
    \    }\n    int class_extension_strength = 0;\n    for(extension; extensions)\n\
    \    {\n        class_extension_strength = 0;\n        for(extension_letter; extension)\n\
    \        {\n            if(extension_letter.isUpper)\n            {\n        \
    \        class_extension_strength++;\n            }\n            else if(extension_letter.isLower)\n\
    \            {\n                class_extension_strength--;\n            }\n \
    \       }\n    }\n    return (class_name ~ \".\" ~ strongest_extension);\n}\n\
    /*\n    You are given a list of integers:\n    [1, 10, 7, 3, 3, 3, 4, 5, 5, 5,\
    \ 7, 8, 9, 10, 11, 4, 4, 5, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81huaxvf.d(31): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp81huaxvf.d(34): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmp81huaxvf.d(45): Error: found `}` when expecting `)`

    /tmp/tmp81huaxvf.d(48): Error: unterminated /* */ comment

    /tmp/tmp81huaxvf.d(65): Error: found `End of File` when expecting `)`

    /tmp/tmp81huaxvf.d(65): Error: found `End of File` instead of statement

    /tmp/tmp81huaxvf.d(65): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81huaxvf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164345
