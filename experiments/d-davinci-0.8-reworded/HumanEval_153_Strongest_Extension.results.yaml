language: d
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest)\n        {\n            strongest\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbkd9m9nl.d(31): Error: no property `isUpper` for type `immutable(char)`\n/tmp/tmpbkd9m9nl.d(33):
    Error: no property `isLower` for type `immutable(char)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpbkd9m9nl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    double strength\
    \ = -1.0;\n    foreach(string s; extensions) {\n        int caps = 0;\n      \
    \  int sms = 0;\n        foreach(char c; s) {\n            if(c >= 'A' && c <=\
    \ 'Z')\n                caps++;\n            else if(c >= 'a' && c <= 'z')\n \
    \               sms++;\n        }\n        double cur_strength = double(caps)/double(sms);\n\
    \        if(cur_strength > strength) {\n            strength = cur_strength;\n\
    \            strongest = s;\n        }\n    }\n    return class_name~\".\"~strongest;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpoxld3gux.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x429225]\n??:? void tmpoxld3gux.__unittest_L43_C1() [0x427d85]\n??:?
    void tmpoxld3gux.__modtest() [0x42848c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42daff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa3c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a939]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428f55]\n??:? runModuleUnitTests [0x42d8d5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429674]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4295fb]\n??:? _d_run_main [0x429566]\n??:? main [0x42849f]\n??:?
    __libc_start_main [0xf172e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = null;\n    float\
    \ highest_strength = 0;\n    float strength = 0;\n    foreach(string extension;\
    \ extensions)\n    {\n        strength = 0;\n        float CAP = 0;\n        float\
    \ SM = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper())\n\
    \            {\n                CAP++;\n            }\n            else\n    \
    \        {\n                SM++;\n            }\n        }\n        strength\
    \ = CAP - SM;\n        if(strength > highest_strength)\n        {\n          \
    \  highest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return (class_name ~ \".\" ~ strongest_extension);\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ncf2ytu.d(34): Error: no property `isUpper` for type `char`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ncf2ytu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    if (extensions.length == 0)\n        return class_name;\n\
    \    ulong i = 0;\n    double str = 0;\n    double temp = 0;\n    foreach (ext;\
    \ extensions)\n    {\n        temp = 0;\n        foreach (t; ext)\n        {\n\
    \            if (t.isUpper)\n                temp++;\n            else\n     \
    \           temp--;\n        }\n        if (temp > str)\n        {\n         \
    \   str = temp;\n            i = extensions.indexOf(ext);\n        }\n    }\n\
    \    return class_name ~ \".\" ~ extensions[i];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdin4k70o.d(34): Error: no property `isUpper` for type `immutable(char)`\n/tmp/tmpdin4k70o.d(42):
    Error: no property `indexOf` for type `string[]`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpdin4k70o.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return (class_name ~ \".\" ~ extensions[0]);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpev6kfi9q.d(30): unittest failure\n----------------\n??:?
    _d_unittestp [0x4290cd]\n??:? void tmpev6kfi9q.__unittest_L26_C1() [0x427c31]\n??:?
    void tmpev6kfi9q.__modtest() [0x428338]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e26]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a958]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a855]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428dfd]\n??:? runModuleUnitTests [0x42d7f1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429590]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x429517]\n??:? _d_run_main [0x429482]\n??:? main [0x42834b]\n??:?
    __libc_start_main [0x47c47554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float maxStrength = 0.0f;\n    int maxStrengthIndex\
    \ = 0;\n    float currentStrength = 0.0f;\n    int lowerCaseAmount = 0;\n    int\
    \ upperCaseAmount = 0;\n    foreach(index, extension; extensions)\n    {\n   \
    \     foreach(character; extension)\n        {\n            if(character.isUpper)\n\
    \            {\n                upperCaseAmount++;\n            }\n          \
    \  else\n            {\n                lowerCaseAmount++;\n            }\n  \
    \      }\n        currentStrength = (upperCaseAmount / (float)lowerCaseAmount);\n\
    \        if(currentStrength > maxStrength)\n        {\n            maxStrength\
    \ = currentStrength;\n            maxStrengthIndex = index;\n        }\n     \
    \   lowerCaseAmount = 0;\n        upperCaseAmount = 0;\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[maxStrengthIndex];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz4djyh_f.d(42): Error: C style cast illegal, use `cast(float)lowerCaseAmount`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz4djyh_f.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //TODO: Add code here\n    int current_max_strength\
    \ = -1;\n    string current_max_extension = \"\";\n    foreach(string ext; extensions)\n\
    \    {\n        int new_strength = 0;\n        foreach(char c; ext)\n        {\n\
    \            if(isupper(c))\n                new_strength++;\n            else\
    \ if(islower(c))\n                new_strength--;\n        }\n        if(new_strength\
    \ > current_max_strength)\n        {\n            current_max_strength = new_strength;\n\
    \            current_max_extension = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ current_max_extension;\n}\n/*\n    You are given an integer array\
    \ which represents the height of a histogram,\n    where the width of each bar\
    \ is 1. For example, if the array is [2, 3, 1, 2, 4],\n    then here is the histogram\
    \ that it represents:\n    *\n    * *\n    * *\n    * * *\n    * * *\n    Write\
    \ a function that takes in such an array and return the size of the largest\n\
    \    rectangle that can be made out of the histogram. For the histogram above,\n\
    \    the largest rectangle would be the 4x3 rectangle with the top-left corner\
    \ at (1, 2).\n    If the array is [2, 3, 1, 2, 4, 3], then here is the histogram\
    \ that it represents:\n    *\n    * *\n    * *\n    * * *\n    * * *\n    * *\
    \ *\n    The largest rectangle would be the 3x2 rectangle with the top-left corner\
    \ at (2, 3).\n    If the array is [5, 4, 3, 2, 1], then here is the histogram\
    \ that it represents:\n    * * * * *\n    * * * * *\n    * * * * *\n    * * *\
    \ * *\n    * * * * *\n    The largest rectangle would be the 5x1 rectangle with\
    \ the top-left corner at (0, 0).\n    If the array is [5, 4, 3, 2, 1, 6], then\
    \ here is the histogram that it represents:\n    * * *\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp433fht49.d(45): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp433fht49.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    uint max = 0;\n    foreach(ref string s; extensions)\n\
    \    {\n        uint count = 0;\n        foreach(c; s)\n        {\n          \
    \  if(isUpper(c))\n                count++;\n        }\n        if(count > max)\n\
    \            max = count;\n    }\n    return class_name ~ \".\" ~ extensions[max];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe0rqc9vj.d(30): Error: undefined identifier `isUpper`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0rqc9vj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n     int strength = -1;\n     int uppercase = 0;\n\
    \     int lowercase = 0;\n     string strongest_extension = \"\";\n     foreach(string\
    \ s; extensions)\n     {\n         foreach(char c; s)\n         {\n          \
    \   if(c.isUpper)\n             {\n                 uppercase++;\n           \
    \  }\n             else\n             {\n                 lowercase++;\n     \
    \        }\n         }\n         if(uppercase - lowercase > strength)\n      \
    \   {\n             strength = uppercase - lowercase;\n             strongest_extension\
    \ = s;\n         }\n         uppercase = 0;\n         lowercase = 0;\n     }\n\
    \     return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk0cuubsw.d(32): Error: no property `isUpper` for type `char`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk0cuubsw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // 1. Take string class_name and string[] extensions\n\
    \    // 2. Loop through extensions and calculate strength (total_upper - total_lower)\n\
    \    // 3. Return \"class_name.extension_with_highest_strength\"\n    //\n   \
    \ //  loop-extensions -> get-total-upper -> get-total-lower -> calculate-strength\
    \ ->\n    //  check-if-highest -> return-string\n    //  \n    //  loop-extensions\
    \ -> get-total-upper -> get-total-lower -> calculate-strength ->\n    //  check-if-highest\
    \ -> return-string\n    //  \n    //  loop-extensions -> get-total-upper -> get-total-lower\
    \ -> calculate-strength ->\n    //  check-if-highest -> return-string\n    //\
    \  \n    //  loop-extensions -> get-total-upper -> get-total-lower -> calculate-strength\
    \ ->\n    //  check-if-highest -> return-string\n    //  \n    //  return \"class_name.extension_with_highest_strength\"\
    \n    //  \n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n \
    \   //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy6nvqy1k.d(130): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy6nvqy1k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\t// your code goes here\n\tint c_count = 0;\n\tint\
    \ l_count = 0;\n\tfloat max_strength = -100;\n\tstring strongest_extension = \"\
    \";\n\tforeach(string extension; extensions)\n\t{\n\t\tforeach(char c; extension)\n\
    \t\t{\n\t\t\tif(isupper(c)) c_count++;\n\t\t\telse if(islower(c)) l_count++;\n\
    \t\t}\n\t\tfloat strength = (float)c_count - (float)l_count;\n\t\tif(strength\
    \ > max_strength)\n\t\t{\n\t\t\tmax_strength = strength;\n\t\t\tstrongest_extension\
    \ = extension;\n\t\t}\n\t\tc_count = 0;\n\t\tl_count = 0;\n\t}\n\treturn class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpepqgb6yl.d(36): Error: C style cast illegal, use `cast(float)c_count`\n/tmp/tmpepqgb6yl.d(36):
    Error: C style cast illegal, use `cast(float)l_count`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpepqgb6yl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.typecons;\n    // sort the array in\
    \ order\n    sort(extensions);\n    int[] strengths = new int[extensions.length];\n\
    \    for (int i = 0; i < extensions.length; i++) {\n        int cap_count = 0;\n\
    \        int small_count = 0;\n        for (int j = 0; j < extensions[i].length;\
    \ j++) {\n            char c = extensions[i][j];\n            if (c.isUpper) {\n\
    \                cap_count++;\n            } else {\n                small_count++;\n\
    \            }\n        }\n        strengths[i] = cap_count - small_count;\n \
    \   }\n    int best_strength = strengths[0];\n    int best_index = 0;\n    for\
    \ (int i = 1; i < strengths.length; i++) {\n        if (strengths[i] > best_strength)\
    \ {\n            best_strength = strengths[i];\n            best_index = i;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ extensions[best_index];\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgrsquuz1.d(26): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\n/tmp/tmpgrsquuz1.d(33): Error: no property `isUpper` for
    type `char`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgrsquuz1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = -9;\n    string Max = \"\";\n    foreach(string\
    \ val; extensions)\n    {\n        int up = 0;\n        int low = 0;\n       \
    \ foreach(char c; val)\n        {\n            if(c.isUpper)\n               \
    \ up++;\n            else\n                low++;\n        }\n        if(up -\
    \ low > max)\n        {\n            max = up - low;\n            Max = val;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ Max;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1ddki68x.d(32): Error: no property `isUpper` for type `char`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ddki68x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    if (extensions.length == 0)\n        return class_name;\n\
    \    string greatest = extensions[0];\n    int greatest_strength = 0;\n    foreach\
    \ (string extension; extensions)\n    {\n        int strength = 0;\n        foreach\
    \ (char c; extension)\n        {\n            if (isUpper(c))\n              \
    \  strength++;\n            else if (isLower(c))\n                strength--;\n\
    \        }\n        if (strength > greatest_strength)\n        {\n           \
    \ greatest_strength = strength;\n            greatest = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ greatest;\n}\n/*\nA square matrix of integers\
    \ is given as input. Your task is to determine\nif the matrix is magic square.\
    \ You must follow the definition of\nmagic square which is:\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp41tzrc9j.d(46): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp41tzrc9j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct ExtensionStrength\n    {\n        size_t\
    \ index;\n        float strength;\n        bool operator<(ExtensionStrength other)\
    \ const\n        {\n            if (this.strength != other.strength)\n       \
    \         return this.strength < other.strength;\n            return this.index\
    \ < other.index;\n        }\n    }\n    auto strengths = extensions.map!(ext =>\
    \ {\n        int sm = 0;\n        int cap = 0;\n        foreach (immutable char\
    \ c; ext)\n        {\n            if (isUpper(c))\n                cap++;\n  \
    \          else\n                sm++;\n        }\n        return ExtensionStrength(ext.indexOf,\
    \ cast(float)cap / (sm+1));\n    });\n    auto strongest = strengths.max;\n  \
    \  return class_name ~ \".\" ~ extensions[strongest.index];\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpima8k_bo.d(28): Error: semicolon expected, not `<`\n/tmp/tmpima8k_bo.d(28):
    Error: declaration expected, not `<`\n/tmp/tmpima8k_bo.d(32): Error: declaration
    expected, not `return`\n/tmp/tmpima8k_bo.d(48): Error: declaration expected, not
    `return`\n/tmp/tmpima8k_bo.d(49): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpima8k_bo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = 0;\n    string strongest_name = extensions[0];\n\
    \    foreach(string e; extensions)\n    {\n        int curr = countUp(e) - countDown(e);\n\
    \        if(curr > max)\n        {\n            max = curr;\n            strongest_name\
    \ = e;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_name;\n}\n\
    private int countUp(string name)\n{\n    int count = 0;\n    foreach(char c; name)\n\
    \    {\n        if(c.isUpper)\n            count++;\n    }\n    return count;\n\
    }\nprivate int countDown(string name)\n{\n    int count = 0;\n    foreach(char\
    \ c; name)\n    {\n        if(c.isLower)\n            count++;\n    }\n    return\
    \ count;\n}\n/*\n    Write a function that takes a number and returns all of its\
    \ prime factors.\n    The result should be a tuple of numbers arranged from smallest\
    \ to largest.\n    For example, if the input is 120, the output should be (2,\
    \ 2, 2, 3, 5).\n    Example:\n    >>> prime_factors(120)\n    (2, 2, 2, 3, 5)\n\
    \    \n*/\nTuple!(int[]) prime_factors(int n)\n{\n    Tuple!(int[]) factors;\n\
    \    int[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    foreach(int prime; primes)\n    {\n\
    \        while(n % prime == 0)\n        {\n            n /= prime;\n         \
    \   factors ~= prime;\n        }\n    }\n    return factors;\n}\n/*\n    You are\
    \ given a list of integers. You should count the smallest number of \n    swaps\
    \ needed to sort the list in non-decreasing order.\n    A swap is defined as a\
    \ pair of elements being swapped. Each element can \n    only be swapped once.\n\
    \    The list is always sorted in non-\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpykdbzv8b.d(80): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpykdbzv8b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strong = 0;\n    int strong_pos = 0;\n   \
    \ int i;\n    int sm;\n    int cap;\n    string result;\n    if (extensions.length\
    \ == 0) \n    {\n        return class_name;\n    }\n    foreach (auto extension;\
    \ extensions) \n    {\n        int sm = 0;\n        int cap = 0;\n        i =\
    \ 0;\n        while (i < extension.length) \n        {\n            if (extension[i]\
    \ > 64 && extension[i] < 91) \n            {\n                cap++;\n       \
    \     }\n            else if (extension[i] > 96 && extension[i] < 123) \n    \
    \        {\n                sm++;\n            }\n            i++;\n        }\n\
    \        int s = cap - sm;\n        if (s > strong) \n        {\n            strong\
    \ = s;\n            strong_pos = i;\n        }\n    }\n    result = class_name\
    \ ~ \".\" ~ extensions[strong_pos];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpas6hcfix.d(34): Error: basic type expected, not `auto`\n/tmp/tmpas6hcfix.d(34):
    Error: no identifier for declarator `_error_`\n/tmp/tmpas6hcfix.d(34): Error:
    found `auto` when expecting `;`\n/tmp/tmpas6hcfix.d(34): Error: found `;` when
    expecting `)`\n/tmp/tmpas6hcfix.d(34): Error: found `)` when expecting `;` following
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpas6hcfix.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = class_name;\n    double max_strength\
    \ = 0;\n    foreach(string ext; extensions) {\n        double strength = 0;\n\
    \        foreach(char c; ext) {\n            if (c >= 'A' && c <= 'Z') {\n   \
    \             strength += 1;\n            } else if (c >= 'a' && c <= 'z') {\n\
    \                strength -= 1;\n            }\n        }\n        if (strength\
    \ > max_strength) {\n            max_strength = strength;\n            result\
    \ = class_name ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4rgn3gtl.d(48): unittest failure\n----------------\n??:?
    _d_unittestp [0x42925d]\n??:? void tmp4rgn3gtl.__unittest_L42_C1() [0x427f93]\n??:?
    void tmp4rgn3gtl.__modtest() [0x4284c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db37]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428fb6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa74]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a971]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428f8d]\n??:? runModuleUnitTests [0x42d90d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296ac]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x429633]\n??:? _d_run_main [0x42959e]\n??:? main [0x4284d7]\n??:?
    __libc_start_main [0xea7a5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strength_of_extension = 0.0;\n    float[]\
    \ strength_of_all_extensions = new float[extensions.length];\n    for (int i =\
    \ 0; i < extensions.length; i++)\n    {\n        for (int j = 0; j < extensions[i].length;\
    \ j++)\n        {\n            if (isupper(extensions[i][j]))\n            {\n\
    \                strength_of_extension += 1;\n            }\n            else\n\
    \            {\n                strength_of_extension -= 1;\n            }\n \
    \       }\n        strength_of_all_extensions[i] = strength_of_extension;\n  \
    \      strength_of_extension = 0;\n    }\n    uint pos_of_strongest_extension\
    \ = max_element_index(strength_of_all_extensions);\n    return class_name + \"\
    .\" + extensions[pos_of_strongest_extension];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgfkqkcrp.d(30): Error: undefined identifier `isupper`\n/tmp/tmpgfkqkcrp.d(42):
    Error: undefined identifier `max_element_index`\n/tmp/tmpgfkqkcrp.d(43): Error:
    invalid array operation `class_name + "."` (possible missing [])\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpgfkqkcrp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real max_strength = real.min;\n    string max_ext;\n\
    \    foreach(ext; extensions)\n    {\n        int caps = 0;\n        int sms =\
    \ 0;\n        foreach(c; ext)\n        {\n            if(c.isUpper)\n        \
    \        caps++;\n            else\n                sms++;\n        }\n      \
    \  real strength = cast(real)caps - cast(real)sms;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            max_ext = ext;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ max_ext;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf9zdtcqq.d(24): Error: no property `min` for type `real`\n/tmp/tmpf9zdtcqq.d(32):
    Error: no property `isUpper` for type `immutable(char)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpf9zdtcqq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string current_strongest = \"\";\n    double strongest_strength\
    \ = 0;\n    foreach(string ext; extensions) {\n        int upper = count_if!(\"\
    a >= 'A' && a <= 'Z'\")(ext);\n        int lower = count_if!(\"a >= 'a' && a <=\
    \ 'z'\")(ext);\n        double strength = to!double(upper) - to!double(lower);\n\
    \        if(strength > strongest_strength) {\n            strongest_strength =\
    \ strength;\n            current_strongest = ext;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ current_strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdkbsnyvp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto caps = extension => extension.countif!(c\
    \ => c.isUpper);\n    auto sm = extension => extension.countif!(c => c.isLower);\n\
    \    auto strongest = extensions.min!\"a.count - b.count\"(a, b) => a.count >\
    \ b.count ? a : b;\n    return strongest.count > 0 ? $\"{class_name}.{strongest}\"\
    \ : class_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfcbrpeb2.d(26): Error: semicolon expected following auto declaration,
    not \''=>\''\n/tmp/tmpfcbrpeb2.d(26): Error: found \''=>\'' instead of statement\n/tmp/tmpfcbrpeb2.d(27):
    Error: \''$\'' is valid only inside [] of index or slice\n/tmp/tmpfcbrpeb2.d(27):
    Error: found \''"{class_name}.{strongest}"\'' when expecting \'':\''\n/tmp/tmpfcbrpeb2.d(27):
    Error: expression expected, not \'':\''\n/tmp/tmpfcbrpeb2.d(27): Error: found
    \''class_name\'' when expecting \'';\'' following return statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfcbrpeb2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_extension_strength = 0;\n    string\
    \ strongest_extension = \"\";\n    foreach(string extension; extensions)\n   \
    \ {\n        double extension_strength = 0;\n        extension_strength = extension.count!(\"\
    A-Z\") - extension.count!(\"a-z\");\n        if(extension_strength > max_extension_strength)\n\
    \        {\n            max_extension_strength = extension_strength;\n       \
    \     strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt26g45yq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tint i = 0;\n\tint CAP = 0;\n\tint SM = 0;\n\tfloat\
    \ strength = 0;\n\tfloat StrengthTest = 0;\n\tstring ChosenOne = \"\";\n\twhile\
    \ (i < extensions.length)\n\t{\n\t\tCAP = 0;\n\t\tSM = 0;\n\t\tint j = 0;\n\t\t\
    while (j < extensions[i].length)\n\t\t{\n\t\t\tif (extensions[i][j] >= 'A' &&\
    \ extensions[i][j] <= 'Z')\n\t\t\t{\n\t\t\t\tCAP++;\n\t\t\t}\n\t\t\telse if (extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z')\n\t\t\t{\n\t\t\t\tSM++;\n\t\t\t}\n\t\t\t\
    j++;\n\t\t}\n\t\tstrength = CAP - SM;\n\t\tif (strength > StrengthTest)\n\t\t\
    {\n\t\t\tStrengthTest = strength;\n\t\t\tChosenOne = extensions[i];\n\t\t}\n\t\
    \ti++;\n\t}\n\treturn class_name + \".\" + ChosenOne;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprnrchfe3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string a = \"\";\n    float max = 0;\n    foreach(string\
    \ i; extensions)\n    {\n        float CAP = 0;\n        float SM = 0;\n     \
    \   float strenght = 0;\n        foreach(char j; i)\n        {\n            if(j\
    \ >= 'A' && j <= 'Z')\n            {\n                CAP = CAP + 1;\n       \
    \     }\n            else\n            {\n                SM = SM + 1;\n     \
    \       }\n        }\n        strenght = CAP - SM;\n        if(strenght > max)\n\
    \        {\n            max = strenght;\n            a = i;\n        }\n    }\n\
    \    return class_name + \".\" + a;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqa155tge.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto extension_strength = (ext) { \n        num(std.string.countif(ext,\
    \ (c) => std.char.isUpper(c))) \n        - num(std.string.countif(ext, (c) =>\
    \ std.char.isLower(c))) \n    };\n    auto strongest_extension = std.algorithm.reduce!(extension_strength)(extensions);\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt87flfwc.d(25): Error: identifier expected following \''.\'',
    not \''char\''\n/tmp/tmpt87flfwc.d(26): Error: identifier expected following \''.\'',
    not \''char\''\n/tmp/tmpt87flfwc.d(27): Error: found \''}\'' when expecting \'';\''
    following statement\n/tmp/tmpt87flfwc.d(31): Error: semicolon expected following
    auto declaration, not \''unittest\''\n/tmp/tmpt87flfwc.d(31): Error: found \''unittest\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt87flfwc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strength = 0;\n    int value = 0;\n    string\
    \ strongest_extension = \"\";\n    foreach(string ext; extensions)\n    {\n  \
    \      foreach(char c; ext)\n        {\n            if(c.isUpper)\n          \
    \  {\n                value++;\n            }\n            else if(c.isLower)\n\
    \            {\n                strength++;\n            }\n        }\n      \
    \  if(value - strength > 0)\n        {\n            if(strongest_extension ==\
    \ \"\")\n            {\n                strongest_extension = ext;\n         \
    \   }\n            else if(value - strength > (value - strength)(strongest_extension))\n\
    \            {\n                strongest_extension = ext;\n            }\n  \
    \      }\n        strength = 0;\n        value = 0;\n    }\n    if(strongest_extension\
    \ == \"\")\n    {\n        return class_name;\n    }\n    return class_name ~\
    \ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ui_vk6a.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strength = 0.0;\n    string strongest =\
    \ \"\";\n    foreach(string s; extensions) {\n        int lower = 0;\n       \
    \ int upper = 0;\n        foreach(char c; s) {\n            if(isUpper(c))\n \
    \               upper++;\n            else\n                lower++;\n       \
    \ }\n        if((double)upper / (double)lower > strength) {\n            strength\
    \ = (double)upper / (double)lower;\n            strongest = s;\n        }\n  \
    \  }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpluxg8fq8.d(35): Error: C style cast illegal, use cast(double)upper\n/tmp/tmpluxg8fq8.d(35):
    Error: C style cast illegal, use cast(double)lower\n/tmp/tmpluxg8fq8.d(36): Error:
    C style cast illegal, use cast(double)upper\n/tmp/tmpluxg8fq8.d(36): Error: C
    style cast illegal, use cast(double)lower\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpluxg8fq8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //use built in methods\n    int max_strength =\
    \ extensions[0].count('A') - extensions[0].count('a');\n    string strongest_extension\
    \ = extensions[0];\n    foreach(i, extension; extensions)\n    {\n        int\
    \ local_strength = extension.count('A') - extension.count('a');\n        if(local_strength\
    \ > max_strength)\n        {\n            max_strength = local_strength;\n   \
    \         strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\n/*\n    You are given a list of numbers and\
    \ a target number. You should write a \n    function that returns a tuple that\
    \ contains the index of two numbers that\n    add up to the target number.\n \
    \   If a pair of numbers is found, the function should return a tuple that\n \
    \   contains their indices. The indices of the numbers should be 1-based, and\n\
    \    their order does not matter.\n    Example:\n    >>> FindIndices([1, 3, 5,\
    \ 7, 11], 4)\n    (1, 3)\n    >>> FindIndices([1, 3, 5, 7, 11], 1)\n    (-1, -1)\n\
    */\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wiek64r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = class_name;\n    float best_strength\
    \ = 0;\n    int i = 0;\n    foreach(extension; extensions)\n    {\n        auto\
    \ smalls = extension.filter!(a => a.isLower);\n        auto caps = extension.filter!(a\
    \ => a.isUpper);\n        float current_strength = float(caps.length) - float(smalls.length);\n\
    \        if(current_strength > best_strength)\n        {\n            best_strength\
    \ = current_strength;\n            result ~= \".\" ~ extension;\n        }\n \
    \       else if(current_strength == best_strength)\n        {\n            float\
    \ first_index = extensions.indexOf(result.split(\".\")[1]);\n            float\
    \ second_index = extensions.indexOf(extension);\n            if(second_index <\
    \ first_index)\n            {\n                result = class_name ~ \".\" ~ extension;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfd__g7dc.d(31): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmpfd__g7dc.d(31): Error: semicolon expected, not \'')\''\n/tmp/tmpfd__g7dc.d(31):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpfd__g7dc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjs6e38gq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return class_name + \".\" +\n    extensions.max(0,\
    \ a, b => {\n        auto nCapsA = a.count(c => c.isUpper);\n        auto nCapsB\
    \ = b.count(c => c.isUpper);\n        auto nSmallsA = a.count(c => c.isLower);\n\
    \        auto nSmallsB = b.count(c => c.isLower);\n        return float(nCapsA\
    \ - nSmallsA) - float(nCapsB - nSmallsB);\n    });\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzg50w8o7.d(30): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmpzg50w8o7.d(30): Error: found \'')\'' when expecting \'';\''
    following return statement\n/tmp/tmpzg50w8o7.d(30): Error: found \''(\'' when
    expecting \''.\'' following float\n/tmp/tmpzg50w8o7.d(30): Error: found \'')\''
    when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpzg50w8o7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real best_strength = 1.0f;\n    string best_extension\
    \ = \"\";\n    foreach(extension; extensions) {\n        int upper_case_count\
    \ = 0;\n        int lower_case_count = 0;\n        foreach(ch; extension) {\n\
    \            if(ch.isUpper) {\n                upper_case_count++;\n         \
    \   } else if(ch.isLower) {\n                lower_case_count++;\n           \
    \ }\n        }\n        real strength = cast(real)upper_case_count / cast(real)lower_case_count;\n\
    \        if(strength < best_strength) {\n            best_strength = strength;\n\
    \            best_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ best_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwcgjmxd8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  string str_class_name = class_name.toLower();\n\
    \  string temp = extensions[0];\n  double max_strength = 0.0;\n  double temp_strength\
    \ = 0.0;\n  foreach(i, element; extensions)\n  {\n    temp_strength = 0.0;\n \
    \   foreach(x, ite; element)\n    {\n      if(isUpper(ite))\n      {\n       \
    \ temp_strength++;\n      }\n      else\n      {\n        temp_strength--;\n \
    \     }\n    }\n    if(temp_strength > max_strength)\n    {\n      max_strength\
    \ = temp_strength;\n      temp = element;\n    }\n  }\n  return class_name + \"\
    .\" + temp;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n  \
    \  assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_3_azvm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = extensions[0];\n    float strong_strength\
    \ = 0;\n    foreach(ext; extensions)\n    {\n        int upper = 0;\n        int\
    \ lower = 0;\n        foreach(i; ext)\n        {\n            if(isUpper(i)) \n\
    \            {\n                upper++;\n            }\n            else\n  \
    \          {\n                lower++;\n            }\n        }\n        float\
    \ temp = (float)upper / (float)lower;\n        if(temp >= strong_strength)\n \
    \       {\n            strong_strength = temp;\n            strongest = ext;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6d83us71.d(41): Error: C style cast illegal, use cast(float)upper\n/tmp/tmp6d83us71.d(41):
    Error: C style cast illegal, use cast(float)lower\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6d83us71.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  struct Extension\n  {\n    int Strength;\n    string\
    \ Name;\n  }\n  int max_strength = 0;\n  string strongest_extension = \"\";\n\
    \  foreach(index, value; extensions)\n  {\n    int CAP = 0;\n    int SM = 0;\n\
    \    foreach(ch; value)\n    {\n      if (ch in ['A' .. 'Z'])\n        CAP++;\n\
    \      else if (ch in ['a' .. 'z'])\n        SM++;\n    }\n    if (max_strength\
    \ < CAP - SM)\n    {\n      max_strength = CAP - SM;\n      strongest_extension\
    \ = value;\n    }\n  }\n  return class_name ~ \".\" ~ strongest_extension;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp30scepuq.d(37): Error: found \''..\'' when expecting \'',\''\n/tmp/tmp30scepuq.d(39):
    Error: found \''..\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp30scepuq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest_extension = tuple(0.0, \"nothing\"\
    );\n    int i = 0;\n    foreach(extension; extensions)\n    {\n        auto strength\
    \ = extension.filter!(x => x.isUpperCase).length - extension.filter!(x => x.isLowerCase).length;\n\
    \        if(strength > strongest_extension[0])\n        {\n            strongest_extension\
    \ = tuple(strength, extension);\n        }\n        else if(strength == strongest_extension[0])\n\
    \        {\n            if(i < extensions.indexOf(strongest_extension[1]))\n \
    \           {\n                strongest_extension = tuple(strength, extension);\n\
    \            }\n        }\n        i++;\n    }\n    return class_name ~ \".\"\
    \ ~ strongest_extension[1];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpijjdtnk8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //write your code here\n    class strength\n \
    \   {\n        int capital;\n        int small;\n        public:\n        strength(string\
    \ s)\n        {\n            capital = 0;\n            small = 0;\n          \
    \  for(char c : s)\n            {\n                if(c.isUpper)\n           \
    \         capital++;\n                else if(c.isLower)\n                   \
    \ small++;\n            }\n        }\n        int getStrength()\n        {\n \
    \           return capital - small;\n        }\n    }\n    auto charFunc = function(char\
    \ c)\n    {\n        if(c.isUpper)\n            return 1;\n        else if(c.isLower)\n\
    \            return -1;\n        else\n            return 0;\n    }\n    /*\n\
    \    auto func = function(string s)\n    {\n        int capital = count(s.filter!(a\
    \ => a.isUpper));\n        int small = count(s.filter!(a => a.isLower));\n   \
    \     int strength = capital - small;\n        return strength;\n    }\n    */\n\
    \    auto func = function(string s)\n    {\n        int capital = count(s.filter!(a\
    \ => a.isUpper));\n        int small = count(s.filter!(a => a.isLower));\n   \
    \     int strength = capital - small;\n        return strength;\n    }\n    //auto\
    \ max = extensions.map!(c => strength(c).getStrength).max;\n    auto max = extensions.map!(func).max;\n\
    \    //auto max = extensions.map!(c => c.map!(charFunc).sum).max;\n    /*\n  \
    \  auto max = extensions.map!(c => {\n        int capital = count(c.filter!(a\
    \ => a.isUpper));\n        int small = count(c.filter!(a => a.isLower));\n   \
    \     int strength = capital - small;\n        return strength;\n    }).max;\n\
    \    */\n    auto result = extensions.map!(c => tuple(func(c), c)).filter!(c =>\
    \ c[0] == max).take(1)[0][1];\n    //auto result = extensions.map!(\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8isr6zok.d(30): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmp8isr6zok.d(31):
    Error: no identifier for declarator strength(string s)\n/tmp/tmp8isr6zok.d(34):
    Error: semicolon expected, not \'':\''\n/tmp/tmp8isr6zok.d(34): Error: expression
    expected, not \'':\''\n/tmp/tmp8isr6zok.d(34): Error: found \''s\'' when expecting
    \'';\'' following for condition\n/tmp/tmp8isr6zok.d(65): Error: semicolon expected
    following auto declaration, not \''auto\''\n/tmp/tmp8isr6zok.d(73): Error: semicolon
    expected following auto declaration, not \''auto\''\n/tmp/tmp8isr6zok.d(85): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8isr6zok.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n    auto ext_info =  zip(extensions, map!(a\
    \ => tuple(a.filter!(c => c.isUpper).length, a.filter!(c => c.isLower).length),\
    \ extensions));\n    auto ext_sorted = ext_info.sort!(a => a[1][0] - a[1][1]);\n\
    \    return format(\"%s.%s\", class_name, ext_sorted[$-1][0]);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptu_hthps.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest = 0;\n    int index_of_strongest\
    \ = 0;\n    int strength;\n    foreach(int i, string ext; extensions)\n    {\n\
    \        strength = to!int(std.algorithm.count_if!(t => islower(t))(ext));\n \
    \       if(strength > strongest)\n        {\n            strongest = strength;\n\
    \            index_of_strongest = i;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[index_of_strongest];\n}\n/*\nYou are given an array of\
    \ integers and a number, k. \nYou should find the sum of all numbers that are\
    \ greater than \ntheir k-th successor.\nExample:\n>>> Solution([1,2,3,4,5,6,7,8,9,10],\
    \ 3)\n40\n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp73ke_mmf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    alias strongest_extension = Tuple!(string, double);\n\
    \    const strongest_extension zero = tuple(\"\", 0.0);\n    // The reduce function\
    \ will return the tuple that holds the name and the strength\n    // of the strongest\
    \ extension.\n    return class_name ~ \".\" ~ reduce!((a, b) => a[1] > b[1] ?\
    \ a : b)(zero, map!((extension) => {\n        int big = 0;\n        int small\
    \ = 0;\n        foreach(char c; extension) {\n            if (c.isUpper) big++;\n\
    \            else if (c.isLower) small++;\n        }\n        return tuple(extension,\
    \ double(big - small));\n    })(extensions))[0];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5hnczagl.d(35): Error: found \''(\'' when expecting \''.\''
    following double\n/tmp/tmp5hnczagl.d(35): Error: found \'')\'' when expecting
    \'';\'' following return statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp5hnczagl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  //write code here\n  int value = 0;\n  int diff\
    \ = 0;\n  foreach(element; extensions)\n  {\n    int cap = 0;\n    int sm = 0;\n\
    \    foreach(ch; element)\n    {\n      if(ch.isUpper)\n        cap++;\n     \
    \ else if(ch.isLower)\n        sm++;\n    }\n    int dif = cap - sm;\n    if(dif\
    \ > diff)\n    {\n      diff = dif;\n      value = extensions.indexOf(element);\n\
    \    }\n  }\n  return class_name ~ \".\" ~ extensions[value];\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurllx7x5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest = -1000;\n    string strongest_ext\
    \ = \"\";\n    foreach(string ext; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(dchar c; ext)\n        {\n            if(c.isUpper)\n\
    \                strength += 1;\n            else\n                strength -=\
    \ 1;\n        }\n        if(abs(strength) > abs(strongest))\n        {\n     \
    \       strongest = strength;\n            strongest_ext = ext;\n        }\n \
    \   }\n    return to!string(class_name ~ \".\" ~ strongest_ext);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp89ngolf2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string myExt = \"\";\n    float myExtStrength\
    \ = 1;\n    foreach(string ext; extensions)\n    {\n        float extStrength\
    \ = 0;\n        for(int i = 0; i < ext.length; i++)\n        {\n            if(ext[i]\
    \ > 64 && ext[i] < 91)\n            {\n                extStrength++;\n      \
    \      }\n            else if(ext[i] > 96 && ext[i] < 123)\n            {\n  \
    \              extStrength--;\n            }\n        }\n        if(extStrength\
    \ < myExtStrength)\n        {\n            myExt = ext;\n            myExtStrength\
    \ = extStrength;\n        }\n    }\n    return class_name ~ \".\" ~ myExt;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi8qytp0_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // your code\n    double strength_cap = 0;\n \
    \   double strength_sm = 0;\n    double strong_ext = 0;\n    string strong_ext_name\
    \ = \"\";\n    foreach(ext; extensions)\n    {\n        strength_cap = 0;\n  \
    \      strength_sm = 0;\n        foreach(i; 0 .. ext.length)\n        {\n    \
    \        if(ext[i] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n            {\n       \
    \         strength_cap++;\n            }\n            else\n            {\n  \
    \              strength_sm++;\n            }\n        }\n        if(strong_ext\
    \ < strength_cap - strength_sm)\n        {\n            strong_ext = strength_cap\
    \ - strength_sm;\n            strong_ext_name = ext;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strong_ext_name;\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuq3o3uf6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = extensions[0];\n    float maxStrength\
    \ = (Strongest_Extension_Strength(extensions[0]));\n    foreach(extension; extensions[1..$])\n\
    \    {\n        float strength = Strongest_Extension_Strength(extension);\n  \
    \      if(strength > maxStrength)\n        {\n            maxStrength = strength;\n\
    \            strongest = extension;\n        }\n    }\n    return class_name ~\
    \ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprf_opzg6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = -1;\n    auto strongest_ext =\
    \ \"\";\n    foreach(ext; extensions)\n    {\n        auto upcases = ext.count!(c\
    \ => c.isUpper);\n        auto locases = ext.count!(c => c.isLower);\n       \
    \ auto strength = cast(double)upcases / (upcases + locases);\n        if(strength\
    \ > strongest)\n        {\n            strongest = strength;\n            strongest_ext\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_ext;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ckv6nd4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = extensions[0];\n\
    \    real strength = Count(strongest_extension);\n    for (int i = 1; i < extensions.length;\
    \ i++)\n    {\n        int current_strength = Count(extensions[i]);\n        if\
    \ (current_strength > strength)\n        {\n            strength = current_strength;\n\
    \            strongest_extension = extensions[i];\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwi2rbkgi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    float strongest_strength\
    \ = -FLT_MAX;\n    foreach(ext; extensions)\n    {\n        float strength = 0;\n\
    \        foreach(c; ext)\n        {\n            if(c >= 'A' && c <= 'Z')\n  \
    \              strength++;\n            else if(c >= 'a' && c <= 'z')\n      \
    \          strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpokq07tec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest;\n    float strength = 0;\n \
    \   foreach(extension; extensions) \n    {\n        int upper = 0;\n        int\
    \ lower = 0;\n        foreach(char; extension) \n        {\n            if(isUpper(char))\
    \ upper++;\n            else lower++;\n        }\n        float cur_strength =\
    \ (upper-lower);\n        if(cur_strength > strength)\n        {\n           \
    \ strength = cur_strength;\n            strongest = extension;\n        }\n  \
    \  }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnr_m05cb.d(30): Error: no identifier for declarator char\n/tmp/tmpnr_m05cb.d(32):
    Error: found \'')\'' when expecting \''.\'' following char\n/tmp/tmpnr_m05cb.d(32):
    Error: found \'')\'' when expecting identifier following \''char.\''\n/tmp/tmpnr_m05cb.d(32):
    Error: found \''upper\'' when expecting \'',\''\n/tmp/tmpnr_m05cb.d(32): Error:
    expression expected, not \'';\''\n/tmp/tmpnr_m05cb.d(33): Error: found \''else\''
    when expecting \'',\''\n/tmp/tmpnr_m05cb.d(33): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpnr_m05cb.d(34): Error: expression expected, not \''}\''\n/tmp/tmpnr_m05cb.d(35):
    Error: found \''float\'' when expecting \'',\''\n/tmp/tmpnr_m05cb.d(35): Error:
    found \'';\'' when expecting \'',\''\n/tmp/tmpnr_m05cb.d(36): Error: expression
    expected, not \''if\''\n/tmp/tmpnr_m05cb.d(37): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmpnr_m05cb.d(38): Error: found \'';\'' when expecting \'',\''\n/tmp/tmpnr_m05cb.d(39):
    Error: found \'';\'' when expecting \'',\''\n/tmp/tmpnr_m05cb.d(40): Error: expression
    expected, not \''}\''\n/tmp/tmpnr_m05cb.d(41): Error: found \''}\'' when expecting
    \'',\''\n/tmp/tmpnr_m05cb.d(42): Error: expression expected, not \''return\''\n/tmp/tmpnr_m05cb.d(42):
    Error: found \''class_name\'' when expecting \'',\''\n/tmp/tmpnr_m05cb.d(42):
    Error: found \'';\'' when expecting \'',\''\n/tmp/tmpnr_m05cb.d(43): Error: expression
    expected, not \''}\''\n/tmp/tmpnr_m05cb.d(44): Error: found \''unittest\'' when
    expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnr_m05cb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongestStrength = 0;\n    string strongestExtension\
    \ = \"\";\n    double lowerCaseCount;\n    double upperCaseCount;\n    double\
    \ extensionStrength;\n    for (string extension : extensions)\n    {\n       \
    \ lowerCaseCount = 0;\n        upperCaseCount = 0;\n        for (char letter :\
    \ extension)\n        {\n            if (letter.isUpper())\n            {\n  \
    \              upperCaseCount += 1;\n            }\n            else if (letter.isLower())\n\
    \            {\n                lowerCaseCount += 1;\n            }\n        }\n\
    \        extensionStrength = upperCaseCount - lowerCaseCount;\n        if (extensionStrength\
    \ > strongestStrength)\n        {\n            strongestStrength = extensionStrength;\n\
    \            strongestExtension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongestExtension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmxx4n2m9.d(29): Error: found \''extension\'' when expecting
    \'';\'' following statement\n/tmp/tmpmxx4n2m9.d(29): Error: expression expected,
    not \'':\''\n/tmp/tmpmxx4n2m9.d(29): Error: found \''extensions\'' when expecting
    \'';\'' following for condition\n/tmp/tmpmxx4n2m9.d(33): Error: semicolon expected,
    not \'':\''\n/tmp/tmpmxx4n2m9.d(33): Error: expression expected, not \'':\''\n/tmp/tmpmxx4n2m9.d(33):
    Error: found \''extension\'' when expecting \'';\'' following for condition\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmxx4n2m9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto len = extensions.length;\n    auto first\
    \ = true;\n    auto max_strength = -1.0;\n    auto strongest_extension = \"\"\
    ;\n    foreach(extension; extensions)\n    {\n        auto cap = count_if!((c){return\
    \ isUpper(c);})(extension);\n        auto sm = count_if!((c){return isLower(c);})(extension);\n\
    \        auto strength = cast(double)cap / sm;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpouvnwhs7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    Tuple!(\"name\", \"strength\")[] ext_list = new\
    \ Tuple!(\"name\", \"strength\")[extensions.length];\n    for (int i = 0; i <\
    \ extensions.length; i++)\n    {\n        ext_list[i] = tuple(\"name\" => extensions[i],\
    \ \"strength\" => extensions[i].countUpper - extensions[i].countLower);\n    }\n\
    \    ext_list.sort!((a, b) => a.strength > b.strength);\n    return format(\"\
    %s.%s\", class_name, ext_list[0].name);\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmi8jvl1_.d(27): Error: found \''=>\'' when expecting \'',\''\n/tmp/tmpmi8jvl1_.d(27):
    Error: found \''=>\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpmi8jvl1_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            strength += (c.isUpper\
    \ && c != '-') ? 1 : -1;\n        }\n        if(strength >= max_strength)\n  \
    \      {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfru197q7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tstatic bool isUpper(dchar c) \n\t{\n\t\treturn c\
    \ >= 'A' && c <= 'Z';\n\t}\n\t\n\tstatic bool isLower(dchar c) \n\t{\n\t\treturn\
    \ c >= 'a' && c <= 'z';\n\t}\n\t\n\tauto ext = extensions.map!(ext => \n\t{\n\t\
    \treturn tuple(ext, ext.count!(isUpper) - ext.count!(isLower));\n\t}).max!((a,\
    \ b) => {\n\t\treturn (a[1] > b[1]) || (a[1] == b[1] && a[0] < b[0]);\n\t});\n\
    \t\n\treturn format(\"%s.%s\", class_name, ext[0]);\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpneebomae.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    foreach(e; extensions)\n    {\n        int upper\
    \ = 0;\n        int lower = 0;\n        foreach(c; e)\n        {\n           \
    \ if(c.isUpper) upper++;\n            else lower++;\n        }\n        e ~= \"\
    ,\" ~ to!string(upper - lower);\n    }\n    assert(extensions.length);\n    auto\
    \ tuple = max(extensions);\n    assert(tuple[0].find(\",\"));\n    string[] parts\
    \ = tuple[0].split(\",\");\n    assert(parts.length == 2);\n    return class_name\
    \ ~ \".\" ~ parts[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwcv_cjv0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength_list = [];\n    string[] sliced_extensions\
    \ = [];\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int upper_case_letters\
    \ = 0;\n        int lower_case_letters = 0;\n        foreach (c; extensions[i])\n\
    \        {\n            if (c.isUpper)\n            {\n                upper_case_letters++;\n\
    \            }\n            else\n            {\n                lower_case_letters++;\n\
    \            }\n        }\n        strength_list ~= cast(int)(upper_case_letters\
    \ - lower_case_letters);\n        sliced_extensions ~= extensions[i];\n    }\n\
    \    return class_name ~ \".\" ~ sliced_extensions[indexOf(strength_list, max(strength_list))];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8c52w8jk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double highest_value = -9999;\n    string strongest_extension;\n\
    \    foreach(string extension; extensions) {\n        int cap = 0;\n        int\
    \ sm = 0;\n        foreach(char c; extension) {\n            if(isupper(c)) cap++;\n\
    \            else sm++;\n        }\n        double strength = cap - sm;\n    \
    \    if(strength > highest_value) {\n            highest_value = strength;\n \
    \           strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp37yhu780.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    const int min_strength = -2;\n    real max_strength\
    \ = min_strength;\n    string strongest = \"\";\n    string candidate = \"\";\n\
    \    foreach(ext; extensions)\n    {\n        real cur_strength = real(countUpper(ext)\
    \ - countLower(ext));\n        if(cur_strength == max_strength)\n        {\n \
    \           // Choose the one that comes first in the array\n            if(ext\
    \ < candidate)\n            {\n                strongest = ext;\n            }\n\
    \        }\n        else if(cur_strength > max_strength)\n        {\n        \
    \    max_strength = cur_strength;\n            strongest = ext;\n        }\n \
    \   }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnir5sms3.d(30): Error: found \''(\'' when expecting \''.\''
    following real\n/tmp/tmpnir5sms3.d(30): Error: semicolon expected, not \'')\''\n/tmp/tmpnir5sms3.d(30):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnir5sms3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    int strongest_strength\
    \ = 0;\n    string current_extension = \"\";\n    int current_strength = 0;\n\
    \    foreach(extension; extensions)\n    {\n        current_extension = extension;\n\
    \        current_strength = 0;\n        foreach(char a; current_extension)\n \
    \       {\n            if(isUpper(a))\n            {\n                current_strength++;\n\
    \            }\n            else\n            {\n                current_strength--;\n\
    \            }\n        }\n        if(current_strength >= strongest_strength)\n\
    \        {\n            strongest_strength = current_strength;\n            strongest_extension\
    \ = current_extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nstatic assert(Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) ==\
    \ \"my_class.AA\");\nstatic assert(Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"Cc\"]) == \"my_class.AA\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"Aa\", \"Be\", \"CC\"]) == \"my_class.CC\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"aa\", \"Be\", \"CC\"]) == \"my_class.CC\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.AA\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.AA\");\nstatic\
    \ assert(Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"\
    ]) == \"Slices.SErviNGSliCes\");\nstatic assert(Strongest_Extension(\"my_class\"\
    , [\"NeW\", \"clasS\", \"For\", \"You\"]) == \"my_class.NeW\");\nstatic assert(Strongest_Extension(\"\
    my_class\", [\"NWe\", \"clasS\", \"For\", \"You\"]) == \"my\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpioqm0is3.d(64): Error: found \''Watashi\'' when expecting \'')\''\n/tmp/tmpioqm0is3.d(64):
    Error: found \''", ["\'' when expecting \'';\''\n/tmp/tmpioqm0is3.d(64): Error:
    no identifier for declarator tEN\n/tmp/tmpioqm0is3.d(64): Error: Declaration expected,
    not \''", "\''\n/tmp/tmpioqm0is3.d(72): Error: unterminated string constant starting
    at /tmp/tmpioqm0is3.d(72)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpioqm0is3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct Ext {\n        int cap;\n        int small;\n\
    \        string name;\n    }\n    Ext strongest;\n    Ext[] extension = new Ext[];\n\
    \    extension.length = extensions.length;\n    foreach(i, e; extensions) {\n\
    \        extension[i].name = e;\n        extension[i].cap = count(e.filter!(x\
    \ => x.isUpper));\n        extension[i].small = count(e.filter!(x => x.isLower));\n\
    \    }\n    strongest = extension[0];\n    foreach(i, e; extension) {\n      \
    \  if (strongest.cap - strongest.small < e.cap - e.small) {\n            strongest\
    \ = e;\n        }\n    }\n    return class_name ~ \".\" ~ strongest.name;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6t3qyp6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return cast(string)std.algorithm.maxElement(extensions,\
    \ (a, b) => score(a) > score(b));\n}\nalias score = (string ext) => {\n    return\
    \ ext.filter!(c => isUpper(c)).length - ext.filter!(c => isLower(c)).length;\n\
    };\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy67i330q.d(26): Error: basic type expected, not (\n/tmp/tmpy67i330q.d(26):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmpy67i330q.d(26): Error: semicolon expected to close
    alias declaration\n/tmp/tmpy67i330q.d(26): Error: Declaration expected, not \''=>\''\n/tmp/tmpy67i330q.d(28):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy67i330q.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = \"\";\n    double strength = 0;\n\
    \    string best = \"\";\n    string a = \"\";\n    bool cap = false;\n    bool\
    \ sm = false;\n    int count = 0;\n    foreach(string ext; extensions)\n    {\n\
    \        foreach(char c; ext)\n        {\n            if(c.isUpper)\n        \
    \    {\n                cap = true;\n            }\n            else if(c.isLower)\n\
    \            {\n                sm = true;\n            }\n        }\n       \
    \ if(cap && sm)\n        {\n            result = class_name ~ \".\" ~ ext;\n \
    \           strength = (ext.countUpper - ext.countLower) / ext.length;\n     \
    \       if(strength > 0)\n            {\n                a = class_name ~ \".\"\
    \ ~ ext;\n                best = a;\n            }\n            else if(strength\
    \ < 0)\n            {\n                a = class_name ~ \".\" ~ ext;\n       \
    \         best = a;\n            }\n            else if(strength == 0)\n     \
    \       {\n                a = class_name ~ \".\" ~ ext;\n                best\
    \ = a;\n            }\n        }\n        else\n        {\n            result\
    \ = class_name;\n        }\n    }\n    return best;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppp6n6dsh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    class strong\n    {\n        int strength;\n \
    \       string ext;\n        this(string ext) {\n            this.ext = ext;\n\
    \            int CAP = 0;\n            int SM = 0;\n            foreach(c; ext)\
    \ {\n                c.isUpper\n                ? CAP += 1\n                :\
    \ SM += 1;\n            }\n            this.strength = CAP - SM;\n        }\n\
    \        bool opEquals(strong s) {\n            return this.strength == s.strength;\n\
    \        }\n        bool opCmp(strong s) {\n            return this.strength >\
    \ s.strength;\n        }\n    }\n    strong strong_ext;\n    strong_ext.strength\
    \ = -99999;\n    int index = 0;\n    foreach(ext; extensions) {\n        strong\
    \ s = strong(ext);\n        if(s.strength > strong_ext.strength) {\n         \
    \   strong_ext = s;\n            index = indexOf(extensions, ext);\n        }\n\
    \    }\n    return class_name ~ \".\" ~ extensions[index];\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmputdtwosb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strength = (string s) => s.count(\"a..z\"\
    ) - s.count(\"A..Z\");\n    return format(\"%s.%s\", class_name, extensions.max!(strength)[0]);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2m7b_kwa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.algorithm;\n    import std.math;\n\
    \    import std.range;\n    import std.stdio;\n    import std.typecons;\n    auto\
    \ countUpper =(string s) => s.filter!(c => c.isUpper).length;\n    auto countLower\
    \ =(string s) => s.filter!(c => c.isLower).length;\n    struct Strength{string\
    \ strength; string name;}\n    auto strong = map!(e => Strength(to!string(countUpper(e)\
    \ - countLower(e)), e))(extensions);\n    strong.sort!((a, b) => a.strength.compare(b.strength));\n\
    \    return class_name ~ \".\" ~ strong[$-1].name;\n}\n//\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6577o266.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions) {\n        int strength =\
    \ extension.count!(char.isUpper) - extension.count!(char.isLower);\n        if(strength\
    \ > max_strength) {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp723g7n4u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strenght = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = countUntil!(extension[],\
    \ char c => c.isUpper);\n        int sm = countUntil!(extension[], char c => c.isLower);\n\
    \        int st = cap - sm;\n        if(max_strenght < st)\n        {\n      \
    \      max_strenght = st;\n            strongest_extension = extension;\n    \
    \    }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprikya4h_.d(28): Error: found \''c\'' when expecting \''.\''
    following char\n/tmp/tmprikya4h_.d(28): Error: found \''=>\'' when expecting identifier
    following \''char.\''\n/tmp/tmprikya4h_.d(28): Error: found \''c\'' when expecting
    \'')\'' following template argument list\n/tmp/tmprikya4h_.d(28): Error: semicolon
    expected, not \'')\''\n/tmp/tmprikya4h_.d(28): Error: found \'')\'' instead of
    statement\n/tmp/tmprikya4h_.d(29): Error: found \''c\'' when expecting \''.\''
    following char\n/tmp/tmprikya4h_.d(29): Error: found \''=>\'' when expecting identifier
    following \''char.\''\n/tmp/tmprikya4h_.d(29): Error: found \''c\'' when expecting
    \'')\'' following template argument list\n/tmp/tmprikya4h_.d(29): Error: semicolon
    expected, not \'')\''\n/tmp/tmprikya4h_.d(29): Error: found \'')\'' instead of
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprikya4h_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    int strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        int curr_strength =\
    \ 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n  \
    \              curr_strength++;\n            else\n                curr_strength--;\n\
    \        }\n        if(curr_strength > strength)\n        {\n            strength\
    \ = curr_strength;\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_hsd674.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = 0;\n    string strongest_ext\
    \ = \"\";\n    foreach(string e; extensions) {\n        float ext_strength = float(std.regex.matchAll(e,\
    \ `[A-Z]`).length) - \n                             float(std.regex.matchAll(e,\
    \ `[a-z]`).length);\n        if(ext_strength > strongest) {\n            strongest\
    \ = ext_strength;\n            strongest_ext = e;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp0eb_i0y.d(27): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmpp0eb_i0y.d(27): Error: semicolon expected, not \'')\''\n/tmp/tmpp0eb_i0y.d(27):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpp0eb_i0y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto s = extensions.sort!(\n                (string\
    \ x, string y) => \n                {\n                    int nx = x.length;\n\
    \                    int ny = y.length;\n                    int cx = 0;\n   \
    \                 int cy = 0;\n                    int sx = 0;\n             \
    \       int sy = 0;\n                    foreach(char ch; x)\n               \
    \     {\n                        if (std.ctype.isupper(ch))\n                \
    \            cx++;\n                        else if (std.ctype.islower(ch))\n\
    \                            sx++;\n                    }\n                  \
    \  foreach(char ch; y)\n                    {\n                        if (std.ctype.isupper(ch))\n\
    \                            cy++;\n                        else if (std.ctype.islower(ch))\n\
    \                            sy++;\n                    }\n                  \
    \  double dx = cx - sx;\n                    double dy = cy - sy;\n          \
    \          if (dx > dy)\n                        return 1;\n                 \
    \   else if (dx < dy)\n                        return -1;\n                  \
    \  else\n                        return 0;\n                }\n            );\n\
    \    return class_name ~ \".\" ~ s[$-1];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwg51misy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto res = tuple(extensions.map!(a => tuple(a,\
    \ a.count!\"isUpper\".curried, a.count!\"isLower\".curried)));\n    res = res.sort!((a,\
    \ b) => b[1] - b[2] > a[1] - a[2]);\n    return class_name ~ \".\" ~ res[0][0];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi8tdg6gl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strong = \"\";\n    double strong_len =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double cap_len = 0;\n\
    \        double sm_len = 0;\n        foreach(ch; extension)\n        {\n     \
    \       if(ch.isUpper)\n                cap_len++;\n            else\n       \
    \         sm_len++;\n        }\n        if(cap_len - sm_len > strong_len)\n  \
    \      {\n            strong_len = cap_len - sm_len;\n            strong = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strong;\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl8ha8ciy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float max_strength = 0.0;\n    int pos = 0;\n\
    \    float strength = 0.0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        strength = 0.0;\n        foreach (x; extensions[i])\n        {\n\
    \            if (isUpper(x))\n                strength++;\n            else\n\
    \                strength--;\n        }\n        if (strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            pos = i;\n     \
    \   }\n    }\n    return class_name ~ \".\" ~ extensions[pos];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp48alonq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Get the strength of the extensions\n    string[]\
    \ strengths = new string[extensions.length];\n    foreach(i, ex; extensions)\n\
    \    {\n        int lower = 0;\n        int upper = 0;\n        foreach(c; ex)\n\
    \        {\n            if(std.ascii.isUpper(c))\n                upper++;\n \
    \           else\n                lower++;\n        }\n        auto temp = format(\"\
    %s.%d\", ex, (upper - lower));\n        strengths[i] = temp;\n    }\n    std.algorithm.sort(strengths);\n\
    \    // Get the strongest extension\n    string strongest = strengths[0];\n  \
    \  return format(\"%s.%s\", class_name, strongest[0..$-3]);\n}\n/*\nYou are given\
    \ an array of people's names. You should return a string which \nconsists of the\
    \ last names of each of the people in the array.\n    The last name of each person\
    \ is separated by a comma.\n    Example:\n    >>> Names_To_String([\"Jake\", \"\
    Bruce\", \"Cameron\"])\n    \"Jake,Bruce,Cameron\"\n*/\nstring Names_To_String(string[]\
    \ names) \n{\n    string name_string = \"\";\n    foreach(n; names)\n    {\n \
    \       auto pos = n.find(\" \");\n        if(pos > 0)\n            name_string\
    \ ~= format(\"%s,\", n[(pos+1)..$]);\n        else\n            name_string ~=\
    \ format(\"%s,\", n);\n    }\n    return name_string[0..$-1];\n}\n/*\nYou are\
    \ given a string, write a function that would reverse the words in it,\n    but\
    \ not the characters. For example, if the string is \"Bob likes Alice\",\n   \
    \ then the function should return \"Alice likes Bob\".\n    Example:\n    >>>\
    \ Reverse_Words(\"Bob likes Alice\")\n    \"Alice likes Bob\"\n*/\nstring Reverse_Words(string\
    \ words) \n{\n    return words.split(' ').reverse().join(' ');\n}\n/*\nYou are\
    \ given a string consisting of two or more words separated by \nwhitespace. You\
    \ are to return a\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp97n9cn0p.d(78): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp97n9cn0p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double maxStrength = 0;\n    string strongest\
    \ = \"\";\n    foreach(ext; extensions)\n    {\n        double capNum = ext.count!(x\
    \ => x.isUpper);\n        double smNum = ext.count!(x => x.isLower);\n       \
    \ double strength = capNum - smNum;\n        if(strength > maxStrength)\n    \
    \    {\n            maxStrength = strength;\n            strongest = ext;\n  \
    \      }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp83uoj1oo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return class_name+\".\"+highest.sort!((a,b) =>\
    \ a.strength>b.strength)(map!(extension => tuple(extension, (to!(int)(filter!(c\
    \ => isUpper(c))(extension)).length)-(to!(int)(filter!(c => isLower(c))(extension)).length)))(extensions))[0][0];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplfb73tcb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongestExtension = \"\";\n    double\
    \ strongestStrength = double.min;\n    foreach(string extension; extensions)\n\
    \    {\n        double strength = (cap(extension) - lc(extension));\n        if(strength\
    \ > strongestStrength)\n        {\n            strongestStrength = strength;\n\
    \            strongestExtension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongestExtension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwop58iwz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double[] strengths = extensions.map!(extension\
    \ => to!double(extension.count!(a => a.isUpper) - extension.count!(a => a.isLower))).array;\n\
    \    int strongest_idx = strengths.maxIndex;\n    return class_name ~ \".\" ~\
    \ extensions[strongest_idx];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprnpqk2g9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int str_ext = 0;\n    int sm_ext = 0;\n    string\
    \ strongest_extension = \"\";\n    foreach(string ext; extensions)\n    {\n  \
    \      int strength = 0;\n        int str_count = 0;\n        int sm_count = 0;\n\
    \        foreach(char ch; ext)\n        {\n            if(isupper(ch))\n     \
    \       {\n                str_count++;\n            }\n            else\n   \
    \         {\n                sm_count++;\n            }\n        }\n        strength\
    \ = str_count - sm_count;\n        if(strength > str_ext)\n        {\n       \
    \     str_ext = strength;\n            strongest_extension = ext;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0l64dkbu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  double strength = 0;\n  string strongest_extension\
    \ = extensions[0];\n  foreach(extension; extensions)\n  {\n    double curr_strength\
    \ = 0;\n    foreach(letter; extension)\n    {\n      if(letter.isUpper) curr_strength++;\n\
    \      else curr_strength--;\n    }\n    if(curr_strength > strength)\n    {\n\
    \      strength = curr_strength;\n      strongest_extension = extension;\n   \
    \ }\n  }\n  return class_name ~ \".\" ~ strongest_extension;\n}\n//-----------------------------------------------------\n\
    /*\nYou will be given an array of alphanumeric characters. Your task is to\n \
    \   perform the following actions:\n    1. Go through the string and add all letters\
    \ to a new array. All letters\n    should be in lowercase and no duplicates allowed.\n\
    \    2. Go through the string and add all digits to a new array.\n    3. Sort\
    \ the letters alphabetically.\n    4. Sort the digits in order from smallest to\
    \ largest.\n    5. Take the first element from the letters array, add it to the\
    \ result\n    string and then delete it from the array. Take the first element\
    \ from the\n    digits array, add it to the result string and then delete it from\
    \ the array.\n    Keep doing this until you have exhausted either one of the two\
    \ arrays.\n    6. Return the result string.\n    Example:\n    >>> Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Code_Me(string[]\
    \ alphanumeric) \n{\n  string[] digits = [];\n  string[] letters = [];\n  foreach(symbol;\
    \ alphanumeric)\n  {\n    if(symbol.isAlpha) letters ~= symbol.toLower;\n    else\
    \ digits ~= symbol;\n  }\n  letters = sort(letters);\n  digits = sort(digits);\n\
    \  string result = \"\";\n  while(letters.length > 0 || digits.length > 0)\n \
    \ {\n    if(letters.length > 0)\n    {\n      result ~= letters[0];\n      letters\
    \ = letters[1..$];\n    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo6zfhqqf.d(80): Error: found \''unittest\'' instead of statement\n/tmp/tmpo6zfhqqf.d(94):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo6zfhqqf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap = 0;\n    int sm = 0;\n    double max\
    \ = 0;\n    string max_ext = \"\";\n    for (int i = 0; i < extensions.length;\
    \ i++) {\n        foreach (char c; extensions[i]) {\n            if (c.isUpper())\
    \ {\n                cap++;\n            } else {\n                sm++;\n   \
    \         }\n        }\n        if (cap - sm > max) {\n            max = cap -\
    \ sm;\n            max_ext = extensions[i];\n        }\n        cap = 0;\n   \
    \     sm = 0;\n    }\n    return class_name ~ \".\" ~ max_ext;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqolwtqa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return extensions.length == 0 \n        ? class_name\
    \ \n        : class_name ~ \".\" ~ extensions.filter!((string elt) { \n      \
    \      return elt.count!isUpper == abs(elt.count!isUpper - elt.count!isLower);\
    \ \n        }).min;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5i_dcb15.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string name = \"\";\n    double strength = 0;\n\
    \    double strong = 0;\n    foreach(e; extensions)\n    {\n        name = e;\n\
    \        strength = 0;\n        foreach(i; name)\n        {\n            if(isUpper(i))\n\
    \            {\n                strength++;\n            }\n            else\n\
    \            {\n                strength--;\n            }\n        }\n      \
    \  if(strong < strength)\n        {\n            strong = strength;\n        \
    \    name = e;\n        }\n    }\n    return class_name ~ \".\" ~ name;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy6cyoxuv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real maxStrength = 0;\n    string result;\n  \
    \  string currentExtension;\n    int CAP;\n    int SM;\n    foreach(currentExtension;\
    \ extensions)\n    {\n        CAP = std.string.countChars(currentExtension, (x){return\
    \ x.isUpper();});\n        SM = std.string.countChars(currentExtension, (x){return\
    \ x.isLower();});\n        if(CAP - SM > maxStrength)\n        {\n           \
    \ maxStrength = CAP - SM;\n            result = format(\"%s.%s\", class_name,\
    \ currentExtension);\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe5rf3qam.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string best_extension = \"\";\n    double best_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        int cap = 0;\n\
    \        int sm = 0;\n        foreach(char c; extension)\n        {\n        \
    \    if(c.isUpper)\n                cap++;\n            else\n               \
    \ sm++;\n        }\n        double strength = cast(double)cap - sm;\n        if(strength\
    \ > best_extension_strength)\n        {\n            best_extension_strength =\
    \ strength;\n            best_extension = extension;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ best_extension;\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppxv18sy8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest_extension_strength = -1;\n    string\
    \ strongest_extension_name = \"\";\n    int extension_strength = 0;\n    foreach(extension;\
    \ extensions)\n    {\n        extension_strength = extension.countOf!(ch => ch.isUpper)\
    \ - extension.countOf!(ch => ch.isLower);\n        if(extension_strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = extension_strength;\n \
    \           strongest_extension_name = extension;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest_extension_name;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpab6hg29w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = -1.1f;\n    string strongest_extension\
    \ = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        float\
    \ strength = 0.0f;\n        for (int j = 0; j < extensions[i].length; j++)\n \
    \       {\n            if (extensions[i][j] <= 'Z')\n                strength\
    \ += 1.0f;\n            else\n                strength -= 1.0f;\n        }\n \
    \       if (strength > strongest)\n        {\n            strongest = strength;\n\
    \            strongest_extension = extensions[i];\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4kwxnnru.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result;\n    real strongest = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        real cap = 0;\n        real sm = 0;\n\
    \        foreach(char letter; extension)\n        {\n            if(letter >=\
    \ 'A' && letter <= 'Z')\n            {\n                cap += 1;\n          \
    \  }\n            else if(letter >= 'a' && letter <= 'z')\n            {\n   \
    \             sm += 1;\n            }\n        }\n        real strength = cap\
    \ - sm;\n        if(strength > strongest)\n        {\n            strongest =\
    \ strength;\n            result = class_name ~ \".\" ~ extension;\n        }\n\
    \    }\n    return result;\n}\n/*\nYou will be given an array of integers and\
    \ a target value.\n    You should find the number of pairs of integers in the\
    \ array that has the\n    difference equal to the target value. A pair is considered\
    \ a single pair,\n    the order of the values doesn't matter.\n    For example,\
    \ if you are given the array [1, 2, 3, 4] and the target value\n    is 1 then\
    \ you should return 3 because there are three pairs of integers\n    that have\
    \ a difference of 1 in the array: (1, 2), (2, 3) and (3, 4).\n    Example:\n \
    \   >>> target_difference([1, 2, 3, 4], 1)\n    3\n*/\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv4sw7kpn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string output = \"\";\n    double max_strength\
    \ = double.min;\n    string max_extension = \"\";\n    foreach(e; extensions)\n\
    \    {\n        double upper = 0;\n        double lower = 0;\n        foreach(c;\
    \ e)\n        {\n            if(c.isUpper)\n            {\n                upper++;\n\
    \            }\n            else\n            {\n                lower++;\n  \
    \          }\n        }\n        double strength = upper / lower;\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   max_extension = e;\n        }\n    }\n    return format(\"%s.%s\", class_name,\
    \ max_extension);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprj5j05xq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int CAP = 0;\n    int SM = 0;\n    string rv =\
    \ \"\";\n    double [string] strength = [];\n    foreach(item; extensions) \n\
    \    {\n        item = item.toLower();\n        CAP = 0;\n        SM = 0;\n  \
    \      foreach(i; item)\n        {\n            if(i >= 'A' && i <= 'Z')\n   \
    \         {\n                CAP++;\n            }\n            else\n       \
    \     {\n                SM++;\n            }\n        }\n        //writefln(\"\
    item: %s, CAP: %d, SM: %d\", item, CAP, SM);\n        strength[item] = double(CAP)\
    \ - double(SM);\n    }\n    double max_strength = -INFINITY;\n    foreach(item;\
    \ strength)\n    {\n        if(item.value > max_strength)\n        {\n       \
    \     max_strength = item.value;\n            rv = item.key;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ rv;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfs0c_ro4.d(45): Error: found \''(\'' when expecting \''.\''
    following double\n/tmp/tmpfs0c_ro4.d(45): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpfs0c_ro4.d(45): Error: found \''(\'' when
    expecting \''.\'' following double\n/tmp/tmpfs0c_ro4.d(45): Error: found \'')\''
    when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpfs0c_ro4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n    auto exts = extensions.map!((x) => mixin(\"\
    x.length\")).array;\n    auto strength = extensions.map!((x) => x.filter!((y)\
    \ => y.isUpper).length - x.filter!((y) => y.isLower).length).array;\n    int i\
    \ = 0;\n    int max = strength[0];\n    int index = 0;\n    foreach(ex; extensions)\n\
    \    {\n        if(max < strength[i])\n        {\n            max = strength[i];\n\
    \            index = i;\n        }\n        i++;\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxmq1b0a7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //Parameters: \n    //class_name(string): the\
    \ name of the class.\n    //extensions(string[]): the list of extensions.\n  \
    \  //Returns: string\n    // the strongest extension.\n    // Constraints: \n\
    \    //   \u2022 All names consist of letters, there are no numbers and no symbols.\n\
    \    //   \u2022 The extension name can be longer than the class name.\n    //\
    \   \u2022 class_name and extensions are not empty and they contain at least one\
    \ \n    //   element.\n    auto extension_strength = [](string extension) {\n\
    \        int CAP = 0;\n        int SM = 0;\n        for (char ch : extension)\
    \ {\n            if (isUpper(ch)) {\n                CAP++;\n            } else\
    \ {\n                SM++;\n            }\n        }\n        return tuple(CAP,\
    \ SM);\n    };\n    tuple best_extension = tuple(0,0);\n    string best_extension_name\
    \ = \"\";\n    foreach (extension; extensions) {\n        tuple current_extension\
    \ = extension_strength(extension);\n        if (current_extension[0] > best_extension[0])\
    \ {\n            best_extension = current_extension;\n            best_extension_name\
    \ = extension;\n        } else if (current_extension[0] == best_extension[0])\
    \ {\n            if (current_extension[1] < best_extension[1]) {\n           \
    \     best_extension = current_extension;\n                best_extension_name\
    \ = extension;\n            }\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ best_extension_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5qqwbyxy.d(34): Error: found \''extension\'' when expecting
    \'',\''\n/tmp/tmp5qqwbyxy.d(34): Error: semicolon expected following auto declaration,
    not \''{\''\n/tmp/tmp5qqwbyxy.d(37): Error: semicolon expected, not \'':\''\n/tmp/tmp5qqwbyxy.d(37):
    Error: expression expected, not \'':\''\n/tmp/tmp5qqwbyxy.d(37): Error: found
    \''extension\'' when expecting \'';\'' following for condition\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5qqwbyxy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto cmp1 = cmp(a, b) { return a > b; };\n   \
    \ auto cmp2 = cmp(a, b) { return a < b; };\n    auto ext2strength = ext =>\n \
    \   {\n        ext.toUpper().filter!((x) => x.isUpper).length \n            -\
    \ ext.toLower().filter!((x) => x.isLower).length;\n    };\n    return format(\"\
    %s.%s\", class_name, extensions.sort!(cmp1, cmp2, ext2strength)[0]);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm8szin2b.d(24): Error: semicolon expected following auto declaration,
    not \''{\''\n/tmp/tmpm8szin2b.d(25): Error: semicolon expected following auto
    declaration, not \''{\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8szin2b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    int current_strength\
    \ = 0;\n    string max_extension = \"\";\n    foreach(string extension; extensions)\n\
    \    {\n        current_strength = 0;\n        foreach(char letter; extension)\n\
    \        {\n            if(isUpper(letter))\n            {\n                current_strength\
    \ += 1;\n            }\n            else if(isLower(letter))\n            {\n\
    \                current_strength -= 1;\n            }\n        }\n        if(current_strength\
    \ > max_strength)\n        {\n            max_strength = current_strength;\n \
    \           max_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8oh91mu8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto x = zip(extensions,map!(x => countUntil!(isUpper,true)(x.idup),extensions)).enumerate;\n\
    \    auto y = x.filter!(a => a[1][1] != 0).sort!(b => b[1][1]).array;\n    return\
    \ class_name ~ \".\" ~ y[$-1][1][0];\n}\nstatic struct Point{\n\tfloat x;\n\t\
    float y;\n\t\n\tthis(float x, float y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\
    }\n\t\n\tint hashof(){\n\t\treturn x.hashof ^ y.hashof;\n\t}\n\t\n\tbool opEquals(Point\
    \ p){\n\t\treturn this.x == p.x && this.y == p.y;\n\t}\n\t\n\tfloat getDistance(Point\
    \ p){\n\t\treturn sqrt((this.x - p.x)^2 + (this.y - p.y)^2);\n\t}\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8x3f0dk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strength;\n    float best_strength = -1000.0f;\n\
    \    string best_extension = \"\";\n    foreach(extension; extensions)\n    {\n\
    \        strength = 0.0f;\n        foreach(char ch; extension)\n        {\n  \
    \          if(ch >= 'A' && ch <= 'Z')\n            {\n                strength\
    \ += 1.0f;\n            }\n            else if(ch >= 'a' && ch <= 'z')\n     \
    \       {\n                strength -= 1.0f;\n            }\n        }\n     \
    \   if(strength > best_strength)\n        {\n            best_strength = strength;\n\
    \            best_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ best_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzs9s8yuf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension;\n\
    \    foreach(string ext; extensions)\n    {\n        int strength = 0;\n     \
    \   foreach(char c; ext)\n        {\n            if(isupper(c)) strength++;\n\
    \            else if(islower(c)) strength--;\n        }\n        if(strength >\
    \ max_strength)\n        {\n            max_strength = strength;\n           \
    \ strongest_extension = ext;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp8ri4wr1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest_strength;\n    string strongest_extension;\n\
    \    foreach(e; extensions)\n    {\n        double cap = 0;\n        double sm\
    \ = 0;\n        foreach(c; e)\n        {\n            if (toUpper(c) == c)\n \
    \               cap++;\n            else\n                sm++;\n        }\n \
    \       double strength = cap - sm;\n        if (strongest_strength < strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = e;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\n/*\nYou will be given 3 positive integers: a, b and n.\n    You have to output\
    \ an array of integers, each of which is formed by multiplying\n    a by b n-1\
    \ times, (i.e. a, a*b, a*b*b, a*b*b*b, ...).\n    You have to print the array\
    \ from the smallest value to the largest one.\n    If any of these elements is\
    \ greater than or equal to 2^32, then you should \n    output 'Overflow' in place\
    \ of that element.\n    Example:\n    >>> overflow(1, 2, 10)\n    [1, 2, 4, 8,\
    \ 16, 32, 64, 128, 256, 512]\n    >>> overflow(1, 1, 20)\n    [1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> overflow(3, 2, 32)\n \
    \   [3, 6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144, 12288, 24576, 49152,\n\
    \     98304, 196608, 393216, 786432, 1572864, 3145728, 6291456, 12582912, 25165824,\n\
    \     50331648, 100663296, 201326592, 402653184, 805306368, 1610612736, 3221225472,\n\
    \     'Overflow']\n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp809go2dw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = -1000;\n    string max_strength_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = \n            cast(double)sum(filter!(ch => ch.isUpper())(extension)) -\n\
    \            cast(double)sum(filter!(ch => ch.isLower())(extension));\n      \
    \  if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            max_strength_extension = extension;\n        }\n    }\n    return\
    \ format(\"%s.%s\", class_name, max_strength_extension);\n}\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcw13r3ah.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = 0;\n    string strongest_ext\
    \ = \"\";\n    foreach(string ext; extensions)\n    {\n        int uppercase =\
    \ 0;\n        int lowercase = 0;\n        for(int i = 0; i < ext.length; i++)\n\
    \        {\n            if(ext[i] == toupper(ext[i]))\n            {\n       \
    \         uppercase++;\n            }\n            else\n            {\n     \
    \           lowercase++;\n            }\n        }\n        double strength =\
    \ uppercase - lowercase;\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_ext = ext;\n       \
    \ }\n    }\n    return class_name ~ \".\" ~ strongest_ext;\n}\n/*\nYou are given\
    \ a string of positive integers. Your task is to return a string \nthat shows\
    \ how many times each digit was used in the original string.\n    For example:\n\
    \    >>> Histogram(\"0123456789\")\n    \"0000000000: 1 | 000000000: 0 | 00000000:\
    \ 0 | 0000000: 0 | 000000: 0 | 00000: 0 | 0000: 0 | 000: 0 | 00: 0 | 0: 0\"\n\
    \    >>> Histogram(\"1122\")\n    \"0000000000: 0 | 000000000: 0 | 00000000: 0\
    \ | 0000000: 0 | 000000: 0 | 00000: 0 | 0000: 0 | 000: 0 | 00: 1 | 0: 1\"\n  \
    \  >>> Histogram(\"11000110000\")\n    \"0000000000: 2 | 000000000: 0 | 00000000:\
    \ 1 | 0000000: 0 | 000000: 0 | 00000: 0 | 0000: 2 | 000: 0 | 00: 1 | 0: 1\"\n\
    \    The string should be formatted in this way:\n    \"<digit>: <count> | <digit>:\
    \ <count> | <digit>: <count> | ... | <digit>: <count>\"\n*/\nstring Histogram(string\
    \ input) \n{\n    string result = \"\";\n    int[] counts = new int[10];\n   \
    \ for(int i = 0; i < input.length; i++)\n    {\n        counts[to!int(input[i])]++;\n\
    \    }\n    for(int i = 0; i <\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8fmuf9gm.d(72): Error: expression expected, not \''unittest\''\n/tmp/tmp8fmuf9gm.d(73):
    Error: found \''{\'' when expecting \'';\'' following for condition\n/tmp/tmp8fmuf9gm.d(74):
    Error: expression expected, not \''alias\''\n/tmp/tmp8fmuf9gm.d(74): Error: found
    \''candidate\'' when expecting \'')\''\n/tmp/tmp8fmuf9gm.d(74): Error: found \''=\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8fmuf9gm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strength = 0.0;\n    int curr_strength\
    \ = 0;\n    int x = 0;\n    foreach(ext; extensions)\n    {\n        int counter_upper\
    \ = 0;\n        int counter_lower = 0;\n        foreach(c; ext)\n        {\n \
    \           if(isLower(c))\n                counter_lower++;\n            else\
    \ if(isUpper(c))\n                counter_upper++;\n        }\n        double\
    \ tmp = counter_upper - counter_lower;\n        if(tmp > strength)\n        {\n\
    \            strength = tmp;\n            x = curr_strength;\n        }\n    \
    \    curr_strength++;\n    }\n    return class_name ~ \".\" ~ extensions[x];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4d24m34s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string extension = extensions[0];\n    int strength\
    \ = (extension.count('A', 'Z') - extension.count('a', 'z'));\n    foreach(string\
    \ e; extensions)\n    {\n        int str = (e.count('A', 'Z') - e.count('a', 'z'));\n\
    \        if(str > strength)\n        {\n            strength = str;\n        \
    \    extension = e;\n        }\n    }\n    return class_name ~ \".\" ~ extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3xz7tt_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Code here\n    double s = 0;\n    int strongest\
    \ = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int sm\
    \ = extensions[i].count('a') + extensions[i].count('b') + extensions[i].count('c')\
    \ + extensions[i].count('d') + extensions[i].count('e') + extensions[i].count('f')\
    \ + extensions[i].count('g') + extensions[i].count('h') + extensions[i].count('i')\
    \ + extensions[i].count('j') + extensions[i].count('k') + extensions[i].count('l')\
    \ + extensions[i].count('m') + extensions[i].count('n') + extensions[i].count('o')\
    \ + extensions[i].count('p') + extensions[i].count('q') + extensions[i].count('r')\
    \ + extensions[i].count('s') + extensions[i].count('t') + extensions[i].count('u')\
    \ + extensions[i].count('v') + extensions[i].count('w') + extensions[i].count('x')\
    \ + extensions[i].count('y') + extensions[i].count('z');\n        int cap = extensions[i].count('A')\
    \ + extensions[i].count('B') + extensions[i].count('C') + extensions[i].count('D')\
    \ + extensions[i].count('E') + extensions[i].count('F') + extensions[i].count('G')\
    \ + extensions[i].count('H') + extensions[i].count('I') + extensions[i].count('J')\
    \ + extensions[i].count('K') + extensions[i].count('L') + extensions[i].count('M')\
    \ + extensions[i].count('N') + extensions[i].count('O') + extensions[i].count('P')\
    \ + extensions[i].count('Q') + extensions[i].count('R') + extensions[i].count('S')\
    \ + extensions[i].count('T') + extensions[i].count('U') + extensions[i].count('V')\
    \ + extensions[i].count('W') + extensions[i].count('X') + extensions[i].count('Y')\
    \ + extensions[i\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4e10rc_q.d(31): Error: found \''unittest\'' when expecting \'']\''\n/tmp/tmp4e10rc_q.d(32):
    Error: semicolon expected, not \''{\''\n/tmp/tmp4e10rc_q.d(45): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmp4e10rc_q.d(45): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp4e10rc_q.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float highestStrength = float.min;\n    string\
    \ strongestExtension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        int upper = 0;\n        int lower = 0;\n        for (int j = 0;\
    \ j < extensions[i].length; j++)\n        {\n            if (extensions[i][j]\
    \ == extensions[i].toupper())\n            {\n                upper++;\n     \
    \       }\n            else\n            {\n                lower++;\n       \
    \     }\n        }\n        float currentStrength = float(upper) - float(lower);\n\
    \        if (currentStrength > highestStrength)\n        {\n            highestStrength\
    \ = currentStrength;\n            strongestExtension = extensions[i];\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongestExtension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiobpds3z.d(41): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmpiobpds3z.d(41): Error: semicolon expected, not \'')\''\n/tmp/tmpiobpds3z.d(41):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpiobpds3z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tint max_strength = 0;\n\tstring strongest = \"\"\
    ;\n\t\n\tforeach(string extension; extensions)\n\t{\n\t\tint strength = 0;\n\t\
    \tforeach(char letter; extension)\n\t\t{\n\t\t\tif(isUpper(letter))\n\t\t\t\t\
    strength++;\n\t\t\telse\n\t\t\t\tstrength--;\n\t\t}\n\t\tif(strength > max_strength)\n\
    \t\t{\n\t\t\tmax_strength = strength;\n\t\t\tstrongest = extension;\n\t\t}\n\t\
    }\n\treturn class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiq1n0bgf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongestExtension;\n    float maximumStrength\
    \ = 0;\n    float currentStrength = 0;\n    foreach(extension; extensions)\n \
    \   {\n        currentStrength = to!float(countUpper(extension)) - to!float(countLower(extension));\n\
    \        if(currentStrength > maximumStrength)\n        {\n            maximumStrength\
    \ = currentStrength;\n            strongestExtension = extension;\n        }\n\
    \    }\n    return strongestExtension;\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxdrnby1c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest_extension = double.max;\n   \
    \ string extension_name = \"\";\n    foreach(string extension; extensions) {\n\
    \        uint uppercase_count = countUntil((cast(const(char)*)extension)[], \n\
    \            isLower);\n        uint lowercase_count = countUntil((cast(const(char)*)extension)[],\
    \ \n            isUpper);\n        double extension_strength = uppercase_count\
    \ - lowercase_count;\n        if(extension_strength < strongest_extension) {\n\
    \            strongest_extension = extension_strength;\n            extension_name\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ extension_name;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7cvknafv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max = 0;\n    int idx = 0;\n    string\
    \ result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n   \
    \     int cap = count(extensions[i].filter!isUpper);\n        int sm = count(extensions[i].filter!isLower);\n\
    \        if (cap - sm > max)\n        {\n            max = cap - sm;\n       \
    \     idx = i;\n        }\n    }\n    result = class_name ~ \".\" ~ extensions[idx];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5jw3keyd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = std.min(int.min, 1);\n    string\
    \ result = \"\";\n    foreach(string ext; extensions)\n    {\n        int CAP\
    \ = 0;\n        int SM = 0;\n        foreach(char c; ext)\n        {\n       \
    \     CAP += c.isUpper;\n            SM += c.isLower;\n        }\n        int\
    \ strength = CAP - SM;\n        if(strength > max_strength)\n        {\n     \
    \       max_strength = strength;\n            result = ext;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0namhuxr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Write your code here.\n    int l = extensions.length;\n\
    \    string res = \"\";\n    int maxStrength = 0;\n    for (int i = 0; i < l;\
    \ i++) {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j\
    \ < extensions[i].length; j++) {\n            if (extensions[i][j] == toUpper(extensions[i][j]))\
    \ {\n                cap++;\n            } else {\n                sm++;\n   \
    \         }\n        }\n        if (cap - sm > maxStrength) {\n            maxStrength\
    \ = cap - sm;\n            res = extensions[i];\n        }\n    }\n    return\
    \ class_name + \".\" + res;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmfe4aclx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float previous_strength = 0.0f;\n    int previous_index\
    \ = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int upper_case_count\
    \ = 0;\n        int lower_case_count = 0;\n        for (int j = 0; j < extensions[i].length;\
    \ j++)\n        {\n            if (is_upper(extensions[i][j]))\n            {\n\
    \                upper_case_count++;\n            }\n            else\n      \
    \      {\n                lower_case_count++;\n            }\n        }\n    \
    \    float current_strength = float(upper_case_count) - float(lower_case_count);\n\
    \        if (current_strength > previous_strength)\n        {\n            previous_strength\
    \ = current_strength;\n            previous_index = i;\n        }\n    }\n   \
    \ return class_name ~ \".\" ~ extensions[previous_index];\n}\nunittest\n{\n  \
    \  alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5_k_4agt.d(41): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmp5_k_4agt.d(41): Error: semicolon expected, not \'')\''\n/tmp/tmp5_k_4agt.d(41):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp5_k_4agt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float[] strength = new float[0];\n    int[] caps\
    \ = new int[0];\n    int[] sms = new int[0];\n    float stren;\n    int cap;\n\
    \    int sm;\n    string result;\n    int i;\n    int ctr = 0;\n    foreach(var\
    \ ext in extensions)\n    {\n        strength ~= stren = 0;\n        caps ~= cap\
    \ = 0;\n        sms ~= sm = 0;\n        foreach(var c in ext)\n        {\n   \
    \         if(c >= 'A' && c <= 'Z')\n            {\n                stren++;\n\
    \                cap++;\n            }\n            else if(c >= 'a' && c <= 'z')\n\
    \            {\n                stren--;\n                sm++;\n            }\n\
    \        }\n        strength[ctr] = stren;\n        caps[ctr] = cap;\n       \
    \ sms[ctr] = sm;\n        ctr++;\n    }\n    float strongest = max(strength);\n\
    \    int index = strength.indexOf(strongest);\n    result = class_name ~ \".\"\
    \ ~ extensions[index];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo43pw0fn.d(33): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpo43pw0fn.d(38):
    Error: found \''in\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpo43pw0fn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  float strngth = 0;\n  int strngth_cap = 0;\n  int\
    \ strngth_sm = 0;\n  float strngth_result = 0;\n  string result = \"\";\n  string\
    \ result_class_name = \"\";\n  string result_extension_name = \"\";\n  foreach(i;\
    \ 0 .. extensions.length)\n  {\n    foreach(j; 0 .. extensions[i].length)\n  \
    \  {\n      if (extensions[i][j] <= 90)\n      {\n        strngth_cap = strngth_cap\
    \ + 1;\n      }\n      else\n      {\n        strngth_sm = strngth_sm + 1;\n \
    \     }\n    }\n    strngth = strngth_cap - strngth_sm;\n    if (strngth == strngth_result)\n\
    \    {\n      if (result_extension_name > extensions[i])\n      {\n        result_extension_name\
    \ = extensions[i];\n      }\n    }\n    if (strngth > strngth_result)\n    {\n\
    \      strngth_result = strngth;\n      result_extension_name = extensions[i];\n\
    \    }\n    strngth_cap = 0;\n    strngth_sm = 0;\n  }\n  result_class_name =\
    \ class_name;\n  result = result_class_name ~ \".\" ~ result_extension_name;\n\
    \  return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzajcxn8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string[] temp;\n    class strongest\n    {\n \
    \       string name;\n        int strength;\n    }\n    strongest test = new strongest;\n\
    \    test.name = extensions[0];\n    test.strength = to!int((count(class_name,\
    \ isupper) - count(class_name, islower)));\n    foreach(string i; extensions)\n\
    \    {\n        temp = i.split(\"_\");\n        if(test.strength <= to!int((count(i,\
    \ isupper) - count(i, islower))))\n        {\n            test.name = i;\n   \
    \         test.strength = to!int((count(i, isupper) - count(i, islower)));\n \
    \       }\n    }\n    return class_name + \".\" + test.name;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwi80y9v2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n}\n/*\nThe value of a positive integer n is\
    \ defined to be the sum of all the positive divisors of n. \n    We define N(n)\
    \ to be the sum of all values of n. You are given an array of positive integers\
    \ A. \n    For each element in the array find the sum of all values which are\
    \ less than or equal to that element. \n    For example if A[i] = 5 then N(A[i])\
    \ = 1 + 2 + 3 + 4 + 5 = 15. You should return an array containing \n    the values\
    \ N(A[0]), N(A[1]), ..., N(A[N-1]).\n    Example:\n    >>> Divisor_Sum_Array([1,\
    \ 5, 10])\n    [1, 15, 55]\n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb52h2k1l.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = 0.0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions) {\n        float cap = countUntil!((x)\
    \ => (x >= 'A' && x <= 'Z'))(extension.sli\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp02gowo4j.d(28): Error: found \''unittest\'' when expecting \'',\''\n/tmp/tmp02gowo4j.d(42):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmp02gowo4j.d(42): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmp02gowo4j.d(42): Error: expression
    expected, not \''}\''\n/tmp/tmp02gowo4j.d(42): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmp02gowo4j.d(42): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp02gowo4j.d(42):
    Error: semicolon expected, not \''EOF\''\n/tmp/tmp02gowo4j.d(42): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp02gowo4j.d(42):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp02gowo4j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongness = 0;\n    string strongest =\
    \ \"\";\n    foreach(string extension; extensions)\n    {\n        double tmp\
    \ = 0;\n        foreach(char ch; extension)\n        {\n            if (isupper(ch))\
    \ tmp += 1;\n            else tmp -= 1;\n        }\n        if (tmp > strongness)\
    \ \n        {\n            strongness = tmp;\n            strongest = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\n/*\n    This\
    \ is a one-dimensional version of the Lights Out puzzle. You will be given\n \
    \   an array (a) which contains a boolean value in each position. Every light\
    \ can \n    be either on or off. The goal is to turn all of the lights off. Every\
    \ light has\n    a switch which can be flipped to turn that light either on or\
    \ off. When you flip\n    a switch all of the lights to the right of the switch's\
    \ position flip their \n    states. You must return the minimum number of switches\
    \ that need to be flipped\n    to turn all of the lights off.\n    Example:\n\
    \    >>> Light_Out([1,1,1,1,1,1,1,1,1,1])\n    4\n*/\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf6766diq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    ulong max = 0;\n    string extension = \"\";\n\
    \    foreach(e; extensions)\n    {\n        uint upper = 0;\n        uint lower\
    \ = 0;\n        foreach(c; e)\n        {\n            if(isUpper(c)) upper++;\n\
    \            else lower++;\n        }\n        long strength = (long)upper - (long)lower;\n\
    \        if(strength > max)\n        {\n            max = strength;\n        \
    \    extension = e;\n        }\n    }\n    return class_name ~ \".\" ~ extension;\n\
    }\n/*\nYou have an array of integers. You should find the smallest positive integer\n\
    \    that is not present in the array. The array may contain negative numbers,\
    \ \n    zeros and positive numbers.\n    For example, in the array [1, 2, 3] the\
    \ smallest positive integer not\n    present is 4. In the array [-1, -3] the smallest\
    \ positive integer not\n    present is 1.\n    Example:\n    >>> Find_The_Smallest_Positive_Integer_Missing([1,\
    \ 2, 3])\n    4\n    >>> Find_The_Smallest_Positive_Integer_Missing([-1, -3])\n\
    \    1\n    >>> Find_The_Smallest_Positive_Integer_Missing([0, 5, -1, 1, 2, 5,\
    \ 3])\n    4\n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpshs6tsco.d(35): Error: C style cast illegal, use cast(long)upper\n/tmp/tmpshs6tsco.d(35):
    Error: C style cast illegal, use cast(long)lower\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpshs6tsco.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tdouble maxStrength = -100;\n\tint indx = 0;\n\t\
    for (int i = 0; i < extensions.length; i++) {\n\t\tdouble strength = 0;\n\t\t\
    for (int j = 0; j < extensions[i].length; j++) {\n\t\t\tif (extensions[i][j] >=\
    \ 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\tstrength += 1;\n\t\t\t} else {\n\t\
    \t\t\tstrength -= 1;\n\t\t\t}\n\t\t}\n\t\tif (strength > maxStrength) {\n\t\t\t\
    maxStrength = strength;\n\t\t\tindx = i;\n\t\t}\n\t}\n\treturn class_name + \"\
    .\" + extensions[indx];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6leiwjc2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result;\n    int max_cap = 0;\n    string\
    \ max_string = extensions[0];\n    int cap_count;\n    int sm_count;\n    foreach(string\
    \ item; extensions)\n    {\n        cap_count = 0;\n        sm_count = 0;\n  \
    \      foreach(char c; item)\n        {\n            if(isUpper(c))\n        \
    \        cap_count++;\n            else\n                sm_count++;\n       \
    \ }\n        if(cap_count - sm_count > max_cap)\n        {\n            max_cap\
    \ = cap_count - sm_count;\n            max_string = item;\n        }\n    }\n\
    \    result = class_name ~ \".\" ~ max_string;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp73dp7__s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct Extension \n    {\n        //string name;\n\
    \        int strength;\n    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz36ieqzr.d(29): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz36ieqzr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return class_name + \".\" + std.max(extensions,ext\
    \ => \n    {\n        return (ext.countif!(x => x.isupper()) - ext.countif!(x\
    \ => x.islower()));\n    });\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnr7rmpbe.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto rtn = class_name ~ \".\" ~ extensions[0];\n\
    \    int strongest_value = 0;\n    foreach(i, v; extensions)\n    {\n        auto\
    \ tmp = v.filter!(a => 'A' <= a && a <= 'Z').length;\n        tmp -= v.filter!(a\
    \ => 'a' <= a && a <= 'z').length;\n        if(tmp > strongest_value)\n      \
    \  {\n            strongest_value = tmp;\n            rtn = class_name ~ \".\"\
    \ ~ v;\n        }\n    }\n    return rtn;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeucvt1pv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest_streng = 0;\n    string Strongest_Extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double upp\
    \ = extension.count!(a => a.isUpper);\n        double low = extension.count!(a\
    \ => a.isLower);\n        double strength = upp - low;\n        if(strength >\
    \ strongest_streng)\n        {\n            strongest_streng = strength;\n   \
    \         Strongest_Extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ Strongest_Extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9mcr8_zt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    ulong index = 0, max = 0;\n    foreach(int i,\
    \ string ext; extensions)\n    {\n        ulong sum = count(ext.lowercase);\n\
    \        if (ext.length - sum > max)\n        {\n            max = ext.length\
    \ - sum;\n            index = i;\n        }\n    }\n    return class_name ~ \"\
    .\" ~ extensions[index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1x3lzqje.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double min_val = 1.1;\n    int min_ind = 0;\n\
    \    for (int i = 0; i < extensions.length; i++) {\n        double upper = 0.0;\n\
    \        double lower = 0.0;\n        foreach (c; extensions[i]) {\n         \
    \   if ('A' <= c && c <= 'Z')\n                upper += 1.0;\n            else\n\
    \                lower += 1.0;\n        }\n        double val = upper / lower;\n\
    \        if (val < min_val) {\n            min_val = val;\n            min_ind\
    \ = i;\n        }\n    }\n    return format(\"%s.%s\", class_name, extensions[min_ind]);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8toggmvc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real strongest = -real.max;\n    int strongest_i\
    \ = 0;\n    real temp = 0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        temp = 0;\n        foreach (char c; extensions[i])\n        {\n\
    \            if (toUpper(c) == c) temp += 1;\n            else temp -= 1;\n  \
    \      }\n        if (temp > strongest)\n        {\n            strongest = temp;\n\
    \            strongest_i = i;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ extensions[strongest_i];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpknptngir.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double class_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    // For each extension, calculate the strength and return the strongest.\n\
    \    foreach(string ext; extensions) {\n        double upper_case = 0;\n     \
    \   double lower_case = 0;\n        // Check each character of each extension\
    \ to calculate the strength.\n        foreach(char c; ext) {\n            if(c\
    \ >= 'A' && c <= 'Z') {\n                upper_case++;\n            } else if(c\
    \ >= 'a' && c <= 'z') {\n                lower_case++;\n            }\n      \
    \  }\n        // Get the strength of the current extension.\n        double current_strength\
    \ = upper_case - lower_case;\n        // If the strength of the current extension\
    \ is greater than the\n        // strength of the previous extension, update the\
    \ name of the\n        // strongest extension.\n        if(current_strength >\
    \ class_strength) {\n            class_strength = current_strength;\n        \
    \    strongest_extension = ext;\n        }\n    }\n    return class_name + \"\
    .\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7vohi3ps.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto t = (auto x) {\n        int upper = 0;\n\
    \        int lower = 0;\n        foreach(i;0..x.length) {\n            if(x[i]\
    \ == 'a' || x[i] == 'b' || x[i] == 'c' || x[i] == 'd' || x[i] == 'e' || x[i] ==\
    \ 'f' || x[i] == 'g' || x[i] == 'h' || x[i] == 'i' || x[i] == 'j' || x[i] == 'k'\
    \ || x[i] == 'l' || x[i] == 'm' || x[i] == 'n' || x[i] == 'o' || x[i] == 'p' ||\
    \ x[i] == 'q' || x[i] == 'r' || x[i] == 's' || x[i] == 't' || x[i] == 'u' || x[i]\
    \ == 'v' || x[i] == 'w' || x[i] == 'x' || x[i] == 'y' || x[i] == 'z') {\n    \
    \            lower++;\n            } else {\n                upper++;\n      \
    \      }\n        }\n        return double(upper) - double(lower);\n    };\n \
    \   double strength = 0;\n    string name = \"\";\n    foreach(ext;extensions)\
    \ {\n        if(t(ext) > strength) {\n            strength = t(ext);\n       \
    \     name = ext;\n        }\n    }\n    string result = class_name ~ \".\" ~\
    \ name;\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpex3lgf72.d(34): Error: found \''(\'' when expecting \''.\''
    following double\n/tmp/tmpex3lgf72.d(34): Error: found \'')\'' when expecting
    \'';\'' following return statement\n/tmp/tmpex3lgf72.d(34): Error: found \''(\''
    when expecting \''.\'' following double\n/tmp/tmpex3lgf72.d(34): Error: found
    \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpex3lgf72.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.math : abs;\n    struct Ext { \n  \
    \      string name;\n        double strength;\n    }\n    Ext max_strength = null;\n\
    \    foreach(ext; extensions) {\n        int caps = 0;\n        int sms = 0;\n\
    \        foreach(c; ext) {\n            if(isupper(c)) caps++;\n            else\
    \ if(islower(c)) sms++;\n        }\n        if(max_strength.strength < (caps -\
    \ sms)) {\n            max_strength = Ext(ext, caps - sms);\n        }\n    }\n\
    \    return max_strength == null ? \"\" : class_name ~ \".\" ~ max_strength.name;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjw2p82yt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double maxStrength = -10000;\n    string answer\
    \ = class_name;\n    foreach(string ext; extensions)\n    {\n        double currentStrength\
    \ = 0;\n        foreach(char c; ext)\n        {\n            if(isUpper(c))\n\
    \                currentStrength++;\n            else if(isLower(c))\n       \
    \         currentStrength--;\n        }\n        if(currentStrength > maxStrength)\n\
    \        {\n            maxStrength = currentStrength;\n            answer = format(\"\
    %s.%s\", class_name, ext);\n        }\n    }\n    return answer;\n}\n/*\n    The\
    \ function first assigns value to -10000 to maxStrength and assigns \n    class_name\
    \ to answer.\n    Then it goes through each item of the array extensions.\n  \
    \  Then it goes through each character of each item of the array extensions.\n\
    \    If the character is an uppercase letter then currentStrength++.\n    If the\
    \ character is a lowercase letter then currentStrength--.\n    If currentStrength\
    \ is greater than maxStrength then maxStrength is assigned the \n    value of\
    \ currentStrength and answer is assigned the value of the format string.\n   \
    \ Answer is then returned.\n    \n*/\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppzp_82b8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string ret = class_name;\n    double max_str =\
    \ 0;\n    foreach(ext; extensions)\n    {\n        double str = 1.0 * count(ext.filter!(c\
    \ => c.isUpperCase())) -\n                     1.0 * count(ext.filter!(c => c.isLowerCase()));\n\
    \        if(str > max_str)\n        {\n            max_str = str;\n          \
    \  ret ~= \".\" ~ ext;\n        }\n    }\n    return ret;\n}\nunittest\n{\n  \
    \  alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwu5jdkxi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest;\n    float value = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        float ext_value = 0;\n        foreach(wchar\
    \ t; ext)\n        {\n            if(isUpper(t))\n                ext_value++;\n\
    \            else\n                ext_value--;\n        }\n        if(ext_value\
    \ > value)\n        {\n            value = ext_value;\n            strongest =\
    \ ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppipdcesf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double maxStrenght = 0;\n    string ans = \"\"\
    ;\n    foreach(string ext; extensions)\n    {\n        int CAP = 0;\n        int\
    \ SM = 0;\n        foreach(char a; ext)\n        {\n            if(isupper(a))\n\
    \                CAP++;\n            else\n                SM++;\n        }\n\
    \        double strenght = (double)CAP - SM;\n        if(strenght > maxStrenght)\n\
    \        {\n            maxStrenght = strenght;\n            ans = ext;\n    \
    \    }\n    }\n    return class_name ~ \".\" ~ ans;\n}\n/*\nYou are given a string\
    \ array, whose elements represent your current name and\n    surname. Your new\
    \ name should be created in this way:\n    Your surname becomes your first name;\n\
    \    Your first name becomes your middle name;\n    Your middle name becomes your\
    \ surname;\n    Example:\n    >>> rename(\"Fred\", \"Smith\")\n    [\"Smith\"\
    , \"Fred\", \"\"]\n    >>> rename(\"Alex\", \"Dowd\")\n    [\"Dowd\", \"\", \"\
    Alex\"]\n    >>> rename(\"James\", \"Earl Jones\")\n    [\"Jones\", \"James\"\
    , \"Earl\"]\n*/\nstring[] rename(string name, string surname) \n{\n    string[]\
    \ ans = {surname, name, \"\"};\n    if(surname.length > 2)\n    {\n        string\
    \ middle = surname[1..$-1];\n        ans[1] = surname[0..0];\n        ans[2] =\
    \ middle;\n    }\n    return ans;\n}\n/*\nYou are given a string array and a string.\
    \ The goal is to rearrange the order\n    of the elements in the array in such\
    \ a way that all occurrences of the\n    string find are in the beginning of the\
    \ array. The remaining elements in\n    the array should be in their original\
    \ order. Return the rearranged array.\n    Example:\n    >>> find_and_sort([\"\
    somethi\", \"notthing\", \"find\", \"find\"], \"find\")\n    [\"find\", \"find\"\
    , \"somethi\", \"notthing\"]\n*/\nstring[] find_and_sort(string[] array, string\
    \ find)\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwe3nagr4.d(37): Error: C style cast illegal, use cast(double)CAP\n/tmp/tmpwe3nagr4.d(81):
    Error: semicolon expected following function declaration\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpwe3nagr4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real strength = 0;\n    string result = \"\";\n\
    \    foreach(string str; extensions)\n    {\n        string temp = str;\n    \
    \    temp = temp.toLower();\n        //count lower case letters\n        real\
    \ small = temp.count(\"[a-z]\");\n        //count CAP case letters\n        real\
    \ CAP = str.count(\"[A-Z]\");\n        real temp_strength = CAP - small;\n   \
    \     if(temp_strength >= strength)\n        {\n            strength = temp_strength;\n\
    \            result = str;\n        }\n    }\n    return class_name ~ \".\" ~\
    \ result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp801he9co.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto temp = class_name;\n    double max_strength\
    \ = -1000;\n    int index = 0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        double strength = to!double(extensions[i].filter!(a => a.isUpper).length)\
    \ \n                            - to!double(extensions[i].filter!(a => a.isLower).length);\n\
    \        if (strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            index = i;\n        }\n    }\n    return temp ~ \".\" ~ extensions[index];\n\
    }\n/*\nYou will be given two integers, x and y. \n    You will be given a list\
    \ of strings, each string has a length of x + y. \n    Find the shortest substring\
    \ in the strings that has a length of x and a \n    length of y. \n    For example:\
    \ Given a string 'AABBABBABAABBBA' and x = 2 and y = 3, \n    the shortest substring\
    \ is 'BBB'. \n    Example:\n    >>> Shortest_Substring(2, 3, [\"AABBABBABAABBBA\"\
    , \"AABBABBABAABBB\"])\n    \"BBB\"\n*/\nstring Shortest_Substring(int x, int\
    \ y, string[] arr) \n{\n    string result = \"\";\n    auto temp = arr.front;\n\
    \    bool found = false;\n    while (temp.length >= x + y)\n    {\n        if\
    \ (temp.contains(result))\n        {\n            temp = temp[temp.indexOf(result)\
    \ + result.length .. temp.length];\n        }\n        if (temp.length < x + y)\n\
    \        {\n            temp = temp[0 .. temp.length];\n        }\n        else\n\
    \        {\n            temp = temp[0 .. x + y];\n        }\n        if (temp.length\
    \ == x + y)\n        {\n            found = true;\n            break;\n      \
    \  }\n    }\n    return temp;\n}\n/*\nYou will be given a list of points (x and\
    \ y coordinates) and a radius. \n    You\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkdqxi64i.d(77): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpkdqxi64i.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    \n    auto strengts = new int[](extensions.length);\n\
    \    foreach(int i, string extension; zip(i,extension; extensions))\n    {\n \
    \       auto caps = 0;\n        auto smalls = 0;\n        foreach(char c; extension)\n\
    \        {\n            if (isUpper(c)) caps++;\n            else smalls++;\n\
    \        }\n        strengts[i] = caps - smalls;\n    }\n    import std.conv;\n\
    \    auto max = strengts.max;\n    auto strongest_ext = to!string(max);\n    return\
    \ class_name ~ \".\" ~ extensions[strongest_ext];\n    \n    \n    \n    \n  \
    \  \n}\n \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo8i6tg9x.d(26): Error: found \'';\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8i6tg9x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    int max_idx = 0;\n\
    \    for (int i = 0; i < extensions.length; i++)\n    {\n        int CAP = extensions[i].count(\"\
    [A-Z]\");\n        int SM = extensions[i].count(\"[a-z]\");\n        int strength\
    \ = CAP - SM;\n        if (strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            max_idx = i;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[max_idx];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9gov_v23.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct my_extension{\n        string name;\n \
    \       int strength;\n    }\n    auto my_extensions = appender!(my_extension[])();\n\
    \    foreach(extension; extensions) {\n        int count_cap = 0;\n        int\
    \ count_small = 0;\n        foreach(ch; extension) {\n            if(ch.isUpper)\
    \ {\n                count_cap += 1;\n            }\n            else {\n    \
    \            count_small += 1;\n            }\n        }\n        my_extensions.put(my_extension(extension,\
    \ count_cap - count_small));\n    }\n    my_extension max_extension = max(my_extensions.data);\n\
    \    return class_name ~ \".\" ~ max_extension.name;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpffb6bdvf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n  int N = extensions.length;\n  int[] strength = new\
    \ int[N];\n  int max_strength = 0;\n  int max_strength_index = 0;\n  foreach(int\
    \ i, string ext; extensions)\n  {\n    int CAP = countUntil!(x => isUpper(x),\
    \ ext);\n    int SM = countUntil!(x => isLower(x), ext);\n    strength[i] = CAP\
    \ - SM;\n    if(strength[i] > max_strength)\n    {\n      max_strength = strength[i];\n\
    \      max_strength_index = i;\n    }\n  }\n  return class_name ~ \".\" ~ extensions[max_strength_index];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8zasm1jp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // your code here\n    import std.stdio;\n   \
    \ writefln(\"Class name : %s\", class_name);\n    foreach(e; extensions)\n   \
    \ {\n        writefln(\"Extensions : %s\", e);\n    }\n    return \"\";\n}\n/*\n\
    The \"Drones\" are coming! And they are ready to do some nasty things, \nyour\
    \ job is to stop them before they do it!\n    \nThe drone can only move in the\
    \ following directions: up, down, left, right.\n    \nThe drone finds its current\
    \ position on a map which is in the form of a 2D array, \nit then checks the array\
    \ for one of these characters: / - \\\n    If the drone sees any of those, it\
    \ makes a decision on which direction it should fly next.\n    We will be given\
    \ a string array which will contain the map and a drone starting position \n \
    \   as a tuple of two integers (x, y) where x is the horizontal position and y\
    \ is the vertical.\n    You should return the direction the drone will take next.\n\
    \    The order of priority for direction is: down, up, left, right.\n    For example,\
    \ if the array is:\n    <<<\n    [[' ', ' ', ' ', ' ', ' ', ' ', ' '],\n     ['\
    \ ', ' ', ' ', ' ', ' ', ' ', ' '],\n     [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n\
    \     [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n     [' ', ' ', ' ', ' ', ' ', ' ',\
    \ ' '],\n     [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n     [' ', ' ', ' ', ' ',\
    \ ' ', ' ', ' ']]\n    >>>\n    And the drone's current position is: (1, 1)\n\
    \    Then the drone will return 'right' (since it can't go up or down).\n    Example:\n\
    \    >>> Drone_Flight_Plan([[' ', ' ', ' ', ' ', ' ', ' ', ' '],\n           \
    \                [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n                      \
    \     [' ', ' ', ' ', ' ', ' ', ' ', ' '],\n                           [' ', '\
    \ ', ' ', ' ', ' ', ' ', '\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd96y0m9d.d(33): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpd96y0m9d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest = extensions[0].count('A') -\
    \ extensions[0].count('a');\n    string strongest_extension = extensions[0];\n\
    \    foreach(extension; extensions)\n    {\n        double strength = extension.count('A')\
    \ - extension.count('a');\n        if(strength > strongest)\n        {\n     \
    \       strongest = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo9ntv8ad.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string answer = \"\";\n    float current_strength\
    \ = 0;\n    float strength = 0;\n    foreach(string extension; extensions)\n \
    \   {\n        strength = 0;\n        foreach(char ch; extension)\n        {\n\
    \            if(isUpper(ch))\n            {\n                strength += 1;\n\
    \            }\n            else\n            {\n                strength -= 1;\n\
    \            }\n        }\n        if(abs(strength) > abs(current_strength))\n\
    \        {\n            current_strength = strength;\n            answer = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ answer;\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7hbs5ex_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double[] extension_strength = extensions.map!(x\
    \ => (x.count!(char.isUpper) - x.count!(char.isLower)) / double(x.length)).array;\n\
    \    string strongest_extension = extensions[extension_strength.indexOf(max(extension_strength))];\n\
    \    return $\"{class_name}.{strongest_extension}\";\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe75mmow6.d(24): Error: found \''(\'' when expecting \''.\''
    following double\n/tmp/tmpe75mmow6.d(24): Error: semicolon expected, not \'')\''\n/tmp/tmpe75mmow6.d(24):
    Error: found \'')\'' instead of statement\n/tmp/tmpe75mmow6.d(26): Error: \''$\''
    is valid only inside [] of index or slice\n/tmp/tmpe75mmow6.d(26): Error: found
    \''"{class_name}.{strongest_extension}"\'' when expecting \'';\'' following return
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe75mmow6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int bestStrength = 0;\n    string strongestExtension\
    \ = \"\";\n    foreach(string ext; extensions)\n    {\n        int upperCase =\
    \ 0;\n        int lowerCase = 0;\n        foreach(wchar ch; ext)\n        {\n\
    \            if(ch.isUpper)\n                upperCase++;\n            else\n\
    \                lowerCase++;\n        }\n        int strength = upperCase - lowerCase;\n\
    \        if(strength > bestStrength)\n        {\n            bestStrength = strength;\n\
    \            strongestExtension = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongestExtension;\n}\n/*\nYou will be given the names of two classes\
    \ and a list of dependencies. Dependencies\nare the items that need to be initialized\
    \ before the given item. The function should\nreturn a sorted list of all the\
    \ given classes.\nExample:\n>>> Get_Sorted_Classes([\"A\", \"B\", \"C\"], [[\"\
    C\", \"A\"], [\"B\", \"A\"]])\n[\"A\", \"B\", \"C\"]\n*/\nstring[] Get_Sorted_Classes(string[]\
    \ classes, string[][] dependencies) \n{\n    auto classesMap = classes.map!(s\
    \ => s.toLower() => 0);\n    classes.each!(s => s.toLower() => 0);\n    foreach(string[]\
    \ dep; dependencies)\n    {\n        if(classesMap.contains(dep[0].toLower())\
    \ && classesMap.contains(dep[1].toLower()))\n        {\n            classesMap[dep[0].toLower()]++;\n\
    \            classesMap[dep[1].toLower()]--;\n        }\n    }\n    auto sortedClasses\
    \ = classesMap.map!(t => t.key)();\n    sortedClasses.sort!((a, b) => classesMap[a]\
    \ > classesMap[b]);\n    return sortedClasses;\n}\n/*\nYou will be given an array\
    \ of numbers and a value n. You should find the n-th \n    highest number in the\
    \ array and return it. If n is 0 or negative or larger\n    than the size of the\
    \ array, return 0.\n    Example:\n    >>> Find_Nth_Hig\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnz2ba9pk.d(56): Error: found \''=>\'' when expecting \'')\''
    following template argument list\n/tmp/tmpnz2ba9pk.d(56): Error: semicolon expected
    following auto declaration, not \''0\''\n/tmp/tmpnz2ba9pk.d(56): Error: found
    \'')\'' when expecting \'';\'' following statement\n/tmp/tmpnz2ba9pk.d(57): Error:
    found \''=>\'' when expecting \'')\'' following template argument list\n/tmp/tmpnz2ba9pk.d(57):
    Error: found \''0\'' when expecting \'';\'' following statement\n/tmp/tmpnz2ba9pk.d(57):
    Error: found \'')\'' instead of statement\n/tmp/tmpnz2ba9pk.d(70): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnz2ba9pk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return class_name ~ \".\" ~ maxExtension(extensions);\n\
    }\nprivate string maxExtension(string[] extensions)\n{\n    string max = extensions[0];\n\
    \    real maxStrength = Strength(max);\n    foreach(string extension; extensions)\n\
    \    {\n        real currStrength = Strength(extension);\n        if(currStrength\
    \ > maxStrength)\n        {\n            maxStrength = currStrength;\n       \
    \     max = extension;\n        }\n    }\n    return max;\n}\nprivate real Strength(string\
    \ extension)\n{\n    uint cap = 0;\n    uint sm = 0;\n    foreach(char c; extension)\n\
    \    {\n        if(isUpper(c))\n            cap++;\n        else\n           \
    \ sm++;\n    }\n    return (cap - sm) / extension.length;\n}\nprivate bool isUpper(char\
    \ c)\n{\n    return c >= 'A' && c <= 'Z';\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkzqxb6ig.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    return extensions.front;\n}\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy31zrszm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tint max_score = int.min;\n\tint cur_score = 0;\n\
    \tstring tmp_str;\n\tstring result = class_name;\n\tforeach(i,ext)\n\t{\n\t\t\
    tmp_str = ext;\n\t\tforeach(tmp_char;tmp_str)\n\t\t{\n\t\t\tif(tmp_char.isUpper)\n\
    \t\t\t\tcur_score++;\n\t\t\telse\n\t\t\t\tcur_score--;\n\t\t}\n\t\tif(cur_score\
    \ > max_score)\n\t\t{\n\t\t\tmax_score = cur_score;\n\t\t\tresult ~= \".\" ~ ext;\n\
    \t\t}\n\t\tcur_score = 0;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5rapeoqp.d(28): Error: no identifier for declarator ext\n/tmp/tmp5rapeoqp.d(28):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp5rapeoqp.d(45): Error: found
    \''return\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp5rapeoqp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.stdio;\n    int current_strength =\
    \ 0;\n    int current_index = 0;\n    float current_value = 0.0;\n    for (int\
    \ i = 0; i < extensions.length; i++)\n    {\n        foreach (ext; extensions[i])\n\
    \        {\n            if (ext >= 'A' && ext <= 'Z')\n            {\n       \
    \         current_strength++;\n            }\n            else if (ext >= 'a'\
    \ && ext <= 'z')\n            {\n                current_strength--;\n       \
    \     }\n        }\n        current_value = cast(float)current_strength / extensions[i].length;\n\
    \        if (current_value < 0)\n        {\n            current_value = current_value\
    \ * -1;\n        }\n        if (current_value > current_strength)\n        {\n\
    \            current_strength = cast(int)current_value;\n            current_index\
    \ = i;\n        }\n        current_strength = 0;\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[current_index];\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72sj3a1k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tstring final_str = class_name;\n\tfloat strength_array[]\
    \ = new float[extensions.length];\n\tfloat strength = 0.0;\n\tint cap = 0;\n\t\
    int sm = 0;\n\tint min = 0;\n\tfor(int i = 0; i < extensions.length; i++)\n\t\
    {\n\t\tfor(int j = 0; j < extensions[i].length; j++)\n\t\t{\n\t\t\tif(extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z')\n\t\t\t{\n\t\t\t\tcap++;\n\t\t\t}\n\t\t\t\
    else if(extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n\t\t\t{\n\t\t\t\t\
    sm++;\n\t\t\t}\n\t\t}\n\t\tstrength = (float)cap - (float)sm;\n\t\tstrength_array[i]\
    \ = strength;\n\t\tcap = 0;\n\t\tsm = 0;\n\t}\n\tmin = -1;\n\tfor(int i = 0; i\
    \ < strength_array.length; i++)\n\t{\n\t\tif(min == -1)\n\t\t{\n\t\t\tmin = 0;\n\
    \t\t}\n\t\telse if(strength_array[i] > strength_array[min])\n\t\t{\n\t\t\tmin\
    \ = i;\n\t\t}\n\t}\n\tfinal_str += '.';\n\tfinal_str += extensions[min];\n\treturn\
    \ final_str;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n \
    \   assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnktehb3q.d(43): Error: C style cast illegal, use cast(float)cap\n/tmp/tmpnktehb3q.d(43):
    Error: C style cast illegal, use cast(float)sm\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnktehb3q.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string str_strongest_extension = \"\";\n    float\
    \ fl_strongest_extension = 0.0;\n    float fl_strength = 0.0;\n    float fl_num_upper\
    \ = 0.0;\n    float fl_num_lower = 0.0;\n    string extension;\n    foreach(extension;\
    \ extensions)\n    {\n        foreach(char ch; extension)\n        {\n       \
    \     if(isUpper(ch))\n            {\n                fl_num_upper += 1.0;\n \
    \           }\n            else\n            {\n                fl_num_lower +=\
    \ 1.0;\n            }\n        }\n        fl_strength = fl_num_upper - fl_num_lower;\n\
    \        if(fl_strength > fl_strongest_extension)\n        {\n            fl_strongest_extension\
    \ = fl_strength;\n            str_strongest_extension = extension;\n        }\n\
    \        else if(fl_strength == fl_strongest_extension)\n        {\n         \
    \   str_strongest_extension = extension;\n        }\n        fl_num_upper = 0.0;\n\
    \        fl_num_lower = 0.0;\n    }\n    return class_name ~ \".\" ~ str_strongest_extension;\n\
    }\n/*\nYou are given an array of arrays of strings.\n    Your task is to return\
    \ the number of times the smallest array is present.\n    Example:\n    >>> number_of_smallest_arrays([[\"\
    A\", \"B\"], [\"A\", \"B\", \"C\"], [\"A\"]])\n    2\n*/\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvn6d33a4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int n = extensions.length;\n    double maxStrength\
    \ = 0;\n    string classString = \"\";\n    string extensionString = \"\";\n \
    \   for (int i = 0; i < n; i++)\n    {\n        string[] tmp = extensions[i].split();\n\
    \        int CAP = tmp[0].length;\n        int SM = tmp[1].length;\n        double\
    \ strength = double(CAP) - double(SM);\n        if (strength > maxStrength)\n\
    \        {\n            maxStrength = strength;\n            extensionString =\
    \ extensions[i];\n        }\n    }\n    classString = class_name + \".\" + extensionString;\n\
    \    return classString;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_jqug6dx.d(33): Error: found \''(\'' when expecting \''.\''
    following double\n/tmp/tmp_jqug6dx.d(33): Error: semicolon expected, not \'')\''\n/tmp/tmp_jqug6dx.d(33):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp_jqug6dx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    //cout << extensions.length << endl;\n    size_t\
    \ extension_length = extensions.length;\n    if (extension_length == 0) return\
    \ class_name;\n    double[] strengths = new double[extension_length];\n    double[]\
    \ strengths_2 = new double[extension_length];\n    size_t extension_index = 0;\n\
    \    double strongest_strength = 0;\n    double strongest_index = 0;\n    for\
    \ (string extension : extensions) {\n        double strength = 0;\n        size_t\
    \ extension_length = extension.length;\n        size_t upper_count = 0;\n    \
    \    size_t lower_count = 0;\n        for (size_t j = 0; j < extension_length;\
    \ j++) {\n            char character = extension[j];\n            //cout << character\
    \ << endl;\n            if (character.isUpper) upper_count++;\n            else\
    \ lower_count++;\n        }\n        strength = upper_count - lower_count;\n \
    \       strengths[extension_index] = strength;\n        strengths_2[extension_index]\
    \ = strength;\n        if (strength > strongest_strength) {\n            strongest_strength\
    \ = strength;\n            strongest_index = extension_index;\n        }\n   \
    \     extension_index++;\n    }\n    //cout << strongest_index << endl;\n    sort(strengths);\n\
    \    //cout << strongest_strength << endl;\n    //cout << lengths[strengths.length\
    \ - 1] << endl;\n    size_t strongest_indexes_length = 0;\n    for (double strength\
    \ : strengths) {\n        if (strength == strongest_strength) {\n            strongest_indexes_length++;\n\
    \        }\n    }\n    size_t[] strongest_indexes = new size_t[strongest_indexes_length];\n\
    \    size_t i = 0;\n    size_t index = 0;\n    for (double strength : strengths_2)\
    \ {\n        if (strength == strongest_strength) {\n            strongest_indexes[index]\
    \ = i;\n            index++;\n        }\n        i++;\n    }\n    //cout << strongest_indexes[0]\
    \ << endl;\n   \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n \
    \   assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_4qzs16m.d(32): Error: found \''extension\'' when expecting
    \'';\'' following statement\n/tmp/tmp_4qzs16m.d(32): Error: expression expected,
    not \'':\''\n/tmp/tmp_4qzs16m.d(32): Error: found \''extensions\'' when expecting
    \'';\'' following for condition\n/tmp/tmp_4qzs16m.d(57): Error: semicolon expected,
    not \'':\''\n/tmp/tmp_4qzs16m.d(57): Error: expression expected, not \'':\''\n/tmp/tmp_4qzs16m.d(57):
    Error: found \''strengths\'' when expecting \'';\'' following for condition\n/tmp/tmp_4qzs16m.d(65):
    Error: semicolon expected, not \'':\''\n/tmp/tmp_4qzs16m.d(65): Error: expression
    expected, not \'':\''\n/tmp/tmp_4qzs16m.d(65): Error: found \''strengths_2\''
    when expecting \'';\'' following for condition\n/tmp/tmp_4qzs16m.d(74): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp_4qzs16m.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max = 0;\n    string result = class_name;\n\
    \    string max_ext = extensions[0];\n    foreach(string ext; extensions)\n  \
    \  {\n        double s = 0;\n        foreach(c; ext)\n        {\n            if\
    \ (c >= 'A' && c <= 'Z')\n                s++;\n            else if (c >= 'a'\
    \ && c <= 'z')\n                s--;\n        }\n        if (s > max)\n      \
    \  {\n            max = s;\n            max_ext = ext;\n        }\n    }\n   \
    \ return result ~ \".\" ~ max_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa9khkgo_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string ret_val = class_name;\n    double strongest_strength\
    \ = 0;\n    foreach(string s; extensions)\n    {\n        double strength = (double)count(s.split(std.regex.alnum),\
    \ \"isUpper\") -\n                          (double)count(s.split(std.regex.alnum),\
    \ \"isLower\");\n        if(strength > strongest_strength)\n        {\n      \
    \      strongest_strength = strength;\n            ret_val = class_name ~ \".\"\
    \ ~ s;\n        }\n    }\n    return ret_val;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9n10_wma.d(28): Error: C style cast illegal, use cast(double)count(s.split(std.regex.alnum),
    "isUpper")\n/tmp/tmp9n10_wma.d(29): Error: C style cast illegal, use cast(double)count(s.split(std.regex.alnum),
    "isLower")\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9n10_wma.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    uint strongest = 0;\n    int strongest_index =\
    \ 0;\n    for (uint i = 0; i < extensions.length; i++)\n    {\n        uint strong\
    \ = extensions[i].count!(a => a.isUpper) - extensions[i].count!(a => a.isLower);\n\
    \        if (strong > strongest)\n        {\n            strongest = strong;\n\
    \            strongest_index = i;\n        }\n    }\n    return class_name ~ \"\
    .\" ~ extensions[strongest_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjpzdyvx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = class_name;\n    float strongest_extension\
    \ = 0.0f;\n    foreach(string extension; extensions)\n    {\n        float uppercase_letters\
    \ = 0.0f;\n        float lowercase_letters = 0.0f;\n        foreach(dchar ch;\
    \ extension)\n        {\n            if(ch.isUpper)\n                uppercase_letters\
    \ += 1.0f;\n            else if(ch.isLower)\n                lowercase_letters\
    \ += 1.0f;\n        }\n        if(strongest_extension < uppercase_letters - lowercase_letters)\n\
    \        {\n            strongest_extension = uppercase_letters - lowercase_letters;\n\
    \            result ~= \".\" ~ extension;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9m9t616.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string winner = \"\";\n    double strength = double.min;\n\
    \    extensions.each!(ext => {\n        writeln(ext);\n        if(ext.filter!(c\
    \ => c.isUpper).length - ext.filter!(c => c.isLower).length > strength)\n    \
    \    {\n            winner = ext;\n            strength = ext.filter!(c => c.isUpper).length\
    \ - ext.filter!(c => c.isLower).length;\n        }\n    });\n    return class_name\
    \ ~ \".\" ~ winner;\n}\n/*\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj4j5sksu.d(36): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpj4j5sksu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    class_name += \".\";\n    foreach(string ext,\
    \ int i; extensions)\n    {\n        class_name += getStrongestExtension(extensions,\
    \ i);\n        break;\n    }\n    return class_name;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphays6mo_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strong = float.min;\n    string strongest;\n\
    \    foreach(i, ext; extensions)\n    {\n        int caps = 0;\n        int smalls\
    \ = 0;\n        foreach(j, char_in_ext; ext)\n        {\n            if(isUpper(char_in_ext))\n\
    \                caps++;\n            else if(isLower(char_in_ext))\n        \
    \        smalls++;\n        }\n        auto temp = (float) caps - smalls;\n  \
    \      if(temp > strong)\n        {\n            strong = temp;\n            strongest\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\n//\
    \ auto result = Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]);\n\
    // assert(result == \"my_class.AA\");\n// auto result = Strongest_Extension(\"\
    Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"]);\n// assert(result ==\
    \ \"Slices.SErviNGSliCes\");\n// auto result = Strongest_Extension(\"Slices\"\
    , [\"SErviNGSliCes\", \"Be\", \"CC\"]);\n// assert(result == \"Slices.SErviNGSliCes\"\
    );\n// auto result = Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"SA\"\
    , \"CC\"]);\n// assert(result == \"Slices.SErviNGSliCes\");\n// auto result =\
    \ Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"SA\", \"SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvwgdv4c5.d(37): Error: C style cast illegal, use cast(float)caps\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwgdv4c5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Check if the array is empty, if not then continue\
    \ with\n    // finding the strongest extension.\n    if (extensions.length !=\
    \ 0)\n    {\n        // Find the strongest extension and save it in the variable\n\
    \        // strongest_extension.\n        string strongest_extension = extensions[0];\n\
    \        float strongest_strength = Calculate_Strength(strongest_extension);\n\
    \        foreach (extension; extensions)\n        {\n            float extension_strength\
    \ = Calculate_Strength(extension);\n            if (extension_strength > strongest_strength)\n\
    \            {\n                strongest_extension = extension;\n           \
    \     strongest_strength = extension_strength;\n            }\n        }\n   \
    \     // Return the string of the class name and strongest extension.\n      \
    \  return class_name ~ \".\" ~ strongest_extension;\n    }\n    // If the array\
    \ is empty, return a message.\n    else\n    {\n        return \"No extensions\
    \ given.\";\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiq2qpp_c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest_strength = 0;\n    string strongest_name\
    \ = \"\";\n    double strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        strength = getStrength(extension);\n        if(strongest_strength\
    \ < strength)\n        {\n            strongest_strength = strength;\n       \
    \     strongest_name = extension;\n        }\n    }\n    return class_name ~ \"\
    .\" ~ strongest_name;\n}\ndouble getStrength(string extension)\n{\n    return\
    \ extension.count!(char[](\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")) - extension.count!(char[](\"\
    abcdefghijklmnopqrstuvwxyz\"));\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp462ib1wh.d(40): Error: found \''[\'' when expecting \''.\''
    following char\n/tmp/tmp462ib1wh.d(40): Error: found \'']\'' when expecting identifier
    following \''char.\''\n/tmp/tmp462ib1wh.d(40): Error: found \''[\'' when expecting
    \''.\'' following char\n/tmp/tmp462ib1wh.d(40): Error: found \'']\'' when expecting
    identifier following \''char.\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp462ib1wh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\
    \u0432\u043E \u0437\u0430\u0433\u043B\u0430\u0432\u043D\u044B\u0445 \u0431\u0443\
    \u043A\u0432 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0438 \u0440\u0430\
    \u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F\n    uint cap_num(string x) {\n\
    \        uint s = 0;\n        for (i, c; x)\n            if (c > 'A' && c < 'Z')\n\
    \                s++;\n        return s;\n    }\n    // \u043A\u043E\u043B\u0438\
    \u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0442\u0440\u043E\u0447\u043D\u044B\
    \u0445 \u0431\u0443\u043A\u0432 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\
    \u0438 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F\n    uint\
    \ sm_num(string x) {\n        uint s = 0;\n        for (i, c; x)\n           \
    \ if (c > 'a' && c < 'z')\n                s++;\n        return s;\n    }\n  \
    \  // \u0441\u0438\u043B\u0430 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\
    \u0438\u044F\n    real strength(string x) {\n        return real(cap_num(x) -\
    \ sm_num(x));\n    }\n    // \u0441\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\
    \u0430 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u0439 \u043F\u043E\
    \ \u0441\u0438\u043B\u0435\n    string[] sort_ext(string[] ex) {\n        string[]\
    \ tmp = ex.dup;\n        ex.sort!(a, b => (strength(a) > strength(b)));\n    \
    \    return ex;\n    }\n    // \u043D\u0430\u0439\u0442\u0438 \u0441\u0430\u043C\
    \u043E\u0435 \u0441\u0438\u043B\u044C\u043D\u043E\u0435 \u0440\u0430\u0441\u0448\
    \u0438\u0440\u0435\u043D\u0438\u0435\n    string find_strongest(string[] ex) {\n\
    \        auto str = strength(ex[0]);\n        foreach (e; ex)\n            if\
    \ (strength(e) > str)\n                str = strength(e);\n        return str;\n\
    \    }\n    // \u043D\u0430\u0439\u0442\u0438 \u0438\u043D\u0434\u0435\u043A\u0441\
    \ \u0441\u0430\u043C\u043E\u0433\u043E \u0441\u0438\u043B\u044C\u043D\u043E\u0433\
    \u043E \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F\n    int index_strongest(string\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmfrdmpe0.d(27): Error: found \'')\'' when expecting \'';\''
    following for condition\n/tmp/tmpmfrdmpe0.d(28): Error: expression expected, not
    \''if\''\n/tmp/tmpmfrdmpe0.d(29): Error: found \''s\'' when expecting \'')\''\n/tmp/tmpmfrdmpe0.d(29):
    Error: expression expected, not \'';\''\n/tmp/tmpmfrdmpe0.d(30): Error: found
    \''return\'' when expecting \'';\'' following statement\n/tmp/tmpmfrdmpe0.d(35):
    Error: found \'')\'' when expecting \'';\'' following for condition\n/tmp/tmpmfrdmpe0.d(36):
    Error: expression expected, not \''if\''\n/tmp/tmpmfrdmpe0.d(37): Error: found
    \''s\'' when expecting \'')\''\n/tmp/tmpmfrdmpe0.d(37): Error: expression expected,
    not \'';\''\n/tmp/tmpmfrdmpe0.d(38): Error: found \''return\'' when expecting
    \'';\'' following statement\n/tmp/tmpmfrdmpe0.d(42): Error: found \''(\'' when
    expecting \''.\'' following real\n/tmp/tmpmfrdmpe0.d(42): Error: found \'')\''
    when expecting \'';\'' following return statement\n/tmp/tmpmfrdmpe0.d(60): Error:
    found \''unittest\'' when expecting \'')\''\n/tmp/tmpmfrdmpe0.d(74): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmfrdmpe0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // we will use a tuple to store the CAP and SM\
    \ values and the index\n    // position in the array\n    Tuple!(int, int, int)[]\
    \ strength;\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu_0cttht.d(27): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu_0cttht.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto len = extensions.length;\n    string[] caps\
    \ = new string[len];\n    string[] lowercases = new string[len];\n    string[]\
    \ results = new string[len];\n    foreach(i, item; extensions)\n    {\n      \
    \  int cap = 0;\n        int lowercase = 0;\n        foreach(char c; item)\n \
    \       {\n            if(isupper(c))\n                cap++;\n            else\
    \ if(islower(c))\n                lowercase++;\n        }\n        double result\
    \ = (double)cap - (double)lowercase;\n        results[i] = result.to!string;\n\
    \        caps[i] = to!string(cap);\n        lowercases[i] = to!string(lowercase);\n\
    \    }\n    //we have values of caps and lowercases and results, now we sort.\n\
    \    foreach(i, x; results)\n    {\n        writeln(x);\n    }\n    string[] results_capped\
    \ = results.dup;\n    string[] results_lowercased = results.dup;\n    sort!((a,\
    \ b) => a > b)(results);\n    sort!((a, b) => a > b)(results_capped);\n    sort!((a,\
    \ b) => a > b)(results_lowercased);\n    writeln(results[0]);\n    writeln(results_capped[0]);\n\
    \    writeln(results_lowercased[0]);\n    //we have sorted arrays, now find the\
    \ greatest result\n    int index = results.length - 1;\n    int index_capped =\
    \ results_capped.length - 1;\n    int index_lowercased = results_lowercased.length\
    \ - 1;\n    string[] greatest_results = new string[3];\n    foreach(i, x; results)\n\
    \    {\n        if(x == results[index])\n            greatest_results[0] = x;\n\
    \    }\n    foreach(i, x; results_capped)\n    {\n        if(x == results_capped[index_capped])\n\
    \            greatest_results[1] = x;\n    }\n    foreach(i, x; results_lowercased)\n\
    \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmv2_aq72.d(39): Error: C style cast illegal, use cast(double)cap\n/tmp/tmpmv2_aq72.d(39):
    Error: C style cast illegal, use cast(double)lowercase\n/tmp/tmpmv2_aq72.d(74):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpmv2_aq72.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengths = extensions.map!((string x) =>\
    \ \n                        x.countUntil!(a => !char.isUpper(a)) - \n        \
    \                x.countUntil!(a => !char.isLower(a))).array;\n    int max = strengths.max;\n\
    \    int index = strengths.indexOf(max);\n    return class_name ~ \".\" ~ extensions[index];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrlpa6qz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    if (extensions.length == 0) \n        return class_name;\n\
    \    double strength = DBL_MIN;\n    int index = 0;\n    for (int i = 0; i < extensions.length;\
    \ i++) \n    {\n        string extension = extensions[i];\n        double tmp\
    \ = double(extension.filter!(x => x.isUpper).length) - double(extension.filter!(x\
    \ => x.isLower).length);\n        if (tmp > strength) \n        {\n          \
    \  strength = tmp;\n            index = i;\n        }\n    }\n    return format(\"\
    %s.%s\", class_name, extensions[index]);\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx_x3x9ic.d(31): Error: found \''(\'' when expecting \''.\''
    following double\n/tmp/tmpx_x3x9ic.d(31): Error: semicolon expected, not \'')\''\n/tmp/tmpx_x3x9ic.d(31):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpx_x3x9ic.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float highest = -1;\n    int index = 0;\n    float\
    \ s;\n    foreach(int i,string extension; extensions){\n        s = (float)extension.filter!((a)=>a.isUpper).length\
    \ - extension.filter!((a)=>a.isLower).length;\n        if(s > highest){\n    \
    \        highest = s;\n            index = i;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[index];\n}\n/*\n    You are given a 2D array, coordinates\
    \ and a color. A cell can be colored\n    by its coordinates.\n    For example:\
    \ coordinates = [[1,1], [2,5], [3,3]] and color = 'red'\n    means: you have to\
    \ color the cell with the coordinates [1,1] with the color\n    'red', the cell\
    \ with the coordinates [2,5] with the color 'red' and\n    the cell with the coordinates\
    \ [3,3] with the color 'red'.\n    Example:\n    >>> color_coordinates([[1,2],[3,4],[5,6]],\
    \ 'red')\n    [['red', 2], [3, 4], [5, 6]]\n    >>> color_coordinates([[1,2],[3,4],[5,6]],\
    \ 'blue')\n    [[1, 2], [3, 4], ['blue', 6]]\n    >>> color_coordinates([[1,2],[3,4],[5,6]],\
    \ 'white')\n    [[1, 2], [3, 4], [5, 6]]\n*/\nstring[][] color_coordinates(int[][]\
    \ coordinates, string color) \n{\n    string[][] result = new string[][](coordinates.length);\n\
    \    foreach(int i, int[] c; coordinates){\n        result[i] = new string[](2);\n\
    \        result[i][0] = c[0].to!string;\n        result[i][1] = c[1].to!string;\n\
    \    }\n    foreach(int i, int[] c; coordinates){\n        if(c[0] == c[1]){\n\
    \            result[i][c[0]-1] = color\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxow4b72g.d(28): Error: C style cast illegal, use cast(float)extension.filter!((a)
    => a.isUpper).length\n/tmp/tmpxow4b72g.d(62): Error: found \''unittest\'' when
    expecting \'';\'' following statement\n/tmp/tmpxow4b72g.d(76): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpxow4b72g.d(76): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpxow4b72g.d(76):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxow4b72g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = extensions[0];\n\
    \    float strongest_extension_strength = 0;\n    float extension_strength = 0;\n\
    \    int number_of_uppercase_letters = 0;\n    int number_of_lowercase_letters\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        number_of_uppercase_letters\
    \ = 0;\n        number_of_lowercase_letters = 0;\n        foreach(letter; extension)\n\
    \        {\n            if(letter.isUpper)\n            {\n                number_of_uppercase_letters++;\n\
    \            }\n            else\n            {\n                number_of_lowercase_letters++;\n\
    \            }\n        }\n        extension_strength = float(number_of_uppercase_letters)/number_of_lowercase_letters;\n\
    \        if(extension_strength > strongest_extension_strength)\n        {\n  \
    \          strongest_extension_strength = extension_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name~\".\"~strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzf39eawq.d(44): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmpzf39eawq.d(44): Error: found \'')\'' when expecting \'';\''
    following statement\n/tmp/tmpzf39eawq.d(44): Error: found \''/\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzf39eawq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strong = 0.0;\n    string strongest = \"\"\
    ;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        auto sm = 0.0;\n\
    \        auto cap = 0.0;\n        for (int j = 0; j < extensions[i].length; j++)\n\
    \        {\n            if(extensions[i][j] >= 65 && extensions[i][j] <= 90)\n\
    \            {\n                cap++;\n            }\n            else if(extensions[i][j]\
    \ >= 97 && extensions[i][j] <= 122)\n            {\n                sm++;\n  \
    \          }\n        }\n        auto strength = cap - sm;\n        if(strength\
    \ > strong)\n        {\n            strong = strength;\n            strongest\
    \ = extensions[i];\n        }\n    }\n    return format(\"%s.%s\", class_name,\
    \ strongest);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy017k1rv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.math;\n    import std.conv;\n    import\
    \ std.typecons;\n    int tmp = 0;\n    int ext_strength = 0;\n    int max_strength\
    \ = 0;\n    string final_ext = \"\";\n    foreach(ext; extensions)\n    {\n  \
    \      auto tmp_strength = 0;\n        foreach(cc; ext)\n        {\n         \
    \   if (cc.isUpper)\n                tmp_strength++;\n            else\n     \
    \           tmp_strength--;\n        }\n        if (tmp_strength > max_strength)\n\
    \        {\n            max_strength = tmp_strength;\n            final_ext =\
    \ ext;\n        }\n    }\n    return class_name ~ \".\" ~ final_ext;\n}\n/*\n\
    The function should find the first place where the two arrays have \n    common\
    \ elements and return the index of the first common element in \n    the second\
    \ array. The arrays are expected to have the same length and\n    their length\
    \ is always at least 1.\n    Example:\n    >>> Find_Common_Element([1,2,3,4,5,6],\
    \ [1,3,5,8,11,12])\n    0\n    >>> Find_Common_Element([1,2,3,4,5,6], [8,11,12,9,10,7])\n\
    \    -1\n    >>> Find_Common_Element([1,2,3,4,5,6], [9,10,7,1,2,3])\n    3\n \
    \   >>> Find_Common_Element([1,2,3,4,5,6], [1,2,3,4,5,6])\n    0\n*/\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsxk46xgt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double tmp1 = 0;\n    string tmp2 = \"\";\n  \
    \  foreach(string x; extensions)\n    {\n        double tmp = 0;\n        foreach(char\
    \ c; x)\n        {\n            if(isUpper(c))\n                tmp += 1;\n  \
    \          else if(isLower(c))\n                tmp -= 1;\n        }\n       \
    \ if(tmp > tmp1)\n        {\n            tmp1 = tmp;\n            tmp2 = x;\n\
    \        }\n    }\n    return format(\"%s.%s\", class_name, tmp2);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6o5k3uwa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string s = \"\";\n    double max = double.min;\n\
    \    foreach(string extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(isUpper(c))\n \
    \               strength += 1;\n            else if(isLower(c))\n            \
    \    strength -= 1;\n        }\n        if(strength > max)\n        {\n      \
    \      max = strength;\n            s = extension;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ s;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp1bedtyg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // initialisation :\n    double strength = -DBL_MAX;\n\
    \    string strongest_extension = \"\";\n    // for each extension in the list\
    \ :\n    foreach(extension; extensions)\n    {\n        double extension_strength\
    \ = (count!(\"A\")(extension) + count!(\"B\")(extension) +\n                 \
    \                   count!(\"C\")(extension) + count!(\"D\")(extension) +\n  \
    \                                  count!(\"E\")(extension) + count!(\"F\")(extension)\
    \ +\n                                    count!(\"G\")(extension) + count!(\"\
    H\")(extension) +\n                                    count!(\"I\")(extension)\
    \ + count!(\"J\")(extension) +\n                                    count!(\"\
    K\")(extension) + count!(\"L\")(extension) +\n                               \
    \     count!(\"M\")(extension) + count!(\"N\")(extension) +\n                \
    \                    count!(\"O\")(extension) + count!(\"P\")(extension) +\n \
    \                                   count!(\"Q\")(extension) + count!(\"R\")(extension)\
    \ +\n                                    count!(\"S\")(extension) + count!(\"\
    T\")(extension) +\n                                    count!(\"U\")(extension)\
    \ + count!(\"V\")(extension) +\n                                    count!(\"\
    W\")(extension) + count!(\"X\")(extension) +\n                               \
    \     count!(\"Y\")(extension) + count!(\"Z\")(extension)) -\n               \
    \                     (count!(\"a\")(extension) + count!(\"b\")(extension) +\n\
    \                                    count!(\"c\")(extension) + count!(\"d\")(extension)\
    \ +\n                                    count!(\"e\")(extension) + count!(\"\
    f\")(extension) +\n                                    count!(\"g\")(extension)\
    \ + count!(\"h\")(extension) +\n                                    count!(\"\
    i\")(extension) + count!(\"j\")(extension) +\n                               \
    \     count!(\"k\")(extension) + count!(\"l\")(extension) +\n                \
    \                    count!(\"m\")(extension) + count!(\"n\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf8savqjx.d(43): Error: unterminated string constant starting
    at /tmp/tmpf8savqjx.d(62)\n/tmp/tmpf8savqjx.d(54): Error: found \''Watashi\''
    when expecting \'')\'' following template argument list\n/tmp/tmpf8savqjx.d(43):
    Error: found \''", ["\'' when expecting \'')\''\n/tmp/tmpf8savqjx.d(54): Error:
    semicolon expected, not \''tEN\''\n/tmp/tmpf8savqjx.d(54): Error: found \''",
    "\'' when expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(54): Error:
    found \''", "\'' when expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(54):
    Error: found \''"]) == "\'' when expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(54):
    Error: found \''");\\x0a    assert(candidate("\'' when expecting \'';\'' following
    statement\n/tmp/tmpf8savqjx.d(55): Error: found \''", ["\'' when expecting \'';\''
    following statement\n/tmp/tmpf8savqjx.d(55): Error: found \''", "\'' when expecting
    \'';\'' following statement\n/tmp/tmpf8savqjx.d(55): Error: found \''", "\'' when
    expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(55): Error: found \''",
    "\'' when expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(55): Error:
    found \''tggg\'' when expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(55):
    Error: found \''Boku123\'' when expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(55):
    Error: found \''");\\x0a    assert(candidate("\'' when expecting \'';\'' following
    statement\n/tmp/tmpf8savqjx.d(56): Error: found \''", ["\'' when expecting \'';\''
    following statement\n/tmp/tmpf8savqjx.d(56): Error: found \''", "\'' when expecting
    \'';\'' following statement\n/tmp/tmpf8savqjx.d(56): Error: found \''", "\'' when
    expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(56): Error: found \''",
    "\'' when expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(56): Error:
    found \''", "\'' when expecting \'';\'' following statement\n/tmp/tmpf8savqjx.d(56):
    Error: found \''", "\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpf8savqjx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    size_t\
    \ strength = 0;\n    foreach(string extension; extensions)\n    {\n        size_t\
    \ cap = 0;\n        size_t sm = 0;\n        foreach(char ch; extension)\n    \
    \    {\n            if(ch >= 'A' && ch <= 'Z') cap++;\n            else if(ch\
    \ >= 'a' && ch <= 'z') sm++;\n        }\n        if(cap - sm > strength)\n   \
    \     {\n            strength = cap - sm;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgvugjj2w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float[] strengths = extensions.map!((ext) => float(ext.count!isUpper)\
    \ - ext.count!isLower)();\n    return class_name ~ \".\" ~ extensions[strengths.indexOf(strengths.max)];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprko_0v8i.d(24): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmprko_0v8i.d(24): Error: semicolon expected, not \'')\''\n/tmp/tmprko_0v8i.d(24):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprko_0v8i.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest_value = 0;\n    string strongest_name\
    \ = extensions[0];\n    int c_cap, c_sm;\n    foreach(s; extensions)\n    {\n\
    \        c_cap = countUntil!(isUpper)(s);\n        c_sm = countUntil!(isLower)(s);\n\
    \        if(strongest_value < float(c_cap - c_sm))\n        {\n            strongest_value\
    \ = float(c_cap - c_sm);\n            strongest_name = s;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_name;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi21dfp4w.d(31): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmpi21dfp4w.d(31): Error: found \'')\'' instead of statement\n/tmp/tmpi21dfp4w.d(37):
    Error: Declaration expected, not \''return\''\n/tmp/tmpi21dfp4w.d(38): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi21dfp4w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    class Ext {\n        string name;\n        string\
    \ class_name;\n        int strength;\n        \n        this(string name, string\
    \ class_name) {\n            this.name = name;\n            this.class_name =\
    \ class_name;\n            this.strength = countOfUpper(name) - countOfLower(name);\n\
    \        }\n        \n        int countOfUpper(string name) {\n            int\
    \ count = 0;\n            foreach(ch; name)\n                if(isUpper(ch))\n\
    \                    count++;\n            return count;\n        }\n        \n\
    \        int countOfLower(string name) {\n            int count = 0;\n       \
    \     foreach(ch; name)\n                if(isLower(ch))\n                   \
    \ count++;\n            return count;\n        }\n        \n        int opCmp(Ext\
    \ other) {\n            return strength - other.strength;\n        }\n    }\n\
    \    \n    string[] result = class_name.split('.');\n    class_name = result[0];\n\
    \    Ext[] exts = [Ext(ext, class_name) for ext in extensions];\n    Ext maxExt\
    \ = max(exts);\n    return class_name ~ \".\" ~ maxExt.name;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2i29h3vw.d(58): Error: comma expected separating array initializers,
    not for\n/tmp/tmp2i29h3vw.d(58): Error: semicolon expected, not \''ext\''\n/tmp/tmp2i29h3vw.d(58):
    Error: found \'']\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp2i29h3vw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015080
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\tforeach(inout string x; extensions)\n\t{\n\t\tint\
    \ cnt = 0;\n\t\tforeach(immutable char x1; x)\n\t\t{\n\t\t\tif(isupper(x1)) cnt++;\n\
    \t\t}\n\t\tif(x.length > 0)\n\t\t\tx = format(\"%s.%s\",class_name,x);\n\t\telse\n\
    \t\t\tx = class_name;\n\t\tx ~= to!string(cnt-x.length);\n\t}\n\tstring result\
    \ = class_name;\n\tforeach(immutable auto x; extensions)\n\t{\n\t\tif(to!double(x[$-1..$])\
    \ > to!double(result[$-1..$]))\n\t\t\tresult = x;\n\t}\n\treturn result;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp47yawooi.d(38): Error: basic type expected, not auto\n/tmp/tmp47yawooi.d(38):
    Error: no identifier for declarator int\n/tmp/tmp47yawooi.d(38): Error: found
    \''auto\'' when expecting \'';\''\n/tmp/tmp47yawooi.d(38): Error: found \'';\''
    when expecting \'')\''\n/tmp/tmp47yawooi.d(38): Error: found \'')\'' when expecting
    \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp47yawooi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    Tuple!(int, int, string)[] extensionStrength =\
    \ extensions.map!(extension => {\n        uint numberOfUpperCaseLetters = extension.filter!(char\
    \ => char.isUpper).length;\n        uint numberOfLowerCaseLetters = extension.filter!(char\
    \ => char.isLower).length;\n        return tuple(numberOfUpperCaseLetters - numberOfLowerCaseLetters,\
    \ numberOfUpperCaseLetters, extension);\n    });\n    extensionStrength.sort!((a,\
    \ b) => a[0] > b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return class_name\
    \ ~ \".\" ~ extensionStrength[0][2];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiq9ifbwo.d(25): Error: found \''=>\'' when expecting \''.\''
    following char\n/tmp/tmpiq9ifbwo.d(25): Error: found \''char\'' when expecting
    identifier following \''char.\''\n/tmp/tmpiq9ifbwo.d(26): Error: found \''=>\''
    when expecting \''.\'' following char\n/tmp/tmpiq9ifbwo.d(26): Error: found \''char\''
    when expecting identifier following \''char.\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpiq9ifbwo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions) {\n        int lower = count(extension.lowercased,\
    \ 'a');\n        int upper = count(extension.uppercased, 'A');\n        double\
    \ strength = (upper - lower) / extension.length;\n        if(strength > strongest)\
    \ {\n            strongest = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\n/*\n\
    You're given a list of n strings each of length n, words.\nLet's define a word\
    \ as a diagonal word if it's possible to draw a diagonal line \ninside a grid\
    \ of letters of size n x n such that all the letters on this line are \nthe same.\n\
    It is possible to draw a diagonal line only if all the characters in the word\
    \ are\nthe same.\nReturn the number of diagonal words in the given list.\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpti7td_7w.d(37): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpti7td_7w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    double strongest_strength\
    \ = 0;\n    foreach(ext; extensions) {\n        int caps = 0;\n        int smalls\
    \ = 0;\n        foreach(c; ext) {\n            if(isUpper(c)) {\n            \
    \    caps++;\n            } else {\n                smalls++;\n            }\n\
    \        }\n        double strength = caps - smalls;\n        if(strength > strongest_strength)\
    \ {\n            strongest = ext;\n            strongest_strength = strength;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nstring Strongest_Extension2(string\
    \ class_name, string[] extensions) {\n    // make a tuple with the strength and\
    \ the class name\n    auto make_tuple(string extension) {\n        int caps =\
    \ 0;\n        int smalls = 0;\n        foreach(c; extension) {\n            if(isUpper(c))\
    \ {\n                caps++;\n            } else {\n                smalls++;\n\
    \            }\n        }\n        return tuple(caps - smalls, extension);\n \
    \   }\n    // sort them by the strength, then by the names\n    auto tuples =\
    \ extensions.map!make_tuple.sort!((t1, t2) => t1[0] < t2[0] || (t1[0] == t2[0]\
    \ && t1[1] < t2[1]));\n    // return the name\n    return class_name ~ \".\" ~\
    \ tuples[0][1];\n}\nstring Strongest_Extension3(string class_name, string[] extensions)\
    \ {\n    auto tuples = extensions.map!(ext => tuple(ext.count!(c => isUpper(c))\
    \ - ext.count!(c => isLower(c)), ext)).sort!((t1, t2) => t1[0] < t2[0] || (t1[0]\
    \ == t2[0] && t1[1] < t2[1]));\n    return class_name ~ \".\" ~ tuples[0][1];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1pgmiwz3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.math;\n    import std.conv;\n    int[]\
    \ strength = [extensions.length];\n    foreach(i, e; extensions)\n    {\n    \
    \    int cap = 0;\n        int sm = 0;\n        foreach(c; e)\n        {\n   \
    \         cap += cast(bool)(c >= 'A' && c <= 'Z');\n            sm += cast(bool)(c\
    \ >= 'a' && c <= 'z');\n        }\n        strength[i] = abs(cap - sm);\n    }\n\
    \    int max_strength = 0;\n    int s_idx = 0;\n    foreach(i, s; strength)\n\
    \    {\n        if(s > max_strength)\n        {\n            max_strength = s;\n\
    \            s_idx = i;\n        }\n    }\n    return class_name ~ \".\" ~ extensions[s_idx];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjp5roaub.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_score = 0;\n    foreach(extension; extensions)\n    {\n\
    \        double upper_case_count = 0;\n        double lower_case_count = 0;\n\
    \        foreach(c; extension)\n        {\n            if(isUpper(c))\n      \
    \      {\n                upper_case_count++;\n            }\n            else\n\
    \            {\n                lower_case_count++;\n            }\n        }\n\
    \        double score = (upper_case_count / lower_case_count);\n        if(score\
    \ > strongest_extension_score)\n        {\n            strongest_extension_score\
    \ = score;\n            strongest_extension = extension;\n        }\n    }\n \
    \   return class_name ~ \".\" ~ strongest_extension;\n}\n//you can also use import(\"\
    dietstdio.d\");\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n \
    \   assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq5zn8e4s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest_index = 0;\n    double strongest_strength\
    \ = 0;\n    foreach(idx, extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(ch; extension)\n        {\n            if (ch.isUpper)\
    \ strength++;\n            else strength--;\n        }\n        if (strength >\
    \ strongest_strength)\n        {\n            strongest_index = idx;\n       \
    \     strongest_strength = strength;\n        }\n    }\n    return format(\"%s.%s\"\
    , class_name, extensions[strongest_index]);\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc0qmjzzm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real max_strength;\n    string best_extension;\n\
    \    foreach(extension; extensions) \n    {\n        int lower_count;\n      \
    \  int upper_count;\n        for(i;0..extension.length) \n        {\n        \
    \    if(extension[i].isUpper) upper_count++;\n            else lower_count++;\n\
    \        }\n        if(upper_count==0) continue;\n        real strength = (upper_count\
    \ - lower_count) / real(upper_count);\n        if(max_strength < strength) \n\
    \        {\n            max_strength = strength;\n            best_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ best_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2t_o8hmc.d(30): Error: found \''..\'' when expecting \'';\''
    following for condition\n/tmp/tmp2t_o8hmc.d(36): Error: found \''(\'' when expecting
    \''.\'' following real\n/tmp/tmp2t_o8hmc.d(36): Error: semicolon expected, not
    \'')\''\n/tmp/tmp2t_o8hmc.d(36): Error: found \'')\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2t_o8hmc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n\t// First make sure the extensions array is sorted\n\
    \tsort(extensions);\n\t// Take the length of the extensions array\n\tsize_t ext_len\
    \ = extensions.length;\n\tint ext_cap = 0;\n\tint ext_sm = 0;\n\tint max_cap =\
    \ 0;\n\tint max_sm = 0;\n\tstring strongest_ext = \"\";\n\tfor (size_t i = 0;\
    \ i < ext_len; i++)\n\t{\n\t\text_cap = extensions[i].count_if!(a => a >= 'A'\
    \ && a <= 'Z');\n\t\text_sm = extensions[i].count_if!(a => a >= 'a' && a <= 'z');\n\
    \t\t\n\t\tif (ext_cap > max_cap)\n\t\t{\n\t\t\tmax_cap = ext_cap;\n\t\t\tmax_sm\
    \ = ext_sm;\n\t\t\tstrongest_ext = extensions[i];\n\t\t}\n\t\telse if (ext_cap\
    \ == max_cap)\n\t\t{\n\t\t\tif (ext_sm < max_sm)\n\t\t\t{\n\t\t\t\tmax_cap = ext_cap;\n\
    \t\t\t\tmax_sm = ext_sm;\n\t\t\t\tstrongest_ext = extensions[i];\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn class_name ~ \".\" ~ strongest_ext;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv1_sxxht.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = extensions[0].length;\n    int min =\
    \ extensions[0].length;\n    int imax = 0;\n    int imin = 0;\n    int k = 0;\n\
    \    int temp_max = 0;\n    int temp_min = 0;\n    string result;\n    foreach(i,extension;extensions)\n\
    \    {\n        temp_max = 0;\n        temp_min = 0;\n        foreach(ch;extension)\n\
    \        {\n            if(std.ctype.isupper(ch))\n            {\n           \
    \     temp_max++;\n            }\n            else if(std.ctype.islower(ch))\n\
    \            {\n                temp_min++;\n            }\n        }\n      \
    \  if(temp_max - temp_min > max - min)\n        {\n            max = temp_max;\n\
    \            min = temp_min;\n            imax = i;\n        }\n        else if(temp_max\
    \ - temp_min == max - min)\n        {\n            if(i < imax)\n            {\n\
    \                imax = i;\n            }\n        }\n    }\n    result = class_name\
    \ ~ \".\" ~ extensions[imax];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi07uxvov.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = -1;\n    string extension\
    \ = extensions[0];\n    int n = extensions.length;\n    foreach(string ex; extensions)\
    \ {\n        int uppercase = 0;\n        int lowercase = 0;\n        foreach(char\
    \ c; ex) {\n            if (isupper(c)) uppercase++;\n            else lowercase++;\n\
    \        }\n        double strength = double(uppercase) - double(lowercase);\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            extension = ex;\n        }\n    }\n    return format(\"%s.%s\", class_name,\
    \ extension);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp77p9o7_f.d(34): Error: found \''(\'' when expecting \''.\''
    following double\n/tmp/tmp77p9o7_f.d(34): Error: semicolon expected, not \'')\''\n/tmp/tmp77p9o7_f.d(34):
    Error: found \'')\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp77p9o7_f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    immutable wchar[] letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    int count_upper = 0;\n    int count_lower = 0;\n    int strongest_ext =\
    \ 0;\n    int strongest_index = 0;\n    foreach(ext; extensions)\n    {\n    \
    \    count_upper = 0;\n        count_lower = 0;\n        foreach(ch; ext)\n  \
    \      {\n            if(ch.toUpper.canFind(ch))\n            {\n            \
    \    count_upper++;\n            }\n            else\n            {\n        \
    \        count_lower++;\n            }\n        }\n        if(count_upper - count_lower\
    \ > strongest_ext)\n        {\n            strongest_ext = count_upper - count_lower;\n\
    \            strongest_index = cast(int)indexOf(extensions, ext);\n        }\n\
    \    }\n    return class_name ~ \".\" ~ extensions[strongest_index];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzmal_jfm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string[] class_words = class_name.split('_');\n\
    \    string class_cap = class_words.map!(w => w.toUpper).join;\n    int class_cap_count\
    \ = class_cap.count!(c => c.isUpper);\n    int class_sm_count = class_cap.count!(c\
    \ => c.isLower);\n    string class_str = class_cap.retro.replace('_', '');\n \
    \   int class_strength = class_cap_count - class_sm_count;\n    int current_strength\
    \ = class_strength;\n    int index = -1;\n    foreach(i, extension; extensions)\n\
    \    {\n        int cap_count = extension.count!(c => c.isUpper);\n        int\
    \ sm_count = extension.count!(c => c.isLower);\n        int strength = cap_count\
    \ - sm_count;\n        if(strength > current_strength)\n        {\n          \
    \  current_strength = strength;\n            index = i;\n        }\n    }\n  \
    \  if(index == -1) return format(\"%s.%s\", class_str, class_str);\n    else return\
    \ format(\"%s.%s\", class_str, extensions[index]);\n}\n// Test Cases\nunittest\n\
    {\n    string[] arr1 = [\"AA\", \"Be\", \"CC\"];\n    string[] arr2 = [\"CHeese\"\
    , \"Toast\"];\n    string[] arr3 = [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"\
    ];\n    string[] arr4 = [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"];\n    string[]\
    \ arr5 = [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"];\n    string[] arr6 = [\"\
    SErviNGSliCes\", \"Cheese\", \"StuFfed\"];\n    string[] arr7 = [\"SErviNGSliCes\"\
    , \"Cheese\", \"StuFfed\"];\n    string[] arr8 = [\"SErviNGSliCes\", \"Cheese\"\
    , \"StuFfed\"];\n    string[] arr9\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe9w4iepy.d(28): Error: unterminated character constant\n/tmp/tmpe9w4iepy.d(57):
    Error: found \''arr9\'' when expecting \'';\'' following statement\n/tmp/tmpe9w4iepy.d(58):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpe9w4iepy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = tuple(0, \"\") ;\n    foreach(ext;\
    \ extensions)\n    {\n        auto n = count(ext, (c) { return 'A' <= c && c <=\
    \ 'Z'; } )\n              - count(ext, (c) { return 'a' <= c && c <= 'z'; } );\n\
    \        if(n > strongest[0])\n            strongest = tuple(n, ext);\n    }\n\
    \    return format(\"%s.%s\", class_name, strongest[1]);\n}\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmporyfedzy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string s = \"\";\n    float max = -10000000;\n\
    \    int i = 0;\n    float cur;\n    foreach(string ex; extensions)\n    {\n \
    \       cur = float(ex.filter!(a => a.isUpper).length) - float(ex.filter!(a =>\
    \ a.isLower).length);\n        if(cur > max)\n        {\n            max = cur;\n\
    \            s = class_name ~ \".\" ~ ex;\n        }\n    }\n    return s;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1plyck1f.d(30): Error: found \''(\'' when expecting \''.\''
    following float\n/tmp/tmp1plyck1f.d(30): Error: found \'')\'' when expecting \'';\''
    following statement\n/tmp/tmp1plyck1f.d(30): Error: found \''(\'' when expecting
    \''.\'' following float\n/tmp/tmp1plyck1f.d(30): Error: found \'')\'' when expecting
    \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1plyck1f.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max = 0;\n    string result = class_name;\n\
    \    foreach(string extension; extensions)\n    {\n        double caps = 0, smalls\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c >= 'A'\
    \ && c <= 'Z')\n                caps += 1;\n            else if(c >= 'a' && c\
    \ <= 'z')\n                smalls += 1;\n        }\n        if(max < caps - smalls)\n\
    \        {\n            max = caps - smalls;\n            result = class_name\
    \ ~ \".\" ~ extension;\n        }\n    }\n    return result;\n}\n/*\nYou are given\
    \ a text string and a list of keywords. To make the text string\n    more secure\
    \ you want to remove all the keywords from the text string. \n    We will use\
    \ a very basic way of removal, by replacing the keywords in the \n    text string\
    \ by a space.\n    For example, if the text string is \"I really like really red\
    \ apples\" \n    and the keywords are [\"really\", \"red\"], we get \"I like apples\"\
    .\n    Create a function that takes a text string and a list of keywords and \n\
    \    returns the text string with the keywords removed.\n    Example:\n    >>>\
    \ Secure_Text(\"I really like really red apples\", [\"really\", \"red\"])\n  \
    \  \"I like apples\"\n*/\nstring Secure_Text(string text, string[] keywords) \n\
    {\n    text = text.toLower();\n    foreach(string s; keywords)\n    {\n      \
    \  int index = 0;\n        for(; index >= 0;)\n        {\n            index =\
    \ text.find(s);\n            if(index >= 0)\n                text = text[0..index]\
    \ ~ text[index+s.length..$];\n        }\n    }\n    return text;\n}\n/*\nArrays\
    \ of arrays are a useful data structure for many types of games and other applications.\n\
    \    They are also known as tables or grids. To keep things simple, we will be\
    \ using a 2D array.\n    Write a function that, given a 2D array, checks if it\
    \ contains a 2x2\n    block of the same values.\n    Example:\n    >>> Block_Check([\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5rbak_wa.d(72): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5rbak_wa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengs = extensions.map!(e => e.count!(c\
    \ => c.isUpperCase) - e.count!(c => c.isLowerCase));\n    int[] idx = iota(extensions.length);\n\
    \    idx.sort!((a, b) => strengs[a] < strengs[b] || strengs[a] == strengs[b] &&\
    \ a > b);\n    return format(\"%s.%s\", class_name, extensions[idx[0]]);\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf8tkvz4z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Your code goes here\n    real maxStrength =\
    \ 0;\n    string strongestExtension = \"\";\n    foreach(extension; extensions)\n\
    \    {\n        size_t uppers = 0;\n        size_t lowers = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(isUpper(c))\n                uppers++;\n\
    \            else\n                lowers++;\n        }\n        real strength\
    \ = cast(real)uppers - cast(real)lowers;\n        if(strength > maxStrength)\n\
    \        {\n            maxStrength = strength;\n            strongestExtension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongestExtension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfvqshxr6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int CAP = 0;\n    int SM = 0;\n    double strongest\
    \ = 0;\n    int strongest_i = 0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length;\
    \ j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j]\
    \ <= 'Z')\n            {\n                CAP++;\n            }\n            else\
    \ if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n            {\n   \
    \             SM++;\n            }\n        }\n        if (CAP - SM > strongest)\n\
    \        {\n            strongest = CAP - SM;\n            strongest_i = i;\n\
    \        }\n    }\n    return class_name + \".\" + extensions[strongest_i];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0b2coz2_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int uppercase_count\
    \ = 0;\n        int lowercase_count = 0;\n        foreach(in char ch; extension)\n\
    \        {\n            if(isLower(ch))\n            {\n                lowercase_count++;\n\
    \            }\n            else if(isUpper(ch))\n            {\n            \
    \    uppercase_count++;\n            }\n        }\n        int temp_strength =\
    \ uppercase_count - lowercase_count;\n        if(temp_strength > strength)\n \
    \       {\n            strength = temp_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqs8zwi4v.d(30): Error: basic type expected, not in\n/tmp/tmpqs8zwi4v.d(30):
    Error: no identifier for declarator int\n/tmp/tmpqs8zwi4v.d(30): Error: found
    \''in\'' when expecting \'';\''\n/tmp/tmpqs8zwi4v.d(30): Error: found \''ch\''
    when expecting \''.\'' following char\n/tmp/tmpqs8zwi4v.d(30): Error: found \'';\''
    when expecting identifier following \''char.\''\n/tmp/tmpqs8zwi4v.d(30): Error:
    found \''extension\'' when expecting \'')\''\n/tmp/tmpqs8zwi4v.d(30): Error: found
    \'')\'' instead of statement\n/tmp/tmpqs8zwi4v.d(36): Error: found \''else\''
    instead of statement\n/tmp/tmpqs8zwi4v.d(40): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqs8zwi4v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and an array of extensions.\n    The extensions are to\
    \ be used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the array.\n    For example, if you are\
    \ given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    struct Class_Extensions\n    {\n        string\
    \ class_name;\n        string strongest_extension;\n        int extension_strength;\n\
    \    }\n    int class_extension_strength = 0;\n    for(extension; extensions)\n\
    \    {\n        class_extension_strength = 0;\n        for(extension_letter; extension)\n\
    \        {\n            if(extension_letter.isUpper)\n            {\n        \
    \        class_extension_strength++;\n            }\n            else if(extension_letter.isLower)\n\
    \            {\n                class_extension_strength--;\n            }\n \
    \       }\n    }\n    return (class_name ~ \".\" ~ strongest_extension);\n}\n\
    /*\n    You are given a list of integers:\n    [1, 10, 7, 3, 3, 3, 4, 5, 5, 5,\
    \ 7, 8, 9, 10, 11, 4, 4, 5, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\
    \ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjm27sqls.d(31): Error: found \'')\'' when expecting \'';\''
    following for condition\n/tmp/tmpjm27sqls.d(34): Error: found \'')\'' when expecting
    \'';\'' following for condition\n/tmp/tmpjm27sqls.d(45): Error: found \''}\''
    when expecting \'')\''\n/tmp/tmpjm27sqls.d(48): Error: unterminated /* */ comment\n/tmp/tmpjm27sqls.d(65):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpjm27sqls.d(65): Error:
    found \''EOF\'' instead of statement\n/tmp/tmpjm27sqls.d(65): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpjm27sqls.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015081
