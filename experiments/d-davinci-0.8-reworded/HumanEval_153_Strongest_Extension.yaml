name: HumanEval_153_Strongest_Extension
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name of\
  \ a class (a string) and an array of extensions.\n    The extensions are to be used\
  \ to load additional classes to the class. The\n    strength of the extension is\
  \ as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
  \ name, and let SM be the number of lowercase letters \n    in the extension's name,\
  \ the strength is given by the fraction CAP - SM. \n    You should find the strongest\
  \ extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
  \    If there are two or more extensions with the same strength, you should\n  \
  \  choose the one that comes first in the array.\n    For example, if you are given\
  \ \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes',\
  \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
  \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n\
  \    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\
  \n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n"
tests: "unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
  Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
  Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
  );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
  , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
  K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
  __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
  YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
  YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
  , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\"\
  , \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"])\
  \ == \"Sp.671235\");\n}\nvoid main(){}"
completions: ["{\n    int strongest = 0;\n    string strongest_extension = \"\";\n\
    \    foreach(extension; extensions)\n    {\n        int strength = 0;\n      \
    \  foreach(c; extension)\n        {\n            if(c.isUpper)\n             \
    \   strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest)\n        {\n            strongest\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}", "{\n    string strongest\
    \ = \"\";\n    double strength = -1.0;\n    foreach(string s; extensions) {\n\
    \        int caps = 0;\n        int sms = 0;\n        foreach(char c; s) {\n \
    \           if(c >= 'A' && c <= 'Z')\n                caps++;\n            else\
    \ if(c >= 'a' && c <= 'z')\n                sms++;\n        }\n        double\
    \ cur_strength = double(caps)/double(sms);\n        if(cur_strength > strength)\
    \ {\n            strength = cur_strength;\n            strongest = s;\n      \
    \  }\n    }\n    return class_name~\".\"~strongest;\n}", "{\n    string strongest_extension\
    \ = null;\n    float highest_strength = 0;\n    float strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        strength = 0;\n        float CAP = 0;\n\
    \        float SM = 0;\n        foreach(char c; extension)\n        {\n      \
    \      if(c.isUpper())\n            {\n                CAP++;\n            }\n\
    \            else\n            {\n                SM++;\n            }\n     \
    \   }\n        strength = CAP - SM;\n        if(strength > highest_strength)\n\
    \        {\n            highest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return (class_name ~ \".\" ~ strongest_extension);\n\
    }", "{\n    if (extensions.length == 0)\n        return class_name;\n    ulong\
    \ i = 0;\n    double str = 0;\n    double temp = 0;\n    foreach (ext; extensions)\n\
    \    {\n        temp = 0;\n        foreach (t; ext)\n        {\n            if\
    \ (t.isUpper)\n                temp++;\n            else\n                temp--;\n\
    \        }\n        if (temp > str)\n        {\n            str = temp;\n    \
    \        i = extensions.indexOf(ext);\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[i];\n}", "{\n    return (class_name ~ \".\" ~ extensions[0]);\n\
    }", "{\n    float maxStrength = 0.0f;\n    int maxStrengthIndex = 0;\n    float\
    \ currentStrength = 0.0f;\n    int lowerCaseAmount = 0;\n    int upperCaseAmount\
    \ = 0;\n    foreach(index, extension; extensions)\n    {\n        foreach(character;\
    \ extension)\n        {\n            if(character.isUpper)\n            {\n  \
    \              upperCaseAmount++;\n            }\n            else\n         \
    \   {\n                lowerCaseAmount++;\n            }\n        }\n        currentStrength\
    \ = (upperCaseAmount / (float)lowerCaseAmount);\n        if(currentStrength >\
    \ maxStrength)\n        {\n            maxStrength = currentStrength;\n      \
    \      maxStrengthIndex = index;\n        }\n        lowerCaseAmount = 0;\n  \
    \      upperCaseAmount = 0;\n    }\n    return class_name ~ \".\" ~ extensions[maxStrengthIndex];\n\
    }", "{\n    //TODO: Add code here\n    int current_max_strength = -1;\n    string\
    \ current_max_extension = \"\";\n    foreach(string ext; extensions)\n    {\n\
    \        int new_strength = 0;\n        foreach(char c; ext)\n        {\n    \
    \        if(isupper(c))\n                new_strength++;\n            else if(islower(c))\n\
    \                new_strength--;\n        }\n        if(new_strength > current_max_strength)\n\
    \        {\n            current_max_strength = new_strength;\n            current_max_extension\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ current_max_extension;\n\
    }\n/*\n    You are given an integer array which represents the height of a histogram,\n\
    \    where the width of each bar is 1. For example, if the array is [2, 3, 1,\
    \ 2, 4],\n    then here is the histogram that it represents:\n    *\n    * *\n\
    \    * *\n    * * *\n    * * *\n    Write a function that takes in such an array\
    \ and return the size of the largest\n    rectangle that can be made out of the\
    \ histogram. For the histogram above,\n    the largest rectangle would be the\
    \ 4x3 rectangle with the top-left corner at (1, 2).\n    If the array is [2, 3,\
    \ 1, 2, 4, 3], then here is the histogram that it represents:\n    *\n    * *\n\
    \    * *\n    * * *\n    * * *\n    * * *\n    The largest rectangle would be\
    \ the 3x2 rectangle with the top-left corner at (2, 3).\n    If the array is [5,\
    \ 4, 3, 2, 1], then here is the histogram that it represents:\n    * * * * *\n\
    \    * * * * *\n    * * * * *\n    * * * * *\n    * * * * *\n    The largest rectangle\
    \ would be the 5x1 rectangle with the top-left corner at (0, 0).\n    If the array\
    \ is [5, 4, 3, 2, 1, 6], then here is the histogram that it represents:\n    *\
    \ * *", "{\n    uint max = 0;\n    foreach(ref string s; extensions)\n    {\n\
    \        uint count = 0;\n        foreach(c; s)\n        {\n            if(isUpper(c))\n\
    \                count++;\n        }\n        if(count > max)\n            max\
    \ = count;\n    }\n    return class_name ~ \".\" ~ extensions[max];\n}", "{\n\
    \     int strength = -1;\n     int uppercase = 0;\n     int lowercase = 0;\n \
    \    string strongest_extension = \"\";\n     foreach(string s; extensions)\n\
    \     {\n         foreach(char c; s)\n         {\n             if(c.isUpper)\n\
    \             {\n                 uppercase++;\n             }\n             else\n\
    \             {\n                 lowercase++;\n             }\n         }\n \
    \        if(uppercase - lowercase > strength)\n         {\n             strength\
    \ = uppercase - lowercase;\n             strongest_extension = s;\n         }\n\
    \         uppercase = 0;\n         lowercase = 0;\n     }\n     return class_name\
    \ ~ \".\" ~ strongest_extension;\n}", "{\n    // 1. Take string class_name and\
    \ string[] extensions\n    // 2. Loop through extensions and calculate strength\
    \ (total_upper - total_lower)\n    // 3. Return \"class_name.extension_with_highest_strength\"\
    \n    //\n    //  loop-extensions -> get-total-upper -> get-total-lower -> calculate-strength\
    \ ->\n    //  check-if-highest -> return-string\n    //  \n    //  loop-extensions\
    \ -> get-total-upper -> get-total-lower -> calculate-strength ->\n    //  check-if-highest\
    \ -> return-string\n    //  \n    //  loop-extensions -> get-total-upper -> get-total-lower\
    \ -> calculate-strength ->\n    //  check-if-highest -> return-string\n    //\
    \  \n    //  loop-extensions -> get-total-upper -> get-total-lower -> calculate-strength\
    \ ->\n    //  check-if-highest -> return-string\n    //  \n    //  return \"class_name.extension_with_highest_strength\"\
    \n    //  \n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n \
    \   //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n", "{\n\
    \t// your code goes here\n\tint c_count = 0;\n\tint l_count = 0;\n\tfloat max_strength\
    \ = -100;\n\tstring strongest_extension = \"\";\n\tforeach(string extension; extensions)\n\
    \t{\n\t\tforeach(char c; extension)\n\t\t{\n\t\t\tif(isupper(c)) c_count++;\n\t\
    \t\telse if(islower(c)) l_count++;\n\t\t}\n\t\tfloat strength = (float)c_count\
    \ - (float)l_count;\n\t\tif(strength > max_strength)\n\t\t{\n\t\t\tmax_strength\
    \ = strength;\n\t\t\tstrongest_extension = extension;\n\t\t}\n\t\tc_count = 0;\n\
    \t\tl_count = 0;\n\t}\n\treturn class_name ~ \".\" ~ strongest_extension;\n}",
  "{\n    import std.typecons;\n    // sort the array in order\n    sort(extensions);\n\
    \    int[] strengths = new int[extensions.length];\n    for (int i = 0; i < extensions.length;\
    \ i++) {\n        int cap_count = 0;\n        int small_count = 0;\n        for\
    \ (int j = 0; j < extensions[i].length; j++) {\n            char c = extensions[i][j];\n\
    \            if (c.isUpper) {\n                cap_count++;\n            } else\
    \ {\n                small_count++;\n            }\n        }\n        strengths[i]\
    \ = cap_count - small_count;\n    }\n    int best_strength = strengths[0];\n \
    \   int best_index = 0;\n    for (int i = 1; i < strengths.length; i++) {\n  \
    \      if (strengths[i] > best_strength) {\n            best_strength = strengths[i];\n\
    \            best_index = i;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ extensions[best_index];\n}", "{\n    int max = -9;\n    string Max = \"\"\
    ;\n    foreach(string val; extensions)\n    {\n        int up = 0;\n        int\
    \ low = 0;\n        foreach(char c; val)\n        {\n            if(c.isUpper)\n\
    \                up++;\n            else\n                low++;\n        }\n\
    \        if(up - low > max)\n        {\n            max = up - low;\n        \
    \    Max = val;\n        }\n    }\n    return class_name ~ \".\" ~ Max;\n}", "{\n\
    \    if (extensions.length == 0)\n        return class_name;\n    string greatest\
    \ = extensions[0];\n    int greatest_strength = 0;\n    foreach (string extension;\
    \ extensions)\n    {\n        int strength = 0;\n        foreach (char c; extension)\n\
    \        {\n            if (isUpper(c))\n                strength++;\n       \
    \     else if (isLower(c))\n                strength--;\n        }\n        if\
    \ (strength > greatest_strength)\n        {\n            greatest_strength = strength;\n\
    \            greatest = extension;\n        }\n    }\n    return class_name ~\
    \ \".\" ~ greatest;\n}\n/*\nA square matrix of integers is given as input. Your\
    \ task is to determine\nif the matrix is magic square. You must follow the definition\
    \ of\nmagic square which is:", "{\n    struct ExtensionStrength\n    {\n     \
    \   size_t index;\n        float strength;\n        bool operator<(ExtensionStrength\
    \ other) const\n        {\n            if (this.strength != other.strength)\n\
    \                return this.strength < other.strength;\n            return this.index\
    \ < other.index;\n        }\n    }\n    auto strengths = extensions.map!(ext =>\
    \ {\n        int sm = 0;\n        int cap = 0;\n        foreach (immutable char\
    \ c; ext)\n        {\n            if (isUpper(c))\n                cap++;\n  \
    \          else\n                sm++;\n        }\n        return ExtensionStrength(ext.indexOf,\
    \ cast(float)cap / (sm+1));\n    });\n    auto strongest = strengths.max;\n  \
    \  return class_name ~ \".\" ~ extensions[strongest.index];\n}", "{\n    int max\
    \ = 0;\n    string strongest_name = extensions[0];\n    foreach(string e; extensions)\n\
    \    {\n        int curr = countUp(e) - countDown(e);\n        if(curr > max)\n\
    \        {\n            max = curr;\n            strongest_name = e;\n       \
    \ }\n    }\n    return class_name ~ \".\" ~ strongest_name;\n}\nprivate int countUp(string\
    \ name)\n{\n    int count = 0;\n    foreach(char c; name)\n    {\n        if(c.isUpper)\n\
    \            count++;\n    }\n    return count;\n}\nprivate int countDown(string\
    \ name)\n{\n    int count = 0;\n    foreach(char c; name)\n    {\n        if(c.isLower)\n\
    \            count++;\n    }\n    return count;\n}\n/*\n    Write a function that\
    \ takes a number and returns all of its prime factors.\n    The result should\
    \ be a tuple of numbers arranged from smallest to largest.\n    For example, if\
    \ the input is 120, the output should be (2, 2, 2, 3, 5).\n    Example:\n    >>>\
    \ prime_factors(120)\n    (2, 2, 2, 3, 5)\n    \n*/\nTuple!(int[]) prime_factors(int\
    \ n)\n{\n    Tuple!(int[]) factors;\n    int[] primes = [2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n \
    \   foreach(int prime; primes)\n    {\n        while(n % prime == 0)\n       \
    \ {\n            n /= prime;\n            factors ~= prime;\n        }\n    }\n\
    \    return factors;\n}\n/*\n    You are given a list of integers. You should\
    \ count the smallest number of \n    swaps needed to sort the list in non-decreasing\
    \ order.\n    A swap is defined as a pair of elements being swapped. Each element\
    \ can \n    only be swapped once.\n    The list is always sorted in non-", "{\n\
    \    int strong = 0;\n    int strong_pos = 0;\n    int i;\n    int sm;\n    int\
    \ cap;\n    string result;\n    if (extensions.length == 0) \n    {\n        return\
    \ class_name;\n    }\n    foreach (auto extension; extensions) \n    {\n     \
    \   int sm = 0;\n        int cap = 0;\n        i = 0;\n        while (i < extension.length)\
    \ \n        {\n            if (extension[i] > 64 && extension[i] < 91) \n    \
    \        {\n                cap++;\n            }\n            else if (extension[i]\
    \ > 96 && extension[i] < 123) \n            {\n                sm++;\n       \
    \     }\n            i++;\n        }\n        int s = cap - sm;\n        if (s\
    \ > strong) \n        {\n            strong = s;\n            strong_pos = i;\n\
    \        }\n    }\n    result = class_name ~ \".\" ~ extensions[strong_pos];\n\
    \    return result;\n}", "{\n    string result = class_name;\n    double max_strength\
    \ = 0;\n    foreach(string ext; extensions) {\n        double strength = 0;\n\
    \        foreach(char c; ext) {\n            if (c >= 'A' && c <= 'Z') {\n   \
    \             strength += 1;\n            } else if (c >= 'a' && c <= 'z') {\n\
    \                strength -= 1;\n            }\n        }\n        if (strength\
    \ > max_strength) {\n            max_strength = strength;\n            result\
    \ = class_name ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}", "{\n\
    \    float strength_of_extension = 0.0;\n    float[] strength_of_all_extensions\
    \ = new float[extensions.length];\n    for (int i = 0; i < extensions.length;\
    \ i++)\n    {\n        for (int j = 0; j < extensions[i].length; j++)\n      \
    \  {\n            if (isupper(extensions[i][j]))\n            {\n            \
    \    strength_of_extension += 1;\n            }\n            else\n          \
    \  {\n                strength_of_extension -= 1;\n            }\n        }\n\
    \        strength_of_all_extensions[i] = strength_of_extension;\n        strength_of_extension\
    \ = 0;\n    }\n    uint pos_of_strongest_extension = max_element_index(strength_of_all_extensions);\n\
    \    return class_name + \".\" + extensions[pos_of_strongest_extension];\n}",
  "{\n    real max_strength = real.min;\n    string max_ext;\n    foreach(ext; extensions)\n\
    \    {\n        int caps = 0;\n        int sms = 0;\n        foreach(c; ext)\n\
    \        {\n            if(c.isUpper)\n                caps++;\n            else\n\
    \                sms++;\n        }\n        real strength = cast(real)caps - cast(real)sms;\n\
    \        if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            max_ext = ext;\n        }\n    }\n    return class_name ~ \".\" ~\
    \ max_ext;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
