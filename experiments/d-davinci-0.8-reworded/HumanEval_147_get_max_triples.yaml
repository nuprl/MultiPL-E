name: HumanEval_147_get_max_triples
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a positive\
  \ integer n. You have to create an integer array a of length n.\n        For each\
  \ i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the\
  \ number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j]\
  \ + a[k] is a multiple of 3.\n\n    Example :\n    >>> get_max_triples(5L)\n   \
  \ 1L\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid\
  \ triple is (1, 7, 13).\n    \n*/\nlong get_max_triples(long n) \n"
tests: "unittest\n{\n    alias candidate = get_max_triples;\n\n    assert(candidate(5L)\
  \ == 1L);\n    assert(candidate(6L) == 4L);\n    assert(candidate(10L) == 36L);\n\
  \    assert(candidate(100L) == 53361L);\n}\nvoid main(){}"
completions: ["{\n    auto l = new long[](n);\n    long cnt = 0;\n    foreach(i, l)\n\
    \    {\n        l[i] = i * i - i + 1;\n    }\n    foreach(i, l)\n    {\n     \
    \   foreach(j, l[i + 1 .. $])\n        {\n            foreach(k, l[j + 1 .. $])\n\
    \            {\n                if((l[i] + l[j] + l[k]) % 3 == 0)\n          \
    \      {\n                    ++cnt;\n                }\n            }\n     \
    \   }\n    }\n    return cnt;\n}", "{\n    auto arr = appender!(long[])();\n \
    \   long i;\n    for (i = 1; i <= n; i++) \n    {\n        arr.put(i * i - i +\
    \ 1);\n    }\n    long num_triples = 0;\n    for (i = 0; i < n; i++) \n    {\n\
    \        for (long j = i + 1; j < n; j++) \n        {\n            for (long k\
    \ = j + 1; k < n; k++) \n            {\n                if ((arr[i] + arr[j] +\
    \ arr[k]) % 3 == 0) \n                {\n                    num_triples++;\n\
    \                }\n            }\n        }\n    }\n    return num_triples;\n\
    }", "{\n    int[] a = new int[n];\n    int count = 0;\n    foreach(idx, i; a)\n\
    \    {\n        a[idx] = i * i - i + 1;\n    }\n    foreach(i; a)\n    {\n   \
    \     foreach(j; a[i + 1 .. $])\n        {\n            foreach(k; a[j + 1 ..\
    \ $])\n            {\n                if((i + j + k) % 3 == 0)\n             \
    \   {\n                    count++;\n                }\n            }\n      \
    \  }\n    }\n    return count;\n}\n/*\n    The order of the Fibonacci sequence\
    \ is a row of numbers where every number is the sum of the two numbers directly\
    \ before it.\n    Your task is to write a function that takes in an integer, n,\
    \ and returns the nth number of the Fibonacci sequence.\n    Example:\n    >>>\
    \ get_fibonacci(1)\n    1\n    >>> get_fibonacci(2)\n    1\n    >>> get_fibonacci(8)\n\
    \    21\n    >>> get_fibonacci(0)\n    -1\n*/", "{\n    // create vector based\
    \ on n\n    auto size = n as int;\n    auto a = new int[](size);\n    // fill\
    \ vector\n    foreach(i, ref item; a)\n    {\n        item = i * i - i + 1;\n\
    \    }\n    // print vector\n    foreach(i, ref item; a)\n    {\n        writeln(item);\n\
    \    }\n    return 0L;\n}", "{\n    long[] a = new long[n];\n    long triple_cnt\
    \ = 0;\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = i * i - i + 1;\n\
    \    }\n    for (int i = 0; i < n - 2; i++)\n    {\n        for (int j = i + 1;\
    \ j < n - 1; j++)\n        {\n            for (int k = j + 1; k < n; k++)\n  \
    \          {\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\n           \
    \     {\n                    triple_cnt++;\n                }\n            }\n\
    \        }\n    }\n    return triple_cnt;\n}\n// Test #1\nimport testlib.checker.Checker;\n\
    import testlib.checker.StringUtils;\nimport testlib.checker.StringWrapper;", "{\n\
    \    // Write your code here\n    long[] a = new long[(int)n];\n    foreach(i;\
    \ 0 .. n)\n    {\n        a[i] = i * i - i + 1;\n    }\n    long result = 0;\n\
    \    foreach(i; 0 .. n)\n    {\n        foreach(j; i+1 .. n)\n        {\n    \
    \        foreach(k; j+1 .. n)\n            {\n                if(a[i] + a[j] +\
    \ a[k] % 3 == 0)\n                {\n                    result++;\n         \
    \       }\n            }\n        }\n    }\n    return result;\n}", "{\n    long\
    \ counter=0L;\n    for(long i=1L;i<n;i++)\n    {\n        for(long j=i+1L;j<n;j++)\n\
    \        {\n            for(long k=j+1L;k<n;k++)\n            {\n            \
    \    if((i*i-i+1L+j*j-j+1L+k*k-k+1L)%3L==0L)\n                {\n            \
    \        counter++;\n                }\n            }\n        }\n    }\n    return\
    \ counter;\n}", "{\n    long res = 0;\n    foreach(size_t i; 0 .. n - 2)\n   \
    \ {\n        foreach(size_t j; i + 1 .. n - 1)\n        {\n            foreach(size_t\
    \ k; j + 1 .. n)\n            {\n                if(i*i - i + 1 + j*j - j + 1\
    \ + k*k - k + 1 % 3 == 0)\n                {\n                    res++;\n   \
    \             }\n            }\n        }\n    }\n    return res;\n}", "{\n  \
    \  long ret = 0;\n    long ai = 0;\n    long aj = 0;\n    long ak = 0;\n    foreach(i;\
    \ 1..n)\n    {\n        ai = i * i - i + 1;\n        foreach(j; (i + 1)..n)\n\
    \        {\n            aj = j * j - j + 1;\n            foreach(k; (j + 1)..n)\n\
    \            {\n                ak = k * k - k + 1;\n                if((ai +\
    \ aj + ak) % 3 == 0)\n                {\n                    ret++;\n        \
    \        }\n            }\n        }\n    }\n    return ret;\n}\n/*\n    TEST\n\
    */\nimport std.stdio;", "{\n    long total = 0;\n    for (long i = 0; i < n; i++)\n\
    \    {\n        for (long j = i + 1; j < n; j++)\n        {\n            for (long\
    \ k = j + 1; k < n; k++)\n            {\n                long v1 = (i + 1) * (i\
    \ + 1) - (i + 1) + 1;\n                long v2 = (j + 1) * (j + 1) - (j + 1) +\
    \ 1;\n                long v3 = (k + 1) * (k + 1) - (k + 1) + 1;\n           \
    \     if ((v1 + v2 + v3) % 3 == 0)\n                {\n                    total++;\n\
    \                }\n            }\n        }\n    }\n    return total;\n}", "{\n\
    \    enum num = ctfe(3);\n    long[] a = new long[n];\n    foreach(int i, ref\
    \ el; a)\n    {\n        el = i * i - i + 1;\n    }\n    long count = 0;\n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n\
    \        {\n            for(int k = j + 1; k < n; k++)\n            {\n      \
    \          if((a[i] + a[j] + a[k]) % num == 0)\n                {\n          \
    \          count++;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}", "{\n    long[] a = new long[int(n)];\n    long count = 0;\n    foreach(i;\
    \ 0..n)\n    {\n        a[i] = i * i - i + 1;\n    }\n    foreach(i; 0..n)\n \
    \   {\n        foreach(j; i+1..n)\n        {\n            foreach(k; j+1..n)\n\
    \            {\n                if((a[i] + a[j] + a[k]) % 3 == 0)\n          \
    \      {\n                    ++count;\n                }\n            }\n   \
    \     }\n    }\n    return count;\n}\n/*\n    We will call the num_vertices function\
    \ on the tree t and the number n. \n    It should return the number of vertices\
    \ that are located at a distance less than or equal to n from the root.\n*/",
  "{\n    long result = 0;\n    // for (i in 1..n)\n    for (long i = 1; i <= n; i++)\n\
    \    {\n        long a_i = i * i - i + 1;\n        // for (j in i + 1..n)\n  \
    \      for (long j = i + 1; j <= n; j++)\n        {\n            long a_j = j\
    \ * j - j + 1;\n            // for (k in j + 1..n)\n            for (long k =\
    \ j + 1; k <= n; k++)\n            {\n                long a_k = k * k - k + 1;\n\
    \                // if (a_i + a_j + a_k) % 3 == 0\n                if ((a_i +\
    \ a_j + a_k) % 3 == 0)\n                {\n                    // result += 1\n\
    \                    result += 1;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    long count = 0;\n    long mod_sum;\n \
    \   for (long a = 1; a < n - 1; a++)\n    {\n        for (long b = a + 1; b <\
    \ n; b++)\n        {\n            mod_sum = (a * a - a + 1) + (b * b - b + 1);\n\
    \            for (long c = b + 1; c <= n; c++)\n            {\n              \
    \  mod_sum += (c * c - c + 1);\n                if (mod_sum % 3 == 0)\n      \
    \          {\n                    count++;\n                }\n            }\n\
    \        }\n    }\n    return count;\n}", "{\n    long t = 0;\n    long hl = (n\
    \ - 1) / 2;\n    foreach(idx, item; iota(1L, n + 1L)) \n    {\n        auto v\
    \ = item * item - item + 1;\n        if (v % 3 == 0) \n        {\n           \
    \ auto x = (hl + 1) / item;\n            auto c = idx - hl;\n            auto\
    \ d = n - idx;\n            if (c >= 0 && d >= 0) \n            {\n          \
    \      t += x * c + x * d - x * x;\n            }\n        }\n    }\n    return\
    \ t;\n}", "{\n    return (n * (n - 1) * (n - 2)) / 6;\n}", "{\n    long[] a =\
    \ new long[n];\n    foreach(i, ref e; a)\n    {\n        e = i * i - i + 1;\n\
    \    }\n    long counter = 0;\n    for(long i = 0; i < n; i++)\n    {\n      \
    \  for(long j = i + 1; j < n; j++)\n        {\n            for(long k = j + 1;\
    \ k < n; k++)\n            {\n                if((a[i] + a[j] + a[k]) % 3 == 0)\n\
    \                {\n                    counter++;\n                }\n      \
    \      }\n        }\n    }\n    return counter;\n}", "{\n    long[] a = new long[to!int(n)];\n\
    \    long r=0;\n    for(long i=0;i<n;i++)\n    {\n        a[i]=i*i-i+1;\n    \
    \    if(i>1)\n        {\n            for(long j=i-1;j>0;j--)\n            {\n\
    \                if((a[i]+a[j])%3==0)\n                {\n                   \
    \ for(long k=j-1;k>=0;k--)\n                    {\n                        if((a[i]+a[j]+a[k])%3==0)\n\
    \                        {\n                            r++;\n               \
    \         }\n                    }\n                }\n            }\n       \
    \ }\n    }\n    return r;\n}", "{\n    long[long] a;\n    a[0] = 1;\n    for (long\
    \ i = 1; i < n; i++) \n    {\n        a[i] = a[i - 1] + (2 * i + 1);\n    }\n\
    \    long cnt = 0;\n    for (long i = 0; i < n - 2; i++) \n    {\n        for\
    \ (long j = i + 1; j < n - 1; j++) \n        {\n            long psum = a[i] +\
    \ a[j];\n            if (psum % 3 == 0) \n            {\n                long\
    \ rem = psum / 3;\n                auto m = std.algorithm.lower_bound(a, i + 1,\
    \ n, rem);\n                if (m != n && *m == rem) \n                {\n   \
    \                 cnt++;\n                }\n            }\n        }\n    }\n\
    \    return cnt;\n}\nlong calculateMultiplicativePersistence(long n)\n{\n\tif\
    \ (n < 10) return 0;\n\tauto p = n.to!string.reduce!((a, b) => a * b).to!long;\n\
    \treturn 1 + calculateMultiplicativePersistence(p);\n}", "{\n    long count=0L;\n\
    \    if(n==0L)\n        return 0L;\n    if(n<=3L)\n        return 0L;\n    if(n<=5L)\n\
    \        return 1L;\n    foreach(i;1L..n)\n    {\n        foreach(j;i+1L..n)\n\
    \        {\n            foreach(k;j+1L..n)\n            {\n                if((i*i-i+1L+j*j-j+1L+k*k-k+1L)%3L==0L)\n\
    \                    count++;\n            }\n        }\n    }\n    return count;\n\
    }", "{\n    long ret=0;\n    foreach(int i;0..n)\n    {\n        foreach(int j;0..n)\n\
    \        {\n            foreach(int k;0..n)\n            {\n                if(j>i\
    \ && k>j && (i*i-i+1 +j*j-j+1 +k*k-k+1)%3==0)\n                {\n           \
    \         ret++;\n                }\n            }\n        }\n    }\n    return\
    \ ret;\n}", "{\n    long counter = 0;\n    for (size_t i = 0; i < n; i++)\n  \
    \  {\n        for (size_t j = i + 1; j < n; j++)\n        {\n            for (size_t\
    \ k = j + 1; k < n; k++)\n            {\n                if ((i * i - i + 1 +\
    \ j * j - j + 1 + k * k - k + 1) % 3 == 0)\n                {\n              \
    \      counter++;\n                }\n            }\n        }\n    }\n    return\
    \ counter;\n}", "{\n    long const m = n;\n    long l = 0L;\n    while(n--) l\
    \ += n - 1L;\n    return l / 3L;\n}", "{\n    auto a = new int[n](1);\n    foreach(i,\
    \ ref e; a) e = i * i - i + 1;\n    long count = 0;\n    foreach(i, e; a)\n  \
    \  {\n        foreach(j, f; a[i + 1 .. $])\n        {\n            foreach(k,\
    \ g; a[j + 1 .. $])\n            {\n                if((e + f + g) % 3 == 0)\n\
    \                    count++;\n            }\n        }\n    }\n    return count;\n\
    }", "{\n    long res = 0;\n    for (long i = 1; i < n; i++)\n    {\n        auto\
    \ a = i * i - i + 1;\n        for (long j = i + 1; j < n; j++)\n        {\n  \
    \          auto b = j * j - j + 1;\n            for (long k = j + 1; k < n; k++)\n\
    \            {\n                auto c = k * k - k + 1;\n                if ((a\
    \ + b + c) % 3 == 0)\n                    res++;\n            }\n        }\n \
    \   }\n    return res;\n}", "{\n    long result = 0;\n    long _a = 1;\n    long\
    \ _b = 3;\n    long _c = 7;\n    long _d = 13;\n    long _e = 21;\n    for (;\
    \ _a < n; _a++)\n    {\n        for (; _b < n; _b++)\n        {\n            for\
    \ (; _c < n; _c++)\n            {\n                if ((_a + _b + _c) % 3 == 0)\n\
    \                {\n                    result++;\n                }\n       \
    \     }\n            _c = _b + 4;\n        }\n        _b = _a + 4;\n    }\n  \
    \  return result;\n}", "{\n    auto maxTriple = 0L;\n    for(size_t i = 1; i <\
    \ n - 1; i++)\n    {\n        for(size_t j = i + 1; j < n; j++)\n        {\n \
    \           for(size_t k = j + 1; k <= n; k++)\n            {\n              \
    \  auto ai = i * i - i + 1;\n                auto aj = j * j - j + 1;\n      \
    \          auto ak = k * k - k + 1;\n                if((ai + aj + ak) % 3 ==\
    \ 0)\n                {\n                    maxTriple++;\n                }\n\
    \            }\n        }\n    }\n    return maxTriple;\n}", "{\n    long res\
    \ = 0;\n    for (int i = 1; i < n - 1; i++) \n    {\n        for (int j = i +\
    \ 1; j < n; j++) \n        {\n            if ((j * j - j + 1) % 3 == 0) \n   \
    \         {\n                res += (n - j);\n                break;\n       \
    \     }\n        }\n    }\n    return res;\n}", "{\n    long sum = 0;\n    for\
    \ (int i = 1; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n  \
    \      {\n            for (int k = j + 1; k < n; k++)\n            {\n       \
    \         if ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n    \
    \            {\n                    sum++;\n                }\n            }\n\
    \        }\n    }\n    return sum;\n}", "{\n    long[] a = new long[cast(size_t)n];\n\
    \    foreach(i; 0..n)\n        a[i] = i * i - i + 1;\n    long count = 0;\n  \
    \  for(long i = 0; i < n - 2; i++)\n        for(long j = i + 1; j < n - 1; j++)\n\
    \            for(long k = j + 1; k < n; k++)\n                if((a[i] + a[j]\
    \ + a[k]) % 3 == 0)\n                    count++;\n    return count;\n}", "{\n\
    \    long[] a = new long[n];\n    for (int i = 0; i < n; i++) \n    {\n      \
    \  a[i] = i * i - i + 1;\n    }\n    long count = 0;\n    for (int i = 0; i <\
    \ n - 2; i++) \n    {\n        for (int j = i + 1; j < n - 1; j++) \n        {\n\
    \            for (int k = j + 1; k < n; k++) \n            {\n               \
    \ if ((a[i] + a[j] + a[k]) % 3 == 0)\n                    count++;\n         \
    \   }\n        }\n    }\n    return count;\n}", "{\n    import std.range;\n  \
    \  assert(n > 0);\n    long count = 0;\n    foreach(size_t i, size_t j, size_t\
    \ k; i < n && j < n && k < n; \n        ++i, ++j, ++k) \n    {\n        if((i\
    \ + j + k) % 3 == 0)\n            ++count;\n    }\n    return count;\n}", "{\n\
    \    auto arr = array(3, 0, n);\n    for (int i = 0; i < n; i++)\n    {\n    \
    \    int cur = i * i - i + 1;\n        arr[cur % 3]++;\n    }\n    auto triple\
    \ = [](int a, int b, int c) \n    {\n        return a * b * c;\n    };\n    long\
    \ ret = triple(arr[0], arr[0], arr[0]);\n    ret += 2 * triple(arr[0], arr[0],\
    \ arr[1]);\n    ret += 2 * triple(arr[0], arr[0], arr[2]);\n    ret += 2 * triple(arr[0],\
    \ arr[1], arr[1]);\n    ret += 2 * triple(arr[0], arr[1], arr[2]);\n    ret +=\
    \ 2 * triple(arr[0], arr[2], arr[2]);\n    ret += 2 * triple(arr[1], arr[1], arr[1]);\n\
    \    ret += 2 * triple(arr[1], arr[1], arr[2]);\n    ret += 2 * triple(arr[1],\
    \ arr[2], arr[2]);\n    ret += triple(arr[2], arr[2], arr[2]);\n    return ret;\n\
    }", "{\n    import std.math : ln;\n    import std.algorithm.iteration : all;\n\
    \    auto init_arr(long n) {\n        return iota(1L).take(n).map!(x => x * x\
    \ - x + 1L).array;\n    }\n    double lg3 = ln(3L);\n    auto is_triple = (long\
    \ lhs, long rhs) {\n        return cast(long)((ln(lhs) + ln(rhs)) / lg3) == \n\
    \            cast(long)((ln(lhs) + ln(rhs)) / lg3);\n    };\n    auto arr = init_arr(n);\n\
    \    long acc = 0L;\n    for (size_t i = 0; i < arr.length; i++) {\n        for\
    \ (size_t j = i + 1; j < arr.length; j++) {\n            auto tmp = arr[i] + arr[j];\n\
    \            for (size_t k = j + 1; k < arr.length; k++) {\n                if\
    \ (is_triple(tmp, arr[k])) acc++;\n            }\n        }\n    }\n    return\
    \ acc;\n}", "{\n    long a_size0 = n;\n    double a_size1 = n;\n    long[] a =\
    \ new long[a_size0];\n    for (long i = 0; i < a_size0; i += 1) \n    {\n    \
    \    a[i] = i * i - i + 1;\n    }\n    long triples = 0;\n    foreach (i; 0 ..\
    \ a_size0) \n    {\n        foreach (j; i + 1 .. a_size0) \n        {\n      \
    \      foreach (k; j + 1 .. a_size0) \n            {\n                if ((a[i]\
    \ + a[j] + a[k]) % 3 == 0) \n                {\n                    triples +=\
    \ 1;\n                }\n            }\n        }\n    }\n    return triples;\n\
    }", "{\n    // Create a new empty array\n    int[] a = new int[n];\n    long count\
    \ = 0;\n    foreach(i; 0..n) \n    {\n        // Append the value to the array\n\
    \        a[i] = i * i - i + 1;\n    }\n    foreach(i; 0..n) \n    {\n        foreach(j;\
    \ 0..n) \n        {\n            foreach(k; 0..n) \n            {\n          \
    \      if(i < j && j < k && (a[i] + a[j] + a[k]) % 3 == 0) \n                {\n\
    \                    count++;\n                }\n            }\n        }\n \
    \   }\n    return count;\n}\n/*\n    Problem:\n        You are given a function\
    \ f and an integer n. \n    You have to return an array of n length. \n    For\
    \ each i (1 \u2264 i \u2264 n), the value of the ith element should be the number\
    \ of letters in the ith term of the series of f(0), f(1), f(2), ....\n    You\
    \ may assume that the value of n won't exceed 1000.", "{\n    long count = 0;\n\
    \    for (long i = 1; i < n - 1; i++)\n    {\n        for (long j = i + 1; j <\
    \ n; j++)\n        {\n            for (long k = j + 1; k <= n; k++)\n        \
    \    {\n                if ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) %\
    \ 3 == 0)\n                {\n                    count++;\n                }\n\
    \            }\n        }\n    }\n    return count;\n}", "{\n    return reduce!((a,\
    \ b) => a+b)(filter!((arr) => arr[0] + arr[1] + arr[2] % 3 == 0)(cartesianProduct!(iota(1L,\
    \ n), iota(1L, n), iota(1L, n))));\n}", "{\n    return (n - 2) * (n - 1) / 2;\n\
    }", "{\n    long div = n / 3;\n    long count = 0;\n    for (long i = 1; i <=\
    \ div; i++)\n    {\n        for (long j = i; j <= n; j++)\n        {\n       \
    \     long k = n - i - j;\n            if (k > j)\n            {\n           \
    \     // std.stdio.writeln(i,\" \",j,\" \",k);\n                count++;\n   \
    \         }\n        }\n    }\n    return count;\n}", "{\n    long i = 0;\n  \
    \  long j = 0;\n    long k = 0;\n    long count = 0;\n    for (i = 1; i < n; i++)\
    \ \n    {\n        for (j = i + 1; j < n; j++) \n        {\n            for (k\
    \ = j + 1; k < n; k++) \n            {\n                if ((((i * i) - i + 1)\
    \ + ((j * j) - j + 1) + ((k * k) - k + 1)) % 3 == 0) \n                {\n   \
    \                 count++;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}", "{\n    long result = 0;\n    int[long] array = new int[n];\n\
    \    int i;\n    foreach(i; 0 .. n)\n    {\n        array[i] = i * i - i + 1;\n\
    \    }\n    foreach(int i; 0 .. n - 2)\n    {\n        foreach(int j; i + 1 ..\
    \ n - 1)\n        {\n            foreach(int k; j + 1 .. n)\n            {\n \
    \               //std.stdio.writeln(array[i], array[j], array[k]);\n         \
    \       if((array[i] + array[j] + array[k]) % 3 == 0)\n                {\n   \
    \                 result++;\n                }\n            }\n        }\n   \
    \ }\n    return result;\n}", "{\n    long[] l = new long[n];\n    long sum = 0L;\n\
    \    foreach(i; 0 .. n)\n    {\n        l[i] = i * i - i + 1;\n    }\n    foreach(i;\
    \ 0 .. n)\n    {\n        foreach(j; i + 1 .. n)\n        {\n            foreach(k;\
    \ j + 1 .. n)\n            {\n                if((l[i] + l[j] + l[k]) % 3 == 0)\n\
    \                {\n                    sum++;\n                }\n          \
    \  }\n        }\n    }\n    return sum;\n}", "{\n    long result = 0;\n    for\
    \ (size_t i = 0; i < n - 2; i++) \n    {\n        for (size_t j = i + 1; j < n\
    \ - 1; j++) \n        {\n            for (size_t k = j + 1; k < n; k++) \n   \
    \         {\n                if ((i + 1) * (i + 1) - (i + 1) + 1 + (j + 1) * (j\
    \ + 1) - (j + 1) + 1 + (k + 1) * (k + 1) - (k + 1) + 1) % 3 == 0) \n         \
    \       {\n                    result++;\n                }\n            }\n \
    \       }\n    }\n    return result;\n}", "{\n    long[] a = new long[to!long(n)];\n\
    \    long triple_count = 0;\n    for (int i = 0; i < a.length; i++)\n    {\n \
    \       a[i] = i * i - i + 1;\n    }\n    for (int i = 0; i < a.length; i++)\n\
    \    {\n        for (int j = i + 1; j < a.length; j++)\n        {\n          \
    \  for (int k = j + 1; k < a.length; k++)\n            {\n                if ((a[i]\
    \ + a[j] + a[k]) % 3 == 0)\n                {\n                    triple_count++;\n\
    \                }\n            }\n        }\n    }\n    return triple_count;\n\
    }", "{\n    long result = 0;\n    for (long i = 0; i < n - 2; i++)\n    {\n  \
    \      for (long j = i + 1; j < n - 1; j++)\n        {\n            for (long\
    \ k = j + 1; k < n; k++)\n            {\n                long value = 1 + i *\
    \ i - i + 3 + j * j - j + 7 + k * k - k;\n                if (value % 3 == 0)\n\
    \                {\n                    result++;\n                }\n       \
    \     }\n        }\n    }\n    return result;\n}", "{\n    // My old solution\n\
    \    /*\n    n = n.minOf(min(n.divOf(3), n.divOf(2)));\n    bool[] a = bool[n];\n\
    \    foreach(i; 0..n)\n        a[i] = false;\n    foreach(i; 0..n)\n        foreach(j;\
    \ i+1..n)\n            if (((i+1) * (i+1) - (i+1) + 1) + ((j+1) * (j+1) - (j+1)\
    \ + 1) + ((j+1) * (j+1) - (j+1) + 1) % 3 == 0)\n                a[i] = true;\n\
    \    return a.countOf(true);\n    */\n    /*\n        My solution\n        a[i]\
    \ = i*i - i + 1\n        a[j] = j*j - j + 1\n        a[k] = k*k - k + 1\n    \
    \    i < j < k\n        a[i] + a[j] + a[k] = 3 * i*i + 3 * j*j + 3 * k*k - (i\
    \ + j + k) * 3 + 3\n        i + j + k = n.\n        n = n.minOf(min(n.divOf(3),\
    \ n.divOf(2)));\n        i + j + k = n;\n        i + j = n - k\n        0 \u2264\
    \ i \u2264 j \u2264 k \u2264 n\n        k = n - (i + j)\n        we can see that\
    \ it is possible to get all the pairs (i, j) such that i + j = n - k.\n      \
    \  This is a classical programming problem.\n        Let's represent the pairs\
    \ (i, j) as a map.\n        We will solve this problem in 2 steps.\n        1)\
    \ We find all possible pairs (i, j).\n        2) We find the possible values of\
    \ k.\n        We find the possible values of k if for some pair (i, j) we have\
    \ (i, j, k) a triple that satisfies the problem.\n    */\n    n = n.minOf(min(n.divOf(3),\
    \ n.div", "{ \n    long count = 0;\n    long max_i = n / 3 + (n % 3 == 0 ? 0 :\
    \ 1);\n    foreach(i; 1 .. max_i) {\n        long i_sq = i * i;\n        long\
    \ j_val = i_sq + i;\n        long j_max = n - j_val;\n        long j_sq = (j_max\
    \ * j_max + j_max) / 2;\n        long j_max_plus = j_sq - j_val + 1;\n       \
    \ long max_k = (j_max_plus + j_val) / 3 + (j_max_plus + j_val) % 3 == 0 ? 0 :\
    \ 1;\n        count += j_max - max_k + 1;\n    }\n    return count;\n}", "{ \n\
    \    long count = 0;\n    foreach(i; 1 .. n)\n    {\n        foreach(j; i + 1\
    \ .. n)\n        {\n            foreach(k; j + 1 .. n)\n            {\n      \
    \          if ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0) \n  \
    \              {\n                    ++count;\n                }\n          \
    \  }\n        }\n    }\n    return count;\n}", "{\n    size_t count = 0;\n   \
    \ Tuple!(int, int, int)[n][n][n] triples;\n    for (size_t i = 0; i < n; i++)\n\
    \    {\n        for (size_t j = i + 1; j < n; j++)\n        {\n            for\
    \ (size_t k = j + 1; k < n; k++)\n            {\n                triples[i][j][k]\
    \ = tuple(i * i - i + 1, j * j - j + 1, k * k - k + 1);\n                if ((i\
    \ * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0) count++;\n          \
    \  }\n        }\n    }\n    return count;\n}", "{\n    long numTriples = 0;\n\
    \    long[] a;\n    bool isMultipleOf3 = false;\n    //create an integer array\
    \ a of length n.\n    //For each i (1 \u2264 i \u2264 n), the value of a[i] =\
    \ i * i - i + 1.\n    a = new long[n];\n    foreach(i; 0..n)\n    {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    //check for triples\n    foreach(i; 0..n)\n   \
    \ {\n        foreach(j; i+1..n)\n        {\n            foreach(k; j+1..n)\n \
    \           {\n                isMultipleOf3 = ((a[i] + a[j] + a[k]) % 3) == 0;\n\
    \                if(isMultipleOf3)\n                {\n                    numTriples++;\n\
    \                }\n            }\n        }\n    }\n    return numTriples;\n\
    }\n/*\n    tested with the following\n    assert(get_max_triples(5L) == 1L);\n\
    \    assert(get_max_triples(10L) == 11L);\n    assert(get_max_triples(15L) ==\
    \ 51L);\n    assert(get_max_triples(20L) == 121L);\n    assert(get_max_triples(50L)\
    \ == 2099L);\n    assert(get_max_triples(100L) == 6501L);\n    assert(get_max_triples(500L)\
    \ == 243401L);\n    assert(get_max_triples(1000L) == 564470L);\n    assert(get_max_triples(2000L)\
    \ == 2277404L);\n    assert(get_max_triples(5000L) == 21392563L);\n    assert(get_max_triples(10000L)\
    \ == 158418343L);\n    assert(get_max_triples(20000L) == 137372363L);\n    assert(get_max_triples(30000L)\
    \ == 113090920L);\n    assert(get_max_triples(40000L) == 97767", "{\n    long\
    \ triples = 0;\n    for (long i = 1; i < n; i++)\n    {\n        for (long j =\
    \ i + 1; j < n; j++)\n        {\n            for (long k = j + 1; k < n; k++)\n\
    \            {\n                if ( (i * i - i + 1 + j * j - j + 1 + k * k -\
    \ k + 1) % 3 == 0)\n                {\n                    triples++;\n      \
    \          }\n            }\n        }\n    }\n    return triples;\n}", "{\n \
    \   long count = 0;\n    foreach(immutable i; 1..n)\n    {\n        foreach(immutable\
    \ j; i..n)\n        {\n            foreach(immutable k; j..n)\n            {\n\
    \                if((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n\
    \                {\n                    ++count;\n                }\n        \
    \    }\n        }\n    }\n    return count;\n}", "{\n    long count = 0;\n   \
    \ long i = 0;\n    long j = 0;\n    long k = 0;\n    long sum = 0;\n    long a[n];\n\
    \    for (long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n  \
    \  for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n\
    \            for (long k = j + 1; k < n; k++) {\n                sum = a[i] +\
    \ a[j] + a[k];\n                if (sum % 3 == 0) {\n                    count++;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    long[] triplets = new long[n];\n    for (long i = 0; i < n; i++)\n    {\n\
    \        triplets[i] = (i * i) - i + 1;\n    }\n    long sum;\n    long count\
    \ = 0;\n    for (long i = 0; i < n; i++)\n    {\n        for (long j = i + 1;\
    \ j < n; j++)\n        {\n            for (long k = j + 1; k < n; k++)\n     \
    \       {\n                sum = triplets[i] + triplets[j] + triplets[k];\n  \
    \              if (sum % 3 == 0)\n                {\n                    count++;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    for (int i = 1; i < n - 1; i++)\n    {\n        for\
    \ (int j = i + 1; j < n; j++)\n        {\n            for (int k = j + 1; k <=\
    \ n; k++)\n            {\n                if ((i * i - i + 1 + j * j - j + 1 +\
    \ k * k - k + 1) % 3 == 0)\n                {\n                    count++;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    int res = 0;\n    for (int i = 0; i < n - 2; i++)\n    {\n        for (int\
    \ j = i + 1; j < n - 1; j++)\n        {\n            for (int k = j + 1; k < n;\
    \ k++)\n            {\n                long val = i * i - i + 1 + j * j - j +\
    \ 1 + k * k - k + 1;\n                if (val % 3 == 0)\n                    res++;\n\
    \            }\n        }\n    }\n    return res;\n}", "{\n    long[] a = new\
    \ long[cast(size_t)n];\n    foreach(i; 0..n)\n        a[i] = i * i - i + 1;\n\
    \    \n    long total_triples = 0;\n    for(long i = 0; i < n; i++) {\n      \
    \  for(long j = i + 1; j < n; j++) {\n            for(long k = j + 1; k < n; k++)\
    \ {\n                if(a[i] + a[j] + a[k] % 3 == 0) {\n                    total_triples++;\n\
    \                }\n            }\n        }\n    }\n    return total_triples;\n\
    }", "{\n    /*\n        n => 5\n        size(a) = 5\n        a[0] => 1\n     \
    \   a[1] => 3\n        a[2] => 7\n        a[3] => 13\n        a[4] => 21\n   \
    \     a[i] = i*i - i + 1\n        get range => [1, 3, 7, 13, 21]\n        i, j,\
    \ k => [1, 2, 3, 4]\n        check a[i] + a[j] + a[k] is multiple of 3\n     \
    \   i, j, k => 1,2,3 => 1 + 3 + 7 = 11\n        i, j, k => 1,2,4 => 1 + 3 + 13\
    \ = 17\n        i, j, k => 1,3,4 => 1 + 7 + 13 = 21\n        i, j, k => 2,3,4\
    \ => 3 + 7 + 13 = 23\n    */\n    long max_triples_count = 0;\n    long[] a =\
    \ new long[n];\n    // range(a) => [1, 3, 7, 13, 21]\n    a[0] = 1;\n    for (long\
    \ i = 1; i < n; i++)\n    {\n        a[i] = i * i - i + 1;\n    }\n    // a[i]\
    \ + a[j] + a[k]\n    for (long i = 0; i < n; i++)\n    {\n        for (long j\
    \ = i + 1; j < n; j++)\n        {\n            for (long k = j + 1; k < n; k++)\n\
    \            {\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\n         \
    \       {\n                    // cout(\"a[i] + a[j] + a[k] => \", a[i], \" +\
    \ \", a[j], \" + \", a[k], \" => \", a[i] + a[j] + a[k]);\n                  \
    \  max_triples_count++;\n                }\n            }\n        }\n    }\n\
    \    return max_triples_count;\n}", "{\n    long result = 0;\n    foreach(int\
    \ i; 2..n-1)\n    {\n        long j = i+1;\n        while(j <= n)\n        {\n\
    \            if( (i*i - i + 1 + j*j - j + 1) % 3 == 0 )\n            {\n     \
    \           long k = j+1;\n                while(k <= n)\n                {\n\
    \                    if( (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 )\n\
    \                    {\n                        result++;\n                  \
    \  }\n                    k++;\n                }\n            }\n           \
    \ j++;\n        }\n    }\n    return result;\n}", "{ \n    long result = 0;\n\
    \    for (long i = 0; i < n; i++)\n    {\n        for (long j = i + 1; j < n;\
    \ j++)\n        {\n            for (long k = j + 1; k < n; k++)\n            {\n\
    \                if (((i * i - i + 1) + (j * j - j + 1) + (k * k - k + 1)) % 3\
    \ == 0)\n                {\n                    result++;\n                }\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long a_size\
    \ = n;\n    // store your result in this variable\n    long result = 0;\n    /*\
    \ ************************* */\n    // your code here\n    if (n == 0) {return\
    \ 0;}\n    auto a = array(typeof(a_size), a_size);\n    for (int i = 0; i < n;\
    \ i++) {\n        a[i] = (i+1) * (i+1) - (i+1) + 1;\n    }\n    for (int i = 0;\
    \ i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            for\
    \ (int k = j+1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 ==\
    \ 0) {\n                    result++;\n                }\n            }\n    \
    \    }\n    }\n    /* ************************* */\n    return result;\n}", "{\n\
    \    // store in array\n    immutable long[] vals = new long[n];\n    long i =\
    \ 0;\n    foreach(x; 0..n)\n    {\n        vals[i] = i * i - i + 1;\n        i++;\n\
    \    }\n    // we need to find all combinations for a[i] + a[j] + a[k] = 3*n\n\
    \    long count = 0;\n    foreach(x; 1..n-2)\n    {\n        foreach(y; x+1..n-1)\n\
    \        {\n            foreach(z; y+1..n)\n            {\n                if\
    \ (vals[x] + vals[y] + vals[z] == 3*n)\n                {\n                  \
    \  count++;\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n    You are given an array of integers a.\n        For each i (1 \u2264\
    \ i \u2264 n), the value of a[i] must be in the range [-1, n-i].\n        You\
    \ need to find the total number of permutations of a, satisfying the above conditions.",
  "{\n    long result = 0;\n    long[] a = new long[n];\n    for (long i = 0; i <\
    \ n; i++) \n    {\n        a[i] = i * i - i + 1;\n    }\n    for (long i = 0;\
    \ i < n; i++) \n    {\n        for (long j = i + 1; j < n; j++) \n        {\n\
    \            for (long k = j + 1; k < n; k++) \n            {\n              \
    \  if ((a[i] + a[j] + a[k]) % 3 == 0) \n                {\n                  \
    \  result++;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n// ====", "{\n    auto a = array!long(n).init;\n    foreach(i, ref elem; a)\n\
    \    {\n        elem = i*i - i + 1;\n    }\n    long count = 0;\n    for(long\
    \ i = 0; i < n; i++)\n    {\n        for(long j = i+1; j < n; j++)\n        {\n\
    \            for(long k = j+1; k < n; k++)\n            {\n                if((a[i]\
    \ + a[j] + a[k]) % 3 == 0)\n                {\n                    count++;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    return n * (n - 1) * (n - 2) / 6L;\n}", "{\n    int[] a = new int[n];\n \
    \   for (int i = 0; i < n; i++)\n    {\n        a[i] = i * i - i + 1;\n    }\n\
    \    int count = 0;\n    for (int i = 0; i < n - 2; i++)\n    {\n        for (int\
    \ j = i + 1; j < n - 1; j++)\n        {\n            for (int k = j + 1; k < n;\
    \ k++)\n            {\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\n  \
    \              {\n                    count++;\n                }\n          \
    \  }\n        }\n    }\n    return count;\n}", "{\n    assert(n>0, \"n must be\
    \ a positive number\");\n    int sz = to!int(n);\n    auto a = new int[sz];\n\
    \    foreach(i;0..sz)\n    {\n        a[i] = i*i - i + 1;\n    }\n    long count\
    \ = 0;\n    for(int i = 0; i < sz-2; i++)\n    {\n        for(int j = i+1; j <\
    \ sz-1; j++)\n        {\n            for(int k = j+1; k < sz; k++)\n         \
    \   {\n                if((a[i] + a[j] + a[k]) % 3 == 0)\n                {\n\
    \                    count++;\n                }\n            }\n        }\n \
    \   }\n    return count;\n}", "{ \n    long max_triples = 0;\n    // Type-safety\
    \ is vital on this problem,\n    // so we create a TypeTuple of the type\n   \
    \ // we want to index our dynamic array with.\n    auto index_type = TypeTuple!(size_t);\n\
    \    // dynamic arrays can be used as a tuple,\n    // so we create one using\
    \ our type tuple\n    // to ensure index safety.\n    auto tuple = tuple(1, 3,\
    \ 7, 13, 21);\n    foreach(index_1; tuple.zip(index_type)[0 .. n])\n    {\n  \
    \      foreach(index_2; tuple.zip(index_type)[index_1 .. n])\n        {\n    \
    \        foreach(index_3; tuple.zip(index_type)[index_2 .. n])\n            {\n\
    \                if(\n                    (tuple[index_1] + tuple[index_2] + tuple[index_3])\
    \ % 3 == 0\n                )\n                {\n                    max_triples++;\n\
    \                }\n            }\n        }\n    }\n    return max_triples;\n\
    }", "{\n    long result = 0;\n    if (n < 3)\n        return result;\n    assert(n\
    \ > 0);\n    ulong[] a = new ulong[];\n    foreach (i; 0..n)\n        a ~= i *\
    \ i - i + 1;\n    foreach (i; 0..n)\n        foreach (j; i+1..n)\n           \
    \ foreach (k; j+1..n)\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\n  \
    \                  result++;\n    return result;\n}", "{\n    // Implicitly assume\
    \ the entire array is filled with 0's, which means there are no triples.\n   \
    \ // Count the number of triples that would be present with an array of length\
    \ n.\n    // How to increase the number of valid triples ?\n    // With each index,\
    \ increase their value by 1 until it would be non-zero if the sum is divisible\
    \ by 3.\n    long num_triples = 0L;\n    bool triple_possible = false;", "{\n\
    \    long res = 0;\n    for (long i = 1; i < n - 1; i++)\n    {\n        for (long\
    \ j = i + 1; j < n; j++)\n        {\n            for (long k = j + 1; k <= n;\
    \ k++)\n            {\n                if ((i * i - i + 1 + j * j - j + 1 + k\
    \ * k - k + 1) % 3 == 0)\n                {\n                    res++;\n    \
    \            }\n            }\n        }\n    }\n    return res;\n}", "{\n   \
    \ long cnt = 0;\n    for (long i = 1; i < n - 1; i++)\n    {\n        for (long\
    \ j = i + 1; j < n; j++)\n        {\n            for (long k = j + 1; k <= n;\
    \ k++)\n            {\n                if ((i * i - i + 1 + j * j - j + 1 + k\
    \ * k - k + 1) % 3 == 0)\n                {\n                    cnt++;\n    \
    \            }\n            }\n        }\n    }\n    return cnt;\n}", "{\n   \
    \ auto a = new int[n];\n    long count = 0;\n    for (long i = 0; i < n; i++)\n\
    \    {\n        a[i] = i * i - i + 1;\n    }\n    for (long i = 0; i < n; i++)\n\
    \    {\n        for (long j = i + 1; j < n; j++)\n        {\n            for (long\
    \ k = j + 1; k < n; k++)\n            {\n                if ((a[i] + a[j] + a[k])\
    \ % 3 == 0)\n                {\n                    count++;\n               \
    \ }\n            }\n        }\n    }\n    return count;\n}", "{\n    // Return\
    \ the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    // and\
    \ a[i] + a[j] + a[k] is a multiple of 3.\n    // Also, create a range array a\
    \ with the given conditions.\n    auto a = iota(1L, n).map!((x) => x * x - x +\
    \ 1L);\n    // Find the combinations that can be multiple of 3\n    // The combinations\
    \ are (3 numbers) with the condition: (i < j < k)\n    auto combinations = iota(0L,\
    \ n - 3L).cartesianProduct(iota(1L, n - 2L)).cartesianProduct(iota(2L, n - 1L))\n\
    \        .filter!((x) => (a[x[0][0]] + a[x[0][1]] + a[x[1]]) % 3L == 0L);\n  \
    \  // Return the length of the combinations\n    return combinations.length;\n\
    }", "{\n    long res = 0;\n    for (long i = 1; i < n - 1; i++)\n    {\n     \
    \   for (long j = i + 1; j < n; j++)\n        {\n            for (long k = j +\
    \ 1; k <= n; k++)\n            {\n                if (((i * i - i + 1) + (j *\
    \ j - j + 1) + (k * k - k + 1)) % 3 == 0)\n                {\n               \
    \     res++;\n                }\n            }\n        }\n    }\n    return res;\n\
    }", "{\n    long[] a = new long[n];\n    long result = 0;\n    for (long i = 0;\
    \ i < n; i++) \n    {\n        a[i] = i * i - i + 1;\n    }\n    /*\n        //This\
    \ is a possible solution.\n        for (long i = 0; i < n; i++) \n        {\n\
    \            for (long j = i + 1; j < n; j++) \n            {\n              \
    \  for (long k = j + 1; k < n; k++) \n                {\n                    if\
    \ ((a[i] + a[j] + a[k]) % 3 == 0) \n                    {\n                  \
    \      result++;\n                    }\n                }\n            }\n  \
    \      }\n    */\n    long sum = 0;\n    for (long i = 0; i < n; i++) \n    {\n\
    \        sum += a[i];\n        if (sum % 3 == 0) \n        {\n            result\
    \ += n - i - 1;\n        }\n    }\n    for (long i = 0; i < n; i++) \n    {\n\
    \        for (long j = i + 1; j < n; j++) \n        {\n            sum -= a[i];\n\
    \            if (sum % 3 == 0) \n            {\n                result += n -\
    \ j - 1;\n            }\n        }\n    }\n    return result;\n}", "{\n    long\
    \ sum,\n        res = 0L;\n    long[] a = new long[to!long(n)];\n    for (long\
    \ i = 0L; i < n; i++)\n    {\n        a[i] = i * i - i + 1L;\n    }\n    for (long\
    \ i = 0L; i < n - 2L; i++)\n    {\n        for (long j = i + 1L; j < n - 1L; j++)\n\
    \        {\n            for (long k = j + 1L; k < n; k++)\n            {\n   \
    \             sum = a[i] + a[j] + a[k];\n                if (sum % 3L == 0L)\n\
    \                {\n                    res++;\n                }\n          \
    \  }\n        }\n    }\n    return res;\n}\n/*\n    Tests\n*/\nunittest\n{\n \
    \   import std.stdio;\n    import std.string;\n    void assert_equal(long actual,\
    \ long expected)\n    {\n        if (actual != expected)\n        {\n        \
    \    writefln(\"Got %s, but expected %s\", actual, expected);\n            assert(0);\n\
    \        }\n    }\n    void run_tests()\n    {\n        writeln(\"Running tests...\"\
    );\n        writeln(\"\\n* Test 1\");\n        assert_equal(get_max_triples(5L),\
    \ 1L);\n        writeln(\"* Test 2\");\n        assert_equal(get_max_triples(2L),\
    \ 0L);\n        writeln(\"* Test 3\");\n        assert_equal(get_max_triples(10L),\
    \ 2L);\n        writeln(\"* Test 4\");\n        assert_equal(get_max_triples(7L),\
    \ 3L);\n        writeln(\"* Test 5\");\n        assert_equal(get_max_triples(50L),\
    \ 18L);\n        writeln(\"Done!\");\n    }\n    run_tests();\n}", "{\n    /*\n\
    \        I only found one approach to solve this problem in reasonable time:\n\
    \        Instead of explicitly constructing the array a and then iterating over\n\
    \        all triples of a, we can construct and count the valid triples \n   \
    \     directly. For each valid triple (i, j, k), where i < j < k, we have\n  \
    \      the following restrictions:", "{\n    import std.algorithm : equal;\n \
    \   long triples = 0;\n    long[] array = new long[n];\n    for (long i = 0; i\
    \ < n; i++)\n    {\n        array[i] = i * i - i + 1;\n    }\n    for (long i\
    \ = 0; i < n; i++)\n    {\n        for (long j = i+1; j < n; j++)\n        {\n\
    \            for (long k = j+1; k < n; k++)\n            {\n                if\
    \ ((array[i] + array[j] + array[k]) % 3 == 0)\n                {\n           \
    \         triples++;\n                }\n            }\n        }\n    }\n   \
    \ return triples;\n}", "{\n    // your code here\n    long cnt = 0;\n    for(long\
    \ i = 1; i < n; i++)\n    {\n        for(long j = i + 1; j < n; j++)\n       \
    \ {\n            for(long k = j + 1; k < n; k++)\n            {\n            \
    \    if((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n          \
    \      {\n                    cnt++;\n                }\n            }\n     \
    \   }\n    }\n    return cnt;\n}\n/*\n    You are given a positive integer n.\
    \ You have to create an integer array a of length n.\n        For each i (1 \u2264\
    \ i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of\
    \ triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k]\
    \ is a multiple of 3.", "{\n    /*\n        Sample Test Cases\n        >>> get_max_triples(0L)\n\
    \        0L\n        >>> get_max_triples(1L)\n        0L\n        >>> get_max_triples(2L)\n\
    \        0L\n        >>> get_max_triples(3L)\n        0L\n        >>> get_max_triples(4L)\n\
    \        0L\n        >>> get_max_triples(5L)\n        1L\n        >>> get_max_triples(6L)\n\
    \        0L\n        >>> get_max_triples(7L)\n        1L\n        >>> get_max_triples(8L)\n\
    \        0L\n        >>> get_max_triples(9L)\n        0L\n        >>> get_max_triples(10L)\n\
    \        0L\n        >>> get_max_triples(11L)\n        1L\n        >>> get_max_triples(12L)\n\
    \        0L\n        >>> get_max_triples(13L)\n        1L\n        >>> get_max_triples(14L)\n\
    \        0L\n        >>> get_max_triples(15L)\n        0L\n        >>> get_max_triples(16L)\n\
    \        0L\n        >>> get_max_triples(17L)\n        1L\n        >>> get_max_triples(18L)\n\
    \        0L\n        >>> get_max_triples(19L)\n        1L\n        >>> get_max_triples(20L)\n\
    \        0L\n        >>> get_max_triples(21L)\n        1L\n        >>> get_max_triples(22L)\n\
    \        0L\n        >>> get_max_triples(23L)\n        0L\n        >>> get_max_triples(24L)\n\
    \        0L\n        >>> get_max_triples(25L)\n        1L\n        >>> get_max_triples(26L)\n\
    \        0L\n        >>> get_max_triples(27L)\n        1L\n        >>> get_max_triples(28L)\n\
    \        0L\n        >>> get_max_triples", "{\n    long result = 0;\n    long[]\
    \ a = new long[n];\n    // int a_size = a.length;\n    for (int i = 0; i < n;\
    \ i++)\n    {\n        a[i] = i * i - i + 1;\n    }\n    foreach (i; 0 .. n)\n\
    \    {\n        foreach (j; 0 .. n)\n        {\n            foreach (k; 0 .. n)\n\
    \            {\n                if (i < j && j < k && ((a[i] + a[j] + a[k]) %\
    \ 3 == 0))\n                {\n                    result++;\n               \
    \ }\n            }\n        }\n    }\n    return result;\n}", "{\n    // A tuple(long,\
    \ long, long) is a struct with 3 long fields.\n    auto  result = tuple(0L, 0L,\
    \ 0L); //  number of triples, a[i], a[j]\n    auto  sum; \n    foreach(i; 1..n)\n\
    \    {\n        result[1] = i * i - i + 1;\n        foreach(j; i+1..n)\n     \
    \   {\n            result[2] = j * j - j + 1;\n            sum = result[1] + result[2];\
    \ \n            foreach(k; j+1..n)\n            {\n                if((sum + (k\
    \ * k - k + 1)) % 3 == 0) result[0]++;\n            }\n        }\n    }\n    return\
    \ result[0];\n}", "{\n    long[] a = new long[n];\n    foreach(i, ref elem; a)\n\
    \    {\n        elem = i * i - i + 1;\n    }\n    long count = 0;\n    foreach(i,\
    \ ref a_i; a)\n    {\n        if(i + 1 >= n)\n            break;\n        foreach(j,\
    \ ref a_j; a[i + 1 .. $])\n        {\n            if(j + 1 >= n)\n           \
    \     break;\n            foreach(k, ref a_k; a[j + 1 .. $])\n            {\n\
    \                if(a_i + a_j + a_k % 3 == 0)\n                    count++;\n\
    \            }\n        }\n    }\n    return count;\n}", "{\n    int result =\
    \ 0;\n    int [] a = new int[(cast(int)n)];\n    foreach(index, val; a)\n    {\n\
    \        a[index] = index * index - index + 1;\n    }\n    //writeln(a);\n   \
    \ foreach(i; 0 .. n)\n    {\n        foreach(j; i + 1 .. n)\n        {\n     \
    \       foreach(k; j + 1 .. n)\n            {\n                if(a[i] + a[j]\
    \ + a[k] % 3 == 0)\n                {\n                    result += 1;\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    size_t len = 3;\n    bool b = (n - 3) % 2;\n    if(b)\n        len += 1;\n\
    \    uint len_8 = len / 8;\n    if(len % 8)\n        len_8 += 1;\n    bool[] bytemask\
    \ = new bool[len_8];\n    bytemask[0] = true;\n    bytemask[1] = true;\n    if(b)\n\
    \        bytemask[2] = true;\n    bytemask[len_8 - 1] = true;\n    long x = 1;\n\
    \    long y = n - 2;\n    long sum = 3;\n    long triples = (n * (n - 1) * (n\
    \ - 2)) / 6;\n    while(x < y)\n    {\n        if(sum % 3 == 0)\n        {\n \
    \           triples -= ((y - x) * (y - x - 1)) / 2;\n            if(b)\n     \
    \           triples -= (y - x);\n        }\n        sum -= x;\n        sum +=\
    \ y;\n        x++;\n        y--;\n    }\n    return triples;\n}", "{\n    /*\n\
    \        i * i + i * i - i + 1 + i * i + i * i - i + 1\n        = 2 * i * i +\
    \ 2 * i - 2 + 1\n        = 2 * i * i + 2 * i - 1\n        = 2 * i * (i + 1) -\
    \ 1\n        = 2 * i * (i + 1) - 1\n    */\n    long nn = (n + 1) * (n + 1);\n\
    \    //printf(\"%s, %d, %s, %ld\\n\", __func__, __LINE__, \"nn\", nn);\n    if(nn\
    \ % 3 == 0){\n        return n;\n    }\n    return n - 1;\n}", "{\n    long result\
    \ = 0;\n    static int i = 1;\n    static int j = 2;\n    static int k = 3;\n\
    \    static int[] a = new int[n];\n    //fill array with elements\n    while(i\
    \ < n)\n    {\n        a[i] = (i * i) - i + 1;\n        i++;\n    }\n    //looks\
    \ for triples\n    while(j < n)\n    {\n        while(k < n)\n        {\n    \
    \        if((a[i] + a[j] + a[k]) % 3 == 0)\n            {\n                result++;\n\
    \            }\n            k++;\n        }\n        j++;\n    }\n    return result;\n\
    }\n//to test\nmain(string[] args) \n{\n    long n = 5L;\n    writefln(\"n: %s\"\
    , n);\n    writeln(\"result: \", get_max_triples(n));\n}", "{\n    long count\
    \ = 0;\n    for (long i = 0; i < n - 2; i++)\n    {\n        for (long j = i +\
    \ 1; j < n - 1; j++)\n        {\n            for (long k = j + 1; k < n; k++)\n\
    \            {\n                if ((i * i - i + 1 + j * j - j + 1 + k * k - k\
    \ + 1) % 3 == 0)\n                {\n                    count++;\n          \
    \      }\n            }\n        }\n    }\n    return count;\n}", "{\n    if (n\
    \ < 3) \n        return 0;\n    \n    /*\n        a[i] = i*i - i + 1\n       \
    \ a[i] % 3 == 0 iff n = 3*k iff (i*i - i + 1) % 3 == 0 iff i*i % 3 == 1 iff i*i\
    \ % 3 == 2 iff i = 3*k+1 or i = 3*k+2\n    */\n    long total = (n - 1) / 3 *\
    \ 2;", "{\n    long ret = 0L;\n    return ret;\n}", "{\n    long a = 0L;\n   \
    \ foreach(immutable i; 0 .. n)\n    {\n        foreach(immutable j; i+1 .. n)\n\
    \        {\n            foreach(immutable k; j+1 .. n)\n            {\n      \
    \          if(((i+1)*(i+1)-(i+1)+1 + (j+1)*(j+1)-(j+1)+1 + (k+1)*(k+1)-(k+1)+1)\
    \ % 3 == 0)\n                {\n                    ++a;\n                }\n\
    \            }\n        }\n    }\n    return a;\n}", "{\n    long[long] a = new\
    \ long[long];\n    long counter = 0;\n    // populate the array\n    foreach(i;\
    \ 0 .. n)\n    {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n   \
    \ // do the magic\n    foreach(i; 0 .. n)\n    {\n        foreach(j; i + 1 ..\
    \ n)\n        {\n            foreach(k; j + 1 .. n)\n            {\n         \
    \       if((a[i] + a[j] + a[k]) % 3 == 0)\n                {\n               \
    \     counter++;\n                }\n            }\n        }\n    }\n    return\
    \ counter;\n}", "{\n    assert(n > 0L);\n    n = n / 3L;\n    return n * (n +\
    \ 1L) / 2L;\n}\n/*\n    We have a sequence of integer numbers a1, a2, ..., an.\n\
    \        We consider a triple of indexes (i, j, k) valid if 1 \u2264 i < j < k\
    \ \u2264 n and ai < aj < ak.\n        Your task is to calculate the number of\
    \ valid triples.", "{\n    long res = 0;\n    for (long i = 1; i < n - 1; i++)\n\
    \    {\n        for (long j = i + 1; j < n; j++)\n        {\n            for (long\
    \ k = j + 1; k <= n; k++)\n            {\n                if ((i * i - i + 1 +\
    \ j * j - j + 1 + k * k - k + 1) % 3 == 0)\n                {\n              \
    \      res++;\n                }\n            }\n        }\n    }\n    return\
    \ res;\n}\n// Test", "{\n    long[] a = new long[cast(size_t)n];\n    long triple\
    \ = 0;\n    long sum = 0;\n    auto s = new SumType!(long, const(char)[])(\"sum\"\
    , \"num\");\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = (i + 1) *\
    \ (i + 1) - (i + 1) + 1;\n        sum = a[i] + sum;\n        if (sum % 3 == 0)\n\
    \        {\n            s.init!(long)(sum);\n            //writeln(s.sum);\n \
    \           triple++;\n        }\n    }\n    return triple;\n}", "{\n    auto\
    \ a = new int[](n);\n    long res = 0;\n    foreach(i; 0..n)\n    {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    foreach(i; 0..n-2)\n    {\n        foreach(j; i+1..n-1)\n\
    \        {\n            foreach(k; j+1..n)\n            {\n                if((a[i]\
    \ + a[j] + a[k]) % 3 == 0) res++;\n            }\n        }\n    }\n    return\
    \ res;\n}", "{\n    if (n<3)\n        return 0;\n    long ret=0;\n    size_t i,j,k;\n\
    \    int a[n];\n    foreach(i,a)\n        a[i]=i*i-i+1;\n    foreach(i,a)\n  \
    \      foreach(j,i+1,a)\n            foreach(k,j+1,a)\n                if((a[i]+a[j]+a[k])%3==0)\n\
    \                    ret++;\n    return ret;\n}", "{\n    long res = 0;\n    long\
    \ t1 = 0;\n    long t2 = 0;\n    long t3 = 0;\n    long t = 0;\n    t = 3;\n \
    \   long j = 2;\n    long k = 3;\n    while(t < n)\n    {\n        t1 = t2 = t3\
    \ = t;\n        res += (n - 1 - t) * (n - 2 - t) / 2;\n        while(t3 < n)\n\
    \        {\n            t3 += (j * j - j + 1);\n            ++j;\n        }\n\
    \        while(t2 < n)\n        {\n            t2 += (k * k - k + 1);\n      \
    \      ++k;\n        }\n        res -= (j - 2) * (k - 3);\n        t += (t * t\
    \ - t + 1);\n    }\n    return res;\n}", "{\n    long res=0;\n    foreach(immutable\
    \ i;0..n-2)\n    {\n        long ai=i*i-i+1;\n        foreach(immutable j;i+1..n-1)\n\
    \        {\n            long aj=j*j-j+1;\n            foreach(immutable k;j+1..n)\n\
    \            {\n                long ak=k*k-k+1;\n                if((ai+aj+ak)%3==0)\n\
    \                {\n                    res++;\n                }\n          \
    \  }\n        }\n    }\n    return res;\n}\n/*\n    Instead of using three loops\
    \ in your solution, use 2 loops, \n    and make them only go over the values they\
    \ have to go over. \n    For instance:\n*/\nlong get_max_triples_2(long n) \n\
    {\n    long res=0;\n    foreach(immutable i;0..n-2)\n    {\n        long ai=i*i-i+1;\n\
    \        foreach(immutable j;i+1..n-1)\n        {\n            long aj=j*j-j+1;\n\
    \            if((ai+aj)%3==0)\n            {\n                res+=n-j-1;\n  \
    \          }\n        }\n    }\n    return res;\n}\n/*\n    The array a can be\
    \ calculated in a couple of milliseconds. \n    Generating the array is not a\
    \ bottleneck. \n    The triple loops are. Instead of using three loops in your\
    \ solution, \n    use 2 loops, and make them only go over the values they have\
    \ to go over. \n    For instance:\n*/\nlong get_max_triples_3(long n) \n{\n  \
    \  long res=0;\n    foreach(immutable i;0..n-2)\n    {\n        long ai=i*i-i+1;\n\
    \        foreach(immutable j;i+1..n-1)\n        {\n            long aj=j*j-j+1;\n\
    \            if((ai+aj)%3==0)\n            {\n                res+=n-j-1;\n",
  "{\n    long sum = 0;\n    Tuple!(long,long,long)[] triples = [];\n    long t =\
    \ 1;\n    for(long i = 1; i < n; i++)\n    {\n        for(long j = i+1; j < n;\
    \ j++)\n        {\n            if(j - i > 1)\n            {\n                long\
    \ a = i * i - i + 1;\n                long b = j * j - j + 1;\n              \
    \  long c = (j-i) * (j-i) - (j-i) + 1;\n                if((a + b + c) % 3 ==\
    \ 0)\n                {\n                    triples ~= tuple(a,b,c);\n      \
    \              sum++;\n                }\n            }\n        }\n    }\n  \
    \  return sum;\n}", "{\n    long count = 0;\n    for (long i = 1; i < n - 1; i++)\n\
    \    {\n        auto a = i * i - i + 1;\n        for (long j = i + 1; j < n; j++)\n\
    \        {\n            auto b = j * j - j + 1;\n            for (long k = j +\
    \ 1; k <= n; k++)\n            {\n                auto c = k * k - k + 1;\n  \
    \              if ((a + b + c) % 3 == 0)\n                {\n                \
    \    count++;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}", "{\n    //  The sum of three consecutive numbers divisible by 3\n\
    \    //  => sum of the triple = n + n+1 + n+2 = 3n + 3\n    //\n    //  First\
    \ number in the triple: \n    //      n <= a[n] <= 3n - 3\n    //\n    //  Second\
    \ number in the triple:\n    //      n + 1 <= a[n+1] <= 3n - 2\n    // \n    //\
    \  Third number in the triple:\n    //      n + 2 <= a[n+2] <= 3n - 1\n    //\n\
    \    long sum = 0;\n    long val = 0;\n    long [long] map;\n    foreach(i; 1\
    \ .. n + 2)\n    {\n        val = i * i - i + 1;\n        if(i <= 3)\n       \
    \ {\n            map[val] = 1;\n        }\n        else\n        {\n         \
    \   if(val > 3*(i-2))\n            {\n                long diff = val - 3*(i-2);\n\
    \                auto key = map.keys.front;\n                map.remove(key);\n\
    \                sum += map[diff];\n            }\n            map[val] += 1;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long[] a = new long[n];\n    foreach(i;\
    \ 0..n)\n        a[i] = i * i - i + 1;\n    \n    int count = 0;\n    for(int\
    \ i = 0; i < n - 2; i++)\n        for(int j = i + 1; j < n - 1; j++)\n       \
    \     for(int k = j + 1; k < n; k++)\n                if((a[i] + a[j] + a[k])\
    \ % 3 == 0)\n                    count++;\n    return count;\n}", "{\n    size_t[]\
    \ a = new size_t[n];\n    size_t cnt = 0;\n    size_t tmp = 0;\n    for (size_t\
    \ i = 0; i < n; i++) {\n        a[i] = cast(size_t)(i * i - i + 1);\n    }\n \
    \   for (size_t i = 0; i < n - 2; i++) {\n        for (size_t j = i + 1; j < n\
    \ - 1; j++) {\n            for (size_t k = j + 1; k < n; k++) {\n            \
    \    tmp = a[i] + a[j] + a[k];\n                if (tmp % 3 == 0) {\n        \
    \            cnt++;\n                }\n            }\n        }\n    }\n    return\
    \ cast(long)cnt;\n}", "{\n    long[] arr = new long[(int)n];\n    for (int i =\
    \ 0; i < n; i++)\n    {\n        arr[i] = (i * i) - i + 1;\n    }\n    long counter\
    \ = 0;\n    for (int i = 0; i < n - 2; i++)\n    {\n        for (int j = i + 1;\
    \ j < n - 1; j++)\n        {\n            for (int k = j + 1; k < n; k++)\n  \
    \          {\n                if (arr[i] + arr[j] + arr[k] % 3 == 0)\n       \
    \         {\n                    ++counter;\n                }\n            }\n\
    \        }\n    }\n    return counter;\n}", "{\n    enum range = iota(n);\n  \
    \  int[int] a = 0;\n    foreach(i;range) \n    {\n        a[i] = (i*i)-i+1;\n\
    \    }\n    long counter = 0;\n    foreach(i;1..n-2) \n    {\n        foreach(j;i+1..n-1)\
    \ \n        {\n            foreach(k;j+1..n) \n            {\n               \
    \ if((a[i]+a[j]+a[k])%3==0) \n                {\n                    counter++;\n\
    \                }\n            }\n        }\n    }\n    return counter;\n}",
  "{\n    long a[n];\n    for (long i = 0; i < n; i++)\n        a[i] = i * i - i +\
    \ 1;\n    long count = 0;\n    for (long i = 0; i < n; i++)\n        for (long\
    \ j = i + 1; j < n; j++)\n            for (long k = j + 1; k < n; k++)\n     \
    \           if ((a[i] + a[j] + a[k]) % 3 == 0)\n                    count++;\n\
    \    return count;\n}\n/*\n    You are given an integer n. Create a 2-dimensional\
    \ array a of length n consisting of n rows, \n    where the element a[i][j] equals\
    \ i * j.\n        Return the sum of all elements of the array.", "{\n    long\
    \ result = 0;\n    long half = n/2;\n    long third = n/3;\n    long quarter =\
    \ n/4;\n    foreach(i;0..half)\n    {\n        result += half - i;\n        result\
    \ += third - i;\n        result += quarter - i;\n    }\n    return result;\n}",
  "{\n    /*\n        max possible number of triples is\n        (n - 2)(n - 1)(n\
    \ - 0) / 6", "{\n    if (n <= 3)\n        return 0;\n    \n    long triples =\
    \ 0;\n    long[] arr = new long[cast(size_t)n];\n    for (long i = 0; i < n; i++)\n\
    \        arr[i] = i * i - i + 1;\n    \n    for (long i = 0; i < n; i++)\n   \
    \ {\n        for (long j = i + 1; j < n; j++)\n        {\n            for (long\
    \ k = j + 1; k < n; k++)\n            {\n                if ((arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0)\n                    triples++;\n            }\n       \
    \ }\n    }\n    return triples;\n}", "{\n    // Write your code here\n    auto\
    \ a = new int[n];\n    foreach(i, a)\n        a[i] = i * i - i + 1;\n    long\
    \ res = 0;\n    for(int i = 0; i < n - 2; i++)\n        for(int j = i + 1; j <\
    \ n - 1; j++)\n            for(int k = j + 1; k < n; k++)\n                if(a[i]\
    \ + a[j] + a[k] % 3 == 0)\n                    res++;\n    return res;\n}", "{\n\
    \    long[] arr = new long[n];\n    long count = 0;\n    for (long i = 0; i <\
    \ n; i++)\n    {\n        arr[i] = i * i - i + 1;\n    }\n    foreach (i; 0..n\
    \ - 3)\n    {\n        foreach (j; i + 1..n - 2)\n        {\n            foreach\
    \ (k; j + 1..n - 1)\n            {\n                if ((arr[i] + arr[j] + arr[k])\
    \ % 3 == 0)\n                {\n                    count++;\n               \
    \ }\n            }\n        }\n    }\n    return count;\n}", "{\n    long[] arr\
    \ = new long[(int)n];\n    foreach(index, _; arr)\n    {\n        arr[index] =\
    \ index * index - index + 1;\n    }\n    long sum, counter = 0;\n    foreach(i,\
    \ _; arr)\n    {\n        foreach(j, _; arr[i+1..$])\n        {\n            foreach(k,\
    \ _; arr[j+1..$])\n            {\n                sum = arr[i] + arr[j] + arr[k];\n\
    \                if(sum % 3 == 0)\n                {\n                    counter++;\n\
    \                }\n            }\n        }\n    }\n    return counter;\n}",
  "{\n    long ret = 0L;\n    ulong uret = 0UL;\n    ulong[] ar1;\n    int[] ar2;\n\
    \    ar1.length = ar2.length = n;\n    for (int i = 0; i < n; i++) {\n       \
    \ ar1[i] = i * i - i + 1UL;\n        ar2[i] = (int)((ar1[i] + 1UL) % 3UL);\n \
    \   }\n    /*\n        ar2: [1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\
    \ 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2,\
    \ 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1,\
    \ 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\
    \ 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2,\
    \ 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1,\
    \ 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\
    \ 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0", "{\n\
    \    long[] a = new long[n];\n    long accum = 0;\n    a[0] = 1;\n    for (long\
    \ i = 1; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    for (long i\
    \ = 0; i < n - 2; i++) {\n        for (long j = i + 1; j < n - 1; j++) {\n   \
    \         for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j]\
    \ + a[k]) % 3 == 0) {\n                    accum++;\n                }\n     \
    \       }\n        }\n    }\n    return accum;\n}", "{\n    // step 1: put all\
    \ of the elements in the array\n    auto a = [1L..n].map!(i => i * i - i + 1);\n\
    \    auto result = 0L;\n    auto count = 0L;\n    auto mark = new bool[n];\n \
    \   foreach(i; a)\n    {\n        mark[i] = false;\n    }\n    for(int i = 0;\
    \ i < n - 2; i++)\n    {\n        for(int j = i + 1; j < n - 1; j++)\n       \
    \ {\n            for(int k = j + 1; k < n; k++)\n            {\n             \
    \   if((a[i] + a[j] + a[k]) % 3 == 0)\n                {\n                   \
    \ mark[i] = true;\n                    mark[j] = true;\n                    mark[k]\
    \ = true;\n                    count++;\n                }\n            }\n  \
    \      }\n    }\n    result = count;\n    return result;\n}", "{\n    long[] a\
    \ = new long[n];\n    foreach(idx, ref elem; a)\n    {\n        elem = idx * idx\
    \ - idx + 1;\n    }\n    long max_triples = 0;\n    foreach(i; 0 .. n)\n    {\n\
    \        foreach(j; i+1 .. n)\n        {\n            foreach(k; j+1 .. n)\n \
    \           {\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\n          \
    \      {\n                    max_triples++;\n                }\n            }\n\
    \        }\n    }\n    return max_triples;\n}", "{\n    long count = 0;\n    foreach(i,\
    \ j; chain(iota(n - 2), iota(1, n - 1)))\n    {\n        if((i * i - i + 1 + j\
    \ * j - j + 1) % 3 == 0)\n        {\n            auto max_k = n - 1 - j;\n   \
    \         auto min_k = j + 2;\n            auto k = max_k * max_k - max_k + 1;\n\
    \            if(k % 3 == 0)\n            {\n                count += max_k - min_k\
    \ + 1;\n            }\n            else if((j + 1) % 3 == 0)\n            {\n\
    \                count += (max_k - min_k) / 3 + 1;\n            }\n          \
    \  else\n            {\n                count += (max_k - min_k) / 3;\n      \
    \      }\n        }\n    }\n    return count;\n}", "{\n    //I know this can be\
    \ solved with one loop, but I would need to use more temporary variables\n   \
    \ //and I would like to check if the current number can be added to any of the\
    \ two previous to\n    //form a triple. It is easier with two loops.\n    //Considering\
    \ the fact that the array can be very large, I will use a tuple.\n    Tuple!(long,\
    \ long)[] tempArray;\n    foreach(long i; 0..n)\n    {\n        tempArray ~= tuple(i\
    \ * i - i + 1, 0);\n    }\n    //The value of the second element of the tuple\
    \ will tell me if the first element \n    //can be added to the previous element\
    \ of the array to form a triple.\n    //If it is greater than 0, then the first\
    \ element can be added to the first element\n    //of the previous triple.\n \
    \   //Else if it is equal to 0, then the first element cannot be added to any\
    \ previous\n    //triple.\n    //If it is less than 0, then the first element\
    \ can be added to the first element of\n    //the previous triple, and to the\
    \ first element of the triple before the previous\n    //triple.\n    long temp\
    \ = 0;\n    long counter = 0;\n    foreach(ref tuple e; tempArray)\n    {\n  \
    \      if(temp > 0)\n        {\n            if((e[0] + tempArray[temp - 1][0])\
    \ % 3 == 0)\n            {\n                e[1] = 1;\n                counter++;\n\
    \            }\n        }\n        else if(temp > 1)\n        {\n            if((e[0]\
    \ + tempArray[temp - 1][0] + tempArray[temp - 2][0]) % 3 == 0)\n            {\n\
    \                e[1] = -1;\n                counter++;\n            }\n     \
    \   }\n        temp++;\n    }\n    return counter;\n}", "{\n    long triples_count\
    \ = 0;\n    long[] a = new long[n];\n    for (long i = 0; i < n; i++) \n    {\n\
    \        a[i] = i * i - i + 1;\n    }\n    for (long i = 0; i < n; i++) \n   \
    \ {\n        for (long j = i + 1; j < n; j++) \n        {\n            for (long\
    \ k = j + 1; k < n; k++) \n            {\n                if ((a[i] + a[j] + a[k])\
    \ % 3 == 0) \n                {\n                    triples_count++;\n      \
    \          }\n            }\n        }\n    }\n    return triples_count;\n}",
  "{\n    if (n <= 2)\n        return 0;\n    auto a = new int[].init;\n    foreach\
    \ (index, _; 0 .. n)\n        a ~= index * index - index + 1;\n    long cnt =\
    \ 0;\n    foreach (i, ai; a)\n    {\n        if (ai % 3 == 0)\n        {\n   \
    \         cnt += n - i - 1;\n            continue;\n        }\n        if (ai\
    \ % 3 == 1)\n        {\n            auto rem_2 = std.algorithm.count(a[i + 1 ..\
    \ $], (e) => e % 3 == 2);\n            auto rem_1 = std.algorithm.count(a[i +\
    \ 1 .. $], (e) => e % 3 == 1);\n            auto rem_0 = std.algorithm.count(a[i\
    \ + 1 .. $], (e) => e % 3 == 0);\n            cnt += rem_2 + (rem_1 * (rem_1 -\
    \ 1) / 2) + rem_0;\n            continue;\n        }\n        if (ai % 3 == 2)\n\
    \        {\n            auto rem_1 = std.algorithm.count(a[i + 1 .. $], (e) =>\
    \ e % 3 == 1);\n            auto rem_0 = std.algorithm.count(a[i + 1 .. $], (e)\
    \ => e % 3 == 0);\n            cnt += rem_1 + rem_0;\n            continue;\n\
    \        }\n    }\n    return cnt;\n}", "{\n    static assert(n > 0L);\n    long[]\
    \ a = new long[n];\n    int j;\n    long sum = 0L;\n    for (int i = 0; i < n;\
    \ i++)\n    {\n        a[i] = (i * i) - i + 1;\n    }\n    for (int i = 0; i <\
    \ n - 2; i++)\n    {\n        for (j = i + 1; j < n - 1; j++)\n        {\n   \
    \         for (int k = j + 1; k < n; k++)\n            {\n                if (a[i]\
    \ + a[j] + a[k] % 3 == 0)\n                {\n                    sum++;\n   \
    \             }\n            }\n        }\n    }\n    return sum;\n}", "{\n  \
    \  if (n < 3) return 0;\n    return typeof(n)[] a = iota(n).map!(i => i * i -\
    \ i + 1).array;\n    long count = 0;\n    for (long i = 0; i < n - 2; i++)\n \
    \   {\n        for (long j = i + 1; j < n - 1; j++)\n        {\n            for\
    \ (long k = j + 1; k < n; k++)\n            {\n                if ((a[i] + a[j]\
    \ + a[k]) % 3 == 0)\n                {\n                    count++;\n       \
    \         }\n            }\n        }\n    }\n    return count;\n}", "{\n    long\
    \ r = 0;\n    int[] a = new int[n];\n    foreach(i; 0..n)\n    {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    foreach(i; 0..n-2)\n    {\n        foreach(j; i+1..n-1)\n\
    \        {\n            foreach(k; j+1..n)\n            {\n                if((a[i]\
    \ + a[j] + a[k]) % 3 == 0)\n                {\n                    r++;\n    \
    \            }\n            }\n        }\n    }\n    return r;\n}", "{\n    //\
    \ your code goes here\n    long count = 0;\n    for(long i = 1; i < n - 1; i++)\n\
    \    {\n        for(long j = i + 1; j < n; j++)\n        {\n            for(long\
    \ k = j + 1; k <= n; k++)\n            {\n                //printf(\"[%d, %d,\
    \ %d]\\n\", a[i], a[j], a[k]);\n                if(((i * i - i + 1) + (j * j -\
    \ j + 1) + (k * k - k + 1)) % 3 == 0)\n                {\n                   \
    \ //printf(\"[%d, %d, %d]\\n\", a[i], a[j], a[k]);\n                    count++;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    long[] a = new long[cast(int)n];\n    foreach(i, ref x; a)\n    {\n     \
    \   a[i] = i * i - i + 1;\n    }\n    long res = 0;\n    for(long i = 0; i < n\
    \ - 2; i++)\n    {\n        for(long j = i + 1; j < n - 1; j++)\n        {\n \
    \           for(long k = j + 1; k < n; k++)\n            {\n                if((a[i]\
    \ + a[j] + a[k]) % 3 == 0)\n                {\n                    res++;\n  \
    \              }\n            }\n        }\n    }\n    return res;\n}", "{\n \
    \   long[] a = new long[n];\n    for (long i = 0; i < n; i++) {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    long triples_sum = 0;\n    foreach (d; 0..n)\n\
    \    {\n        foreach (e; d..n)\n        {\n            foreach (f; e..n)\n\
    \            {\n                if (a[d] + a[e] + a[f] % 3 == 0) {\n         \
    \           triples_sum++;\n                }\n            }\n        }\n    }\n\
    \    return triples_sum;\n}", "{\n    long result = 0;\n    long prev_k_1 = 0;\n\
    \    long prev_k_2 = 0;\n    foreach(i; 1 .. n)\n    {\n        long a_i = i *\
    \ i - i + 1;\n        result += prev_k_1;\n        prev_k_1 += prev_k_2;\n   \
    \     prev_k_2 = (a_i % 3 == 0) ? prev_k_2 + 1 : prev_k_2;\n    }\n    return\
    \ result;\n}", "{\n    // a[i] = i * i - i + 1\n    return 0L;\n}", "{\n    long[]\
    \ a = new long[n];\n    foreach(int i, ref long e; a)\n    {\n        e = i *\
    \ i - i + 1;\n    }\n    long res = 0;\n    foreach(int i, int j, int k; iota(n\
    \ - 2))\n    {\n        if((a[i] + a[j] + a[k]) % 3 == 0)\n        {\n       \
    \     ++res;\n        }\n    }\n    return res;\n}", "{\n    /*\n        n = 2\
    \  \n            1 + 3 + 7\n            5 % 3 == 2\n        n = 3\n          \
    \  1 + 3 + 13\n            17 % 3 == 2\n        n = 4\n            1 + 3 + 21\n\
    \            25 % 3 == 1\n    */\n    alias T = Tuple!(long, long, long);\n  \
    \  // 1, 3, 7, 13, 21, 31, 43, 57, 73, 91, 111, 133, 157, 183, 211, 241, 273,\
    \ 307, 343, 381\n    // 1, 2, 4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 49, 56, 64,\
    \ 72, 81, 90, 100, 110, 121, 132, 144, 156, 169, 182, 196, 210, 225, 240, 256,\
    \ 272, 289, 306, 324, 342, 361, 380, 400\n    // 1, 2, 4, 6, 9, 12, 16, 20, 25,\
    \ 30, 36, 42, 49, 56, 64, 72, 81, 90, 100, 110, 121, 132, 144, 156, 169, 182,\
    \ 196, 210, 225, 240, 256, 272, 289, 306, 324, 342, 361, 380, 400, 421, 442, 464,\
    \ 486, 509, 532, 556, 580, 605, 630, 656, 682, 709, 736, 764, 792, 821, 850, 880,\
    \ 910, 941, 972, 1004, 1036, 1069, 1102, 1136, 1170, 1205, 1240, 1276, 1312, 1349,\
    \ 1386, 1424, 1462, 1501, 1540, 1580, 1620, 1661, 1702, 1744, 1786, 1829, 1872,\
    \ 1916, 1960, 2005, 2050, 2096, 2142, 2189, 2236, 2284, 2332, 2381, 2430, 2480,\
    \ 2530, 2581, 2632, 2684, 2736, 2789, 2842, 2896, 2950, 3005, 3060, 3116, 3172,\
    \ 3229, 3286, 3344, 3402, 3461, 3520, 35", "{\n    int count = 0;\n    for (int\
    \ i = 1; i < n; i++)\n    {\n        for (int j = i+1; j < n; j++)\n        {\n\
    \            for (int k = j+1; k < n; k++)\n            {\n                if\
    \ ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n               \
    \ {\n                    count++;\n                }\n            }\n        }\n\
    \    }\n    return count;\n}", "{\n    long maxTriples = 0;\n    for (long i =\
    \ 0; i < n; i++)\n    {\n        for (long j = i + 1; j < n; j++)\n        {\n\
    \            for (long k = j + 1; k < n; k++)\n            {\n               \
    \ if (((i*i - i + 1) + (j*j - j + 1) + (k*k - k + 1)) % 3 == 0)\n            \
    \    {\n                    maxTriples++;\n                }\n            }\n\
    \        }\n    }\n    return maxTriples;\n}", "{\n    if (n < 3)\n        return\
    \ 0;\n    // https://en.wikipedia.org/wiki/Partition_(number_theory)\n    long\
    \ m = (n - 1) / 2;\n    long s = n % 2 == 0 ? n / 2 : n / 2 + 1;\n    long res\
    \ = 0;\n    for (long i = m; i > s; i--)\n    {\n        long k = n - i;\n   \
    \     long x = ((2 * i - n) * (n - 1) - (i - 1) * i) / 6;\n        long y = ((2\
    \ * k - n) * (n - 1) - (k - 1) * k) / 6;\n        long z = (m * (m + 1) - s *\
    \ (s + 1)) / 6;\n        res += 3 * (x + y - z) + 2 * (i - k - 1);\n    }\n  \
    \  return res;\n}", "{\n    long[] a = new long[n];\n    long result = 0;\n  \
    \  foreach(ref i; 0 .. n)\n    {\n        a[i] = i * i - i + 1;\n    }\n    foreach(i;\
    \ 0 .. n)\n    {\n        foreach(j; i + 1 .. n)\n        {\n            foreach(k;\
    \ j + 1 .. n)\n            {\n                if((a[i] + a[j] + a[k]) % 3 == 0)\n\
    \                {\n                    result += 1;\n                }\n    \
    \        }\n        }\n    }\n    return result;\n}", "{\n    // 1 \u2264 n \u2264\
    \ 100000\n    assert(n >= 1L && n <= 100000L);\n    // 1 \u2264 a[i] \u2264 1000000000\n\
    \    assert(n*n - n + 1L >= 1L && n*n - n + 1L <= 1000000000L);\n    // Sum of\
    \ all a[i] \u2264 1000000000000000000.\n    assert(n*(n*n - n + 1L)/2 <= 1000000000000000000L);\n\
    \    auto a = new long[](n);\n    for (int i = 0; i < n; i++) {\n        a[i]\
    \ = i*i - i + 1L;\n    }\n    long sum = 0L;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1;\
    \ k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3L == 0L) {\n    \
    \                sum++;\n                }\n            }\n        }\n    }\n\
    \    return sum;\n}", "{\n    long counter = 0;\n    foreach(immutable i; 1..n-2)\n\
    \    {\n        foreach(immutable j; i+1..n-1)\n        {\n            foreach(immutable\
    \ k; j+1..n)\n            {\n                if((i*i - i + 1 + j*j - j + 1 + k*k\
    \ - k + 1) % 3 == 0)\n                {\n                    counter++;\n    \
    \            }\n            }\n        }\n    }\n    return counter;\n}", "{\n\
    \    long ret = 0L;\n    long[] arr = new long[n];\n    foreach(i; 0 .. n)\n \
    \   {\n        arr[i] = i * i - i + 1;\n    }\n    foreach(i; 0 .. n)\n    {\n\
    \        foreach(j; i+1 .. n)\n        {\n            foreach(k; j+1 .. n)\n \
    \           {\n                if((arr[i] + arr[j] + arr[k]) % 3 == 0)\n     \
    \           {\n                    ret++;\n                }\n            }\n\
    \        }\n    }\n    return ret;\n}", "{\n    long i, j, k, cnt = 0L;\n    long[n]\
    \ a;\n    foreach(i, j; zip(a, iota(n)))\n        a[j] = (i + 1L) * (i + 1L) -\
    \ (i + 1L) + 1L;\n    foreach(i; iota(n - 2L))\n        foreach(j; iota(i + 1L,\
    \ n - 1L))\n            foreach(k; iota(j + 1L, n))\n                if((a[i]\
    \ + a[j] + a[k]) % 3L == 0L)\n                    cnt++;\n    return cnt;\n}",
  "{\n    n--;\n    long n2 = n >> 1;\n    long n3 = n / 3;\n    long n5 = n / 5;\n\
    \    long n15 = n / 15;\n    long n2p = n2 * (n2 + 1) / 2;\n    long n3p = n3\
    \ * (n3 + 1) / 2;\n    long n5p = n5 * (n5 + 1) / 2;\n    long n15p = n15 * (n15\
    \ + 1) / 2;\n    long n30p = n15p;\n    return 3 * n2p * n3p - 3 * n2p * n5p -\
    \ 3 * n2p * n15p + 3 * n2p * n30p - n3p * n5p + 2 * n3p * n15p - n3p * n30p -\
    \ n5p * n15p + n5p * n30p + n15p * n30p;\n}\n/*\n    1L \n    Explanation: \n\
    \    a = [1, 3, 7, 13, 21]\n    The only valid triple is (1, 7, 13).\n*/", "{\n\
    \    long result = 0;\n    int[int] dict = new int[int];\n    int count = 0;\n\
    \    foreach(i; 1 .. n - 1)\n    {\n        foreach(j; i + 1 .. n)\n        {\n\
    \            foreach(k; j + 1 .. n + 1)\n            {\n                if((i\
    \ * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n                {\n\
    \                    dict[i]++;\n                    dict[j]++;\n            \
    \        dict[k]++;\n                    count++;\n                }\n       \
    \     }\n        }\n    }\n    foreach(key; keys(dict))\n    {\n        if(dict[key]\
    \ == count)\n        {\n            result++;\n        }\n    }\n    return result;\n\
    }", "{\n    // tests.addTest(new Test(n, 1L));\n    if (n < 3)\n        return\
    \ 0;\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n        a[i]\
    \ = i * i - i + 1;\n    int[] b = new int[n + 1];\n    int[] c = new int[n + 1];\n\
    \    for (int i = 0; i < n; i++)\n    {\n        b[i + 1] = b[i] + a[i];\n   \
    \     c[i + 1] = c[i] + (a[i] % 3);\n    }\n    // return tests.calculateAllTests();\n\
    \    long ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j\
    \ = i + 1; j < n; j++)\n        {\n            int s = c[n] - c[j] - (c[i] - c[0]);\n\
    \            int k = b[n] - b[j] - (b[i] - b[0]);\n            if (s == k)\n \
    \               ans++;\n        }\n    }\n    return ans;\n}", "{\n    long myTriples\
    \ = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    if (n > 0)\n    {\n\
    \        while (k < n)\n        {\n            i = 0;\n            j = i + 1;\n\
    \            k = j + 1;\n            while (j < n)\n            {\n          \
    \      while (k < n)\n                {\n                    long triple = (i\
    \ * i - i + 1) + (j * j - j + 1) + (k * k - k + 1);\n                    if (triple\
    \ % 3 == 0)\n                    {\n                        myTriples++;\n   \
    \                 }\n                    k++;\n                }\n           \
    \     j++;\n                k = j + 1;\n            }\n            i++;\n    \
    \    }\n    }\n    return myTriples;\n}", "{\n    long a[], count = 0L;\n    a.length\
    \ = n;\n    for (long i = 0L; i < n; i++)\n    {\n        a[i] = (i * i) - i +\
    \ 1L;\n    }\n    foreach (i, value_i; a)\n    {\n        foreach (j, value_j;\
    \ a[i..$])\n        {\n            foreach (k, value_k; a[j..$])\n           \
    \ {\n                if (value_i + value_j + value_k % 3L == 0L)\n           \
    \     {\n                    count++;\n                }\n            }\n    \
    \    }\n    }\n    return count / 3L;\n}", "{\n    long res = 0;\n    for (long\
    \ i = 1; i < n - 1; i++) \n    {\n        long start = i * i - i + 1;\n      \
    \  for (long j = i + 1; j < n; j++) \n        {\n            start += 2 * i +\
    \ 1;\n            long end = j * j - j + 1;\n            for (long k = j + 1;\
    \ k <= n; k++) \n            {\n                end += 2 * j + 1;\n          \
    \      if ((start + end) % 3 == 0) \n                {\n                    res++;\n\
    \                }\n            }\n        }\n    }\n    return res;\n}", "{\n\
    \    //ch\u1EC9 ch\u1EA1y \u0111\u1EBFn 2/3 s\u1ED1 l\u01B0\u1EE3ng m\u1EA3ng\
    \ v\xEC s\u1ED1 sau 2/3 ch\u1EAFc ch\u1EAFn\n    //d\u01B0 1 v\xE0 ch\u1EC9 ch\u1EA1\
    y i < j < k -> 1 < 2 < 3\n    long max = 0;\n    foreach(a; 0..(n / 3)) {\n  \
    \      foreach(b; (a + 1)..(n / 2)) {\n            foreach(c; (b + 1)..n) {\n\
    \                //\u0111\u1EC3 n\xF3 th\u1EF1c hi\u1EC7n nhanh h\u01A1n b\u1EB1\
    ng c\xE1ch ch\u1EC9 \u0111\u1EC3 c\u1ED9ng l\u1EA1i s\u1ED1 nguy\xEAn\n      \
    \          //ch\u1EE9 kh\xF4ng \u0111\u1EC3 gi\u1EA3i ph\u01B0\u01A1ng tr\xEC\
    nh nh\u01B0 b\xE0i tr\u01B0\u1EDBc\n                if((a * a - a + 1 + b * b\
    \ - b + 1 + c * c - c + 1) % 3 == 0) {\n                    ++max;\n         \
    \       }\n            }\n        }\n    }\n    return max;\n}", "{\n    long\
    \ count=0L;\n    for(long i=0L;i<n;i++)\n    {\n        for(long j=i+1L;j<n;j++)\n\
    \        {\n            for(long k=j+1L;k<n;k++)\n            {\n            \
    \    if(((i*i-i+1L)+(j*j-j+1L)+(k*k-k+1L))%3L==0L)\n                {\n      \
    \              count++;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}", "{\n    long result = 0;\n    long sum = 0;\n    long\
    \ a = 0;\n    long b = 0;\n    long c = 0;\n    for (long i = 0; i < n; i++)\n\
    \    {\n        a = i * i - i + 1;\n        for (long j = 0; j < n; j++)\n   \
    \     {\n            b = j * j - j + 1;\n            for (long k = 0; k < n; k++)\n\
    \            {\n                c = k * k - k + 1;\n                sum = a +\
    \ b + c;\n                if (sum % 3 == 0)\n                {\n             \
    \       result++;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    size_t[] a = new size_t[n];\n    auto count = 0L;\n   \
    \ foreach( i; 0..n )\n    {\n        a[i] = i * i - i + 1;\n    }\n    foreach(\
    \ i; 0..n-2 )\n    {\n        foreach( j; i+1..n-1 )\n        {\n            foreach(\
    \ k; j+1..n )\n            {\n                if( (a[i] + a[j] + a[k]) % 3 ==\
    \ 0 )\n                {\n                    count++;\n                }\n  \
    \          }\n        }\n    }\n    return count;\n}", "{\n    long ans = 0;\n\
    \    for (int i = 1; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n\
    \        {\n            for (int k = j + 1; k < n; k++)\n            {\n     \
    \           if ((j * j - j + 1 + k * k - k + 1 + i * i - i + 1) % 3 == 0)\n  \
    \              {\n                    ans++;\n                }\n            }\n\
    \        }\n    }\n    return ans;\n}\n// @exclude", "{\n    n = n == 0L ? 1L\
    \ : n;\n    long[] a = new long[n];\n    foreach(i, ref a_i; a)\n    {\n     \
    \   a_i = i * i - i + 1L;\n    }\n    long result = 0L;\n    foreach_reverse(i,\
    \ i_prev; a)\n    {\n        if (i <= 0L)\n        {\n            break;\n   \
    \     }\n        result += a[i_prev] / 3L;\n    }\n    return result;\n}", "{\n\
    \    static int count = 0;\n    static int how = 0;\n    static int size = 0;\n\
    \    static int index = 0;\n    static int sum = 0;\n    static int[] arr;\n \
    \   static int[] sum_arr;\n    static int[] multi_arr;\n    static tuple[] ans;\n\
    \    static tuple[] temp;\n    static int[] ret;\n    static int[] ret_sum;\n\
    \    static int[] ret_multi;\n    static tuple[] ret_tup;\n    static int ret_index\
    \ = 0;\n    static int max = 0;\n    static int mod = 0;\n    static int[] memo;\n\
    \    static int[] memo_index;\n    static int memo_index_index = 0;\n    static\
    \ int memo_index_index_index = 0;\n    static int memo_index_index_index_index\
    \ = 0;\n    static int memo_index_index_index_index_index = 0;\n    static int\
    \ first = 0;\n    static int second = 0;\n    static int third = 0;\n    static\
    \ int[] temp_ret;\n    static int[] temp_ans;\n    static int[] temp_ret_index;\n\
    \    static int count_ret = 0;\n    static int[] temp_arr;\n    static int temp_max\
    \ = 0;\n    static int temp_mod = 0;\n    static int[] temp_multi_arr;\n    static\
    \ int[] temp_sum_arr;\n    static int temp_sum = 0;\n    static tuple[] temp_tup;\n\
    \    static int temp_how = 0;\n    static int temp_count = 0;\n    static int\
    \ temp_count_ret = 0;\n    static int temp_ret_index = 0;\n    static int[] temp_ret_sum;\n\
    \    static int[] temp_ret_multi;\n    static int temp_multi = 0;\n    static\
    \ int temp_ret_multi_sum = 0;\n    static int ret_multi_sum = 0;\n    static int\
    \ temp_ret_sum_sum = 0;\n    static int ret_sum_sum = 0;\n    if (count == 0)\
    \ {\n        arr = new int[n];\n        sum_arr = new int[n];\n        multi",
  "{\n    long res = 0;\n    auto a = tuple(iota(n)).map!((long x) {return x * x -\
    \ x + 1;}).array;\n    // auto a = tuple(iota(n)).map!((long x) {return (x * x\
    \ - x + 1) % 3;}).array;\n    // auto a = tuple(iota(n)).map!((long x) {return\
    \ (x * x - x + 1) & 1;}).array;\n    // auto a = tuple(iota(n)).map!((long x)\
    \ {return (x * x - x + 1) % 4;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) / 3;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) % 5;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) / 7;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) % 8;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) % 10;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) % 12;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) % 16;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) % 20;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) % 27;}).array;\n    // auto a = tuple(iota(n)).map!((long\
    \ x) {return (x * x - x + 1) % 36;}).array;\n    // auto", "{\n    // setup\n\
    \    long i, j, k;\n    long triple_count = 0;\n    long[] a = new long[n];\n\
    \    // populate a\n    foreach(i; 0..n)\n    {\n        a[i] = i * i - i + 1;\n\
    \    }\n    // loop through a\n    foreach(i; 0..n)\n    {\n        foreach(j;\
    \ i..n)\n        {\n            foreach(k; j..n)\n            {\n            \
    \    if((a[i] + a[j] + a[k]) % 3 == 0)\n                {\n                  \
    \  triple_count += 1;\n                }\n            }\n        }\n    }\n  \
    \  return triple_count;\n}", "{\n    import std.algorithm : sum;\n    import std.array\
    \ : array;\n    import std.math : round;\n    import std.range : iota;\n    import\
    \ std.typecons : tuple;\n    import std.algorithm : map;\n    assert(n>0);\n \
    \   auto a = iota(n).map!(x => x*x-x+1).array;\n    long sum = 0;\n    foreach(i;iota(n-2))\n\
    \    {\n        foreach(j;iota(i+1,n-1))\n        {\n            foreach(k;iota(j+1,n))\n\
    \            {\n                long tmp = a[i]+a[j]+a[k];\n                if(tmp%3==0)\n\
    \                    sum+=1;\n            }\n        }\n    }\n    return sum;\n\
    }", "{\n    //auto [a, b, c] = tuple(1, 2, 3);\n    //static if (is(typeof({1,2,3})\
    \ == Tuple!(int, int, int)))\n    //    writeln(\"Tuple\");\n    //else\n    //\
    \    writeln(\"Not a Tuple\");\n    //assert(a == 1);\n    //assert(b == 2);\n\
    \    //assert(c == 3);\n    //static if (is(typeof({1,2,3}) == Tuple!(int, int,\
    \ int)))\n    //    writeln(\"Tuple\");\n    //else\n    //    writeln(\"Not a\
    \ Tuple\");\n    long arr[n];\n    long res = 0;\n    for (long i = 0; i < n;\
    \ i++)\n    {\n        arr[i] = i * i - i + 1;\n        //writeln(arr[i]);\n \
    \   }\n    for (long i = 0; i < n - 2; i++)\n    {\n        for (long j = i +\
    \ 1; j < n - 1; j++)\n        {\n            for (long k = j + 1; k < n; k++)\n\
    \            {\n                //assert(arr[i] + arr[j] + arr[k] == i * i - i\
    \ + 1 + j * j - j + 1 + k * k - k + 1);\n                if ((arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0)\n                {\n                    res++;\n       \
    \             //writeln(i, j, k);\n                }\n            }\n        }\n\
    \    }\n    return res;\n}", "{\n    //write your code here\n    long result =\
    \ 0;\n    bool[] a = new bool[n+1];\n    for(int i = 1; i < n+1; i++)\n    {\n\
    \        a[i] = true;\n    }\n    for(int i = 1; i < n+1; i++)\n    {\n      \
    \  for(int j = i+1; j < n+1; j++)\n        {\n            int remainder = (i*i-i+1\
    \ + j*j-j+1) % 3;\n            if(remainder == 0)\n            {\n           \
    \     a[j] = false;\n            }\n        }\n    }\n    for(int i = 1; i < n+1;\
    \ i++)\n    {\n        if(a[i])\n        {\n            result++;\n        }\n\
    \    }\n    return result;\n}", "{\n    if (n < 2) return 0;\n    long count =\
    \ 0;\n    immutable  uint a = (1,3,7,13,21);\n    //for (int i = 0; i < n; i++)\
    \ \n    //    a[i] = i * i - i + 1;\n    const uint sum = a[0] + a[1] + a[2];\n\
    \    int j = 2;\n    for (int i = 0; i < n; i++) \n    {\n        auto tmp = sum\
    \ - a[i];\n        for (uint k = j; k < n; k++) \n        {\n            if (tmp\
    \ + a[k] == 3) count++;\n            else if (tmp + a[k] < 3) break;\n       \
    \ }\n        if (i + 2 == j) j++;\n    }\n    return count;\n}", "{\n    enum\
    \ isMultipleOfThree = n => n % 3 == 0;\n    enum isValidPair(long[] a, long i,\
    \ long j)\n    {\n        return (1 < i < j < a.length) && isMultipleOfThree(a[i]\
    \ + a[j] + a[i+1]);\n    }\n    enum isValidTriple(long[] a, long i, long j, long\
    \ k)\n    {\n        return (1 < i < j < k < a.length) && isMultipleOfThree(a[i]\
    \ + a[j] + a[k]);\n    }\n    long[] values = iota(1L, n).map!(it => it * it -\
    \ it + 1).array;\n    long result = 0;\n    foreach(i; 0 .. n - 2)\n    {\n  \
    \      foreach(j; i + 1 .. n - 1)\n        {\n            if(isValidPair(values,\
    \ i, j))\n            {\n                ++result;\n            }\n        }\n\
    \    }\n    foreach(i; 0 .. n - 3)\n    {\n        foreach(j; i + 1 .. n - 2)\n\
    \        {\n            foreach(k; j + 1 .. n - 1)\n            {\n          \
    \      if(isValidTriple(values, i, j, k))\n                {\n               \
    \     ++result;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    if (n < 3)\n        return 0;\n    long result = (n - 2)\
    \ * (n - 1) * n / 3 / 2;\n    return result;\n}", "{\n    long[] a = new long[n];\n\
    \    foreach(i;0 .. n)\n    {\n        a[i] = i * i - i + 1;\n    }\n    return\
    \ a;\n}", "{\n    long result;\n    long i;\n    long j;\n    long[] a;\n    long[]\
    \ dp;\n    long[] prev;\n    long[] sum;\n    long[] next;\n    long tmp;\n  \
    \  a = (long[]) new int[(int)n];\n    foreach (idx; 0 .. n) {\n        a[idx]\
    \ = cast(long)(idx * idx - idx + 1);\n    }\n    dp = (long[]) new int[(int)n];\n\
    \    prev = (long[]) new int[(int)n];\n    sum = (long[]) new int[(int)n];\n \
    \   next = (long[]) new int[(int)n];\n    foreach (i; 0 .. n) {\n        prev[i]\
    \ = cast(long)(-1);\n        next[i] = cast(long)(-1);\n    }\n    foreach (i;\
    \ 0 .. n) {\n        foreach (j; i + 1 .. n) {\n            if (j > i + 1) {\n\
    \                tmp = cast(long)(a[i] + a[j] + a[j - 1]);\n                if\
    \ (tmp % 3L == 0L) {\n                    dp[j] = cast(long)(max(dp[j], 1L + dp[j\
    \ - 1]));\n                    if (prev[j] == -1L) {\n                       \
    \ prev[j] = i;\n                    }\n                }\n            }\n    \
    \        if (j < n - 1) {\n                tmp = cast(long)(a[i] + a[j] + a[j\
    \ + 1]);\n                if (tmp % 3L == 0L) {\n                    dp[j] = cast(long)(max(dp[j],\
    \ 1L + dp[j + 1]));\n                    if (next[j] == -1L) {\n             \
    \           next[j] = i;\n                    }\n                }\n         \
    \   }\n        }\n    }\n    result = cast(long)(0L);\n    foreach (i; 0 .. n)\
    \ {\n        sum[i] = cast(long)(dp[i]);\n        if (prev[i]", "{\n    // initialize\
    \ array\n    int[] a = new int[(int)n];\n    // populate array\n    foreach(i,\
    \ val; a)\n    {\n        val = i * i - i + 1;\n    }\n    // get all triples\n\
    \    alias Tuple!(int, int, int) triple;\n    auto triples = new triple[]((int)n);\n\
    \    foreach(i, j, k; 0 .. n)\n    {\n        // skip if sum is not divisible\
    \ by 3\n        if ((a[i] + a[j] + a[k]) % 3 != 0) continue;\n        triples\
    \ ~= triple(a[i], a[j], a[k]);\n    }\n    return triples.length;\n}", "{\n  \
    \  long c = 0;\n    foreach(int i; 0..n)\n    {\n        foreach(int j; i+1..n)\n\
    \        {\n            foreach(int k; j+1..n)\n            {\n              \
    \  if((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n            \
    \    {\n                    c++;\n                }\n            }\n        }\n\
    \    }\n    return c;\n}", "{\n    long cnt = 0;\n    for (long i = 0; i < n;\
    \ i++)\n    {\n        long a_i = i * i - i + 1;\n        for (long j = i + 1;\
    \ j < n; j++)\n        {\n            long a_j = j * j - j + 1;\n            for\
    \ (long k = j + 1; k < n; k++)\n            {\n                long a_k = k *\
    \ k - k + 1;\n                if ((a_i + a_j + a_k) % 3 == 0)\n              \
    \  {\n                    cnt++;\n                }\n            }\n        }\n\
    \    }\n    return cnt;\n}", "{\n    int result = 0;\n    for (int i = 1; i <\
    \ n - 1; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n   \
    \         for (int k = j + 1; k <= n; k++)\n            {\n                if\
    \ ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n               \
    \ {\n                    result++;\n                }\n            }\n       \
    \ }\n    }\n    return result;\n}", "{\n    long n_sqrt_3 = (long)ceil(pow(n,\
    \ 1.0/3.0));\n    long res = 0;\n    for (long i = 1; i <= n_sqrt_3; i++)\n  \
    \  {\n        long a = i * i - i + 1;\n        for (long j = i + 1; j <= n_sqrt_3;\
    \ j++)\n        {\n            long b = j * j - j + 1;\n            if ((a + b)\
    \ % 3 != 0)\n                continue;\n            auto k = 2.0 * (a + b) / 3\
    \ - i - j;\n            if (k <= n && k > j)\n                res++;\n       \
    \ }\n    }\n    return res;\n}", "{\n    // long total = 0;\n    // for (long\
    \ i = 1; i < n; i++) {\n    //     for (long j = i + 1; j < n; j++) {\n    //\
    \         if ((i * i - i + 1 + j * j - j + 1) % 3 == 0) {\n    //            \
    \ total++;\n    //         }\n    //     }\n    // }\n    // return total;\n \
    \   auto result = 0L;\n    auto n2 = n * n;\n    foreach (i; 1..n) {\n       \
    \ auto temp = n2 - i * i;\n        auto count = temp / (3 * i);\n        if (temp\
    \ % (3 * i) == 0) {\n            result += count;\n        }\n    }\n    return\
    \ result;\n}", "{\n    alias T = long;\n    long res = 0;\n    const long mod\
    \ = 3;\n    foreach(i, T; 0..n-2)\n    {\n        foreach(j, T; i+1..n-1)\n  \
    \      {\n            foreach(k, T; j+1..n)\n            {\n                if(((i+1)*(i+1)-(i+1)+1\
    \ + (j+1)*(j+1)-(j+1)+1 + (k+1)*(k+1)-(k+1)+1) % mod == 0)\n                {\n\
    \                    res++;\n                }\n            }\n        }\n   \
    \ }\n    return res;\n}", "{\n    if (n < 3)\n        return 0;\n    long count\
    \ = 0;\n    for (long i = 0; i < n - 2; i++)\n    {\n        for (long j = i +\
    \ 1; j < n - 1; j++)\n        {\n            for (long k = j + 1; k < n; k++)\n\
    \            {\n                if (((i * i - i + 1) + (j * j - j + 1) + (k *\
    \ k - k + 1)) % 3 == 0)\n                    count++;\n            }\n       \
    \ }\n    }\n    return count;\n}\n/*\n    First level of optimization: \n    Change\
    \ array to tuple.\n    Change i, j, k to uint, because array and tuple index can\
    \ be only positive.\n    For optimization you can use std.math.isMultiple.\n*/\n\
    long get_max_triples2(long n) \n{\n    if (n < 3)\n        return 0;\n    auto\
    \ a = tuple(iota(n).map!(x => x * x - x + 1));\n    long count = 0;\n    for (uint\
    \ i = 0; i < n - 2; i++)\n    {\n        for (uint j = i + 1; j < n - 1; j++)\n\
    \        {\n            for (uint k = j + 1; k < n; k++)\n            {\n    \
    \            if (isMultiple(a[i] + a[j] + a[k], 3))\n                    count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n    Second level of\
    \ optimization: \n    Use the fact that a[i] + a[j] + a[k] will only be a multiple\
    \ of 3 \n    if both of the following are true:\n        1. a[i] + a[j] is a multiple\
    \ of 3.\n        2. a[j] + a[k] is a multiple of 3.\n    So you can iterate through\
    \ the list of a, \n    and save each number with how many numbers before it are\
    \ multiples of 3.\n    Then for each a[i] you can calculate the number of k for\
    \ which a[i] + a[j] + a[k]", "{\n    long res=0L;\n    int mod3;\n    foreach(i;0..n)\n\
    \    {\n        mod3=cast(int)((i*i-i+1)%3);\n        res+=mod3==0?n-i-1:((n-i-1)/3)*2;\n\
    \    }\n    return res;\n}", "{\n    long[] a = new long[(int)n];\n    for (int\
    \ i = 0; i < n; i++) \n    {\n        a[i] = (i+1) * (i+1) - (i+1) + 1;\n    }\n\
    \    int count = 0;\n    for (int i = 0; i < n; i++) \n    {\n        for (int\
    \ j = i+1; j < n; j++) \n        {\n            for (int k = j+1; k < n; k++)\
    \ \n            {\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\n      \
    \              count++;\n            }\n        }\n    }\n    return count;\n}",
  "{\n    int mod = n % 3;\n    mod = n - mod;\n    long sum = n * n;\n    long res\
    \ = 0;\n    long a = n / 3;\n    long b = 2 * n / 3;\n    long c = n;\n    while\
    \ (mod >= 1)\n    {\n        if (a + b + c == sum && (a + b) % 3 == 0)\n     \
    \       res++;\n        a--;\n        b++;\n        c--;\n        mod -= 3;\n\
    \    }\n    return res;\n}", "{\n    long ret = 0;\n    auto a = new long[][]();\n\
    \    a = new long[][]();\n    a[0] = new long[]{1L, 3L, 7L, 13L, 21L};\n    a[1]\
    \ = new long[]{3L, 9L, 15L, 21L, 27L};\n    a[2] = new long[]{7L, 15L, 23L, 31L,\
    \ 39L};\n    a[3] = new long[]{13L, 21L, 31L, 41L, 51L};\n    a[4] = new long[]{21L,\
    \ 27L, 39L, 51L, 63L};\n    foreach (i; 1 .. n - 2L)\n    {\n        foreach (j;\
    \ i + 1L .. n - 1L)\n        {\n            foreach (k; j + 1L .. n)\n       \
    \     {\n                if ((a[i - 1L][j - i - 1L] + a[i - 1L][k - i - 1L] +\
    \ a[j - 1L][k - j - 1L]) % 3L == 0L)\n                {\n                    ret++;\n\
    \                }\n            }\n        }\n    }\n    return ret;\n}", "{\n\
    \    long[] a = new long[n];\n    foreach(i; 0..n)\n        a[i] = i * i - i +\
    \ 1;\n    long res = 0;\n    foreach(i; 1..n)\n        foreach(j; i+1..n)\n  \
    \          foreach(k; j+1..n)\n                if((a[i] + a[j] + a[k]) % 3 ==\
    \ 0) res++;\n    return res;\n}", "{\n    long result = 0;\n    long i = 0, j\
    \ = 0, k = 0;\n    //std.range.iota(1L, n+1) is [1L, 2L, 3L, 4L, 5L]\n    //std.algorithm.map\
    \ is to make a[] as [1, 3, 7, 13, 21]\n    //std.algorithm.array is to make a[]\
    \ as an array, not Range\n    int[] a = std.algorithm.array(std.algorithm.map!(d\
    \ => d*d - d + 1)(std.range.iota(1L, n+1)));\n    foreach(ref i; a)\n    {\n \
    \       foreach(ref j; a[i+1..$])\n        {\n            foreach(ref k; a[j+1..$])\n\
    \            {\n                if(i + j + k == 0)\n                {\n      \
    \              result++;\n                }\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    auto m3 = n / 3;\n    return (m3-1)*m3/2;\n}",
  "{\n    long ans = 0;\n    foreach(i, 1..n)\n    {\n        long b = i * i - i +\
    \ 1;\n        //printf(\"%ld \", b);\n        foreach(j, i + 1..n)\n        {\n\
    \            long c = j * j - j + 1;\n            //printf(\"(%ld, %ld) \", b,\
    \ c);\n            if((b + c) % 3 != 0) continue;\n            foreach(k, j +\
    \ 1..n)\n            {\n                long d = k * k - k + 1;\n            \
    \    //printf(\"[%ld, %ld, %ld] \", b, c, d);\n                if((b + c + d)\
    \ % 3 == 0) ans++;\n            }\n        }\n    }\n    return ans;\n}", "{\n\
    \    size_t result = 0;\n    if (n > 0)\n    {\n        // compute a[i]\n    \
    \    size_t* a = new size_t[n];\n        size_t* a_ = a;\n        size_t* a_end\
    \ = a + n;\n        size_t i = 1;\n        while (a_ != a_end)\n        {\n  \
    \          *a_ = i * i - i + 1;\n            ++a_;\n            ++i;\n       \
    \ }\n        /*\n        for (size_t* a_ = a; a_ != a_end; ++a_)\n        {\n\
    \            writeln(*a_);\n        }\n        */\n        // compute (a[i], a[j],\
    \ a[k]) for i < j < k\n        for (size_t i = 0; i < n - 2; ++i)\n        {\n\
    \            for (size_t j = i + 1; j < n - 1; ++j)\n            {\n         \
    \       for (size_t k = j + 1; k < n; ++k)\n                {\n              \
    \      if ((a[i] + a[j] + a[k]) % 3 == 0)\n                    {\n           \
    \             ++result;\n                    }\n                }\n          \
    \  }\n        }\n        // delete a[i]\n        delete[] a;\n    }\n    return\
    \ result;\n}\n/*\n    Get the maximum possible length of a subsequence such that\
    \ the sum of its elements is a multiple of M.", "{\n    int[] a = new int[cast(int)n];\n\
    \    long res = 0;\n    foreach(i; 0..cast(int)n)\n    {\n        a[i] = i * i\
    \ - i + 1;\n    }\n    foreach(i; 0..cast(int)n)\n    {\n        foreach(j; i+1..cast(int)n)\n\
    \        {\n            foreach(k; j+1..cast(int)n)\n            {\n         \
    \       if((a[i] + a[j] + a[k]) % 3 == 0)\n                {\n               \
    \     res++;\n                }\n            }\n        }\n    }\n    return res;\n\
    }", "{\n    long result = 0;\n    long[long] array;\n    long[long] triples;\n\
    \    long counter = 0;\n    foreach(i; 1..n+1)\n    {\n        array[i] = i*i\
    \ - i + 1;\n    }\n    foreach(i; 1..n+1)\n    {\n        foreach(j; i+1..n+1)\n\
    \        {\n            foreach(k; j+1..n+1)\n            {\n                if(array[i]\
    \ + array[j] + array[k] % 3 == 0)\n                {\n                    triples[counter]\
    \ = tuple(array[i], array[j], array[k]);\n                    ++counter;\n   \
    \             }\n            }\n        }\n    }\n    return counter;\n}", "{\n\
    \    long res = 0;\n    for (long i = 1; i < n - 1; i++) \n    {\n        for\
    \ (long j = i + 1; j < n; j++) \n        {\n            for (long k = j + 1; k\
    \ <= n; k++) \n            {\n                if ((i*i - i + 1 + j*j - j + 1 +\
    \ k*k - k + 1) % 3 == 0) \n                {\n                    res++;\n   \
    \             }\n            }\n        }\n    }\n    return res;\n}", "{\n  \
    \  long res = 0;\n    for (size_t i = 0; i < n; i++)\n    {\n        for (size_t\
    \ j = i + 1; j < n; j++)\n        {\n            for (size_t k = j + 1; k < n;\
    \ k++)\n            {\n                if ((i * i - i + 1 + j * j - j + 1 + k\
    \ * k - k + 1) % 3 == 0)\n                {\n                    res++;\n    \
    \            }\n            }\n        }\n    }\n    return res;\n}", "{\n\talias\
    \ array_type = int[];\n\tarray_type a;\n\tforeach(i; 0 .. n)\n\t{\n\t\ta ~= cast(int)(i\
    \ * i - i + 1);\n\t}\n\tlong result = 0;\n\tforeach(i; 0 .. a.length)\n\t{\n\t\
    \tforeach(j; i + 1 .. a.length)\n\t\t{\n\t\t\tforeach(k; j + 1 .. a.length)\n\t\
    \t\t{\n\t\t\t\tresult += (a[i] + a[j] + a[k]) % 3 == 0 ? 1 : 0;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn result;\n}", "{\n    \n    long[] a = new long[cast(size_t)n];\n\
    \    long[] b = new long[cast(size_t)n];\n    long[] c = new long[cast(size_t)n];\n\
    \    foreach(i, e; a)\n    {\n        a[i] = (i + 1L) * (i + 1L) - (i + 1L) +\
    \ 1L;\n    }\n    foreach(i, e; b)\n    {\n        b[i] = a[i] % 3L;\n    }\n\
    \    foreach(i, e; c)\n    {\n        c[i] = b[i] % 3L;\n    }\n    long[] d =\
    \ zip(b, c);\n    long count = 0L;\n    foreach(e; d)\n    {\n        tuple!(long,\
    \ long) tup = e;\n        long a1 = tup[0];\n        long a2 = tup[1];\n     \
    \   if (a1 + a2 == 0L)\n        {\n            count++;\n        }\n    }\n  \
    \  return count;\n    \n}", "{\n    // if (n == 1L) return 0L;\n    // else if\
    \ (n == 2L) return 0L;\n    // else if (n == 3L) return 1L;\n    // else if (n\
    \ == 4L) return 1L;\n    // else if (n == 5L) return 1L;\n    // else return n-3;\n\
    \    long count_triples = 0L;\n    long[] a = new long[n];\n    for (long i =\
    \ 0L; i < n; i++)\n    {\n        a[i] = i * i - i + 1;\n    }\n    for (long\
    \ i = 0L; i < n-2; i++)\n    {\n        for (long j = i+1; j < n-1; j++)\n   \
    \     {\n            for (long k = j+1; k < n; k++)\n            {\n         \
    \       if ((a[i] + a[j] + a[k]) % 3 == 0)\n                {\n              \
    \      count_triples++;\n                }\n            }\n        }\n    }\n\
    \    return count_triples;\n}", "{\n    if (n < 3) \n        return 0;\n    long\
    \ * a = new long[](n);\n    foreach (i, v; a)\n        v = (i+1) * (i+1) - (i+1)\
    \ + 1;\n    long cnt = 0;\n    for (size_t i = 0; i < n - 2; i++)\n        for\
    \ (size_t j = i + 1; j < n - 1; j++)\n            for (size_t k = j + 1; k < n;\
    \ k++)\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\n                 \
    \   cnt++;\n    return cnt;\n}", "{\n    import std.algorithm : filter, map, reduce;\n\
    \    long[long] a;\n    long[long] b;\n    long[long] c;\n    long[long] d;\n\
    \    long[long] e;\n    long[long] f;\n    long[long] g;\n    long[long] h;\n\
    \    long[long] i;\n    long[long] j;\n    long[long] k;\n    long[long] l;\n\
    \    long[long] m;\n    long[long] o;\n    long[long] p;\n    long[long] q;\n\
    \    long[long] r;\n    long[long] s;\n    long[long] t;\n    long[long] u;\n\
    \    long[long] v;\n    long[long] w;\n    long[long] x;\n    long[long] y;\n\
    \    long[long] z;\n    return a.length;\n}", "{\n    auto bs = map!(a => a *\
    \ a - a + 1, iota(1L, n + 1L));\n    long mult_3_cnt = 0L;\n    foreach(i; 0 ..\
    \ n)\n    {\n        foreach(j; i + 1 .. n)\n        {\n            foreach(k;\
    \ j + 1 .. n)\n            {\n                if ((bs[i] + bs[j] + bs[k]) % 3L\
    \ == 0L)\n                {\n                    mult_3_cnt++;\n             \
    \   }\n            }\n        }\n    }\n    return mult_3_cnt;\n}", "{\n    long\
    \ result = 0;\n    for (long i = 0; i < n; i++)\n    {\n        for (long j =\
    \ i + 1; j < n; j++)\n        {\n            for (long k = j + 1; k < n; k++)\n\
    \            {\n                if ((i * i - i + 1 + j * j - j + 1 + k * k - k\
    \ + 1) % 3 == 0)\n                {\n                    result++;\n         \
    \       }\n            }\n        }\n    }\n    return result;\n}", "{\n    enum\
    \ size_t count_for_triple = 0u;\n    //enum size_t [] data_array = new size_t[n];\n\
    \    auto data_array = new int[n];\n    foreach(i, index; 0 .. n) \n    {\n  \
    \      data_array[index] = (index + 1) * (index + 1) - (index + 1) + 1;\n    }\n\
    \    foreach(i, index; 0 .. n - 2) \n    {\n        foreach(j, index_inner; i\
    \ + 1 .. n - 1) \n        {\n            foreach(k, index_inner_2; j + 1 .. n)\
    \ \n            {\n                if( (data_array[index] + data_array[index_inner]\
    \ + data_array[index_inner_2]) % 3 == 0)\n                {\n                \
    \    count_for_triple++;\n                }\n            }\n        }\n    }\n\
    \    return cast(long)count_for_triple;\n}", "{\n    auto arr = new Tuple!(size_t,\
    \ size_t, size_t)[](n);\n    auto c = 0;\n    auto i = 1;\n    while(i <= n)\n\
    \    {\n        c += 1;\n        arr[i - 1] = tuple(i, i*i, i*i - i + 1);\n  \
    \      i += 1;\n    }\n    return cast(long)arr;\n}", "{\n    immutable int length\
    \ = cast(int)n;\n    auto a = new int[](length);\n    foreach(i; 0..length)\n\
    \    {\n        a[i] = i * i - i + 1;\n    }\n    int counter = 0;\n    //loop\
    \ three times.\n    foreach(i; 0..length)\n    {\n        foreach(j; i+1..length)\n\
    \        {\n            foreach(k; j+1..length)\n            {\n             \
    \   if((a[i] + a[j] + a[k]) % 3 == 0)\n                {\n                   \
    \ counter++;\n                }\n            }\n        }\n    }\n    return counter;\n\
    }", "{\n    long[long] arr;\n    foreach(i; 0..n)\n    {\n        long temp =\
    \ i * i - i + 1;\n        if(temp % 3 == 0)\n        {\n            arr[i] = temp;\n\
    \        }\n    }\n    // writeln(arr);\n    long l = arr.length;\n    long count\
    \ = 0;\n    foreach(i; 1..l-2)\n    {\n        foreach(j; i+1..l-1)\n        {\n\
    \            foreach(k; j+1..l)\n            {\n                if(arr[i] + arr[j]\
    \ + arr[k] == 0)\n                {\n                    count++;\n          \
    \      }\n            }\n        }\n    }\n    return count;\n}", "{ \n    long\
    \ sum = 0L;\n    for (int i = 1; i < n; i++) \n    { \n        for (int j = i\
    \ + 1; j < n; j++) \n        { \n            for (int k = j + 1; k < n; k++) \n\
    \            { \n                if ((i * i - i + 1 + j * j - j + 1 + k * k -\
    \ k + 1) % 3 == 0) \n                { \n                    ++sum; \n       \
    \         } \n            } \n        } \n    } \n    return sum; \n} ", "{\n\
    \     long i = 0L;\n     long j = 0L;\n     long k = 0L;\n     long result = 0L;\n\
    \     long r = 0L;\n     long test = 0L;\n     long[] a = null;\n     a = new\
    \ long[cast(size_t)n];\n     for (i = 0L; i < n; i++)\n     {\n         a[cast(size_t)i]\
    \ = i * i - i + 1L;\n     }\n     for (i = 0L; i < n; i++)\n     {\n         for\
    \ (j = i + 1L; j < n; j++)\n         {\n             for (k = j + 1L; k < n; k++)\n\
    \             {\n                 test = a[cast(size_t)i] + a[cast(size_t)j] +\
    \ a[cast(size_t)k];\n                 if (test % 3L == 0L)\n                 {\n\
    \                     result += 1L;\n                 }\n             }\n    \
    \     }\n     }\n     return result;\n}", "{\n    return n*(n-1)*(n-2)/6;\n}",
  "{\n    enum is_valid_triple = \n        mixin(\"return \" ~ \"a[i] + a[j] + a[k]\"\
    ) % 3L == 0L;\n    //@assert(mixin(\"return \" ~ \"1 + 2 + 3\") % 3L == 0L);"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
