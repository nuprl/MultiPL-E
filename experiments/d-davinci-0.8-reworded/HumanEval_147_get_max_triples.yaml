name: HumanEval_147_get_max_triples
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a positive\
  \ integer n. You have to create an integer array a of length n.\n        For each\
  \ i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the\
  \ number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j]\
  \ + a[k] is a multiple of 3.\n\n    Example :\n    >>> get_max_triples(5L)\n   \
  \ 1L\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid\
  \ triple is (1, 7, 13).\n    \n*/\nlong get_max_triples(long n) \n"
tests: "unittest\n{\n    alias candidate = get_max_triples;\n\n    assert(candidate(5L)\
  \ == 1L);\n    assert(candidate(6L) == 4L);\n    assert(candidate(10L) == 36L);\n\
  \    assert(candidate(100L) == 53361L);\n}\nvoid main(){}"
completions: ["{\n    auto l = new long[](n);\n    long cnt = 0;\n    foreach(i, l)\n\
    \    {\n        l[i] = i * i - i + 1;\n    }\n    foreach(i, l)\n    {\n     \
    \   foreach(j, l[i + 1 .. $])\n        {\n            foreach(k, l[j + 1 .. $])\n\
    \            {\n                if((l[i] + l[j] + l[k]) % 3 == 0)\n          \
    \      {\n                    ++cnt;\n                }\n            }\n     \
    \   }\n    }\n    return cnt;\n}", "{\n    auto arr = appender!(long[])();\n \
    \   long i;\n    for (i = 1; i <= n; i++) \n    {\n        arr.put(i * i - i +\
    \ 1);\n    }\n    long num_triples = 0;\n    for (i = 0; i < n; i++) \n    {\n\
    \        for (long j = i + 1; j < n; j++) \n        {\n            for (long k\
    \ = j + 1; k < n; k++) \n            {\n                if ((arr[i] + arr[j] +\
    \ arr[k]) % 3 == 0) \n                {\n                    num_triples++;\n\
    \                }\n            }\n        }\n    }\n    return num_triples;\n\
    }", "{\n    int[] a = new int[n];\n    int count = 0;\n    foreach(idx, i; a)\n\
    \    {\n        a[idx] = i * i - i + 1;\n    }\n    foreach(i; a)\n    {\n   \
    \     foreach(j; a[i + 1 .. $])\n        {\n            foreach(k; a[j + 1 ..\
    \ $])\n            {\n                if((i + j + k) % 3 == 0)\n             \
    \   {\n                    count++;\n                }\n            }\n      \
    \  }\n    }\n    return count;\n}\n/*\n    The order of the Fibonacci sequence\
    \ is a row of numbers where every number is the sum of the two numbers directly\
    \ before it.\n    Your task is to write a function that takes in an integer, n,\
    \ and returns the nth number of the Fibonacci sequence.\n    Example:\n    >>>\
    \ get_fibonacci(1)\n    1\n    >>> get_fibonacci(2)\n    1\n    >>> get_fibonacci(8)\n\
    \    21\n    >>> get_fibonacci(0)\n    -1\n*/", "{\n    // create vector based\
    \ on n\n    auto size = n as int;\n    auto a = new int[](size);\n    // fill\
    \ vector\n    foreach(i, ref item; a)\n    {\n        item = i * i - i + 1;\n\
    \    }\n    // print vector\n    foreach(i, ref item; a)\n    {\n        writeln(item);\n\
    \    }\n    return 0L;\n}", "{\n    long[] a = new long[n];\n    long triple_cnt\
    \ = 0;\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = i * i - i + 1;\n\
    \    }\n    for (int i = 0; i < n - 2; i++)\n    {\n        for (int j = i + 1;\
    \ j < n - 1; j++)\n        {\n            for (int k = j + 1; k < n; k++)\n  \
    \          {\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\n           \
    \     {\n                    triple_cnt++;\n                }\n            }\n\
    \        }\n    }\n    return triple_cnt;\n}\n// Test #1\nimport testlib.checker.Checker;\n\
    import testlib.checker.StringUtils;\nimport testlib.checker.StringWrapper;", "{\n\
    \    // Write your code here\n    long[] a = new long[(int)n];\n    foreach(i;\
    \ 0 .. n)\n    {\n        a[i] = i * i - i + 1;\n    }\n    long result = 0;\n\
    \    foreach(i; 0 .. n)\n    {\n        foreach(j; i+1 .. n)\n        {\n    \
    \        foreach(k; j+1 .. n)\n            {\n                if(a[i] + a[j] +\
    \ a[k] % 3 == 0)\n                {\n                    result++;\n         \
    \       }\n            }\n        }\n    }\n    return result;\n}", "{\n    long\
    \ counter=0L;\n    for(long i=1L;i<n;i++)\n    {\n        for(long j=i+1L;j<n;j++)\n\
    \        {\n            for(long k=j+1L;k<n;k++)\n            {\n            \
    \    if((i*i-i+1L+j*j-j+1L+k*k-k+1L)%3L==0L)\n                {\n            \
    \        counter++;\n                }\n            }\n        }\n    }\n    return\
    \ counter;\n}", "{\n    long res = 0;\n    foreach(size_t i; 0 .. n - 2)\n   \
    \ {\n        foreach(size_t j; i + 1 .. n - 1)\n        {\n            foreach(size_t\
    \ k; j + 1 .. n)\n            {\n                if(i*i - i + 1 + j*j - j + 1\
    \ + k*k - k + 1 % 3 == 0)\n                {\n                    res++;\n   \
    \             }\n            }\n        }\n    }\n    return res;\n}", "{\n  \
    \  long ret = 0;\n    long ai = 0;\n    long aj = 0;\n    long ak = 0;\n    foreach(i;\
    \ 1..n)\n    {\n        ai = i * i - i + 1;\n        foreach(j; (i + 1)..n)\n\
    \        {\n            aj = j * j - j + 1;\n            foreach(k; (j + 1)..n)\n\
    \            {\n                ak = k * k - k + 1;\n                if((ai +\
    \ aj + ak) % 3 == 0)\n                {\n                    ret++;\n        \
    \        }\n            }\n        }\n    }\n    return ret;\n}\n/*\n    TEST\n\
    */\nimport std.stdio;", "{\n    long total = 0;\n    for (long i = 0; i < n; i++)\n\
    \    {\n        for (long j = i + 1; j < n; j++)\n        {\n            for (long\
    \ k = j + 1; k < n; k++)\n            {\n                long v1 = (i + 1) * (i\
    \ + 1) - (i + 1) + 1;\n                long v2 = (j + 1) * (j + 1) - (j + 1) +\
    \ 1;\n                long v3 = (k + 1) * (k + 1) - (k + 1) + 1;\n           \
    \     if ((v1 + v2 + v3) % 3 == 0)\n                {\n                    total++;\n\
    \                }\n            }\n        }\n    }\n    return total;\n}", "{\n\
    \    enum num = ctfe(3);\n    long[] a = new long[n];\n    foreach(int i, ref\
    \ el; a)\n    {\n        el = i * i - i + 1;\n    }\n    long count = 0;\n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n\
    \        {\n            for(int k = j + 1; k < n; k++)\n            {\n      \
    \          if((a[i] + a[j] + a[k]) % num == 0)\n                {\n          \
    \          count++;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}", "{\n    long[] a = new long[int(n)];\n    long count = 0;\n    foreach(i;\
    \ 0..n)\n    {\n        a[i] = i * i - i + 1;\n    }\n    foreach(i; 0..n)\n \
    \   {\n        foreach(j; i+1..n)\n        {\n            foreach(k; j+1..n)\n\
    \            {\n                if((a[i] + a[j] + a[k]) % 3 == 0)\n          \
    \      {\n                    ++count;\n                }\n            }\n   \
    \     }\n    }\n    return count;\n}\n/*\n    We will call the num_vertices function\
    \ on the tree t and the number n. \n    It should return the number of vertices\
    \ that are located at a distance less than or equal to n from the root.\n*/",
  "{\n    long result = 0;\n    // for (i in 1..n)\n    for (long i = 1; i <= n; i++)\n\
    \    {\n        long a_i = i * i - i + 1;\n        // for (j in i + 1..n)\n  \
    \      for (long j = i + 1; j <= n; j++)\n        {\n            long a_j = j\
    \ * j - j + 1;\n            // for (k in j + 1..n)\n            for (long k =\
    \ j + 1; k <= n; k++)\n            {\n                long a_k = k * k - k + 1;\n\
    \                // if (a_i + a_j + a_k) % 3 == 0\n                if ((a_i +\
    \ a_j + a_k) % 3 == 0)\n                {\n                    // result += 1\n\
    \                    result += 1;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    long count = 0;\n    long mod_sum;\n \
    \   for (long a = 1; a < n - 1; a++)\n    {\n        for (long b = a + 1; b <\
    \ n; b++)\n        {\n            mod_sum = (a * a - a + 1) + (b * b - b + 1);\n\
    \            for (long c = b + 1; c <= n; c++)\n            {\n              \
    \  mod_sum += (c * c - c + 1);\n                if (mod_sum % 3 == 0)\n      \
    \          {\n                    count++;\n                }\n            }\n\
    \        }\n    }\n    return count;\n}", "{\n    long t = 0;\n    long hl = (n\
    \ - 1) / 2;\n    foreach(idx, item; iota(1L, n + 1L)) \n    {\n        auto v\
    \ = item * item - item + 1;\n        if (v % 3 == 0) \n        {\n           \
    \ auto x = (hl + 1) / item;\n            auto c = idx - hl;\n            auto\
    \ d = n - idx;\n            if (c >= 0 && d >= 0) \n            {\n          \
    \      t += x * c + x * d - x * x;\n            }\n        }\n    }\n    return\
    \ t;\n}", "{\n    return (n * (n - 1) * (n - 2)) / 6;\n}", "{\n    long[] a =\
    \ new long[n];\n    foreach(i, ref e; a)\n    {\n        e = i * i - i + 1;\n\
    \    }\n    long counter = 0;\n    for(long i = 0; i < n; i++)\n    {\n      \
    \  for(long j = i + 1; j < n; j++)\n        {\n            for(long k = j + 1;\
    \ k < n; k++)\n            {\n                if((a[i] + a[j] + a[k]) % 3 == 0)\n\
    \                {\n                    counter++;\n                }\n      \
    \      }\n        }\n    }\n    return counter;\n}", "{\n    long[] a = new long[to!int(n)];\n\
    \    long r=0;\n    for(long i=0;i<n;i++)\n    {\n        a[i]=i*i-i+1;\n    \
    \    if(i>1)\n        {\n            for(long j=i-1;j>0;j--)\n            {\n\
    \                if((a[i]+a[j])%3==0)\n                {\n                   \
    \ for(long k=j-1;k>=0;k--)\n                    {\n                        if((a[i]+a[j]+a[k])%3==0)\n\
    \                        {\n                            r++;\n               \
    \         }\n                    }\n                }\n            }\n       \
    \ }\n    }\n    return r;\n}", "{\n    long[long] a;\n    a[0] = 1;\n    for (long\
    \ i = 1; i < n; i++) \n    {\n        a[i] = a[i - 1] + (2 * i + 1);\n    }\n\
    \    long cnt = 0;\n    for (long i = 0; i < n - 2; i++) \n    {\n        for\
    \ (long j = i + 1; j < n - 1; j++) \n        {\n            long psum = a[i] +\
    \ a[j];\n            if (psum % 3 == 0) \n            {\n                long\
    \ rem = psum / 3;\n                auto m = std.algorithm.lower_bound(a, i + 1,\
    \ n, rem);\n                if (m != n && *m == rem) \n                {\n   \
    \                 cnt++;\n                }\n            }\n        }\n    }\n\
    \    return cnt;\n}\nlong calculateMultiplicativePersistence(long n)\n{\n\tif\
    \ (n < 10) return 0;\n\tauto p = n.to!string.reduce!((a, b) => a * b).to!long;\n\
    \treturn 1 + calculateMultiplicativePersistence(p);\n}", "{\n    long count=0L;\n\
    \    if(n==0L)\n        return 0L;\n    if(n<=3L)\n        return 0L;\n    if(n<=5L)\n\
    \        return 1L;\n    foreach(i;1L..n)\n    {\n        foreach(j;i+1L..n)\n\
    \        {\n            foreach(k;j+1L..n)\n            {\n                if((i*i-i+1L+j*j-j+1L+k*k-k+1L)%3L==0L)\n\
    \                    count++;\n            }\n        }\n    }\n    return count;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
