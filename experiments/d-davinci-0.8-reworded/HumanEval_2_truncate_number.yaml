name: HumanEval_2_truncate_number
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating point\
  \ number, it can be decomposed into\n    and integer part (largest integer smaller\
  \ than given number) and decimals\n    (leftover part always smaller than 1).\n\n\
  \    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n\
  \    \n*/\nfloat truncate_number(float number) \n"
tests: "unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
  \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) ==\
  \ 0.0);\n}\nvoid main(){}"
completions: ["{\n  float result;\n  double int_part;\n  result = modf(number, &int_part);\n\
    \  return result;\n}", "{\n  return number - cast(int)number;\n}", "{\n    //\
    \ an alias for `std.math.floor`\n    return number - floor(number);\n}", "{\n\
    \    return number - cast(int)number;\n}\n/*\nGiven a binary number represented\
    \ by a string, return the decimal value.\n    >>> parse_binary(\"101010\")\n \
    \   42\n*/", "{\n    return number % 1;\n}", "{\n    // here we use tuple to unpack\
    \ the value returned by split_floats()\n    // see http://dlang.org/phobos/std_typecons.html#.split_floats\n\
    \    int integerPart;\n    float decimalPart;\n    tie(integerPart, decimalPart)\
    \ = split_floats(number);\n    return decimalPart;\n}", "{\n    return number\
    \ - cast(int)number;\n}", "{\n    return number - cast(int)number;\n}", "{\n \
    \   return number % cast(int)number;\n}", "{\n    //TODO: your code here\n}\n\
    // Uncomment to run the truncate_number unit test\n//unittest\n{\n    // Decimal\
    \ part of a number\n    assert(truncate_number(4.4) == 0.4);\n    assert(truncate_number(4.5)\
    \ == 0.5);\n    assert(truncate_number(4.6) == 0.6);\n    \n    // No decimal\
    \ part of a number\n    assert(truncate_number(10) == 0);\n    assert(truncate_number(10.0)\
    \ == 0);\n    \n    // Positive integer with decimal part\n    assert(truncate_number(3.1)\
    \ == 0.1);\n    assert(truncate_number(3.5) == 0.5);\n    assert(truncate_number(3.9)\
    \ == 0.9);\n    \n    // Negative integer with decimal part\n    assert(truncate_number(-3.1)\
    \ == 0.9);\n    assert(truncate_number(-3.5) == 0.5);\n    assert(truncate_number(-3.9)\
    \ == 0.1);\n    \n    // Negative integer without decimal part\n    assert(truncate_number(-10)\
    \ == 0);\n    assert(truncate_number(-10.0) == 0);\n}\n/*\n    Given an integer\
    \ 'num' and a number of moves 'steps', divide\n    'num' in half that many times\
    \ and return the integer result.\n    If 'num' is odd and cannot be divided in\
    \ half, the algorithm\n    should try to make it the closest even number (for\
    \ example,\n    if it is 5, the closest even number is 6).\n    \n    >>> half_num(6,\
    \ 1)\n    3\n    \n    >>> half_num(6, 2)\n    1\n    \n    >>> half_num(6, 3)\n\
    \    0\n    \n    >>> half_num(6, 4)\n    0\n    \n    >>> half_num(5, 1)\n  \
    \  2\n    \n    >>> half_num(5, 2)\n    1\n    \n    >>> half_num(5, 3)\n", "{\n\
    \treturn number - floor(number);\n}", "{\n    return float(int(number)) - number;\n\
    }", "{\n  return number - cast(int)number;\n}\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).", "{\n    // TODO:\n    // The decimal part is the decimal value of the\
    \ number subtracted by its\n    // integer part.\n    float n = number - int(number);\n\
    \    return n;\n}", "{\n    return 0.0;\n}", "    @safe pure nothrow @nogc {\n\
    \    return number - cast(int)number;\n}", "{\n    return number - cast(int)number;\n\
    }\n/*\n    Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "{\n    int larger = number;\n \
    \   float small = number - larger;\n    return small;\n}", "    in(number) nothrow\
    \ @nogc\n{\n    // negative numbers are not handled\n    assert(number >= 0);\n\
    \    // the math module has the `modf` function which does exactly this\n    float\
    \ int_part = 0.0;\n    return modf(number, int_part);\n}\n/*\n When you are trying\
    \ to call a function with parameters that don't match,\n you will get an error.\
    \ The first way to fix this is to make sure the parameters\n match.", "{\n\treturn\
    \ number - cast(int)number;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
