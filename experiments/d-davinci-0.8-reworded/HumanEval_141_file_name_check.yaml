name: HumanEval_141_file_name_check
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nCreate a function which takes\
  \ a string representing a file's name, and returns\n    'Yes' if the the file's\
  \ name is valid, and returns 'No' otherwise.\n    A file's name is considered to\
  \ be valid if and only if all the following conditions \n    are met:\n    - There\
  \ should not be more than three digits ('0'-'9') in the file's name.\n    - The\
  \ file's name contains exactly one dot '.'\n    - The substring before the dot should\
  \ not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z'\
  \ and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt',\
  \ 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"\
  Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string\
  \ file_name) \n"
tests: "unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
  example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n\
  \    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\"\
  ) == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"\
  His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n \
  \   assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\"\
  ) == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
  this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
  ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n   \
  \ assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
  this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\")\
  \ == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
  Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"\
  Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
  I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n\
  \    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
  ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
  s.\") == \"No\");\n}\nvoid main(){}"
completions: ["{\n    string file_types[] = [\"txt\", \"exe\", \"dll\"];\n    foreach(file_type;\
    \ file_types)\n    {\n        string extension = \".\" ~ file_type;\n        if(file_name.count(extension)\
    \ == 1)\n        {\n            string file_name_without_extension = file_name.split(extension)[0];\n\
    \            if(file_name_without_extension.length > 0)\n            {\n     \
    \           if(file_name_without_extension[0].isLetter)\n                {\n \
    \                   if(file_name_without_extension.count(\"0\":\"9\") <= 3)\n\
    \                    {\n                        return \"Yes\";\n            \
    \        }\n                }\n            }\n        }\n    }\n    return \"\
    No\";\n}\n// (function() {\n//   /* Fill in code here */\n// })();", "{\n\tbool\
    \ is_txt = \"txt\" in file_name.split(\".\")[1];\n\tbool is_exe = \"exe\" in file_name.split(\"\
    .\")[1];\n\tbool is_dll = \"dll\" in file_name.split(\".\")[1];\n\tbool no_ext\
    \ = is_txt || is_exe || is_dll;\n\tint count = 0;\n\tforeach(immutable c; file_name.split(\"\
    .\")[0]) \n\t{\n\t\tif(\"0\" .. \"9\" in c) \n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\
    }\n\tif(\"a\" .. \"z\" in file_name.split(\".\")[0][0]) \n\t{\n\t\tif(count <=\
    \ 3 && no_ext) \n\t\t{\n\t\t\treturn \"Yes\";\n\t\t}\n\t}\n\treturn \"No\";\n}",
  "{\n    //If the file name contains more than three digits\n    if(file_name.match(r\"\
    \\d\\d\\d\").length > 3)\n    {\n        return \"No\";\n    }\n    //If the file\
    \ name contains more than one dot\n    if(file_name.match(r\"\\.\").length > 1)\n\
    \    {\n        return \"No\";\n    }\n    //If the file name contains 0 dots\n\
    \    if(file_name.match(r\"\\.\").length == 0)\n    {\n        return \"No\";\n\
    \    }\n    //If the substring before the dot is empty or is not a letter\n  \
    \  if(file_name.match(r\"^[a-zA-Z]\").length == 0)\n    {\n        return \"No\"\
    ;\n    }\n    //If the substring after the dot is not one of the provided strings\n\
    \    if(file_name.match(r\"\\.(exe|txt|dll)$\").length == 0)\n    {\n        return\
    \ \"No\";\n    }\n    return \"Yes\";\n}", "{\n    int len = file_name.length;\n\
    \    char ext = file_name[len-3];\n    char ext1 = file_name[len-2];\n    char\
    \ ext2 = file_name[len-1];\n    string extension = ext + ext1 + ext2;\n    uint\
    \ counter = 0;\n    for(uint i = 0; i < len; i++)\n    {\n        if(file_name[i]\
    \ == '.')\n        {\n            if(counter > 0)\n            {\n           \
    \     return \"No\";\n            }\n            counter++;\n        }\n     \
    \   if(isdigit(file_name[i]))\n        {\n            counter++;\n        }\n\
    \    }\n    if(counter > 3)\n    {\n        return \"No\";\n    }\n    if(file_name[0]\
    \ == '.')\n    {\n        return \"No\";\n    }\n    if(extension != \"txt\" &&\
    \ extension != \"exe\" && extension != \"dll\")\n    {\n        return \"No\"\
    ;\n    }\n    return \"Yes\";\n}", "{\n    auto result = true;\n    foreach(i;\
    \ 0 .. file_name.length)\n    {\n        if (file_name[i] >= '0' && file_name[i]\
    \ <= '9')\n        {\n            if (result)\n            {\n               \
    \ if (i > 3)\n                {\n                    result = false;\n       \
    \         }\n            }\n        }\n        else if (file_name[i] == '.')\n\
    \        {\n            if (i == 0 || i == file_name.length - 1)\n           \
    \ {\n                result = false;\n            }\n            else\n      \
    \      {\n                if (file_name[i + 1] == 't' && file_name[i + 2] == 'x'\
    \ && file_name[i + 3] == 't')\n                {\n                }\n        \
    \        else if (file_name[i + 1] == 'e' && file_name[i + 2] == 'x' && file_name[i\
    \ + 3] == 'e')\n                {\n                }\n                else if\
    \ (file_name[i + 1] == 'd' && file_name[i + 2] == 'l' && file_name[i + 3] == 'l')\n\
    \                {\n                }\n                else\n                {\n\
    \                    result = false;\n                }\n            }\n     \
    \   }\n        else if (file_name[i] >= 'a' && file_name[i] <= 'z')\n        {\n\
    \            if (i == file_name.length - 1)\n            {\n                result\
    \ = false;\n            }\n        }\n        else if (file_name[i] >= 'A' &&\
    \ file_name[i] <= 'Z')\n        {\n            if (i == file_name.length - 1)\n\
    \            {\n                result = false;\n            }\n        }\n  \
    \      else\n        {\n            result = false;\n        }\n    }\n    if\
    \ (result)\n    {\n        return \"Yes\";\n    }\n    else\n    {\n        return\
    \ \"No\";\n    }\n}\n/*\nGiven a string, return a string representing its value\
    \ in binary, and with the binary \nindices as specified below.\nExamples:\n",
  "{\n    enum { MAX_DIGITS = 3 };", "{\n    enum alph = ['a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    enum digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    enum\
    \ extention = ['txt', 'exe', 'dll'];\n    int dot_count = 0;\n    int digit_count\
    \ = 0;\n    int char_count = 0;\n    bool is_alph = false;\n    string file_name_extention\
    \ = \"\";\n    string file_name_without_extention = \"\";\n    if (file_name.length\
    \ == 0)\n    {\n        return \"No\";\n    }\n    foreach (c; file_name)\n  \
    \  {\n        if (c == '.')\n        {\n            dot_count++;\n        }\n\
    \        else if (digits.canFind(c))\n        {\n            digit_count++;\n\
    \        }\n        else if (alph.canFind(c))\n        {\n            is_alph\
    \ = true;\n            char_count++;\n        }\n        else\n        {\n   \
    \         return \"No\";\n        }\n    }\n    if (dot_count != 1)\n    {\n \
    \       return \"No\";\n    }\n    if (digit_count > 3)\n    {\n        return\
    \ \"No\";\n    }\n    if (!is_alph)\n    {\n        return \"No\";\n    }\n  \
    \  file_name_extention = file_name[file_name.length - 3 .. file_name.length];\n\
    \    file_name_without_", "{\n    enum file_type = [\"txt\", \"exe\", \"dll\"\
    ];\n    immutable file_name_type = file_name.split(\".\");\n    if (file_name_type.length\
    \ != 2) return \"No\";\n    if (file_name_type[0].filter!(ch => ch.isDigit).length\
    \ > 3) return \"No\";\n    if (file_name_type[0].length == 0) return \"No\";\n\
    \    if (!file_name_type[0][0].isAlpha) return \"No\";\n    if (file_name_type[1]\
    \ !in file_type) return \"No\";\n    return \"Yes\";\n}", "{\n\tstring [] file_name_array\
    \ = split(file_name, \".\");\n\t// Check for only one dot.\n\tif (file_name_array.length\
    \ > 2)\n\t{\n\t\treturn \"No\";\n\t}\n\t// Check for at least one letter\n\tif\
    \ (file_name_array[0].length == 0)\n\t{\n\t\treturn \"No\";\n\t}\n\t// Check for\
    \ correct file extension.\n\tif (!in(file_name_array[1], [\"txt\", \"exe\", \"\
    dll\"]))\n\t{\n\t\treturn \"No\";\n\t}\n\t// Check that the file name is not empty.\n\
    \tif (file_name_array[0].length == 0)\n\t{\n\t\treturn \"No\";\n\t}\n\t// Check\
    \ that there are no numbers in the file name.\n\tforeach (letter; file_name_array[0])\n\
    \t{\n\t\tif (in('0', '9', letter))\n\t\t{\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\t\
    // Check that the first letter is not a number.\n\tif (in('0', '9', file_name_array[0][0]))\n\
    \t{\n\t\treturn \"No\";\n\t}\n\treturn \"Yes\";\n}", "{\n    auto index = file_name.find('.');\n\
    \    if ( index != string.npos ) \n    {\n        string prefix = file_name[0..index];\n\
    \        string postfix = file_name[index+1..$];\n        size_t num_digits =\
    \ 0;\n        bool letter_found = false;\n        for (auto e : prefix) \n   \
    \     {\n            if (isdigit(e))\n                num_digits++;\n        \
    \    else if (isalpha(e))\n                letter_found = true;\n        }\n \
    \       if (num_digits > 3 || !letter_found || prefix.length == 0)\n         \
    \   return \"No\";\n        else if (postfix != \"txt\" && postfix != \"exe\"\
    \ && postfix != \"dll\")\n            return \"No\";\n        else\n         \
    \   return \"Yes\";\n    } \n    else \n    {\n        return \"No\";\n    }\n\
    }\n/*\n10)\nCreate a function which takes a string representing a polynomial expression,\n\
    and returns the simplified expression.\nThe expression is of form 'ax + b', where\
    \ a and b are real numbers, and x\nis a variable name.\nx is considered to be\
    \ a valid variable name if and only if all the following conditions\nare met:\n\
    - The first character is 'x'.\n- The rest of the characters are letters from the\
    \ latin alphabet ( 'a'-'z' and 'A'-'Z' ).", "{\n    \n    //returns the file name\
    \ without the extension\n    auto name = file_name.split(\".\").front();\n   \
    \ //returns the file's extension\n    auto extension = file_name.split(\".\").back;\n\
    \    int count = 0;\n    foreach(i;0..name.length)\n    {\n        //if a number\
    \ is found, count increases by 1\n        if(isNumeric(name[i]))\n        {\n\
    \            count++;\n        }\n    }\n    //checks if all conditions are met\n\
    \    return (count<=3 && file_name.count('.')==1 && name[0].isAlpha && extension\
    \ == \"txt\" || extension == \"exe\" || extension == \"dll\") ? \"Yes\" : \"No\"\
    ;\n}", "{\n    static struct file_name_check_result\n    {\n        string is_valid\
    \ = \"No\";\n        uint dot_pos = 0;\n        uint num_of_digits = 0;\n    }\
    \ fncr;\n    static string const valid_exts[] = [\"txt\", \"exe\", \"dll\"];\n\
    \    static string const alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    static\
    \ string const digits = \"0123456789\";\n    static string const dot = \".\";\n\
    \    static import std.range.primitives : take, takeOne;\n    static import std.algorithm.comparison\
    \ : startsWith;\n    static import std.algorithm.searching : count, any;\n   \
    \ static import std.algorithm.iteration : countUntil;\n    static import std.functional\
    \ : pred;\n    static import std.array : array;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;\n    static import std.typecons\
    \ : tuple;\n    static import std.typecons : tuple;", "{\n    string[] exten =\
    \ [\"txt\", \"exe\", \"dll\"];\n    int dot_position = file_name.find(\".\");\n\
    \    string sub = file_name[0..dot_position];\n    string after_dot = file_name[dot_position\
    \ + 1..$];\n    bool valid = true;\n    if (dot_position == 0) \n    {\n     \
    \   valid = false;\n    }\n    else if (count(file_name, \".\") != 1) \n    {\n\
    \        valid = false;\n    }\n    else if (!(exten.find(after_dot) != -1)) \n\
    \    {\n        valid = false;\n    }\n    int cnt = 0;\n    foreach (char c;\
    \ sub) \n    {\n        if (c >= '0' && c <= '9') \n        {\n            cnt++;\n\
    \        }\n    }\n    if (cnt > 3) \n    {\n        valid = false;\n    }\n \
    \   else if (!((sub[0] >= 'a' && sub[0] <= 'z') || (sub[0] >= 'A' && sub[0] <=\
    \ 'Z'))) \n    {\n        valid = false;\n    }\n    return valid ? \"Yes\" :\
    \ \"No\";\n}", "{\n    string result = \"No\";\n    int num_of_dots = 0;\n   \
    \ int num_of_digits = 0;\n    string file_name_ext;\n    string file_name_prefix;\n\
    \    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n    \
    \        num_of_dots++;\n            continue;\n        }\n        if(num_of_dots\
    \ == 0)\n        {\n            file_name_prefix ~= c;\n        }\n        else\n\
    \        {\n            file_name_ext ~= c;\n        }\n        if(isdigit(c))\n\
    \        {\n            num_of_digits++;\n        }\n    }\n    if(num_of_dots\
    \ == 1 && num_of_digits <= 3 && file_name_prefix.length != 0 \n        && isalpha(file_name_prefix[0])\
    \ && (file_name_ext == \"txt\" || file_name_ext == \"exe\" || file_name_ext ==\
    \ \"dll\"))\n    {\n        result = \"Yes\";\n    }\n    return result;\n}",
  "{\n    int count = 0;\n    int dot_count = 0;\n    int i = 0;\n    bool is_letter\
    \ = false;\n    bool is_extension = false;\n    int point = 0;\n    while(file_name[i]\
    \ != '\\0')\n    {\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n\
    \            point = i;\n        }\n        else if(file_name[i] >= '0' && file_name[i]\
    \ <= '9')\n        {\n            count++;\n        }\n        else if((file_name[i]\
    \ >= 'a' && file_name[i] <= 'z') || (file_name[i] >= 'A' && file_name[i] <= 'Z'))\n\
    \        {\n            is_letter = true;\n        }\n        else if(file_name[i]\
    \ == '.')\n        {\n            point = i;\n        }\n        i++;\n    }\n\
    \    string extension = file_name[point+1..$];\n    if(extension == \"txt\" ||\
    \ extension == \"exe\" || extension == \"dll\")\n    {\n        is_extension =\
    \ true;\n    }\n    if(count <= 3 && dot_count == 1 && is_letter && is_extension)\n\
    \    {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\"\
    ;\n    }\n}", "{\n    auto extension = file_name.split(\".\");\n    bool result\
    \ = extension.length > 1 && extension[0].length > 0 && \n        extension[0].all!(\"\
    a\"..\"z\" ~ \"A\"..\"Z\") && \n        extension[1] in [\"txt\", \"exe\", \"\
    dll\"] &&\n        extension[0].all!(\"0\"..\"9\");\n    return result ? \"Yes\"\
    \ : \"No\";\n}\n \n \nstring file_name_check_regex(string file_name) \n{\n   \
    \ enum match = file_name.match(\"\\\\w+\\\\.(txt|exe|dll)\");\n    return match\
    \ ? \"Yes\" : \"No\";\n}\n \n void main()\n {\n     assert(file_name_check(\"\
    example.txt\") == \"Yes\");\n     assert(file_name_check(\"1example.dll\") ==\
    \ \"No\");\n     assert(file_name_check(\"1example.exe\") == \"No\");\n     assert(file_name_check(\"\
    example.txt2\") == \"No\");\n     assert(file_name_check(\"exa3mple.txt\") ==\
    \ \"No\");\n     assert(file_name_check(\"exampl3.txt\") == \"No\");\n     assert(file_name_check_regex(\"\
    example.txt\") == \"Yes\");\n     assert(file_name_check_regex(\"1example.dll\"\
    ) == \"No\");\n     assert(file_name_check_regex(\"1example.exe\") == \"No\");\n\
    \     assert(file_name_check_regex(\"example.txt2\") == \"No\");\n     assert(file_name_check_regex(\"\
    exa3mple.txt\") == \"No\");\n     assert(file_name_check_regex(\"exampl3.txt\"\
    ) == \"No\");\n     //TODO add more tests.\n }", "{\n    /* aliases */\n    import\
    \ std.array;\n    import std.algorithm;\n    import std.string;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.algorithm : filter, map, count;\n    import std.range : take,\
    \ drop, takeExactly, dropExactly;\n    import std.range : find;\n    import std.range\
    \ : empty;\n    import std.conv : text;\n    import std.range : iota;\n    import\
    \ std.regex : regex, ctRegex, RegexMatch;\n    import std.regex : replace;\n \
    \   import std.math : sqrt;\n    import std.math : parse;\n    import std.digest.sha\
    \ : sha1;\n    import std.digest.crc : crc32;\n    import std.range : only;\n\
    \    import std.math : isNaN;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.traits : Unqual;\n    import std.traits : unqual;\n\
    \    import std.typecons : tuple;\n    import std.range : only;\n    import std.typecons\
    \ : Tuple;\n    import std.traits : Unqual;\n    import std.traits : unqual;\n\
    \    import std.range : only;\n    import std.range : only;\n    import std.range\
    \ : only;\n    import std.range : only;\n    import std.range : only;\n    import\
    \ std.range : only;\n    import std.range : only;\n    import std.range : only;\n\
    \    import std.range : only;\n    import std.range : only;\n    import std.range\
    \ : only;\n    import std.range : only;\n    import std.range : only;\n    import\
    \ std.range : only;\n    import std.range : only;\n    import std.range : only;\n\
    \    import std.range : only;\n    import std.range : only;\n    import std.range\
    \ : only;\n    import std.range : only;\n    import std.range : only;\n    import",
  "{\n    int dot_position = file_name.find('.');\n    string extension = file_name.substr(dot_position\
    \ + 1);\n    if(extension.length != 3) \n    {\n        return \"No\";\n    }\n\
    \    else if(!std.regex.match(\"^[a-zA-Z]+$\", file_name.substr(0, dot_position)))\
    \ \n    {\n        return \"No\";\n    }\n    else if(!std.regex.match(\"^[a-zA-Z]$\"\
    , file_name[0])) \n    {\n        return \"No\";\n    }\n    else if(!std.regex.match(\"\
    ^[a-zA-Z0-9]+$\", extension)) \n    {\n        return \"No\";\n    }\n    else\
    \ if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\") \n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n/*\n    Create\
    \ a function which takes a string representing the file's name, and returns \n\
    \    its extention.\n    A file's name is considered to be valid if and only if\
    \ all the following conditions \n    are met:\n    - There should not be more\
    \ than three digits ('0'-'9') in the file's name.\n    - The file's name contains\
    \ exactly one dot '.'\n    - The substring before the dot should not be empty,\
    \ and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n\
    \    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\
    \    It is assured that the input is valid.\n    Examples:\n    >>> file_name_get_extension(\"\
    example.txt\")\n    \"txt\"\n    >>> file_name_get_extension(\"1example.dll\"\
    )\n    \"dll\"\n*/\nstring file_name_get_extension(string file_name) \n{\n   \
    \ int dot_position = file_name.find('.');\n    return file_name.substr(dot_position\
    \ + 1);\n}\n/*\n    Create a", "{\n    string sub = file_name[1..$-4];\n    if\
    \ (file_name[$-3..$] == \"txt\" || file_name[$-3..$] == \"exe\" || file_name[$-3..$]\
    \ == \"dll\")\n    {\n        if (file_name[0..0] != \"0\" && file_name[0..0]\
    \ != \"1\" && file_name[0..0] != \"2\" && file_name[0..0] != \"3\" && file_name[0..0]\
    \ != \"4\" && file_name[0..0] != \"5\" && file_name[0..0] != \"6\" && file_name[0..0]\
    \ != \"7\" && file_name[0..0] != \"8\" && file_name[0..0] != \"9\")\n        {\n\
    \            int num = 0;\n            foreach (c; sub)\n            {\n     \
    \           if (c == \"0\" || c == \"1\" || c == \"2\" || c == \"3\" || c == \"\
    4\" || c == \"5\" || c == \"6\" || c == \"7\" || c == \"8\" || c == \"9\")\n \
    \               {\n                    num++;\n                }\n           \
    \ }\n            if (num <= 3)\n            {\n                return \"Yes\"\
    ;\n            }\n            else\n            {\n                return \"No\"\
    ;\n            }\n        }\n        else\n        {\n            return \"No\"\
    ;\n        }\n    }\n    else\n    {\n        return \"No\";\n    }\n}", "{\n\
    \    auto file_name_parts = splitter(file_name, \".\");\n    int dot_count = 0;\n\
    \    int digits_count = 0;\n    string file_extension = \"\";\n    string file_name_to_check\
    \ = \"\";\n    bool file_name_valid = true;\n    foreach(part; file_name_parts)\n\
    \    {\n        if(part == \"txt\" || part == \"exe\" || part == \"dll\")\n  \
    \      {\n            file_extension = part;\n        }\n        else\n      \
    \  {\n            file_name_to_check = part;\n        }\n        if(part == \"\
    .\")\n        {\n            dot_count += 1;\n        }\n        digits_count\
    \ += count(part, char(48..57));\n    }\n    if(file_name_to_check.length() ==\
    \ 0 || !file_name_to_check[0].isAlpha || file_name_to_check[0].isLower)\n    {\n\
    \        file_name_valid = false;\n    }\n    if(digits_count > 3 || dot_count\
    \ != 1 || file_extension == \"\")\n    {\n        file_name_valid = false;\n \
    \   }\n    if(file_name_valid)\n    {\n        return \"Yes\";\n    }\n    else\n\
    \    {\n        return \"No\";\n    }\n    \n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
