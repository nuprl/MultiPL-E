name: HumanEval_77_iscube
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that takes\
  \ an integer a and returns true \n    if this ingeger is a cube of some integer\
  \ number.\n    Note: you may assume the input is always valid.\n    Examples:\n\
  \    >>> iscube(1L)\n    true\n    >>> iscube(2L)\n    false\n    >>> iscube(-1L)\n\
  \    true\n    >>> iscube(64L)\n    true\n    >>> iscube(0L)\n    true\n    >>>\
  \ iscube(180L)\n    false\n    \n*/\nbool iscube(long a) \n"
tests: "unittest\n{\n    alias candidate = iscube;\n\n    assert(candidate(1L) ==\
  \ true);\n    assert(candidate(2L) == false);\n    assert(candidate(-1L) == true);\n\
  \    assert(candidate(64L) == true);\n    assert(candidate(180L) == false);\n  \
  \  assert(candidate(1000L) == true);\n    assert(candidate(0L) == true);\n    assert(candidate(1729L)\
  \ == false);\n}\nvoid main(){}"
completions: ["{\n    return typeof(a) == long ? (a ^^ 3).sign == 0 : false;\n}\n\
    /*\n    Write a function that takes a tuple of integers and returns \n    the\
    \ tuple of products of all items except ith, where i is \n    the index of the\
    \ item in the tuple.\n    Note: you may assume that all items in the tuple are\
    \ positive.\n    Examples:\n    >>> products((1, 2, 3, 4))\n    (24, 12, 8, 6)\n\
    \    >>> products((1, 2, 3, 4, 5))\n    (120, 60, 40, 30, 24)\n    >>> products((1,\
    \ 2, 3, 4, 5, 6))\n    (720, 360, 240, 180, 144, 120)\n    >>> products((1, 2,\
    \ 3, 4, 5, 6, 7))\n    (5040, 2520, 1680, 1260, 1008, 840, 720)\n    >>> products((1,\
    \ 2, 3, 4, 5, 6, 7, 8))\n    (40320, 20160, 13440, 10080, 8064, 6720, 5760, 5040)\n\
    \    >>> products((1, 2, 3, 4, 5, 6, 7, 8, 9))\n    (362880, 181440, 120960, 90720,\
    \ 72576, 60480, 51840, 45360, 40320)\n    >>> products((1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10))\n    (3628800, 1814400, 1209600, 907200, 7257600, 60480, 518400, 453600,\
    \ 403200, 362880)\n*/\nauto products(T)(T items)\n{\n    static if(__traits(compiles,\
    \ staticMap!((a, b) => a * b, items)))\n    {\n        return staticMap!((a, b)\
    \ => a * b, items);\n    }\n    else\n    {\n        import std.algorithm.iteration;\n\
    \        return items.reduce!((a, b) => a * b);\n    }\n}\n/*\n    Write a function\
    \ that takes a tuple of integers of length N", "{\n    return (((long)round(pow(a,\
    \ 1./3)))**3) == a;\n}", "{\n    if (a == 0) return true;\n    if (a == 1) return\
    \ true;\n    if (a == -1) return true;\n    if (a < 0) return false;\n    long\
    \ cbrt = pow(a, 1.0/3.0);\n    if (pow(cbrt, 3) == a) return true;\n    return\
    \ false;\n}", "{\n    auto cbrt_a = cbrt(a);\n    return cbrt_a == int(cbrt_a);\n\
    }", "{\n    return a == pow(round(pow(a, 1.0/3.0)), 3);\n}", "{\n    if (a ==\
    \ 0L) return true;\n    long b = abs(a);\n    long t = pow(b, 1.0 / 3.0);\n  \
    \  if (t * t * t == b) return true;\n    else return false;\n}\n/*\n    Write\
    \ a function that takes an integer a and returns true \n    if this ingeger is\
    \ a square of some integer number.\n    Note: you may assume the input is always\
    \ valid.\n    Examples:\n    >>> issquare(1L)\n    true\n    >>> issquare(2L)\n\
    \    false\n    >>> issquare(-1L)\n    true\n    >>> issquare(0L)\n    true\n\
    \    >>> issquare(64L)\n    true\n    >>> issquare(180L)\n    false\n    \n*/",
  "{\n    if (a == 0) \n        return true;\n    double x = abs(a);\n    double x3\
    \ = pow(x, 1.0/3.0);\n    int r = int(x3);\n    return r*r*r == a;\n}\n//version\
    \ (2)\nauto iscube2 = [](long a) { return !a || pow(abs(a), 1.0/3.0) == int(pow(abs(a),\
    \ 1.0/3.0)); };\n//version (3)", "{\n    return sqrt(a) == round(sqrt(a));\n}\n\
    /*\n    You're given a list of integers alist.\n    You have to write a function\
    \ iseven that \n    returns a list of booleans that tell if a given element \n\
    \    in alist is even or not.\n    >>> iseven([2, 3, 5, 1, 6, 9, 11])\n    [true,\
    \ false, false, false, true, false, false]\n    >>> iseven([])\n    []\n    >>>\
    \ iseven([1, 3, 5, 7, 9])\n    [false, false, false, false, false]\n    >>> iseven([2,\
    \ 4, 6, 8, 10])\n    [true, true, true, true, true]\n*/\nstatic auto iseven(alias\
    \ predicate = \"a % 2 == 0\")(int[] a)\n{\n    return a.map!(x => predicate(x))();\n\
    }\n// version without a parameter", "{\n    double b = cbrt(a);\n    return (a==(long)b*(long)b*(long)b);\n\
    }", "{\n    return a == pow(cast(long)pow(cast(double)a, 1.0/3.0), 3);\n}", "{\n\
    \    return a==0L || cast(int)pow(a,0.333333)==pow(a,0.333333);\n}", "{\n    long\
    \ temp;\n    temp = round(pow(a, 1.0 / 3.0));\n    temp = temp * temp * temp;\n\
    \    return temp == a;\n}", "{\n    long cube_root_long = long(pow(a, 1.0/3.0));\n\
    \    double cube_root_double = pow(a, 1.0/3.0);\n    double x = cube_root_double-cube_root_long;\n\
    \    bool is_cube = (x==0);\n    return is_cube;\n}", "{\n    if (a == 0L)\n \
    \       return true;\n    if (a < 0L)\n        a = -a;\n    long b = rint(pow(cast(double)a,\
    \ 1.0/3.0));\n    return b*b*b == a;\n}", "{\n    if (a == 0L)\n        return\
    \ true;\n    else if (a < 0L)\n        return iscube(-a);\n    else {\n      \
    \  double cbrt = Math.cbrt(a);\n        if (Math.ceil(cbrt) == Math.floor(cbrt))\n\
    \            return true;\n        else\n            return false;\n    }\n}",
  "{\n    bool result = false;\n    if (a == 0L)\n    {\n        result = true;\n\
    \    } else if (a > 0L)\n    {\n        result = a == pow(round(pow(a, (1.0/3.0))),\
    \ 3);\n    } else if (a < 0L)\n    {\n        result = a == -pow(round(pow(-a,\
    \ (1.0/3.0))), 3);\n    }\n    return result;\n}", "{\n    // double cube_root\
    \ = pow(a, 1.0/3.0);\n    // return a == cube_root * cube_root * cube_root;",
  "{\n  if (a == 0)\n    return true;\n  else if (a < 0)\n    return iscube(-a);\n\
    \  else {\n    double aRoot = exp(log(a) / 3);\n    return aRoot == ceil(aRoot);\n\
    \  }\n}\n#endif", "{\n    return isPerfectCube(a);\n}", "{\n    long cbrt;\n \
    \   cbrt = cast(long) round(cbrt(a));\n    return(cbrt * cbrt * cbrt == a);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
