name: HumanEval_77_iscube
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that takes\
  \ an integer a and returns true \n    if this ingeger is a cube of some integer\
  \ number.\n    Note: you may assume the input is always valid.\n    Examples:\n\
  \    >>> iscube(1L)\n    true\n    >>> iscube(2L)\n    false\n    >>> iscube(-1L)\n\
  \    true\n    >>> iscube(64L)\n    true\n    >>> iscube(0L)\n    true\n    >>>\
  \ iscube(180L)\n    false\n    \n*/\nbool iscube(long a) \n"
tests: "unittest\n{\n    alias candidate = iscube;\n\n    assert(candidate(1L) ==\
  \ true);\n    assert(candidate(2L) == false);\n    assert(candidate(-1L) == true);\n\
  \    assert(candidate(64L) == true);\n    assert(candidate(180L) == false);\n  \
  \  assert(candidate(1000L) == true);\n    assert(candidate(0L) == true);\n    assert(candidate(1729L)\
  \ == false);\n}\nvoid main(){}"
completions: ["{\n    return typeof(a) == long ? (a ^^ 3).sign == 0 : false;\n}\n\
    /*\n    Write a function that takes a tuple of integers and returns \n    the\
    \ tuple of products of all items except ith, where i is \n    the index of the\
    \ item in the tuple.\n    Note: you may assume that all items in the tuple are\
    \ positive.\n    Examples:\n    >>> products((1, 2, 3, 4))\n    (24, 12, 8, 6)\n\
    \    >>> products((1, 2, 3, 4, 5))\n    (120, 60, 40, 30, 24)\n    >>> products((1,\
    \ 2, 3, 4, 5, 6))\n    (720, 360, 240, 180, 144, 120)\n    >>> products((1, 2,\
    \ 3, 4, 5, 6, 7))\n    (5040, 2520, 1680, 1260, 1008, 840, 720)\n    >>> products((1,\
    \ 2, 3, 4, 5, 6, 7, 8))\n    (40320, 20160, 13440, 10080, 8064, 6720, 5760, 5040)\n\
    \    >>> products((1, 2, 3, 4, 5, 6, 7, 8, 9))\n    (362880, 181440, 120960, 90720,\
    \ 72576, 60480, 51840, 45360, 40320)\n    >>> products((1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10))\n    (3628800, 1814400, 1209600, 907200, 7257600, 60480, 518400, 453600,\
    \ 403200, 362880)\n*/\nauto products(T)(T items)\n{\n    static if(__traits(compiles,\
    \ staticMap!((a, b) => a * b, items)))\n    {\n        return staticMap!((a, b)\
    \ => a * b, items);\n    }\n    else\n    {\n        import std.algorithm.iteration;\n\
    \        return items.reduce!((a, b) => a * b);\n    }\n}\n/*\n    Write a function\
    \ that takes a tuple of integers of length N", "{\n    return (((long)round(pow(a,\
    \ 1./3)))**3) == a;\n}", "{\n    if (a == 0) return true;\n    if (a == 1) return\
    \ true;\n    if (a == -1) return true;\n    if (a < 0) return false;\n    long\
    \ cbrt = pow(a, 1.0/3.0);\n    if (pow(cbrt, 3) == a) return true;\n    return\
    \ false;\n}", "{\n    auto cbrt_a = cbrt(a);\n    return cbrt_a == int(cbrt_a);\n\
    }", "{\n    return a == pow(round(pow(a, 1.0/3.0)), 3);\n}", "{\n    if (a ==\
    \ 0L) return true;\n    long b = abs(a);\n    long t = pow(b, 1.0 / 3.0);\n  \
    \  if (t * t * t == b) return true;\n    else return false;\n}\n/*\n    Write\
    \ a function that takes an integer a and returns true \n    if this ingeger is\
    \ a square of some integer number.\n    Note: you may assume the input is always\
    \ valid.\n    Examples:\n    >>> issquare(1L)\n    true\n    >>> issquare(2L)\n\
    \    false\n    >>> issquare(-1L)\n    true\n    >>> issquare(0L)\n    true\n\
    \    >>> issquare(64L)\n    true\n    >>> issquare(180L)\n    false\n    \n*/",
  "{\n    if (a == 0) \n        return true;\n    double x = abs(a);\n    double x3\
    \ = pow(x, 1.0/3.0);\n    int r = int(x3);\n    return r*r*r == a;\n}\n//version\
    \ (2)\nauto iscube2 = [](long a) { return !a || pow(abs(a), 1.0/3.0) == int(pow(abs(a),\
    \ 1.0/3.0)); };\n//version (3)", "{\n    return sqrt(a) == round(sqrt(a));\n}\n\
    /*\n    You're given a list of integers alist.\n    You have to write a function\
    \ iseven that \n    returns a list of booleans that tell if a given element \n\
    \    in alist is even or not.\n    >>> iseven([2, 3, 5, 1, 6, 9, 11])\n    [true,\
    \ false, false, false, true, false, false]\n    >>> iseven([])\n    []\n    >>>\
    \ iseven([1, 3, 5, 7, 9])\n    [false, false, false, false, false]\n    >>> iseven([2,\
    \ 4, 6, 8, 10])\n    [true, true, true, true, true]\n*/\nstatic auto iseven(alias\
    \ predicate = \"a % 2 == 0\")(int[] a)\n{\n    return a.map!(x => predicate(x))();\n\
    }\n// version without a parameter", "{\n    double b = cbrt(a);\n    return (a==(long)b*(long)b*(long)b);\n\
    }", "{\n    return a == pow(cast(long)pow(cast(double)a, 1.0/3.0), 3);\n}", "{\n\
    \    return a==0L || cast(int)pow(a,0.333333)==pow(a,0.333333);\n}", "{\n    long\
    \ temp;\n    temp = round(pow(a, 1.0 / 3.0));\n    temp = temp * temp * temp;\n\
    \    return temp == a;\n}", "{\n    long cube_root_long = long(pow(a, 1.0/3.0));\n\
    \    double cube_root_double = pow(a, 1.0/3.0);\n    double x = cube_root_double-cube_root_long;\n\
    \    bool is_cube = (x==0);\n    return is_cube;\n}", "{\n    if (a == 0L)\n \
    \       return true;\n    if (a < 0L)\n        a = -a;\n    long b = rint(pow(cast(double)a,\
    \ 1.0/3.0));\n    return b*b*b == a;\n}", "{\n    if (a == 0L)\n        return\
    \ true;\n    else if (a < 0L)\n        return iscube(-a);\n    else {\n      \
    \  double cbrt = Math.cbrt(a);\n        if (Math.ceil(cbrt) == Math.floor(cbrt))\n\
    \            return true;\n        else\n            return false;\n    }\n}",
  "{\n    bool result = false;\n    if (a == 0L)\n    {\n        result = true;\n\
    \    } else if (a > 0L)\n    {\n        result = a == pow(round(pow(a, (1.0/3.0))),\
    \ 3);\n    } else if (a < 0L)\n    {\n        result = a == -pow(round(pow(-a,\
    \ (1.0/3.0))), 3);\n    }\n    return result;\n}", "{\n    // double cube_root\
    \ = pow(a, 1.0/3.0);\n    // return a == cube_root * cube_root * cube_root;",
  "{\n  if (a == 0)\n    return true;\n  else if (a < 0)\n    return iscube(-a);\n\
    \  else {\n    double aRoot = exp(log(a) / 3);\n    return aRoot == ceil(aRoot);\n\
    \  }\n}\n#endif", "{\n    return isPerfectCube(a);\n}", "{\n    long cbrt;\n \
    \   cbrt = cast(long) round(cbrt(a));\n    return(cbrt * cbrt * cbrt == a);\n}",
  "{\n    return (long)pow(round(pow(a, 1.0/3.0)), 3) == a;\n}", "{\n    return a\
    \ == 0 || cast(long)pow(cast(double)abs(a), 1./3) == abs(a);\n}", "{\n    return\
    \ (long)round(pow(a, 1.0 / 3.0)) * (long)round(pow(a, 1.0 / 3.0)) * (long)round(pow(a,\
    \ 1.0 / 3.0)) == a;\n}", "{\n    if (a > 0L) {\n        long cbrtA = cast(long)std.math.cbrt(a);\n\
    \        if (cbrtA*cbrtA*cbrtA == a) return true;\n    }\n    else if (a < 0L)\
    \ {\n        long cbrtA = cast(long)std.math.cbrt(-a);\n        if (cbrtA*cbrtA*cbrtA\
    \ == -a) return true;\n    }\n    else if (a == 0L) return true;\n    return false;\n\
    }\n/*\n    Write a function that takes an integer a, and returns true if \n  \
    \  this integer is a perfect cube, otherwise it returns false.\n    Examples:\n\
    \    >>> isperfectcube(1L)\n    true\n    >>> isperfectcube(2L)\n    false\n \
    \   >>> isperfectcube(-1L)\n    true\n    >>> isperfectcube(64L)\n    true\n \
    \   >>> isperfectcube(0L)\n    true\n    >>> isperfectcube(180L)\n    false\n\
    \    \n*/", "{\n    \n    return a == pow(cast(int) (pow(cast(double)a, 1.0/3.0)),\
    \ 3);\n}", "{\n    long b = 0;\n    long c = 0;\n    if (a == 0)\n    {\n    \
    \    return true;\n    }\n    else if (a > 0)\n    {\n        b = cast(long)cbrt(a);\n\
    \        c = b * b * b;\n        if (c == a)\n        {\n            return true;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    else\n    {\n        b = cast(long)cbrt(a);\n        c = b * b * b;\n\
    \        if (c == a)\n        {\n            return true;\n        }\n       \
    \ else\n        {\n            return false;\n        }\n    }\n}\n/*\n    Write\
    \ a function, which finds the longest \n    substring of input text, which has\
    \ a palindrome as a prefix.\n    Example:\n    >>> longestPalindromePrefix(\"\
    abcd\")\n    \"\"\n    >>> longestPalindromePrefix(\"abba\")\n    \"abba\"\n \
    \   >>> longestPalindromePrefix(\"aba\")\n    \"aba\"\n    >>> longestPalindromePrefix(\"\
    abacaba\")\n    \"abacaba\"\n    >>> longestPalindromePrefix(\"abacabad\")\n \
    \   \"abacaba\"\n    >>> longestPalindromePrefix(\"qwerty\")\n    \"\"\n    >>>\
    \ longestPalindromePrefix(\"abcdedcba\")\n    \"abcdedcba\"\n*/\nstring longestPalindromePrefix(string\
    \ input)\n{\n    size_t length = input.length;\n    string temp = \"\";\n    for\
    \ (size_t i = 0; i < length; i++)\n    {\n        if (input[i] == input[length\
    \ - 1 - i])\n        {\n            temp ~= input[i];\n        }\n        else\n\
    \        {\n            break;\n        }\n    }\n    return temp;\n}\n/*\n  \
    \  Write a function that returns two times the square of any given integer\n \
    \   Example:\n    >>> timesSquare(3)\n    18\n    >>> timesSquare(9)\n    162\n\
    \    >>> timesSquare(0)\n    0\n    >>> timesSquare(-2", "{\n    // Type of literal\
    \ is int\n    auto b = cast(long) pow(a, 1.0/3.0);\n    return (pow(b, 3) == a);\n\
    }\n// UNIT TESTS\nstatic assert(iscube(1L));\nstatic assert(!iscube(2L));\nstatic\
    \ assert(iscube(-1L));\nstatic assert(iscube(64L));\nstatic assert(iscube(0L));\n\
    static assert(!iscube(180L));", "{\n    long cube = 0;\n    for (long i = 0; cube\
    \ <= a; i++)\n    {\n        cube = i * i * i;\n        if (cube == a)\n     \
    \   {\n            return true;\n        }\n    }\n    return false;\n}\n/*",
  "{\n    // TODO: implement the algorithm described above\n    return false;\n}\n\
    \ \n// ============================================================================\n\
    // Tests:\n// ============================================================================\n\
    unittest\n{\n    import std.stdio;\n    import std.exception;\n    // I have changed\
    \ the function name to 'iscube' because I need 'iscubic'\n    // for something\
    \ else (sorry about that).  Also, I made the function\n    // take a long instead\
    \ of an int, as D does not have an 'isqrt' for\n    // ints.\n    assert(iscube(1));\n\
    \    assert(!iscube(2));\n    assert(iscube(-1));\n    assert(iscube(64));\n \
    \   assert(iscube(0));\n    assert(!iscube(180));\n    writeln(\"All tests passed.\"\
    );\n}\n \n/*", "{\n    long cube;\n    cube = (long)pow(a, 1.0/3.0);\n    return\
    \ cube*cube*cube == a;\n}\n/*\n    Write a function that takes an integer a and\
    \ returns true if a is an even number.\n    Note: you may assume the input is\
    \ always valid.\n    Examples:\n    >>> iseven(1L)\n    false\n    >>> iseven(2L)\n\
    \    true\n    >>> iseven(-1L)\n    false\n    >>> iseven(64L)\n    true\n   \
    \ >>> iseven(0L)\n    true\n    >>> iseven(180L)\n    true\n    \n*/", "{\n  \
    \  bool res = false;\n    for (int i = 0; i < a; i++)\n    {\n        if ( i *\
    \ i * i == a)\n        {\n            res = true;\n            break;\n      \
    \  }\n    }\n    return res;\n}", "{\n    long b = 0;\n    foreach(i; 0..~a)\n\
    \    {\n        if(i * i * i == a)\n        {\n            b++;\n        }\n \
    \   }\n    if(b > 0)\n    {\n        return true;\n    }\n    else\n    {\n  \
    \      return false;\n    }\n}\n ", "{\n    // return true if a is a cube of some\
    \ integer number\n    if (a == 0)\n    {\n        return true;\n    }\n    else\
    \ if (a < 0)\n    {\n        if (int(abs(a)) == int(pow(abs(a), 1./3)))\n    \
    \    {\n            return true;\n        }\n        else\n        {\n       \
    \     return false;\n        }\n    }\n    else\n    {\n        if (int(a) ==\
    \ int(pow(a, 1./3)))\n        {\n            return true;\n        }\n       \
    \ else\n        {\n            return false;\n        }\n    }\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "{\n    long b = cast(long)\
    \ floor( pow(a, 1.0/3.0) );\n    return b*b*b == a;\n}\n/*", "{\n    long b =\
    \ round(pow(a, 1.0/3.0));\n    long cubed = b*b*b;\n    return cubed == a;\n}",
  "{\n    if (a == 0) \n        return true;\n    return (int)pow(floor(pow(a,(1/3.0))),3)\
    \ == a;\n}", "{\n    \n   return a == 0L or is(typeof(pow(a, 1.0/3)) == double);\n\
    }", "{\n    return a > 0 ? (int) pow(a, 1.0 / 3) == pow(a, 1.0 / 3) : true;\n\
    }\n/*\n    Write a function that takes a string s and returns the number of \n\
    \    occurences of the letter a in the string.\n    >>> lettercount('mamamma')\n\
    \    4\n    >>> lettercount('papa')\n    1\n    >>> lettercount('aaaaa')\n   \
    \ 5\n    >>> lettercount('b')\n    0\n    >>> lettercount('')\n    0\n*/", "{\n\
    \treturn cube(cast(long)pow(a, 1.0 / 3.0)) == a;\n}", "{\n    return 0 <= a &&\
    \ a == rint(cbrt(a));\n}", "{\n    return (Math.cbrt(a) % 1 == 0) ? true : false;\n\
    }", "{\n    long tst = long(pow(abs(a), 1.0/3.0));\n    return tst*tst*tst ==\
    \ a;\n}", "{\n    return a>=0 && cubeRoot(a)*cubeRoot(a)*cubeRoot(a)==a;\n}\n\
    /*\n# No.13\n*/\n//int twoSum(int[] nums, int target)", "{\n    if (a > 0) \n\
    \    {\n        return pow(cast(real)a,1.0/3.0) % 1.0 == 0.0;\n    }\n    else\
    \ \n    {\n        return pow(cast(real)a,1.0/3.0) % 1.0 == 0.0;\n    }\n}", "{\n\
    \    return cast(double)a == pow(cast(double)ceil(pow(cast(double)a, 1.0/3.0)),\
    \ 3.0);\n}", "{\n    // the answer is the \"round\" of the cube root of the number\n\
    \    return typeof(pow(a, 1.0/3)) == double && a == cast(long)pow(a, 1.0/3);\n\
    }", "{\n    if (a > 0)\n    {\n        long t = (long) round(pow(a, 1 / 3.0));\n\
    \        if (t * t * t == a)\n            return true;\n    }\n    else if (a\
    \ == 0)\n        return true;\n    else\n    {\n        long t = (long) round(pow(-a,\
    \ 1 / 3.0));\n        if (t * t * t == -a)\n            return true;\n    }\n\
    \    return false;\n}", "{\n    // this solution is based on the fact that\n \
    \   // for any integer n^3 and n^4, n^3 < n^4\n    // so if n^3 <= x <= n^4, we\
    \ can conclude that\n    // x is the cube of n\n    if (a == 0L)\n        return\
    \ true;\n    long n = 1L;\n    long ncubed = 1L;\n    long ncubedplusone = 2L;\n\
    \    while (ncubedplusone < a) {\n        n++;\n        ncubed = n * n * n;\n\
    \        ncubedplusone = (n + 1) * (n + 1) * (n + 1);\n    }\n    return ncubed\
    \ <= a && a <= ncubedplusone;\n}", "{\n    return (pow(a,1.0/3.0))%1 == 0;\n}\n\
    /*\n    Write a function that takes a floating-point number as a parameter\n \
    \   and calculates the number of digits that are after the decimal point.\n  \
    \  Examples:\n    >>> numofdecimaldigits(1.0)\n    0\n    >>> numofdecimaldigits(1.5)\n\
    \    1\n    >>> numofdecimaldigits(1.2345)\n    4\n*/", "{\n    long long n =\
    \ abs(a);", "{\n    return iscube!long(a);\n}", "{\n    return a == 0L || a ==\
    \ 1L || a == -1L || (long)pow(cbrt(a), 3) == a;\n}", "{\n    long res = (long)pow(a,\
    \ 1.0 / 3.0);\n    return (a == res * res * res);\n}", "{\n    long x = (long)pow(a,\
    \ 1.0/3.0);\n    if(x * x * x == a)\n        return true;\n    return false;\n\
    }", "{\n    return a % 2 == 0 || a % 3 == 0 || a % 4 == 0;\n}", "{\n    return\
    \ (a == 0) || (a > 0 && float.isinteger(math.cbrt(a)));\n}", "{\n    if (a==0)\n\
    \        return true;\n    else if (a==1)\n        return true;\n    else if (a<0)\n\
    \        return iscube(-a);\n    else\n    {\n        long x = (long)ceil(pow(a,1.0/3.0));\n\
    \        if (x*x*x==a)\n            return true;\n        else\n            return\
    \ false;\n    }\n}", "{\n    return floor(pow(a, 1/3.0)) == pow(a, 1/3.0);\n}\n\
    /*\n    Show what will be the result of the following program and why.\n    int\
    \ a = 5;\n    int &b = a;\n    int *p = &a;\n    *p = b = 2;\n    cout << a <<\
    \ \", \" << b << \", \" << *p << endl;\n*/\n//Will print 2, 2, 2\n/*\n    What\
    \ will be the result of the following program and why.\n    int a = 5;\n    int\
    \ &b = a;\n    int *p = &a;\n    *p = b = a = 2;\n    cout << a << \", \" << b\
    \ << \", \" << *p << endl;\n*/\n//Will print 2, 2, 2\n/*\n    Write a function\
    \ that takes an integer a and returns true \n    if this ingeger is a square of\
    \ some integer number.\n    Note: you may assume the input is always valid.\n\
    \    Examples:\n    >>> issquare(1L)\n    true\n    >>> issquare(2L)\n    false\n\
    \    >>> issquare(-1L)\n    true\n    >>> issquare(64L)\n    true\n    >>> issquare(0L)\n\
    \    true\n    >>> issquare(180L)\n    false\n*/", "{\n\tassert(a >= 0);\n\treturn\
    \ isPowerOfThree(a);\n}", "{\n    return a == pow(cast(long)round(pow(a, 1.0 /\
    \ 3.0)), 3L);\n}", "{\n    long cbrt(long);\n    return a == 0 || (a < 0 && -a\
    \ == cbrt(-a)) || a == cbrt(a);\n}", "{\n    long tmp=a;\n    if(a<0)\n    {\n\
    \        tmp=-a;\n    }\n    for(size_t i=0;i<tmp;i++)\n    {\n        if(tmp==i*i*i)\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    /*\n    Write a function that takes two integers a and b and returns \n    true\
    \ if one of them is positive and the other is negative.\n    Examples:\n    >>>\
    \ haveoppsigns(1L, -1L)\n    true\n    >>> haveoppsigns(1L, 1L)\n    false\n \
    \   >>> haveoppsigns(-1L, -1L)\n    false\n    >>> haveoppsigns(0L, -1L)\n   \
    \ true\n    >>> haveoppsigns(0L, 1L)\n    true\n    >>> haveoppsigns(1L, 0L)\n\
    \    true\n    >>> haveoppsigns(-1L, 0L)\n    true\n*/", "{\n    if (a == 0)\n\
    \        return true;\n    else if (a == 1)\n        return true;\n    else if\
    \ (a < 0)\n        return iscube(-a);\n    auto x = ((long)pow(a, (1.0 / 3.0)));\n\
    \    return x * x * x == a;\n}", "{\n  return (a == 0) || ((a % 2 == 0 || a %\
    \ 2 == -2) && cubeRoot(abs(a)) * cubeRoot(abs(a)) * cubeRoot(abs(a)) == a);\n}",
  "{\n    if (a==0) return true;\n    if (a<0) a*=-1;\n    if (cast(long)pow(cast(double)a,\
    \ 1.0/3.0) == pow(cast(double)a, 1.0/3.0))\n        return true;\n    return false;\n\
    }", "{\n    return a == 0 || floor(pow(abs(a), 1.0/3.0))**3 == abs(a);\n}", "{\n\
    \    return ispow(a,3);\n}", "{\n    return cast(bool)(a == 0L || (((long)pow(a,\
    \ (1.0/3.0))) * ((long)pow(a, (1.0/3.0))) * ((long)pow(a, (1.0/3.0))) == a));\n\
    }", "{\n    long temp = isqrt(a);\n    if (temp*temp*temp == a)\n    {\n     \
    \   return true;\n    }\n    return false;\n}", "{\n    long b = 0;\n    for (b\
    \ = 0; b < a; b++)\n    {\n        if (pow(b, 3) == a)\n        {\n          \
    \  return true;\n        }\n    }\n    return false;\n}", "{\n    return (i64)pow(abs(a),\
    \ 1.0/3.0) == pow(abs(a), 1.0/3.0);\n}\n ", "{\n    double d = std.math.sqrt(a);\n\
    \    double cubeRoot = std.math.round(d);\n    return a == cubeRoot * cubeRoot\
    \ * cubeRoot;\n}\n/*\n    Write a function that takes a string as input and returns\
    \ a long that is the \n    number of unbracketed comments in the string.\n   \
    \ Note: \"unbracketed\" here means that the comment starts with // or /*, but\n\
    \    its end is not signalled by */\n    Note: a \"comment\" always starts with\
    \ // or /* and ends with the next line \n    break (newline symbol).\n    Examples:\n\
    \    >>> unbracketed_comments_count(\"\")\n    0L\n    >>> unbracketed_comments_count(\"\
    //sfsf\\nsfsfffsfs\")\n    1L\n    >>> unbracketed_comments_count(\"/*sfsf\\nsfsfffsfs\"\
    )\n    1L\n    >>> unbracketed_comments_count(\"/*sfsf\\nsfsfffsfs\\n*/sfsfsf\"\
    )\n    1L\n    >>> unbracketed_comments_count(\"//sfsf\\nsfsfffsfs\\n/*\\nsfsfsf\"\
    )\n    2L\n*/\nlong unbracketed_comments_count(string a)\n{\n    import std.string;\n\
    \    import std.regex;\n    import std.algorithm;\n    import std.range;\n   \
    \ import std.conv;\n    int result = 0;\n    while(true)\n    {\n        int idx\
    \ = a.find(\"//\");\n        if(idx == -1)\n            break;\n        a = a[idx+2..$];\n\
    \        result++;\n    }\n    while(true)\n    {\n        int idx = a.find(\"\
    /*\");\n        if(idx == -1)\n            break;\n        a = a[idx+2..$];\n\
    \        result++;\n    }\n    return result;\n}\n/*\n    Write a function that\
    \ takes an array of numbers as input and returns a long\n    which is the index\
    \ of the first entry in the array that is greater than its \n    right neighbour.\n\
    \    If there is", "{\n    return (ispositivge(a) || a == 0) && !(a % cbrt(a)\
    \ != 0);\n}", "{\n  return modf(cbrt(a)) == 0.0;\n}", "{\n\treturn cast(bool)(a\
    \ % 3 == 0 || a == 0);\n}", "{\n    double x = cbrt(a);\n    if (x == ceil(x))\n\
    \        return true;\n    else\n        return false;\n}", "{\n    return (cubeRoot(a)\
    \ - floor(cubeRoot(a))) == 0.0;\n}", "{\n    return a == cbrt(a) * cbrt(a) * cbrt(a);\n\
    }", "{\n    // Note: if you need to work with float, \n    // use std.math.sqrt\
    \ instead of the root function.\n    // long b = Math.root(a, 3);\n    // return\
    \ a == b * b * b;", "{\n    if (a == 0)\n        return true;\n    else\n    \
    \    return a % 3 == 0 && iscube(a / 3);\n}", "{\n    return Math.isInt(Math.cbrt(a));\n\
    }", "{\n    // if 'a' is a cube of some integer number,\n    // then 'a' must\
    \ be divided by some power of 3 without a reminder\n    return (a % 3) == 0;\n\
    }", "{\n    bool ret = false;\n    if( a == 0 || a == 1 || a == -1 ) ret = true;\n\
    \    else if( a > 0 )\n    {\n        long end = long(pow(a,1.0/3.0));\n     \
    \   foreach(i;0 .. end)\n        {\n            if( i*i*i == a )\n           \
    \ {\n                ret = true;\n                break;\n            }\n    \
    \    }\n    }\n    else\n    {\n        long end = long(pow(-a,1.0/3.0));\n  \
    \      foreach(i;0 .. end)\n        {\n            if( i*i*i == -a )\n       \
    \     {\n                ret = true;\n                break;\n            }\n\
    \        }\n    }\n    return ret;\n}", "{\n     //1L is the same as 1\n     if(a\
    \ == 1L) \n     {\n         return true;\n     }\n     if(a < 0L)\n     {\n  \
    \       a = abs(a);\n     }\n     if(a == 0L)\n     {\n         return true;\n\
    \     }\n     //if(cast(long) pow(cast(double) a, 1.0 / 3.0) == a) \n     if(cast(long)\
    \ pow(cast(double) a, 0.33333333333333333333) == a) \n     {\n         return\
    \ true;\n     }\n     return false;\n}", "{\n    long num = a;\n    double x =\
    \ 0.0;\n    while(a > 0)\n    {\n        if(a % 3 == 0)\n        {\n         \
    \   a /= 3;\n            x++;\n        }\n        else\n        {\n          \
    \  return false;\n        }\n    }\n    long res = (long)Math.pow(3, x);\n   \
    \ if(res == num)\n    {\n        return true;\n    }\n    else\n    {\n      \
    \  return false;\n    }\n}\nstatic class Program\n{\n    static void Main()\n\
    \    {\n        int num = int.Parse(Console.ReadLine());\n        bool res = iscube(num);\n\
    \        Console.WriteLine(res);\n    }\n}", "{\n    if (a == 0L)\n        return\
    \ true;\n    if (a < 0L)\n        a = -a;\n    double b = cbrt(a);\n    if (b\
    \ == floor(b))\n        return true;\n    return false;\n}", "{\n    return a\
    \ == 0 || (a > 0 && pow(a, 1.0/3.0) % 1 == 0);\n}", "{\n    return a == pow(cast(int)\
    \ (cbrt(a) + 0.5), 3);\n}", "{\n    if (a == 0)\n        return true;\n    if\
    \ (a % 2 == 0) \n    {\n        return false;\n    } \n    else \n    {\n    \
    \    long left = long(pow(a, 1.0 / 3.0));\n        if (left * left * left == a)\n\
    \            return true;\n        else\n            return false;\n    }\n}",
  "{\n    // Make a new optional long\n    auto x = to!long(pow(a, 1.0/3.0));\n  \
    \  // Return true if the cube root is equal to the cube\n    return x.isSome &&\
    \ a == x.get * x.get * x.get;\n}", "{\n    //TODO\n    if (a == 1 || a == -1 ||\
    \ a == 0) {\n        return true;\n    }\n    if (a % 2 == 0) {\n        return\
    \ false;\n    }\n    double result = cbrt(a);\n    if (result == int(result))\
    \ {\n        return true;\n    }\n    return false;\n}", "{\n    long result =\
    \ round(cbrt(a));\n    if (result*result*result == a) return true;\n    return\
    \ false;\n}\n ", "{\n    return floor(pow(a, 1.0/3.0)) == ceil(pow(a, 1.0/3.0));\n\
    }", "{\n    if (a == 0) return true;\n    if (a < 0) a = -a;\n    long pow = to!long(pow(a,\
    \ 1.0 / 3.0));\n    return a == pow * pow * pow;\n}", "{\n    auto v=typeof(a)(pow(double(abs(a)),1.0/3.0));\n\
    \    if (a==0) return true;\n    if (abs(v*v*v)!=abs(a)) return false;\n    if\
    \ (a<0) return (v*v*v==a && (v%2)!=0);\n    return true;\n}", "{\n    if (a ==\
    \ 0L) \n    {\n        return true;\n    }\n    auto c = cast(long)cbrt(a);\n\
    \    return c*c*c == a;\n}", "{\n    if (a < 0) \n    {\n        a = -a;\n   \
    \ }\n    long x = isqrt(a);\n    long val = x * x * x;\n    return val == a;\n\
    }", "{\n    return a == cast(int) (pow(a, 1.0/3.0));\n}", "{\n    // your code\
    \ here\n    if (a == 0)\n        return true;\n    if (a % 2 == 0)\n        return\
    \ false;\n    long b = ceil(pow(a, 1.0/3.0));\n    return b*b*b == a;\n}", "{\n\
    \    return a==0?true:a>0?(long)abs(pow(a,1.0/3))==pow(a,1.0/3):(long)abs(pow(a,1.0/3))==pow(a,1.0/3);\n\
    }", "{\n    bool result;\n    if (a<0) \n    {\n        a*=-1;\n    }\n    long\
    \ lower=1;\n    long upper=(long)pow(a,1/3.0);\n    if (a==0) \n    {\n      \
    \  result=true;\n    }\n    else if (a>0) \n    {\n        if (a==lower*lower*lower)\
    \ \n        {\n            result=true;\n        }\n        else if (a==upper*upper*upper)\
    \ \n        {\n            result=true;\n        }\n        else \n        {\n\
    \            result=false;\n        }\n    }\n    return result;\n}\nversion(unittest)\n\
    {\n    static assert(iscube(1L));\n    static assert(!iscube(2L));\n    static\
    \ assert(iscube(-1L));\n    static assert(iscube(64L));\n    static assert(iscube(0L));\n\
    \    static assert(!iscube(180L));\n    static assert(iscube(64L));\n    static\
    \ assert(iscube(27L));\n    static assert(iscube(216L));\n    static assert(iscube(125L));\n\
    \    static assert(iscube(216L));\n    static assert(iscube(0L));\n    static\
    \ assert(iscube(1L));\n    static assert(iscube(-1L));\n    static assert(iscube(-27L));\n\
    \    static assert(iscube(-125L));\n    static assert(iscube(-216L));\n    static\
    \ assert(iscube(-729L));\n    static assert(iscube(-1000L));\n    static assert(iscube(-531441L));\n\
    \    static assert(iscube(-1953125L));\n    static assert(iscube(-1000000L));\n\
    \    static assert(iscube(-9765625L));\n    static assert(iscube(-9261L));\n \
    \   static assert(iscube(-15625L));\n    static assert(iscube(-17576L));\n   \
    \ static assert(iscube(-19683L));\n    static assert(iscube(-387420489L));\n \
    \   static assert(iscube(-43046721L));\n", "{\n    // your code here\n    int\
    \ cubeRoot = int(cbrt(a));\n    return cubeRoot * cubeRoot * cubeRoot == a;\n}",
  "{\n    return is(typeof(cbrt(a))) && cbrt(a) == cast(long)cbrt(a);\n}", "{\n  \
    \  if (a == 0)\n        return true;\n    double i = pow(a, 1.0 / 3.0);\n    long\
    \ j = i;\n    return i == j;\n}", "{\n    long s;\n    //long   r = a % 2;\n \
    \   long r = modulo(a, 2);\n    if (a >= 0) \n    {\n        s = sqrt(a);\n  \
    \      return (r == 0 && s * s * s == a);\n    }\n    else \n    {\n        s\
    \ = sqrt(-a);\n        return (r == 0 && s * s * s == -a);\n    }\n}", "{\n  \
    \  long r = powl(a, 1.0 / 3.0);\n    if (r*r*r == a)\n        return true;\n \
    \   else\n        return false;\n}", "{\n    return typeTuple(a) == typeTuple(pow(round(pow(a,\
    \ 1.0/3.0)), 3));\n}", "{\n    return abs(a) == cast(long)pow(abs(a), 1.0/3.0);\n\
    }", "{\n    return pow(cbrt(a), 3) == a;\n}", "{\n    bool ret = false;\n    double\
    \ root = (a != 0) ? pow(a,1.0/3.0) : 0;\n    long r = cast(long)root;\n    if(\
    \ r * r * r == a )\n        ret = true;\n    return ret;\n}", "{\n    long x =\
    \ a > 0 ? a : -a;\n    long r = (long)pow(x, 1./3.);\n    return r * r * r ==\
    \ x;\n}", "{\n    return is(typeof(cbrt(a) - cast(int)cbrt(a) == 0));\n}", "{\n\
    \    if (a == 0) return true;\n    long b = abs(a);\n    long y = pow(b, 1./3);\n\
    \    return y*y*y == b;\n}\n \n/*\n    Main function\n*/", "{\n    return ispow(abs(a),\
    \ 3L);\n}", "{\n    if (a == 0)\n        return true;\n    if (a < 0)\n      \
    \  a = -a;\n    return double.approxEqual(pow(a, 1.0 / 3.0), trunc(pow(a, 1.0\
    \ / 3.0)));\n}", "{\n    // a is cube if and only if n^3 is integer\n    long\
    \ n = (long)cbrt(a);\n    return n*n*n == a;\n}", "{\n    return a == cbrt(a)\
    \ * cbrt(a) * cbrt(a);\n}", "{\n    // your code goes here\n}\n/*\n    Write a\
    \ function that takes an integer and returns this integer\n    in reverse order.\
    \ \n    Examples:\n    >>> reverse(12345)\n    54321\n    >>> reverse(100500)\n\
    \    5001\n*/", "{\n    auto y = cast(long)pow(a, 1.0 / 3.0);\n    if (y*y*y ==\
    \ a)\n        return true;\n    return false;\n}", "{\n    if (a == 0)\n     \
    \   return true;\n    double x = abs(a);\n    return pow(floor(pow(x, 1.0 / 3.0)),\
    \ 3) == x;\n}", "{\n    \n    a = abs(a);\n    long x = (long) (std.math.cbrt(a));\n\
    \    long cube = x * x * x;\n    if (cube == a) {\n        return true;\n    }\n\
    \    return false;\n}\n// write iscube", "{\n    \n    if (a < 0)\n    {\n   \
    \     a = -a;\n    }\n    \n    if (a == 0)\n    {\n        return true;\n   \
    \ }\n    \n    long x = static_cast!long(pow(a, 1 / 3.0));\n    \n    return x\
    \ * x * x == a;\n    \n}", "{\n    //cbrt is a function in the std.math module\n\
    \    return (is(typeof(cbrt(a)) == double)); \n    //returns true if the type\
    \ of the expression is a double\n}", "{\n    int cube;\n    cube = round(pow(abs(a),1.0/3.0));\n\
    \    return (a == cube*cube*cube);\n}", "{\n    if (a == 0) return true;\n   \
    \ if (a < 0) a = -a;\n    long x = (long)pow(a, 1.0/3.0);\n    return x*x*x ==\
    \ a;\n}", "{\n    return a < 0 ? iscube(-a) : int(cube_root(a)) == cube_root(a);\n\
    }", "{\n    return a > 0 ? (pow(a,1/3f)%1 == 0 ? true : false) : true;\n}", "{\n\
    \    long c = cast(long)pow(a, 1/3.0);\n    return c*c*c == a;\n}", "{\n    long\
    \ b;\n    for (long i = 1; i < a / 2; i++) \n    {\n        b = (long)pow(i, 3);\n\
    \        if (b == a)\n            return true;\n    }\n    return false;\n}",
  "{\n    double cbrt = sqrt(a);\n    return cbrt == rint(cbrt);\n}\n/*\n    The function\
    \ below takes the two parameters and returns the number of numbers that are larger\
    \ than the first parameter and smaller than the second one (including both the\
    \ parameters).\n    If the function is called with the first parameter being larger\
    \ than the second one, return 0.\n    Examples:\n    >>> countnumbers(3, 5)\n\
    \    2\n    >>> countnumbers(5, 3)\n    0\n    >>> countnumbers(1, 1)\n    0\n\
    \    >>> countnumbers(5, 8)\n    3\n    >>> countnumbers(1, 10)\n    9\n    >>>\
    \ countnumbers(5, 5)\n    0\n*/\nlong countnumbers(long a, long b)\n{\n    if\
    \ (a > b) {\n        return 0;\n    } else {\n        return b - a - 1;\n    }\n\
    }\n/*\n    Write a function that checks if two given numbers are relatively prime.\
    \ Two numbers are relatively prime if their only common divisor is 1.\n    Example:",
  "{\n    static if (__traits(compiles, typeof(long.isNaN)))\n    {\n        if (a.isNaN)\n\
    \            return false;\n    }\n    if (a < 0)\n        a = -a;\n    if (a\
    \ == 0)\n        return true;\n    long r = cast(long) sqrt(a);\n    return r\
    \ * r * r == a;\n}", "{\n    return (a % cube(cast(long)sqrt(a)) == 0);\n}", "{\n\
    \    return (std.math.cbrt(a) * std.math.cbrt(a) * std.math.cbrt(a)) == a;\n}",
  "{\n    return a == cube(cast(long)sqrt(a));\n}", "{\n    auto cbrt = (long)pow(cast(double)a,\
    \ 1.0/3.0);\n    return cbrt * cbrt * cbrt == a;\n}", "{\n    if (a == 0) return\
    \ true;\n    if (a == 1) return true;\n    if (a < 0) a = abs(a);\n    double\
    \ b = pow(a, 1.0/3.0);\n    return (b == int(b));\n}", "{\n    const ispoweroftwo\
    \ = (long n) {\n        if (n <= 0) return false;\n        while(n % 2 == 0) n\
    \ /= 2;\n        return n == 1;\n    };\n    return a == 0 || (ispoweroftwo(a)\
    \ && a % 8 == 1);\n}\n/*", "{\n    bool ret;\n    if (a < 0)\n    {\n        ret\
    \ = true;\n    }\n    else\n    {\n        auto b = long(pow(float(a), 1.0/3.0));\n\
    \        if (b * b * b == a)\n        {\n            ret = true;\n        }\n\
    \        else\n        {\n            ret = false;\n        }\n    }\n    return\
    \ ret;\n}\n/*\n    Write a function that takes a string and returns a tuple of\
    \ \n    3 elements containing the count of lowercase, uppercase and \n    neither\
    \ case characters.\n    Note: you may assume the input is always valid.\n    Examples:\n\
    \    >>> count(\"abcABC\")\n    (3, 3, 0)\n    >>> count(\"aBc\")\n    (1, 2,\
    \ 0)\n    >>> count(\"123\")\n    (0, 0, 3)\n    >>> count(\"\")\n    (0, 0, 0)\n\
    \    >>> count(\"aaa!!!!!!BBBB!!!!!!!\")\n    (3, 4, 8)\n    >>> count(\"Aa\"\
    )\n    (1, 1, 0)\n*/\nauto count(string a) \n{\n    auto lower = a.count!(char.isLower)();\n\
    \    auto upper = a.count!(char.isUpper)();\n    auto neither = a.count!(c =>\
    \ !char.isUpper(c) && !char.isLower(c))();\n    return tuple(lower, upper, neither);\n\
    }\n/*\n    Write a function that takes a list of integers and two integers \n\
    \    x and y and returns the number of elements that are \n    greater than y\
    \ and less than x\n    Note: you may assume the input is always valid.\n    Examples:\n\
    \    >>> count_range([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4, 7)\n    3\n    >>> count_range([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10], 1, 20)\n    10\n    >>> count_range([1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10], 10, 1)\n", "{\n    return (cast(long)pow(cast(double)a,\
    \ 1.0/3.0)) * (cast(long)pow(cast(double)a, 1.0/3.0)) * (cast(long)pow(cast(double)a,\
    \ 1.0/3.0)) == a;\n}", "{\n    long left = 1L;\n    long right = a;\n    while\
    \ (left <= right)\n    {\n        auto mid = (left + right) / 2;\n        auto\
    \ res = mid * mid * mid;\n        if (res == a)\n            return true;\n  \
    \      else if (res < a)\n            left = mid + 1;\n        else\n        \
    \    right = mid - 1;\n    }\n    return false;\n}", "{\n    return a == 0 ||\
    \ abs(cbrt(a) % 1) < 0.0001;\n}", "{\n    long n = (long) exp(log(a) / 3);\n \
    \   return (n * n * n) == a;\n}", "{\n    if (a == 0L)\n        return true;\n\
    \    else if (a < 0L)\n        return iscube(-a);\n    else {\n        auto b\
    \ = a;\n        while (b < a * a)\n            b += b;\n        return b == a\
    \ * a;\n    }\n}\n/*\n    Write a function that takes an integer n and returns\
    \ all primes less than n.\n    Note: prime numbers start from 2.\n    Examples:\n\
    \    >>> primes(2)\n    [2]\n    >>> primes(10)\n    [2, 3, 5, 7]\n    >>> primes(20)\n\
    \    [2, 3, 5, 7, 11, 13, 17, 19]\n    >>> primes(1)\n    []\n*/", "{\n    return\
    \ (cbrt(a) - floor(cbrt(a))) == 0;\n}", "{\n    long x = powl(a, 1.0L / 3.0L);\n\
    \    return powl(x, 3L) == a;\n}", "{\n    if (a == 0L)\n        return true;\n\
    \    long k = pow(a, 1.0/3.0);\n    return k * k * k == a;\n}", "{\n    return\
    \ (long)cbrt(a) == cbrt(a);\n}", "{\n    bool result = false;\n    long max =\
    \ a;\n    long min = -a;\n    for (long i = min; i < max; i++){\n        if (i\
    \ * i * i == a){\n            result = true;\n            break;\n        }\n\
    \    }\n    return result;\n}", "{\n    return a == 0 or ispow(a, 1/3.0);\n}",
  "{\n    double b = a;\n    long c = a;\n    double result = pow(b, 1.0/3.0);\n \
    \   long d = result;\n    double x = result - d;\n    if (x == 0)\n    {\n   \
    \     return true;\n    }\n    else \n    {\n        return false;\n    }\n}",
  "{\n    auto cbrt = cast(long)pow(a, 1.0/3.0);\n    return cbrt * cbrt * cbrt ==\
    \ a;\n}", "{\n    //long m = (long)ceil(exp(log(a)/3.0));\n    long m = (long)ceil(pow(a,\
    \ 1.0/3.0));\n    return pow(m, 3) == a;\n}", "{\n    //find the cube root of\
    \ a \n    //int cuberoot = cbrt(a);\n    //cube the cuberoot\n    //return a ==\
    \ cuberoot * cuberoot * cuberoot;\n    import std.algorithm : map;\n    alias\
    \ ints = iota(1, 10);\n    auto cubes = ints.map!(a => (a^3));\n    return cubes.canFind(a);\n\
    }", "{\n    return a == 0L || a == 1L || a == -1L || (a > 0L && round(cbrt(a))\
    \ == cbrt(a));\n}", "{\n    if (a < 0)\n        a = -a;\n    foreach (i; 1L ..\
    \ a + 1L)\n    {\n        if (i * i * i == a)\n            return true;\n    }\n\
    \    return false;\n}\n/*\n    Write a function that takes a string s and returns\
    \ true if s \n    is a substring of some palindrome.\n    Examples:\n    >>> ispalindromesubstring(\"\
    anna\")\n    true\n    >>> ispalindromesubstring(\"ann\")\n    false\n    >>>\
    \ ispalindromesubstring(\"annaanna\")\n    true\n    >>> ispalindromesubstring(\"\
    a\")\n    true\n    >>> ispalindromesubstring(\"bbb\")\n    true\n    >>> ispalindromesubstring(\"\
    \")\n    true\n*/", "{\n    return a == 0L || a == 1L || sqrt(abs(a)) % 1 == 0;\n\
    }", "{\n    //cbrt(a);\n    if (a==0)\n        return true;\n    else if (a<0)\n\
    \        return iscube(-a);\n    else \n    {\n        float x = cbrt(a);\n  \
    \      if (x!=long(x))\n            return false;\n        else \n           \
    \ return true;\n    }\n}", "{\n    long cub = cbrt(a);\n    return (cub * cub\
    \ * cub == a);\n}", "{\n\treturn a < 0 ? cubeRoot(a) * cubeRoot(a) * cubeRoot(a)\
    \ == a : cubeRoot(a) * cubeRoot(a) * cubeRoot(a) == a;\n}", "{\n    auto result\
    \ = (long)round(pow(a, 1.0/3.0));\n    return pow(result, 3) == a;\n}", "{\n \
    \   if (a >= 0) {\n        long b = (long)cbrt(a);\n        if (b * b * b == a)\n\
    \            return true;\n    } else {\n        long b = (long)cbrt(-a);\n  \
    \      if (b * b * b == -a)\n            return true;\n    }\n    return false;\n\
    }\n// NOTE: The following code is not intended to be readable.\n// It's written\
    \ in a way that minimizes compilation times for\n// the auto-grading system.",
  "{\n    long c = abs(a);\n    long i = cbrt(c);\n    return c==i*i*i;\n}", "{\n\
    \    // your code here\n}\n/*", "{\n    return floor(cbrt(a)) == cbrt(a);\n}",
  "{\n    return a==0L || a==1L || modf(pow(abs(a),1.0/3.0))==0.0;\n}\n/*\n    Write\
    \ a function that takes an integer a and returns true if this integer is a square\
    \ of some integer number.\n    Note: you may assume the input is always valid.\n\
    \    Examples:\n    >>> issquare(1L)\n    true\n    >>> issquare(2L)\n    false\n\
    \    >>> issquare(-1L)\n    true\n    >>> issquare(64L)\n    true\n    >>> issquare(0L)\n\
    \    true\n    >>> issquare(180L)\n    false\n*/", "{\n    return a == cast(long)pow(cast(double)a,\
    \ 1.0/3.0);\n}", "{\n    foreach(i; 0 .. 100)\n    {\n        if(a == i*i*i)\n\
    \            return true;\n    }\n    return false;\n}", "{\n    if (a == 0)\n\
    \        return true;\n    auto n = (long)pow(abs(a), 1.0 / 3.0);\n    return\
    \ (pow(n, 3) == abs(a));\n}", "{\n    return a == 0 || (abs(a) % (long)pow(a,\
    \ 1.0 / 3.0) == 0);\n}", "{\n    if (a == 0)\n        return true;\n    else if\
    \ (a < 0)\n        return iscube(-a);\n    else\n    {\n        double z = a;\n\
    \        double y = cbrt(z);\n        double yy = trunc(y);\n        if (abs(y\
    \ - yy) < 0.000001)\n            return true;\n        else\n            return\
    \ false;\n    }\n}", "{\n    return a == 0 || \n           a == pow(cast(long)pow(abs(a),1.0/3.0),3);\n\
    }", "{\n    bool res = false;\n    if (a > 0) {\n        double d =  Math.pow(a,\
    \ 1/3);\n        res = d == (long)d;\n    }\n    else {\n        res = a == 0\
    \ || iscube(-a);\n    }\n    return res;\n}", "{\n    return a!=0 && a == pow(int(cbrt(a)),\
    \ 3);\n}", "{\n    auto cub = a * a * a;\n    if (cub == a)\n        return true;\n\
    \    else\n        return false;\n}", "{\n    // TODO: do your magic here!\n \
    \   return 0;\n}", "{\n    a = abs(a);\n    long res = (long)pow(a, 1.0/3.0);\n\
    \    return (long)pow(res, 3) == a;\n}", "{\n    int a1 = abs(a);\n    int a2\
    \ = floor(cbrt(a1));\n    long a3 = a2 * a2 * a2;\n    return a3 == a1;\n}", "{\n\
    \    return (ceil(pow(abs(a), 1/3.0)) == floor(pow(abs(a), 1/3.0)));\n}", "{\n\
    \    static assert(is(typeof(~a)));\n    return a ~ 0L && a % cast(typeof(a))(cbrt(a))\
    \ == 0L;\n}\n/*\n    Write a function that takes a string and returns a new string\
    \ \n    where all the vowels in the original string are capitalized.\n    >>>\
    \ capitalize_vowels(\"Hello world!\")\n    \"HEllO wOrld!\"\n    >>> capitalize_vowels(\"\
    \")\n    \"\"\n    >>> capitalize_vowels(\"a\")\n    \"A\"\n    >>> capitalize_vowels(\"\
    you\")\n    \"yOU\"\n    >>> capitalize_vowels(\"AeIoU\")\n    \"AEIOU\"\n*/\n\
    string capitalize_vowels(string str)\n{\n    string result = str;\n    foreach(i,\
    \ c; str) {\n        if(c.toLower() in ['a', 'e', 'i', 'o', 'u'])\n          \
    \  result[i] = c.toUpper();\n    }\n    return result;\n}\n/*\n    Write a function\
    \ that takes an integer n and returns a tuple of two \n    values that represent\
    \ the next two elements of the Fibonacci sequence \n    (consider Fibonacci sequence\
    \ starts with 1,1).\n    >>> fib(0)\n    (1, 1)\n    >>> fib(1)\n    (1, 2)\n\
    \    >>> fib(5)\n    (8, 13)\n    >>> fib(10)\n    (89, 144)\n*/\nTuple!(long,\
    \ long) fib(long n)\n{\n    long a = 1L, b = 1L;\n    for(; n > 0; --n) {\n  \
    \      auto t = a;\n        a = b;\n        b += t;\n    }\n    return tuple(a,\
    \ b);\n}\n/*\n    Write a function that takes a string and returns a new string\
    \ \n    where all the 'camelCase' (https://en.wikipedia.org/wiki/Camel_case) \n\
    \    words are converted to 'snake_case' (https://en.wikipedia.org/wiki/Snake_case).\n\
    \    >>> camel_to_", "{\n    return a == 0 || (long)pow(floor(pow(a, 1.0/3.0)),\
    \ 3) == a;\n}", "{\n    static assert(is(typeof(a*a*a)) == is(typeof(a)));", "{\n\
    \    long[] list = new long[1000];\n    long x = 0;\n    for (int i = 0; i < list.length;\
    \ i++)\n    {\n        list[i] = x * x * x;\n        x++;\n    }\n    bool ans\
    \ = false;\n    for (int i = 0; i < list.length; i++)\n    {\n        if (list[i]\
    \ == a)\n        {\n            ans = true;\n        }\n    }\n    return ans;\n\
    }", "{\n    /*\n    // Your answer\n    return false;\n    */\n    /*\n    //\
    \ Your answer\n    return true;\n    */\n    /*\n    // Your answer\n    // use\
    \ these functions: cast, sqrt, trunc, ceil, floor\n    return true;\n    */\n\
    \    /*\n    // Your answer\n    // use these functions: cast, pow, trunc, ceil,\
    \ floor\n    return true;\n    */\n    // My answer\n    return (cast(long)trunc(pow(a,\
    \ 1.0 / 3.0)) == pow(a, 1.0 / 3.0));\n}", "{\n    long temp;\n    temp = (long)pow(a,(1/3));\n\
    \    if((temp*temp*temp) == a)\n        return true;\n    else\n        return\
    \ false;\n}", "{\n    if (a == 0L) return true;\n    if (a < 0L) a = -a;\n   \
    \ long cbrt_a = cast(long) floor(cbrt(a));\n    return a == cbrt_a * cbrt_a *\
    \ cbrt_a;\n}", "{\n    // write your code here\n    long tol = 0.1;\n    //double\
    \ cbrtOfA = cbrt(a);\n    //if (a == 0)\n    //{\n    //    return true;\n   \
    \ //}\n    //double cbrtOfA_i = cbrtOfA;\n    //double cbrtOfA_f = cbrtOfA - cbrtOfA_i;\n\
    \    //return cbrtOfA_f <= tol;\n    long cbrtOfA = cbrt(a);\n    return cbrtOfA\
    \ * cbrtOfA * cbrtOfA == a;\n}", "{\n    return (a == 0 || a == 1) || (a % 2 !=\
    \ 0 && cast(long)pow(cast(double)a, 1.0/3.0) == pow(cast(double)a, 1.0/3.0));\n\
    }", "{\n    // your code here\n    int tmp = a > 0 ? a : -a;\n    for (int i =\
    \ 0; i <= (tmp >> 1); i++) {\n        if (i * i * i == tmp) {\n            return\
    \ true;\n        }\n    }\n    return false;\n}", "{\n    return istuple!(tuple,typeof(isPow(a,3)))&&(!a<0||a==0);\n\
    }", "{\n    // it is assumed that the input is always valid.\n    // therefore,\
    \ we don't need to check if a is negative.\n    if (a == 0) return true;\n   \
    \ auto b = cast(long)pow(abs(a), 1.0 / 3.0);\n    return b * b * b == a;\n}\n\
    /*\n    Write a function that takes a float number a, return true \n    if it\
    \ is a prime number and false otherwise.\n    Note: you may assume the input is\
    \ always valid.\n    Examples:\n    >>> isprime(0.0)\n    false\n    >>> isprime(1.0)\n\
    \    false\n    >>> isprime(2.0)\n    true\n    >>> isprime(2.0)\n    true\n \
    \   >>> isprime(5.0)\n    true\n    >>> isprime(6.0)\n    false\n    >>> isprime(11.0)\n\
    \    true\n*/", "{\n    bool cube = false;\n    if (a < 0) a = -a;\n    if (a\
    \ == 0) cube = true;\n    else {\n        int i = 1;\n        while (i < a) {\n\
    \            i++;\n            if (i*i*i == a) {\n                cube = true;\n\
    \                break;\n            }\n        }\n    }\n    return cube;\n}",
  "{\n    return (long)pow(a, 1.0/3.0) == pow(a, 1.0/3.0);\n}\n/*\n    Write a function\
    \ that takes in an array of integers\n    and returns a tuple containing the length\
    \ of the longest\n    subarray with all positive integers and the length of\n\
    \    the longest subarray with all negative integers.\n    Examples:\n    >>>\
    \ longestSubarray([1,2,3,4,5])\n    (5, 0)\n    >>> longestSubarray([1,2,3,4,5,-1,-2,-3,-4,-5])\n\
    \    (5, 5)\n    >>> longestSubarray([1,2,3,4,5,-1,-2,-3,-4,-5,10,11,12])\n  \
    \  (3, 5)\n    >>> longestSubarray([-1,-2,-3,-4,-5,10,11,12])\n    (3, 5)\n  \
    \  >>> longestSubarray([])\n    (0, 0)\n    >>> longestSubarray([1,2,3,4,5,6,7,8,9,0])\n\
    \    (1, 1)\n    >>> longestSubarray([-1,-2,-3,-4,-5,0,1,2,3,4,5])\n    (1, 5)\n\
    \    >>> longestSubarray([0,0,0,0,0,0,0,0,0,0])\n    (0, 0)\n*/\nTuple!(ulong,\
    \ ulong) longestSubarray(int[] array)\n{\n    ulong lenPos = 0, lenNeg = 0, maxPos\
    \ = 0, maxNeg = 0;\n    foreach(int el; array)\n    {\n        if(el > 0)\n  \
    \      {\n            if(lenNeg > maxNeg)\n                maxNeg = lenNeg;\n\
    \            lenNeg = 0;\n            lenPos++;\n        }\n        else if(el\
    \ < 0)\n        {\n            if(lenPos > maxPos)\n                maxPos = lenPos;\n\
    \            lenPos = 0;\n            lenNeg++;\n        }\n        else\n   \
    \     {\n            if(lenPos > maxPos)\n                maxPos = lenPos;\n",
  "{\n    return modf(cbrt(a)) == 0.0;\n}\n/*", "{\n    return is(typeof(0L))(a) &&\
    \ a > 0;\n}", "{\n    long b = (long)cbrt(a);\n    return a == b * b * b;\n}",
  "{\n    float i = cbrt(a);\n    return (i == (int)i);\n}", "{\n    return is_perfect_cube(a);\n\
    }", "{\n    long cbrt = cast(long)cbrt(cast(double)a);\n    return pow(cbrt, 3)\
    \ == a;\n}", "{\n    int i = 0;\n    for (i = 1; i <= a; i++)\n    {\n       \
    \ if (i * i * i == a)\n        {\n            return true;\n        }\n    }\n\
    \    return false;\n}", "{\n    return (pow(a,1.0/3) % 1 == 0);\n}\n/*\n    Write\
    \ a function that takes an array of integers and a long number k and \n    returns\
    \ true if a and b are two integers such that a^3+b^3=k.\n    Note: you may assume\
    \ the input is always valid.\n    Examples:\n    >>> findCubeSum({1L,2L,3L,4L,5L,6L,7L,8L,9L,10L},\
    \ 1729L)\n    true\n    >>> findCubeSum({1L,2L,3L,4L,5L,6L,7L,8L,9L,10L}, 20L)\n\
    \    false\n    >>> findCubeSum({1L,2L,3L,4L,5L,6L,7L,8L,9L,10L}, 3L)\n    true\n\
    \    >>> findCubeSum({1L,2L,3L,4L,5L,6L,7L,8L,9L,10L}, 1L)\n    true\n    >>>\
    \ findCubeSum({1L,2L,3L,4L,5L,6L,7L,8L,9L,10L}, -1L)\n    false\n    >>> findCubeSum({1L,2L,3L,4L,5L,6L,7L,8L,9L,10L},\
    \ 0L)\n    true\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
