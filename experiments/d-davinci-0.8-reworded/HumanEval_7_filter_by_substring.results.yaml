language: d
name: HumanEval_7_filter_by_substring
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\t\n\tstring[] result;\n\tforeach(string s;\
    \ strings) \n\t{\n\t\tif(s.contains(substring))\n\t\t\tresult ~= s;\n\t}\n\treturn\
    \ result;\n}\n/*\n Find the index of a given string in the input array\n    >>>\
    \ search_by_name([\"1\", \"2\", \"3\"], \"1\")\n    0\n    >>> search_by_name([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"bacd\")\n    1\n*/\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdldwj43h.d(17): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdldwj43h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto filtered_strings = appender!(string[])();\n\
    \    foreach(string s; strings)\n    {\n        if(s.contains(substring))\n  \
    \      {\n            filtered_strings.put(s);\n        }\n    }\n    return filtered_strings.data;\n\
    }\n/*\n    Sort an input array of strings\n    >>> sort_strings([\"c\", \"b\"\
    , \"a\"])\n    [\"a\", \"b\", \"c\"]\n    >>> sort_strings([\"a\", \"b\", \"a\"\
    ])\n    [\"a\", \"a\", \"b\"]\n*/\nstring[] sort_strings(string[] strings) \n\
    {\n    auto local_strings = strings.dup;\n    local_strings.sort();\n    return\
    \ local_strings;\n}\n/*\n    Given an array of strings, return a string\n    that\
    \ is composed of all the strings joined\n    together.\n    >>> join_strings([\"\
    a\", \"b\", \"c\"])\n    \"abc\"\n    >>> join_strings([\"a\", \"b\", \"c\", \"\
    \"])\n    \"abc\"\n    >>> join_strings([\"a\", \"b\", \"c\", \"d\"])\n    \"\
    abcd\"\n    >>> join_strings([\"\", \"\", \"\"])\n    \"\"\n*/\nstring join_strings(string[]\
    \ strings) \n{\n    return strings.joiner;\n}\n/*\n    Given an array of integers,\
    \ return an array\n    of the same size with each element doubled.\n    >>> double_array([1,\
    \ 2, 3])\n    [2, 4, 6]\n    >>> double_array([])\n    []\n    >>> double_array([-1,\
    \ -2])\n    [-2, -4]\n    >>> double_array([9])\n    [18]\n*/\nunittest\n{\n \
    \   alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppx5g516x.d(13): Error: template instance `appender!(string[])`
    template `appender` is not defined

    /tmp/tmppx5g516x.d(16): Error: no property `contains` for type `string`

    /tmp/tmppx5g516x.d(33): Error: no property `sort` for type `string[]`

    /tmp/tmppx5g516x.d(51): Error: no property `joiner` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppx5g516x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    scope scope = scope();\n    scope._filter\
    \ = new string[];\n    scope.predicate = (string x) => (x.find(substring) >= 0);\n\
    \    std.algorithm.filter!(scope.predicate)(strings);\n    return scope._filter;\n\
    }\n/*\n Filter an input array of strings only for ones that contain a string from\
    \ a given array of strings\n    >>> filter_by_substrings([], [\"a\"])\n    []\n\
    \    >>> filter_by_substrings([\"abc\", \"bacd\", \"cde\", \"array\"], [\"a\"\
    , \"c\"])\n    [\"abc\", \"bacd\", \"cde\", \"array\"]\n    >>> filter_by_substrings([\"\
    abc\", \"bacd\", \"cde\", \"array\"], [\"b\", \"x\"])\n    [\"bacd\"]\n*/\nstring[]\
    \ filter_by_substrings(string[] strings, string[] substrings) \n{\n    scope scope\
    \ = scope();\n    scope._filter = new string[];\n    scope.predicate = (string\
    \ x) {\n        foreach (string ss; substrings) {\n            if (x.find(ss)\
    \ >= 0) {\n                return true;\n            }\n        }\n        return\
    \ false;\n    };\n    std.algorithm.filter!(scope.predicate)(strings);\n    return\
    \ scope._filter;\n}\n/*\n Filter an input array of strings only for ones that\
    \ satisfy a given predicate.\n    >>> filter_by_predicate([], (string x) => true)\n\
    \    []\n    >>> filter_by_predicate([\"abc\", \"bacd\", \"cde\", \"array\"],\
    \ (string x) => x.canFind(\"a\"))\n    [\"abc\", \"bacd\", \"array\"]\n    >>>\
    \ filter_by_predicate([\"abc\", \"bacd\", \"cde\", \"array\"], (string x) => x.canFind(\"\
    x\"))\n    []\n*/\nstring[] filter_by_predicate(string[] strings, alias pred)\
    \ \n{\n    scope scope = scope();\n    scope._filter = new string[];\n    scope.predicate\
    \ = pred;\n    std.algorithm.filter!(scope.predicate)(\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp32zkpojc.d(13): Error: redundant attribute `scope`

    /tmp/tmp32zkpojc.d(13): Error: basic type expected, not `=`

    /tmp/tmp32zkpojc.d(13): Error: no identifier for declarator `_error_`

    /tmp/tmp32zkpojc.d(13): Error: found `=` instead of statement

    /tmp/tmp32zkpojc.d(14): Error: no identifier for declarator `._filter`

    /tmp/tmp32zkpojc.d(14): Error: found `=` instead of statement

    /tmp/tmp32zkpojc.d(15): Error: no identifier for declarator `.predicate`

    /tmp/tmp32zkpojc.d(15): Error: found `=` instead of statement

    /tmp/tmp32zkpojc.d(16): Error: expression expected, not `scope`

    /tmp/tmp32zkpojc.d(17): Error: expression expected, not `scope`

    /tmp/tmp32zkpojc.d(30): Error: redundant attribute `scope`

    /tmp/tmp32zkpojc.d(30): Error: basic type expected, not `=`

    /tmp/tmp32zkpojc.d(30): Error: no identifier for declarator `_error_`

    /tmp/tmp32zkpojc.d(30): Error: found `=` instead of statement

    /tmp/tmp32zkpojc.d(31): Error: no identifier for declarator `._filter`

    /tmp/tmp32zkpojc.d(31): Error: found `=` instead of sta'
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.contains(substring))(strings);\n\
    }\n/*\n Compute a sum of a given array of integers\n    >>> sum_array([])\n  \
    \  0\n    >>> sum_array([1, 2, 3, 4, 5])\n    15\n*/\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv2jagbba.d(13): Error: template instance `filter!((s) => s.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv2jagbba.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl05a50d7.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl05a50d7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto res = [];\n    foreach(i,x; strings)\
    \ {\n        if (x.canFind(substring)) {\n            res ~= x;\n        }\n \
    \   }\n    return res;\n}\n \n/*\n    >>> filter_by_substring([\"abc\", \"bacd\"\
    , \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n*/\nstring[] filter_by_substring2(string[] strings, string substring)\
    \ \n{\n    auto res = [];\n    foreach(i,x; strings) {\n        if (x.canFind(substring))\
    \ {\n            res ~= x;\n        }\n    }\n    return res;\n}\n/*\n    >>>\
    \ filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"\
    abc\", \"bacd\", \"array\"]\n    >>> filter_by_substring([], \"a\")\n    []\n\
    */\nstring[] filter_by_substring3(string[] strings, string substring) \n{\n  \
    \  auto res = [];\n    foreach(i,x; strings) {\n        if (x.canFind(substring))\
    \ {\n            res ~= x;\n        }\n    }\n    return res;\n}\n/*\n    >>>\
    \ filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"\
    abc\", \"bacd\", \"array\"]\n    >>> filter_by_substring([], \"a\")\n    []\n\
    */\nstring[] filter_by_substring4(string[] strings, string substring) \n{\n  \
    \  auto res = [];\n    foreach(i,x; strings) {\n        if (x.canFind(substring))\
    \ {\n            res ~= x;\n        }\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpertpf1ic.d(15): Error: no property `canFind` for type `string`

    /tmp/tmpertpf1ic.d(16): Error: cannot append type `string` to type `void[]`

    /tmp/tmpertpf1ic.d(19): Error: cannot implicitly convert expression `res` of type
    `void[]` to `string[]`

    /tmp/tmpertpf1ic.d(32): Error: no property `canFind` for type `string`

    /tmp/tmpertpf1ic.d(33): Error: cannot append type `string` to type `void[]`

    /tmp/tmpertpf1ic.d(36): Error: cannot implicitly convert expression `res` of type
    `void[]` to `string[]`

    /tmp/tmpertpf1ic.d(48): Error: no property `canFind` for type `string`

    /tmp/tmpertpf1ic.d(49): Error: cannot append type `string` to type `void[]`

    /tmp/tmpertpf1ic.d(52): Error: cannot implicitly convert expression `res` of type
    `void[]` to `string[]`

    /tmp/tmpertpf1ic.d(64): Error: no property `canFind` for type `string`

    /tmp/tmpertpf1ic.d(65): Error: cannot append type `string` to type `void[]`

    /tmp/tmpertpf1ic.d(68): Error: cannot implicitly convert expression `res` of type
    `void[]` to `string[]`

    Failed: ["dmd", '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\treturn strings.filter!(str => str.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq6dgt1z5.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq6dgt1z5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    import std.algorithm;\n    return strings.filter!(s\
    \ => s.contains(substring)).array;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnot3eqm9.d(14): Error: no property `contains` for type `string`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):        instantiated
    from here: `FilterResult!(__lambda3, string[])`

    /tmp/tmpnot3eqm9.d(14):        instantiated from here: `filter!(string[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnot3eqm9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto res = [];\n    foreach(s; strings)\
    \ \n    {\n        if (s.find(substring) != -1)\n            res ~= s;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp67yz8xhq.d(16): Error: no property `find` for type `string`

    /tmp/tmp67yz8xhq.d(17): Error: cannot append type `string` to type `void[]`

    /tmp/tmp67yz8xhq.d(19): Error: cannot implicitly convert expression `res` of type
    `void[]` to `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp67yz8xhq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    /*\n        >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n        [\"abc\", \"bacd\", \"array\"\
    ]\n    */\n    string[] result = [\"abc\", \"bacd\", \"array\"];\n    return result;\n\
    }\n \n/*\n Filter an input array of string pairs by a given key, return a new\
    \ array of values for given key\n    >>> filter_by_key([(\"a\", 1), (\"b\", 2),\
    \ (\"a\", 3)], \"a\")\n    [1, 3]\n    >>> filter_by_key([(\"a\", 1), (\"b\",\
    \ 2), (\"a\", 3)], \"b\")\n    [2]\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpryw0ahkd.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f45]

    ??:? void tmpryw0ahkd.__unittest_L28_C1() [0x427c69]

    ??:? void tmpryw0ahkd.__modtest() [0x4281b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d81f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a75c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c75]

    ??:? runModuleUnitTests [0x42d5f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429394]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(a => a.canFind(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp608a0iov.d(13): Error: template instance `filter!((a) => a.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp608a0iov.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.canFind(substring));\n\
    }\n/*\n Number of lines of code in a file.\n    >>> count_lines_of_code(\"test.txt\"\
    )\n    3\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjiesnpzm.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjiesnpzm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] output = new string[0];\n    foreach(string\
    \ s; strings)\n    {\n        if(s.canFind(substring))\n        {\n          \
    \  output ~= s;\n        }\n    }\n    return output;\n}\n/*\nCompute the median\
    \ of a list of doubles (possible using std.algorithm.sorting.median()).\n    >>>\
    \ median([2.0, 3.0, 4.0])\n    3.0\n    >>> median([])\n    0.0\n    >>> median([1.0,\
    \ 2.0, 3.0, 4.0])\n    2.5\n*/\ndouble median(double[] values)\n{\n    if(values.length\
    \ == 0)\n    {\n        return 0.0;\n    }\n    else if(values.length % 2 == 1)\n\
    \    {\n        sort(values);\n        return values[values.length / 2];\n   \
    \ }\n    else\n    {\n        sort(values);\n        return 0.5 * (values[values.length\
    \ / 2] + values[values.length / 2 - 1]);\n    }\n}\n/*\nFind an integer e, such\
    \ that when it is added to all elements of an input array, the sum is equal to\
    \ a given integer.\n    >>> find_integer([0], 0)\n    0\n    >>> find_integer([1,2,3],\
    \ 6)\n    3\n    >>> find_integer([1,2,3], 5)\n    4\n    >>> find_integer([1,2,3],\
    \ 7)\n    4\n    >>> find_integer([1,2,3], 2)\n    -1\n    >>> find_integer([1,2,3],\
    \ 3)\n    -1\n    >>> find_integer([1,2,3], 4)\n    -1\n    >>> find_integer([1,2,3],\
    \ 0)\n    -1\n    >>> find_integer([1,2,3], 1)\n    -1\n    >>> find_integer([1,2,3],\
    \ 8)\n    -1\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n\
    \    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzmibp4kf.d(16): Error: no property `canFind` for type `string`

    /tmp/tmpzmibp4kf.d(40): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpzmibp4kf.d(45): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzmibp4kf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    import std.stdio;\n    int i = 0;\n    string[]\
    \ tmp = new string[strings.length];\n    foreach(s; strings)\n    {\n        if(s.contains(substring))\n\
    \        {\n            tmp[i] = s;\n            i += 1;\n        }\n    }\n \
    \   return tmp[0..i];\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphox7y13j.d(18): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphox7y13j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  string[] result = [];\n  for (size_t i = 0;\
    \ i < strings.length; i++)\n  {\n    if (strings[i].canFind(substring))\n    {\n\
    \      result ~= strings[i];\n    }\n  }\n  return result;\n}\nunittest\n{\n \
    \   alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1w1l_kf4.d(16): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1w1l_kf4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] r = [];\n    foreach(s; strings)\
    \ \n    {\n        if(s.contains(substring))\n            r ~= s;\n    }\n   \
    \ return r;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n  \
    \  assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqtzw2z16.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtzw2z16.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  string[] filtered_strings;\n  foreach(string\
    \ str; strings) \n  {\n    if (str.contains(substring)) \n    {\n      filtered_strings\
    \ ~= str;\n    }\n  }\n  return filtered_strings;\n}\n/*\n    Filter an input\
    \ array of strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"f\")\n    []\n*/\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuc4qxepk.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuc4qxepk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string elem;\
    \ strings) \n    {\n        if (elem.contains(substring)) \n        {\n      \
    \      result ~= elem;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_bjfx428.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_bjfx428.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhojda89.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhojda89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.contains(substring))(strings);\n\
    }\n \n/*\n Filter an input array of integers only for odd numbers\n    >>> filter_odd([1,\
    \ 2, 3, 4, 5])\n    [1, 3, 5]\n    >>> filter_odd([2, 4, 6, 8, 10])\n    []\n\
    */\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6a8gnjwp.d(13): Error: template instance `filter!((s) => s.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6a8gnjwp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] arr = [];\n    foreach(item; strings)\
    \ \n    {\n        if(item.contains(substring)) \n        {\n            arr ~=\
    \ item;\n        }\n    }\n    return arr;\n}\n/*\n Convert an input array of\
    \ strings to the list of pairs of substrings: \n before the first digit and after\
    \ the first digit. \n It should return the empty list if no digit is found in\
    \ the input strings. \n    >>> split_by_digit([])\n    []\n    >>> split_by_digit([\"\
    abc\", \"bacd\", \"cde\", \"array\"])\n    []\n    >>> split_by_digit([\"abc\"\
    , \"bacd\", \"cde1\", \"array\"])\n    [(\"cde\", \"1\")]\n    >>> split_by_digit([\"\
    1abc\", \"a2bacd\", \"cde\", \"ar3ray\"])\n    [(\"\", \"1\"), (\"a\", \"2\"),\
    \ (\"ar\", \"3\")]\n*/\nalias Pair!(string, string) Pair;\nPair[] split_by_digit(string[]\
    \ strings) \n{\n    Pair[] arr = [];\n    foreach(item; strings) \n    {\n   \
    \     int i = 0;\n        foreach(c; item) \n        {\n            if(std.string.isDigit(c))\
    \ \n            {\n                arr ~= Pair(item[0..i], item[i..$]);\n    \
    \            break;\n            }\n            i++;\n        }\n    }\n    return\
    \ arr;\n}\n/*\n Convert an input array of numbers to the list of squares of those\
    \ numbers. \n Return the empty list if the input is an empty list. \n    >>> square_values([])\n\
    \    []\n    >>> square_values([1,2,3])\n    [1, 4, 9]\n*/\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp36fkqvxt.d(36): Error: template instance `Pair!(string, string)`
    recursive template expansion

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp36fkqvxt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.canFind(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyfm7vmg.d(13): Error: template instance `filter!((s) => s.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyfm7vmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    @safe pure nothrow \n{\n    string[] result;\n\
    \    foreach(str; strings) {\n        if (str.contains(substring)) {\n       \
    \     result ~= str;\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2o8pusvt.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2o8pusvt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzb38fgs3.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzb38fgs3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.contains(substring));\n\
    }\n/*\n Filter an input array of strings only for ones that don't contain given\
    \ substring\n    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"cde\"]\n*/\nstring[] filter_not_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => !x.contains(substring));\n\
    }\n/*\n Filter an input array of strings only for ones that start with given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n*/\nstring[]\
    \ filter_by_startswith(string[] strings, string substring) \n{\n    return strings.filter!(x\
    \ => x.startsWith(substring));\n}\n/*\n Filter an input array of strings only\
    \ for ones that don't start with given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"bacd\", \"cde\"]\n*/\nstring[] filter_not_by_startswith(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => !x.startsWith(substring));\n\
    }\n/*\n Filter an input array of strings only for ones that end with given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"bacd\", \"array\"]\n*/\n\
    string[] filter_by_endswith(string[] strings, string substring) \n{\n    return\
    \ strings.filter!(x => x.endsWith(substring));\n}\n/*\n Filter an input array\
    \ of strings only for ones that don't end with\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdjxcwls1.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjxcwls1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string i;\
    \ strings)\n    {\n        if(i.contains(substring))\n        {\n            result\
    \ ~= i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0udiuena.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0udiuena.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = [];\n    foreach(string\
    \ s; strings) \n    {\n        if (s.find(substring) > -1) \n        {\n     \
    \       result ~= s;\n        }\n    }\n    return result;\n}\n/*\n Prints a message\
    \ about a birthday party\n    >>> wish_happy_birthday(\"Ann\")\n    Happy birthday,\
    \ dear Ann!\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n \
    \   assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp154w2s5e.d(16): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp154w2s5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.canFind(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyfm7vmg.d(13): Error: template instance `filter!((s) => s.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyfm7vmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.canFind(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyfm7vmg.d(13): Error: template instance `filter!((s) => s.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyfm7vmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \nin \n{\n    assert(substring.length > 0);\n}\n\
    out\n{\n    assert(res.length <= strings.length);\n    for (int i = 0; i < res.length;\
    \ i++)\n    {\n        assert(res[i].contains(substring));\n    }\n}\ndo\n{\n\
    \    string[] res = [];\n    for (int i = 0; i < strings.length; i++)\n    {\n\
    \        if (strings[i].contains(substring))\n        {\n            res.push(strings[i]);\n\
    \        }\n    }\n    return res;\n}\n/*\n Find the longest common prefix of\
    \ a list of strings\n    >>> longest_common_prefix([])\n    \"\"\n    >>> longest_common_prefix([\"\
    abcd\", \"abca\", \"abck\"])\n    \"abc\"\n    >>> longest_common_prefix([\"abcd\"\
    , \"abca\", \"abck\", \"qwerty\"])\n    \"\"\n*/\nstring longest_common_prefix(string[]\
    \ strings) \nin \n{\n    assert(strings.length > 0);\n}\nout\n{\n    assert(res.length\
    \ <= strings[0].length);\n    for (int i = 0; i < res.length; i++)\n    {\n  \
    \      for (int j = 1; j < strings.length; j++)\n        {\n            assert(strings[j][i]\
    \ == res[i]);\n        }\n    }\n}\ndo\n{\n    string prefix = \"\";\n    for\
    \ (int i = 0; i < strings[0].length; i++)\n    {\n        char c = strings[0][i];\n\
    \        bool is_prefix = true;\n        for (int j = 1; j < strings.length; j++)\n\
    \        {\n            if (i >= strings[j].length || strings[j][i] != c)\n  \
    \          {\n                is_prefix = false;\n                break;\n   \
    \         }\n        }\n        if (is_prefix)\n        {\n            prefix\
    \ += c;\n        }\n        else\n        {\n            break;\n        }\n \
    \   }\n    return prefix;\n}\n/*\n Given two arrays, return a new array containing\
    \ elements from\nunittest\n{\n    alias candidate = filter_by_substring;\n\n \
    \   assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk6pc7b3t.d(87): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk6pc7b3t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ktqi5eg.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ktqi5eg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered = [];\n    foreach(string\
    \ word; strings)\n    {\n        if(word.contains(substring))\n        {\n   \
    \         filtered ~= word;\n        }\n    }\n    return filtered;\n}\n/*\n Finds\
    \ given substring in a given array of strings\n    >>> find_substring([], \"a\"\
    )\n    false\n    >>> find_substring([\"abc\", \"bacd\", \"cde\", \"array\"],\
    \ \"a\")\n    true\n    >>> find_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"e\")\n    true\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplev0_007.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplev0_007.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = [];\n    for (int i =\
    \ 0; i < strings.length; i++)\n    {\n        if (strings[i].toLower().contains(substring.toLower()))\n\
    \        {\n            result ~= strings[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzgb3s25_.d(16): Error: no property `toLower` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzgb3s25_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(string)(strings, (string\
    \ str) => str.canFind(substring));\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv0307say.d(13): Error: template instance `filter!string` template
    `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv0307say.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] ret = [];\n    foreach(string s;\
    \ strings)\n    {\n        if(s.find(substring) != -1)\n        {\n          \
    \  ret ~= s;\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmsgts84q.d(16): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmsgts84q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  string[] result;\n  foreach(string s; strings)\n\
    \  {\n    if(s.contains(substring))\n    {\n      result ~= s;\n    }\n  }\n \
    \ return result;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8a88hot8.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8a88hot8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    immutable(string)[] filtered_list = filter!(s\
    \ => \n    {\n        if (s.canFind(substring))\n            return true;\n  \
    \      else\n            return false;\n    })(strings);\n    return filtered_list;\n\
    }\n/*\n    Calculate polygon area\n    >>> polygon_area([])\n    -1\n    >>> polygon_area([[0,\
    \ 0], [1, 0], [1, 1], [0, 1]])\n    1\n    >>> polygon_area([[0, 0], [1, 0], [1,\
    \ 1], [0, 1], [0, 0]])\n    1\n*/\ndouble polygon_area(immutable(real[])[] points)\
    \ \n{\n    import std.array;\n    import std.math;\n    if (points.length == 0)\n\
    \        return -1;\n    auto double result = 0;\n    auto double[] s_points =\
    \ points[0];\n    auto double[] e_points = points[0];\n    foreach (i, point;\
    \ points) \n    {\n        if (i > 0) \n        {\n            s_points = points[i\
    \ - 1];\n            e_points = points[i];\n            result += s_points[0]\
    \ * e_points[1] - s_points[1] * e_points[0];\n        }\n    }\n    s_points =\
    \ points[points.length - 1];\n    e_points = points[0];\n    result += s_points[0]\
    \ * e_points[1] - s_points[1] * e_points[0];\n    return abs(result) / 2;\n}\n\
    /*\n    Find min and max elements\n    >>> MinMax([])\n    []\n    >>> MinMax([1,\
    \ 2, 3, 4, 5])\n    [1, 5]\n    >>> MinMax([9, -9, 1])\n    [-9, 9]\n*/\nimmutable(double)[]\
    \ MinMax(immutable(double)[] array) \n{\n    import std.array;\n    if (array.length\
    \ == 0)\n        return [];\n    auto double[] result = [array[0], array[0\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpio_0l2k_.d(69): Error: found `unittest` when expecting `,`

    /tmp/tmpio_0l2k_.d(78): Error: found `void` when expecting `,`

    /tmp/tmpio_0l2k_.d(78): Error: found `{` when expecting `,`

    /tmp/tmpio_0l2k_.d(78): Error: expression expected, not `}`

    /tmp/tmpio_0l2k_.d(78): Error: found `End of File` when expecting `,`

    /tmp/tmpio_0l2k_.d(78): Error: found `End of File` when expecting `]`

    /tmp/tmpio_0l2k_.d(78): Error: found `End of File` instead of array initializer

    /tmp/tmpio_0l2k_.d(78): Error: semicolon expected, not `End of File`

    /tmp/tmpio_0l2k_.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpio_0l2k_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] new_array;\n    foreach(string\
    \ s; strings)\n    {\n        if(s.contains(substring))\n        {\n         \
    \   new_array ~= s;\n        }\n    }\n    return new_array;\n}\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxfotqw92.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxfotqw92.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered = [];\n    foreach(string\
    \ s; strings) \n    {\n        if(s.contains(substring)) \n        {\n       \
    \     filtered ~= s;\n        }\n    }\n    return filtered;\n}\n/*\n Compute\
    \ the length of the longest string in the array\n    >>> longest_length([\"abc\"\
    , \"bacd\", \"cde\", \"array\"])\n    5\n*/\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2szr7oed.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2szr7oed.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => find(s, substring) !=\
    \ -1)(strings);\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n\
    \    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt55p9qjk.d(13): Error: template instance `filter!((s) => find(s,
    substring) != -1)` template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt55p9qjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\treturn strings.filter!(x => x.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmc92nmcd.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmc92nmcd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    import std.array;\n    return strings.filter!(s\
    \ => s.canFind(substring)).array;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcs2wqc5e.d(14): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcs2wqc5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    if (strings.length == 0) return [];\n    else\
    \ return to!(string[])([strings[0]] ~ filter_by_substring(strings[1..$], substring))\
    \ if (strings[0].find(substring) >= 0);\n    else return filter_by_substring(strings[1..$],\
    \ substring);\nunittest\n{\n    alias candidate = filter_by_substring;\n\n   \
    \ assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqdeama91.d(12): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpqdeama91.d(12): Error: declaration expected, not `if`

    /tmp/tmpqdeama91.d(13): Error: declaration expected, not `else`

    /tmp/tmpqdeama91.d(14): Error: declaration expected, not `else`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqdeama91.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\n/*\n Equivalent to lower_bound and upper_bound in STL\n    >>> lower_bound([1,\
    \ 2, 2, 3, 4, 5], 2)\n    1\n    >>> lower_bound([1, 2, 2, 3, 4, 5], 3)\n    3\n\
    \    >>> lower_bound([1, 2, 2, 3, 4, 5], 1)\n    0\n    >>> lower_bound([1, 2,\
    \ 2, 3, 4, 5], 0)\n    0\n    >>> lower_bound([1, 2, 2, 3, 4, 5], 6)\n    6\n\
    \    >>> upper_bound([1, 2, 2, 3, 4, 5], 2)\n    3\n    >>> upper_bound([1, 2,\
    \ 2, 3, 4, 5], 3)\n    4\n    >>> upper_bound([1, 2, 2, 3, 4, 5], 1)\n    1\n\
    \    >>> upper_bound([1, 2, 2, 3, 4, 5], 0)\n    0\n    >>> upper_bound([1, 2,\
    \ 2, 3, 4, 5], 6)\n    6\n    >>> binary_search([1, 2, 2, 3, 4, 5], 2)\n    2\n\
    \    >>> binary_search([1, 2, 2, 3, 4, 5], 3)\n    3\n    >>> binary_search([1,\
    \ 2, 2, 3, 4, 5], 1)\n    1\n    >>> binary_search([1, 2, 2, 3, 4, 5], 0)\n  \
    \  0\n    >>> binary_search([1, 2, 2, 3, 4, 5], 6)\n    0\n*/\ntemplate<typename\
    \ A, typename B> B binary_search(A& a, B t)\n{\n    auto it = a.lower_bound(t);\n\
    \    if (it == a.end() || t < *it) return B(0);\n    return *it;\n}\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp__vzls28.d(48): Error: identifier expected following `template`

    /tmp/tmp__vzls28.d(48): Error: declaration expected, not `<`

    /tmp/tmp__vzls28.d(51): Error: declaration expected, not `if`

    /tmp/tmp__vzls28.d(52): Error: declaration expected, not `return`

    /tmp/tmp__vzls28.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp__vzls28.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in {\n        foreach(string s; strings) {\n\
    \            assert(s.size != 0);\n        }\n        assert(substring.size !=\
    \ 0);\n    }\n    body {\n        auto result = strings.filter!(s => s.contains(substring));\n\
    \        foreach(string s; result) {\n            assert(s.contains(substring));\n\
    \        }\n        return result;\n    }\nunittest\n{\n    alias candidate =\
    \ filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc647ruv6.d(19): Error: no property `filter` for type `string[]`

    /tmp/tmpc647ruv6.d(14): Error: no property `size` for type `string`

    /tmp/tmpc647ruv6.d(16): Error: no property `size` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc647ruv6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] res = [string];\n    for (int i\
    \ = 0; i < strings.length; i++)\n    {\n        if (strings[i].find(substring)\
    \ != -1)\n        {\n            res.append(strings[i]);\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n\
    \    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdfk6io9u.d(13): Error: type `string` has no value

    /tmp/tmpdfk6io9u.d(16): Error: no property `find` for type `string`

    /tmp/tmpdfk6io9u.d(18): Error: no property `append` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdfk6io9u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnusyrh5l.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnusyrh5l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfvc6l6cv.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfvc6l6cv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered_strings;\n    foreach(i,\
    \ string; strings) \n    {\n        if (contains(string, substring))\n       \
    \ {\n            filtered_strings ~= string;\n        }\n    }\n    return filtered_strings;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqxp_8oeq.d(16): Error: undefined identifier `contains`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqxp_8oeq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.canFind(substring))(strings);\n\
    }\n/*\n Get a word as user input and filter an array of strings only for ones\
    \ that contain that word.\n    >>> filter_words_by_user_input([\"abc\", \"bacd\"\
    , \"cde\", \"array\"])\n    Enter a substring: a\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    >>> filter_words_by_user_input([\"abc\", \"bacd\", \"cde\", \"array\"])\n\
    \    Enter a substring: a\n    [\"abc\", \"bacd\", \"array\"]\n*/\nstring[] filter_words_by_user_input(string[]\
    \ strings) \n{\n    writeln(\"Enter a substring: \");\n    string substring =\
    \ readln();\n    return filter_by_substring(strings, substring);\n}\n/*\n Get\
    \ the position of an element in a string array\n    >>> find_position([\"This\"\
    , \"is\", \"a\", \"sentence\"], \"a\")\n    2\n    >>> find_position([\"This\"\
    , \"is\", \"a\", \"sentence\"], \"sentence\")\n    3\n    >>> find_position([\"\
    This\", \"is\", \"a\", \"sentence\"], \"Not in the array\")\n    -1\n*/\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkz26r79p.d(13): Error: template instance `filter!((s) => s.canFind(substring))`
    template `filter` is not defined

    /tmp/tmpkz26r79p.d(26): Error: `writeln` is not defined, perhaps `import std.stdio;`
    is needed?

    /tmp/tmpkz26r79p.d(27): Error: undefined identifier `readln`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkz26r79p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.canFind(substring)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0luov21x.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0luov21x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in \n    {\n    }\n    body \n    {\n     \
    \   return filter!((a) => a.canFind(substring))(strings);\n    }\n    out(result)\
    \ \n    {\n        assert(all!((a) => a.canFind(substring))(result));\n    }\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn50k2ha1.d(19): Error: declaration expected, not `out`

    /tmp/tmpn50k2ha1.d(22): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn50k2ha1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(a => a.contains(substring))(strings);\n\
    }\n/*\n Create a range with given start value, end value and increment\n    >>>\
    \ range(2, 10, 2)\n    [2, 4, 6, 8]\n    >>> range(10, 2, 2)\n    []\n*/\nT[]\
    \ range(T)(T start, T end, T increment) if (isIntegral!T || is(T == float) ||\
    \ is(T == double)) \n{\n    T[] result;\n    if (start > end) {\n        return\
    \ result;\n    }\n    while (start <= end) {\n        result ~= start;\n     \
    \   start += increment;\n    }\n    return result;\n}\n/*\n Finds a position of\
    \ the given element in array\n    >>> find_position([3, 1, 4, 1, 5, 9], 1)\n \
    \   1\n    >>> find_position([], 1)\n    -1\n*/\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmfc88l56.d(13): Error: template instance `filter!((a) => a.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmfc88l56.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    import std.algorithm : filter;\n    return\
    \ strings.filter!(s => s.contains(substring));\n}\n/*\n ArrayStatistics: a struct\
    \ that represents statistics of a numeric array\n    >>> ArrayStatistics([1, 2,\
    \ 3, 4, 5]).mean\n    3.0\n    >>> ArrayStatistics([1, 2, 3, 4, 5]).std\n    1.5811388300841898\n\
    \    >>> ArrayStatistics([1, 2, 3, 4, 5]).min\n    1\n    >>> ArrayStatistics([1,\
    \ 2, 3, 4, 5]).max\n    5\n    >>> ArrayStatistics([1, 2, 3, 4, 5]).median\n \
    \   3\n*/\nstruct ArrayStatistics(T) \n    if (isFloatingPoint!T || isIntegral!T)\n\
    {\n    static assert(isArithmetic!T, \"type must be either an arithmetic type\"\
    );\n    /*\n     * Calculate the standard deviation of this array\n     */\n \
    \   T std()\n    {\n        import std.math : sqrt;\n        auto mean = this.mean;\n\
    \        return T(sqrt(this.mean((element, index) => (element - mean) ^^ 2)));\n\
    \    }\n    /*\n     * Calculate the mean of this array\n     */\n    T mean()\n\
    \    {\n        return this.sum / this.length;\n    }\n    /*\n     * Calculate\
    \ the median of this array\n     */\n    T median()\n    {\n        return array_median(this.array);\n\
    \    }\n    /*\n     * Get the minimum of this array\n     */\n    T min()\n \
    \   {\n        return this.array[0];\n    }\n    /*\n     * Get the maximum of\
    \ this array\n     */\n    T max()\n    {\n        return this.array[$ - 1];\n\
    \    }\n    /*\n     * Create an ArrayStatistics from a given array\n     */\n\
    \    private static ArrayStatistics create(T[] array)\n    {\n        static if\
    \ (isFloatingPoint!T)\n        {\n            return ArrayStatistics!T(array.sum,\
    \ array.length, array.array);\n        }\n        else static if (isIntegral!T\n\
    unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbl5bmoz6.d(80): Error: found `unittest` when expecting `)`

    /tmp/tmpbl5bmoz6.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpbl5bmoz6.d(89): Error: `}` expected following members in `struct` declaration
    at /tmp/tmpbl5bmoz6.d(29)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbl5bmoz6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  string[] filtered_strings;\n  foreach(string\
    \ s; strings)\n  {\n    if(s.find(substring) != -1)\n    {\n      filtered_strings\
    \ ~= s;\n    }\n  }\n  return filtered_strings;\n}\n/*\n Filter an input array\
    \ of strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  string[] filtered_strings;\n  foreach(string\
    \ s; strings)\n  {\n    if(s.find(substring) != -1)\n    {\n      filtered_strings\
    \ ~= s;\n    }\n  }\n  return filtered_strings;\n}\n/*\n Add two integers\n  \
    \  >>> add(1, 2)\n    3\n    >>> add(1, 0)\n    1\n    >>> add(0, 0)\n    0\n\
    */\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5r4en5f8.d(16): Error: no property `find` for type `string`

    /tmp/tmp5r4en5f8.d(36): Error: no property `find` for type `string`

    /tmp/tmp5r4en5f8.d(56): Error: `tmp5r4en5f8.filter_by_substring` called with argument
    types `(void[], string)` matches both:

    /tmp/tmp5r4en5f8.d(11):     `tmp5r4en5f8.filter_by_substring(string[] strings,
    string substring)`

    and:

    /tmp/tmp5r4en5f8.d(31):     `tmp5r4en5f8.filter_by_substring(string[] strings,
    string substring)`

    /tmp/tmp5r4en5f8.d(57): Error: `tmp5r4en5f8.filter_by_substring` called with argument
    types `(string[], string)` matches both:

    /tmp/tmp5r4en5f8.d(11):     `tmp5r4en5f8.filter_by_substring(string[] strings,
    string substring)`

    and:

    /tmp/tmp5r4en5f8.d(31):     `tmp5r4en5f8.filter_by_substring(string[] strings,
    string substring)`

    /tmp/tmp5r4en5f8.d(58): Error: `tmp5r4en5f8.filter_by_substring` called with argument
    types `(string[], string)` matches both:

    /tmp/tmp5r4en5f8.d(11):     `tmp5r4en5f8.filter_by_substring(string[] strings,
    string substring)`

    and:

    /tmp'
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in \n    {\n        assert(strings.all!(s =>\
    \ s.length > 0));\n        assert(substring.length > 0);\n    }\n    body\n  \
    \  {\n        return strings.filter!(s => s.contains(substring));\n    }\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6c567imy.d(19): Error: no property `filter` for type `string[]`

    /tmp/tmp6c567imy.d(14): Error: no property `all` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6c567imy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.canFind(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyfm7vmg.d(13): Error: template instance `filter!((s) => s.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyfm7vmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(c => c.find(substring) !=\
    \ -1)(strings);\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n\
    \    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagnec7ze.d(13): Error: template instance `filter!((c) => c.find(substring)
    != -1)` template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagnec7ze.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string current_string;\
    \ strings) \n    {\n        if (current_string.contains(substring)) \n       \
    \ {\n            result ~= current_string;\n        }\n    }\n    return result;\n\
    }\n/*\n Filter out all even numbers\n    >>> filter_out_even([1, 2, 3, 4, 5])\n\
    \    [1, 3, 5]\n    >>> filter_out_even([])\n    []\n*/\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn62ubxfz.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn62ubxfz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.canFind(substring));\n\
    }\n/*\n  Write a more concise version of above\n  >>> filter_by_substring([],\
    \ \"a\")\n  []\n  >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n  [\"abc\", \"bacd\", \"array\"]\n  \n*/\nstring[] filter_by_substring2(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.canFind(substring));\n\
    }\n/*\n  >>> get_max([], -1)\n  -1\n  >>> get_max([1, 4, -2, 9, 0], -1)\n  9\n\
    \  >>> get_max([1, 4, -2, 9, 0], 1)\n  9\n*/\nT get_max(T)(T[] numbers, T default_max)\n\
    {\n    if (numbers.length == 0)\n        return default_max;\n    T maximum =\
    \ numbers[0];\n    foreach (num; numbers)\n    {\n        if (num > maximum)\n\
    \            maximum = num;\n    }\n    return maximum;\n}\n/*\n  >>> max_of([],\
    \ -1)\n  -1\n  >>> max_of([1, 4, -2, 9, 0], -1)\n  9\n  >>> max_of([1, 4, -2,\
    \ 9, 0], 1)\n  9\n*/\nT max_of(T)(T[] numbers, T default_max)\n{\n    if (numbers.length\
    \ == 0)\n        return default_max;\n    T maximum = numbers[0];\n    foreach\
    \ (num; numbers)\n    {\n        if (num > maximum)\n            maximum = num;\n\
    \    }\n    return maximum;\n}\n/*\n  >>> sum_of([])\n  0\n  >>> sum_of([1, 4,\
    \ -2, 9, 0])\n  12\n*/\nT sum_of(T)(T[] numbers)\n{\n    T ret = 0;\n    foreach\
    \ (num; numbers)\n    {\n        ret += num;\n    }\n\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpczy0lfm7.d(81): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpczy0lfm7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto result = string[];\n    for (auto str\
    \ : strings) {\n        if (str.contains(substring)) {\n            result ~=\
    \ str;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp20e00841.d(14): Error: no identifier for declarator `str`

    /tmp/tmp20e00841.d(14): Error: expression expected, not `:`

    /tmp/tmp20e00841.d(14): Error: found `strings` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp20e00841.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring)).array;\n\
    }\n/*\n Filter an input array of strings only for ones that start with given substring\n\
    \    >>> filter_by_substring_prefix([], \"a\")\n    []\n    >>> filter_by_substring_prefix([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\nstring[] filter_by_substring_prefix(string[] strings, string substring) \n\
    {\n    return strings.filter!(s => s.startsWith(substring)).array;\n}\n/*\n Filter\
    \ an input array of strings only for ones that end with given substring\n    >>>\
    \ filter_by_substring_suffix([], \"a\")\n    []\n    >>> filter_by_substring_suffix([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"bacd\", \"array\"]\n    \n\
    */\nstring[] filter_by_substring_suffix(string[] strings, string substring) \n\
    {\n    return strings.filter!(s => s.endsWith(substring)).array;\n}\n/*\n Return\
    \ indices of array elements which are equal to given value\n    >>> find_all_indices([\"\
    a\", \"b\", \"c\", \"a\"], \"a\")\n    [0, 3]\n    >>> find_all_indices([\"a\"\
    , \"b\", \"c\", \"a\"], \"b\")\n    [1]\n    >>> find_all_indices([\"a\", \"b\"\
    , \"c\", \"a\"], \"c\")\n    [2]\n    >>> find_all_indices([\"a\", \"b\", \"c\"\
    , \"a\"], \"d\")\n    []\n*/\nsize_t[] find_all_indices(alias pred = \"a == b\"\
    , T)(T[] arr, T value) \n    if (is(typeof(unaryFun!pred(value, value))))\n{\n\
    \    return arr.findIndices(value);\n}\n/*\n Return first index of array element\
    \ which is equal to given value\n    >>> find_first_index([\"a\", \"b\", \"c\"\
    , \"\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvwz0a7_6.d(55): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwz0a7_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhojda89.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhojda89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in { \n        foreach (string s; strings)\
    \ \n            assert(s.length > 0);\n        assert(substring.length > 0);\n\
    \    }\n    out (result) {\n        foreach (string r; result)\n            assert(r.length\
    \ > 0);\n    }\n    body {\n        // Use filter here\n        return strings.filter!(s\
    \ => s.canFind(substring));\n    }\n/*\n    >>> filter_by_substring_optimized([],\
    \ \"a\")\n    []\n    >>> filter_by_substring_optimized([\"abc\", \"bacd\", \"\
    cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n*/\nstring[] filter_by_substring_optimized(string[]\
    \ strings, string substring) \n    in { \n        foreach (string s; strings)\
    \ \n            assert(s.length > 0);\n        assert(substring.length > 0);\n\
    \    }\n    out (result) {\n        foreach (string r; result)\n            assert(r.length\
    \ > 0);\n    }\n    body {\n        // Use filter here\n        return strings.filter!(s\
    \ => s.contains(substring));\n    }\n/*\n    >>> filter_by_substring_optimized_2([],\
    \ \"a\")\n    []\n    >>> filter_by_substring_optimized_2([\"abc\", \"bacd\",\
    \ \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n*/\nstring[]\
    \ filter_by_substring_optimized_2(string[] strings, string substring) \n    in\
    \ { \n        foreach (string s; strings) \n            assert(s.length > 0);\n\
    \        assert(substring.length > 0);\n    }\n    out (result) {\n        foreach\
    \ (string r; result)\n            assert(r.length > 0);\n    }\n    body {\n \
    \       // Use filter here\n        return strings.filter!(s => s.contains(substring));\n\
    \    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz1xvqco7.d(23): Error: no property `filter` for type `string[]`

    /tmp/tmpz1xvqco7.d(43): Error: no property `filter` for type `string[]`

    /tmp/tmpz1xvqco7.d(63): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz1xvqco7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.find(substring)\
    \ >= 0);\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxlw4pfkb.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxlw4pfkb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered_strings;\n    foreach(string\
    \ word; strings)\n    {\n        if(word.indexOf(substring) != -1)\n        {\n\
    \            filtered_strings ~= word;\n        }\n    }\n    return filtered_strings;\n\
    }\n/*\n \n */\n/*\n    >>> is_prime(0)\n    false\n    >>> is_prime(1)\n    false\n\
    \    >>> is_prime(2)\n    true\n    >>> is_prime(3)\n    true\n    >>> is_prime(4)\n\
    \    false\n    >>> is_prime(5)\n    true\n    >>> is_prime(6)\n    false\n  \
    \  >>> is_prime(7)\n    true\n    >>> is_prime(8)\n    false\n    >>> is_prime(9)\n\
    \    false\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n  \
    \  assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyasg9g7l.d(16): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyasg9g7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = strings.filter!(\n   \
    \     (string s) => s.contains(substring)\n    );\n    return result;\n}\n/*\n\
    \ Create a new array of strings that contains only the first and last character\n\
    \    >>> reverse_string([\"abc\", \"bacd\", \"cde\", \"array\"])\n    [\"ac\"\
    , \"dbc\", \"ed\", \"ayra\"]\n    \n*/\nstring[] reverse_string(string[] strings)\
    \ \n{\n    string[] result = strings.map!(\n        (string s) => s[0..1].reverse.to!string\n\
    \    );\n    return result;\n}\n/*\n Create a new array that contains the area\
    \ of each shape\n    >>> get_areas([rectangle(2, 3), rectangle(3, 2), rectangle(1,\
    \ 1)])\n    [6, 6, 1]\n    \n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv_xq4vbu.d(13): Error: no property `filter` for type `string[]`

    /tmp/tmpv_xq4vbu.d(26): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv_xq4vbu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in \n    {\n        assert(strings.length >\
    \ 0, \"Expected an input array with at least one element.\");\n        assert(substring.length\
    \ == 1, \"Expected a single-character substring.\");\n    }\n    do\n    {\n \
    \       return strings.filter!(s => s.count(substring) > 0).array;\n    }\n  \
    \  \n/*\nConvert an array of strings to upper case\n    >>> to_upper_case([\"\
    a\", \"b\", \"c\"])\n    [\"A\", \"B\", \"C\"]\n*/\nstring[] to_upper_case(string[]\
    \ strings) \n    in \n    {\n        assert(strings.length > 0, \"Expected an\
    \ input array with at least one element.\");\n    }\n    do\n    {\n        return\
    \ strings.map!(s => s.toUpper()).array;\n    }\n/*\n    Returns all the permutations\
    \ of a given array of strings\n    >>> get_permutations([\"a\", \"b\", \"c\"])\n\
    \    [[\"a\", \"b\", \"c\"], [\"a\", \"c\", \"b\"], [\"b\", \"a\", \"c\"], [\"\
    b\", \"c\", \"a\"], [\"c\", \"a\", \"b\"], [\"c\", \"b\", \"a\"]]\n*/\n/*\nstring[][]\
    \ get_permutations(string[] strings) \n    in \n    {\n        assert(strings.length\
    \ > 0, \"Expected an input array with at least one element.\");\n    }\n    do\n\
    \    {\n        string[][] result = [];\n        // TODO: Implement!\n       \
    \ return result;\n    }\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpot1tww71.d(19): Error: no property `filter` for type `string[]`

    /tmp/tmpot1tww71.d(34): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpot1tww71.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\tstring[] result;\n\tforeach(string str; strings)\
    \ \n\t{\n\t\tif(str.canFind(substring)) \n\t\t{\n\t\t\tresult ~= str;\n\t\t}\n\
    \t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphlgf1f_x.d(16): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphlgf1f_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \nin {\n    assert(strings.length > 0);\n    assert(substring.length\
    \ > 0);\n}\nout (result) {\n    assert(result.length <= strings.length);\n   \
    \ foreach (string str; result) {\n        assert(str.contains(substring));\n \
    \   }\n}\nbody {\n    int result_idx = 0;\n    foreach (string str; strings) {\n\
    \        if (str.contains(substring)) {\n            result[result_idx] = str;\n\
    \            result_idx++;\n        }\n    }\n    return result[0..result_idx];\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk1fz6hy8.d(25): Error: no property `contains` for type `string`

    /tmp/tmpk1fz6hy8.d(26): Error: undefined identifier `result`

    /tmp/tmpk1fz6hy8.d(30): Error: undefined identifier `result`

    /tmp/tmpk1fz6hy8.d(19): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk1fz6hy8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    int[] indices = new int[0];\n    string[]\
    \ result = new string[0];\n    int i = 0;\n    foreach(string s; strings)\n  \
    \  {\n        if(s.contains(substring))\n        {\n            indices ~= i;\n\
    \        }\n        i++;\n    }\n    foreach(int i; indices)\n    {\n        result\
    \ ~= strings[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5l9swv6n.d(18): Error: no property `contains` for type `string`

    /tmp/tmp5l9swv6n.d(24): Error: variable `i` is shadowing variable `tmp5l9swv6n.filter_by_substring.i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5l9swv6n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.canFind(substring));\n\
    }\n/*\n    Prints all permutations of the given string\n    >>> print_permutations(\"\
    \")\n    >>> print_permutations(\"a\")\n    a\n    >>> print_permutations(\"ab\"\
    )\n    ab\n    ba\n    >>> print_permutations(\"abc\")\n    abc\n    acb\n   \
    \ bac\n    bca\n    cab\n    cba\n    \n    \n    \n*/\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3llfvd8h.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3llfvd8h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    import std.algorithm;\n    import std.algorithm.searching;\n\
    \    string[] filtered = strings.filter!(string s)(s.canFind(substring));\n  \
    \  return filtered;\n}\n/*\n Filter an input array of strings only for ones that\
    \ contain given substring\n    >>> filter_by_substring_std([], \"a\")\n    []\n\
    \    >>> filter_by_substring_std([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring_std(string[]\
    \ strings, string substring) \n{\n    import std.algorithm;\n    import std.algorithm.searching;\n\
    \    string[] filtered = strings.filter!(s => s.canFind(substring));\n    return\
    \ filtered;\n}\n/*\n Filter an input array of strings only for ones that contain\
    \ given substring\n    >>> filter_by_substring_lambda([], \"a\")\n    []\n   \
    \ >>> filter_by_substring_lambda([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring_lambda(string[]\
    \ strings, string substring) \n{\n    import std.algorithm;\n    import std.algorithm.searching;\n\
    \    string[] filtered = strings.filter!(s => s.canFind(substring));\n    return\
    \ filtered;\n}\n/*\n Filter an input array of strings only for ones that contain\
    \ given substring\n    >>> filter_by_substring_no_import([], \"a\")\n    []\n\
    \    >>> filter_by_substring_no_import([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring_no_import(string[]\
    \ strings, string substring) \n{\n    string[] filtered = strings.filter!(s =>\
    \ s.canFind(substring));\n    return filtered;\n}\n/*\n Filter an input array\
    \ of strings only for ones that contain given subst\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptrachi19.d(15): Error: found `s` when expecting `)` following template
    argument list

    /tmp/tmptrachi19.d(15): Error: semicolon expected, not `)`

    /tmp/tmptrachi19.d(15): Error: found `)` instead of statement

    /tmp/tmptrachi19.d(61): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptrachi19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\tstring[] filtered;\n\tforeach(string s; strings)\n\
    \t{\n\t\tif(std.algorithm.find(s, substring) != -1)\n\t\t{\n\t\t\tfiltered ~=\
    \ s;\n\t\t}\n\t}\n\treturn filtered;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpchdeqxjx.d(16): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchdeqxjx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(str; strings)\
    \ \n    {\n        if (str.contains(substring)) \n        {\n            result\
    \ ~= str;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpws27_uuf.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpws27_uuf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(a => a.contains(substring))(strings);\n\
    }\n/*\nFinds most occurring element in a range\n*/\nT most_occuring(T)(T[] arr)\n\
    {\n    auto groups = group(arr);\n    return max!(a => a.length)(arr);\n}\n/*\n\
    Counts occurrences of a specific element in range\n*/\nsize_t count_occurences(T)(T[]\
    \ arr, T elem)\n{\n    return arr.count!(a => a == elem);\n}\n/*\nReturns a random\
    \ element from range\n*/\nT random_element(T)(T[] arr)\n{\n    return arr[uniform(0,\
    \ arr.length)];\n}\n/*\nReturns true if subarray is contained in the array (can\
    \ be sequential or scattered)\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpca4tuvcg.d(13): Error: template instance `filter!((a) => a.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpca4tuvcg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.canFind(substring)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhzsxih0.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhzsxih0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\treturn strings.filter!(x => x.contains(substring)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpny9mwdwb.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpny9mwdwb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \nin { \n    assert(strings != null);\n    assert(substring\
    \ != null);\n}\nout (result) {\n    assert(result != null);\n    foreach (string\
    \ s; result) {\n        assert(s != null);\n        assert(s.contains(substring));\n\
    \    }\n} \nbody {\n    return filter!(x => x.contains(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprq2t9rwr.d(24): Error: template instance `filter!((x) => x.contains(substring))`
    template `filter` is not defined

    /tmp/tmprq2t9rwr.d(20): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprq2t9rwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in \n    {\n        assert(substring.length\
    \ > 0);\n    }\n    body\n    {\n        return filter!((s) => s.canFind(substring))(strings);\n\
    \    }\n    \nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9bxbimsl.d(18): Error: template instance `filter!((s) => s.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9bxbimsl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string s;\
    \ strings)\n    {\n        if (s.contains(substring))\n        {\n           \
    \ result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi5kgjmo7.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi5kgjmo7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    int[] index_of_substring = new int[];\n\
    \    for (i, str; strings) \n    {\n        if ((index_of_substring[i] = find(str,\
    \ substring)) != -1)\n        {\n            writefln(\"'%s' -> %d\", str, index_of_substring[i]);\n\
    \        }\n    }\n    return filter!(a => a != -1)(index_of_substring);\n}\n\
    /*\n    >>> filter_by_substring_compact([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring_compact(string[]\
    \ strings, string substring) \n{\n    int[] index_of_substring = filter!(str =>\
    \ find(str, substring) != -1)(strings);\n    return index_of_substring;\n}\n/*\n\
    \ Filter an input array of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring_with_index([], \"a\")\n    []\n    >>> filter_by_substring_with_index([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n*/\nstring[] filter_by_substring_with_index(string[] strings, string substring)\
    \ \n{\n    int[] index_of_substring = new int[];\n    for (i, str; strings) \n\
    \    {\n        if ((index_of_substring[i] = find(str, substring)) != -1)\n  \
    \      {\n            writefln(\"'%s' -> %d\", str, index_of_substring[i]);\n\
    \        }\n    }\n    return filter!(a => a != -1)(index_of_substring);\n}\n\
    /*\n Filter an input array of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring_with_index_with_map([], \"a\")\n    []\n    >>> filter_by_substring_with_index_with_map([\"\
    abc\", \"b\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmhh2st7k.d(14): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmpmhh2st7k.d(21): Error: found `return` when expecting `)`

    /tmp/tmpmhh2st7k.d(43): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpmhh2st7k.d(50): Error: found `return` when expecting `)`

    /tmp/tmpmhh2st7k.d(52): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmhh2st7k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered = [];\n    foreach(string\
    \ s; strings)\n    {\n        if(s.indexOf(substring) != -1)\n        {\n    \
    \        filtered ~= s;\n        }\n    }\n    return filtered;\n}\n/*\n Takes\
    \ two strings that contain a number and returns the sum of the two numbers\n \
    \   >>> add_strings(\"1\", \"2\")\n    3\n    >>> add_strings(\"4\", \"10\")\n\
    \    14\n    >>> add_strings(\"-1\", \"10\")\n    9\n    >>> add_strings(\"-1\"\
    , \"-2\")\n    -3\n    \n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpftkvxuce.d(16): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpftkvxuce.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    nothrow\n{\n    return std.algorithm.filter!(a\
    \ => a.canFind(substring))(strings);\n}\n/*\nFilter an input array of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring_2([],\
    \ \"a\")\n    []\n    >>> filter_by_substring_2([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n*/\nstring[] filter_by_substring_2(string[]\
    \ strings, string substring) \n    pure nothrow\n{\n    return std.algorithm.filter!(a\
    \ => a.canFind(substring))(strings);\n}\n/*\nReturn a list of words in the input\
    \ sentence\n    >>> sentence_to_words(\"Sentence with spaces\")\n    [\"Sentence\"\
    , \"with\", \"spaces\"]\n    >>> sentence_to_words(\"Sentence without spaces\"\
    )\n    [\"Sentence\", \"without\", \"spaces\"]\n    >>> sentence_to_words(\"Sentence\
    \ with, multiple spaces   \")\n    [\"Sentence\", \"with,\", \"multiple\", \"\
    spaces\"]\n*/\nstring[] sentence_to_words(string sentence) \n    pure nothrow\n\
    {\n    return sentence.split(' ');\n}\n/*\nReturn a list of words in the input\
    \ sentence\n    >>> sentence_to_words_2(\"Sentence with spaces\")\n    [\"Sentence\"\
    , \"with\", \"spaces\"]\n    >>> sentence_to_words_2(\"Sentence without spaces\"\
    )\n    [\"Sentence\", \"without\", \"spaces\"]\n    >>> sentence_to_words_2(\"\
    Sentence with, multiple spaces   \")\n    [\"Sentence\", \"with,\", \"multiple\"\
    , \"spaces\"]\n*/\nstring[] sentence_to_words_2(string sentence) \n    pure nothrow\n\
    {\n    return sentence.split(' ');\n}\n/*\nReturn a list of words in the input\
    \ sentence\n    >>> sentence_to_words_3(\"Sentence with spaces\")\n    [\"Sentence\"\
    , \"with\", \"spaces\"]\n    >>> sentence_to_words_3(\"Sentence without spaces\"\
    )\n    [\"Sentence\", \"without\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp30g9aghr.d(56): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp30g9aghr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnusyrh5l.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnusyrh5l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => canFind(s, substring))(strings);\n\
    }\n/*\n Filter an input array of strings only for ones that start with given substring\n\
    \    >>> filter_by_start([], \"a\")\n    []\n    >>> filter_by_start([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\n\
    string[] filter_by_start(string[] strings, string start) \n{\n    return filter!(s\
    \ => s.startsWith(start))(strings);\n}\n/*\n Get the index of the minimal element\
    \ of the input array\n    >>> min_index([])\n    -1\n    >>> min_index([1, -1,\
    \ 10, 2])\n    1\n    >>> min_index([1, -1, 10, -5, 2])\n    3\n    \n*/\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ellz8gr.d(13): Error: template instance `filter!((s) => canFind(s,
    substring))` template `filter` is not defined

    /tmp/tmp_ellz8gr.d(25): Error: template instance `filter!((s) => s.startsWith(start))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ellz8gr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    immutable filter_predicate = (x) => isContainedIn(substring,\
    \ x);\n    return strings.filter!filter_predicate;\n}\n/*\n Return the frequency\
    \ of each element in the input array as a dictionary with\n element as key and\
    \ number of times it appears in the array as the value\n    >>> frequency([])\n\
    \    {}\n    >>> frequency([1,2,3,3,3,3,4,5,6,7,7,8,9,10])\n    {1: 1, 2: 1, 3:\
    \ 4, 4: 1, 5: 1, 6: 1, 7: 2, 8: 1, 9: 1, 10: 1}\n*/\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvukms9ub.d(13): Error: variable `tmpvukms9ub.filter_by_substring.filter_predicate`
    type `void` is inferred from initializer `(x) => isContainedIn(substring, x)`,
    and variables cannot be of type `void`

    /tmp/tmpvukms9ub.d(13): Error: template lambda has no value

    /tmp/tmpvukms9ub.d(14): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvukms9ub.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    // Base case:\n    if (strings.length ==\
    \ 0)\n    {\n        return [];\n    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpafgxtw1k.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpafgxtw1k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.contains(substring)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqp8_7_n5.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqp8_7_n5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] newList;\n    foreach(word; strings)\n\
    \    {\n        if(word.canFind(substring))\n        {\n            newList ~=\
    \ word;\n        }\n    }\n    return newList;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3r56y4st.d(16): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3r56y4st.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\tstring[] result;\n\tforeach(string str; strings)\n\
    \t{\n\t\tif(str.contains(substring))\n\t\t{\n\t\t\tresult ~= str;\n\t\t}\n\t}\n\
    \treturn result;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp2t_tvss.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp2t_tvss.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(a => a.canFind(substring))(strings);\n\
    }\n/*\n    >>> binary_search([1, 2, 3, 5, 6, 7, 8, 9, 10], 3)\n    2\n    >>>\
    \ binary_search([1, 2, 3, 5, 6, 7, 8, 9, 10], 4)\n    -1\n    \n*/\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf882cm4s.d(13): Error: template instance `filter!((a) => a.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf882cm4s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\n/*\n    Filter an input array of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcfmzm693.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcfmzm693.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    size_t n = strings.length;\n    string[]\
    \ filtered_strings;\n    for (size_t i = 0; i < n; i++) \n    {\n        string\
    \ s = strings[i];\n        if (s.contains(substring)) \n        {\n          \
    \  filtered_strings ~= s;\n        }\n    }\n    return filtered_strings;\n}\n\
    unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp306l8eq6.d(18): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp306l8eq6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return std.algorithm.filter!((string s)\
    \ => s.canFind(substring))(strings);\n}\n/*\n Filter an input array of strings\
    \ only for ones that are anagrams of given word\n    >>> filter_by_anagram([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"abc\")\n    [\"abc\", \"bacd\"]\n    \n\
    */\nstring[] filter_by_anagram(string[] strings, string word) \n{\n    return\
    \ std.algorithm.filter!((string s) => word.canFind(s) && s.canFind(word))(strings);\n\
    }\n/*\n Filter an input array of strings only for ones that are anagrams of given\
    \ word\n    >>> filter_by_anagram([\"abc\", \"bacd\", \"cde\", \"array\"], \"\
    abc\")\n    [\"abc\", \"bacd\"]\n    \n*/\nunittest\n{\n    alias candidate =\
    \ filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4_okb7zl.d(13): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmp4_okb7zl.d(23): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4_okb7zl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered = [];\n    foreach(string\
    \ str; strings) \n    {\n        if(str.find(substring) != -1) \n        {\n \
    \           filtered ~= str;\n        }\n    }\n    return filtered;\n}\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc0qgi7y1.d(16): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc0qgi7y1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.contains(substring)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqp8_7_n5.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqp8_7_n5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in {\n        assert(strings != null);\n  \
    \      assert(substring != null);\n    }\n    body {\n        string[] filtered_strings\
    \ = [];\n        foreach (string s; strings) {\n            if (s.contains(substring))\
    \ {\n                filtered_strings ~= s;\n            }\n        }\n      \
    \  return filtered_strings;\n    }\n// Counts the number of vowels in a string\n\
    /*\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a\")\n    1\n  \
    \  >>> count_vowels(\"aba\")\n    2\n    >>> count_vowels(\"big\")\n    1\n*/\n\
    unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7mn2x1t.d(19): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7mn2x1t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto array_elements = strings.filter!(a\
    \ => a.canFind(substring));\n    return array_elements;\n}\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyx5qvd6q.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyx5qvd6q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered_strings;\n    foreach(string\
    \ s; strings)\n    {\n        if(std.string.indexOf(s, substring) != -1)\n   \
    \     {\n            filtered_strings ~= s;\n        }\n    }\n    return filtered_strings;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_hnt2v10.d(16): Error: undefined identifier `string` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hnt2v10.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.canFind(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyfm7vmg.d(13): Error: template instance `filter!((s) => s.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyfm7vmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    int size = 0;\n    foreach(str; strings)\n\
    \    {\n        if(str.find(substring) != -1)\n        {\n            size++;\n\
    \        }\n    }\n    string[] result = new string[];\n    result.length = size;\n\
    \    size = 0;\n    foreach(str; strings)\n    {\n        if(str.find(substring)\
    \ != -1)\n        {\n            result[size] = str;\n            size++;\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5latw0l2.d(16): Error: no property `find` for type `string`

    /tmp/tmp5latw0l2.d(21): Error: new can only create structs, dynamic arrays or
    class objects, not `string[]`''s

    /tmp/tmp5latw0l2.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5latw0l2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in(strings) out(strings) nothrow @safe pure\
    \ {\n    import std.algorithm.searching : canFind;\n    import std.string : toLower;\n\
    \    return strings.filter!(s => s.toLower().canFind(substring));\n}\n/*\n Make\
    \ a tuple containing all the elements from\n    >>> all_unique_elements([1,2,3,4])\n\
    \    [1, 2, 3, 4]\n    >>> all_unique_elements([1,1,1,1])\n    [1]\n    >>> all_unique_elements([1,2,3,4,3,2,1])\n\
    \    [1, 2, 3, 4]\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3q990e5r.d(12): Error: statement expected to be `{ }`, not `nothrow`

    /tmp/tmp3q990e5r.d(12): Error: basic type expected, not `{`

    /tmp/tmp3q990e5r.d(12): Error: no identifier for declarator `_error_`

    /tmp/tmp3q990e5r.d(12): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3q990e5r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \nin {\n    foreach (s; strings)\n        assert(s.length\
    \ > 0);\n    assert(substring.length > 0);\n}\nout(result) {\n    foreach (s;\
    \ result) {\n        assert(s.length > 0);\n        assert(s.contains(substring));\n\
    \    }\n}\nbody {\n    return filter!(s => s.contains(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp642ora24.d(24): Error: template instance `filter!((s) => s.contains(substring))`
    template `filter` is not defined

    /tmp/tmp642ora24.d(20): Error: no property `contains` for type `const(string)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp642ora24.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhojda89.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhojda89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!( (s) => s.canFind(substring)\
    \ );\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp28tv2qbj.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp28tv2qbj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered;\n    foreach(string s;\
    \ strings) \n    {\n        if (s.find(substring) > -1)\n            filtered\
    \ ~= s;\n    }\n    return filtered;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp803v2kpz.d(16): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp803v2kpz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg04uu3lp.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg04uu3lp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    if (strings.length == 0) \n    {\n     \
    \   return [];\n    }\n    string[] result = new string[];\n    foreach (index,\
    \ str; strings) \n    {\n        if (str.contains(substring)) \n        {\n  \
    \          result ~= str;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9w6ui4yr.d(17): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmp9w6ui4yr.d(20): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9w6ui4yr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string s;\
    \ strings) \n    {\n        if (s.contains(substring)) \n        {\n         \
    \   result ~= s;\n        }\n    }\n    return result;\n}\n/*\n Use the above\
    \ function to find all the words that contain the substring \"lo\" in the following\
    \ array\n*/\nstring[] words = [\"hello\", \"hey\", \"world\", \"python\", \"loops\"\
    , \"welcome\"];\nstring[] filtered_words = filter_by_substring(words, \"lo\");\n\
    unittest\n{\n    assert(filtered_words == [\"hello\", \"loops\"]);\n}\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp1y4fx_p.d(16): Error: no property `contains` for type `string`

    /tmp/tmpp1y4fx_p.d(27):        called from here: `filter_by_substring(words, "lo")`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp1y4fx_p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered_strings;\n    foreach(string\
    \ input_string; strings) \n    {\n        if (input_string.contains(substring))\n\
    \        {\n            filtered_strings ~= input_string;\n        }\n    }\n\
    \    return filtered_strings;\n}\n/*\n    Filter a string of words, separated\
    \ by white space, \n    for ones that contain given substring\n    >>> filter_by_substring_many(\"\
    a b c d\", \"a\")\n    [\"a\", \"b\", \"d\"]\n*/\nstring[] filter_by_substring_many(string\
    \ words, string substring) \n{\n    string[] filtered_strings;\n    string[] strings\
    \ = words.split;\n    foreach(string input_string; strings) \n    {\n        if\
    \ (input_string.contains(substring))\n        {\n            filtered_strings\
    \ ~= input_string;\n        }\n    }\n    return filtered_strings;\n}\n/*\nFind\
    \ a string pattern in a given string,\nreturn the index of its first character\n\
    \    >>> find_pattern(\"dab\", \"a\")\n    1\n    >>> find_pattern(\"dab\", \"\
    b\")\n    2\n    >>> find_pattern(\"dab\", \"c\")\n    -1\n*/\nunittest\n{\n \
    \   alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1jsqx1qf.d(16): Error: no property `contains` for type `string`

    /tmp/tmp1jsqx1qf.d(32): Error: no property `split` for type `string`

    /tmp/tmp1jsqx1qf.d(35): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1jsqx1qf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\n \n/*\n \nMang(struct) co 3 phan tu:\n- mang 1 chieu cua so\n- mang 1 chieu\
    \ cua string\n- mang 1 chieu cua struct\n \n*/\nstruct Mang\n{\n    int[] a;\n\
    \    string[] b;\n    // mang 1 chieu cua struct\n    Prs[] c;\n    void init(int[]\
    \ a, string[] b, Prs[] c)\n    {\n        this.a = a;\n        this.b = b;\n \
    \       this.c = c;\n    }\n}\n \n/*\n Tao 1 mang kieu tuong minh\n*/\nMang TaoMang()\n\
    {\n    int[] a = new int[](5);\n    a[0] = 1;\n    a[1] = 2;\n    a[2] = 3;\n\
    \    a[3] = 4;\n    a[4] = 5;\n \n    string[] b = new string[](3);\n    b[0]\
    \ = \"abc\";\n    b[1] = \"def\";\n    b[2] = \"ghi\";\n \n    Prs[] c = new Prs[](4);\n\
    \    c[0].init(1, \"abc\");\n    c[1].init(2, \"def\");\n    c[2].init(3, \"ghi\"\
    );\n    c[3].init(4, \"jkl\");\n \n    Mang m = new Mang();\n    m.init(a, b,\
    \ c);\n    return m;\n}\n \n/*\n In 1 mang kieu tuong minh\n*/\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsra0wqb3.d(29): Error: undefined identifier `Prs`

    /tmp/tmpsra0wqb3.d(30): Error: undefined identifier `Prs`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsra0wqb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \nin {\n    assert(strings.length > 0);\n    assert(substring.length\
    \ > 0);\n} \nout (result) {\n    assert(result.length <= strings.length);\n  \
    \  assert(forall(i, 0, result.length - 1, result[i].contains(substring)));\n}\n\
    body {\n    foreach (string s; strings) {\n        if (s.contains(substring))\
    \ {\n            result ~= s;\n        }\n    }\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4codkr61.d(22): Error: no property `contains` for type `string`

    /tmp/tmp4codkr61.d(23): Error: undefined identifier `result`

    /tmp/tmp4codkr61.d(18): Error: undefined identifier `forall`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4codkr61.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in {\n        assert(strings != null);\n  \
    \      assert(substring != null);\n    } out (result) {\n        assert(result\
    \ != null);\n        foreach (index, elem; result) {\n            assert(index\
    \ < result.length);\n            assert(index >= 0);\n            assert(elem.contains(substring));\n\
    \        }\n    } body {\n    string[] filtered = [];\n    foreach (str; strings)\
    \ {\n        if (str.contains(substring)) {\n            filtered ~= str;\n  \
    \      }\n    }\n    return filtered;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmg1nv4ax.d(25): Error: no property `contains` for type `string`

    /tmp/tmpmg1nv4ax.d(20): Error: no property `contains` for type `const(string)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmg1nv4ax.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.canFind(substring)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhzsxih0.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhzsxih0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhojda89.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhojda89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] res = [];\n    foreach(s; strings)\
    \ {\n        if (s.contains(substring)) {\n            res ~= s;\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp40eml9tv.d(15): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp40eml9tv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] ret = new string[];\n    foreach(str;\
    \ strings)\n    {\n        if(str.contains(substring))\n        {\n          \
    \  ret ~= str;\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbvxfqxon.d(13): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpbvxfqxon.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbvxfqxon.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnusyrh5l.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnusyrh5l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] strings_containing_substring;\n\
    \    foreach(string s; strings)\n    {\n        if(s.indexOf(substring) != -1)\n\
    \        {\n            strings_containing_substring ~= s;\n        }\n    }\n\
    \    return strings_containing_substring;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7q3u1ct0.d(16): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7q3u1ct0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] res = [];\n    foreach(str; strings)\
    \ \n    {\n        if(str.canFind(substring)) \n        {\n            res ~=\
    \ str;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp88qetn6h.d(16): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp88qetn6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\treturn filter!(s => s.find(substring) != -1)(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw8b19sme.d(13): Error: template instance `filter!((s) => s.find(substring)
    != -1)` template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw8b19sme.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto result = filter!(a => a.contains(substring))(strings);\n\
    \    return result;\n}\n/*\n Check if all elements of an array are equal\n   \
    \ >>> all_equal([1,1,1,1])\n    true\n    >>> all_equal([1,1,1,0])\n    false\n\
    */\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9_3diqbf.d(13): Error: template instance `filter!((a) => a.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_3diqbf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\treturn strings.filter!(s => s.contains(substring));\n\
    }\n/*\n Append a random item from an array to it\n    >>> append_random_item([],\
    \ [])\n    []\n    >>> append_random_item([1, 2, 3], [])\n    [1, 2, 3, 1]\n \
    \   >>> append_random_item([1, 2, 3], [1])\n    [1, 2, 3, 2]\n*/\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbi93ylun.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbi93ylun.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    import std.array;\n    return strings.filter!(a\
    \ => a.canFind(substring)).array;\n}\n/*\nCompute sum of 2 arrays of different\
    \ lengths, so that the length of the sum is the max(len(a), len(b))\n    >>> array_sum([1,\
    \ 2, 3], [1, 2])\n    [2, 4, 3]\n    >>> array_sum([1, 2, 3], [1, 2, 3, 4])\n\
    \    [2, 4, 6, 4]\n    >>> array_sum([1, 2, 3, 4], [])\n    [1, 2, 3, 4]\n*/\n\
    T[] array_sum(T)(T[] a, T[] b) \n{\n    import std.array;\n    T[] out;\n    int\
    \ i = 0;\n    while (i < max(a.length, b.length)) \n    {\n        out ~= (i <\
    \ a.length ? a[i] : 0) + (i < b.length ? b[i] : 0);\n        i++;\n    }\n   \
    \ return out;\n}\n/*\nCreate an array of integers starting from `start` up to\
    \ and excluding `end`, in steps of `step`\n    >>> range(0, 5, 1)\n    [0, 1,\
    \ 2, 3, 4]\n    >>> range(0, 5, 2)\n    [0, 2, 4]\n    >>> range(0, -5, -1)\n\
    \    [0, -1, -2, -3, -4]\n    >>> range(0, -5, -2)\n    [0, -2, -4]\n    >>> range(0,\
    \ -5, 2)\n    []\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp60wght_u.d(28): Error: found `out` when expecting `;` following
    statement

    /tmp/tmp60wght_u.d(28): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp60wght_u.d(32): Error: found `out` instead of statement

    /tmp/tmp60wght_u.d(35): Error: expression expected, not `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp60wght_u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    if (strings.length == 0)\n        return strings;\n\
    \    foreach (string _string; strings)\n        if (_string.canFind(substring))\n\
    \            return strings;\n    return strings[];\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdrhbr6pj.d(12): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpdrhbr6pj.d(12): Error: declaration expected, not `if`

    /tmp/tmpdrhbr6pj.d(14): Error: declaration expected, not `foreach`

    /tmp/tmpdrhbr6pj.d(14): Error: no identifier for declarator `strings`

    /tmp/tmpdrhbr6pj.d(14): Error: declaration expected, not `)`

    /tmp/tmpdrhbr6pj.d(17): Error: declaration expected, not `return`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdrhbr6pj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.canFind(substring));\n\
    }\n/*\n Similar to filter_by_substring, but not case sensitive\n*/\nstring[] filter_by_substring_ignore_case(string[]\
    \ strings, string substring) \n{\n    auto lower = strings.map!(s => s.toLower());\n\
    \    return lower.filter!(s => s.canFind(substring.toLower()));\n}\n/*\n Get the\
    \ hamming distance between two strings\n    >>> hamming_distance(\"abc\", \"abd\"\
    )\n    1\n    >>> hamming_distance(\"abc\", \"abc\")\n    0\n*/\nsize_t hamming_distance(string\
    \ left, string right) \n{\n    size_t distance = 0;\n    foreach (index, c; left)\
    \ \n    {\n        if (right[index] != c)\n            distance++;\n    }\n  \
    \  return distance;\n}\n/*\n Get the edit distance between two strings\n    >>>\
    \ edit_distance(\"abc\", \"abd\")\n    1\n    >>> edit_distance(\"abc\", \"abc\"\
    )\n    0\n    >>> edit_distance(\"abc\", \"ab\")\n    1\n    >>> edit_distance(\"\
    abc\", \"abcd\")\n    1\n*/\nsize_t edit_distance(string left, string right) \n\
    {\n    auto d = new size_t[][](left.length + 1, right.length + 1);\n    foreach\
    \ (ref row; d) \n    {\n        row[] = 0..$;\n    }\n    foreach (ref row; d[1..$])\
    \ \n    {\n        row[0] = row.length - 1;\n    }\n    foreach (row; 1..d.length)\
    \ \n    {\n        foreach (col; 1..d[row].length) \n        {\n            d[row][col]\
    \ = min(d[row - 1][col] + 1,\n                                d[row][col - 1]\
    \ + 1,\n                                d[row - 1][col - 1] + (left[row - 1] !=\
    \ right[col - 1] ? 1 : 0));\n        }\n    }\n    return d[d.\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn1dnib7u.d(56): Error: found `..` when expecting `;` following
    statement

    /tmp/tmpn1dnib7u.d(56): Error: found `$` instead of statement

    /tmp/tmpn1dnib7u.d(72): Error: identifier expected following `.`, not `unittest`

    /tmp/tmpn1dnib7u.d(73): Error: found `{` when expecting `,`

    /tmp/tmpn1dnib7u.d(74): Error: expression expected, not `alias`

    /tmp/tmpn1dnib7u.d(74): Error: found `candidate` when expecting `,`

    /tmp/tmpn1dnib7u.d(74): Error: expression expected, not `=`

    /tmp/tmpn1dnib7u.d(74): Error: found `filter_by_substring` when expecting `,`

    /tmp/tmpn1dnib7u.d(74): Error: expression expected, not `;`

    /tmp/tmpn1dnib7u.d(76): Error: found `assert` when expecting `,`

    /tmp/tmpn1dnib7u.d(76): Error: found `;` when expecting `,`

    /tmp/tmpn1dnib7u.d(77): Error: found `;` when expecting `,`

    /tmp/tmpn1dnib7u.d(78): Error: found `;` when expecting `,`

    /tmp/tmpn1dnib7u.d(79): Error: found `;` when expecting `,`

    /tmp/tmpn1dnib7u.d(80): Error: expression expected, not `}`

    /tmp/tmpn1dnib7u.d(81): Error: found `void` w'
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!( (string string)\
    \ => string.canFind(substring)).array;\n}\nunittest\n{\n    alias candidate =\
    \ filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe66tmx4y.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe66tmx4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.contains(substring)).array;\n\
    }\n/*\n Filter an input array of strings only for ones that are palindromes\n\
    \    >>> filter_palindromes([])\n    []\n    >>> filter_palindromes([\"abc\",\
    \ \"bacd\", \"ababa\", \"aba\", \"bac\", \"cde\", \"array\"])\n    [\"ababa\"\
    , \"aba\"]\n    \n*/\nstring[] filter_palindromes(string[] strings) \n{\n    return\
    \ strings.filter!(x => x.isPalindrome).array;\n}\n/*\n Make a unicode string from\
    \ a code point\n    >>> to_unicode(0xABCD)\n    \"\u0A8D\"\n    >>> to_unicode(0xABCD.max)\n\
    \    \"\U0001D13B\"\n    \n*/\nstring to_unicode(dchar c) \n{\n    static immutable\
    \ string str_format = \"\\\\u%04X\";\n    char[] s = new char[5];\n    foreach(immutable\
    \ int i; 0 .. 4) \n    {\n        char ch = ((c >> ((3 - i) * 4)) & 0x0F).to!char;\n\
    \        s[i] = ch > 9 ? ch + 0x37 : ch + 0x30;\n    }\n    return str_format.format(s.idup);\n\
    }\n/*\n Make a non-grapheme substring from a grapheme string\n    >>> slice_by_grapheme(\"\
    abcd\", 1, 3)\n    \"b\"\n    >>> slice_by_grapheme(\"abcd\", 0, 1)\n    \"a\"\
    \n    >>> slice_by_grapheme(\"abcd\", 1, 1)\n    \"\"\n    >>> slice_by_grapheme(\"\
    abcd\", 0, 5)\n    \"abcd\"\n    >>> slice_by_grapheme(\"abcd\", -1, 5)\n    \"\
    abcd\"\n    >>> slice_by_grapheme(\"abcd\", -1, -2)\n    \"\"\n    >>> slice_by_grapheme(\"\
    abcd\", -1, -\nunittest\n{\n    alias candidate = filter_by_substring;\n\n   \
    \ assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmk16m3vd.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmk16m3vd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.indexOf(substring)\
    \ > -1);\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp68q41j3e.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp68q41j3e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzb38fgs3.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzb38fgs3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  auto filtered_array = filter!(string x)(strings)\n\
    \  {\n    // should we keep it?\n    x.find(substring) != string.npos;\n  };\n\
    \  return filtered_array;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsffkfn59.d(13): Error: found `x` when expecting `)` following template
    argument list

    /tmp/tmpsffkfn59.d(13): Error: semicolon expected following auto declaration,
    not `)`

    /tmp/tmpsffkfn59.d(13): Error: found `)` instead of statement

    /tmp/tmpsffkfn59.d(18): Error: declaration expected, not `return`

    /tmp/tmpsffkfn59.d(19): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsffkfn59.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto result = array();\n    for (string\
    \ str ; strings) \n    {\n        if (str.contains(substring)) \n        {\n \
    \           result ~= str;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprocfx1uj.d(14): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmprocfx1uj.d(21): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprocfx1uj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = [];\n    foreach(s; strings)\
    \ \n    {\n        if(s.find(substring) != string.npos) \n        {\n        \
    \    result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3t14nj6w.d(16): Error: no property `find` for type `string`

    /tmp/tmp3t14nj6w.d(16): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3t14nj6w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(string => string.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptgy8g80h.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptgy8g80h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    import std.algorithm;\n    auto result =\
    \ strings.filter!(x => x.contains(substring));\n    return result;\n}\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_usb1ah8.d(14): Error: no property `contains` for type `string`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):        instantiated
    from here: `FilterResult!(__lambda3, string[])`

    /tmp/tmp_usb1ah8.d(14):        instantiated from here: `filter!(string[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_usb1ah8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.contains(substring))(strings);\n\
    }\n/*\n Insert value to array at a given index\n    >>> insert_at([], 0, 2)\n\
    \    [2]\n    >>> insert_at([1, 2, 3], 1, 0)\n    [1, 0, 2, 3]\n    >>> insert_at([1,\
    \ 2, 3], 2, 0)\n    [1, 2, 0, 3]\n*/\nT[] insert_at(T, int index, T value)(T[]\
    \ arr, int index, T value) \n{\n    return arr[0 .. index] ~ [value] ~ arr[index\
    \ .. $];\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplsiul65v.d(13): Error: template instance `filter!((s) => s.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplsiul65v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ktqi5eg.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ktqi5eg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    // return std.algorithm.filter!(\n    //\
    \     (s) => s.find(substring) != -1\n    // )(strings);\n    return std.algorithm.filter!(\n\
    \        (s) => std.array.find(strings, s) != -1\n    )(strings);\n}\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo10l6u_4.d(16): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo10l6u_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto filtered = filter!(a => a.contains(substring))(strings);\n\
    \    return filtered;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9qc_u2yp.d(13): Error: template instance `filter!((a) => a.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9qc_u2yp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(x => x.contains(substring))(strings);\n\
    }\n/*\n Filter an input array of Integers for the ones greater than given int\n\
    \    >>> filter_greater_than([1, 2, 3, 4, 5], 2)\n    [3, 4, 5]\n*/\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6e0zqgsn.d(13): Error: template instance `filter!((x) => x.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6e0zqgsn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhojda89.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhojda89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    import std.algorithm.searching;\n    import\
    \ std.algorithm.iteration;\n    return strings.filter!(s => s.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy_npun5x.d(15): Error: cannot implicitly convert expression `filter(strings)`
    of type `FilterResult!(__lambda3, string[])` to `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy_npun5x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    assert(strings.length > 0);\n    return\
    \ strings.filter!(x => (x.find(substring) != -1));\n}\n/*\n Replace a substring\
    \ by another in an input string.\n    >>> replace_substring(\"\", \"\", \"a\"\
    )\n    \"\"\n    >>> replace_substring(\"abc\", \"\", \"a\")\n    \"abc\"\n  \
    \  >>> replace_substring(\"abc\", \"a\", \"e\")\n    \"ebc\"\n    >>> replace_substring(\"\
    abc\", \"b\", \"e\")\n    \"aec\"\n    >>> replace_substring(\"abc\", \"c\", \"\
    e\")\n    \"abe\"\n    >>> replace_substring(\"abdabdabd\", \"ab\", \"e\")\n \
    \   \"edebdebd\"\n    >>> replace_substring(\"abdabdabd\", \"ab\", \"\")\n   \
    \ \"ddd\"\n    \n*/\nstring replace_substring(string input, string substring,\
    \ string replacement) \n{\n    immutable replacement_length = replacement.length;\n\
    \    immutable substring_length = substring.length;\n    assert(input.length >\
    \ 0);\n    assert(replacement_length > 0);\n    assert(substring_length > 0);\n\
    \    string[] split_string = input.split(substring);\n    return split_string.join(replacement);\n\
    }\n/*\n Reverse a string\n    >>> reverse_string(\"abc\")\n    \"cba\"\n    >>>\
    \ reverse_string(\"abcdef\")\n    \"fedcba\"\n    >>> reverse_string(\"\")\n \
    \   \"\"\n    \n*/\nstring reverse_string(string input) \n{\n    assert(input.length\
    \ > 0);\n    return input.retro;\n}\n/*\n Get the longest string in a list of\
    \ strings\n    >>> longest_string([\"a\", \"a\", \"a\"])\n    \"a\"\n    >>> longest_string([\"\
    a\", \"bc\", \"abcd\"])\n    \"abcd\"\n    >>> longest_string([\"abc\", \"bc\"\
    , \"abcd\"])\n    \"abcd\"\n    >>> longest_string([\"abc\", \"bcde\", \"abcd\"\
    ])\n    \"bcde\"\n    >>> longest\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7sr7mddg.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7sr7mddg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto ret = new string[](strings.length);\n\
    \    int j = 0;\n    foreach(i, val; strings) \n    {\n        if (val.contains(substring))\n\
    \        {\n            ret[j] = val;\n            j++;\n        }\n    }\n  \
    \  return ret[0..j];\n}\n \n/*\n Count number of substring occurrences in a string\n\
    \    >>> count_substring_occurrences(\"test test\", \"test\")\n    2\n    >>>\
    \ count_substring_occurrences(\"test test\", \"tes\")\n    2\n    >>> count_substring_occurrences(\"\
    test test\", \"\")\n    5\n    >>> count_substring_occurrences(\"test test\",\
    \ \"a\")\n    0\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjugqnsnw.d(17): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjugqnsnw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ktqi5eg.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ktqi5eg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(a => a.contains(substring))(strings);\n\
    }\n/*\n Same as `filter_by_substring`, except it splits the string into words\
    \ (split by whitespace) and then filters those words.\n    >>> filter_by_word([\"\
    abc aca bacd\", \"cde a\"], \"a\")\n    [\"abc aca bacd\"]\n*/\nstring[] filter_by_word(string[]\
    \ strings, string substring) \n{\n    return filter!(s =>\n    {\n        foreach\
    \ (word; s.split)\n        {\n            if (word.contains(substring))\n    \
    \            return true;\n        }\n        return false;\n    })(strings);\n\
    }\n/*\n Same as `filter_by_word`, except it does not require substring to be surrounded\
    \ by whitespace, but does not allow overlap.\n    >>> filter_by_word_no_overlap([\"\
    abcacabacd\", \"cdea\"], \"a\")\n    [\"abcacabacd\"]\n*/\nstring[] filter_by_word_no_overlap(string[]\
    \ strings, string substring) \n{\n    import std.regex;\n    return filter!(s\
    \ => s.match(RegExp(`\\b${substring}\\b`)))(strings);\n}\n/*\n Takes a map of\
    \ strings to ints, and returns a new map where the int value has been incremented\
    \ by one. The map is immutable.\n    >>> increment_map([\"a\": 1, \"b\": 2])\n\
    \    [\"a\": 2, \"b\": 3]\n*/\nMap!int increment_map(Map!int m) \n{\n    return\
    \ m.map!(k => 1 + k);\n}\n/*\n Takes a map and a function. Returns a new map where\
    \ the function has been applied to each value.\n    >>> apply_map_function!(x\
    \ => x + 1)([\"a\": 1, \"b\": 2])\n    [\"a\": 2, \"b\": 3]\n*/\nauto apply_map_function(Map!int\
    \ m, alias f) \n{\n    return m.map!f;\n}\n/*\n Takes an array of structs that\
    \ have a field `name` and\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprj3ifpd0.d(56): Error: basic type expected, not `alias`

    /tmp/tmprj3ifpd0.d(56): Error: found `alias` when expecting `)`

    /tmp/tmprj3ifpd0.d(56): Error: semicolon expected following function declaration

    /tmp/tmprj3ifpd0.d(56): Error: no identifier for declarator `f`

    /tmp/tmprj3ifpd0.d(56): Error: declaration expected, not `)`

    /tmp/tmprj3ifpd0.d(59): Error: unrecognized declaration

    /tmp/tmprj3ifpd0.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprj3ifpd0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered;\n    foreach(string s;\
    \ strings)\n    {\n        if(s.find(substring) != -1)\n        {\n          \
    \  filtered ~= s;\n        }\n    }\n    return filtered;\n}\n/*\n Filter an input\
    \ array of strings only for ones that are prefixes to given string\n    >>> filter_by_prefix([],\
    \ \"abc\")\n    []\n    >>> filter_by_prefix([\"ab\", \"abc\", \"abcd\", \"a\"\
    , \"c\"], \"abc\")\n    [\"ab\", \"abc\"]\n*/\nstring[] filter_by_prefix(string[]\
    \ strings, string prefix) \n{\n    string[] filtered;\n    foreach(string s; strings)\n\
    \    {\n        if(s.startsWith(prefix))\n        {\n            filtered ~= s;\n\
    \        }\n    }\n    return filtered;\n}\n/*\n Filter an input array of strings\
    \ only for ones that are prefixes to given string,\n and \n    >>> filter_by_prefix_and_substring([],\
    \ \"abc\", \"b\")\n    []\n    >>> filter_by_prefix_and_substring([\"ab\", \"\
    abc\", \"abcd\", \"a\", \"c\"], \"abc\", \"b\")\n    [\"abc\"]\n*/\nstring[] filter_by_prefix_and_substring(string[]\
    \ strings, string prefix, string substring) \n{\n    string[] filtered;\n    foreach(string\
    \ s; strings)\n    {\n        if(s.startsWith(prefix) && s.find(substring) !=\
    \ -1)\n        {\n            filtered ~= s;\n        }\n    }\n    return filtered;\n\
    }\n/*\nGiven a list of elements, return a list of the same length with all elements\n\
    in order, except for elements at the given indices (which should be removed).\n\
    \    >>> remove_indices([1, 2, 3, 4, 5], [1, 3])\n    [1, 3, 5]\n    >>> remove_indices([1,\
    \ 2, 3, 4, 5], [1, 2, 3])\n    [1, 5]\n    >>> remove_indices([1, 2, 3, 4, 5],\
    \ [])\n    [\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ckqo9fq.d(62): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ckqo9fq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    pure nothrow\n{\n    string[] result;\n   \
    \ foreach(string s; strings)\n    {\n        if (contains(s, substring))\n   \
    \     {\n            result ~= s;\n        }\n    }\n    return result;\n}\n//\
    \ Compute the frequency of each element in the array\n    /*\n Compute the frequency\
    \ of each element in the array\n    >>> frequency([])\n    []\n    >>> frequency([1,\
    \ 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4,\
    \ 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2,\
    \ 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4,\
    \ 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2,\
    \ 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4,\
    \ 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2,\
    \ 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4,\
    \ 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2,\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb_vonvtn.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_vonvtn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return std.algorithm.filter!(s => s.canFind(substring))(strings);\n\
    }\n/*\nSplit an input array of strings into pairs of strings (tuples)\n    >>>\
    \ string_pairs([])\n    []\n    >>> string_pairs([\"abc\", \"bacd\", \"cde\",\
    \ \"array\"])\n    [(\"abc\", \"bacd\"), (\"cde\", \"array\")]\n*/\nTuple!(string,\
    \ string)[] string_pairs(string[] strings) \n{\n    assert(strings.length % 2\
    \ == 0);\n    return iota(0, strings.length / 2).map!(i => tuple(strings[2 * i],\
    \ strings[2 * i + 1])).array;\n}\n/*\nSort an input array of strings by longest\
    \ word in a string\n    >>> sort_by_length([\"abc\", \"a\", \"xyz\", \"wxyz\"\
    ])\n    [\"a\", \"abc\", \"xyz\", \"wxyz\"]\n*/\nstring[] sort_by_length(string[]\
    \ strings) \n{\n    return strings.sort!((a, b) => a.length > b.length);\n}\n\
    /*\nFilter input array of strings only for ones that contain given substring,\n\
    then split into pairs of strings (tuples), then sort by longest word in a string\n\
    */\nTuple!(string, string)[] complicated_function(string[] strings, string substring)\
    \ \n{\n    return string_pairs(sort_by_length(filter_by_substring(strings, substring)));\n\
    }\n/*\nFilter input array of strings only for ones that contain given substring,\n\
    then split into pairs of strings (tuples), then sort by longest word in a string\n\
    */\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf1axpf_4.d(13): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpf1axpf_4.d(25): Error: undefined identifier `iota`

    /tmp/tmpf1axpf_4.d(34): Error: no property `sort` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf1axpf_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered;\n    foreach(str; strings)\n\
    \    {\n        if(str.canFind(substring))\n        {\n            filtered ~=\
    \ str;\n        }\n    }\n    return filtered;\n}\n/*\n Filter an input array\
    \ of strings only for ones that match a given pattern\n    >>> filter_by_pattern([],\
    \ \".a.\")\n    []\n    >>> filter_by_pattern([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \".a.\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_pattern(string[]\
    \ strings, string pattern) \n{\n    string[] filtered;\n    foreach(str; strings)\n\
    \    {\n        auto reg = regex(pattern);\n        if(reg.canFind(str))\n   \
    \     {\n            filtered ~= str;\n        }\n    }\n    return filtered;\n\
    }\n/*\n Calculate the mean of a list of integers\n    >>> mean([])\n    0\n  \
    \  >>> mean([1, 2, 3, 4, 5])\n    3\n    \n*/\ndouble mean(int[] list) \n{\n \
    \   return sum(list) / list.length;\n}\n/*\n Calculate the median of a list of\
    \ integers\n    >>> median([])\n    0\n    >>> median([1, 2, 3, 4, 5])\n    3\n\
    \    >>> median([1, 2, 3, 4, 5, 6])\n    3.5\n    \n*/\ndouble median(int[] list)\
    \ \n{\n    sort(list);\n    double median = 0;\n    if(list.length == 0)\n   \
    \ {\n        return median;\n    }\n    if(list.length % 2 == 0)\n    {\n    \
    \    median = mean([list[list.length / 2], list[list.length / 2 - 1]]);\n    }\n\
    \    else\n    {\n        median = list[list.length / 2];\n    }\n    return median;\n\
    }\n/*\n Calculate the mode of a list of integers\n    >>> mode([])\n    0\n  \
    \  >>> mode([1, 2, 3, 4, 5])\n    1\n    >>> mode([1, 2, 3, 3\nunittest\n{\n \
    \   alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcojzm1q8.d(84): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcojzm1q8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] res;\n    foreach(idx, string value;\
    \ strings) \n    {\n        if (value.contains(substring))\n            res ~=\
    \ value;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpliajhbwl.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpliajhbwl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(string => is_substring(substring,\
    \ string))(strings);\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp219h106a.d(13): Error: template instance `filter!((string) => is_substring(substring,
    string))` template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp219h106a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhojda89.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhojda89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \nin {\n    assert(strings.length >= 0);\n}\nout\
    \ {\n    for(int i = 0; i < result.length; i++)\n    assert(result[i].length >\
    \ 0);\n}\n{\n    string[] filtered = [];\n    foreach(string s; strings)\n   \
    \ {\n        if(s.indexOf(substring) != -1)\n        {\n            filtered ~=\
    \ s;\n        }\n    }\n    return filtered;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxrajmk1i.d(19): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxrajmk1i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.indexOf(substring)\
    \ != -1)();\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n  \
    \  assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwmt50hw5.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwmt50hw5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = [];\n    foreach(string\
    \ s; strings) \n    {\n        if (s.canFind(substring)) \n        {\n       \
    \     result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpop_xjnfn.d(16): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpop_xjnfn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    scope result = scope();\n    foreach(string\
    \ s; strings) \n    {\n        if (s.contains(substring)) \n        {\n      \
    \      result ~= s;\n        }\n    }\n    return cast(string[])result;\n}\n/*\n\
    \    Map array of strings to its lengths\n    >>> map_to_length([])\n    []\n\
    \    >>> map_to_length([\"abc\", \"bacd\", \"cde\", \"array\"])\n    [3, 4, 3,\
    \ 5]\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpld2uor_v.d(13): Error: expression expected, not `scope`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpld2uor_v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.count(substring) >\
    \ 0)(strings);\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n\
    \    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphsxy44m9.d(13): Error: template instance `filter!((s) => s.count(substring)
    > 0)` template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphsxy44m9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in\n    {\n        assert(strings.length >\
    \ 0);\n        assert(substring.length > 0);\n    }\n    out\n    (\n        result.length\
    \ == strings.length\n    )\n    body\n    {\n        string[] result;\n      \
    \  for (size_t i = 0; i < strings.length; i++)\n        {\n            if (strings[i].contains(substring))\n\
    \            {\n                result ~= strings[i];\n            }\n       \
    \ }\n        return result;\n    }\n/*\n Compute the length of an array of strings\n\
    \    >>> lengths([])\n    []\n    >>> lengths([\"abc\", \"bacd\", \"cde\", \"\
    array\"])\n    [3, 4, 3, 5]\n*/\nsize_t[] lengths(string[] strings)\n    in\n\
    \    {\n        assert(strings.length > 0);\n    }\n    out\n    (\n        result.length\
    \ == strings.length\n    )\n    body\n    {\n        size_t[] result;\n      \
    \  for (size_t i = 0; i < strings.length; i++)\n        {\n            result\
    \ ~= strings[i].length;\n        }\n        return result;\n    }\n/*\n Apply\
    \ a function to an array of strings\n    >>> apply_to_strings([], (str) => str)\n\
    \    []\n    >>> apply_to_strings([\"abc\", \"bacd\", \"cde\", \"array\"], (str)\
    \ => str ~ str)\n    [\"abcabc\", \"bacdbacd\", \"cdecde\", \"arrayarray\"]\n\
    */\nstring[] apply_to_strings(string[] strings, alias f)\n    in\n    {\n    \
    \    assert(strings.length > 0);\n    }\n    out\n    (\n        result.length\
    \ == strings.length\n    )\n    body\n    {\n        string[] result;\n      \
    \  for (size_t i = 0; i < strings.length; i++)\n        {\n            result\
    \ ~= f(strings[i]);\n        }\n        return result;\n    }\n/*\n Compute the\
    \ max of an array of numbers\n    >>> max_of_numbers([])\n    0\n    >>> max_of_n\n\
    unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplgsqzpbo.d(19): Error: found `.` when expecting `)`

    /tmp/tmplgsqzpbo.d(19): Error: statement expected to be `{ }`, not `length`

    /tmp/tmplgsqzpbo.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmplgsqzpbo.d(47): Error: found `.` when expecting `)`

    /tmp/tmplgsqzpbo.d(47): Error: statement expected to be `{ }`, not `length`

    /tmp/tmplgsqzpbo.d(48): Error: found `)` when expecting `;` following statement

    /tmp/tmplgsqzpbo.d(65): Error: basic type expected, not `alias`

    /tmp/tmplgsqzpbo.d(65): Error: found `alias` when expecting `)`

    /tmp/tmplgsqzpbo.d(65): Error: semicolon expected following function declaration

    /tmp/tmplgsqzpbo.d(65): Error: no identifier for declarator `f`

    /tmp/tmplgsqzpbo.d(65): Error: declaration expected, not `)`

    /tmp/tmplgsqzpbo.d(69): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplgsqzpbo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpii08zfiu.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpii08zfiu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered = [];\n    foreach(string\
    \ s; strings)\n    {\n        if(s.contains(substring)) filtered ~= s;\n    }\n\
    \    return filtered;\n}\n//@disallow(strings, substring);\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp053lw5q.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp053lw5q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  string[] output;\n  foreach(line; strings)\n\
    \  {\n    if(line.find(substring) != -1)\n    {\n      output ~= line;\n    }\n\
    \  }\n  return output;\n}\n/*\n Take an input of a single line for coordinates\
    \ of form \"X Y\"\n    >>> get_coords(\"0 1\")\n    (0, 1)\n    >>> get_coords(\"\
    1 0\")\n    (1, 0)\n    \n*/\nauto get_coords(string str) \n{\n  auto str_array\
    \ = split(str);\n  int x = to!int(str_array[0]);\n  int y = to!int(str_array[1]);\n\
    \  return tuple(x, y);\n}\n/*\n Take an input of a single line for coordinates\
    \ of form \"X Y\"\n    >>> get_coords(\"0 1\")\n    (0, 1)\n    >>> get_coords(\"\
    1 0\")\n    (1, 0)\n    \n*/\nauto get_coords(string str) \n{\n  auto str_array\
    \ = split(str);\n  int x = to!int(str_array[0]);\n  int y = to!int(str_array[1]);\n\
    \  return tuple(x, y);\n}\n/*\n Take an input of a single line for coordinates\
    \ of form \"X Y\"\n    >>> get_coords(\"0 1\")\n    (0, 1)\n    >>> get_coords(\"\
    1 0\")\n    (1, 0)\n    \n*/\nauto get_coords(string str) \n{\n  auto str_array\
    \ = split(str);\n  int x = to!int(str_array[0]);\n  int y = to!int(str_array[1]);\n\
    \  return tuple(x, y);\n}\n/*\n Take an input of a single line for coordinates\
    \ of form \"X Y\"\n    >>> get_coords(\"0 1\")\n    (0, 1)\n    >>> get_coords(\"\
    1 0\")\n    (1, 0)\n    \n*/\nauto get_coords(string str) \n{\n  auto str_array\
    \ = split(str);\n  int\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3slbdbu4.d(80): Error: no identifier for declarator `int`

    /tmp/tmp3slbdbu4.d(80): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3slbdbu4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = new string[];\n    foreach(string\
    \ s; strings)\n    {\n        if(s.indexOf(substring) != -1)\n        {\n    \
    \        result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpag4t2ms1.d(13): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpag4t2ms1.d(16): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpag4t2ms1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.canFind(substring));\n\
    }\n/*\n Find the number of evens in an array\n    >>> count_evens([])\n    0\n\
    \    >>> count_evens([1, 2, 3, 4, 5])\n    2\n    >>> count_evens([0, 2, 4, 6,\
    \ 8])\n    5\n    >>> count_evens([1, 3, 5, 7, 9])\n    0\n*/\nunittest\n{\n \
    \   alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyrntns8w.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyrntns8w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered_strings;\n    foreach(string\
    \ s; strings) \n    {\n        if (s.contains(substring)) \n        {\n      \
    \      filtered_strings ~= s;\n        }\n    }\n    return filtered_strings;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdvatpg35.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdvatpg35.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(string s => s.canFind(substring))(strings);\n\
    }\n/*\n    >>> mean([])\n    0.0\n    >>> mean([1.0, 2.0, 3.0])\n    2.0\n*/\n\
    double mean(double[] xs)\n{\n    double total = 0.0;\n    foreach(double x; xs)\n\
    \    {\n        total += x;\n    }\n    return total / xs.length;\n}\n/*\n   \
    \ >>> expt(2, 3)\n    8\n    >>> expt(2, -1)\n    0.5\n*/\ndouble expt(double\
    \ b, int e)\n{\n    if (e < 0)\n    {\n        return 1.0 / expt(b, abs(e));\n\
    \    }\n    double total = 1.0;\n    for (int i = 0; i < e; i++)\n    {\n    \
    \    total *= b;\n    }\n    return total;\n}\n/*\n >>> factorial(4)\n 24\n >>>\
    \ factorial(5)\n 120\n >>> factorial(0)\n 1\n*/\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpttynw7ef.d(13): Error: found `s` when expecting `)` following template
    argument list

    /tmp/tmpttynw7ef.d(13): Error: found `=>` when expecting `;` following `return`
    statement

    /tmp/tmpttynw7ef.d(13): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttynw7ef.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\n/*\nMerge array of input strings into one string\n    >>> join_strings([])\n\
    \    \"\"\n    >>> join_strings([\"one\", \"two\", \"three\"])\n    \"onetwothree\"\
    \n*/\nstring join_strings(string[] strings) \n{\n    return strings.join(\"\"\
    );\n}\n/*\nJoin an array of strings by given separator\n    >>> join_strings_with_separator([],\
    \ \";\")\n    \"\"\n    >>> join_strings_with_separator([\"one\", \"two\", \"\
    three\"], \";\")\n    \"one;two;three\"\n*/\nstring join_strings_with_separator(string[]\
    \ strings, string separator) \n{\n    return strings.join(separator);\n}\n/*\n\
    Split a string into array of substrings\n    >>> split_string(\"\", \";\")\n \
    \   []\n    >>> split_string(\"one;two;three\", \";\")\n    [\"one\", \"two\"\
    , \"three\"]\n*/\nstring[] split_string(string s, string separator) \n{\n    return\
    \ s.split(separator);\n}\n/*\nSplit a string into array of substrings.\n    >>>\
    \ split_string_by_length(\"\", 2)\n    []\n    >>> split_string_by_length(\"onetwothree\"\
    , 2)\n    [\"on\", \"et\", \"wo\", \"th\", \"re\", \"e\"]\n*/\nstring[] split_string_by_length(string\
    \ s, int length) \n{\n    import std.algorithm.searching : isSinglePass;\n   \
    \ auto lengths = iota(0, s.length, length);\n    return lengths.map!(l => s[l\
    \ .. min(l + length, s.length)]).array();\n}\n/*\nSplit a string into array of\
    \ substrings, removing empty substrings.\n    >>> split_string_by_length_with_removal(\"\
    \", 2)\n    []\n    >>> split_string_by_length_with_removal(\"onetwothree\", 2)\n\
    \    [\"on\", \"et\", \"wo\", \"th\", \"re\"]\n*/\nstring[] split\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcxsaaw6_.d(69): Error: semicolon expected, not `unittest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcxsaaw6_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] res = [];\n    foreach(str; strings)\
    \ \n    {\n        if(str.contains(substring)) \n        {\n            res ~=\
    \ str;\n        }\n    }\n    return res;\n}\n/*\n Find maximum value in an input\
    \ array of numbers\n    >>> find_max([])\n    -Inf\n    >>> find_max([1, 2, 3,\
    \ 4, 5])\n    5\n*/\nT find_max(T)(T[] nums) \n{\n    T max = nums[0];\n    foreach(num;\
    \ nums) \n    {\n        if(num > max)\n        {\n            max = num;\n  \
    \      }\n    }\n    return max;\n}\n/*\n Find the max value in an array of numbers\
    \ or the max value in an array of arrays of numbers\n    >>> find_max([1, 2, 3,\
    \ 4, 5])\n    5\n    >>> find_max([[1, 2, 3], [4, 5]])\n    5\n*/\nT find_max(T)(T[][]\
    \ nums) \n{\n    T max = nums[0][0];\n    foreach(num; nums) \n    {\n       \
    \ foreach(item; num) \n        {\n            if(item > max) \n            {\n\
    \                max = item;\n            }\n        }\n    }\n    return max;\n\
    }\n/*\n Find the max value in an array of numbers or the max value in an array\
    \ of arrays of numbers with custom comparison\n    >>> find_max(1, 2, 3, 4, 5,\
    \ fn(a, b) => a > b)\n    5\n    >>> find_max([[1, 2, 3], [4, 5]], fn(a, b) =>\
    \ a > b)\n    5\n*/\nT find_max(T, Cmp)(T[] nums, Cmp cmp) \n{\n    T max = nums[0];\n\
    \    foreach(num; nums) \n    {\n        if(cmp(num, max)) \n        {\n     \
    \       max = num;\n        }\n    }\n    return max;\n}\nT find_max\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq64bvvm_.d(84): Error: semicolon expected, not `unittest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq64bvvm_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.contains(substring)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqp8_7_n5.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqp8_7_n5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\tauto res = new string[];\n\tforeach(i, str;\
    \ strings) {\n\t\tif (str.count(substring))\n\t\t\tres ~= str;\n\t}\n\treturn\
    \ res;\n}\n/*\n Filter an input array of strings only for ones that start with\
    \ a given string\n    >>> filter_by_start_string([], \"a\")\n    []\n    >>> filter_by_start_string([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n*/\nstring[]\
    \ filter_by_start_string(string[] strings, string prefix) \n{\n\tauto res = new\
    \ string[];\n\tforeach(i, str; strings) {\n\t\tif (str.startsWith(prefix))\n\t\
    \t\tres ~= str;\n\t}\n\treturn res;\n}\n/*\n Reads a file line by line and stores\
    \ its lines in an array\n*/\nstring[] read_lines(string file)\n{\n\tauto res =\
    \ new string[];\n\tforeach(line; std.file.byLine(file)) {\n\t\tres ~= line;\n\t\
    }\n\treturn res;\n}\n/*\n Calculates mean of an array\n    >>> mean([])\n    0.0\n\
    \    >>> mean([1,2,3])\n    2.0\n*/\ndouble mean(double[] arr)\n{\n\treturn arr.sum\
    \ / arr.length;\n}\n/*\n Calculates mean of an array\n    >>> median([])\n   \
    \ 0.0\n    >>> median([0,1,2,3])\n    1.5\n    >>> median([0,1,2,3,4])\n    2.0\n\
    */\ndouble median(double[] arr)\n{\n\tauto sorted = arr.dup;\n\tstd.algorithm.sort(sorted);\n\
    \treturn sorted[sorted.length/2];\n}\n/*\n Calculates mode of an array\n    >>>\
    \ mode([])\n    []\n    >>> mode([1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n\
    unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw_alejtz.d(73): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_alejtz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] ret = [];\n    foreach(i, str;\
    \ strings)\n    {\n        if(str.find(substring) != -1)\n        {\n        \
    \    ret ~= str;\n        }\n    }\n    return ret;\n}\n/*\n Write a function\
    \ that takes a list of tuples of two elements each, and returns a list of tuples\
    \ of two elements each, \n where the first element of each tuple is replaced by\
    \ a string obtained by concatenating the two elements.\n    \n    >>> concatenate_tuples([])\n\
    \    []\n    >>> concatenate_tuples([(1, 2), (3, 4)])\n    [(\"12\", 2), (\"34\"\
    , 4)]\n    \n*/\nstring[] concatenate_tuples(int[][] tuples) \n{\n    string[]\
    \ ret = [];\n    foreach(i, str; tuples)\n    {\n        ret ~= str[0] ~ str[1];\n\
    \    }\n    return ret;\n}\n/*\n Write a function that takes a list of tuples,\
    \ \n and returns a list of tuples, where the second element of each tuple is the\
    \ sum of the two elements in the given tuple.\n    >>> add_pair_elements([])\n\
    \    []\n    >>> add_pair_elements([(1, 2), (3, 4)])\n    [(1, 3), (3, 7)]\n*/\n\
    unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo3t77oa5.d(16): Error: no property `find` for type `string`

    /tmp/tmpo3t77oa5.d(38): Error: incompatible types for `(str[0]) ~ (str[1])`: both
    operands are of type `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo3t77oa5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.contains(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6jt_qcar.d(13): Error: template instance `filter!((s) => s.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6jt_qcar.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\treturn filter!(s => s.canFind(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpomhktldq.d(13): Error: template instance `filter!((s) => s.canFind(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpomhktldq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string s;\
    \ strings) \n    {\n        if (s.contains(substring)) \n        {\n         \
    \   result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz0ht03zc.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz0ht03zc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = [for (i = 0; i < strings.length;\
    \ i++)\n        if (strings[i].indexOf(substring) >= 0)\n            strings[i]];\n\
    \    return result;\n}\n/*\n    >>> count_digits_in_numbers([])\n    0\n    >>>\
    \ count_digits_in_numbers([1, 2, 3])\n    3\n    >>> count_digits_in_numbers([22,\
    \ 33, 1])\n    6\n    >>> count_digits_in_numbers([45])\n    2\n*/\nuint count_digits_in_numbers(uint[]\
    \ numbers) \n{\n    uint result = 0;\n    for (uint i = 0; i < numbers.length;\
    \ i++)\n        result += to!string(numbers[i]).length;\n    return result;\n\
    }\n/*\n Flatten an array of arrays\n    >>> flatten([[1, 2], [3, 4]])\n    [1,\
    \ 2, 3, 4]\n    >>> flatten([[1, 2], [], [3, 4]])\n    [1, 2, 3, 4]\n    >>> flatten([[1,\
    \ 2], [3], [], [4]])\n    [1, 2, 3, 4]\n    >>> flatten([[], []])\n    []\n*/\n\
    T[] flatten(T)(T[][] arrays)\n{\n    T[] result = [];\n    for (uint i = 0; i\
    \ < arrays.length; i++)\n        result ~= arrays[i];\n    return result;\n}\n\
    /*\n Find maximum of array of integers\n    >>> find_max([])\n    0\n    >>> find_max([1,\
    \ 2, 3])\n    3\n    >>> find_max([3, 2, 1])\n    3\n    >>> find_max([1, 1, 1])\n\
    \    1\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5uy19bfv.d(13): Error: expression expected, not `for`

    /tmp/tmp5uy19bfv.d(13): Error: found `;` when expecting `,`

    /tmp/tmp5uy19bfv.d(13): Error: found `;` when expecting `,`

    /tmp/tmp5uy19bfv.d(14): Error: comma expected separating array initializers, not
    `if`

    /tmp/tmp5uy19bfv.d(14): Error: semicolon expected, not `(`

    /tmp/tmp5uy19bfv.d(15): Error: found `strings` when expecting `;` following statement

    /tmp/tmp5uy19bfv.d(15): Error: found `]` when expecting `;` following statement

    /tmp/tmp5uy19bfv.d(15): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5uy19bfv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return [str for (str; strings) if (str.contains(substring))];\n\
    }\n/*\n  Get a random item from an array\n    >>> get_random([])\n    \"\"\n \
    \   >>> get_random([\"a\", \"b\", \"c\"]) in [\"a\", \"b\", \"c\"]\n    true\n\
    */\nstring get_random(string[] strings) \n{\n    if (strings.length == 0) \n \
    \   {\n        return \"\";\n    }\n    else \n    {\n        return strings[uniform(0,\
    \ strings.length)];\n    }\n}\n/*\n    Retrieve the smallest number in an array\
    \ and its index\n    \n    >>> min_element([])\n    empty(Tuple!(uint, int));\n\
    \    >>> min_element([5, 4, 7, 2, 1])\n    tuple(uint, int)(1, 4)\n*/\nauto min_element(int[]\
    \ arr) \n{\n    int index = 0;\n    int min = arr[0];\n    foreach (i, val; arr)\
    \ \n    {\n        if (val < min) \n        {\n            min = val;\n      \
    \      index = i;\n        }\n    }\n    return tuple(uint, int)(min, index);\n\
    }\n/*\n    Print a progress bar for current progress\n    \n    >>> progress_bar(50,\
    \ 100)\n    \"[=============                   ] 50/100\"\n*/\nstring progress_bar(int\
    \ current, int max) \n{\n    int length = 80;\n    int fill = current * length\
    \ / max;\n    return format(\"[%-=.*s] %d/%d\", length, \"=\".repeat(fill), current,\
    \ max);\n}\n/*\n    Generate a random string\n    \n    >>> get_random_string(1)\n\
    \    \"a\"\n    >>> get_random_string(5)\n    \"aG8Ln\"\n*/\nstring get_random_string(size_t\
    \ length) \n{\n    string chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\
    ;\n    string result =\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkv1z8guy.d(13): Error: found `for` when expecting `,`

    /tmp/tmpkv1z8guy.d(13): Error: found `;` when expecting `)`

    /tmp/tmpkv1z8guy.d(13): Error: found `strings` when expecting `,`

    /tmp/tmpkv1z8guy.d(13): Error: expression expected, not `)`

    /tmp/tmpkv1z8guy.d(13): Error: found `if` when expecting `,`

    /tmp/tmpkv1z8guy.d(53): Error: found `,` when expecting `.` following uint

    /tmp/tmpkv1z8guy.d(53): Error: found `int` when expecting identifier following
    `uint`.

    /tmp/tmpkv1z8guy.d(79): Error: expression expected, not `unittest`

    /tmp/tmpkv1z8guy.d(80): Error: semicolon expected, not `{`

    /tmp/tmpkv1z8guy.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkv1z8guy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \nin {\n  assert(substring.size() > 0);\n  assert(strings.size()\
    \ > 0);\n  for (int i = 0; i < strings.size(); i++) {\n    assert(strings[i].size()\
    \ > 0);\n  }\n}\nout {\n  assert(strings.size() == result.size());\n  for (int\
    \ i = 0; i < result.size(); i++) {\n    assert(result[i].size() > 0);\n    assert(substring\
    \ in result[i]);\n  }\n}\n{\n  return filter!(a => substring in a)(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp368vwdcg.d(26): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp368vwdcg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] results;\n    foreach(s; strings)\
    \ \n    {\n        if (s.contains(substring)) results ~= s;\n    }\n    return\
    \ results;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\n   \
    \ assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkk0ejz_f.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkk0ejz_f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.contains(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6jt_qcar.d(13): Error: template instance `filter!((s) => s.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6jt_qcar.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered;\n    foreach(string str;\
    \ strings)\n    {\n        if(str.contains(substring))\n        {\n          \
    \  filtered ~= str;\n        }\n    }\n    return filtered;\n}\n/*\nCreate an\
    \ array filled with given value.\n    >>> create_array(\"hello\", 5)\n    [\"\
    hello\", \"hello\", \"hello\", \"hello\", \"hello\"]\n    >>> create_array(\"\
    hello\", 0)\n    []\n    >>> create_array(\"hello\", -1)\n    []\n*/\nstring[]\
    \ create_array(string value, size_t size) \n{\n    string[] strings;\n    if(size\
    \ == 0) return strings;\n    foreach(int i; 0..size)\n    {\n        strings ~=\
    \ value;\n    }\n    return strings;\n}\n/*\nTranspose a 2d array\n    >>> transpose([[\"\
    a\", \"b\"], [\"c\", \"d\"]])\n    [[\"a\", \"c\"], [\"b\", \"d\"]]\n    >>> transpose([[]])\n\
    \    []\n    >>> transpose([[\"a\", \"b\", \"c\"]])\n    [[\"a\"], [\"b\"], [\"\
    c\"]]\n*/\nT[][] transpose(T)(T[][] array) \n{\n    T[][] res;\n    for(size_t\
    \ i = 0; i < array.length; i++)\n    {\n        for(size_t j = 0; j < array[i].length;\
    \ j++)\n        {\n            res[j][i] = array[i][j];\n        }\n    }\n  \
    \  return res;\n}\n/*\nMultiply an array of number by a number\n    >>> multiply_numbers([1,\
    \ 2, 3], 4)\n    [4, 8, 12]\n    >>> multiply_numbers([1, 2, 3], 0)\n    [0, 0,\
    \ 0]\n    >>> multiply_numbers([], 0)\n    []\n*/\nT[] multiply_numbers(T)(T[]\
    \ numbers, T by) \n{\n    T[] res;\n    foreach(T num; numbers)\n    {\n     \
    \   res ~= num * by;\n    }\n\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp5632gyh.d(80): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp5632gyh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.contains(substring));\n\
    }\n/*\nJoin an array of strings with given delimiter\n    >>> join_array([\"one\"\
    , \"two\", \"three\"], \", \")\n    \"one, two, three\"\n    >>> join_array([\"\
    one\", \"two\", \"three\"], \"\")\n    \"onetwothree\"\n    >>> join_array([\"\
    one\", \"two\", \"three\"], \"\\n\")\n    \"one\\ntwo\\nthree\"\n*/\nstring join_array(string[]\
    \ strings, string delimiter) \n{\n    return strings.join(delimiter);\n}\n/*\n\
    \ Join an array of strings with given delimiter and ending, if array length is\
    \ longer than maximum_length\n    >>> join_array_with_ending([\"one\", \"two\"\
    , \"three\"], \", \", 3, \".\")\n    \"one, two, three\"\n    >>> join_array_with_ending([\"\
    one\", \"two\", \"three\"], \", \", 2, \".\")\n    \"one, two, ...\"\n    >>>\
    \ join_array_with_ending([\"one\", \"two\", \"three\"], \", \", 1, \".\")\n  \
    \  \"one, ...\"\n    >>> join_array_with_ending([\"one\", \"two\", \"three\"],\
    \ \", \", 0, \".\")\n    \"...\"\n*/\nstring join_array_with_ending(string[] strings,\
    \ string delimiter, size_t maximum_length, string ending) \n{\n    if (strings.length\
    \ <= maximum_length)\n        return strings.join(delimiter);\n    else\n    \
    \    return strings[0 .. maximum_length].join(delimiter) ~ ending;\n}\n/*\n Join\
    \ an array of strings with given delimiter, if array length is longer than maximum_length\n\
    \    >>> join_array_with_truncate([\"one\", \"two\", \"three\"], \", \", 3)\n\
    \    \"one, two, three\"\n    >>> join_array_with_truncate([\"one\", \"two\",\
    \ \"three\"], \", \", 2)\n    \"one, two\"\n    >>> join_array_with_truncate([\"\
    one\", \"two\", \"three\"], \", \", 1)\n    \"one\"\n    >>> join_\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4izc7ee_.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4izc7ee_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    if (strings.length == 0)\n        return\
    \ [];\n    string[] fsubstring = new string[];\n    for (uint i = 0; i < strings.length;\
    \ i++) \n    {\n        string s = strings[i];\n        if (s.contains(substring))\n\
    \            fsubstring ~= s;\n    }\n    return fsubstring;\n}\n/*\nFilter an\
    \ input array of strings only for ones that do not contain given substring\n \
    \   >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"cde\"]\n    \n*/\nstring[]\
    \ filter_by_substring_not(string[] strings, string substring) \n{\n    if (strings.length\
    \ == 0)\n        return [];\n    string[] fsubstring = new string[];\n    for\
    \ (uint i = 0; i < strings.length; i++) \n    {\n        string s = strings[i];\n\
    \        if (!s.contains(substring))\n            fsubstring ~= s;\n    }\n  \
    \  return fsubstring;\n}\n/*\nBuild a tree of a given array of values\n    >>>\
    \ to_tree([\"a\", \"b\", \"c\"])\n    [\"a\", \"b\", \"c\"]\n    >>> to_tree([\"\
    a\", \"a\", \"a\"])\n    [\"a\", \"a\", \"a\"]\n    >>> to_tree([\"a\", \"b\"\
    , \"c\", \"b\", \"a\"])\n    [\"a\", [\"b\", \"c\", \"b\"], \"a\"]\n    >>> to_tree([\"\
    a\", \"b\", \"c\", \"b\", \"a\", \"b\", \"b\", \"a\"])\n    [\"a\", [\"b\", \"\
    c\", \"b\"], \"a\", \"b\", \"b\", \"a\"]\n    >>> to_tree([\"a\", \"b\", \"c\"\
    , \"b\", \"a\", \"b\", \"b\", \"a\", \"c\", \"b\", \"a\"])\n    [\"a\", [\"b\"\
    , \"c\", \"b\"], \"a\", [\"b\", \"b\", \"a\", \"c\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu2f5r5ic.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu2f5r5ic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return \n        strings.filter!(s => s.indexOf(substring)\
    \ != -1)();\n}\n/*\n Filter an input array of strings only for ones that are palindromes\n\
    \    >>> filter_by_palindrome([])\n    []\n    >>> filter_by_palindrome([\"abc\"\
    , \"aba\", \"cde\", \"abdda\"])\n    [\"aba\", \"abdda\"]\n    \n*/\nstring[]\
    \ filter_by_palindrome(string[] strings)\n{\n    return \n        strings.filter!(s\
    \ => s == s.dup.reverse)();\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvuxnxlea.d(14): Error: no property `filter` for type `string[]`

    /tmp/tmpvuxnxlea.d(27): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvuxnxlea.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered;\n    foreach(string s;\
    \ strings) \n    {\n        if (s.find(substring) >= 0) \n        {\n        \
    \    filtered ~= s;\n        }\n    }\n    return filtered;\n}\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpptqah_l_.d(16): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpptqah_l_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in(strings)\n    out(result)\n{\n    import\
    \ std.algorithm;\n    immutable result = strings.filter!(x => x.contains(substring));\n\
    \    return result;\n}\n/*\n Output result of the prime factorization of a given\
    \ number\n    >>> factorize(4)\n    2 * 2\n    >>> factorize(24)\n    2 * 2 *\
    \ 2 * 3\n    >>> factorize(40)\n    2 * 2 * 2 * 5\n*/\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8yp_rojv.d(11): Error: function `tmp8yp_rojv.filter_by_substring`
    `in` and `out` contracts can only appear without a body when they are virtual
    interface functions or abstract

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8yp_rojv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfvc6l6cv.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfvc6l6cv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164145
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return [s for (s ; strings) if (s.contains(substring))];\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnbh75u7h.d(13): Error: found `for` when expecting `,`

    /tmp/tmpnbh75u7h.d(13): Error: found `;` when expecting `)`

    /tmp/tmpnbh75u7h.d(13): Error: found `strings` when expecting `,`

    /tmp/tmpnbh75u7h.d(13): Error: expression expected, not `)`

    /tmp/tmpnbh75u7h.d(13): Error: found `if` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnbh75u7h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\tstring[] result = strings.filter!(s => s.contains(substring)).array;\n\
    \treturn result;\n}\n/*\nFilter an input array of strings only for ones that contain\
    \ given character\n>>> filter_by_character([], 'a')\n[]\n>>> filter_by_character([\"\
    abc\", \"bacd\", \"cde\", \"array\"], 'a')\n[\"abc\", \"bacd\", \"array\"]\n*/\n\
    string[] filter_by_character(string[] strings, char character) \n{\n\tstring[]\
    \ result = strings.filter!(s => s.contains(character)).array;\n\treturn result;\n\
    }\n/*\nFilter an input array of strings only for ones that start with given character\n\
    >>> filter_by_start_character([], 'a')\n[]\n>>> filter_by_start_character([\"\
    abc\", \"abcd\", \"cde\", \"array\"], 'a')\n[\"abc\", \"abcd\", \"array\"]\n*/\n\
    string[] filter_by_start_character(string[] strings, char character) \n{\n\tstring[]\
    \ result = strings.filter!(s => s.startsWith(character)).array;\n\treturn result;\n\
    }\n/*\nFilter an input array of strings only for ones that end with given character\n\
    >>> filter_by_end_character([], 'a')\n[]\n>>> filter_by_end_character([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], 'a')\n[\"bacd\", \"array\"]\n*/\nstring[] filter_by_end_character(string[]\
    \ strings, char character) \n{\n\tstring[] result = strings.filter!(s => s.endsWith(character)).array;\n\
    \treturn result;\n}\n/*\nFilter an input array of strings only for ones that end\
    \ with given substring\n>>> filter_by_end_substring([], 'a')\n[]\n>>> filter_by_end_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], 'a')\n[\"bacd\", \"array\"]\n*/\nstring[]\
    \ filter_by_end_substring(string[] strings, string substring) \n{\n\tstring[]\
    \ result = strings.filter!(s => s.endsWith(\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjk83ysbc.d(62): Error: expression expected, not `unittest`

    /tmp/tmpjk83ysbc.d(63): Error: found `{` when expecting `,`

    /tmp/tmpjk83ysbc.d(64): Error: expression expected, not `alias`

    /tmp/tmpjk83ysbc.d(64): Error: found `candidate` when expecting `,`

    /tmp/tmpjk83ysbc.d(64): Error: expression expected, not `=`

    /tmp/tmpjk83ysbc.d(64): Error: found `filter_by_substring` when expecting `,`

    /tmp/tmpjk83ysbc.d(64): Error: expression expected, not `;`

    /tmp/tmpjk83ysbc.d(66): Error: found `assert` when expecting `,`

    /tmp/tmpjk83ysbc.d(66): Error: found `;` when expecting `,`

    /tmp/tmpjk83ysbc.d(67): Error: found `;` when expecting `,`

    /tmp/tmpjk83ysbc.d(68): Error: found `;` when expecting `,`

    /tmp/tmpjk83ysbc.d(69): Error: found `;` when expecting `,`

    /tmp/tmpjk83ysbc.d(70): Error: expression expected, not `}`

    /tmp/tmpjk83ysbc.d(71): Error: found `void` when expecting `,`

    /tmp/tmpjk83ysbc.d(71): Error: found `{` when expecting `,`

    /tmp/tmpjk83ysbc.d(71): Error: expression expected, not `}`

    /tmp/tmpjk83ysbc.d('
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(string => string.canFind(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptgy8g80h.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptgy8g80h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    //filter is a higher order function, it\
    \ accepts a lambda that it applies to each item in the input array \n    //a lambda\
    \ is denoted by the => operator, it accepts a string argument s and returns bool\
    \ if s.contains(substring)\n    return strings.filter!(s => s.contains(substring));\n\
    }\n/*\n Return a tuple containing the summed value of all even values in the given\
    \ array. \n The second element in the returned tuple should contain the product\
    \ of all the odd values in the array.\n    >>> even_odd_count([0,1,2,3,4,5,6,7,8,9])\n\
    \    (20, 945)\n    >>> even_odd_count([1,1,1,1,1,1,1,1,1,1])\n    (0, 1)\n  \
    \  >>> even_odd_count([0,1,2,3,4,5,6,7,8,9,10])\n    (30, 945)\n    >>> even_odd_count([0,2,4,6,8,10])\n\
    \    (30, 0)\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n\
    \    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplwdv1_dt.d(15): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwdv1_dt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto filtered = filter!(x => x.contains(substring))(strings);\n\
    \    return filtered;\n}\n/*\n Find all unique strings in the input array and\
    \ return them in a new array\n    >>> find_unique([\"abc\", \"bacd\", \"cde\"\
    , \"cde\", \"abc\"])\n    [\"abc\", \"bacd\", \"cde\"]\n*/\nstring[] find_unique(string[]\
    \ strings) \n{\n    // TODO: solution\n    return [];\n}\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa6_awt6e.d(13): Error: template instance `filter!((x) => x.contains(substring))`
    template `filter` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa6_awt6e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] res;\n    foreach(str; strings)\n\
    \    {\n        if(str.find(substring) != -1)\n        {\n            res ~= str;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgi8_1knx.d(16): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgi8_1knx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(s => s.contains(substring));\n\
    }\n/*\n Returns a new array with only even numbers from input array of numbers\n\
    \    >>> filter_even_numbers([])\n    []\n    >>> filter_even_numbers([1, 2, 3,\
    \ 4, 5, 6])\n    [2, 4, 6]\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp4mi9xpx.d(13): Error: no property `filter` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp4mi9xpx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string str;\
    \ strings)\n    {\n        if(str.contains(substring))\n        {\n          \
    \  result ~= str;\n        }\n    }\n    return result;\n}\n/*\n    Filter an\
    \ input array of strings only for ones that contain given substring\n    >>> filter_by_substring_with_filter([],\
    \ \"a\")\n    []\n    >>> filter_by_substring_with_filter([\"abc\", \"bacd\",\
    \ \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\n\
    string[] filter_by_substring_with_filter(string[] strings, string substring) \n\
    {\n    return strings.filter!(str => str.contains(substring));\n}\n/*\n    Filter\
    \ an input array of strings only for ones that contain given substring\n    >>>\
    \ filter_by_substring_with_filter_pure([], \"a\")\n    []\n    >>> filter_by_substring_with_filter_pure([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    \n*/\nstring[] filter_by_substring_with_filter_pure(string[] strings, string\
    \ substring) \n{\n    pure string[] result;\n    foreach(string str; strings)\n\
    \    {\n        if(str.contains(substring))\n        {\n            result ~=\
    \ str;\n        }\n    }\n    return result;\n}\n/*\n    Filter an input array\
    \ of strings only for ones that contain given substring\n    >>> filter_by_substring_with_filter_pure_and_filter([],\
    \ \"a\")\n    []\n    >>> filter_by_substring_with_filter_pure_and_filter([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    \n*/\nstring[] filter_by_substring_with_filter_pure_and_filter(string[]\
    \ strings, string substring) \n{\n    pure string[] result;\n    result = strings.filter!(str\
    \ =>\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqd7w9zrp.d(67): Error: expression expected, not `unittest`

    /tmp/tmpqd7w9zrp.d(68): Error: found `{` when expecting `)` following template
    argument list

    /tmp/tmpqd7w9zrp.d(69): Error: found `alias` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqd7w9zrp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  string[] result;\n  foreach(s; strings) {\n\
    \    if (s.contains(substring)) {\n      result ~= s;\n    }\n  }\n  return result;\n\
    }\n/*\n Find all index of given substring in given string\n    >>> find_all_substring_indexes(\"\
    \", \"a\")\n    []\n    >>> find_all_substring_indexes(\"abc\", \"c\")\n    [2]\n\
    \    >>> find_all_substring_indexes(\"abcabcabc\", \"abc\")\n    [0, 3, 6]\n*/\n\
    size_t[] find_all_substring_indexes(string str, string substr)\n{\n  size_t[]\
    \ result;\n  while (str.count(substr) > 0) {\n    auto index = str.indexOf(substr);\n\
    \    result ~= index;\n    str = str[index + substr.length .. $];\n  }\n  return\
    \ result;\n}\n/*\n Get a string representation of given number with given number\
    \ of leading zeros\n    >>> pad_leading(10, 2)\n    \"10\"\n    >>> pad_leading(9,\
    \ 2)\n    \"09\"\n    >>> pad_leading(123, 2)\n    \"123\"\n    >>> pad_leading(123,\
    \ 10)\n    \"0000000123\"\n*/\nstring pad_leading(T)(T number, size_t zeros)\n\
    {\n  string result = to!string(number);\n  while (result.length < zeros) {\n \
    \   result = \"0\" ~ result;\n  }\n  return result;\n}\n/*\n Returns lowest value\
    \ in a tuple\n    >>> min_tuple((1, 2, 3))\n    1\n    >>> min_tuple((1, 3, 2))\n\
    \    1\n    >>> min_tuple((3, 2, 1))\n    1\n*/\nT min_tuple(Tuple!(T, N) tuple)\n\
    {\n  T result = tuple[0];\n  foreach(t; tuple) {\n    if (t < result) {\n    \
    \  result = t;\n    }\n  }\n  return result;\n}\n/*\n Returns highest value in\
    \ a tuple\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpet9dqpwy.d(78): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpet9dqpwy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto st = filter!(a => a.canFind(substring))(strings);\n\
    \    return st;\n}\n/*\n Filter an input array of strings only for ones that contain\
    \ given substring.\n If substring is empty, return all.\n    >>> filter_by_substring([],\
    \ \"\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"\")\n    [\"abc\", \"bacd\", \"cde\", \"array\"]\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"d\"\
    )\n    [\"bacd\"]\n*/\nstring[] filter_by_substring2(string[] strings, string\
    \ substring) \n{\n    auto st = filter!(a => substring.empty || a.canFind(substring))(strings);\n\
    \    return st;\n}\n/*\nFilter an input string and remove all non-alphabetic chars.\n\
    \    >>> remove_non_alphabetic(\"A\")\n    \"A\"\n    >>> remove_non_alphabetic(\"\
    A B C - D\")\n    \"ABCD\"\n    >>> remove_non_alphabetic(\"C++ is not a scripting\
    \ language!\")\n    \"Cisscriptinglanguage\"\n*/\nstring remove_non_alphabetic(string\
    \ input) \n{\n    auto st = filter!(a => isalpha(a))(input);\n    return st;\n\
    }\n/*\nFilter an input array of strings and remove empty ones.\n    >>> remove_empty([\"\
    A\"])\n    [\"A\"]\n    >>> remove_empty([\"A\", \"\"])\n    [\"A\"]\n    >>>\
    \ remove_empty([\"C++\", \"\", \"is\", \"not\", \"a\", \"scripting\", \"language\"\
    ])\n    [\"C++\", \"is\", \"not\", \"a\", \"scripting\", \"language\"]\n*/\nstring[]\
    \ remove_empty(string[] strings) \n{\n    auto st = filter!(a => !a.empty)(strings);\n\
    \    return\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgg_z4u3.d(60): Error: expression expected, not `unittest`

    /tmp/tmpwgg_z4u3.d(61): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgg_z4u3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    in \n    {\n        assert(!strings.empty);\n\
    \        assert(!substring.empty);\n    }\n    body \n    {\n        foreach (s;\
    \ strings)\n        {\n            if (s.contains(substring))\n            {\n\
    \                yield s;\n            }\n        }\n    }\n/*\n Given a 2D array\
    \ create a new array which contains the sum of each column.\n    >>> sum_columns([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]])\n    [12, 15, 18]\n*/\nalias Array!double Array2D;\n\
    unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo8i6btvu.d(32): Error: template instance `Array!double` template
    `Array` is not defined, did you mean Array2D?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8i6btvu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    assert(strings.length >= 0);\n    // TODO\
    \ is this correct?\n    if (strings.length == 0)\n        return null;\n    assert(substring.length\
    \ >= 0);\n    // TODO is this correct?\n    if (substring.length == 0)\n     \
    \   return null;\n    string[] new_strings = [];\n    foreach (str; strings)\n\
    \    {\n        // assert(str.length >= 0);\n        if (str.length < substring.length)\n\
    \            continue;\n        // TODO Should this be kept?\n        // assert(str.length\
    \ >= substring.length);\n        size_t found = 0;\n        for (size_t i = 0;\
    \ i < str.length; i++)\n        {\n            if (str[i] == substring[found])\n\
    \            {\n                found++;\n                if (found == substring.length)\n\
    \                {\n                    new_strings ~= str;\n                \
    \    break;\n                }\n            }\n            else\n            {\n\
    \                found = 0;\n            }\n        }\n    }\n    return new_strings;\n\
    }\n/*\n Merge an input array of strings into one and separate them with given\
    \ separator\n    >>> merge_strings([], \".\")\n    \"\"\n    >>> merge_strings([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \".\")\n    \"abc.bacd.cde.array\"\n   \
    \ \n*/\nstring merge_strings(string[] strings, string separator) \n{\n    assert(strings.length\
    \ >= 0);\n    if (strings.length == 0)\n        return \"\";\n    assert(separator.length\
    \ >= 0);\n    if (separator.length == 0)\n        return \"\";\n    string new_string\
    \ = \"\";\n    foreach (str; strings)\n    {\n        // assert(str.length >=\
    \ 0);\n        if (str.length == 0)\n            continue;\n        if (new_string.length\
    \ > 0)\n            new_string ~= separator;\n        new_string ~= str;\n   \
    \ }\n    return new_string;\n}\n/*\n Convert an input array of strings into an\
    \ integer array. \n Numbers with leading zeros\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8fpnp9wv.d(77): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8fpnp9wv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  string[] filtered_strings;\n  foreach(string\
    \ str; strings)\n  {\n    if(str.contains(substring))\n    {\n      filtered_strings\
    \ ~= str;\n    }\n  }\n  return filtered_strings;\n}\n/*\n Check if an input string\
    \ is a palindrome\n    >>> is_palindrome(\"bob\")\n    true\n    >>> is_palindrome(\"\
    ababa\")\n    true\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"\
    char\")\n    false\n    >>> is_palindrome(\"asdf\")\n    false\n    \n*/\nunittest\n\
    {\n    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpawycoibi.d(16): Error: no property `contains` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpawycoibi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164146
