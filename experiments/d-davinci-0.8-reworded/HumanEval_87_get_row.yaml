name: HumanEval_87_get_row
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
  \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
  \    each row may contain a different number of columns.\n    Given lst, and integer\
  \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
  \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
  \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
  \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L,\
  \ 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
  \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
  \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
  \ lst, long x) \n"
tests: "unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
  \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
  \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
  \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
  \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
  \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
  \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
  \ 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L,\
  \ 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L,\
  \ 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L,\
  \ 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L),\
  \ tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]],\
  \ 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L,\
  \ 2L)]);\n}\nvoid main(){}"
completions: ["{\n    Tuple!(long, long)[] res;\n    foreach(rowIndex, row; lst)\n\
    \    {\n        foreach(colIndex, item; row)\n        {\n            if(item ==\
    \ x)\n            {\n                res ~= tuple(rowIndex, colIndex);\n     \
    \       }\n        }\n    }\n    res.sort!((a, b) => a[0] == b[0] ? a[1] > b[1]\
    \ : a[0] < b[0]);\n    return res;\n}", "{\n    auto ret = appender!(Tuple!(long,\
    \ long)[])();\n    for (long row = 0; row < lst.length; row++)\n    {\n      \
    \  for (long col = 0; col < lst[row].length; col++)\n        {\n            if\
    \ (lst[row][col] == x)\n            {\n                ret.put(tuple(row, col));\n\
    \            }\n        }\n    }\n    return ret.data.sort(a => a[0]).sort(a =>\
    \ -a[1]);\n}", "{\n    auto lst_ret = Tuple!(long, long)[]();\n    for (long i\
    \ = 0L; i < lst.length; i++)\n    {\n        for (long j = 0L; j < lst[i].length;\
    \ j++)\n        {\n            if (lst[i][j] == x)\n            {\n          \
    \      lst_ret ~= tuple(i, j);\n            }\n        }\n    }\n    return lst_ret.sort!((a,\
    \ b) => a[0] == b[0] ? b[1] < a[1] : a[0] < b[0]);\n}\n/*\n    Expected Output:\n\
    \    (tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L))\n\
    */\n ", "{\n    long[][] coords;\n    for (long i = 0L; i < lst.length; i++)\n\
    \    {\n        if (lst[i].count(x) != 0L)\n        {\n            coords ~= lst[i].retroFind(x);\n\
    \        }\n    }\n    std.algorithm.sort!((a, b) => a[0] < b[0]);\n    foreach\
    \ (row; coords)\n    {\n        std.algorithm.sort!((a, b) => a[1] > b[1]);\n\
    \    }\n    return coords;\n}", "{\n    Tuple!(long, long)[] result;\n    foreach(immutable\
    \ long i, immutable row; lst)\n    {\n        immutable long[] indexes = row.indexOf(x);\n\
    \        if(indexes.length > 0)\n        {\n            foreach(immutable index;\
    \ indexes)\n            {\n                auto t = tuple(i, index);\n       \
    \         result ~= t;\n            }\n        }\n    }\n    return result.sort();\n\
    }", "    if (is(typeof(std.algorithm.find(lst, x).front.front) : long))\n{\n \
    \   Tuple!(long, long)[] result;\n    long x_idx;\n    long y_idx;\n    for (size_t\
    \ i = 0; i < lst.length; i++) \n    {\n        foreach (j; lst[i]) \n        {\n\
    \            if (j == x) \n            {\n                result ~= tuple(i, j);\n\
    \            }\n        }\n    }\n    return result;\n}\n ", "{\n    long[] ys;\n\
    \    foreach(idx, inner; lst) \n    {\n        foreach(jdx, num; inner) \n   \
    \     {\n            if(num == x) \n            {\n                ys ~= tuple(idx,\
    \ jdx);\n            }\n        }\n    }\n    return ys.sort!((a, b) => (a[0]\
    \ == b[0]) ? b[1] < a[1] : a[0] < b[0]);\n}\n// \u0412\u044B \u0434\u0430\u043D\
    \u044B \u0447\u0438\u0441\u043B\u0430, \u043A\u0430\u043A \u0432\u043B\u043E\u0436\
    \u0435\u043D\u043D\u044B\u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B,\n//\
    \ \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0430\u043F\u043E\u043C\u0438\
    \u043D\u0430\u044E\u0442 \u043C\u0430\u0442\u0440\u0438\u0446\u044B, \u043E\u0434\
    \u043D\u0430\u043A\u043E, \u0432 \u043E\u0442\u043B\u0438\u0447\u0438\u0435 \u043E\
    \u0442 \u043C\u0430\u0442\u0440\u0438\u0446,\n// \u043A\u0430\u0436\u0434\u0430\
    \u044F \u0441\u0442\u0440\u043E\u043A\u0430 \u043C\u043E\u0436\u0435\u0442 \u0441\
    \u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0440\u0430\u0437\u043D\u043E\
    \u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0442\
    \u043E\u043B\u0431\u0446\u043E\u0432.\n// \u0414\u0430\u043D\u043E lst, \u0438\
    \ \u0446\u0435\u043B\u043E\u0435 \u0447\u0438\u0441\u043B\u043E x, \u043D\u0430\
    \u0439\u0434\u0438\u0442\u0435 \u0446\u0435\u043B\u044B\u0435 \u0447\u0438\u0441\
    \u043B\u0430 x \u0432 \u043C\u0430\u0441\u0441\u0438\u0432\u0435,\n// \u0438 \u0432\
    \u0435\u0440\u043D\u0438\u0442\u0435 \u043C\u0430\u0441\u0441\u0438\u0432 \u043A\
    \u043E\u0440\u0442\u0435\u0436\u0435\u0439, [(x1, y1), (x2, y2) ...] \u0442\u0430\
    \u043A,\n// \u0447\u0442\u043E \u043A\u0430\u0436\u0434\u044B\u0439 \u043A\u043E\
    \u0440\u0442\u0435\u0436 - \u044D\u0442\u043E \u043A\u043E\u043E\u0440\u0434\u0438\
    \u043D\u0430\u0442\u0430 - (\u0441\u0442\u0440\u043E\u043A\u0430, \u0441\u0442\
    \u043E\u043B\u0431\u0435\u0446), \u043D\u0430\u0447\u0438\u043D\u0430\u044F \u0441\
    \ 0.\n// \u0421\u043E\u0440\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u043A\u043E\
    \u043E\u0440\u0434\u0438\u043D\u0430\u0442\u044B \u0432\u043D\u0430", "{\n   \
    \ auto res = new Tuple!(long, long)[];\n    foreach(i, e; lst)\n    {\n      \
    \  if(i < 0) continue;\n        auto indices = e.indexOf(x);\n        foreach(j,\
    \ v; indices)\n        {\n            res ~= tuple(i, j);\n        }\n    }\n\
    \    res.sort!((a, b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return\
    \ res;\n}", "{\n    import std.algorithm.iteration : filter, map;\n    import\
    \ std.algorithm.comparison : equal;\n    import std.range.primitives : iota;\n\
    \    import std.range : zip;\n    import std.algorithm.mutation : sort;\n    import\
    \ std.typecons : tuple;\n    auto result = lst.filter!(r => r.equal(x)).map!(r\
    \ => tuple(r.length, r.filter!(e => e == x).length)).sort!((a, b) => a[0] < b[0]\
    \ || a[0] == b[0] && a[1] > b[1]);\n    auto result2 = result.zip(iota(0L, result.length)).map!(t\
    \ => tuple(t[1], t[0][0])).sort!((a, b) => a[0] < b[0] || a[0] == b[0] && a[1]\
    \ > b[1]);\n    return result2;\n}", "{\n    Tuple!(long, long)[] ret = new Tuple!(long,\
    \ long)[0];\n    for (long i = 0; i < lst.length; i++) \n    {\n        for (long\
    \ j = 0; j < lst[i].length; j++) \n        {\n            if (lst[i][j] == x)\
    \ \n            {\n                ret ~= tuple(i, j);\n            }\n      \
    \  }\n    }\n    ret.sort!((a, b) => a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]));\n\
    \    return ret;\n}", "{\n    import std.algorithm : sort;\n    import std.typecons\
    \ : tuple;\n    import std.math : max;\n    import std.range : iota;\n    import\
    \ std.algorithm : filter;\n    import std.algorithm : join;\n    auto row = lst.filter!(a\
    \ => a.arrayof.find(x) != a.arrayof.length).enumerate;\n    foreach(i, a; row)\n\
    \    {\n        row[i].y = a.y.find(x);\n    }\n    row.sort!((a, b) => \n   \
    \           (a.x > b.x) || \n              (a.x == b.x && a.y > b.y)\n       \
    \      );\n    return row;\n}", "{\n    Tuple!(long, long)[] result;\n    int\
    \ count = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        for (int\
    \ j = 0; j < lst[i].length; j++)\n        {\n            if (lst[i][j] == x)\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  result = new Tuple!(long, long)[count];\n    int c = 0;\n    for (int i = 0;\
    \ i < lst.length; i++)\n    {\n        for (int j = 0; j < lst[i].length; j++)\n\
    \        {\n            if (lst[i][j] == x)\n            {\n                result[c]\
    \ = tuple(i, j);\n                c++;\n            }\n        }\n    }\n    int\
    \ asc(Tuple!(long, long) a, Tuple!(long, long) b)\n    {\n        return a[0]\
    \ - b[0];\n    }\n    sort(result, asc);\n    int desc(Tuple!(long, long) a, Tuple!(long,\
    \ long) b)\n    {\n        return a[1] - b[1];\n    }\n    stable_sort(result,\
    \ desc);\n    return result;\n}\n/*", "{\n    Tuple!(long, long)[] result;\n \
    \   foreach(i, ref row; lst) \n    {\n        foreach(j, r; row) \n        {\n\
    \            if(r == x)\n                result ~= tuple(i, j);\n        }\n \
    \   }\n    sort!(\"a.length > b.length\", \"a > b\")(result);\n    return result;\n\
    }", "{\n    auto res = new Tuple!(long, long)[];\n    long y = 0;\n    foreach(row;\
    \ lst)\n    {\n        long x = 0;\n        foreach(item; row)\n        {\n  \
    \          if(item == x)\n            {\n                res ~= tuple(y, x);\n\
    \            }\n            x++;\n        }\n        y++;\n    }\n    std.algorithm.sort!(\"\
    a.tupleof[0] < b.tupleof[0] || (a.tupleof[0] == b.tupleof[0] && a.tupleof[1] >\
    \ b.tupleof[1])\")(res);\n    return res;\n}", "{\n    long row = 0;\n    Tuple!(long,\
    \ long)[] result = [];\n    foreach(sublst; lst)\n    {\n        long column =\
    \ 0;\n        foreach(subsublst; sublst)\n        {\n            if(subsublst\
    \ == x)\n            {\n                result ~= tuple(row, column);\n      \
    \      }\n            column++;\n        }\n        row++;\n    }\n    return\
    \ result.sort!((a, b) => a[0] < b[0]).sort!((a, b) => a[1] > b[1]);\n}", "{\n\
    \    // add your code here\n    auto ret = appender!(Tuple!(long, long)[])();\n\
    \    long indx = 0;\n    for(auto i : lst)\n    {\n        auto col = 0;\n   \
    \     for(auto j : i)\n        {\n            if(j == x)\n            {\n    \
    \            ret.put(tuple(indx, col));\n            }\n            col++;\n \
    \       }\n        indx++;\n    }\n    std.algorithm.sort!(\"a.b > b.b\")(ret.data);\n\
    \    std.algorithm.sort!(\"a.a < b.a\")(ret.data);\n    return ret.data;\n}",
  "{\n    Tuple!(long, long)[] rows = [];\n    foreach(ind; 0 .. lst.length) \n  \
    \  {\n        foreach(jnd; 0 .. lst[ind].length) \n        {\n            if(lst[ind][jnd]\
    \ == x) \n            {\n                rows ~= tuple(ind, jnd);\n          \
    \  }\n        }\n    }\n    //Pragma(msg, rows);\n    rows.sort!((a, b) => a[0]\
    \ < b[0] || a[0] == b[0] && a[1] > b[1]);\n    return rows;\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, long[] row; lst)\n    {\n        foreach(j,\
    \ long v; row)\n        {\n            if(v == x)\n            {\n           \
    \     result ~= tuple(i, j);\n            }\n        }\n    }\n    return sort!((a,\
    \ b) => (a[0] == b[0]) ? b[1] < a[1] : a[0] < b[0])(result);\n}\n// ---", "{\n\
    \    Tuple!(long, long)[] arr;\n    bool temp = false;\n    foreach(row; 0..lst.length)\
    \ \n    {\n        foreach(num; 0..lst[row].length) \n        {\n            if(lst[row][num]\
    \ == x) \n            {\n                temp = true;\n                arr ~=\
    \ tuple(row, num);\n            }\n        }\n    }\n    if(temp)\n    {\n   \
    \     sort!(\"a[0] < b[0] || a[0] == b[0] && a[1] > b[1]\")(arr);\n        return\
    \ arr;\n    }\n    else\n    {\n        return [];\n    }\n}", "{\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.array;\n    return lst.map!(r\
    \ => r.enumerate().filter!(t => t[1] == x).map!(t => tuple(r.length, t[0]))).\n\
    \        filter!(t => t.length > 0).\n        array.\n        transposed.\n  \
    \      map!(t => t.tupleof).\n        sort!((a, b) => a[0] > b[0] || (a[0] ==\
    \ b[0] && a[1] < b[1])).\n        array;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
