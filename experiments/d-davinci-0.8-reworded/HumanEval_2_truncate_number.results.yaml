name: HumanEval_2_truncate_number
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  float result;\n\
    \  double int_part;\n  result = modf(number, &int_part);\n  return result;\n}\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzxpwal_o.d(17): Error: function `std.math.modf(real x, ref real\
    \ i)` is not callable using argument types `(float, double*)`\\n/tmp/tmpzxpwal_o.d(17):\
    \        cannot pass rvalue argument `& int_part` of type `double*` to parameter\
    \ `ref real i`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzxpwal_o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return number -\
    \ cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // an alias for\
    \ `std.math.floor`\n    return number - floor(number);\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\nGiven a binary number represented by a string, return\
    \ the decimal value.\n    >>> parse_binary(\"101010\")\n    42\n*/\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // here we use\
    \ tuple to unpack the value returned by split_floats()\n    // see http://dlang.org/phobos/std_typecons.html#.split_floats\n\
    \    int integerPart;\n    float decimalPart;\n    tie(integerPart, decimalPart)\
    \ = split_floats(number);\n    return decimalPart;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp61tsiima.d(19): Error: undefined identifier `tie`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp61tsiima.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    //TODO: your\
    \ code here\n}\n// Uncomment to run the truncate_number unit test\n//unittest\n\
    {\n    // Decimal part of a number\n    assert(truncate_number(4.4) == 0.4);\n\
    \    assert(truncate_number(4.5) == 0.5);\n    assert(truncate_number(4.6) ==\
    \ 0.6);\n    \n    // No decimal part of a number\n    assert(truncate_number(10)\
    \ == 0);\n    assert(truncate_number(10.0) == 0);\n    \n    // Positive integer\
    \ with decimal part\n    assert(truncate_number(3.1) == 0.1);\n    assert(truncate_number(3.5)\
    \ == 0.5);\n    assert(truncate_number(3.9) == 0.9);\n    \n    // Negative integer\
    \ with decimal part\n    assert(truncate_number(-3.1) == 0.9);\n    assert(truncate_number(-3.5)\
    \ == 0.5);\n    assert(truncate_number(-3.9) == 0.1);\n    \n    // Negative integer\
    \ without decimal part\n    assert(truncate_number(-10) == 0);\n    assert(truncate_number(-10.0)\
    \ == 0);\n}\n/*\n    Given an integer 'num' and a number of moves 'steps', divide\n\
    \    'num' in half that many times and return the integer result.\n    If 'num'\
    \ is odd and cannot be divided in half, the algorithm\n    should try to make\
    \ it the closest even number (for example,\n    if it is 5, the closest even number\
    \ is 6).\n    \n    >>> half_num(6, 1)\n    3\n    \n    >>> half_num(6, 2)\n\
    \    1\n    \n    >>> half_num(6, 3)\n    0\n    \n    >>> half_num(6, 4)\n  \
    \  0\n    \n    >>> half_num(5, 1)\n    2\n    \n    >>> half_num(5, 2)\n    1\n\
    \    \n    >>> half_num(5, 3)\n\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc65d__xj.d(19): Error: declaration expected, not `{`\\n/tmp/tmpc65d__xj.d(22):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmpc65d__xj.d(23): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpc65d__xj.d(26): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmpc65d__xj.d(27): Error: declaration expected, not `assert`\\\
    n/tmp/tmpc65d__xj.d(30): Error: declaration expected, not `assert`\\n/tmp/tmpc65d__xj.d(31):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmpc65d__xj.d(32): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpc65d__xj.d(35): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmpc65d__xj.d(36): Error: declaration expected, not `assert`\\\
    n/tmp/tmpc65d__xj.d(37): Error: declaration expected, not `assert`\\n/tmp/tmpc65d__xj.d(40):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmpc65d__xj.d(41): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpc65d__xj.d(42): Error: unrecognized declaration\\\
    n/tmp/tmpc65d__xj.d(43): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc65d__xj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ floor(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n \
    \   assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n   \
    \ assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return float(int(number))\
    \ - number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_imkmuja.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp_imkmuja.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return number -\
    \ cast(int)number;\n}\n/*\n Given a positive floating point number, it can be\
    \ decomposed into\n    and integer part (largest integer smaller than given number)\
    \ and decimals\n    (leftover part always smaller than 1).\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt79rc1qw.d(17): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt79rc1qw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // TODO:\n  \
    \  // The decimal part is the decimal value of the number subtracted by its\n\
    \    // integer part.\n    float n = number - int(number);\n    return n;\n}\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2v3j44qv.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp2v3j44qv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return 0.0;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc4r2qej6.d(21): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d35]\\n??:? void tmpc4r2qej6.__unittest_L17_C1()\
    \ [0x427a4a]\\n??:? void tmpc4r2qej6.__modtest() [0x427ab8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba5b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a8ee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fa81]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff30]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa0d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8c5]\\n??:? runModuleUnitTests [0x42b831]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428184]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42810b]\\n??:? _d_run_main [0x428076]\\n??:? main [0x427acb]\\\
    n??:? __libc_start_main [0x92192554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n    @safe pure nothrow\
    \ @nogc {\n    return number - cast(int)number;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\n    Given a positive floating point number, it can\
    \ be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfsmd_ady.d(17): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfsmd_ady.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int larger =\
    \ number;\n    float small = number - larger;\n    return small;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0qfzgxwt.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0qfzgxwt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n    in(number) nothrow\
    \ @nogc\n{\n    // negative numbers are not handled\n    assert(number >= 0);\n\
    \    // the math module has the `modf` function which does exactly this\n    float\
    \ int_part = 0.0;\n    return modf(number, int_part);\n}\n/*\n When you are trying\
    \ to call a function with parameters that don't match,\n you will get an error.\
    \ The first way to fix this is to make sure the parameters\n match.\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwt3hyx88.d(14): Error: \\'nothrow\\' cannot be placed after a\
    \ template constraint\\n/tmp/tmpwt3hyx88.d(17): Error: declaration expected, not\
    \ `assert`\\n/tmp/tmpwt3hyx88.d(20): Error: declaration expected, not `return`\\\
    n/tmp/tmpwt3hyx88.d(22): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwt3hyx88.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
