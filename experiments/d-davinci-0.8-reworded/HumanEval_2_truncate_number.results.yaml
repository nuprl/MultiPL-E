language: d
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  float result;\n\
    \  double int_part;\n  result = modf(number, &int_part);\n  return result;\n}\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo0kfshy6.d(17): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, double*)`

    /tmp/tmpo0kfshy6.d(17):        cannot pass rvalue argument `& int_part` of type
    `double*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo0kfshy6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return number -\
    \ cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // an alias for\
    \ `std.math.floor`\n    return number - floor(number);\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\nGiven a binary number represented by a string, return\
    \ the decimal value.\n    >>> parse_binary(\"101010\")\n    42\n*/\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // here we use\
    \ tuple to unpack the value returned by split_floats()\n    // see http://dlang.org/phobos/std_typecons.html#.split_floats\n\
    \    int integerPart;\n    float decimalPart;\n    tie(integerPart, decimalPart)\
    \ = split_floats(number);\n    return decimalPart;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptf1ncg4z.d(19): Error: undefined identifier `tie`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptf1ncg4z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    //TODO: your\
    \ code here\n}\n// Uncomment to run the truncate_number unit test\n//unittest\n\
    {\n    // Decimal part of a number\n    assert(truncate_number(4.4) == 0.4);\n\
    \    assert(truncate_number(4.5) == 0.5);\n    assert(truncate_number(4.6) ==\
    \ 0.6);\n    \n    // No decimal part of a number\n    assert(truncate_number(10)\
    \ == 0);\n    assert(truncate_number(10.0) == 0);\n    \n    // Positive integer\
    \ with decimal part\n    assert(truncate_number(3.1) == 0.1);\n    assert(truncate_number(3.5)\
    \ == 0.5);\n    assert(truncate_number(3.9) == 0.9);\n    \n    // Negative integer\
    \ with decimal part\n    assert(truncate_number(-3.1) == 0.9);\n    assert(truncate_number(-3.5)\
    \ == 0.5);\n    assert(truncate_number(-3.9) == 0.1);\n    \n    // Negative integer\
    \ without decimal part\n    assert(truncate_number(-10) == 0);\n    assert(truncate_number(-10.0)\
    \ == 0);\n}\n/*\n    Given an integer 'num' and a number of moves 'steps', divide\n\
    \    'num' in half that many times and return the integer result.\n    If 'num'\
    \ is odd and cannot be divided in half, the algorithm\n    should try to make\
    \ it the closest even number (for example,\n    if it is 5, the closest even number\
    \ is 6).\n    \n    >>> half_num(6, 1)\n    3\n    \n    >>> half_num(6, 2)\n\
    \    1\n    \n    >>> half_num(6, 3)\n    0\n    \n    >>> half_num(6, 4)\n  \
    \  0\n    \n    >>> half_num(5, 1)\n    2\n    \n    >>> half_num(5, 2)\n    1\n\
    \    \n    >>> half_num(5, 3)\n\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpecckit0u.d(19): Error: declaration expected, not `{`

    /tmp/tmpecckit0u.d(22): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(23): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(26): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(27): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(30): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(31): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(32): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(35): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(36): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(37): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(40): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(41): Error: declaration expected, not `assert`

    /tmp/tmpecckit0u.d(42): Error: unrecognized declaration

    /tmp/tmpecckit0u.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpecckit'
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ floor(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n \
    \   assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n   \
    \ assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return float(int(number))\
    \ - number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfema599w.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfema599w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return number -\
    \ cast(int)number;\n}\n/*\n Given a positive floating point number, it can be\
    \ decomposed into\n    and integer part (largest integer smaller than given number)\
    \ and decimals\n    (leftover part always smaller than 1).\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph6y1537p.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6y1537p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // TODO:\n  \
    \  // The decimal part is the decimal value of the number subtracted by its\n\
    \    // integer part.\n    float n = number - int(number);\n    return n;\n}\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnx5mhgp3.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnx5mhgp3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return 0.0;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxq1l9sgn.d(21): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d35]

    ??:? void tmpxq1l9sgn.__unittest_L17_C1() [0x427a4a]

    ??:? void tmpxq1l9sgn.__modtest() [0x427ab8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8c5]

    ??:? runModuleUnitTests [0x42b831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428184]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n    @safe pure nothrow\
    \ @nogc {\n    return number - cast(int)number;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\n    Given a positive floating point number, it can\
    \ be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz24gyv8x.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz24gyv8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int larger =\
    \ number;\n    float small = number - larger;\n    return small;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgdg68vjx.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgdg68vjx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n    in(number) nothrow\
    \ @nogc\n{\n    // negative numbers are not handled\n    assert(number >= 0);\n\
    \    // the math module has the `modf` function which does exactly this\n    float\
    \ int_part = 0.0;\n    return modf(number, int_part);\n}\n/*\n When you are trying\
    \ to call a function with parameters that don't match,\n you will get an error.\
    \ The first way to fix this is to make sure the parameters\n match.\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbfwusm_l.d(14): Error: ''nothrow'' cannot be placed after a template
    constraint

    /tmp/tmpbfwusm_l.d(17): Error: declaration expected, not `assert`

    /tmp/tmpbfwusm_l.d(20): Error: declaration expected, not `return`

    /tmp/tmpbfwusm_l.d(22): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbfwusm_l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - trunc(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(long)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    /* \n       \
    \ We convert the number in a tuple representing an integer part and a decimal\
    \ part\n        and we extract the decimal part. Note that the decimal part is\
    \ a string because\n        it contains the decimal separator.\n        Tuple\
    \ can be created in this way:\n        >>> auto my_tuple = tuple(1, \"a\");\n\
    \        >>> my_tuple[0]\n        1\n        >>> my_tuple[1]\n        \"a\"\n\
    \    */\n    auto parts = tuple(number.to!int, number.to!string);\n    return\
    \ to!float(parts[1].split(\".\")[1]);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1b4mqglm.d(26): Error: no property `to` for type `float`

    /tmp/tmp1b4mqglm.d(26): Error: no property `to` for type `float`

    /tmp/tmp1b4mqglm.d(27): Error: template instance `to!float` template `to` is not
    defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1b4mqglm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ cast(float*)null);\n}\n/*\n    Write a function that takes an integer exponent\
    \ and returns\n    a float.\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvl2y6zhs.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvl2y6zhs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(long)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  float int_part\
    \ = cast(int) number;\n  return number - int_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    /*\n     * The\
    \ std.math.trunc function truncates the decimals of the given number\n     * and\
    \ returns the result as an integer number.\n     * \n     * Using the std.typecons.wrap\
    \ function we convert the result to a float.\n     *\n     * This result is subtracted\
    \ from the number and the result returned.\n     */\n    return number - wrap!float(trunc(number));\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(5188):
    Error: template instance `std.typecons.dynamicCast!(inout(float))` does not match
    template declaration `dynamicCast(T) if (is(T == class) || is(T == interface))`

    /tmp/tmptxj6n_a0.d(23): Error: template instance `std.typecons.wrap!float.wrap!real`
    error instantiating

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxj6n_a0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float[2] result;\n\
    \    float dummy;\n    result = modf(number, dummy);\n    return result[1];\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcuo48ova.d(17): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float)`

    /tmp/tmpcuo48ova.d(17):        cannot pass argument `dummy` of type `float` to
    parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcuo48ova.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return (int)number\
    \ - number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9l0sa2uk.d(15): Error: C style cast illegal, use `cast(int)number`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9l0sa2uk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return number -\
    \ cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc =\
    \ trunc(number);\n    return number - trunc;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0;\n    int integ = cast(int)number;\n    return number - integ;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(long)number;\n}\n/*\n    Given a number and its power, return the power\
    \ applied to the number.\n    >>> pow(3, 2)\n    9\n*/\nfloat pow(float number,\
    \ float power)\n{\n    float result = number;\n    for (int i = 1; i < power;\
    \ i++)\n    {\n        result *= number;\n    }\n    return result;\n}\n/*\n \
    \   Given a number convert it to the corresponding character.\n    >>> to_char(2)\n\
    \    '2'\n*/\nchar to_char(float number)\n{\n    return cast(char)(number + 48);\n\
    }\n/*\n    Given a number, return the absolute value.\n    >>> abs(-3)\n    3\n\
    */\nfloat abs(float number)\n{\n    return number < 0 ? number * -1 : number;\n\
    }\n/*\n    Given a number, return the number of digits it has.\n    >>> digits(3456)\n\
    \    4\n*/\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // Return the\
    \ decimal part of the number.\n    return number % cast(int)number;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ cast(float*)null);\n}\n/*\n    Return the integer part of the number.\n    >>>\
    \ truncate_number(3.5)\n    3\n*/\nfloat truncate_number_int(float number) \n\
    {\n    return trunc(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw3lkv8s8.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpw3lkv8s8.d(15):        cannot pass rvalue argument `cast(float*)null`
    of type `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw3lkv8s8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    Tuple!(int, float)\
    \ integer_and_decimal = std.math.modf(number);\n    return integer_and_decimal[1];\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp85_dvqeb.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp85_dvqeb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float integral_part;\n\
    \    float float_part;\n    float_part = modf(number, &integral_part);\n    return\
    \ float_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzj1jlr57.d(17): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpzj1jlr57.d(17):        cannot pass rvalue argument `& integral_part` of
    type `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzj1jlr57.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto m = modf(number);\n\
    \    return m[1];\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprz2ewswb.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprz2ewswb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto is_neg =\
    \ (number < 0.0);\n    // If number is negative, we make it positive to perform\
    \ operation and\n    // toggle sign back in the end.\n    auto num = is_neg ?\
    \ -number : number;\n    auto res = num - cast(int)num;\n    if (is_neg) res =\
    \ -res;\n    return res;\n}\n/*\n Given a floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7daktzic.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7daktzic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return cast(float)cast(int)number;\n\
    }\n/*\n This function takes an angle in degrees and returns an angle between\n\
    \ 0 and 360.\n Note that it doesn't take the smallest positive angle between 0\
    \ and 360,\n but the closest one to the input.\n >>> normalize_angle(15)\n 15\n\
    \ >>> normalize_angle(370)\n 10\n >>> normalize_angle(-5)\n 355\n >>> normalize_angle(-360)\n\
    \ 0\n >>> normalize_angle(-740)\n 280\n*/\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpabast045.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d35]

    ??:? void tmpabast045.__unittest_L33_C1() [0x427a46]

    ??:? void tmpabast045.__modtest() [0x427ab4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8c5]

    ??:? runModuleUnitTests [0x42b831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428184]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float integer_part;\n\
    \    return modf(number, &integer_part);\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxsxarj9.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpaxsxarj9.d(16):        cannot pass rvalue argument `& integer_part` of
    type `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxsxarj9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int a = cast(int)number;\n\
    \    float b = number - a;\n    return b;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - int(number);\n}\n/*\n Given a vector of floating point numbers, get the vector\
    \ of their\n    decimal parts only.\n    >>> truncate_vector([3.5, 2.6, 4.3])\n\
    \    [0.5, 0.6, 0.3]\n*/\nfloat[] truncate_vector(float[] vector) \n{\n    float[]\
    \ result = new float[vector.length];\n    for (int i = 0; i < vector.length; i++)\n\
    \    {\n        result[i] = truncate_number(vector[i]);\n    }\n    return result;\n\
    }\n/*\n Given a floating point number, get its rounded integer part.\n    >>>\
    \ round_number(3.5)\n    4\n    >>> round_number(3.2)\n    3\n*/\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqz8ualgi.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqz8ualgi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result;\n\
    \    int digit = int(number);\n    float point = number - digit;\n    result =\
    \ point;\n    return result;\n}\n/*\n Given a random number generator that returns\
    \ a floating point number between\n 0.0 and 1.0, return a random floating point\
    \ number between min and max.\n >>> rand_between(min=5, max=8)\n 5.46456543\n\
    */\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_bbfcicx.d(16): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_bbfcicx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float part_decimal\
    \ = modf(number, out float part_integer);\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyogpwxhn.d(15): Error: expression expected, not `out`

    /tmp/tmpyogpwxhn.d(15): Error: found `float` when expecting `,`

    /tmp/tmpyogpwxhn.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyogpwxhn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part\
    \ = cast(int)number;\n    float decimal_part = number - cast(float)int_part;\n\
    \    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // return function\
    \ trunc()\n    return trunc(number);\n}\n/*\n Given a positive floating point\
    \ number, it can be decomposed into\n    and integer part (largest integer smaller\
    \ than given number) and decimals\n    (leftover part always smaller than 1).\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxj883rd3.d(18): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxj883rd3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ trunc(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n \
    \   assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n   \
    \ assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ (int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n   \
    \ assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuioylejp.d(15): Error: C style cast illegal, use `cast(int)number`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuioylejp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ null);\n}\n/*\n    Remove trailing zeros from given string.\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj3dr4uvb.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj3dr4uvb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float int_part;\n\
    \    float float_part;\n    float_part = modf(number, int_part);\n    return float_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ip_332c.d(17): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float)`

    /tmp/tmp_ip_332c.d(17):        cannot pass argument `int_part` of type `float`
    to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ip_332c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto integer_part\
    \ = cast(int)number;\n    return number - integer_part;\n}\n/*\n Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8m2ujmmr.d(18): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8m2ujmmr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n    { \n    float int_part;\n\
    \    return modf(number, &int_part);\n    }\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgyp32n4r.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpgyp32n4r.d(16):        cannot pass rvalue argument `& int_part` of type
    `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgyp32n4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto number_int\
    \ = cast(int)number;\n    return number - number_int;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    const float ipart\
    \ = cast(float) cast(int) number;\n    const float fpart = number - ipart;\n \
    \   return fpart;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    static import\
    \ std.math;\n    return number - trunc(number);\n}\n/*\n    Return the integer\
    \ part of the number\n    >>> truncate_number(3.5)\n    3\n*/\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return number -\
    \ int(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n   \
    \ assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv3r0912a.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv3r0912a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float [2] div_result;\n\
    \    div_result = modf(number);\n    return div_result[1];\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4nz8foas.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4nz8foas.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - int(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n \
    \   assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n   \
    \ assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp62ghssua.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp62ghssua.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    assert(number\
    \ >= 0.0);\n    auto truncated = cast(int) number;\n    return number - truncated;\n\
    }\n//void main()\n//{\n//    writefln(\"%f\", truncate_number(3.5));\n//}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int base;\n \
    \   return std.math.modf(number,base);\n}\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9r5fqf7w.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, int)`

    /tmp/tmp9r5fqf7w.d(16):        cannot pass argument `base` of type `int` to parameter
    `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9r5fqf7w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\n Write a function to sort an integer array with quick\
    \ sort algorithm.\n*/\nT[] quicksort(T)(T[] a) \n    if (is(T == int))\n{\n  \
    \  if (a.length <= 1) return a;\n    int pivot = a[a.length / 2];\n    T[] less,\
    \ greater;\n    foreach (i, ref e; a) \n    {\n        if (e < pivot) \n     \
    \   {\n            less ~= e;\n        } \n        else if (e > pivot) \n    \
    \    {\n            greater ~= e;\n        }\n    }\n    return quicksort(less)\
    \ ~ quicksort(greater);\n}\n/*\n Write a function to sort an integer array with\
    \ merge sort algorithm.\n*/\nT[] mergesort(T)(T[] a) \n    if (is(T == int))\n\
    {\n    if (a.length <= 1) return a;\n    T[] left = a[0 .. a.length / 2];\n  \
    \  T[] right = a[a.length / 2 .. $];\n    return merge(mergesort(left), mergesort(right));\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1.0;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\n Given a positive floating point number, it can be\
    \ decomposed into\n    and integer part (largest integer smaller than given number)\
    \ and decimals\n    (leftover part always smaller than 1).\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_qqky8m9.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_qqky8m9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ std.typecons.Tuple!(int, float)(number).field1;\n}\n/*\n    Given a floating\
    \ point number, return the distance from\n    the whole number closest to it.\n\
    \    >>> std.math.round(1.2)\n    1\n    >>> closest_number(1.2)\n    0.2\n*/\n\
    float closest_number(float number) \n{\n\treturn std.typecons.Tuple!(int, float)(number).field2;\n\
    }\n/*\n    Given a list of floating point numbers, return\n    a new list of all\
    \ the truncated numbers.\n    >>> truncate_list([1.1, 2.2, 3.3])\n    [0.1, 0.2,\
    \ 0.3]\n*/\nfloat[] truncate_list(float[] numbers) \n{\n\treturn numbers.map!(x\
    \ => truncate_number(x)).array;\n}\n/*\n    Given a list of floating point numbers,\
    \ return\n    a new list of all the closest_numbers\n    >>> closest_numbers([1.1,\
    \ 2.2, 3.3])\n    [0.1, 0.2, 0.3]\n*/\nfloat[] closest_numbers(float[] numbers)\
    \ \n{\n\treturn numbers.map!(x => closest_number(x)).array;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyb2gbp3c.d(15): Error: none of the overloads of `this` are callable
    using argument types `(float)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(668):        `std.typecons.Tuple!(int,
    float).Tuple.this(int _param_0, float _param_1)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(689):        `std.typecons.Tuple!(int,
    float).Tuple.__ctor(U, ulong n)(U[n] values) if (n == Types.length && allSatisfy!(isBuildableFrom!U,
    Types))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(715):        `std.typecons.Tuple!(int,
    float).Tuple.__ctor(U)(U another) if (areBuildCompatibleTuples!(typeof(this),
    U))`

    /tmp/tmpyb2gbp3c.d(27): Error: none of the overloads of `this` are callab'
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number - (int)number;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkvphlm0v.d(15): Error: C style cast illegal, use `cast(int)number`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkvphlm0v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return (number\
    \ - floor(number));\n}\n/*\n Given a positive floating point number, it can be\
    \ decomposed into\n    and integer part (largest integer smaller than given number)\
    \ and decimals\n    (leftover part always smaller than 1).\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt7tq640u.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt7tq640u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // need an int\
    \ part (largest integer smaller than given number)\n    int part = to!int(number);\n\
    \    // decimals (leftover part always smaller than 1)\n    return number - part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdf77vww0.d(16): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdf77vww0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return modf(number,\
    \ cast(float*)null);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2dl4kfzo.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmp2dl4kfzo.d(15):        cannot pass rvalue argument `cast(float*)null`
    of type `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2dl4kfzo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float int_part;\n\
    \    float float_part;\n    float_part = modf(number, &int_part);\n    return\
    \ float_part;\n}\n/*\n Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphgywoccq.d(20): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphgywoccq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int truncated\
    \ = cast(int)number;\n    float decimals = number - truncated;\n    return decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return float(number\
    \ - cast(int)number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\nWrite a function to calculate the sum of all numbers\
    \ in an array.\n*/\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto int_part\
    \ = cast(int)number;\n    return number - int_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // Get the integer\
    \ part of the number\n    auto integer = cast(int) number;\n    // Substracting\
    \ integer part from original number\n    // should give us the decimal part\n\
    \    return number - integer;\n}\n/*\n    Convert degrees to radians\n    >>>\
    \ convert_degrees_to_radians(180)\n    3.141592653589793\n*/\nfloat convert_degrees_to_radians(float\
    \ degrees) \n{\n    return degrees * PI / 180;\n}\n/*\n    Convert radians to\
    \ degrees\n    >>> convert_radians_to_degrees(3.14)\n    179.908\n*/\nfloat convert_radians_to_degrees(float\
    \ radians) \n{\n    return radians * 180 / PI;\n}\n/*\n   Given a latitude, longitude\
    \ and bearing to travel, find the new\n   coordinate.\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphp3jv7r8.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphp3jv7r8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - to!int(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcd8b6rxx.d(15): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcd8b6rxx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\n \n/*\nGiven a number and an array of numbers.\n    Return the product\
    \ of all numbers in the array\n    whose decimal part is smaller than the decimal\
    \ part of the given number.\n    >>> truncate_number_product(3.5, [1.5, 1.25,\
    \ 3.5, 4.5])\n    1.5\n*/\nfloat truncate_number_product(float number, float[]\
    \ numbers) \n{\n    float result = 1;\n    foreach (n; numbers)\n    {\n     \
    \   if (truncate_number(n) < truncate_number(number))\n        {\n           \
    \ result *= n;\n        }\n    }\n    return result;\n}\n \n/*\n Given a list\
    \ of elements and a list of tuples containing the following values:\n    * operation\
    \ symbol\n    * operation function\n    * priority\n    * associativity\n    *\
    \ expected number of elements\n    and a list of operators, return the result\
    \ of the expression.\n    >>> get_calculation_result([1, 2, 3, 4], [(`+`, (x,\
    \ y) => x + y, 1, `left`, 2), (`-`, (x, y) => x - y, 1, `left`, 2), (`*`, (x,\
    \ y) => x * y, 2, `left`, 2), (`/`, (x, y) => x / y, 2, `left`, 2)], [`*`, `-`,\
    \ `+`, `/`])\n    -5\n*/\n \n// structure for the operator tuple\nstruct Operator\n\
    {\n    string symbol;\n    int function(int, int) operation;\n    int priority;\n\
    \    string associativity;\n    int expected_number_of_arguments;\n}\n \nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1.0;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    /*\n        You\
    \ can use std.math.modf to get the integer and decimal part \n        of a number.\
    \ The modf function takes a float number and \n        returns a Tuple!(float,\
    \ float) with the first part being \n        the integer and the second part being\
    \ the decimal part.\n    */\n    auto parts = modf(number);\n    return parts[1];\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwpbz36zf.d(21): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwpbz36zf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,null);\n\
    }\n/*\n    Given a string representation of a number,\n    return the number without\
    \ trailing zeros.\n    >>> truncate_number(\"120.5000\")\n    \"120.5\"\n*/\n\
    string truncate_number(string number) \n{\n    //TODO: I dont know how to do this\
    \ yet...\n    return number;\n}\n/*\n    Given a string representation of a number,\n\
    \    return the number without trailing zeros.\n    >>> truncate_number(\"120.5000\"\
    )\n    \"120.5\"\n*/\nstring truncate_number(string number) \n{\n    if(number.empty)\
    \ return \"\";\n    string tmp;\n    if(number[$-1] == '.') \n    {\n        number.popBack();\n\
    \        tmp = \".\";\n    }\n    number.popBack();\n    while(number.length >\
    \ 0 && number[$-1] == '0') \n    {\n        number.popBack();\n    }\n    number\
    \ ~= tmp;\n    return number;\n}\n/*\n    Find the number of trailing zeros of\
    \ a factorial.\n    >>> zeros(0)\n    0\n    >>> zeros(6)\n    1\n    >>> zeros(30)\n\
    \    7\n*/\nsize_t zeros(size_t number) \n{\n    size_t zeros = 0;\n    while\
    \ (number > 0) \n    {\n        number /= 5;\n        zeros += number;\n    }\n\
    \    return zeros;\n}\n/*\n    Write a function that will return the count of\
    \ distinct case-insensitive alphabetic characters\n    and numeric digits that\
    \ occur more than once in the input string.\n    The input string can be assumed\
    \ to contain only alphabets (both uppercase and lowercase) and numeric digits.\n\
    \    >>> duplicate_count(\"abcde\")\n    0\n    >>> duplicate_count(\"abcdea\"\
    )\n    1\n    >>> duplicate_count(\"indivisibility\")\n    1\n*/\nsize_t duplicate_count(string\
    \ input) \n{\n    string s = input.toLower();\n    size_t count = 0;\n   \nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnq90a7m2.d(86): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnq90a7m2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float ipart;\n\
    \    float fpart = modf(number, &ipart);\n    return fpart;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfr9amkrm.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpfr9amkrm.d(16):        cannot pass rvalue argument `& ipart` of type `float*`
    to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfr9amkrm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n//------------------------------------------------------------------\n\
    /*\n    Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppcb4s8l8.d(18): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppcb4s8l8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return number -\
    \ cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float ceil =\
    \ ceil(number);\n    return ceil - number;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprl5fo1c0.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ead]

    ??:? void tmprl5fo1c0.__unittest_L18_C1() [0x427bf1]

    ??:? void tmprl5fo1c0.__modtest() [0x427c2c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd3f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42abd2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fd65]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430214]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fcf1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aba9]

    ??:? runModuleUnitTests [0x42bb15]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  // your code here\n\
    \  return number - cast(int)number;\n}\n/*\n    This is a simple way to wrap a\
    \ piece of code so that it can be executed at a later time.\n    The syntax is\
    \ a bit strange, but it's very useful in some cases.\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpch217r6c.d(18): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpch217r6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto[a, b] =\
    \ truncate(number);\n    return b;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvf9amy0o.d(15): Error: basic type expected, not `[`

    /tmp/tmpvf9amy0o.d(15): Error: found `,` when expecting `]`

    /tmp/tmpvf9amy0o.d(15): Error: semicolon expected, not `]`

    /tmp/tmpvf9amy0o.d(15): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvf9amy0o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // TODO: write\
    \ code here\n    return 0.0;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7zq75zck.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d35]

    ??:? void tmp7zq75zck.__unittest_L18_C1() [0x427a4a]

    ??:? void tmp7zq75zck.__modtest() [0x427ab8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8c5]

    ??:? runModuleUnitTests [0x42b831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428184]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part\
    \ = (int) number;\n    return number - integer_part;\n}\nfloat truncate_number_using_std(float\
    \ number) \n{\n    return number - cast(int) number;\n}\n/*\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa9_rjagq.d(15): Error: C style cast illegal, use `cast(int)number`

    /tmp/tmpa9_rjagq.d(22): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa9_rjagq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % float(int(number));\n}\n/*\nGiven a two dimensional array, return the flattened\
    \ version of the array.\n    >>> flatten([[1, 2], [3, 4]])\n    [1, 2, 3, 4]\n\
    */\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0str9uy1.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0str9uy1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ cast(float *) null);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqo793ne.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpvqo793ne.d(15):        cannot pass rvalue argument `cast(float*)null`
    of type `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqo793ne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return float(number\
    \ - float(int(number)));\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5ong67ti.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ong67ti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    import std.typecons\
    \ : Tuple;\n    import std.string;\n    Tuple!(int, float) i_f = (cast(int)number,\
    \ number - cast(int)number);\n    string s = format( \"integer part: %d, decimal\
    \ part: %f\", i_f[0], i_f[1]);\n    writeln(s);\n    return i_f[1];\n}\n/*\n \
    \   Return the integer part of the number\n    >>> truncate_number(3.5)\n    3\n\
    */\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyz1vk8xm.d(17): Error: Using the result of a comma expression is
    not allowed

    /tmp/tmpyz1vk8xm.d(17): Error: none of the overloads of `this` are callable using
    argument types `(float)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(668):        `std.typecons.Tuple!(int,
    float).Tuple.this(int _param_0, float _param_1)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(689):        `std.typecons.Tuple!(int,
    float).Tuple.__ctor(U, ulong n)(U[n] values) if (n == Types.length && allSatisfy!(isBuildableFrom!U,
    Types))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(715):        `std.typecons.Tuple!(int,
    float).Tuple.__ctor(U)(U another) if (areBuildCompatibleTuples!(typeof(this),
    U))`

    /tmp/tmpyz1vk8xm.d(19): Error: `writeln` is not defined, perhaps `import std.stdio;`
    is needed?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyz1vk8xm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % cast(int)number;\n}\n/*\n    Given a positive floating point number, it can\
    \ be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp09grx2tk.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp09grx2tk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto numberParts\
    \ = split(number);\n    return numberParts[1];\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphcda2irv.d(15): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphcda2irv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // get integer\
    \ part \n    float int_part = cast(int)number;\n    // get decimals\n    float\
    \ dec_part = number - int_part;\n    return dec_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder\
    \ = number % 1;\n    return remainder;\n}\n/*\nIn mathematics, an identity matrix\
    \ (sometimes ambiguously called a unit matrix)\nof size n is the n \xD7 n square\
    \ matrix with ones on the main diagonal and zeros elsewhere.\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuzxsa3d6.d(18): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuzxsa3d6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float[] t = float.toString(number).split(\"\
    .\");\n    return float.fromString(\"0.\" ~ t[1]);\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpds9sh_ly.d(15): Error: no property `toString` for type `float`

    /tmp/tmpds9sh_ly.d(16): Error: no property `fromString` for type `float`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpds9sh_ly.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    if(number > 0){\n\
    \        int ipart = to!int(number);\n        float dpart = number - ipart;\n\
    \        return dpart;\n    }\n    else{\n        return 0;\n    }\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpftdo7eim.d(16): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpftdo7eim.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    if (number <\
    \ 0) \n    {\n        return -1.0;\n    }\n    return number - cast(int)number;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float i;\n  \
    \  float f = modf(number, i);\n    return f;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpow_2wphr.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float)`

    /tmp/tmpow_2wphr.d(16):        cannot pass argument `i` of type `float` to parameter
    `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpow_2wphr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ &number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppz39vzo8.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmppz39vzo8.d(15):        cannot pass rvalue argument `& number` of type
    `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz39vzo8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n   return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto number_as_tuple\
    \ = std.typecons.tuple(number);\n    int int_part = number_as_tuple[0];\n    float\
    \ decimal_part = number_as_tuple[1];\n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp0xpcy4u.d(16): Error: cannot implicitly convert expression `number_as_tuple.__expand_field_0`
    of type `float` to `int`

    /tmp/tmpp0xpcy4u.d(17): Error: array index `[1]` is outside array bounds `[0 ..
    1]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp0xpcy4u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    /*\n        1.\
    \ Converts the number to a string\n        2. Splits the string into a \"head\"\
    \ containing the integer part and\n        \"tail\" containing the decimal part\n\
    \        3. converts the decimal part back to a float\n    */\n    return to!float(split(to!string(number),\
    \ \".\")[1]);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0lw_g3ym.d(21): Error: template instance `to!float` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0lw_g3ym.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    assert(number\
    \ >= 0);\n    return number - cast(long)number;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1.0;\n}\n/*\n    Return the largest integer smaller than given number.\n \
    \   >>> truncate_number_to_integer(3.5)\n    3\n*/\nfloat truncate_number_to_integer(float\
    \ number) \n{\n    return (float)int(number);\n}\n/*\n    Given a string, return\
    \ a string that has been\n    transformed by appending to each character the letters\n\
    \    until the character can be mapped to a number.\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyesalgxn.d(24): Error: C style cast illegal, use `cast(float)int(number)`

    /tmp/tmpyesalgxn.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyesalgxn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float truncated\
    \ = floor(number);\n    float leftover = number - truncated;\n    return leftover;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\n    Return the n_th decimal of a given number.\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxf_wy4sh.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxf_wy4sh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ cast(float *)null);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps6wa5ogy.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmps6wa5ogy.d(15):        cannot pass rvalue argument `cast(float*)null`
    of type `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps6wa5ogy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  // TODO\n  float\
    \ truncated;\n  float decimals;\n  double intPart = 0;\n  decimals = modf(number,\
    \ &intPart);\n  return decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgfwd1z5_.d(19): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, double*)`

    /tmp/tmpgfwd1z5_.d(19):        cannot pass rvalue argument `& intPart` of type
    `double*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgfwd1z5_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int i = cast(int)\
    \ number;\n    return number - i;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part\
    \ = cast(int) number;\n    float decimal_part = number - integer_part;\n    return\
    \ decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float integer;\n\
    \    float res = modf(number, &integer);\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsg9k2hi0.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpsg9k2hi0.d(16):        cannot pass rvalue argument `& integer` of type
    `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsg9k2hi0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return modf(number,\
    \ cast(float*)null);\n}\n/*\n    Write a function to sort an integer array. Do\
    \ not use the built-in functions.\n    >>> insertion_sort([3, 1, 4, 1, 5, 9, 2,\
    \ 6, 5])\n    [1, 1, 2, 3, 4, 5, 5, 6, 9]\n*/\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiwtaunlh.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpiwtaunlh.d(15):        cannot pass rvalue argument `cast(float*)null`
    of type `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiwtaunlh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - trunc(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float tmp = to!int(number);\n\
    \    return number - tmp;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfa7d2jmo.d(15): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfa7d2jmo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\n/*\nCompute the sum of two integers\n> add(1, 2)\n3\n*/\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,null);\n\
    }\n \nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpip1njffo.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, typeof(null))`

    /tmp/tmpip1njffo.d(15):        cannot pass rvalue argument `null` of type `typeof(null)`
    to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpip1njffo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // typecons.Tuple\n\
    \    // Tuple(A, B, C) ==> tuple[0] = A, tuple[1] = B, tuple[2] = C\n    auto\
    \ t = tuple(1, 1, 1);\n    // typecons.Tuple.length\n    assert(t.length == 3);\n\
    \    // typecons.Tuple.opIndex\n    t[0] = 0;\n    assert(t[0] == 0);\n    assert(t[1]\
    \ == 1);\n    assert(t[2] == 1);\n    // typecons.Tuple.opIndexAssign\n    t[1]\
    \ = 9;\n    assert(t[0] == 0);\n    assert(t[1] == 9);\n    assert(t[2] == 1);\n\
    \    // functions.opDispatch\n    // math.floor(num)\n    // The return value\
    \ is the greatest integer value not greater than x.\n    float number_integer_part\
    \ = floor(number);\n    // functions.opDispatch\n    // functions.opBinary\n \
    \   // math.fmod(x, y)\n    // The floating-point remainder of x / y.\n    float\
    \ decimal_part = fmod(number, number_integer_part);\n    // typecons.Tuple(1.0f,\
    \ 2.0f)\n    // auto t1 = tuple(1.0f, 2.0f);\n    // assert(t1.length == 2);\n\
    \    // assert(t1[0] == 1.0f);\n    // assert(t1[1] == 2.0f);\n    return decimal_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n    in {\n        assert(number\
    \ > 0);\n    }\n    out (result) {\n        assert(result >= 0);\n        assert(result\
    \ < 1);\n    }\n{\n    float int_part;\n    return modf(number, int_part);\n}\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3rtivd1m.d(21): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3rtivd1m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto (i, f) =\
    \ modf(number);\n    return f;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpojbf1a7j.d(15): Error: basic type expected, not `(`

    /tmp/tmpojbf1a7j.d(15): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpojbf1a7j.d(15): Error: no identifier for declarator `_error_`

    /tmp/tmpojbf1a7j.d(15): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpojbf1a7j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return 0.0;\n\
    }\n/*\n Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprzqog770.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprzqog770.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // if number\
    \ is negative, convert it to positive\n    if (number < 0)\n        number = -number;\n\
    \    // get the integer part\n    ulong ipart = ulong(number);\n    // get the\
    \ fractional part\n    float fpart = number - ipart;\n    return fpart;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3oevf0rw.d(19): Error: cannot implicitly convert expression `number`
    of type `float` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3oevf0rw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\n Given a positive floating point number, it can be\
    \ decomposed into\n    and integer part (largest integer smaller than given number)\
    \ and decimals\n    (leftover part always smaller than 1).\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_qqky8m9.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_qqky8m9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float intPart\
    \ = cast(int)number;\n    return number - intPart;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - floor(number);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return cast(float)number\
    \ - cast(float)cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float truncated;\n\
    \    float floored;\n    float rinted;\n    //math.modf, math.floor, math.ceil,\
    \ math.rint\n    //math.frexp, math.ldexp\n    /*\n        1. math.modf(X) ->\
    \ (float, float)\n        Return the fractional and integer parts of X. Both results\
    \ carry the sign of X and are floats.\n    */\n    auto parts = modf(number);\n\
    \    floored = parts[0];\n    rinted = rint(number);\n    truncated = number -\
    \ floored;\n    return truncated;\n}\n/*\n    Given a positive floating point\
    \ number, it can be decomposed into\n    and integer part (largest integer smaller\
    \ than given number) and decimals\n    (leftover part always smaller than 1).\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpolwye46_.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpolwye46_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // some test\
    \ to check the input\n    assert(number > 0);\n    assert(number == cast(int)number\
    \ + cast(float)number);\n    // not sure what you mean by 'decimal part'\n   \
    \ return cast(float)number - cast(int)number;\n}\n/*\n Given the radius of a circle,\
    \ return the area.\n    >>> area_of_circle(2)\n    12.566371\n*/\nfloat area_of_circle(float\
    \ radius)\n{\n    assert(radius > 0);\n    return radius * radius * PI;\n}\n/*\n\
    \ Given the length of two sides of a right-angled triangle, return the length\
    \ of\n    the hypotenuse.\n    >>> pythagoras(2, 3)\n    3.6055512\n*/\ndouble\
    \ pythagoras(double a, double b)\n{\n    assert(a > 0);\n    assert(b > 0);\n\
    \    return sqrt(a * a + b * b);\n}\n/*\n Given the length of the three sides\
    \ of a triangle, return true if the triangle\n    is right-angled, false otherwise.\n\
    \    >>> is_right_angled(3, 4, 5)\n    true\n    >>> is_right_angled(3, 4, 6)\n\
    \    false\n*/\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5w40e2t8.d(17): Assertion failure

    ----------------

    ??:? _d_assertp [0x427ead]

    ??:? float tmp5w40e2t8.truncate_number(float) [0x427aed]

    ??:? void tmp5w40e2t8.__unittest_L51_C1() [0x427bc8]

    ??:? void tmp5w40e2t8.__modtest() [0x427c5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bcb7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab4a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcdd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43018c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc69]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab21]

    ??:? runModuleUnitTests [0x42ba8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function('
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    Tuple!(int, float)\
    \ result = typecons.Tuple(cast(int)number, number - cast(int)number);\n    return\
    \ result[1];\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3_s85ggg.d(15): Error: undefined identifier `typecons`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_s85ggg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - to!int(number);\n}\nfloat truncate_number_test() \n{\n    float n = 3.5;\n\
    \    float expected = 0.5;\n    float actual = truncate_number(n);\n    assert(expected\
    \ == actual);\n}\n/*\nGiven a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7m72q4c.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7m72q4c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float intPart;\n\
    \    float decPart;\n    float retVal;\n    float signVal;\n    float absVal;\n\
    \    float numVal;\n    float retVal;\n    float[] parts;\n    float whole;\n\
    \    float[] intAndFloat;\n    intAndFloat = split(number);\n    intPart = intAndFloat[0];\n\
    \    decPart = intAndFloat[1];\n    signVal = sign(number);\n    absVal = abs(number);\n\
    \    numVal = num(number);\n    parts = split(number);\n    retVal = parts[1];\n\
    \    whole = parts[0];\n    retVal = cast(real) number - cast(real) intPart;\n\
    \    return retVal;\n}\n/*\n    Given a positive floating point number, it can\
    \ be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa42sec76.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa42sec76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvb8vpmz9.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvb8vpmz9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n//float truncate_number(float number) {\n//    auto parts\
    \ = std.typecons.tuple(cast(int)number, cast(float)number);\n//    return parts[1]\
    \ - parts[0];\n//}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    /*\n    float\
    \ ret = number - int(number);\n    if (ret < 0) {\n        ret += 1;\n    }\n\
    \    return ret;\n    */\n    // we make use of the fact that the return type\
    \ of a floating point division is always a floating point type\n    // division\
    \ of two integers always yields an integer.\n    // the trunc operation returns\
    \ the largest integer smaller than the number, but is the same type as the number\n\
    \    return number % 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part\
    \ = cast(int)number;\n    return number - integer_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ cast(float*)null);\n}\n/*\n    Given a number, find the closest number in a\
    \ sorted array\n    >>> closest_number([1, 2, 3, 5, 5, 7, 9, 10, 11], 6)\n   \
    \ 5\n*/\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppukqnvka.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmppukqnvka.d(15):        cannot pass rvalue argument `cast(float*)null`
    of type `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppukqnvka.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float intPart;\n\
    \    return modf(number, &intPart);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr55jcz41.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpr55jcz41.d(16):        cannot pass rvalue argument `& intPart` of type
    `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr55jcz41.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - floor(number);\n}\n/*\n    Given the temperature in celsius, return the temperature\
    \ in kelvin.\n    >>> kelvin_to_celsius(300)\n    26.85\n    >>> kelvin_to_celsius(273.15)\n\
    \    0.0\n*/\nfloat kelvin_to_celsius(float kelvin) \n{\n    return kelvin - 273.15;\n\
    }\n/*\n    Given the temperature in celsius, return the temperature in fahrenheit.\n\
    \    >>> celsius_to_fahrenheit(0)\n    32.0\n    >>> celsius_to_fahrenheit(100)\n\
    \    212.0\n*/\nfloat celsius_to_fahrenheit(float celsius) \n{\n    return celsius\
    \ * 1.8 + 32;\n}\n/*\n    Given the temperature in fahrenheit, return the temperature\
    \ in celsius.\n    >>> fahrenheit_to_celsius(32)\n    0.0\n    >>> fahrenheit_to_celsius(212)\n\
    \    100.0\n*/\nfloat fahrenheit_to_celsius(float fahrenheit) \n{\n    return\
    \ (fahrenheit - 32) / 1.8;\n}\n/*\n    Given the temperature in kelvin, return\
    \ the temperature in fahrenheit.\n    >>> kelvin_to_fahrenheit(300)\n    80.33\n\
    \    >>> kelvin_to_fahrenheit(273.15)\n    32.0\n*/\nfloat kelvin_to_fahrenheit(float\
    \ kelvin) \n{\n    return celsius_to_fahrenheit(kelvin_to_celsius(kelvin));\n\
    }\n/*\n    Given the temperature in fahrenheit, return the temperature in kelvin.\n\
    \    >>> fahrenheit_to_kelvin(32)\n    273.15\n    >>> fahrenheit_to_kelvin(80.33)\n\
    \    300.0\n*/\nfloat fahrenheit_to_kelvin(float fahrenheit) \n{\n    return celsius_to_kelvin(fahrenheit_to_\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr_xkx1bg.d(71): Error: found `unittest` when expecting `,`

    /tmp/tmpr_xkx1bg.d(79): Error: found `void` when expecting `,`

    /tmp/tmpr_xkx1bg.d(79): Error: found `{` when expecting `,`

    /tmp/tmpr_xkx1bg.d(79): Error: expression expected, not `}`

    /tmp/tmpr_xkx1bg.d(79): Error: found `End of File` when expecting `,`

    /tmp/tmpr_xkx1bg.d(79): Error: found `End of File` when expecting `)`

    /tmp/tmpr_xkx1bg.d(79): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmpr_xkx1bg.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_xkx1bg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = 0.0;\n    // if number is negative, the fractional part is added\n    // this\
    \ is needed to simplify the implementation\n    if (number < 0) {\n        number\
    \ = -number;\n        result =  number - cast(int)number;\n        return -result;\n\
    \    }\n    result = number - cast(int)number;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int part = cast(int)\
    \ number;\n    return number - part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = modf(number, &number);\n    return decimals;\n}\n/*\n Given a number, return\
    \ the largest integer smaller than given number.\n    >>> round_number(3.5)\n\
    \    3\n    >>> round_number(3.2)\n    3\n*/\nfloat round_number(float number)\
    \ \n{\n    float decimals = modf(number, &number);\n    return number;\n}\n/*\n\
    \ Given a number, return the smallest integer greater than given number.\n   \
    \ >>> ceil_number(3.5)\n    4\n    >>> ceil_number(3.2)\n    4\n*/\nfloat ceil_number(float\
    \ number) \n{\n    float decimals = modf(number, &number);\n    if (decimals)\
    \ \n    {\n        return number + 1;\n    }\n    return number;\n}\n/*\n Given\
    \ a number, return the power of two bigger than the number.\n    >>> next_power_of_two(3)\n\
    \    4\n    >>> next_power_of_two(4)\n    4\n    >>> next_power_of_two(5)\n  \
    \  8\n*/\nuint next_power_of_two(uint number) \n{\n    if (number == 0) \n   \
    \ {\n        return 0;\n    }\n    number--;\n    number |= number >> 1;\n   \
    \ number |= number >> 2;\n    number |= number >> 4;\n    number |= number >>\
    \ 8;\n    number |= number >> 16;\n    number++;\n    return number;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt1gy5mmx.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmpt1gy5mmx.d(15):        cannot pass rvalue argument `& number` of type
    `float*` to parameter `ref real i`

    /tmp/tmpt1gy5mmx.d(27): Error: function `std.math.modf(real x, ref real i)` is
    not callable using argument types `(float, float*)`

    /tmp/tmpt1gy5mmx.d(27):        cannot pass rvalue argument `& number` of type
    `float*` to parameter `ref real i`

    /tmp/tmpt1gy5mmx.d(39): Error: function `std.math.modf(real x, ref real i)` is
    not callable using argument types `(float, float*)`

    /tmp/tmpt1gy5mmx.d(39):        cannot pass rvalue argument `& number` of type
    `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt1gy5mmx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    size_t int_part;\n\
    \    float result;\n    float dec_part;\n    float dec_x;\n    float  x;\n   \
    \ float mult;\n    if (number >= 0.0) {\n        int_part = cast(size_t)number;\n\
    \        dec_part = number - int_part;\n        x = 10.0;\n        dec_x = 0.0;\n\
    \        mult = 1.0;\n        while (dec_x != dec_part) {\n            dec_x =\
    \ x - int_part;\n            x = dec_x * 10.0;\n            int_part = cast(size_t)\
    \ x;\n            mult *= 10.0;\n        }\n        result = dec_x;\n    }\n \
    \   else {\n        int_part = cast(size_t)number;\n        dec_part = number\
    \ - int_part;\n        x = -10.0;\n        dec_x = 0.0;\n        mult = 1.0;\n\
    \        while (dec_x != dec_part) {\n            dec_x = x - int_part;\n    \
    \        x = dec_x * 10.0;\n            int_part = cast(size_t) x;\n         \
    \   mult *= 10.0;\n        }\n        result = dec_x;\n    }\n    return result;\n\
    }\n/*\n Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcufzttv0.d(51): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcufzttv0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float integer_part;\n\
    \    return modf(number, &integer_part);\n}\n/*\n    Create a function that can\
    \ be used as a decorator to take a single argument\n    and apply some function\
    \ to it.\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphfbwgnnv.d(18): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphfbwgnnv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  return number -\
    \ cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float intpart;\n\
    \    return modf(number, &intpart);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5k_3xvfj.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmp5k_3xvfj.d(16):        cannot pass rvalue argument `& intpart` of type
    `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5k_3xvfj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    size_t int_part\
    \ = cast(size_t)number;\n    float dec_part = number - int_part;\n    return dec_part;\n\
    }\n/*\n Given a positive floating point number, get the exponent part\n    and\
    \ mantissa part.\n    \n    >>> float_to_mantissa_exponent(24.375)\n    (2.859375,\
    \ 4)\n*/\nTuple!(float, size_t) float_to_mantissa_exponent(float number) \n{\n\
    \    float mantissa = number;\n    size_t exponent = 0;\n    while (mantissa >=\
    \ 10.0) {\n        mantissa /= 10.0;\n        exponent++;\n    }\n    return tuple(mantissa,\
    \ exponent);\n}\n/*\n Given a mantissa, put it back in exponent form.\n    >>>\
    \ mantissa_to_float(2.859375, 4)\n    24.375\n*/\nfloat mantissa_to_float(float\
    \ mantissa, size_t exponent) \n{\n    float number = mantissa;\n    while (exponent\
    \ > 0) {\n        number *= 10.0;\n        exponent--;\n    }\n    return number;\n\
    }\n/*\n Given a positive floating point number, return the integer part.\n   \
    \ >>> int_part(3.5)\n    3\n*/\nsize_t int_part(float number) \n{\n    return\
    \ cast(size_t)number;\n}\n/*\n Given a positive floating point number, return\
    \ the decimal part.\n    >>> dec_part(3.5)\n    0.5\n*/\nfloat dec_part(float\
    \ number) \n{\n    return number - cast(size_t)number;\n}\n/*\n    Given a positive\
    \ floating point number, get the closest floating\n    point power of 10.\n  \
    \  \n    >>> closest_power(3.5)\n    10.0\n    >>> closest_power(5.0)\n    10.0\n\
    \    >>> closest_power(0.5)\n    0.1\n*/\nfloat closest_power(float number) \n\
    {\n    float mantissa = float_to_mantissa_exponent(number).tupleof\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsv2vf4p.d(82): Error: semicolon expected, not `unittest`

    /tmp/tmpqsv2vf4p.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsv2vf4p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    //1. Get the\
    \ integer part\n    int integer_part = (int)number;\n    //2. Get the decimal\
    \ part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n\
    }\n/*\n    Return the decimal part of the number without using the\n    built-in\
    \ function (in math.d)\n    >>> truncate_number_no_std(3.5)\n    0.5\n*/\nfloat\
    \ truncate_number_no_std(float number) \n{\n    //1. Get the integer part\n  \
    \  int integer_part = (int)number;\n    //2. Get the decimal part\n    float decimal_part\
    \ = number - integer_part;\n    return decimal_part;\n}\n/*\n    Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu2gvtx6d.d(16): Error: C style cast illegal, use `cast(int)number`

    /tmp/tmpu2gvtx6d.d(30): Error: C style cast illegal, use `cast(int)number`

    /tmp/tmpu2gvtx6d.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu2gvtx6d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n    in \n    {\n   \
    \     assert(number > 0.0f);\n    }\n    body\n    {\n        return number -\
    \ cast(uint)number;\n    }\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164391
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ cast(int)number;\n}\n/*\n Given a positive floating point number, it can be\
    \ decomposed into\n    and integer part (largest integer smaller than given number)\
    \ and decimals\n    (leftover part always smaller than 1).\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpomj635gl.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpomj635gl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    /*\n    float\
    \ test = (number * number);\n    float test2 = (number * test);\n    float test3\
    \ = test / number;\n    float test4 = (test / number) / number;\n    float test5\
    \ = test / (number * number);\n    return test4;\n    */\n    return number %\
    \ cast(int) number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ % 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n  //  return number.trunc;//use\
    \ truncate method\n    import std.array;\n    auto num = to!string(number);\n\
    \    auto res = num.split(\".\");\n    return to!float(res[1]);\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1bxvj49s.d(17): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmp1bxvj49s.d(19): Error: template instance `to!float` template `to` is not
    defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1bxvj49s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - (int)number;\n}\n/*\n Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9sp_ijsu.d(15): Error: C style cast illegal, use `cast(int)number`

    /tmp/tmp9sp_ijsu.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9sp_ijsu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n\treturn number -\
    \ (int)number;\n}\n/*\n Given a floating point number, return its string representation.\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpik7dhfy4.d(15): Error: C style cast illegal, use `cast(int)number`

    /tmp/tmpik7dhfy4.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpik7dhfy4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ cast(float *)null);\n}\n/*\n    Given a range of values, it groups the values\
    \ into N buckets\n    and generates the histogram.\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwdnblr9r.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwdnblr9r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float r = modf(number,\
    \ float());\n    return r < 0 ? r + 1 : r;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcuu4u0zk.d(15): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float)`

    /tmp/tmpcuu4u0zk.d(15):        cannot pass rvalue argument `nanF` of type `float`
    to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcuu4u0zk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return modf(number,\
    \ cast(int) );\n}\n/*\nConvert fahrenheit degrees to celsius\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6f3hsoi0.d(15): Error: expression expected, not `)`

    /tmp/tmp6f3hsoi0.d(15): Error: found `;` when expecting `,`

    /tmp/tmp6f3hsoi0.d(16): Error: expression expected, not `}`

    /tmp/tmp6f3hsoi0.d(17): Error: unterminated /* */ comment

    /tmp/tmp6f3hsoi0.d(27): Error: found `End of File` when expecting `,`

    /tmp/tmp6f3hsoi0.d(27): Error: found `End of File` when expecting `)`

    /tmp/tmp6f3hsoi0.d(27): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmp6f3hsoi0.d(27): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6f3hsoi0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\n/*\n Given a positive floating point number, it can be\
    \ decomposed into\n    and integer part (largest integer smaller than given number)\
    \ and decimals\n    (leftover part always smaller than 1).\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_qqky8m9.d(17): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_qqky8m9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164389
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    auto r = divmod(number,\
    \ 1);\n    return r.rem;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt6852ku9.d(15): Error: undefined identifier `divmod`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt6852ku9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    // Assuming \n\
    \    //    is(typeof(number) == float) &&\n    //    number >= 0\n    return number\
    \ - int(number);\n}\n/*\n Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpin8ngrt2.d(20): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpin8ngrt2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return number\
    \ - cast(int)number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164388
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    return cast(float)\
    \ cast(int) number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxdxwzm41.d(21): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d35]

    ??:? void tmpxdxwzm41.__unittest_L17_C1() [0x427a46]

    ??:? void tmpxdxwzm41.__modtest() [0x427ab4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8c5]

    ??:? runModuleUnitTests [0x42b831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428184]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164391
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float integer;\n\
    \    return modf(number, &integer);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps8er8pl8.d(16): Error: function `std.math.modf(real x, ref real
    i)` is not callable using argument types `(float, float*)`

    /tmp/tmps8er8pl8.d(16):        cannot pass rvalue argument `& integer` of type
    `float*` to parameter `ref real i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps8er8pl8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    Tuple!(int, float)\
    \ result = decompose!float(number);\n    return result[1];\n}\n/*\n Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9otbv4mv.d(18): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9otbv4mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164390
