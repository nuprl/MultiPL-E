name: HumanEval_152_compare
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nI think we all remember that\
  \ feeling when the result of some long-awaited\n    event is finally known. The\
  \ feelings and thoughts you have at that moment are\n    definitely worth noting\
  \ down and comparing.\n    Your task is to determine if a person correctly guessed\
  \ the results of a number of matches.\n    You are given two arrays of scores and\
  \ guesses of equal length, where each index shows a match. \n    Return an array\
  \ of the same length denoting how far off each guess was. If they have guessed correctly,\n\
  \    the value is 0, and if not, the value is the absolute difference between the\
  \ guess and the score.\n    \n    \n    example:\n\n    >>> compare([1L, 2L, 3L,\
  \ 4L, 5L, 1L], [1L, 2L, 3L, 4L, 2L, -2L])\n    [0L, 0L, 0L, 0L, 3L, 3L]\n    >>>\
  \ compare([0L, 5L, 0L, 0L, 0L, 4L], [4L, 1L, 1L, 0L, 0L, -2L])\n    [4L, 4L, 1L,\
  \ 0L, 0L, 6L]\n    \n*/\nlong[] compare(long[] game, long[] guess) \n"
tests: "unittest\n{\n    alias candidate = compare;\n\n    assert(candidate([1L, 2L,\
  \ 3L, 4L, 5L, 1L], [1L, 2L, 3L, 4L, 2L, -2L]) == [0L, 0L, 0L, 0L, 3L, 3L]);\n  \
  \  assert(candidate([0L, 0L, 0L, 0L, 0L, 0L], [0L, 0L, 0L, 0L, 0L, 0L]) == [0L,\
  \ 0L, 0L, 0L, 0L, 0L]);\n    assert(candidate([1L, 2L, 3L], [-1L, -2L, -3L]) ==\
  \ [2L, 4L, 6L]);\n    assert(candidate([1L, 2L, 3L, 5L], [-1L, 2L, 3L, 4L]) == [2L,\
  \ 0L, 0L, 1L]);\n}\nvoid main(){}"
completions: ["{\n    auto result = new long[game.length];\n    for(int i = 0; i <\
    \ game.length; i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n   \
    \ }\n    return result;\n}", "{\n    return map!(a => abs(a[0] - a[1]))(zip(game,\
    \ guess));\n}", "{\n    return game.zip(guess).map!(a => abs(a[0] - a[1]));\n}",
  "{\n    long[] result = new long[game.length];\n    foreach(i, ref x; game)\n  \
    \  {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n\
    }", "{\n\tauto result = new long[game.length];\n\tforeach(i, v; game)\n\t{\n\t\
    \tresult[i] = game[i] - guess[i];\n\t\tif(result[i] < 0)\n\t\t\tresult[i] *= -1;\n\
    \t}\n\treturn result;\n}", "{\n    long[] output = new long[game.length];\n  \
    \  for(size_t i = 0; i < game.length; i++)\n    {\n        output[i] = (game[i]\
    \ - guess[i]).abs;\n    }\n    return output;\n}", "{\n    long[] a = new long[game.length];\n\
    \    foreach(int i, ln; game)\n    {\n        if(game[i] == guess[i])\n      \
    \  {\n            a[i] = 0L;\n        }\n        else\n        {\n           \
    \ a[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return a;\n}", "{\n \
    \   long[] array = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        if(game[i] > guess[i])\n        {\n            array[i]\
    \ = game[i] - guess[i];\n        }\n        else if(game[i] < guess[i])\n    \
    \    {\n            array[i] = guess[i] - game[i];\n        }\n        else if(game[i]\
    \ == guess[i])\n        {\n            array[i] = 0;\n        }\n    }\n    return\
    \ array;\n}\n/*\nA common theme in popular culture is that of the superhero who,\
    \ in a time of need, takes up the mantle of an ordinary person in order to protect\
    \ and save them. \nThe act of transforming into a superhero is called suiting\
    \ up.\nAs such, we want to explore the possibility of determining when someone\
    \ has successfully suited up by looking at their power levels.", "{\n    if(game.length\
    \ != guess.length) \n        return null;\n    long[] res = new long[game.length];\n\
    \    for(size_t i = 0; i < game.length; i++)\n    {\n        res[i] = game[i]\
    \ - guess[i];\n        if(res[i] < 0)\n            res[i] = -res[i];\n    }\n\
    \    return res;\n}", "{\n    \n    long[] res = new long[game.length];\n    auto\
    \ i = 0;\n    foreach(int x; game)\n    {\n        res[i] = abs(game[i] - guess[i]);\n\
    \        i++;\n    }\n    return res;\n    \n}", "{ \n    long[] result = game.dup;\n\
    \    foreach(index, val; result)\n    {\n        result[index] = abs(game[index]\
    \ - guess[index]);\n    }\n    return result;\n} ", "{\n    long[] result = new\
    \ long[game.length];\n    foreach(immutable i, ref r; result)\n    {\n       \
    \ if(guess[i] == game[i])\n            r = 0;\n        else\n            r = abs(guess[i]\
    \ - game[i]);\n    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    foreach(i,v;game)\n    {\n        if(v == guess[i]) \n        {\n       \
    \     result[i] = 0L;\n        }\n        else\n        {\n            result[i]\
    \ = abs(v - guess[i]);\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[game.length];\n    foreach(elem; game.length)\n    {\n   \
    \    result[elem] = abs(game[elem] - guess[elem]);\n    }\n    return result;\n\
    }\n/*\nI think we all remember that feeling when the result of some long-awaited\n\
    \    event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    definitely worth noting down and comparing.\n    Your task is to determine\
    \ if a person correctly guessed the results of a number of matches.\n    You are\
    \ given two arrays of scores and guesses of equal length, where each index shows\
    \ a match. \n    Return an array of the same length denoting how far off each\
    \ guess was. If they have guessed correctly,\n    the value is 0, and if not,\
    \ the value is the absolute difference between the guess and the score.\n    \n\
    \    \n    example:", "{\n    return game.zip(guess).map!(ab => std.math.abs(ab[0]\
    \ - ab[1]));\n}", "{\n    long[] result = new long[game.length];\n    foreach(i,\
    \ e; game) \n    {\n        result[i] = abs(e - guess[i]);\n    }\n    return\
    \ result;\n}", "{\n    long[] diffs = new long[game.length];\n    foreach(i, g;\
    \ game)\n    {\n        diffs[i] = abs(g - guess[i]);\n    }\n    return diffs;\n\
    }", "{\n    long[] ret = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        ret[i] = abs(game[i] - guess[i]);\n    }\n    return ret;\n\
    }", "{\n    long[] result = new long[game.length];\n    for(long i = 0; i < game.length;\
    \ i++) \n    {\n        long a = game[cast(int)i];\n        long b = guess[cast(int)i];\n\
    \        result[cast(int)i] = abs(a - b);\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[game.length];\n    foreach( i, elem; game)\n   \
    \ {\n        result[i] = abs(elem - guess[i]);\n    }\n    return result;\n}",
  "{\n    long[] diffs = new long[game.length];\n    foreach(int i, long g; zip(game,\
    \ guess)) {\n        diffs[i] = abs(g - game[i]);\n    }\n    return diffs;\n}",
  "{\n    long[] result = new long[game.length];\n    foreach(int i, elem; game)\n\
    \    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n\
    }", "{\n    long[] res = new long[game.length];\n    foreach(int i, long j;game)\n\
    \    {\n        if(game[i] == guess[i])\n            res[i] = 0;\n        else\n\
    \            res[i] = abs(game[i] - guess[i]);\n    }\n    return res;\n}", "{\n\
    \    long[] res = new long[game.length];\n    for(size_t i = 0; i < game.length;\
    \ i++)\n    {\n        res[i] = abs(game[i] - guess[i]);\n    }\n    return res;\n\
    }", "{\n    long[] result = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        long diff = game[i] - guess[i];\n        result[i] = abs(diff);\n\
    \    }\n    return result;\n}\n//******************************\n/*\nGiven an\
    \ array of integers, return a new array where each element in the new array is\
    \ the number of smaller \n    elements to the right of that element in the original\
    \ input array.\n    For example, given the array [3, 4, 9, 6, 1], return [1, 1,\
    \ 2, 1, 0], since:\n    There is 1 smaller element to the right of 3\n    There\
    \ is 1 smaller element to the right of 4\n    There are 2 smaller elements to\
    \ the right of 9\n    There is 1 smaller element to the right of 6\n    There\
    \ are no smaller elements to the right of 1\n*/", "{\n    long[] result = new\
    \ long[game.length];\n    for(int i = 0; i < game.length; i++)\n    {\n      \
    \  result[i] = game[i] - guess[i];\n        if(result[i] < 0)\n            result[i]\
    \ *= -1;\n    }\n    return result;\n}", "{\n    import std.conv;\n    long[]\
    \ mis = new long[game.length];\n    for(int i = 0; i < game.length; i++)\n   \
    \ {\n        mis[i] = abs(game[i] - guess[i]);\n    }\n    return mis;\n}", "{\n\
    \t//or you can use the zip function\n\t//return zip(game, guess).map!(tuple =>\
    \ abs(tuple[0] - tuple[1]));\n\tauto result = new long[](game.length);\n\tint\
    \ i;\n\tfor(i = 0; i < game.length; i++)\n\t{\n\t\tresult[i] = abs(game[i] - guess[i]);\n\
    \t}\n\treturn result;\n}", "{\n    long[] result = new long[game.length];\n  \
    \  for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    auto result = new long[game.length];\n\
    \    for(size_t i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    //printf(\"game %d %d %d\
    \ %d %d %d\\n\", game[0], game[1], game[2], game[3], game[4], game[5]);\n    //printf(\"\
    guess %d %d %d %d %d %d\\n\", guess[0], guess[1], guess[2], guess[3], guess[4],\
    \ guess[5]);\n    long[] result = new long[game.length];\n    foreach(i,j; zip(game,\
    \ guess))\n    {\n        result[i] = abs(j[0] - j[1]);\n    }\n    return result;\n\
    }", "{\n    long[] res = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        res[i] = abs(game[i] - guess[i]);\n    }\n    return res;\n\
    }", "{\n    auto ret = new long[$];\n    for(long i = 0; i < game.length; i++)\n\
    \    {\n        ret[i] = abs(game[i] - guess[i]);\n    }\n    return ret;\n}",
  "{\n\tlong[] tab;\n\tforeach(i; 0..game.length)\n\t{\n\t\tif(game[i] == guess[i])\n\
    \t\t\ttab ~= 0L;\n\t\telse\n\t\t\ttab ~= abs(game[i] - guess[i]);\n\t}\n\treturn\
    \ tab;\n}\n/*\ndef compare(game, guess):\n    return [abs(x - y) for x, y in zip(game,\
    \ guess)]\n*/", "{\n     return zip(game, guess).map!(a => abs(a[0] - a[1]));\n\
    }", "{\n    long[] result = new long[game.length];\n    for(size_t i = 0; i <\
    \ game.length; i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    foreach(i, ref v; result)\n    {\n        result[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return result;\n}", "{\n    long[] res;\n    res.length = game.length;\n\
    \    foreach(i, v; game)\n    {\n        res[i] = abs(v - guess[i]);\n    }\n\
    \    return res;\n}", "{\n    long[] result;\n    foreach(i, g; guess)\n    {\n\
    \        if(g == game[i])\n            result ~= 0L;\n        else\n         \
    \   result ~= abs(g - game[i]);\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[game.length];\n    for(int i = 0; i < game.length; i++)\n\
    \    {\n        result[i] = Math.abs(game[i] - guess[i]);\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[game.length];\n    foreach(i, ref a; zip(game,\
    \ guess)) \n    {\n        result[i] = abs(a[0] - a[1]);\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    import std.algorithm.iteration : zip;\n\
    \    foreach(tuple; zip(game, guess))\n    {\n        result ~= abs(tuple[0] -\
    \ tuple[1]);\n    }\n    return result;\n}\n ", "{\n    auto dresult = game.dup;\n\
    \    foreach(i,ref val; dresult)\n    {\n        dresult[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return dresult;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n  long[] result = new long[game.length];\n\
    \  for(size_t i = 0; i < game.length; i++)\n    result[i] = abs(game[i] - guess[i]);\n\
    \  return result;\n}\n/*\n   Cheater! You were found cheating at a local casino\
    \ by writing down the results\n    of the roulette wheel. You claim that you were\
    \ only trying to predict the next number. \n    Can you?\n    You are given the\
    \ results of the last spins, the roulette wheel has the following numbers:\n \
    \   0, 00, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36.\n    The\
    \ 0 and 00 are represented as 0, and the rest of the numbers are represented by\
    \ their actual number.\n    Return an array of zeros and ones, where each index\
    \ corresponds to the number of the slot in the roulette wheel. \n    A 1 means\
    \ you should bet on that number, and a 0 means you should not.\n    \n    For\
    \ example:", "{\n    auto res = new long[game.length];\n    foreach(immutable\
    \ idx, immutable score; game)\n    {\n        res[idx] = abs(guess[idx] - score);\n\
    \    }\n    return res;\n}", "{\n    /*\n    What I want to do is create a new\
    \ array, equal to the length of the score array and\n    guess array, and then\
    \ I want to iterate through these arrays and compare \n    the two numbers, and\
    \ if they're the same put it into the new array, if they're not\n    then find\
    \ the difference and put that in the new array.\n    */\n    long[] result = new\
    \ long[game.length];\n    for(int i = 0; i < game.length; i++)\n    {\n      \
    \  if(game[i] == guess[i])\n        {\n            result[i] = 0;\n        }\n\
    \        else\n        {\n            result[i] = abs(game[i] - guess[i]);\n \
    \       }\n    }\n    return result;\n}\n/*\n    I took this array solution from\
    \ another person, I had it figured out with the \n    array, just not with something\
    \ that actually made sense, but I like this \n    solution, so I'm going to leave\
    \ it. This is the version that I want to use \n    in my project.\n*/\nlong[]\
    \ compare_better(long[] game, long[] guess) \n{\n    long[] results = new long[game.length];\n\
    \    foreach(i, ref a; results)\n    {\n        results[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return results;\n}\n/*\n    Here I took the advice from another user,\
    \ and tried to do the same thing \n    without the use of arrays, only using 2\
    \ ints. Which while I was looking \n    around for help, I noticed that this is\
    \ the most used way to do this.\n*/\nTuple!(long, long) compare_without_array(long\
    \ game, long guess) \n{\n    if(game == guess)\n    {\n        return tuple(0L,\
    \ 0L);\n    }\n    else\n    {\n        return tuple(abs(game - guess), 0L);\n\
    \    }\n}\n/*\n    I forgot that i could just pass the score and guess array through\
    \ to this \n    function and then i could just call the compare_without_array\
    \ function inside of it,\n    and then it should return what I want", "{\n   \
    \ int[] results = new int[game.length];\n    for(int i = 0; i < game.length; i++)\n\
    \    {\n        results[i] = Math.abs(game[i] - guess[i]);\n    }\n    return\
    \ results;\n}", "{\n    return zip(game, guess).map!(a => abs(a[0] - a[1]));\n\
    }", "{\n    long[] score = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        score[i] = Math.abs(game[i] - guess[i]);\n    }\n    return\
    \ score;\n}", "{\n    long[] result = new long[game.length];\n    int j = 0;\n\
    \    foreach(e; game)\n    {\n        long t = abs(e - guess[j]);\n        j++;\n\
    \        result ~= t;\n    }\n    return result;\n}\n ", "{\n    // this makes\
    \ a new array the size of game\n    long[] difference = new long[game.length];\n\
    \    long temp, temp2;\n    // iterates through the size of game\n    for(int\
    \ i = 0; i < game.length; i++)\n    {\n        // sets the temp equal to the absolute\
    \ difference of the two arrays at i\n        temp = abs(game[i] - guess[i]);\n\
    \        temp2 = abs(game[i] - guess[i]);\n        // checks if the temp equals\
    \ the temp2\n        if(temp == temp2)\n        {\n            // if they are\
    \ the same sets the difference at i equal to 0\n            difference[i] = 0;\n\
    \        }\n        else\n        {\n            // if they are not the same sets\
    \ the difference at i equal to the difference of the two arrays at i\n       \
    \     difference[i] = abs(game[i] - guess[i]);\n        }\n    }\n    // returns\
    \ the difference array\n    return difference;\n}", "{\n    long[] result = new\
    \ long[game.length];\n    for(int i = 0; i < game.length; i++) \n    {\n     \
    \   result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n}", "{\n\
    \    long[] temp = new long[game.length];\n    foreach(var i; 0..game.length)\n\
    \    {\n        temp[i] = abs(game[i] - guess[i]);\n    }\n    return temp;\n}",
  "{\n    long[] result;\n    foreach(i,element; game)\n    {\n        if(game[i]>guess[i])\n\
    \        {\n            result ~= game[i]-guess[i];\n        }\n        else if(game[i]<guess[i])\n\
    \        {\n            result ~= guess[i]-game[i];\n        }\n        else\n\
    \        {\n            result ~= game[i]-guess[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[game.length];\n    foreach(int\
    \ i, ref long num; game) \n    {\n        result[i] = abs(num - guess[i]);\n \
    \   }\n    return result;\n}\n//by neovintage", "{\n    long[] longs = new long[game.length];\n\
    \    longs = game.map!(a => a - guess[game.indexOf(a)]);\n    return longs.map!(a\
    \ => abs(a));\n}", "{\n    // result will be the same size as each array.\n  \
    \  long[] result = new long[game.length];\n    //looping through each element\
    \ of the arrays.\n    for(int i = 0; i < game.length; i++)\n    {\n        if(game[i]\
    \ == guess[i])\n        {\n            result[i] = 0;\n        }\n        else\n\
    \        {\n            result[i] = abs(game[i] - guess[i]);\n        }\n    }\n\
    \    return result;\n}", "{\n     long[] res = new long[game.length];\n     foreach(int\
    \ i,d; zip(game,guess))\n     {\n         res[i] = abs(d[0] - d[1]);\n     }\n\
    \     return res;\n}", "{\n    auto res = new long[](game.length);\n    for(int\
    \ i = 0; i < game.length; i++) \n    {\n        res[i] = Math.abs(game[i] - guess[i]);\n\
    \    }\n    return res;\n}", "{\n    long[] results = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        results[i] = Math.abs(game[i]\
    \ - guess[i]);\n    }\n    return results;\n}", "{\n    long[] answer = new long[game.length];\n\
    \    for(long i = 0; i < game.length; i++)\n    {\n        long g = guess[i];\n\
    \        long s = game[i];\n        if(g == s)\n        {\n            answer[i]\
    \ = 0;\n        }\n        else\n        {\n            answer[i] = abs(g - s);\n\
    \        }\n    }\n    return answer;\n}", "{ \n  long[] result = new long[game.length];\n\
    \  foreach(i, val; game)\n  {\n    if(val >= 0)\n      result[i] = abs(val - guess[i]);\n\
    \    else\n      result[i] = abs(abs(val) - guess[i]);\n  }\n  return result;\n\
    }", "{\n    long[] score = new long[guess.length];\n    size_t i = 0;\n    foreach(value;guess)\n\
    \    {\n        if(value < 0L)\n        {\n            score[i] = abs(game[i]\
    \ - (value * -1L));\n        }\n        else\n        {\n            score[i]\
    \ = abs(game[i] - value);\n        }\n        i++;\n    }\n    return score;\n\
    }", "{\n    long[] result = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[game.length];\n    foreach(i,e;\
    \ game)\n    {\n        result[i] = abs(e - guess[i]);\n    }\n    return result;\n\
    }", "{\n\tauto out = new long[game.length];\n\tfor(int i = 0; i < game.length;\
    \ i++)\n\t{\n\t\tout[i] = abs(game[i] - guess[i]);\n\t}\n\treturn out;\n}", "{\n\
    \    long[] result = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    result = new long[game.length];\n \
    \   foreach(int i; 0..game.length)\n    {\n        result[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        if(game[i] == guess[i])\n\
    \        {\n            result[i] = 0;\n        }\n        else\n        {\n \
    \           result[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[game.length];\n    for(int i =\
    \ 0; i < game.length; i++)\n    {\n        if(game[i] == guess[i])\n        {\n\
    \            result[i] = 0;\n        }else\n        {\n            result[i] =\
    \ abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n}", "{\n\tlong[]\
    \ result = [];\n\tgame.length.times!((i) => result ~= abs(game[i] - guess[i]));\n\
    \treturn result;\n}", "{\n    //write your code here\n    long[] result = new\
    \ long[game.length];\n    foreach(i, ref a; result) \n    {\n        a = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    long[] out = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        out[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return out;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}\n/*\nIn the Land of Wallachia, there\
    \ is a special kind of clock. It has an hour hand and a minute hand, \nbut not\
    \ a second hand. The hour hand makes one revolution (clockwise) every twelve hours,\n\
    and the minute hand makes one revolution every hour.\nAt noon, they both point\
    \ straight up. At midnight, they both point straight down.\nIn between, they point\
    \ at various angles.\nIf an observer were to watch the clock for twelve hours,\
    \ starting at noon,\nand record the angle between the hands at each hour, he or\
    \ she would find that the hands first make an angle of 0 degrees,\nthen 11, then\
    \ 22, then 33, and so on. Since the hour hand moves more quickly than the minute\
    \ hand,\nif the observer then waited another twelve hours and recorded the angles\
    \ again, \nhe or she would find that the second time they started at 11 and ended\
    \ at 22, \nso the angle between the hands increased by only 11 degrees the second\
    \ time.\nThe 12-hour clock is a cyclical mechanism, and the time of day can be\
    \ represented\nby a number of revolutions of the minute hand and a number of revolutions\
    \ of the hour hand.\nGiven a number of revolutions of the minute hand and a number\
    \ of revolutions of the hour hand,\nyour task is to find the angle between the\
    \ hands.", "{\n    long[] differences = new long[game.length];\n    for(int i\
    \ = 0; i < game.length; i++)\n    {\n        differences[i] = std.abs(game[i]\
    \ - guess[i]);\n    }\n    return differences;\n}", "{\n    immutable int n =\
    \ game.length;\n    long[] result = new long[n];\n    foreach(int i; 0..n)\n \
    \   {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n\
    }", "{ \n    long[] x = game.dup; \n    long[] y = guess.dup; \n    long[] diff\
    \ = new long[game.length]; \n    for (int i = 0; i < x.length; i++) \n    { \n\
    \        if (x[i] == y[i]) \n        { \n            diff[i] = 0; \n        }\
    \ \n        else \n        { \n            diff[i] = abs(x[i] - y[i]); \n    \
    \    } \n    } \n    return diff; \n}", "{\n    auto result = new long[game.length];\n\
    \    foreach(i, v; game)\n    {\n        if(v == guess[i])\n            result[i]\
    \ = 0;\n        else\n            result[i] = abs(v - guess[i]);\n    }\n    return\
    \ result;\n}", "{\n    long[] r = new long[game.length];\n    for(int i = 0; i\
    \ < game.length; i++)\n    {\n        long g = game[i];\n        long h = guess[i];\n\
    \        if(g == h)\n            r[i] = 0;\n        else\n            r[i] = abs(g\
    \ - h);\n    }\n    return r;\n}", "{\n    long[] result = new long[guess.length];\n\
    \    for(int i = 0; i < guess.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    immutable(long)[] result;\n\
    \    foreach(index, item; game)\n    {\n        if(game[index] == guess[index])\n\
    \        {\n            result ~= 0L;\n        }\n        else\n        {\n  \
    \          result ~= abs(game[index] - guess[index]);\n        }\n    }\n    return\
    \ result;\n}", "{\n    immutable long[] difference = new long[game.length];\n\
    \    size_t i;\n    foreach(i, value; game)\n    {\n        if(guess[i] >= 0)\n\
    \        {\n            if(game[i] == guess[i]) difference[i] = 0;\n         \
    \   else difference[i] = abs(game[i] - guess[i]);\n        }\n        else\n \
    \       {\n            if(game[i] == abs(guess[i])) difference[i] = 0;\n     \
    \       else difference[i] = abs(game[i] - abs(guess[i]));\n        }\n    }\n\
    \    return difference;\n}", "{\n    return zip(game, guess).map!(tuple(a, b)\
    \ => abs(a - b));\n}", "{\n    long[] result = new long[game.length];\n    for(int\
    \ i = 0; i < game.length; i++)\n    {\n        if(guess[i] >= 0 && game[i] >=\
    \ 0)\n        {\n            result[i] = abs(game[i] - guess[i]);\n        }\n\
    \        else if(guess[i] < 0 && game[i] < 0)\n        {\n            result[i]\
    \ = abs(game[i] - guess[i]);\n        }\n        else if(guess[i] < 0 && game[i]\
    \ >= 0)\n        {\n            result[i] = abs(game[i] + guess[i]);\n       \
    \ }\n        else if(guess[i] >= 0 && game[i] < 0)\n        {\n            result[i]\
    \ = abs(game[i] + guess[i]);\n        }\n    }\n    return result;\n}\nlong[]\
    \ compare(long[] game, long[] guess) \n{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}\n//for each, which is better than\
    \ loop\nlong[] compare(long[] game, long[] guess) \n{\n    long[] result = new\
    \ long[game.length];\n    foreach(int i, int g; zip(iota(game.length), game, guess))\n\
    \    {\n        result[i] = abs(g[0] - g[1]);\n    }\n    return result;\n}\n\
    //using map, which is best\nlong[] compare(long[] game, long[] guess) \n{\n  \
    \  return map!((x, y) => abs(x - y))(game, guess);\n}\n//using zip, who knows\n\
    long[] compare(long[] game, long[] guess) \n{\n    return map!((i, j) => abs(i\
    \ - j))(zip(game, guess));\n}\n//the real thing\nlong[] compare(long[] game, long[]\
    \ guess) \n{\n    return", "{\n    auto a = game.map!(a => a).array;\n    auto\
    \ b = guess.map!(a => a).array;\n    auto result = new long[game.length];\n  \
    \  foreach(mut i, j; zip(a, b))\n    {\n        result[i] = abs(j - game[i]);\n\
    \    }\n    return result;\n}\n/*\n    In this kata, you have to write a method\
    \ to verify the validity of IPv4 addresses.\n    An IPv4 address consists of four\
    \ dot-separated numbers in the range 0..255, i.e. 127.0.0.1 is a valid IPv4 address.\n\
    \    Implement this function so that it returns true for valid IPv4 addresses\
    \ and false for invalid IPv4 addresses.\n    \n    >>> isValidIPv4Address(\"172.16.254.1\"\
    )\n    true\n    >>> isValidIPv4Address(\"172.316.254.1\")\n    false\n    >>>\
    \ isValidIPv4Address(\".254.255.0\")\n    false\n*/", "{\n    size_t len = game.length;\n\
    \    long[] res = new long[len];\n    foreach(size_t i; 0..len)\n    {\n     \
    \   res[i] = abs(game[i] - guess[i]);\n    }\n    return res;\n}", "{\n    long[]\
    \ difference = new long[game.length];\n    for(long i = 0; i < game.length; i++)\n\
    \    {\n        difference[i] = abs(game[i] - guess[i]);\n    }\n    return difference;\n\
    }", "{\n    long[] res = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        res[i] = abs(game[i] - guess[i]);\n    }\n    return res;\n\
    }", "{\n    size_t len = game.length;\n    long[] result = new long[len];\n  \
    \  foreach(i, _; result) {\n        result[i] = abs(game[i] - guess[i]);\n   \
    \ }\n    return result;\n}", "{\n    long[] ans = new long[game.length];\n   \
    \ for(int i = 0; i < game.length; i++)\n    {\n        ans[i] = game[i] > guess[i]\
    \ ? game[i] - guess[i] : guess[i] - game[i];\n    }\n    return ans;\n}", "{\n\
    \    long[] list = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        list[i] = abs(game[i] - guess[i]);\n    }\n    return list;\n\
    }", "{\n    //long[] result = new long[6];\n    return game.zip(guess).map!((a,\
    \ b) => abs(a - b)).array;\n}", "{\n    long[] finalResult = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        finalResult[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return finalResult;\n}", "{\n    auto res = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        res[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return res;\n}\n/*\n    Write a function that, given\
    \ a number n, will return all the integers from n to n + n.\n    \n    example:\n\
    \    \n    >>> addN(3)\n    [3, 4, 5, 6, 7, 8, 9]\n    >>> addN(1)\n    [1, 2,\
    \ 3, 4, 5, 6, 7]\n*/", "{\n    long[] result = new long[game.length];\n    for(long\
    \ i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++) \n    {\n        if(guess[i] > game[i])\
    \ \n        {\n            result[i] = guess[i] - game[i];\n        }\n      \
    \  else if(guess[i] < game[i]) \n        {\n            result[i] = game[i] -\
    \ guess[i];\n        }\n        else \n        {\n            result[i] = 0;\n\
    \        }\n    }\n    return result;\n}", "{ \n    return game.map!(a => abs(a\
    \ - guess[$-1])).array;\n}", "{\n    \n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        if(game[i] == guess[i])\n\
    \        {\n            result[i] = 0;\n        }\n        else\n        {\n \
    \           result[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return\
    \ result;\n}", "{\n    int n = game.length;\n    long[] dif = new long[n];\n \
    \   for (int i = 0; i < n; i++)\n    {\n        dif[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return dif;\n}", "{\n    long[] result;\n    result = new long[game.length];\n\
    \    int i = 0;\n    while(i<game.length)\n    {\n        result[i] = abs(game[i]-guess[i]);\n\
    \        i++;\n    }\n    return result;\n}", "{ \n   size_t len = game.length;\n\
    \   long[] res = new long[len];\n   for(size_t i = 0; i < len; i++)\n   {\n  \
    \     res[i] = abs(game[i] - guess[i]);\n   }\n   return res;\n}\n/*\n    Given\
    \ a string, , matching the regular expression [A-Za-z !,?._'@]+, split the string\
    \ into tokens.\n    We define a token to be one or more consecutive English alphabetic\
    \ letters. Then, print the number of tokens,\n    followed by each token on a\
    \ new line.\n    \n    >>> stringTokenizer(\"He is a very very good boy, isn't\
    \ he?\")\n    >>>10\n    >>>He\n    >>>is\n    >>>a\n    >>>very\n    >>>very\n\
    \    >>>good\n    >>>boy\n    >>>isn\n    >>>t\n    >>>he\n*/", "{\n    int i;\n\
    \    int n;\n    n = game.length;\n    long[] result = new long[n];\n    for (i\
    \ = 0; i < n; i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[game.length];\n    for(int\
    \ i = 0; i < game.length; i++)\n    {\n        if(game[i] == guess[i])\n     \
    \   {\n            result[i] = 0;\n        }\n        else\n        {\n      \
    \      result[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n\
    }", "{\n     return game.zip(guess).map!(a => Math.abs(a[0] - a[1]));\n}", "{\n\
    \    long[] result = new long[game.length];\n    foreach(i, item; game)\n    {\n\
    \        if(game[i] == guess[i])\n        {\n            result[i] = 0;\n    \
    \    }\n        else\n        {\n            result[i] = abs(game[i] - guess[i]);\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}\n ", "{\n    long[] res = new long[game.length];\n\
    \    int i = 0;\n    foreach(var x,var y;zip(game,guess))\n    {\n        res[i]\
    \ = x < y ? y - x : x - y;\n        i++;\n    }\n    return res;\n}", "{\n   \
    \ long[] result = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return\
    \ result;\n}", "{\n    auto result = long[game.length];\n    foreach(i, a; game)\n\
    \    {\n        if(a > guess[i])\n            result[i] = a - guess[i];\n    \
    \    else if(a < guess[i])\n            result[i] = guess[i] - a;\n        else\
    \ \n            result[i] = 0;\n    }\n    return result;\n}", "{\n    \n    \n\
    \    \n    \n    //long[] result = new long[game.length];\n    int i = 0;\n  \
    \  long[] result = new long[game.length];\n    for(i = 0; i < game.length; i++)\n\
    \    {\n        if(game[i] == guess[i])\n        {\n            result[i] = 0;\n\
    \        }\n        else\n        {\n            result[i] = Math.abs(game[i]\
    \ - guess[i]);\n        }\n    }\n    return result;\n}", "{\n    long[] res =\
    \ new long[guess.length];\n    foreach(i, g; guess)\n    {\n        res[i] = abs(game[i]\
    \ - g);\n    }\n    return res;\n}", "{\n    return zip(game, guess).map!((a,\
    \ b) => abs(a - b));\n}", "{ \n    long[] counter = new long[game.length];\n \
    \   long[] newcounter = new long[game.length];\n    foreach(index, value; counter)\n\
    \    {\n        if(value != game[index])\n        {\n            newcounter[index]\
    \ = abs(value - game[index]);\n        }\n        else\n        {\n          \
    \  newcounter[index] = 0;\n        }\n    }\n    return newcounter;\n}", "{\n\
    \  auto map = std.range(0, guess.length).map!(i => abs(game[i] - guess[i]));\n\
    \  return map.array;\n}", "{\n  long[] result = new long[game.length];\n  \n \
    \ for(long i = 0; i < game.length; i++)\n  {\n    result[cast(size_t)i] = abs(game[cast(size_t)i]\
    \ - guess[cast(size_t)i]);\n  }\n  \n  return result;\n}", "{\n    long[] compare\
    \ = new long[game.length];\n    for(int i = 0; i < game.length; i++)\n    {\n\
    \        compare[i] = abs(game[i] - guess[i]);\n    }\n    return compare;\n}\n\
    // --------------------------------------------\n/*\n# sort_by_value\nGiven a\
    \ list of items along with their weights, sort the items by their weight in ascending\
    \ order\n    (lightest items first). If two items have the same weight, then keep\
    \ the original order they had in\n    the input list.", "{\n    /*\n    auto results\
    \ = game.dup;\n    int counter = 0;\n    foreach(ref result; results)\n    {\n\
    \        if(result != guess[counter])\n        {\n            result = abs(result\
    \ - guess[counter]);\n        }\n        counter++;\n    }\n    return results;\n\
    \    */\n    return game.zip(guess).map!(t => abs(t[0] - t[1]));\n}", "{ \n  \
    \  long[] result = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        if(game[i] != guess[i])\n        {\n            result[i]\
    \ = abs(game[i] - guess[i]);\n        }\n        else\n        {\n           \
    \ result[i] = 0;\n        }\n    }\n    return result;\n}", "{\n    assert(game.length\
    \ == guess.length);\n    long[] result = new long[game.length];\n    foreach(i,\
    \ r; result)\n    {\n        if(game[i] == guess[i])\n            r = 0;\n   \
    \     else\n            r = abs(game[i] - guess[i]);\n    }\n    return result;\n\
    }", "{\n    immutable(long)[] a = std.array.array(game.length, (immutable(long)\
    \ i) => game[i] - guess[i]);\n    return a.map!abs.array;\n}", "{\n    \n    long[]\
    \ result = new long[game.length];\n    foreach(i, idx; 0 .. game.length)\n   \
    \ {\n        if(game[idx] == guess[idx])\n        {\n            result[idx] =\
    \ 0L;\n        }\n        else\n        {\n            result[idx] = abs(game[idx]\
    \ - guess[idx]);\n        }\n    }\n    return result;\n}", "{\n    long[] results\
    \ = new long[game.length];\n    for(size_t i = 0; i < game.length; i++)\n    {\n\
    \        results[i] = abs(game[i] - guess[i]);\n    }\n    return results;\n}",
  "{\n    long[] result = new long[game.length];\n    long i = 0;\n    foreach(long\
    \ g; game)\n    {\n        result[i] = abs(g - guess[i]);\n        i++;\n    }\n\
    \    return result;\n}", "{\n    //the game and guess parameters will be two arrays\
    \ of equal length,\n    //where for each index the game score is supplied and\
    \ the corresponding\n    //guess is given.", "{\n    long[] result = new long[game.length];\n\
    \    foreach(index, element; game)\n    {\n        result[index] = abs(element\
    \ - guess[index]);\n    }\n    return result;\n}", "{\n    long[] result;\n  \
    \  /*\n    import std.algorithm;\n    import std.range;\n    import std.stdio;\n\
    \    import std.typecons;\n    import std.math;\n    */\n    result = game\n \
    \       .zip(guess)\n        .map!(a => abs(a[0] - a[1]))\n        .array;\n \
    \   return result;\n}", "{\n     long[] result = new long[game.length];\n    \
    \ foreach(i,curr;game)\n     {\n         //If any of the two are negative, the\
    \ difference will always be equal to the larger of the two\n         if(curr <\
    \ 0 || guess[i] < 0)\n         {\n             result[i] = max(abs(curr),abs(guess[i]));\n\
    \         }\n         else\n         {\n             result[i] = abs(curr - guess[i]);\n\
    \         }\n     }\n     return result;\n}", "{\n    assert(game.length == guess.length);\n\
    \    import std.algorithm.comparison;\n    auto res = game.dup;\n    for(int i\
    \ = 0; i < res.length; i++)\n    {\n        if(game[i] == guess[i])\n        \
    \    res[i] = 0;\n        else\n            res[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return res;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        if(game[i] == guess[i])\n\
    \        {\n            result[i] = 0;\n        }\n        else\n        {\n \
    \           result[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] res = new long[game.length];\n    for(int i = 0;\
    \ i < game.length; i++)\n    {\n        res[i] = Math.abs(game[i] - guess[i]);\n\
    \    }\n    return res;\n}", "{\n    long[] result = new long[game.length];\n\
    \    foreach(i, j; game)\n    {\n        result[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return result;\n}", "{\n    auto result = long[](game.length);\n \
    \   for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}\n/*\nDetermine if a triangle is possible\
    \ based on the side lengths.\n A triangle is possible if the sum of any two sides\
    \ is greater than the third side.\n When the sum of the lengths of any two sides\
    \ of a triangle is greater than or equal to the length of the third side,\n then\
    \ the lengths describe a triangle. \n If the sum of the lengths of any two sides\
    \ is less than or equal to the length of the third side,\n  then the lengths do\
    \ not describe a triangle.", "{\n    long[] res = new long[game.length];\n   \
    \ for(int i = 0; i < game.length; i++)\n    {\n        if(game[i] < 0 || guess[i]\
    \ < 0)\n        {\n            res[i] = -1;\n        }\n        else\n       \
    \ {\n            res[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return\
    \ res;\n}", "{\n    \n    long[] temp = new long[game.length];\n    int i;\n \
    \   for(i = 0; i < game.length; i++)\n    {\n        temp[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return temp;\n}", "{\n    long[] results = new long[game.length];\n\
    \    foreach(i, val; game)\n    {\n        results[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return results;\n}", "{\n    //partially applied function 'map'\n\
    \    return game.map!(a => abs(a - guess));\n}", "{\n    long[] res;\n    foreach(index,element;\
    \ game)\n    {\n        if(game[index] == guess[index])\n        {\n         \
    \   res[index] = 0;\n        }\n        else\n        {\n            res[index]\
    \ = abs(game[index] - guess[index]);\n        }\n    }\n    return res;\n}", "{\n\
    \    long[] ret;\n    ret.length = game.length;\n    foreach(i, value; game)\n\
    \    {\n        ret[i] = game[i] > guess[i] ? game[i] - guess[i] : guess[i] -\
    \ game[i];\n    }\n    return ret;\n}", "{\n    // result array\n    long[] result;",
  "{\n  long[] result = new long[game.length];\n  foreach(i, index; game)\n  {\n \
    \   result[index] = abs(game[index] - guess[index]);\n  }\n  return result;\n}",
  "{\n    long[] result;\n    foreach(i, g ; guess)\n    {\n        if(i < guess.length)\n\
    \        {\n            result ~= abs(g - game[i]);\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[game.length];\n    for(int i =\
    \ 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(long i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}\n/*\nMaze\nThere is a rectangular\
    \ maze of size (n x m) consisting of non-negative integer values. The maze consists\
    \ of two types of cells,\n    empty cells with value 0 and walls with value 1.\n\
    \    The maze has a single start and a single end, represented by cells with value\
    \ 2. The start and end may be located anywhere\n    in the maze. Your task is\
    \ to find the shortest path from the start to the end.\n    You must travel only\
    \ through empty cells, moving strictly north, south, east, or west.\n    Return\
    \ an array of cells that describes the shortest path from the start to the end,\
    \ including both the start and the end.\n    If there is no path from the start\
    \ to the end, return an empty array.\n    example:\n    >>> shortestPath([[0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L],\n                       [0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L],\n                       [0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L],\n                       [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L],\n\
    \                       [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L],\n          \
    \             [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L],\n                    \
    \   [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L],\n                       [0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L],\n                       [0L, 0L, 0L, 0", "{\n\
    \    size_t[] r = new size_t[game.length];\n    foreach(i,el;game)\n    {\n  \
    \      r[i] = el - guess[i];\n        if(r[i]<0)\n            r[i] = -r[i];\n\
    \    }\n    return r;\n}", "{\n    long[] result = new long[game.length];\n  \
    \  for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    foreach(i, item; game)\n    {\n        result[i] = abs(item - guess[i]);\n\
    \    }\n    return result;\n}", "{\n    if(game.length == guess.length)\n    {\n\
    \        auto result = game.dup;\n        foreach(int i, auto g; game)\n     \
    \   {\n            result[i] = abs(g - guess[i]);\n        }\n        return result;\n\
    \    }\n    return null;\n}", "{\n    // use an array of tuple to store the values\n\
    \    auto t = new Tuple!(long, long)[game.length];\n    // if you need to look\
    \ up a value in a tuple, you have to cast it as an array\n    // as opposed to\
    \ a string which you can use indexOf\n    foreach(int i, e; t.tupleof)\n    {\n\
    \        t[i] = tuple(game[i], guess[i]);\n    }\n    // create a long[] to return\n\
    \    long[] ret = new long[game.length];\n    foreach(int i, ref e; ret)\n   \
    \ {\n        // if the value of the long[] is 0, they were correct, so set\n \
    \       // ret[i] to 0\n        if(t[i][0] == t[i][1])\n        {\n          \
    \  ret[i] = 0;\n        }\n        // else, get the absolute difference between\
    \ the two\n        else\n        {\n            ret[i] = abs(t[i][0] - t[i][1]);\n\
    \        }\n    }\n    return ret;\n}\n \n \n \n/*\nYour task is to create a function\
    \ that, given a string and an int, \n    creates a string of the same character\
    \ repeated that number of times. \n    If the first parameter is not a string\
    \ or the second parameter is not an int, \n    return false instead.\n    \n \
    \   example:\n    \n    >>> createString(\"b\", 3)\n    \"bbb\"\n    >>> createString(\"\
    *\", 8)\n    \"********\"\n    >>> createString(\"hello\", 0)\n    \"\"\n*/\n\
    string createString(string s, int i)\n{\n    // create a string to return\n  \
    \  string ret = \"\";\n    // start i at the passed value\n    // if i is less\
    \ than 1, then the string needs to be an empty string\n    if(i < 1)\n    {\n\
    \        ret = \"\";\n    }\n    // otherwise, while i is greater than 0, add\
    \ the string to the return string\n    while(i > 0)\n    {\n        ret ~= s;\n\
    \        i--;\n    }\n    return ret;\n}\n \n", "{\n    long[] res = new long[game.length];\n\
    \    foreach(i, element; game)\n    {\n        res[i] = abs(element - guess[i]);\n\
    \    }\n    return res;\n}\n/*\n    description:", "{ \n    long[] result = new\
    \ long[game.length];\n    for(long i = 0; i < game.length; i++)\n    {\n     \
    \   result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n}", "{\n\
    \    long[] res = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        res[i] = abs(game[i] - guess[i]);\n    }\n    return res;\n\
    }", "{\n    auto zipRange = zip(game, guess);\n    long[] result;\n    foreach(zipRange;\
    \ item)\n    {\n        result ~= abs(item[0] - item[1]);\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        if(guess[i] == game[i])\n        {\n            result[i]\
    \ = 0;\n        }\n        else\n        {\n            result[i] = abs(guess[i]\
    \ - game[i]);\n        }\n    }\n    return result;\n}", "{\n    long[] result\
    \ = game.dup;\n    for(int i = 0; i < game.length; i++)\n    {\n        result[i]\
    \ = abs(game[i] - guess[i]);\n    }\n    return result;\n}\n/*\nWe all like to\
    \ save money, and I'm no exception. My only problem is that I'm not very good\
    \ at it. \n    My wife, however, is extremely good at that. She plans our budget\
    \ and keeps track of the bills \n    that need to be paid. I can hardly do a thing\
    \ without consulting her first. But even she occasionally \n    makes mistakes,\
    \ and that's where I'm good at helping. She has put on a paper all the bills we\
    \ paid \n    out in a month in a table with a single column. To each bill she\
    \ added a comment that describes \n    what the bill was for. The comment is either\
    \ \n    'correct' or of the form 'incorrect: <number>', \n    where <number> is\
    \ the amount of money that she could have saved if we paid out the bill for the\
    \ correct amount.\n    Your task is to return the sum of all the values that are\
    \ mentioned in the comments. \n    If there is no number in the comment, ignore\
    \ the comment.\n    \n    examples:\n    >>> moneySaved([['Correct', 'Correct',\
    \ 'Correct', 'Incorrect: 5', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct',\
    \ 'Correct', 'Correct', 'Correct', 'Correct', 'Correct', 'Correct", "{\n    long[]\
    \ arr = new long[6];\n    int i = 0;\n    while(i < 6)\n    {\n        arr[i]\
    \ = abs(game[i] - guess[i]);\n        i++;\n    }\n    return arr;\n}", "{\n \
    \   auto ret = new long[];\n    foreach(i, e; guess)\n    {\n        ret ~= game[i]\
    \ - e;\n    }\n    return ret;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    foreach(counter, element; game)\n    {\n        if(element == guess[counter])\n\
    \        {\n            result[counter] = 0L;\n        }\n        else\n     \
    \   {\n            result[counter] = abs(element - guess[counter]);\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    foreach(idx, val; game) \n    {\n        result[idx] = Math.abs(val - guess[idx]);\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    foreach(i, g; game) {\n        if(guess[i] == g)\n            result[i] =\
    \ 0;\n        else\n            result[i] = abs(guess[i] - g);\n    }\n    return\
    \ result;\n}", "{\n    \n    long[] result = new long[game.length];\n    for(int\
    \ i = 0; i < game.length; i++)\n    {\n        if(guess[i] == game[i])\n     \
    \   {\n            result[i] = 0;\n        }\n        else\n        {\n      \
    \      result[i] = abs(guess[i] - game[i]);\n        }\n    }\n    return result;\n\
    }\n//better solution\nlong[] compare(long[] game, long[] guess)\n{\n    long[]\
    \ result = new long[game.length];\n    for(int i = 0; i < game.length; i++)\n\
    \    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[game.length];\n    for(int i = 0; i < game.length;\
    \ i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return\
    \ result;\n}\n/*\n# DIFFICULTY: very easy\n# POINTS: 1\n# LANGUAGE: D\n# SUBMISSION_DATE:\
    \ 2/12/2019\n# PROBLEM_ID: 18\n# PYTHON_VERSION: 2.7\n# PROGRAMMER: Paulina Vasquez",
  "{ \n    //long[] answer = new long[game.length];\n    auto answer = new long[game.length];\n\
    \    for(uint i = 0; i < game.length; i++)\n    {\n        answer[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return answer;\n}", "{\n    auto res = new long[game.length];\n\
    \    foreach(i, e; zip(game, guess))\n    {\n        res[i] = abs(e[0] - e[1]);\n\
    \    }\n    return res;\n}", "{\n    long[] larr = new long[game.length];\n  \
    \  for(int i = 0; i < game.length; i++) \n    {\n        if(game[i] < 0) game[i]\
    \ = -game[i];\n        if(guess[i] < 0) guess[i] = -guess[i];\n        larr[i]\
    \ = abs(game[i] - guess[i]);\n    }\n    return larr;\n}", "{\n    long[] result\
    \ = new long[game.length];\n    foreach(immutable i, immutable j; zip(game, guess))\n\
    \    {\n        result[i] = abs(j - game[i]);\n    }\n    return result;\n}",
  "{\n\tlong[] s = [];\n\tforeach(d, index; guess)\n\t{\n\t\tlong diff = abs(game[index]\
    \ - guess[index]);\n\t\ts ~= diff;\n\t}\n\treturn s;\n}", "{\n    long[] result\
    \ = new long[game.length];\n    int i = 0;\n    foreach(item; game)\n    {\n \
    \       if(item >= guess[i])\n        {\n            result[i] = item - guess[i];\n\
    \        }\n        else\n        {\n            result[i] = guess[i] - item;\n\
    \        }\n        i++;\n    }\n    return result;\n}", "{ \n  long[] x = new\
    \ long[6];\n  for(int i = 0; i < game.length; i++) {\n    if(game[i] == guess[i])\
    \ {\n      x[i] = 0;\n    }\n    else {\n      x[i] = abs(game[i] - guess[i]);\n\
    \    }\n  }\n  return x;\n}\n//v2\nlong[] compare(long[] game, long[] guess) \n\
    { \n  long[] x = new long[6];\n  for(int i = 0; i < game.length; i++) {\n    x[i]\
    \ = abs(game[i] - guess[i]);\n  }\n  return x;\n}\n//v3\nlong[] compare(long[]\
    \ game, long[] guess) \n{ \n  long[] x = new long[6];\n  for(int i = 0; i < game.length;\
    \ i++) {\n    x[i] = abs(game[i] - guess[i]);\n  }\n  return x;\n}\n//v4\nlong[]\
    \ compare(long[] game, long[] guess) \n{ \n  long[] x = new long[6];\n  for(int\
    \ i = 0; i < game.length; i++) {\n    x[i] = abs(game[i] - guess[i]);\n  }\n \
    \ return x;\n}\n//v5\nlong[] compare(long[] game, long[] guess) \n{ \n  long[]\
    \ x = new long[6];\n  for(int i = 0; i < game.length; i++) {\n    x[i] = abs(game[i]\
    \ - guess[i]);\n  }\n  return x;\n}\n//v6\nlong[] compare(long[] game, long[]\
    \ guess) \n{ \n  long[] x = new long[6];\n  for(int i = 0; i < game.length; i++)\
    \ {\n    x[i] = abs(game[i] - guess[i]);\n  }\n  return x;\n}\n//v7\nlong[] compare(long[]\
    \ game, long[] guess) \n{ \n  long[] x = new long", "{\n    return zip(game, guess).map!(t\
    \ => abs(t[0] - t[1]));\n}", "{\n  // long[] res = new long[game.length];\n  long[]\
    \ res = new long[0];\n  foreach(i, g; game)\n  {\n    res ~= abs(g - guess[i]);\n\
    \  }\n  return res;\n}", "{\n    long[] result = new long[game.length];\n    for(int\
    \ i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return result;\n}", "{\n    auto res = game.dup;\n    foreach(immutable\
    \ i, immutable item; guess)\n    {\n        res[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return res;\n}", "{\n    int i = 0;\n    long[] answer = new long[game.length];\n\
    \    foreach(ref long a; game)\n    {\n        answer[i] = abs(a - guess[i]);\n\
    \        i++;\n    }\n    return answer;\n}\n/*\nGiven an array of integers, sort\
    \ it using the odd-even sort algorithm.", "{\n    auto s = game.length;\n    auto\
    \ result = new long[](s);\n    for (int i = 0; i < s; i++)\n    {\n        result[i]\
    \ = abs(game[i] - guess[i]);\n    }\n    return result;\n}\n/*\nImplement a function\
    \ that takes a list of integers lst and a single integer n, and\n    returns True\
    \ if n is contained in lst, and False otherwise. \n    \n    >>> isIn([1, 2, 3,\
    \ 4, 5], 3)\n    True\n    >>> isIn([1, 2, 3, 4, 5], 6)\n    False\n*/", "{\n\
    \    long[] result = new long[game.length];\n    for( int i = 0; i < game.length;\
    \ i++ )\n    {\n        result[i] = guess[i] == game[i] ? 0 : abs(guess[i] - game[i]);\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(long i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    long[] result;\n    int\
    \ i;\n    int length;\n    length = game.length;\n    result = new long[length];\n\
    \    i = 0;\n    foreach(long l ; game)\n    {\n        if(l < guess[i])\n   \
    \     {\n            result[i] = guess[i] - l;\n        }\n        else if(l >\
    \ guess[i])\n        {\n            result[i] = l - guess[i];\n        }\n   \
    \     else\n        {\n            result[i] = 0;\n        }\n        i++;\n \
    \   }\n    return result;\n}", "{\n    return array(zip(game, guess).map!((a,\
    \ b) => (a < b) ? b - a : a - b));\n}", "{\n    long[] output = new long[game.length];\n\
    \    long diff;\n    foreach(i, g; game)\n    {\n        diff = abs(g - guess[i]);\n\
    \        output[i] = diff;\n    }\n    return output;\n}", "{\n    return zip(game,\
    \ guess).map!(x => abs(x[0] - x[1]));\n}", "{\n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}\n//OOP 2\n/*\nYour task is to construct\
    \ a building which will be a pile of n cubes. The cube at the bottom will have\
    \ a volume of n^3, \nthe cube above will have volume of (n-1)^3 and so on until\
    \ the top which will have a volume of 1^3.", "{\n    auto result = new long[game.length];\n\
    \    foreach(i,j; zip(game, guess))\n    {\n        result[i] = abs(j[0] - j[1]);\n\
    \    }\n    return result;\n}", "{\n    int len = game.length;\n    long[] res\
    \ = new long[len];\n    for (int i = 0; i < len; i++)\n    {\n        res[i] =\
    \ abs(game[i] - guess[i]);\n    }\n    return res;\n}", "{\n    return game.zip(guess).map!(a\
    \ => abs(a[0] - a[1]));\n}", "{\n    int len = game.length;\n    long[] result\
    \ = new long[len];\n    for (int i = 0; i < len; i++)\n    {\n        result[i]\
    \ = abs(game[i] - guess[i]);\n    }\n    return result;\n}\n```\n- [147. Sliding\
    \ Puzzle](https://www.codewars.com/kata/5647f1bdf1c255f8d2000a6a)\n```python\n\
    def sliding_puzzle(puzzle):\n    import math\n    import itertools\n    import\
    \ collections\n    puzzle = tuple(puzzle)\n    start = puzzle\n    target = tuple(sorted(puzzle))\n\
    \    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    # There is a six piece\
    \ puzzle and a nine piece puzzle\n    dimensions = int(math.sqrt(len(puzzle)))\n\
    \    Q = collections.deque([(start, 0)])\n    seen = set([start])\n    while Q:\n\
    \        (state, moves) = Q.popleft()\n        if state == target:\n         \
    \   return moves\n        # Find the empty space\n        for i, s in enumerate(state):\n\
    \            if s == 0:\n                # Calculate the row and column\n    \
    \            (row, col) = (i // dimensions, i % dimensions)\n                #\
    \ Valid neighbors are those within the bounds of the grid\n                valid_neighbors\
    \ = [(row + r, col + c) for (r, c) in neighbors if (0 <= row + r < dimensions\
    \ and 0 <= col + c < dimensions)]\n                # We don't care about the order\
    \ of the tuple, so let's make a set\n                new_states = set()\n    \
    \            for (r, c) in valid_neighbors:\n                    # Swap the empty\
    \ space with the neighbor\n                    new_puzzle = list(state)\n    \
    \                new_puzzle[i], new_puzzle[r * dimensions + c] = new_puzzle[r\
    \ * dimensions + c], new_puzzle[i]\n                    new_puzzle = tuple(new_puzzle)\n\
    \                    if new_puzzle not in seen:\n                        seen",
  "{\n    long[] result = new long[game.length];\n    for(in i = 0; i < game.length;\
    \ i++) \n    {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return\
    \ result;\n}", "{\n    long[] res = new long[game.length];\n    for(int i = 0;\
    \ i < game.length; i++)\n    {\n        res[i] = abs(game[i] - guess[i]);\n  \
    \  }\n    return res;\n}", "{\n    \n    long[] results;\n    //results = new\
    \ long[5];\n    //results = game - guess;\n    results = game.map!(x => x - guess[x]);\n\
    \    //results = results.map!(x => abs(x));\n    return results;\n}", "{ \n  \
    \  return zip(game, guess).map!(t => abs(t[0] - t[1]));\n}", "{\n    long[] result\
    \ = new long[game.length];\n    for(int i = 0; i < game.length; i++)\n    {\n\
    \        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n}",
  "{\n    long[] result = new long[game.length];\n    foreach(index, item; game)\n\
    \    {\n        result[index] = abs(item - guess[index]);\n    }\n    return result;\n\
    }", "{\n    int n = game.length;\n    long[] res = new long[n];\n    for (int\
    \ i = 0; i < n; i++)\n    {\n        res[i] = abs(game[i] - guess[i]);\n    }\n\
    \    return res;\n}", "{\n    long[] ret = new long[game.length];\n    for(int\
    \ i = 0; i < game.length; i++)\n    {\n        ret[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return ret;\n}", "{ \n    long[] result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    auto result = new long[game.length];\n\
    \    for(int i = 0; i < game.length; i++)\n    {\n        result[i] = abs(game[i]\
    \ - guess[i]);\n    }\n    return result;\n}", "{\n    long[] result = game.dup;\n\
    \    foreach(i, e; game) \n    {\n        result[i] = abs(game[i] - guess[i]);\n\
    \    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
