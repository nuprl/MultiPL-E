language: d
name: HumanEval_18_how_many_times
results:
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tconst auto length_of_string\
    \ = string.length;\n\tconst auto length_of_substring = substring.length;\n\t\n\
    \tlong count = 0;\n\t\n\tif(!length_of_string || !length_of_substring)\n\t\treturn\
    \ count;\n\t\t\n\tfor(long i = 0; i <= length_of_string - length_of_substring;\
    \ i++)\n\t{\n\t\tif(string[i .. i + length_of_substring] == substring)\n\t\t\t\
    count++;\n\t}\n\t\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (int i = 0; i < string.length - substring.length; i++) \n    {\n     \
    \   if (string[i .. i + substring.length] == substring) \n        {\n        \
    \    count++;\n        }\n    }\n    return count;\n}\n/*\n Find the number of\
    \ times a given substring can be found in the original string.\n >>> count_substrings(\"\
    This is a test string\", \"is\")\n 2L\n    >>> count_substrings(\"babababa\",\
    \ \"baba\")\n 3L\n    >>> count_substrings(\"Python is an awesome language to\
    \ program in!\", \"o\")\n 4L\n    >>> count_substrings(\"We have nothing in common!\"\
    , \"really?\")\n 0L\n    >>> count_substrings(\"This is this and that is this\"\
    , \"this\")\n 2L\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm36hf8gi.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm36hf8gi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long string_length\
    \ = string.length;\n    long substring_length = substring.length;\n    if (substring_length\
    \ > string_length) \n    {\n        return 0L;\n    }\n    long[] string_substring_table\
    \ = build_substring_table(substring);\n    return count_substring_matches(string,\
    \ substring, string_substring_table);\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptzzmfy43.d(21): Error: undefined identifier `build_substring_table`

    /tmp/tmptzzmfy43.d(22): Error: undefined identifier `count_substring_matches`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptzzmfy43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nin{\n    assert(substring.length\
    \ <= string.length);\n}\nout(count) {\n    assert(count <= string.length - substring.length\
    \ + 1);\n} body {\n    long count = 0;\n    size_t sublen = substring.length;\n\
    \    if (sublen == 0)\n        return 0;\n    for (size_t i = 0; i < string.length\
    \ - sublen + 1; i++) {\n        //printf(\"i: %i\\n\", i);\n        if (string[i..i+sublen]\
    \ == substring) {\n            count++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0l1x1yry.d(15): Assertion failure

    ----------------

    ??:? _d_assertp [0x427fad]

    ??:? long tmp0l1x1yry.how_many_times(immutable(char)[], immutable(char)[]) [0x427ac1]

    ??:? void tmp0l1x1yry.__unittest_L32_C1() [0x427bd3]

    ??:? void tmp0l1x1yry.__modtest() [0x427d60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bdaf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fdd5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430284]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd61]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac95]

    ??:? runModuleUnitTests [0x42bb85]

    ??:? void rt.dmain2._d_run_main(int, cha'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   foreach(immutable k; 0 .. string.length)\n    {\n        if(string[k .. k\
    \ + substring.length - 1] == substring)\n        {\n            count++;\n   \
    \     }\n    }\n    return count;\n}\n/*\n Find the position of the first occurence\
    \ of the given substring. Return (size_t)-1 if not found. Count overlaping cases.\n\
    \    >>> find_first_pos(\"\", \"a\")\n    -1L\n    >>> find_first_pos(\"aaa\"\
    , \"a\")\n    0L\n    >>> find_first_pos(\"aaab\", \"ab\")\n    2L\n    \n*/\n\
    long find_first_pos(string string, string substring) \n{\n    foreach(immutable\
    \ k; 0 .. string.length)\n    {\n        if(string[k .. k + substring.length -\
    \ 1] == substring)\n        {\n            return k;\n        }\n    }\n    return\
    \ -1;\n}\n/*\n Find the position of the last occurence of the given substring.\
    \ Return (size_t)-1 if not found. Count overlaping cases.\n    >>> find_last_pos(\"\
    \", \"a\")\n    -1L\n    >>> find_last_pos(\"aaa\", \"a\")\n    2L\n    >>> find_last_pos(\"\
    aaab\", \"ab\")\n    2L\n    \n*/\nlong find_last_pos(string string, string substring)\
    \ \n{\n    immutable r = -1;\n    foreach(immutable k; 0 .. string.length)\n \
    \   {\n        if(string[k .. k + substring.length - 1] == substring)\n      \
    \  {\n            r = k;\n        }\n    }\n    return r;\n}\n/*\n Check if the\
    \ given string ends with the given substring.\n    >>> ends_with(\"\", \"a\")\n\
    \    false\n    >>> ends_with(\"aaa\", \"a\")\n    true\n    >>> ends_with(\"\
    aaa\", \"aaaa\")\n    false\n    \n*/\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxndoqm_s.d(63): Error: cannot modify `immutable` expression `r`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxndoqm_s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    for (long i = 0; i < string.length; i++) \n    {\n        if (string[i ..\
    \ i + substring.length] == substring) \n        {\n            result++;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpqw_8ftjz.d(18): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x427ff6]

    ??:? long tmpqw_8ftjz.how_many_times(immutable(char)[], immutable(char)[]) [0x427ab7]

    ??:? void tmpqw_8ftjz.__unittest_L25_C1() [0x427bba]

    ??:? void tmpqw_8ftjz.__modtest() [0x427cc4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab72]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc89]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430138]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc15]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab49]

    ??:? runModuleUnitTests [0x42ba39]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n    pure \n{\n    long ret\
    \ = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) !=\
    \ string.npos) \n    {\n        ret++;\n        pos += 2;\n    }\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvf5zluqa.d(18): Error: no property `find` for type `string`

    /tmp/tmpvf5zluqa.d(18): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvf5zluqa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   if (empty(substring)) \n    {\n        return count;\n    }\n    else \n \
    \   {\n        for (long i = 0; i < len(string); i++) \n        {\n          \
    \  for (long j = 0; j < len(substring); j++) \n            {\n               \
    \ if (string[i + j] != substring[j]) \n                {\n                   \
    \ break;\n                }\n                if (j == len(substring) - 1) \n \
    \               {\n                    count++;\n                }\n         \
    \   }\n        }\n        return count;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6jka7jb9.d(16): Error: undefined identifier `empty`

    /tmp/tmp6jka7jb9.d(22): Error: undefined identifier `len`

    /tmp/tmp6jka7jb9.d(24): Error: undefined identifier `len`

    /tmp/tmp6jka7jb9.d(30): Error: undefined identifier `len`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6jka7jb9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nin \n{\n    assert(string.length\
    \ >= substring.length);\n}\nbody \n{\n    long count = 0L;\n    auto stringRange\
    \ = string.byChunks(substring.length);\n    foreach (i, chunk; stringRange)\n\
    \    {\n        if (chunk == substring)\n        {\n            count++;\n   \
    \     }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxpmb04md.d(21): Error: no property `byChunks` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxpmb04md.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (substring.length\
    \ == 0)\n        return 0;\n    if (string.length == 0)\n        return 0;\n \
    \   if (string.length < substring.length)\n        return 0;\n    long counter\
    \ = 0;\n    if (string.find(substring, 0) != -1)\n        counter++;\n    for\
    \ (long i = 0; i < string.length; i++)\n    {\n        long index = string.find(substring,\
    \ i);\n        if (index == -1)\n            break;\n        else\n        {\n\
    \            counter++;\n            i = index;\n        }\n    }\n    return\
    \ counter;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurpd5flh.d(22): Error: no property `find` for type `string`

    /tmp/tmpurpd5flh.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurpd5flh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    static assert(substring.length\
    \ <= string.length);\n    long count = 0;\n    auto string_it = string.front;\n\
    \    while ((string_it = find(string_it, string.back, substring.front)) != string.back)\n\
    \    {\n        auto substring_it = substring.front;\n        while (substring_it\
    \ != substring.back && string_it != string.back && *substring_it == *string_it)\n\
    \        {\n            ++substring_it;\n            ++string_it;\n        }\n\
    \        if (substring_it == substring.back)\n        {\n            ++count;\n\
    \        }\n    }\n    return count;\n}\n \n/*\n    >>> flatten_tuple((1,), (2,),\
    \ (3,))\n    (1, 2, 3)\n    >>> flatten_tuple((1,), (2,), ())\n    (1, 2)\n  \
    \  >>> flatten_tuple((), (2,), (3,))\n    (2, 3)\n    >>> flatten_tuple((1, (2,),\
    \ (3,)),)\n    (1, 2, 3)\n    >>> flatten_tuple(((1,), (2,), (3,)),)\n    (1,\
    \ 2, 3)\n    >>> flatten_tuple(((1, 2),), ((3, 4),))\n    ((1, 2), (3, 4))\n \
    \   >>> flatten_tuple(((1, 2),), ((3, 4),), ((5, 6),))\n    ((1, 2), (3, 4), (5,\
    \ 6))\n    >>> flatten_tuple(((1,), (2,), (3,)), ((4,), (5,), (6,)))\n    (1,\
    \ 2, 3, 4, 5, 6)\n*/\nauto flatten_tuple(auto args...)\n{\n    auto result = tuple();\n\
    \    foreach (arg; args)\n    {\n        result ~= arg;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5xhsce2t.d(52): Error: undefined identifier `args`, did you mean
    template `abs(Num)(Num x)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xhsce2t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tlong\
    \ index = 0;\n\tlong length = string.length;\n\t\n\twhile (index < length)\n\t\
    {\n\t\tif (string[index .. $] == substring)\n\t\t{\n\t\t\tcount++;\n\t\t\tindex\
    \ += substring.length;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tindex++;\n\t\t}\n\t}\n\t\
    \n\treturn count;\n}\n/*\n Determine if a string starts with another string.\n\
    \    >>> is_starts_with(\"Hello, world!\", \"Hello\")\n    true\n    >>> is_starts_with(\"\
    Hello, world!\", \"Hello,\")\n    true\n    >>> is_starts_with(\"Hello, world!\"\
    , \".\")\n    false\n    >>> is_starts_with(\"Hello, world!\", \"\")\n    true\n\
    */\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdg84449j.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f4d]

    ??:? void tmpdg84449j.__unittest_L45_C1() [0x427b97]

    ??:? void tmpdg84449j.__modtest() [0x427ccc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab7a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430140]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab51]

    ??:? runModuleUnitTests [0x42ba41]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428410]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long counter = 0;\n \
    \ long index = 0;\n  int len = length(substring);\n  //1. Find the index for the\
    \ given substring\n  //2. When the index is not -1, increase the counter and get\
    \ the index from the next index of the found index\n  //3. Repeat.\n  while(true)\n\
    \  {\n    index = indexOf(string, substring, index);\n    if(index == -1)\n  \
    \    break;\n    counter++;\n    index += len;\n  }\n  return counter;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqqndpqnc.d(17): Error: undefined identifier `length`

    /tmp/tmpqqndpqnc.d(23): Error: undefined identifier `indexOf`, did you mean variable
    `index`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqqndpqnc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return count(string.countUntil(substring));\n\
    }\n```\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptl3ju9mp.d(17): Error: declaration expected, not `""`

    /tmp/tmptl3ju9mp.d(17): Error: unterminated string constant starting at /tmp/tmptl3ju9mp.d(17)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptl3ju9mp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   while(search(string, substring))\n    {\n        count += 1;\n        string\
    \ = string[substring.length .. $];\n    }\n    return count;\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprj0vhsbv.d(16): Error: undefined identifier `search`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprj0vhsbv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string.empty ||\
    \ substring.empty) \n    {\n        return 0L;\n    }\n    long result = 0L;\n\
    \    long i = 0L;\n    long slen = string.length;\n    long sublen = substring.length;\n\
    \    while (i < slen) \n    {\n        if (string[i..$] == substring) \n     \
    \   {\n            result += 1L;\n            i += sublen;\n        }\n      \
    \  else \n        {\n            i += 1L;\n        }\n    }\n    return result;\n\
    }\n/*\n Find the position of the first occurrence of a substring in a string.\n\
    \    >>> find_index(\"abcdefg\", \"cd\")\n    2L\n    >>> find_index(\"abcdefg\"\
    , \"cde\")\n    2L\n    >>> find_index(\"abcdefg\", \"c\")\n    2L\n    >>> find_index(\"\
    abcdefg\", \"d\")\n    3L\n    >>> find_index(\"abcdefg\", \"fg\")\n    5L\n \
    \   >>> find_index(\"abcdefg\", \"a\")\n    0L\n    >>> find_index(\"abcdefg\"\
    , \"\")\n    0L\n    >>> find_index(\"abcdefg\", \"g\")\n    6L\n    >>> find_index(\"\
    abcdefg\", \"h\")\n    -1L\n*/\nlong find_index(string string, string substring)\
    \ \n{\n    if (string.empty || substring.empty) \n    {\n        return 0L;\n\
    \    }\n    long i = 0L;\n    long slen = string.length;\n    long sublen = substring.length;\n\
    \    while (i < slen) \n    {\n        if (string[i..$] == substring) \n     \
    \   {\n            return i;\n        }\n        else \n        {\n          \
    \  i += 1L;\n        }\n    }\n    return -1L;\n}\n/*\n Returns a slice of the\
    \ given string starting after the first occurrence of the given pattern.\n   \
    \ >>> skip_prefix(\"abcdefg\", \"cd\")\n    \"efg\"\n    >>> skip_prefix(\"abcdefg\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx0i5mlvt.d(80): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0i5mlvt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long len = string.length;\n\
    \    long sublen = substring.length;\n    long i = 0;\n    long count = 0;\n \
    \   while (i + sublen <= len)\n    {\n        if (substring == string[i..sublen])\n\
    \        {\n            count++;\n        }\n        i++;\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpe5clyf31.d(21): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x427ff6]

    ??:? long tmpe5clyf31.how_many_times(immutable(char)[], immutable(char)[]) [0x427ac7]

    ??:? void tmpe5clyf31.__unittest_L29_C1() [0x427b74]

    ??:? void tmpe5clyf31.__modtest() [0x427cc4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab72]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc89]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430138]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc15]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab49]

    ??:? runModuleUnitTests [0x42ba39]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto n = 0L;\n    auto\
    \ ind = -1L;\n    while ((ind = string.find(substring, ind + 1)) != -1L) \n  \
    \  {\n        n++;\n    }\n    return n;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21n0jwm_.d(17): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21n0jwm_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long occurrences =\
    \ 0;\n    size_t found_at = 0;\n    size_t next_pos = 0;\n    foreach(string;\
    \ find(string, substring, next_pos))\n    {\n        occurrences++;\n        found_at\
    \ = next_pos;\n        next_pos = found_at + 1;\n    }\n    return occurrences;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi2ssu4ar.d(18): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi2ssu4ar.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long count = 0;\n  foreach(int\
    \ start, string str; find(string, substring))\n  {\n    count++;\n  }\n  return\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqk4wn7os.d(16): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqk4wn7os.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nin{\n    assert(string.length\
    \ >= substring.length);\n}\nout(result) {\n    assert(result <= (string.length\
    \ - substring.length + 1));\n}\n{\n    if (substring.length == 0) {\n        return\
    \ 0;\n    }\n    long result = 0;\n    foreach (index; 0 .. string.length - substring.length\
    \ + 1) {\n        if (string[index .. index + substring.length] == substring)\
    \ {\n            result++;\n        }\n    }\n    return result;\n}\n/*\n Find\
    \ the longest palindrome in a given string.\n    >>> longest_palindrome(\"a\"\
    )\n    \"a\"\n    >>> longest_palindrome(\"aba\")\n    \"aba\"\n    >>> longest_palindrome(\"\
    aa\")\n    \"aa\"\n    >>> longest_palindrome(\"baa\")\n    \"aa\"\n    >>> longest_palindrome(\"\
    aab\")\n    \"aa\"\n    >>> longest_palindrome(\"baabcd\")\n    \"baab\"\n   \
    \ >>> longest_palindrome(\"baablkj12345432133d\")\n    \"123454321\"\n*/\nstring\
    \ longest_palindrome(string string) \nin{\n    assert(string.length > 0);\n}\n\
    out(result) {\n    assert(result.length <= string.length);\n}\n{\n    // Note:\
    \ string[i .. j] will return \"\" if i > j.\n    foreach (start; 0 .. string.length)\
    \ {\n        foreach (end; start .. string.length) {\n            string substring\
    \ = string[start .. end];\n            if (is_palindrome(substring)) {\n     \
    \           return substring;\n            }\n        }\n    }\n    // empty string\n\
    \    return \"\";\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n \
    \   assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptr49jnah.d(20): Error: missing `do { ... }` after `in` or `out`

    /tmp/tmptr49jnah.d(56): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptr49jnah.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long counter = 0;\n\
    \    int max_index = string.length - substring.length;\n    for (int i = 0; i\
    \ <= max_index; i++) \n    {\n        if (string[i .. i + substring.length] ==\
    \ substring) \n        {\n            counter++;\n        }\n    }\n    return\
    \ counter;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzo7uh72i.d(16): Error: cannot implicitly convert expression `string.length
    - substring.length` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzo7uh72i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long ret = 0;\n   \
    \ foreach(i; 0 .. string.length - substring.length + 1) \n    {\n        if(string[i\
    \ .. i + substring.length - 1] == substring)\n            ret++;\n    }\n    return\
    \ ret;\n}\n/*\n Test how many times all substrings can be found in a given string.\n\
    \    >>> test_how_many_times_all_substrings(\"aaaa\")\n    true\n*/\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4pnrbxix.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f65]

    ??:? void tmp4pnrbxix.__unittest_L28_C1() [0x427baf]

    ??:? void tmp4pnrbxix.__modtest() [0x427ce4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab92]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430158]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab69]

    ??:? runModuleUnitTests [0x42ba59]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428428]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long pos = 0L;\n  \
    \  long count = 0L;\n    while ((pos = string.find(substring, pos)) != string.npos)\
    \ {\n        count++;\n        pos += substring.length();\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw9k8ayuy.d(17): Error: no property `find` for type `string`

    /tmp/tmpw9k8ayuy.d(17): Error: no property `npos` for type `string`

    /tmp/tmpw9k8ayuy.d(19): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw9k8ayuy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint counter = 0;\n\t\
    int index = 0;\n\t\n\twhile (true)\n\t{\n\t\tindex = string.find(substring, index);\n\
    \t\tif (index != -1)\n\t\t{\n\t\t\tcounter++;\n\t\t\tindex += substring.length;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn counter;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmyna18rl.d(20): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmyna18rl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    size_t start = 0;\n    size_t length = substring.length;\n    while ((start\
    \ = string.find(substring, start)) != string.npos) {\n        ++result;\n    \
    \    start += length;\n    }\n    return result;\n}\n/*\n    >>> k_th_occurrence_of_char_in_string('a',\
    \ 2, \"aaaa\")\n    1L\n    >>> k_th_occurrence_of_char_in_string('a', 1, \"aaaa\"\
    )\n    0L\n    >>> k_th_occurrence_of_char_in_string('a', 4, \"aaaa\")\n    3L\n\
    \    >>> k_th_occurrence_of_char_in_string('a', 1, \"aaba\")\n    0L\n    >>>\
    \ k_th_occurrence_of_char_in_string('a', 2, \"aaba\")\n    2L\n    >>> k_th_occurrence_of_char_in_string('b',\
    \ 1, \"aaba\")\n    3L\n    >>> k_th_occurrence_of_char_in_string('a', 1, \"cbabac\"\
    )\n    3L\n    >>> k_th_occurrence_of_char_in_string('a', 2, \"cbabac\")\n   \
    \ 5L\n*/\nlong k_th_occurrence_of_char_in_string(in char c, in long k, in string\
    \ string) \n{\n    size_t start = 0;\n    size_t length = 1;\n    for (long i\
    \ = 0; i < k; ++i) {\n        start = string.find(c, start + length);\n      \
    \  if (start == string.npos) {\n            return -1;\n        }\n    }\n   \
    \ return start;\n}\n/*\n    >>> words_from_string(\"a string\")\n    [\"a\", \"\
    string\"]\n    >>> words_from_string(\"a string with   spaces\")\n    [\"a\",\
    \ \"string\", \"with\", \"spaces\"]\n    >>> words_from_string(\"   a   string\
    \   with   spaces   \")\n    [\"a\", \"string\", \"with\", \"\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkx7xae2e.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkx7xae2e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong ret = 0;\n\tlong\
    \ j = 0;\n\tfor (long i = 0; i < string.length; ++i)\n\t{\n\t\tif (string[i] ==\
    \ substring[j])\n\t\t{\n\t\t\t++j;\n\t\t\tif (j == substring.length)\n\t\t\t{\n\
    \t\t\t\t++ret;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj = 0;\n\
    \t\t}\n\t}\n\treturn ret;\n}\n/*\n    >>> decode_morse(\".... . -.--   .--- ..-\
    \ -.. .\")\n    \"HEY JUDE\"\n    >>> decode_morse(\"...---...\")\n    \"SOS\"\
    \n    >>> decode_morse(\"   .   . \")\n    \"E E\"\n    >>> decode_morse(\"-.-.--\"\
    )\n    \"!@\"\n*/\nstring decode_morse(string encoded)\n{\n\timport std.algorithm;\n\
    \timport std.array;\n\timport std.range;\n\timport std.typecons;\n\timport std.typecons;\n\
    \timport std.stdio;\n\timport std.conv;\n\t\n\tstring[] morse_alphabet = [\n\t\
    \t\"-----\", \".----\", \"..---\", \"...--\", \"....-\", \".....\",\n\t\t\"-....\"\
    , \"--...\", \"---..\", \"----.\", \".-.-.-\", \"--..--\", \"..--..\",\n\t\t\"\
    .-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\"\
    ,\n\t\t\".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\"\
    , \".-.\",\n\t\t\"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\"\
    , \"--..\", \"|\"\n\t];\n\t\n\tstring[] morse_alphabet_letters = [\n\t\t\"A\"\
    , \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\"\
    , \"M\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpglb46n5q.d(63): Error: non-hex character '')'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''='' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''='' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''L'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character '')'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character '';'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''s'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''s'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''r'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''t'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''('' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''n'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''i'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''t'' in hex string

    /tmp/tmpglb46n5q.d(63): Error: non-hex character ''('' in hex string

    /tmp/tmpglb46n5q.d('
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   size_t start = 0;\n    size_t end = string.find_first_of(substring);\n   \
    \ while (end != -1)\n    {\n        count++;\n        start = end + 1;\n     \
    \   end = string.find_first_of(substring, start);\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphsf_h1o0.d(17): Error: no property `find_first_of` for type `string`

    /tmp/tmphsf_h1o0.d(22): Error: no property `find_first_of` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphsf_h1o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nin {\n    assert(!string.empty);\n\
    \    assert(!substring.empty);\n}\nout (result) {\n    assert(result >= 0);\n\
    }\nbody {\n    long count = 0;\n    for (size_t i = 0; i <= string.length - substring.length;\
    \ i++) {\n        if (string[i .. i + substring.length] == substring) {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp34f0798j.d(15): Error: no property `empty` for type `string`

    /tmp/tmp34f0798j.d(16): Error: no property `empty` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp34f0798j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor\
    \ (auto i = 0; i <= string.length - substring.length; ++i)\n\t{\n\t\tauto string_piece\
    \ = string[i .. i + substring.length];\n\t\tif (string_piece == substring)\n\t\
    \t{\n\t\t\t++count;\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6b8r39ou.d(18): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42800e]

    ??:? long tmp6b8r39ou.how_many_times(immutable(char)[], immutable(char)[]) [0x427ac3]

    ??:? void tmp6b8r39ou.__unittest_L26_C1() [0x427b53]

    ??:? void tmp6b8r39ou.__modtest() [0x427ce0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab8a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430150]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab61]

    ??:? runModuleUnitTests [0x42ba51]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long pos = 0;\n    while ((pos = string.find(substring, pos)) != -1) \n  \
    \  {\n        count++;\n        pos++;\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptfgtkywl.d(17): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptfgtkywl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nnothrow @safe pure \n{\n \
    \   static assert(isInputRange!string);\n    static assert(isInputRange!substring);\n\
    \    if(substring.length < 1) return 0;\n    long counter = 0;\n    size_t start\
    \ = 0;\n    size_t found;\n    while ((found = string.findAt(substring, start))\
    \ != string.length)\n    {\n        counter++;\n        start = found + 1;\n \
    \   }\n    return counter;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptpy4qz_e.d(16): Error: template instance `isInputRange!string`
    template `isInputRange` is not defined

    /tmp/tmptpy4qz_e.d(16):        while evaluating: `static assert(isInputRange!string)`

    /tmp/tmptpy4qz_e.d(17): Error: template instance `isInputRange!substring` template
    `isInputRange` is not defined

    /tmp/tmptpy4qz_e.d(17):        while evaluating: `static assert(isInputRange!substring)`

    /tmp/tmptpy4qz_e.d(22): Error: no property `findAt` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptpy4qz_e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    foreach(immutable i; 0 .. string.length - substring.length + 1) \n    {\n\
    \        auto n = string.canFind(substring, i);\n        if(n) \n        {\n \
    \           result++;\n        }\n    }\n    return result;\n}\n/*\n Find the\
    \ length of a given string without using built-in string functions.\n    >>> length(\"\
    \")\n    0L\n    >>> length(\"abcd\")\n    4L\n    >>> length(\"CamelCase\")\n\
    \    9L\n*/\nlong length(string s) \n{\n    long result = 0;\n    foreach(immutable\
    \ ch; s) \n    {\n        result++;\n    }\n    return result;\n}\n/*\n Find the\
    \ longest common prefix string amongst an array of strings.\n    >>> longest_common_prefix([\"\
    ab\", \"abc\", \"abcd\"])\n    \"ab\"\n    >>> longest_common_prefix([\"a\", \"\
    a\", \"ab\"])\n    \"a\"\n    >>> longest_common_prefix([\"a\", \"a\", \"b\"])\n\
    \    \"\"\n*/\nstring longest_common_prefix(string[] strings) \n{\n    if(strings.length\
    \ == 0) \n    {\n        return \"\";\n    }\n    immutable min_length = min(strings.map!(s\
    \ => s.length));\n    auto result = \"\";\n    foreach(immutable i; 0 .. min_length)\
    \ \n    {\n        if(all!(s => s[i] == strings[0][i])(strings)) \n        {\n\
    \            result ~= strings[0][i];\n        }\n        else \n        {\n \
    \           break;\n        }\n    }\n    return result;\n}\n/*\n Given an array\
    \ of strings, group anagrams together.\n    >>> group_anagrams([\"eat\", \"tea\"\
    , \"tan\", \"ate\", \"nat\", \"bat\"])\n    [[\"eat\", \"tea\", \"ate\"], [\"\
    tan\", \"nat\"], [\"bat\"]]\n*/\nstring[][] group_anagrams(string[] strs) \n{\n\
    \    auto dict = []string[][string\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw83m4bt0.d(81): Error: semicolon expected following auto declaration,
    not `string`

    /tmp/tmpw83m4bt0.d(82): Error: found `unittest` when expecting `,`

    /tmp/tmpw83m4bt0.d(91): Error: found `void` when expecting `,`

    /tmp/tmpw83m4bt0.d(91): Error: found `{` when expecting `,`

    /tmp/tmpw83m4bt0.d(91): Error: expression expected, not `}`

    /tmp/tmpw83m4bt0.d(91): Error: found `End of File` when expecting `,`

    /tmp/tmpw83m4bt0.d(91): Error: found `End of File` when expecting `]`

    /tmp/tmpw83m4bt0.d(91): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpw83m4bt0.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw83m4bt0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    /*\n    if (len(substring)\
    \ == 0)\n    {\n        return 1;\n    }\n    long count = 0;\n    long position\
    \ = 0;\n    while(position + len(substring) <= len(string))\n    {\n        if\
    \ (string[position..] == substring)\n        {\n            count++;\n       \
    \     position += len(substring);\n        }\n        else\n        {\n      \
    \      position++;\n        }\n    }\n    return count;\n    */\n    if (substring.length\
    \ == 0)\n    {\n        return 1;\n    }\n    long count = 0;\n    long position\
    \ = 0;\n    while(position + substring.length <= string.length)\n    {\n     \
    \   if (string.substr(position,substring.length) == substring)\n        {\n  \
    \          count++;\n            position += substring.length;\n        }\n  \
    \      else\n        {\n            position++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n>>> odd_even_number_of_steps(4, 4, (1, 2))\n\"D\"\n>>> odd_even_number_of_steps(3,\
    \ 4, (1, 2))\n\"DR\"\n>>> odd_even_number_of_steps(4, 4, (1, 2, 3))\n\"DRD\"\n\
    >>> odd_even_number_of_steps(2, 2, (1, 2))\n\"DR\"\n>>> odd_even_number_of_steps(6,\
    \ 6, (1, 2, 3))\n\"DRUDL\"\n>>> odd_even_number_of_steps(5, 5, (1, 2, 3))\n\"\
    DRUDL\"\n*/\nstring odd_even_number_of_steps(long n, long m, inout dlong[] coordinates)\n\
    {\n    //long n = n;\n    //long m = m;\n    //dlong[] coordinates = coordinates;\n\
    \    // D : 1,0\n    // R : 0,1\n    // U : -1,0\n    // L : 0,-1\n    //string\
    \ result = \"\";\n    dlong target = dlong(n-1,m-1);\n    string\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpia3qkmku.d(82): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpia3qkmku.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpia3qkmku.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return distance(\n\
    \                find(string, substring),\n                find(string, substring).length\
    \ == substring.length ?\n                        string.length : string.length\
    \ + 1);\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_cgqygbz.d(15): Error: undefined identifier `distance`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_cgqygbz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong result = 0;\n\t\
    long pos = 0;\n\t\n\t// \"\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\
    \u043C \u043F\u0443\u0441\u0442\u044B\u0435 \u0441\u0442\u0440\u043E\u043A\u0438\
    \n\tif (substring.length == 0 || string.length == 0) return 0;\n\t\n\twhile(string.find(substring,\
    \ pos) != -1)\n\t{\n\t\tresult++;\n\t\t// \u0421\u043C\u0435\u0449\u0430\u0435\
    \u043C\u0441\u044F \u043D\u0430 \u0434\u043B\u0438\u043D\u0443 \u043F\u043E\u0434\
    \u0441\u0442\u0440\u043E\u043A\u0438 \u0441\u043E \u0441\u0434\u0432\u0438\u0433\
    \u043E\u043C \u043D\u0430 \u043E\u0434\u0438\u043D \u0441\u0438\u043C\u0432\u043E\
    \u043B\n\t\tpos = string.find(substring, pos) + substring.length;\n\t}\n\t\n\t\
    return result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcre15znv.d(21): Error: no property `find` for type `string`

    /tmp/tmpcre15znv.d(25): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcre15znv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if(substring.length\
    \ > string.length) \n        return 0L;\n    else \n    {\n        long times\
    \ = 0L;\n        for(int i = 0; i < string.length - substring.length + 1; i++)\
    \ \n        {\n            string substr = string[i..i + substring.length];\n\
    \            if(substr == substring) \n                times++;\n        }\n \
    \       return times;\n    }\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbb5z3t_4.d(22): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbb5z3t_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tauto\
    \ pos = 0;\n\twhile (true)\n\t{\n\t\tpos = string.find(substring, pos);\n\t\t\
    if (pos == string.npos) break;\n\t\tcount++;\n\t\tpos++;\n\t}\n\treturn count;\n\
    }\n/*\n    >>> generate_pattern(\"a\")\n    [['a']]\n    >>> generate_pattern(\"\
    ab\")\n    [['a', 'b'], ['b', 'a']]\n    >>> generate_pattern(\"abc\")\n    [['a',\
    \ 'b', 'c'], ['a', 'c', 'b'], ['b', 'a', 'c'], ['b', 'c', 'a'], ['c', 'a', 'b'],\
    \ ['c', 'b', 'a']]\n    >>> generate_pattern(\"abcd\")\n    [['a', 'b', 'c', 'd'],\
    \ ['a', 'b', 'd', 'c'], ['a', 'c', 'b', 'd'], ['a', 'c', 'd', 'b'], ['a', 'd',\
    \ 'b', 'c'], ['a', 'd', 'c', 'b'], ['b', 'a', 'c', 'd'], ['b', 'a', 'd', 'c'],\
    \ ['b', 'c', 'a', 'd'], ['b', 'c', 'd', 'a'], ['b', 'd', 'a', 'c'], ['b', 'd',\
    \ 'c', 'a'], ['c', 'a', 'b', 'd'], ['c', 'a', 'd', 'b'], ['c', 'b', 'a', 'd'],\
    \ ['c', 'b', 'd', 'a'], ['c', 'd', 'a', 'b'], ['c', 'd', 'b', 'a'], ['d', 'a',\
    \ 'b', 'c'], ['d', 'a', 'c', 'b'], ['d', 'b', 'a', 'c'], ['d', 'b', 'c', 'a'],\
    \ ['d', 'c', 'a', 'b'], ['d', 'c', 'b', 'a\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4nmsfco3.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4nmsfco3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count;\n    long\
    \ position;\n    position = string.find(substring);\n    count = 0;\n    while\
    \ (position != -1) \n    {\n        ++count;\n        position = string.find(substring,\
    \ position + 1);\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi4m1pd62.d(17): Error: no property `find` for type `string`

    /tmp/tmpi4m1pd62.d(22): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi4m1pd62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\t//return string.count(substring);\n\
    \tlong count = 0;\n\tlong index = 0;\n\twhile(index < string.length)\n\t{\n\t\t\
    index = string.find(substring, index);\n\t\tif(index == -1) break;\n\t\tindex\
    \ += substring.length;\n\t\tcount++;\n\t}\n\treturn count;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1lquof_i.d(20): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1lquof_i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long result = 0;\n  size_t\
    \ index = 0;\n  //get first occurence of the substring\n  auto firstOccurence\
    \ = string.find(substring);\n  //check if the substring exists\n  if (firstOccurence\
    \ != string.npos) \n  {\n    result++;\n    index = firstOccurence + 1;\n    //while\
    \ next occurence of the substring is found increment result and move the index\n\
    \    while ((firstOccurence = string.find(substring, index)) != string.npos) \n\
    \    {\n      result++;\n      index = firstOccurence + 1;\n    }\n  }\n  return\
    \ result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvup1tmg.d(18): Error: no property `find` for type `string`

    /tmp/tmphvup1tmg.d(20): Error: no property `npos` for type `string`

    /tmp/tmphvup1tmg.d(25): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvup1tmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   while(true)\n    {\n        auto m = indexOf(string, substring);\n       \
    \ if(m == -1)\n            break;\n        count++;\n        string = string[$\
    \ + m + 1 .. $];\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj3bxz09k.d(18): Error: undefined identifier `indexOf`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj3bxz09k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long times = 0;\n \
    \   foreach(immutable(index), immutable(value); string)\n    {\n        if(value\
    \ == substring[0])\n        {\n            immutable found_index = index;\n  \
    \          foreach(immutable(index2), immutable(value2); substring)\n        \
    \    {\n                if(value2 != string[found_index])\n                {\n\
    \                    break;\n                }\n                else\n       \
    \         {\n                    found_index++;\n                }\n         \
    \       if(index2 == substring.length - 1)\n                {\n              \
    \      times++;\n                }\n            }\n        }\n    }\n    return\
    \ times;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ih9ux8s.d(16): Error: no identifier for declarator `immutable(index)`

    /tmp/tmp2ih9ux8s.d(16): Error: no identifier for declarator `immutable(value)`

    /tmp/tmp2ih9ux8s.d(21): Error: no identifier for declarator `immutable(index2)`

    /tmp/tmp2ih9ux8s.d(21): Error: no identifier for declarator `immutable(value2)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ih9ux8s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long counter = 0;\n\
    \    long pos = 0;\n    while(true)\n    {\n        pos = string.find(substring,\
    \ pos);\n        if(pos == -1)\n            break;\n        counter++;\n     \
    \   pos++;\n    }\n    return counter;\n}\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaiwwhmj1.d(19): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaiwwhmj1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    // Version 1\n    /*\n\
    \    long count = 0;\n    long index;\n    if (substring.length == 0)\n      \
    \  return 0;\n    if (string.length < substring.length)\n        return 0;\n \
    \   while (index != -1)\n    {\n        index = string.find(substring);\n    \
    \    if (index != -1)\n        {\n            string = string[index + substring.length\
    \ .. $];\n            count++;\n        }\n    }\n    return count;\n    */\n\
    \    // Version 2\n    long count = 0;\n    if (substring.length == 0)\n     \
    \   return 0;\n    if (string.length < substring.length)\n        return 0;\n\
    \    for (long i = 0; i < string.length - substring.length + 1; i++)\n    {\n\
    \        if (string[i .. i + substring.length] == substring)\n            count++;\n\
    \    }\n    return count;\n}\n/*\n    >>> capitalise_letter(\"a\")\n    'A'\n\
    \    >>> capitalise_letter(\"aB\")\n    'Ab'\n    >>> capitalise_letter(\"abc\"\
    )\n    'Abc'\n*/\nchar capitalise_letter(string string)\n{\n    return toUpper(string[0])\
    \ ~ string[1 .. $];\n}\n/*\n    >>> capitalise_first_letter(\"a\")\n    'A'\n\
    \    >>> capitalise_first_letter(\"aB\")\n    'AB'\n    >>> capitalise_first_letter(\"\
    abc\")\n    'Abc'\n*/\nstring capitalise_first_letter(string string)\n{\n    return\
    \ toUpper(string[0]) ~ string[1 .. $];\n}\n/*\n    >>> capitalise_first_letter_of_each_word(\"\
    a\")\n    'A'\n    >>> capitalise_first_letter_of_each_word(\"a b\")\n    'A B'\n\
    \    >>> capitalise_first_letter_of_each_word(\"a b c\")\n    'A B C'\n    >>>\
    \ capitalise_first_letter_of_each_word(\"a  b  c\")\n    'A  B  C'\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhwk85xl.d(71): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhwk85xl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long counter = 0;\n\
    \    long s = string.length;\n    long t = substring.length;\n    if (s == 0)\
    \ return 0;\n    else if (t == 0) return 0;\n    else if (t > s) return 0;\n \
    \   for (auto i = 0; i <= s - t; i++) \n    {\n        if (string[i .. i + t]\
    \ == substring) counter++;\n    }\n    return counter;\n}\n/*\n Take a string\
    \ and swap the case of each letter.\n    >>> swap_case(\"Hello World\")\n    \"\
    hELLO wORLD\"\n*/\nstring swap_case(string input) \n{\n    string s = \"\";\n\
    \    for (auto c : input) \n    {\n        if (c.isUpperCase) s ~= c.toLower;\n\
    \        else if (c.isLowerCase) s ~= c.toUpper;\n        else s ~= c;\n    }\n\
    \    return s;\n}\n/*\n Take a string and return the case folded string (all lowercase).\n\
    \    >>> casefold(\"Hello World\")\n    \"hello world\"\n*/\nstring casefold(string\
    \ input) \n{\n    string s = \"\";\n    for (auto c : input) s ~= c.toLower;\n\
    \    return s;\n}\n/*\n Take a string and return the string where each character\
    \ is repeated once.\n    >>> repeat_chars(\"Hello World\")\n    \"HHeelllloo \
    \ WWoorrlldd\"\n*/\nstring repeat_chars(string input) \n{\n    string s = \"\"\
    ;\n    for (auto c : input) s ~= c ~ c;\n    return s;\n}\n/*\n Take a string\
    \ and return the string in reverse order.\n    >>> reverse(\"Hello World\")\n\
    \    \"dlroW olleH\"\n*/\nstring reverse(string input) \n{\n    return input.dup.reverse;\n\
    }\n/*\n Take a string and return the string with every word reversed in place.\n\
    \    >>> reverse_words(\"Hello World\")\n    \"olleH dlroW\"\n*/\nstring reverse_words(string\
    \ input) \n{\n    string\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcd1yb4jn.d(35): Error: no identifier for declarator `c`

    /tmp/tmpcd1yb4jn.d(35): Error: expression expected, not `:`

    /tmp/tmpcd1yb4jn.d(35): Error: found `input` when expecting `;` following `for`
    condition

    /tmp/tmpcd1yb4jn.d(51): Error: no identifier for declarator `c`

    /tmp/tmpcd1yb4jn.d(51): Error: expression expected, not `:`

    /tmp/tmpcd1yb4jn.d(51): Error: found `input` when expecting `;` following `for`
    condition

    /tmp/tmpcd1yb4jn.d(62): Error: no identifier for declarator `c`

    /tmp/tmpcd1yb4jn.d(62): Error: expression expected, not `:`

    /tmp/tmpcd1yb4jn.d(62): Error: found `input` when expecting `;` following `for`
    condition

    /tmp/tmpcd1yb4jn.d(82): Error: found `unittest` when expecting `;` following statement

    /tmp/tmpcd1yb4jn.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcd1yb4jn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int counter = 0;\n\
    \    int size_of_substring = substring.length;\n    int size_of_string = string.length;\n\
    \    int iterator = 0;\n    while(iterator < size_of_string) \n    {\n       \
    \ if(string[iterator..iterator+size_of_substring] == substring)\n        {\n \
    \           counter += 1;\n            iterator += size_of_substring;\n      \
    \  }\n        else\n        {\n            iterator += 1;\n        }\n    }\n\
    \    return counter;\n}\n/*\n Given a list of numbers and a positive integer k,\
    \ reverse the elements of the list, k items at a time. If the number of elements\
    \ is not a multiple of k, then the remaining items in the end should be left as\
    \ is.\n    >>> reverse(typeof([]), 0)\n    []\n    >>> reverse([1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10], 1)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> reverse([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [3, 2, 1, 6, 5, 4, 9, 8, 7, 10]\n    >>>\
    \ reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5)\n    [5, 4, 3, 2, 1, 10, 9, 8, 7,\
    \ 6]\n    \n*/\nauto reverse(A)(A list, size_t k) if (isArray!A)\n{\n    bool\
    \ reveresed = false;\n    size_t length = list.length;\n    size_t j = 0;\n  \
    \  if(k == 0)\n    {\n        return list;\n    }\n    for(size_t i = 0; i < length/k;\
    \ i++)\n    {\n        if(!reveresed)\n        {\n            list[i..j+k] = list[j..k].reversed;\n\
    \            j += k;\n            reveresed = true;\n        }\n        else\n\
    \        {\n            list[i..j+k] = list[\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwk8elyqy.d(65): Error: expression expected, not `unittest`

    /tmp/tmpwk8elyqy.d(66): Error: found `{` when expecting `,`

    /tmp/tmpwk8elyqy.d(67): Error: expression expected, not `alias`

    /tmp/tmpwk8elyqy.d(67): Error: found `candidate` when expecting `,`

    /tmp/tmpwk8elyqy.d(67): Error: expression expected, not `=`

    /tmp/tmpwk8elyqy.d(67): Error: found `how_many_times` when expecting `,`

    /tmp/tmpwk8elyqy.d(67): Error: expression expected, not `;`

    /tmp/tmpwk8elyqy.d(69): Error: found `assert` when expecting `,`

    /tmp/tmpwk8elyqy.d(69): Error: found `;` when expecting `,`

    /tmp/tmpwk8elyqy.d(70): Error: found `;` when expecting `,`

    /tmp/tmpwk8elyqy.d(71): Error: found `;` when expecting `,`

    /tmp/tmpwk8elyqy.d(72): Error: found `;` when expecting `,`

    /tmp/tmpwk8elyqy.d(73): Error: expression expected, not `}`

    /tmp/tmpwk8elyqy.d(74): Error: found `void` when expecting `,`

    /tmp/tmpwk8elyqy.d(74): Error: found `{` when expecting `,`

    /tmp/tmpwk8elyqy.d(74): Error: expression expected, not `}`

    /tmp/tmpwk8elyqy.d(74): '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   auto search_pos = string.find(substring);\n    while (search_pos != string.npos)\n\
    \    {\n        ++count;\n        search_pos = string.find(substring, search_pos\
    \ + 1);\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgxcf5v8s.d(16): Error: no property `find` for type `string`

    /tmp/tmpgxcf5v8s.d(17): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgxcf5v8s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t current_pos\
    \ = 0L;\n    size_t found_count = 0L;\n    while (true) \n    {\n        auto\
    \ found_at = string.find(substring, current_pos);\n        if (found_at == string.npos)\
    \ \n        {\n            break;\n        }\n        found_count += 1L;\n   \
    \     current_pos = found_at + 1L;\n    }\n    return found_count;\n}\n/*\n  >>>\
    \ remove_shorter_substrings(\"test\", 1)\n  'test'\n  >>> remove_shorter_substrings(\"\
    test\", 2)\n  'est'\n  >>> remove_shorter_substrings(\"test\", 3)\n  'st'\n  >>>\
    \ remove_shorter_substrings(\"test\", 4)\n  ''\n  >>> remove_shorter_substrings(\"\
    test\", 5)\n  ''\n*/\nstring remove_shorter_substrings(string string, size_t min_length)\
    \ \n{\n    string result = \"\";\n    for (; min_length > 0L; min_length -= 1L)\
    \ \n    {\n        auto substring = string.substr(min_length - 1L, string.length\
    \ - min_length + 1L);\n        result += substring;\n    }\n    return result;\n\
    }\n/*\n    >>> remove_shorter_substrings_naive(\"test\", 1)\n    'test'\n    >>>\
    \ remove_shorter_substrings_naive(\"test\", 2)\n    'est'\n    >>> remove_shorter_substrings_naive(\"\
    test\", 3)\n    'st'\n    >>> remove_shorter_substrings_naive(\"test\", 4)\n \
    \   ''\n    >>> remove_shorter_substrings_naive(\"test\", 5)\n    ''\n*/\nstring\
    \ remove_shorter_substrings_naive(string string, size_t min_length) \n{\n    string\
    \ result = \"\";\n    for (size_t i = 0L; i < string.length; i += 1L) \n    {\n\
    \        for (size_t j = min_length; j <= string.length - i; j += 1L)\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4tu0a9js.d(69): Error: found `unittest` instead of statement

    /tmp/tmp4tu0a9js.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4tu0a9js.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return ctPopCnt(string.find(substring));\n\
    }\n// Compile with -version=ctPopCnt\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb2axjjeb.d(15): Error: undefined identifier `ctPopCnt`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb2axjjeb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint n = 0;\n\tint p =\
    \ 0;\n\tint n_substring = substring.length;\n\tint n_string = string.length;\n\
    \tint j = 0;\n\tif (n_substring == 0)\n\t\treturn 0;\n\twhile (j < n_string)\n\
    \t{\n\t\tint i = 0;\n\t\twhile (i < n_substring && j + i < n_string && string[j\
    \ + i] == substring[i])\n\t\t\ti++;\n\t\tif (i == n_substring)\n\t\t{\n\t\t\t\
    n++;\n\t\t\tj += n_substring;\n\t\t}\n\t\telse\n\t\t\tj++;\n\t}\n\treturn n;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpshlzctds.d(17): Error: cannot implicitly convert expression `substring.length`
    of type `ulong` to `int`

    /tmp/tmpshlzctds.d(18): Error: cannot implicitly convert expression `string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpshlzctds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   auto index = 0;\n    auto size_string = string.length;\n    auto size_substring\
    \ = substring.length;\n    auto temp = 0;\n    foreach(i; 0..string.length)\n\
    \    {\n        if(string[i..i+1] == substring[0..1])\n        {\n           \
    \ temp = i;\n            foreach(j; 0..substring.length)\n            {\n    \
    \            if(string[temp] == substring[j])\n                {\n           \
    \         index++;\n                    temp++;\n                }\n         \
    \       else\n                {\n                    index = 0;\n            \
    \        break;\n                }\n            }\n            if(index == substring.length)\n\
    \            {\n                count++;\n                index = 0;\n       \
    \     }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7gi387l9.d(24): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gi387l9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   string s = string;\n    while (s.length > 0) \n    {\n        if (s.length\
    \ >= substring.length) \n        {\n            if (s.startsWith(substring)) \n\
    \            {\n                count++;\n                s = s[substring.length..$];\n\
    \            } \n            else \n            {\n                s = s[1..$];\n\
    \            }\n        } \n        else \n        {\n            break;\n   \
    \     }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdneso42p.d(16): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdneso42p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long occurrence = 0;\n\
    \    long size = string.length;\n    long size_sub = substring.length;\n    for\
    \ (long i = 0; i < size - size_sub + 1; i++)\n    {\n        if (string[i..i +\
    \ size_sub] == substring)\n        {\n            occurrence++;\n        }\n \
    \   }\n    return occurrence;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long n = string.length;\n\
    \    long m = substring.length;\n    long result = 0;\n    foreach (int i, char\
    \ letter; string)\n    {\n        result += (letter == substring[0]) ? \n    \
    \        (m <= n - i) ?\n                std.algorithm.count(string[i..n-m+1],\
    \ substring)\n            : \n                0\n        :\n            0;\n \
    \   }\n    return result;\n}\n/*\n    >>> how_many_times_overlapping(\"\", \"\
    a\")\n    0L\n    >>> how_many_times_overlapping(\"aaa\", \"a\")\n    3L\n   \
    \ >>> how_many_times_overlapping(\"aaaa\", \"aa\")\n    4L\n*/\nlong how_many_times_overlapping(string\
    \ string, string substring) \n{\n    long n = string.length;\n    long m = substring.length;\n\
    \    long result = 0;\n    foreach (int i, char letter; string)\n    {\n     \
    \   result += (letter == substring[0]) ? \n            (m <= n - i) ?\n      \
    \          std.algorithm.count(string[i..n], substring)\n            : \n    \
    \            0\n        :\n            0;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq3owo7z1.d(22): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpq3owo7z1.d(47): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq3owo7z1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long occur_times =\
    \ 0;\n    for (long i = 0; i < string.length - substring.length + 1; i++)\n  \
    \  {\n        if (string[i .. i + substring.length] == substring)\n        {\n\
    \            occur_times++;\n        }\n    }\n    return occur_times;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long occurences;\n\
    \    // Erase all occurences of \"substring\" from \"string\" until no more occurences\n\
    \    // are found. Keep count of how many times this was done.\n    while ((occurences\
    \ = in(substring, string)) != 0) \n    {\n        string = erase(string, substring);\n\
    \    }\n    return string.length - substring.length + 1;\n}\n//Funktion die alle\
    \ IDs aus einem String extrahiert und in ein Tupel packt.\n//Das Tupel enth\xE4\
    lt als erstes Element die Anzahl der vorkommenden IDS\nauto getIDs(string id_string)\n\
    {\n\tuint anzahl = how_many_times(id_string, \",\");\n\ttuple!(uint, uint[]) result;\n\
    \tresult[0] = anzahl;\n\tstring tmp;\n\tif(anzahl == 0)\n\t{\n\t\tresult[1] =\
    \ tuple(1, [to!uint(id_string)]);\n\t}\n\telse\n\t{\n\t\tresult[1] = tuple(anzahl+1,\
    \ [0]*(anzahl+1));\n\t\tuint j = 0;\n\t\tfor(uint i = 0; i < id_string.length;\
    \ i++)\n\t\t{\n\t\t\tif(id_string[i] != ',')\n\t\t\t{\n\t\t\t\ttmp ~= id_string[i];\n\
    \t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult[1][j] = to!uint(tmp);\n\t\t\t\ttmp\
    \ = \"\";\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tresult[1][j] = to!uint(tmp);\n\t\
    }\n\treturn result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwisa29ck.d(18): Error: expression expected, not `in`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwisa29ck.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t last_pos = 0;\n\
    \    long count = 0;\n    while (true) {\n        auto pos = string.find(substring,\
    \ last_pos);\n        if (pos == string.npos) {\n            break;\n        }\n\
    \        ++count;\n        last_pos = pos + 1;\n    }\n    return count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1imbe0d9.d(18): Error: no property `find` for type `string`

    /tmp/tmp1imbe0d9.d(19): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1imbe0d9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long i = 0;\n    long\
    \ j = 0;\n    long times = 0;\n    while(i<string.length)\n    {\n        if(string[i]\
    \ == substring[j])\n        {\n            j++;\n            if(j == substring.length)\n\
    \            {\n                times++;\n                j = 0;\n           \
    \ }\n        }\n        else\n        {\n            i = i - j;\n            j\
    \ = 0;\n        }\n        i++;\n    }\n    return times;\n}\nunittest\n{\n  \
    \  alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkeijfgc9.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e7d]

    ??:? void tmpkeijfgc9.__unittest_L38_C1() [0x427ba4]

    ??:? void tmpkeijfgc9.__modtest() [0x427bfc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc17]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aaaa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc3d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbc9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa81]

    ??:? runModuleUnitTests [0x42b9ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    auto end = string.length - substring.length;\n    for (long i = 0; i <= end;\
    \ i++)\n    {\n        auto slice = string[i .. i + substring.length];\n     \
    \   if (slice == substring)\n        {\n            result++;\n        }\n   \
    \ }\n    return result;\n}\n \n/*\nPairs:\nWrite a program that reads a string\
    \ and a word. The program should output the count of pairs that have the given\
    \ word as a value.\n    >>> count_pairs(\"a b c b\", \"b\")\n    2L\n*/\nlong\
    \ count_pairs(string input, string word)\n{\n    auto list = input.split;\n  \
    \  return list.count(&(x){x == word});\n}\n \n/*\nReverse a string using slice\
    \ assignment.\n    >>> reverse(\"\")\n    \"\"\n    >>> reverse(\"a\")\n    \"\
    a\"\n    >>> reverse(\"ab\")\n    \"ba\"\n    >>> reverse(\"abc\")\n    \"cba\"\
    \n    >>> reverse(\"abcde\")\n    \"edcba\"\n*/\nstring reverse(string s)\n{\n\
    \    string result;\n    result.length = s.length;\n    auto end = s.length -\
    \ 1;\n    for (long i = 0; i < s.length; i++)\n    {\n        result[i] = s[end\
    \ - i];\n    }\n    return result;\n}\n \n/*\nReverse a string using swap function.\n\
    \    >>> reverse_with_swap(\"\")\n    \"\"\n    >>> reverse_with_swap(\"a\")\n\
    \    \"a\"\n    >>> reverse_with_swap(\"ab\")\n    \"ba\"\n    >>> reverse_with_swap(\"\
    abc\")\n    \"cba\"\n    >>> reverse_with_swap(\"abcde\")\n    \"edcba\"\n*/\n\
    string reverse_with_swap(string s)\n{\n    for (long i = 0; i < s.length / 2;\
    \ i++)\n    {\n        auto temp = s[i];\n        s[i] = s[s.length - 1 - i];\n\
    \        s[s.length -\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51d5ea57.d(37): Error: found `}` when expecting `;` following statement

    /tmp/tmp51d5ea57.d(37): Error: found `)` instead of statement

    /tmp/tmp51d5ea57.d(53): Error: found `string` when expecting `,`

    /tmp/tmp51d5ea57.d(53): Error: found `s` when expecting `,`

    /tmp/tmp51d5ea57.d(54): Error: found `{` when expecting `,`

    /tmp/tmp51d5ea57.d(55): Error: found `result` when expecting `,`

    /tmp/tmp51d5ea57.d(55): Error: expression expected, not `;`

    /tmp/tmp51d5ea57.d(56): Error: found `result` when expecting `,`

    /tmp/tmp51d5ea57.d(56): Error: found `;` when expecting `,`

    /tmp/tmp51d5ea57.d(57): Error: expression expected, not `auto`

    /tmp/tmp51d5ea57.d(57): Error: found `end` when expecting `,`

    /tmp/tmp51d5ea57.d(57): Error: expression expected, not `=`

    /tmp/tmp51d5ea57.d(57): Error: found `s` when expecting `,`

    /tmp/tmp51d5ea57.d(57): Error: found `;` when expecting `,`

    /tmp/tmp51d5ea57.d(58): Error: expression expected, not `for`

    /tmp/tmp51d5ea57.d(58): Error: found `i` when expecting `.` following long

    /tmp/'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    // string.count(substring)\n\
    \    return 42;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n   \
    \ assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0hne9_0_.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmp0hne9_0_.__unittest_L18_C1() [0x427a5d]

    ??:? void tmp0hne9_0_.__modtest() [0x427b38]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   string sub = substring.idup;\n    size_t slen = sub.length;\n    size_t sz\
    \ = string.length;\n    while(string.length >= slen)\n    {\n        size_t find\
    \ = string.find(sub);\n        if(find == string.npos)\n            break;\n \
    \       string = string[find+slen..$];\n        count += 1;\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_dkqofe.d(16): Error: `string` is used as a type

    /tmp/tmpo_dkqofe.d(21): Error: no property `find` for type `string`

    /tmp/tmpo_dkqofe.d(22): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_dkqofe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    foreach(ref e; match(string, substring)) {\n        result++;\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n \
    \   assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsxeid0jb.d(16): Error: undefined identifier `match`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsxeid0jb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (substring.length\
    \ == 0) \n    {\n        return 0;\n    }\n    long count = 0;\n    long i = 0;\n\
    \    while (i < string.length) \n    {\n        auto p = string.find(substring,\
    \ i);\n        if (p == string.npos) \n        {\n            break;\n       \
    \ }\n        count++;\n        i = p + 1;\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzcxbyu_u.d(23): Error: no property `find` for type `string`

    /tmp/tmpzcxbyu_u.d(24): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzcxbyu_u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    enum string_length\
    \ = string.length();\n    enum substring_length = substring.length();\n    enum\
    \ count = (string_length - substring_length + 1);\n    long iterations = 0;\n\
    \    for (size_t i = 0; i < count; i += 1)\n    {\n        if (std.algorithm.startsWith(string[i..],\
    \ substring))\n        {\n            iterations += 1;\n        }\n    }\n   \
    \ return iterations;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpax4it06a.d(21): Error: expression expected, not `]`

    /tmp/tmpax4it06a.d(21): Error: found `)` when expecting `,`

    /tmp/tmpax4it06a.d(21): Error: expression expected, not `)`

    /tmp/tmpax4it06a.d(22): Error: found `{` when expecting `,`

    /tmp/tmpax4it06a.d(23): Error: found `;` when expecting `,`

    /tmp/tmpax4it06a.d(24): Error: expression expected, not `}`

    /tmp/tmpax4it06a.d(25): Error: found `}` when expecting `,`

    /tmp/tmpax4it06a.d(26): Error: expression expected, not `return`

    /tmp/tmpax4it06a.d(26): Error: found `iterations` when expecting `,`

    /tmp/tmpax4it06a.d(26): Error: expression expected, not `;`

    /tmp/tmpax4it06a.d(27): Error: found `}` when expecting `,`

    /tmp/tmpax4it06a.d(28): Error: expression expected, not `unittest`

    /tmp/tmpax4it06a.d(29): Error: found `{` when expecting `,`

    /tmp/tmpax4it06a.d(30): Error: expression expected, not `alias`

    /tmp/tmpax4it06a.d(30): Error: found `candidate` when expecting `,`

    /tmp/tmpax4it06a.d(30): Error: expression expected, not `=`

    /tmp/tmpax4it06a.d(30): Error: '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto n = string.length;\n\
    \    auto m = substring.length;\n    if (n < m) return 0;\n    auto l = n - m\
    \ + 1;\n    return count(0, l, i => string[i .. i + m] == substring);\n}\n/*\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqweil_on.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqweil_on.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong result = 0;\n\t\
    foreach(index, i; findAll(string, substring)) \n\t{\n\t\tresult += i;\n\t}\n\t\
    return result;\n}\n/*\n Transform a string into a number, if possible, the other\
    \ way around too.\n    >>> to_number(\"5\");\n    5L\n    >>> to_number(\"-5\"\
    );\n    -5L\n    >>> to_number(\"-5.0\");\n    -5.0\n    >>> to_number(\"5.0\"\
    );\n    5.0\n    >>> to_number(\"5a\");\n    0L\n*/\nauto to_number(string string)\
    \ \n{\n\tlong result;\n\tif(sscanf(string, \"%d\", &result) == 1)\n\t{\n\t\treturn\
    \ result;\n\t}\n\tdouble result_double;\n\tif(sscanf(string, \"%f\", &result_double)\
    \ == 1)\n\t{\n\t\treturn result_double;\n\t}\n\treturn 0;\n}\nstring to_string(auto\
    \ x) \n{\n\tauto s = to!string(x);\n\treturn s;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzuqmru9u.d(49): Error: undefined identifier `x`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzuqmru9u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result;\n    size_t\
    \ pos = 0;\n    auto it = string.indexOf(substring, pos);\n    while (it != std.string.npos)\
    \ \n    {\n        pos = it + 1;\n        it = string.indexOf(substring, pos);\n\
    \        result++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuj5iha8a.d(17): Error: no property `indexOf` for type `string`

    /tmp/tmpuj5iha8a.d(18): Error: undefined identifier `string` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj5iha8a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return 0;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg20g0ysg.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmpg20g0ysg.__unittest_L17_C1() [0x427a9b]

    ??:? void tmpg20g0ysg.__modtest() [0x427b34]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   foreach(i; 0 .. string.length) \n    {\n        if(string[i .. i + substring.length\
    \ - 1] == substring)\n            count++;\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzzilxtwf.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f5d]

    ??:? void tmpzzilxtwf.__unittest_L23_C1() [0x427ba7]

    ??:? void tmpzzilxtwf.__modtest() [0x427cdc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab8a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430150]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab61]

    ??:? runModuleUnitTests [0x42ba51]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428420]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (substring.length\
    \ == 0)\n        return 0;\n    if (string.length == 0)\n        return 0;\n \
    \   auto result = 0;\n    // auto index = string.indexOf(substring);\n    auto\
    \ index = string.find(substring);\n    if (index == -1)\n        return 0;\n \
    \   result += 1;\n    auto partial_string = string.slice(index + 1);\n    result\
    \ += how_many_times(partial_string, substring);\n    return result;\n}\n/*\n Flatten\
    \ an array recursively.\n    >>> flatten_recursive([[1, [2, 3]], 4])\n    [1,\
    \ 2, 3, 4]\n*/\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmwl7ypbp.d(21): Error: no property `find` for type `string`

    /tmp/tmpmwl7ypbp.d(25): Error: no property `slice` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmwl7ypbp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return (string.count!(substring)\
    \ - string.count!(substring ~ substring)) >> 1;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> find_substrings(\"\", \"a\")\n    []\n    >>> find_substrings(\"aaaa\"\
    , \"aa\")\n    [0, 1, 2]\n    >>> find_substrings(\"aacaaaacaa\", \"aa\")\n  \
    \  [0, 1, 4, 7]\n*/\nauto find_substrings(string haystack, string needle)\n{\n\
    \    return haystack.indices.filter!(i => haystack[i .. i + needle.length] ==\
    \ needle).array;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcwpqfrys.d(15): Error: no property `count` for type `string`

    /tmp/tmpcwpqfrys.d(15): Error: no property `count` for type `string`

    /tmp/tmpcwpqfrys.d(28): Error: no property `indices` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcwpqfrys.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long res = 0;\n   \
    \ auto pos = string.length;\n    while ((pos = string.rfind(substring, pos - 1))\
    \ != -1) \n    {\n        res++;\n    }\n    return res;\n}\nunittest\n{\n   \
    \ alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeccld24k.d(17): Error: no property `rfind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeccld24k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   foreach(int pos; findall(string, substring))\n    {\n        count++;\n  \
    \  }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51wrkh03.d(16): Error: undefined identifier `findall`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51wrkh03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   foreach(i;0..string.length)\n    {\n        if(string[i..$].startsWith(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprn_b8stg.d(18): Error: no property `startsWith` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprn_b8stg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\treturn how_many_times(string,\
    \ substring, 0L);\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n \
    \   assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpctxk5fv0.d(15): Error: function `tmpctxk5fv0.how_many_times(string
    string, string substring)` is not callable using argument types `(string, string,
    long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctxk5fv0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    immutable (long, long)[]\
    \ locs = string.findSubstrings(substring);\n    return locs.length;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5xudfvw9.d(15): Error: found `,` when expecting `)`

    /tmp/tmp5xudfvw9.d(15): Error: no identifier for declarator `immutable(long)`

    /tmp/tmp5xudfvw9.d(15): Error: no identifier for declarator `long`

    /tmp/tmp5xudfvw9.d(15): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xudfvw9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    import std.algorithm;\n\
    \    return count(iota(string.length - substring.length + 1), i => string[i ..\
    \ i + substring.length] == substring);\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Do not count overlaping cases.\n    >>>\
    \ how_many_times_not_overlaping(\"\", \"a\")\n    0L\n    >>> how_many_times_not_overlaping(\"\
    aaa\", \"a\")\n    1L\n    >>> how_many_times_not_overlaping(\"aaaa\", \"aa\"\
    )\n    1L\n    \n*/\nlong how_many_times_not_overlaping(string string, string\
    \ substring) \n{\n    import std.algorithm;\n    return count(iota(string.length\
    \ - substring.length + 1), i => string[i .. i + substring.length] == substring,\
    \ 1);\n}\n/*\n    >>> count_subsequences(\"\", \"a\")\n    0L\n    >>> count_subsequences(\"\
    aaa\", \"a\")\n    3L\n    >>> count_subsequences(\"aa\", \"a\")\n    3L\n   \
    \ >>> count_subsequences(\"aaaa\", \"aa\")\n    6L\n*/\nlong count_subsequences(string\
    \ string, string substring) \n{\n    import std.algorithm;\n    auto indexes =\
    \ map!(iota(string.length - substring.length + 1), i => string[i .. i + substring.length]\
    \ == substring);\n    import std.math;\n    return count(indexes, i => i);\n}\n\
    /*\n    >>> count_subsequences_not_overlaping(\"\", \"a\")\n    0L\n    >>> count_subsequences_not_overlaping(\"\
    aaa\", \"a\")\n    1L\n    >>> count_subsequences_not_overlaping(\"aa\", \"a\"\
    )\n    2L\n    >>> count_subsequences_not_overlaping(\"aaaa\", \"aa\")\n    2L\n\
    */\nlong count_subsequences_not_overlaping(string string, string substring) \n\
    {\n    import std.algorithm\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfalhrdw_.d(63): Error: `;` expected

    /tmp/tmpfalhrdw_.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfalhrdw_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long x = 0;\n    if(string.length\
    \ == 0)\n    {\n        return 0;\n    }\n    else if(substring.length == 0)\n\
    \    {\n        return 0;\n    }\n    else if(string.length < substring.length)\n\
    \    {\n        return 0;\n    }\n    else\n    {\n        for(int i = 0; i <=\
    \ string.length - substring.length; i++)\n        {\n            if(string[i..$]\
    \ == substring)\n            {\n                x += 1;\n            }\n     \
    \   }\n        return x;\n    }\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf1p94r2f.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f7d]

    ??:? void tmpf1p94r2f.__unittest_L40_C1() [0x427bcb]

    ??:? void tmpf1p94r2f.__modtest() [0x427d00]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42abaa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcc1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430170]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab81]

    ??:? runModuleUnitTests [0x42ba71]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428440]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  return how_many_times(string,substring,0L);\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    import std.algorithm;\n    import std.range;\n    return\
    \ count(string.split(substring).front.byOne.skip(start));\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, size_t start) \n{\n \
    \   import std.algorithm;\n    import std.range;\n    return count(string.split(substring).front.byOne.drop(start));\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbd8_dgek.d(31): Error: no property `byOne` for type `string`

    /tmp/tmpbd8_dgek.d(47): Error: no property `byOne` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbd8_dgek.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long howManyTimes = 0;\n\
    \  long stringLength = string.length;\n  long substringLength = substring.length;\n\
    \  for (long i = 0; i < stringLength; i++)\n  {\n    if (i + substringLength <=\
    \ stringLength)\n    {\n      auto compSub = string[i..i + substringLength];\n\
    \      if (compSub == substring) howManyTimes++;\n    }\n  }\n  return howManyTimes;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor\
    \ (size_t i = 0; i < string.length; ++i)\n\t{\n\t\tif (string[i..$] == substring)\n\
    \t\t{\n\t\t\t++count;\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpada2rw5j.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f45]

    ??:? void tmpada2rw5j.__unittest_L25_C1() [0x427b8f]

    ??:? void tmpada2rw5j.__modtest() [0x427cc4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab72]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc89]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430138]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc15]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab49]

    ??:? runModuleUnitTests [0x42ba39]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428408]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    auto pos = string.find(substring);\n    while (pos != string.npos) \n   \
    \ {\n        result++;\n        pos = string.find(substring, pos + 1);\n    }\n\
    \    return result;\n}\n/*\n For example, if we want to calculate the Fibonacci\
    \ number of position 10, we can write a recursive solution:\n    >>> fibonacci(10)\n\
    \    55L\n    >>> fibonacci(35)\n    9227465L\n*/\nlong fibonacci(int n) \n{\n\
    \    return n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n}\n/*\n It is not\
    \ a very efficient solution, but it works.\n    >>> fibonacci_fast(10)\n    55L\n\
    \    >>> fibonacci_fast(35)\n    9227465L\n    >>> fibonacci_fast(170)\n    788657867364790503552363213932185062295135977687173263294742533244359449963403342920304284011984623904177212138919638830257642790242637105061926624952829931113462857270763317237396988943922445621451664240254033291864131227428294853277524242407573903240321257405579568660226031904170324062351700858796178922222789623703897374720000000000000000000000000000000000000000000000000L\n\
    */\nlong fibonacci_fast(int n) \n{\n    long[int] cache;\n    return fibonacci_fast(n,\
    \ cache);\n}\nlong fibonacci_fast(int n, long[int] cache) \n{\n    if (n <= 1)\
    \ \n    {\n        return n;\n    }\n    else if (cache.count(n)) \n    {\n  \
    \      return cache[n];\n    }\n    else \n    {\n        long value = fibonacci_fast(n\
    \ - 1, cache) + fibonacci_fast(n -\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph8byspj.d(62): Error: expression expected, not `unittest`

    /tmp/tmpph8byspj.d(63): Error: found `{` when expecting `,`

    /tmp/tmpph8byspj.d(64): Error: expression expected, not `alias`

    /tmp/tmpph8byspj.d(64): Error: found `candidate` when expecting `,`

    /tmp/tmpph8byspj.d(64): Error: expression expected, not `=`

    /tmp/tmpph8byspj.d(64): Error: found `how_many_times` when expecting `,`

    /tmp/tmpph8byspj.d(64): Error: expression expected, not `;`

    /tmp/tmpph8byspj.d(66): Error: found `assert` when expecting `,`

    /tmp/tmpph8byspj.d(66): Error: found `;` when expecting `,`

    /tmp/tmpph8byspj.d(67): Error: found `;` when expecting `,`

    /tmp/tmpph8byspj.d(68): Error: found `;` when expecting `,`

    /tmp/tmpph8byspj.d(69): Error: found `;` when expecting `,`

    /tmp/tmpph8byspj.d(70): Error: expression expected, not `}`

    /tmp/tmpph8byspj.d(71): Error: found `void` when expecting `,`

    /tmp/tmpph8byspj.d(71): Error: found `{` when expecting `,`

    /tmp/tmpph8byspj.d(71): Error: expression expected, not `}`

    /tmp/tmpph8byspj.d(71): '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    long subLength = substring.length;\n    if (subLength == 0)\n        return\
    \ result;\n    long length = string.length;\n    long maxLen = length - subLength;\n\
    \    foreach (i; 0..maxLen)\n    {\n        if (equal(string[i..i+subLength],\
    \ substring))\n            result++;\n    }\n    return result;\n}\n/*\n    >>>\
    \ has_duplicates([1, 2, 3, 4, 5])\n    false\n    >>> has_duplicates([1, 2, 3,\
    \ 4, 4])\n    true\n*/\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_m9ac3ab.d(23): Error: undefined identifier `equal`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_m9ac3ab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t count = 0;\n\
    \    for (size_t i = 0; i < string.length - substring.length + 1; i++)\n    {\n\
    \        if (string[i .. i + substring.length] == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint n = string.length;\n\
    \tint m = substring.length;\n\tif (m > n) \n\t{\n\t\treturn 0;\n\t}\n\telse if\
    \ (m == n) \n\t{\n\t\treturn string == substring ? 1 : 0;\n\t}\n\telse \n\t{\n\
    \t\t// Substring shorter than string:\n\t\tlong cnt = 0;\n\t\tforeach (i; 0 ..\
    \ n - m + 1) \n\t\t{\n\t\t\tif (string[i .. i + m - 1] == substring) \n\t\t\t\
    {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_we_lkkh.d(15): Error: cannot implicitly convert expression `string.length`
    of type `ulong` to `int`

    /tmp/tmp_we_lkkh.d(16): Error: cannot implicitly convert expression `substring.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_we_lkkh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long sub_len = substring.length;\n    long string_len = string.length;\n \
    \   if (sub_len == 0)\n        return 0;\n    for (long i = 0; i < string_len\
    \ - sub_len + 1; i++)\n    {\n        if (string[i..i + sub_len] == substring)\n\
    \            count++;\n    }\n    return count;\n}\n/*\nFind the maximum and the\
    \ minimum values in a list of integers.\n    >>> find_max_min([0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9])\n    (9, 0)\n*/\nTuple!(long, long) find_max_min(long[] array)\
    \ \n{\n    long max = array[0];\n    long min = array[0];\n    foreach (elem;\
    \ array)\n    {\n        if (elem > max)\n            max = elem;\n        if\
    \ (elem < min)\n            min = elem;\n    }\n    return tuple(max, min);\n\
    }\n/*\nFind the mean value of a list of integers.\n    >>> find_mean([0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9])\n    4.5\n*/\ndouble find_mean(long[] array) \n{\n   \
    \ long sum = 0;\n    foreach (elem; array)\n        sum += elem;\n    return sum\
    \ / array.length;\n}\n/*\nFind the median value of a list of integers.\n    >>>\
    \ find_median([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    4.5\n    >>> find_median([0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    5\n*/\ndouble find_median(long[] array)\
    \ \n{\n    long[] sorted_array = sort(array);\n    long n = sorted_array.length;\n\
    \    if (n % 2 == 0)\n        return (sorted_array[n / 2 - 1] + sorted_array[n\
    \ / 2]) / 2.0;\n   \nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy9fw_ji9.d(71): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy9fw_ji9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    \n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4kdsix7g.d(13): Error: function `tmp4kdsix7g.how_many_times` has
    no `return` statement, but is expected to return a value of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4kdsix7g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long index = 0;\n    while ((index = find(string, substring, index)) != -1)\
    \ \n    {\n        count++;\n        index++;\n    }\n    return count;\n}\n/*\n\
    \    Create a function that takes a string and returns a list with all the positions\
    \ of a given character.\n    >>> get_all_positions(\"abracadabra\", 'a')\n   \
    \ [0L, 2L, 4L, 6L, 8L, 10L]\n    >>> get_all_positions(\"abracadabra\", 'c')\n\
    \    [5L]\n*/\nimmutable(int)[] get_all_positions(string string, char character)\
    \ \n{\n    immutable(int)[] positions = [];\n    foreach (index, char x; string)\
    \ \n    {\n        if (x == character) \n        {\n            positions ~= index;\n\
    \        }\n    }\n    return positions;\n}\n/*\n    Create a function that takes\
    \ a list of strings and returns all strings that start with the letter \"a\".\n\
    \    >>> find_a_words([\"apple\", \"bag\", \"cat\", \"applepie\"])\n    [\"apple\"\
    , \"applepie\"]\n*/\nstring[] find_a_words(string[] strings) \n{\n    string[]\
    \ found = [];\n    foreach (string s; strings) \n    {\n        if (s[0] == 'a')\
    \ \n        {\n            found ~= s;\n        }\n    }\n    return found;\n\
    }\n/*\n    Create a function that takes a list of strings and returns only the\
    \ strings with an even length.\n    >>> get_even_length_strings([\"one\", \"two\"\
    , \"three\", \"four\", \"five\", \"six\"])\n    [\"four\", \"six\"]\n*/\nstring[]\
    \ get_even_length_strings(string[] strings) \n{\n    string[] even_length = [];\n\
    \    foreach (string s; strings) \n    {\n        if (s.length % 2 == 0) \n  \
    \      {\n            even_length ~= s;\n        }\n    }\n    return even_length;\n\
    }\n/*\n    Create a function\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzx0ulz0i.d(77): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzx0ulz0i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long res;\n    if (substring.length\
    \ > string.length)\n        return 0;\n    for (long i = 0; i < string.length;\
    \ i++)\n    {\n        if (string[i..i + substring.length] == substring)\n   \
    \         res++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmprg0tc1vc.d(20): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428006]

    ??:? long tmprg0tc1vc.how_many_times(immutable(char)[], immutable(char)[]) [0x427aca]

    ??:? void tmprg0tc1vc.__unittest_L25_C1() [0x427bce]

    ??:? void tmprg0tc1vc.__modtest() [0x427cd8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab82]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430148]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab59]

    ??:? runModuleUnitTests [0x42ba49]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return(string.countOverlapping(substring));\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppkr8f2pb.d(15): Error: no property `countOverlapping` for type
    `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppkr8f2pb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    string temp;\n    if (string.length < substring.length)\n        return result;\n\
    \    for (int i = 0; i < string.length; i++)\n    {\n        temp = string[i..$];\n\
    \        if (temp.startsWith(substring))\n            result++;\n    }\n    return\
    \ result;\n}\n \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgw24g0ll.d(16): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgw24g0ll.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long int total = 0;\n\
    \    size_t pos = 0;\n    size_t found = 0;\n    long int offset = 0;\n    //TODO:\
    \ refactor this iteration\n    for (; pos < string.length; ++pos)\n    {\n   \
    \     found = string.find(substring, pos);\n        if (found == string.npos)\n\
    \        {\n            break;\n        }\n        pos = found;\n        total\
    \ += 1;\n    }\n    return total;\n}\n \n/*\n    Find the number of positions\
    \ in the original string where a substring of the given size can be found\n  \
    \  >>> number_of_alignments(\"\", 0)\n    0L\n    >>> number_of_alignments(\"\
    aa\", 1)\n    2L\n    >>> number_of_alignments(\"aba\", 1)\n    3L\n    >>> number_of_alignments(\"\
    aba\", 2)\n    2L\n    >>> number_of_alignments(\"abab\", 2)\n    4L\n    >>>\
    \ number_of_alignments(\"abab\", 3)\n    2L\n*/\nlong number_of_alignments(string\
    \ string, size_t substring_size) \n{\n    return string.length - substring_size\
    \ + 1;\n}\n \n/*\nGiven two strings s and t, find all locations where t appears\
    \ as a substring of s.\n    >>> find_all_alignments(\"\", \"\")\n    []\n    >>>\
    \ find_all_alignments(\"\", \"a\")\n    []\n    >>> find_all_alignments(\"a\"\
    , \"\")\n    [0L]\n    >>> find_all_alignments(\"ab\", \"a\")\n    [0L]\n    >>>\
    \ find_all_alignments(\"ab\", \"b\")\n    [1L]\n    >>> find_all_alignments(\"\
    aba\", \"a\")\n    [0L, 2L]\n    >>> find_all_alignments(\"aba\", \"b\")\n   \
    \ [1L]\n    >>> find_all_alignments(\"aba\", \"ab\")\n    [0L]\n    >>> find_all_alignments(\"\
    aba\", \"ba\")\n    [1L]\n    >>> find_all_alignments\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7qxsirf2.d(15): Error: no identifier for declarator `long`

    /tmp/tmp7qxsirf2.d(18): Error: no identifier for declarator `long`

    /tmp/tmp7qxsirf2.d(53): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7qxsirf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n    in (string.length >= substring.length)\n\
    {\n    long count = 0;\n    long position = 0;\n    while ((position = string.find(substring,\
    \ position)) != -1) {\n        count++;\n        position++;\n    }\n    return\
    \ count;\n}\n/*\n Given a string, find the number of pairs of substrings of the\
    \ string that are anagrams of each other.\n    >>> anagram_pairs(\"xyyx\")\n \
    \   2L\n    >>> anagram_pairs(\"xyz\")\n    0L\n    >>> anagram_pairs(\"abba\"\
    )\n    4L\n    >>> anagram_pairs(\"abcd\")\n    0L\n    >>> anagram_pairs(\"ifailuhkqq\"\
    )\n    3L\n    >>> anagram_pairs(\"hucpoltgty\")\n    2L\n    >>> anagram_pairs(\"\
    ovarjsnrbf\")\n    2L\n    >>> anagram_pairs(\"pvmupwjjjf\")\n    6L\n    >>>\
    \ anagram_pairs(\"iwwhrlkpek\")\n    3L\n*/\nlong anagram_pairs(string string)\
    \ \n    in (string.length >= 1) \n    out (result >= 0)\n{\n    long count = 0;\n\
    \    for (long i = 0; i < string.length; i++) {\n        for (long j = i + 1;\
    \ j < string.length; j++) {\n            string a = string[i..j];\n          \
    \  if (i > 0) {\n                a = string[0..i-1] ~ a;\n            }\n    \
    \        if (j < string.length - 1) {\n                a = a ~ string[j+1..$];\n\
    \            }\n            if (a.length % 2 == 0) {\n                string left\
    \ = a[0..a.length/2];\n                string right = a[a.length/2..$];\n    \
    \            long left_count = how_many_times(left, string[i..j]);\n         \
    \       long right_count = how_many_times(right, string[i..j]);\n            \
    \    if (left_count > 0 && right_count > 0) {\n                    count += fact\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxg17k0m0.d(47): Error: found `>=` when expecting `)`

    /tmp/tmpxg17k0m0.d(47): Error: statement expected to be `{ }`, not `0`

    /tmp/tmpxg17k0m0.d(47): Error: found `)` when expecting `;` following statement

    /tmp/tmpxg17k0m0.d(48): Error: missing `do { ... }` after `in` or `out`

    /tmp/tmpxg17k0m0.d(66): Error: found `unittest` when expecting `;` following statement

    /tmp/tmpxg17k0m0.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxg17k0m0.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxg17k0m0.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxg17k0m0.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxg17k0m0.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxg17k0m0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    ulong size = std.typecons.Tuple(substring,\
    \ string).min.length;\n    long count = 0;\n    foreach (u ; 0..string.length\
    \ - size + 1)\n    {\n        if (substring == string[u..u + size])\n        \
    \    count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4dy7ekor.d(15): Error: struct `std.typecons.Tuple` cannot deduce
    function from argument types `!()(string, string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(460):        `std.typecons.Tuple(Specs...)
    if (distinctFieldNames!Specs)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4dy7ekor.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  import std.range;\n \
    \ import std.algorithm;\n  return string.count(substring);\n}\n/*\n Check whether\
    \ a given string is a palindrome.\n    >>> is_palindrome(\"\")\n    true\n   \
    \ >>> is_palindrome(\"a\")\n    true\n    >>> is_palindrome(\"aa\")\n    true\n\
    \    >>> is_palindrome(\"bbb\")\n    true\n    >>> is_palindrome(\"aba\")\n  \
    \  true\n    >>> is_palindrome(\"ab\")\n    false\n*/\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqvsk8gl7.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a1b9]

    ??:? void tmpqvsk8gl7.__unittest_L34_C1() [0x428d54]

    ??:? void tmpqvsk8gl7.__modtest() [0x429bd0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42eb0f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42da1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4322f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4327a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43227d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42d9f5]

    ??:? runModuleUnitTests [0x42e8e5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a6d0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long start = 0L;\n\
    \    long counter = 0L;\n    long n = string.length;\n    long m = substring.length;\n\
    \    while (start < n - m + 1L) \n    {\n        string slice = string[start..start\
    \ + m];\n        if (slice == substring)\n        {\n            counter++;\n\
    \            start += m;\n        }\n        else\n        {\n            start++;\n\
    \        }\n    }\n    return counter;\n}\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0c6sg07b.d(21): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0c6sg07b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n    in(string, substring)\
    \ \n{\n    size_t pos = 0;\n    size_t cnt = 0;\n    size_t size = substring.length;\n\
    \    while(true) {\n        pos = string.find(substring, pos);\n        if(pos\
    \ == string.npos)\n            break;\n        pos += size;\n        cnt++;\n\
    \    }\n    return cnt;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp671lcljj.d(20): Error: no property `find` for type `string`

    /tmp/tmp671lcljj.d(21): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp671lcljj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long stringLength = string.length;\n    long substringLength = substring.length;\n\
    \    foreach(i; 0 .. stringLength - substringLength + 1)\n    {\n        if(string[i\
    \ .. i + substringLength - 1] == substring)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n    >>> edit_distance(\"algorithm\"\
    , \"altruistic\")\n    4L\n    >>> edit_distance(\"\", \"\")\n    0L\n    >>>\
    \ edit_distance(\"\", \"a\")\n    1L\n    >>> edit_distance(\"a\", \"\")\n   \
    \ 1L\n    >>> edit_distance(\"foo\", \"foobar\")\n    3L\n*/\nlong edit_distance(string\
    \ s1, string s2)\n{\n    long m = s1.length;\n    long n = s2.length;\n    long\
    \ dp[][] = new long[m + 1][n + 1];\n    for(long i = 0; i <= m; i++)\n    {\n\
    \        for(long j = 0; j <= n; j++)\n        {\n            if(i == 0)\n   \
    \         {\n                dp[i][j] = j;\n            }\n            else if(j\
    \ == 0)\n            {\n                dp[i][j] = i;\n            }\n       \
    \     else if(s1[i - 1] == s2[j - 1])\n            {\n                dp[i][j]\
    \ = dp[i - 1][j - 1];\n            }\n            else\n            {\n      \
    \          dp[i][j] = 1 + min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1]));\n\
    \            }\n        }\n    }\n    return dp[m][n];\n}\n/*\n      >>> longest_subsequence(\"\
    ABCDAF\", \"ACBCF\")\n      'ABCF'\n      >>> longest_subsequence(\"ACA\", \"\
    ABC\")\n      'AC'\n      >>> longest_subsequence(\"A\", \"B\")\n      ''\n  \
    \    >>> longest_subsequence(\"\", \"\")\n      ''\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphx5amz13.d(43): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] dp`

    /tmp/tmphx5amz13.d(68): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphx5amz13.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tsize_t pos = 0;\n\tlong\
    \ count = 0;\n\twhile ((pos = string.find(substring, pos)) != string.npos) \n\t\
    {\n\t\t++count;\n\t\tpos += substring.length();\n\t}\n\treturn count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4gefdxca.d(17): Error: no property `find` for type `string`

    /tmp/tmp4gefdxca.d(17): Error: no property `npos` for type `string`

    /tmp/tmp4gefdxca.d(20): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4gefdxca.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nin\n{\n    assert(string.length\
    \ >= substring.length);\n}\nout(result)\n{\n    assert(result >= 0L);\n}\n{\n\
    \    long n = string.length - substring.length + 1L;\n    if (n <= 0L) return\
    \ 0L;\n    long result = 0L;\n    for (long index = 0L; index < n; index += 1L)\
    \ \n    {\n        bool is_match = true;\n        for (long i = 0L; i < substring.length;\
    \ i += 1L) \n        {\n            if (string[index + i] != substring[i]) \n\
    \            {\n                is_match = false;\n                break;\n  \
    \          }\n        }\n        if (is_match) result += 1L;\n    }\n    return\
    \ result;\n}\n/*\n Find the nth occurrence of a given substring. Return index.\n\
    \    >>> find_nth_occurrence(\"\", \"a\", 1L)\n    -1L\n    >>> find_nth_occurrence(\"\
    a\", \"a\", 1L)\n    0L\n    >>> find_nth_occurrence(\"aa\", \"a\", 1L)\n    0L\n\
    \    >>> find_nth_occurrence(\"aa\", \"a\", 2L)\n    1L\n    >>> find_nth_occurrence(\"\
    aaaa\", \"aa\", 1L)\n    0L\n    >>> find_nth_occurrence(\"aaaa\", \"aa\", 2L)\n\
    \    1L\n    >>> find_nth_occurrence(\"aaaa\", \"aa\", 3L)\n    2L\n    >>> find_nth_occurrence(\"\
    aaaa\", \"aa\", 4L)\n    -1L\n*/\nlong find_nth_occurrence(string string, string\
    \ substring, long n) \nin\n{\n    assert(string.length >= substring.length);\n\
    \    assert(n >= 1L);\n}\nout(result)\n{\n    assert(result >= -1L);\n}\n{\n \
    \   long index = 0L;\n    long count = 0L;\n    while (index + substring.length\
    \ <= string.length) \n    {\n        bool is_match =\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr_2n5i13.d(22): Error: missing `do { ... }` after `in` or `out`

    /tmp/tmpr_2n5i13.d(70): Error: missing `do { ... }` after `in` or `out`

    /tmp/tmpr_2n5i13.d(76): Error: expression expected, not `unittest`

    /tmp/tmpr_2n5i13.d(77): Error: semicolon expected, not `{`

    /tmp/tmpr_2n5i13.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpr_2n5i13.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_2n5i13.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto length = string.length;\n\
    \    auto subLength = substring.length;\n    long count = 0;\n    while (length\
    \ >= subLength) \n    {\n        if (string[0 .. subLength] == substring)\n  \
    \      {\n            count++;\n            length -= subLength;\n           \
    \ string = string[subLength .. $];\n        }\n        else\n        {\n     \
    \       string = string[1 .. $];\n            length--;\n        }\n    }\n  \
    \  return count;\n}\n/*\n\tReturn pair of strings (left, right) with length \n\
    \tof the first string at least 2, and length of the second \n\tstring at least\
    \ 1, and sum of these two string equal to the \n\tinitial string. If there is\
    \ no string that satisfy that\n\tcondition return None.\n\t    >>> split_in_two(\"\
    \")\n\t    None\n\t    >>> split_in_two(\"ab\")\n\t    tuple(\"a\", \"b\")\n\t\
    \    >>> split_in_two(\"abc\")\n\t    tuple(\"ab\", \"c\")\n\t    >>> split_in_two(\"\
    bba\")\n\t    tuple(\"bb\", \"a\")\n\t    >>> split_in_two(\"bab\")\n\t    tuple(\"\
    ba\", \"b\")\n\t    >>> split_in_two(\"bbab\")\n\t    tuple(\"bba\", \"b\")\n\t\
    \    >>> split_in_two(\"bbbbb\")\n\t    tuple(\"bbbb\", \"b\")\n\t    >>> split_in_two(\"\
    abbbb\")\n\t    tuple(\"abbb\", \"b\")\n\t    >>> split_in_two(\"bbbab\")\n\t\
    \    tuple(\"bbba\", \"b\")\n\t    >>> split_in_two(\"aabbb\")\n\t    tuple(\"\
    aabb\", \"b\")\n\t    >>> split_in_two(\"abbbbb\")\n\t    tuple(\"abbbb\", \"\
    b\")\n\t    >>> split_in_two(\"abbbbbb\")\n\t    tuple(\"abbbbb\", \"b\")\n\t\
    \    >>> split_in_two(\"aaaabb\")\n\t    tuple(\"aaaa\", \"bb\")\n\t    >>> split_in_two(\"\
    aaabb\")\n\t    tuple(\"aaa\", \"bb\")\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpufy9kjmh.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpufy9kjmh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\treturn (long)std.algorithm.count(std.range.iota(string.length).map!((i)\
    \ => string[i..$])\n\t                                                       \
    \         .filter!((s) => s.length >= substring.length)\n\t                  \
    \                                              .filter!((s) => s.startsWith(substring)));\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6k3c6zey.d(17): Error: C style cast illegal, use `cast(long)std.algorithm.count(std.range.iota(string.length).map!((i)
    => string[i..__dollar]).filter!((s) => s.length >= substring.length).filter!((s)
    => s.startsWith(substring)))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6k3c6zey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return size_t(count(string,\
    \ substring));\n}\n/*\nFind if a string can be found in another string.\n    >>>\
    \ is_substr(\"\", \"a\")\n    false\n    >>> is_substr(\"a\", \"\")\n    true\n\
    \    >>> is_substr(\"aaa\", \"a\")\n    true\n    >>> is_substr(\"aaa\", \"aa\"\
    )\n    true\n    >>> is_substr(\"aaa\", \"aaa\")\n    true\n    >>> is_substr(\"\
    aaa\", \"aaaa\")\n    false\n    >>> is_substr(\"abc\", \"a\")\n    true\n   \
    \ >>> is_substr(\"abc\", \"b\")\n    true\n    >>> is_substr(\"abc\", \"c\")\n\
    \    true\n    >>> is_substr(\"abc\", \"ab\")\n    true\n    >>> is_substr(\"\
    abc\", \"bc\")\n    true\n    >>> is_substr(\"abc\", \"abc\")\n    true\n    >>>\
    \ is_substr(\"abc\", \"aa\")\n    false\n    >>> is_substr(\"abc\", \"bb\")\n\
    \    false\n    >>> is_substr(\"abc\", \"cc\")\n    false\n*/\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprozu57l0.d(15): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprozu57l0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long sum = 0;\n   \
    \ size_t i = 0;\n    while(i != string.length)\n    {\n        if(string[i..i+substring.length]\
    \ == substring)\n        {\n            sum++;\n            i += substring.length;\n\
    \        }\n        else\n        {\n            i++;\n        }\n    }\n    return\
    \ sum;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpryrhvpy_.d(19): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428016]

    ??:? long tmpryrhvpy_.how_many_times(immutable(char)[], immutable(char)[]) [0x427ac1]

    ??:? void tmpryrhvpy_.__unittest_L31_C1() [0x427bde]

    ??:? void tmpryrhvpy_.__modtest() [0x427ce8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab92]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430158]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab69]

    ??:? runModuleUnitTests [0x42ba59]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return how_many_times(cast(char[])string,\
    \ cast(char[])substring);\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplss7xh1s.d(15): Error: function `tmplss7xh1s.how_many_times(string
    string, string substring)` is not callable using argument types `(char[], char[])`

    /tmp/tmplss7xh1s.d(15):        cannot pass argument `cast(char[])string` of type
    `char[]` to parameter `string string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplss7xh1s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    foreach(int k; 0 .. string.length) \n    {\n        if(string[k .. $].startsWith(substring))\
    \ \n        {\n            result++;\n        }\n    }\n    return result;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n    long result = 0;\n    foreach(int k; 0 .. string.length) \n    {\n\
    \        if(string[k .. $].startsWith(substring)) \n        {\n            result++;\n\
    \        }\n    }\n    return result;\n}\n/*\n A function named first_name that\
    \ takes in an input string name, returns the first name in that string. The function\
    \ will stop looking for the first name once it finds a space.\n    >>> first_name(\"\
    \")\n    \"\"\n    >>> first_name(\"Python\")\n    \"Python\"\n    >>> first_name(\"\
    Python \")\n    \"Python\"\n    >>> first_name(\"Python 3\")\n    \"Python\"\n\
    \    >>> first_name(\"Your first name is Python\")\n    \"Your\"\n    \n*/\nstring\
    \ first_name(string name) \n{\n    return name.find(\" \") == -1 ? name : name[0\
    \ .. name.find(\" \")];\n}\n/*\n A function named first_name that takes in an\
    \ input string name, returns the first name in that string. The function will\
    \ stop looking for the first name once it finds a space.\n    >>> first_name(\"\
    \")\n    \"\"\n    >>> first_name(\"Python\")\n    \"Python\"\n    >>> first_name(\"\
    Python \")\n    \"Python\"\n    >>> first_name(\"Python 3\")\n    \"Python\"\n\
    \    >>> first_name(\"Your first name is Python\")\n    \"Your\"\n    \n*/\nstring\
    \ first_name(string name) \n\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpta9iub3z.d(81): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpta9iub3z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (substring.length\
    \ == 0)\n        return 0;\n    if (string.length == 0)\n        return 0;\n \
    \   if (string.length < substring.length)\n        return 0;\n    long count =\
    \ 0;\n    int index = 0;\n    while (index < string.length)\n    {\n        int\
    \ index_substr = 0;\n        bool find_substr = true;\n        for (index_substr\
    \ = 0; index_substr < substring.length; index_substr++)\n        {\n         \
    \   if (index + index_substr >= string.length)\n            {\n              \
    \  find_substr = false;\n                break;\n            }\n            if\
    \ (string[index + index_substr] != substring[index_substr])\n            {\n \
    \               find_substr = false;\n                break;\n            }\n\
    \        }\n        if (find_substr)\n        {\n            count++;\n      \
    \      index += index_substr;\n        }\n        else\n        {\n          \
    \  index++;\n        }\n    }\n    return count;\n}\n/*\n Find longest palindrome\
    \ in a given string and return the length.\n    >>> longest_palindrome(\"abbaba\"\
    )\n    5L\n    >>> longest_palindrome(\"cbbd\")\n    2L\n    \n*/\nlong longest_palindrome(string\
    \ input) \n{\n    if (input.length == 0)\n        return 0;\n    if (input.length\
    \ == 1)\n        return 1;\n    long longest = 1;\n    for (int i = 0; i < input.length;\
    \ i++)\n    {\n        for (int j = i + 1; j < input.length; j++)\n        {\n\
    \            bool is_palindrome = true;\n            for (int k = 0; k < (j -\
    \ i + 1) / 2; k++)\n            {\n                if (input[i + k] != input[j\
    \ - k])\n                {\n                    is_palindrome = false;\n     \
    \               break;\n                }\n            }\n            if (is_palindrome)\n\
    \            {\n                longest = max(longest, j - i + 1);\n         \
    \   }\n\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6aqxkd15.d(85): Error: found `unittest` instead of statement

    /tmp/tmp6aqxkd15.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp6aqxkd15.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6aqxkd15.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n    if (is(typeof(strstr(string,\
    \ substring)))) {\n    long count = 0;\n    long pos = 0;\n    while ((pos = strstr(string,\
    \ substring, pos)) != -1) {\n        ++count;\n        ++pos;\n    }\n    return\
    \ count;\n} else {\n    assert(0);\n}\n/*\n \n \n \n*/\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp__e40d45.d(14): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmp__e40d45.d(14): Error: declaration expected, not `if`

    /tmp/tmp__e40d45.d(17): Error: declaration expected, not `while`

    /tmp/tmp__e40d45.d(19): Error: declaration expected, not `++`

    /tmp/tmp__e40d45.d(20): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp__e40d45.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int result = 0;\n \
    \   if (substring.length == 0)\n        return result;\n    size_t pos = string.indexOf(substring);\n\
    \    while (pos != string.npos)\n    {\n        result++;\n        pos = string.indexOf(substring,\
    \ pos + 1);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx6wkp_7v.d(18): Error: no property `indexOf` for type `string`

    /tmp/tmpx6wkp_7v.d(19): Error: no property `npos` for type `string`

    /tmp/tmpx6wkp_7v.d(22): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx6wkp_7v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long times = 0;\n \
    \   for (size_t i = 0; i < string.length - substring.length + 1; i++) \n    {\n\
    \        if (string[i .. i + substring.length] == substring) \n        {\n   \
    \         times++;\n        }\n    }\n    return times;\n}\n// count all pairs\
    \ from vector of pairs\nlong count_all_pairs(T...)(T vector_of_pairs) \n{\n  \
    \  long res = 0;\n    foreach (pair; vector_of_pairs) \n    {\n        res +=\
    \ pair[1];\n    }\n    return res;\n}\n/*\n Find how many time each substring\
    \ can be found in the original string.\n    >>> find_substring_frequencies(\"\"\
    , [\"a\"])\n    [\"a\": 0L]\n    >>> find_substring_frequencies(\"aaa\", [\"a\"\
    , \"aa\"])\n    [\"a\": 3L, \"aa\": 1L]\n    >>> find_substring_frequencies(\"\
    aaaa\", [\"aa\", \"aaa\"])\n    [\"aa\": 3L, \"aaa\": 2L]\n*/\nTuple!(string,\
    \ long)[string] find_substring_frequencies(string string, string[] substring_vector)\
    \ \n{\n    auto res = (Tuple!(string, long)[string])null;\n    foreach (substring;\
    \ substring_vector) \n    {\n        if (how_many_times(string, substring) !=\
    \ 0) \n        {\n            res[substring] = how_many_times(string, substring);\n\
    \        }\n    }\n    return res;\n}\n/*\n Return permutations of a given vector\n\
    \    >>> permutations([])\n    [[]]\n    >>> permutations([1])\n    [[1]]\n  \
    \  >>> permutations([1, 2])\n    [[1, 2], [2, 1]]\n    >>> permutations([1, 2,\
    \ 3])\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\
    */\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsvpbs_z7.d(46): Error: C style cast illegal, use `cast(Tuple!(string,
    long)[string])null`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsvpbs_z7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n    in(substring) //substring\
    \ can be longer than string\n{\n    long count = 0;\n    long index = 0;\n   \
    \ while(true)\n    {\n        index = string.find(substring, index);\n       \
    \ if(index == string.npos) break;\n        count++;\n        index++;\n    }\n\
    \    return count;\n}\n/*\n Find the longest substring of given string that can\
    \ be built from the concatenation of two other ones, each appearing at least once.\n\
    \    >>> find_substring(\"abcdxyz\")\n    [\"z\"]\n    >>> find_substring(\"xyzabcd\"\
    )\n    [\"xyz\", \"zab\", \"abcd\"]\n    >>> find_substring(\"aabcdxyz\")\n  \
    \  [\"abcd\", \"cdxy\", \"dxyz\"]\n    >>> find_substring(\"aabcdxyza\")\n   \
    \ [\"abcdxyz\", \"bcdxyza\"]\n    >>> find_substring(\"aabcdxyzaa\")\n    [\"\
    abcdxyzaa\", \"bcdxyzaa\"]\n    >>> find_substring(\"aabcdxyzaaa\")\n    [\"abcdxyzaaa\"\
    , \"bcdxyzaaa\"]\n    >>> find_substring(\"abbcdxyzaa\")\n    [\"bbcdxyz\", \"\
    bcdxyza\", \"cdxyzaa\"]\n    >>> find_substring(\"abc\")\n    [\"bc\"]\n    >>>\
    \ find_substring(\"aaaaaa\")\n    [\"aaaaaa\"]\n    >>> find_substring(\"a\")\n\
    \    []\n    >>> find_substring(\"\")\n    []\n*/\ndstring[] find_substring(string\
    \ string)\n{\n    if(string.empty) return dstring[].init;\n    dstring result;\n\
    \    dstring temp;\n    foreach(i, l; string)\n    {\n        temp = string[i..$];\n\
    \        foreach(j, l; temp)\n        {\n            if(how_many_times(temp, temp[0..j])\
    \ >= 2)\n            {\n                if(result.length < temp[0..j].length)\n\
    \                {\n                    result = temp[0..j];\n               \
    \ }\n            }\n       \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx9vp74e4.d(70): Error: found `unittest` instead of statement

    /tmp/tmpx9vp74e4.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpx9vp74e4.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx9vp74e4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    //return count(string.rfind(substring),\
    \ string.length, substring.length);\n    long count = 0;\n    long index = 0;\n\
    \    while(index < string.length)\n    {\n        auto pos = string.find(substring,\
    \ index);\n        if(pos == -1)\n            break;\n        index = pos + substring.length;\n\
    \        count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph772zqtn.d(20): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph772zqtn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long how_many = 0;\n\
    \    size_t offset = 0;\n    while (true)\n    {\n        size_t cur_pos = string.find(substring,\
    \ offset);\n        if (cur_pos == string.npos) \n            break;\n       \
    \ else\n        {\n            how_many++;\n            offset = cur_pos + 1;\n\
    \        }\n    }\n    return how_many;\n}\n/*\n Given a list and a number, find\
    \ if the number is present in the list and the number of times.\n    >>> how_many_times([1,\
    \ 2, 2, 3, 2, 3, 2, 3, 2, 1], 2)\n    5L\n    >>> how_many_times([1, 2, 2, 3,\
    \ 2, 3, 2, 3, 2, 1], 3)\n    3L\n    >>> how_many_times([1, 2, 2, 3, 2, 3, 2,\
    \ 3, 2, 1], 1)\n    2L\n    >>> how_many_times([1, 2, 2, 3, 2, 3, 2, 3, 2, 1],\
    \ 0)\n    0L\n    >>> how_many_times([1, 2, 2, 3, 2, 3, 2, 3, 2, 1], 20)\n   \
    \ 0L\n*/\nlong how_many_times(long[] numbers, long number) \n{\n    long how_many\
    \ = 0;\n    foreach (n; numbers) \n    {\n        if (n == number) \n        \
    \    how_many++;\n    }\n    return how_many;\n}\n/*\n Given a list of lists and\
    \ a number, find if the number is present in any list of the list and the number\
    \ of times.\n    >>> how_many_times([[1, 2, 2, 3, 2, 3, 2, 3, 2, 1], [1, 2, 3,\
    \ 4]], 2)\n    5L\n    >>> how_many_times([[1, 2, 2, 3, 2, 3, 2, 3, 2, 1], [1,\
    \ 2, 3, 4]], 3)\n    3L\n    >>> how_many_times([[1, 2, 2, 3, 2\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpak_419hx.d(53): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpak_419hx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    size_t index = 0;\n    while (index <= string.length - substring.length)\
    \ \n    {\n        index = string.find(substring, index);\n        if (index ==\
    \ string.npos) \n        {\n            break;\n        }\n        result++;\n\
    \        index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm4w5mah8.d(19): Error: no property `find` for type `string`

    /tmp/tmpm4w5mah8.d(20): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm4w5mah8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\t\n\tlong num = 0;\n\t\
    long count = 0;\n\tforeach(i; 0 .. string.length) \n\t{\n\t\tif(string[i..i+substring.length-1]\
    \ == substring)\n\t\t{\n\t\t\t++num;\n\t\t\t++count;\n\t\t\ti = i + substring.length\
    \ - 1;\n\t\t}\n\t}\n\treturn num;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7yyn5r16.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f75]

    ??:? void tmp7yyn5r16.__unittest_L29_C1() [0x427bbf]

    ??:? void tmp7yyn5r16.__modtest() [0x427cf4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aba2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430168]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab79]

    ??:? runModuleUnitTests [0x42ba69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428438]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164106
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    foreach(size_t i; 0 .. string.length)\n    {\n        if(i+substring.length\
    \ <= string.length)\n        {\n            if(string[i .. i+substring.length]\
    \ == substring)\n            {\n                result += 1;\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    // TODO: your code\
    \ here\n    return 0L;\n}\n/*\n Count how many times there is a space in the string.\
    \ Count only spaces, not tabs.\n    >>> count_spaces(\"a\\tb\")\n    0L\n    >>>\
    \ count_spaces(\"a b\")\n    1L\n    >>> count_spaces(\"  a  b\")\n    3L\n  \
    \  >>> count_spaces(\" a\")\n    1L\n    >>> count_spaces(\"a \")\n    1L\n*/\n\
    long count_spaces(string string) \n{\n    // TODO: your code here\n    return\
    \ 0L;\n}\n/*\n Get first matching substring.\n    >>> get_first_matching_substring(\"\
    abcabcabc\", \"c\")\n    \"c\"\n    >>> get_first_matching_substring(\"abcabcabc\"\
    , \"d\")\n    \"\"\n    >>> get_first_matching_substring(\"abcabcabc\", \"c\"\
    , 1)\n    \"c\"\n    >>> get_first_matching_substring(\"abcabcabc\", \"c\", 2)\n\
    \    \"c\"\n    >>> get_first_matching_substring(\"abcabcabc\", \"c\", 3)\n  \
    \  \"\"\n    >>> get_first_matching_substring(\"abcabcabc\", \"c\", 5)\n    \"\
    \"\n*/\nstring get_first_matching_substring(string string, string substring, size_t\
    \ min_start_offset = 0) \n{\n    // TODO: your code here\n    return \"\";\n}\n\
    /*\n Get the number of occurences of substring in string\n    >>> count_occurences(\"\
    aabaabaa\", \"a\")\n    6L\n    >>> count_occurences(\"aabaabaa\", \"b\")\n  \
    \  2L\n    >>> count_occurences(\"abababab\", \"a\")\n    4L\n    >>> count_occurences(\"\
    abababab\", \"b\")\n    4L\n    >>> count_occurences(\"\", \"a\")\n    0L\n  \
    \  >>> count_occurences(\"aabaabaa\", \"\")\n    0L\n*/\nlong count_occurences(string\
    \ string,\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    /*\n    long k=0;\n\
    \    if(substring.length<=0)\n        return k;\n    for(int i=0;i<string.length;i++)\n\
    \    {\n        if(string[i]==substring[0])\n        {\n            int j;\n \
    \           for(j=0;j<substring.length;j++)\n            {\n                if(string[i+j]!=substring[j])\n\
    \                    break;\n            }\n            if(j==substring.length)\n\
    \            {\n                k++;\n                i+=j-1;\n            }\n\
    \        }\n    }\n    return k;\n    */\n    return count!(string.count(substring)).count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1tezndl_.d(38): Error: template instance `count!(string.count(substring))`
    template `count` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1tezndl_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long counter = 0;\n\
    \    string temp = string;\n    while(temp.indexOf(substring) != -1)\n    {\n\
    \        counter++;\n        temp = temp.substring(temp.indexOf(substring) + 1);\n\
    \    }\n    return counter;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaofven9b.d(16): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaofven9b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint m = string.length;\n\
    \tint n = substring.length;\n\tlong count = 0;\n\tlong i = 0;\n\tlong k = 0;\n\
    \tfor (i = 0; i <= (m - n); i++) {\n\t\tfor (k = 0; k < n; k++) {\n\t\t\tif (string[i\
    \ + k] != substring[k]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (k == n) {\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp70dcsvud.d(15): Error: cannot implicitly convert expression `string.length`
    of type `ulong` to `int`

    /tmp/tmp70dcsvud.d(16): Error: cannot implicitly convert expression `substring.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp70dcsvud.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string.empty ||\
    \ substring.empty) \n    {\n        return 0L;\n    }\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphi_2nx_r.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphi_2nx_r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\treturn split(string,\
    \ substring).length - 1;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfmyz8go.d(15): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfmyz8go.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long i = 0;\n    while(true) \n    {\n        auto pos = string.find(substring,\
    \ i);\n        if(pos < 0)\n            break;\n        count++;\n        i =\
    \ pos + 1;\n    }\n    return count;\n}\n \n/*\n Find how many times the second\
    \ string can be found in the first string using the KMP algorithm.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n*/\nlong how_many_times2(string string, string substring)\
    \ \n{\n    auto prefix = kmpPrefix(substring);\n    long count = 0;\n    long\
    \ j = 0;\n    foreach(long i, char c; string) \n    {\n        while(j > 0 &&\
    \ substring[j] != c)\n            j = prefix[j - 1];\n        if(substring[j]\
    \ == c)\n            j++;\n        if(j == substring.length) \n        {\n   \
    \         count++;\n            j = prefix[j - 1];\n        }\n    }\n    return\
    \ count;\n}\n/*\n Generate the KMP prefix function for a given string.\n    >>>\
    \ kmpPrefix(\"abcdabd\")\n    [0L, 0L, 0L, 0L, 1L, 2L, 0L]\n*/\nlong[] kmpPrefix(string\
    \ s) \n{\n    long[] prefix = new long[s.length];\n    long j = 0;\n    foreach(long\
    \ i, char c; s) \n    {\n        while(j > 0 && s[j] != c)\n            j = prefix[j\
    \ - 1];\n        if(s[j] == c)\n            j++;\n        prefix[i] = j;\n   \
    \ }\n    return prefix;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ibb1wn.d(19): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ibb1wn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long index = 0;\n \
    \   long cnt = 0;\n    while(true) \n    {\n        index = string.find(substring,\
    \ index);\n        if(index == string.npos) break;\n        index += 1;\n    \
    \    cnt += 1;\n    }\n    return cnt;\n}\nlong[] get_indices(string string, string\
    \ substring)\n{\n    long index = 0;\n    long[] indices = null;\n    while(true)\
    \ \n    {\n        index = string.find(substring, index);\n        if(index ==\
    \ string.npos) break;\n        indices ~= index;\n        index += 1;\n    }\n\
    \    return indices;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppmd3m2ya.d(19): Error: no property `find` for type `string`

    /tmp/tmppmd3m2ya.d(20): Error: no property `npos` for type `string`

    /tmp/tmppmd3m2ya.d(32): Error: no property `find` for type `string`

    /tmp/tmppmd3m2ya.d(33): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppmd3m2ya.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (size_t index = 0; index < string.length; index++) \n    {\n        if\
    \ (string[index .. index + substring.length] == substring) \n        {\n     \
    \       count++;\n        }\n    }\n    return count;\n}\n/*\n Write a program\
    \ which uses a while loop to find the largest integer n such that n3 is less than\
    \ 12,000.\n    >>> cube_smaller_than_12000()\n    22L\n*/\nlong cube_smaller_than_12000()\
    \ \n{\n    long number = 1;\n    while (pow(number, 3) < 12000) \n    {\n    \
    \    number++;\n    }\n    return number - 1;\n}\n/*\n Prompt the user to enter\
    \ a positive integer. What happens when you enter a negative number?\n*/\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpzku8dpn7.d(18): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42815e]

    ??:? long tmpzku8dpn7.how_many_times(immutable(char)[], immutable(char)[]) [0x427b4d]

    ??:? void tmpzku8dpn7.__unittest_L42_C1() [0x427c8e]

    ??:? void tmpzku8dpn7.__modtest() [0x427e30]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bdcb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acda]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fdf1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4302a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd7d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42acb1]

    ??:? runModuleUnitTests [0x42bba1]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto count = 0L;\n\
    \    auto index = 0L;\n    auto temp_index = 0L;\n    while (index < string.length)\n\
    \    {\n        temp_index = string.find(substring, index);\n        if (temp_index\
    \ < 0)\n            break;\n        else\n        {\n            count += 1;\n\
    \            index = temp_index + 1;\n        }\n    }\n    return count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqpmnfqw.d(20): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqpmnfqw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return how_many_times(string,\
    \ substring);\n}\n/*\n Given two strings, write a function that returns true if\
    \ one string is one edit away from the other.\n    >>> one_away(\"abc\", \"abc\"\
    )\n    true\n    >>> one_away(\"abc\", \"abcd\")\n    true\n    >>> one_away(\"\
    ab\", \"abc\")\n    true\n    >>> one_away(\"abcde\", \"ab\")\n    false\n   \
    \ >>> one_away(\"ab\", \"abcd\")\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164122
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    long length = string.length;\n    long sublength = substring.length;\n  \
    \  long last_step = length - sublength;\n    if(sublength == 0) return 0;\n  \
    \  foreach(i; 0 .. last_step + 1)\n    {\n        if(string[i .. i + sublength\
    \ - 1] == substring)\n        {\n            result++;\n        }\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdytv9pne.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f75]

    ??:? void tmpdytv9pne.__unittest_L29_C1() [0x427bc3]

    ??:? void tmpdytv9pne.__modtest() [0x427cf8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aba2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430168]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab79]

    ??:? runModuleUnitTests [0x42ba69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428438]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\treturn (string.length\
    \ - string.replace(substring, \"\").length) / substring.length;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring) \n{\n\tlong result =\
    \ 0;\n\tforeach(i; 0 .. string.length - substring.length + 1)\n\t{\n\t\tif(string[i\
    \ .. i + substring.length - 1] == substring)\n\t\t{\n\t\t\tresult += 1;\n\t\t\
    }\n\t}\n\treturn result;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n\tlong result = 0;\n\tlong index = 0;\n\twhile(index < string.length)\n\
    \t{\n\t\tlong index_found = string.indexOf(substring, index);\n\t\tif(index_found\
    \ != -1)\n\t\t{\n\t\t\tresult += 1;\n\t\t\tindex = index_found + 1;\n\t\t}\n\t\
    \telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return a new\
    \ string with all the repetitions of a given substring replaced by the given text.\n\
    \    >>> replace_repetitions(\"ababababa\", \"ab\", \"x\")\n    \"xxxa\"\n   \
    \ >>> replace_repetitions(\"a\", \"a\", \"x\")\n    \"x\"\n    >>> replace_repetitions(\"\
    \", \"\", \"x\")\n    \"\"\n    >>> replace_\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3acbq2pq.d(68): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3acbq2pq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    auto range = string.length;\n    while (true) \n    {\n        auto current\
    \ = string.indexOf(substring, 0, range);\n        if (current == string.length)\n\
    \            break;\n        result++;\n        range = current + 1;\n    }\n\
    \    return result;\n}\n/*\n Find all indexes of a given substring in the original\
    \ string. Count overlaping cases.\n    >>> find_all_indexes(\"\", \"a\")\n   \
    \ []\n    >>> find_all_indexes(\"aaa\", \"a\")\n    [0L, 1L, 2L]\n    >>> find_all_indexes(\"\
    aaaa\", \"aa\")\n    [0L, 1L, 2L]\n*/\nTuple!(long[], long[]) find_all_indexes(string\
    \ string, string substring)\n{\n    long[] result;\n    long[] lenghts;\n    auto\
    \ range = string.length;\n    while (true) \n    {\n        auto current = string.indexOf(substring,\
    \ 0, range);\n        if (current == string.length)\n            break;\n    \
    \    result ~= current;\n        lenghts ~= substring.length;\n        range =\
    \ current + 1;\n    }\n    return tuple(result, lenghts);\n}\nunittest\n{\n  \
    \  alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfqsw07xu.d(19): Error: no property `indexOf` for type `string`

    /tmp/tmpfqsw07xu.d(43): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfqsw07xu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto result = 0L;\n\
    \    auto sub_length = substring.length;\n    for (auto i = 0; i <= string.length\
    \ - sub_length; i++)\n    {\n        if (string[i .. i + sub_length] == substring)\n\
    \        {\n            result++;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpg32jfi9a.d(19): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428006]

    ??:? long tmpg32jfi9a.how_many_times(immutable(char)[], immutable(char)[]) [0x427ac7]

    ??:? void tmpg32jfi9a.__unittest_L26_C1() [0x427b47]

    ??:? void tmpg32jfi9a.__modtest() [0x427cd4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab82]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430148]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab59]

    ??:? runModuleUnitTests [0x42ba49]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    ulong long how_many\
    \ = 0;\n    foreach(index, string_index; iterate(string)) \n    {\n        if(compare(string[index\
    \ .. $], substring) == 0)\n        {\n            how_many++;\n        }\n   \
    \ }\n    return how_many;\n}\n/*\n    Find all the possible ways the slots can\
    \ be filled.\n    >>> run_permutations(\"\", \"\")\n    []\n    >>> run_permutations(\"\
    a\", \"aaa\")\n    [\"aaa\"]\n    >>> run_permutations(\"abc\", \"abc\")\n   \
    \ [\"abc\"]\n    >>> run_permutations(\"ab\", \"aabb\")\n    [\"aabb\", \"abba\"\
    ]\n    >>> run_permutations(\"aa\", \"aabb\")\n    [\"aabb\", \"abba\"]\n    >>>\
    \ run_permutations(\"aab\", \"aabb\")\n    [\"aabb\", \"abba\"]\n    >>> run_permutations(\"\
    abab\", \"aabb\")\n    [\"aabb\", \"abba\"]\n    >>> run_permutations(\"aba\"\
    , \"aabb\")\n    [\"aabb\", \"abba\"]\n    >>> run_permutations(\"abb\", \"aabb\"\
    )\n    [\"aabb\", \"abba\"]\n*/\nstring[] run_permutations(string pattern, string\
    \ string) \n{\n    import std.algorithm;\n    import std.stdio;\n    import std.range;\n\
    \    if(compare(pattern, string) == 0) \n    {\n        return [string];\n   \
    \ }\n    string[] permutations = [];\n    int permutation_size = pattern.length;\n\
    \    int index = 0;\n    while(index < string.length) \n    {\n        string\
    \ permutation = string[index .. index + permutation_size];\n        permutations\
    \ ~= permutation;\n        index += permutation_size;\n    }\n    return permutations;\n\
    }\n/*\n    Find all the possible ways the slots can be filled.\n    >>> run_word_permutations(\"\
    \", \"\")\n    []\n    >>> run_word_permutations(\"a\", \"aaa\")\n    [\"aaa\"\
    ]\n    >>> run_word_permutations(\"abc\", \"abc\")\n    [\"abc\"]\n    >>> run\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa5nvrff1.d(15): Error: no identifier for declarator `ulong`

    /tmp/tmpa5nvrff1.d(66): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa5nvrff1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long res = 0;\n   \
    \ long index = 0;\n    int len = substring.length;\n    while ((index = string.find(substring,\
    \ index)) != -1) \n    {\n        res++;\n        index++;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxkt5asj6.d(17): Error: cannot implicitly convert expression `substring.length`
    of type `ulong` to `int`

    /tmp/tmpxkt5asj6.d(18): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxkt5asj6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    // 1. find all occurences\
    \ in string and count.\n    long count = 0;\n    for (size_t i = 0; i < string.length;\
    \ ++i)\n    {\n        if (string[i .. i + substring.length] == substring)\n \
    \       {\n            ++count;\n        }\n    }\n    return count;\n}\n/*\n\
    \    You are given a string consisting of only the characters 'R', 'G', and 'B'.\n\
    \    Write a function which returns a string containing all of the possible two-character\
    \ \n    combinations of the original string, in alphabetical order.\n    >>> two_character_combinations(\"\
    RB\")\n    [\"BR\", \"GB\", \"GR\"]\n    >>> two_character_combinations(\"RRGGBB\"\
    )\n    [\"BBGG\", \"BBGR\", \"BBRG\", \"BGBG\", \"BGBR\", \"BGRG\", \"BRBG\",\
    \ \"BRGR\", \"GBBG\", \"GBBR\", \"GBRG\", \"GBRR\", \"GRBG\", \"GRBR\", \"GRGB\"\
    , \"GRGR\", \"RBGG\", \"RBGR\", \"RBRG\", \"RGBG\", \"RGBR\", \"RGRG\", \"RRBG\"\
    , \"RRBR\", \"RRGB\", \"RRGR\"]\n    >>> two_character_combinations(\"\")\n  \
    \  []\n    >>> two_character_combinations(\"B\")\n    []\n*/\nstring[] two_character_combinations(string\
    \ string)\n{\n    // 1. generate all possible combinations of two-character combinations\
    \ of the original string, in alphabetical order.\n    // use distinct array to\
    \ remove duplicates.\n    static string[] gen_combinations(size_t size, string\
    \ string)\n    {\n        static int[] gen_indexes(size_t size, size_t string_size)\n\
    \        {\n            return size < 1 ? typeof(return).init : \n           \
    \     filter!(idx => idx < string_size)(chain(iota(0, string_size), 0, gen_indexes(size\
    \ - 1, string_size)));\n        }\n        return map!(chrs => iota(0, chrs.length).map!(idx\
    \ => string[chrs[idx]]\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaiutre1k.d(51): Error: found `unittest` when expecting `)` following
    template argument list

    /tmp/tmpaiutre1k.d(52): Error: found `{` when expecting `)` following template
    argument list

    /tmp/tmpaiutre1k.d(53): Error: found `alias` when expecting `;` following `return`
    statement

    /tmp/tmpaiutre1k.d(60): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaiutre1k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count;\n    size_t\
    \ len = string.length;\n    size_t sublen = substring.length;\n    if (len < sublen)\n\
    \        return 0;\n    if (len == sublen)\n        return string == substring\
    \ ? 1 : 0;\n    while (string.length >= sublen) \n    {\n        if (string.startsWith(substring))\
    \ \n        {\n            count++;\n            string = string[sublen..$];\n\
    \        }\n        else\n            string = string[1..$];\n    }\n    return\
    \ count;\n}\n/*\n    Find how many times a given substring can be found in the\
    \ original string.\nunittest\n{\n    alias candidate = how_many_times;\n\n   \
    \ assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0s9grgd8.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0s9grgd8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    long len_substring = substring.length;\n    long len_string = string.length;\n\
    \    long len_substring_minus_one = len_substring - 1;\n    for (long i = 0; i\
    \ < len_string; i++) \n    {\n        if (string[i .. $] == substring) \n    \
    \    {\n            result++;\n            i += len_substring_minus_one;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn61rnkmw.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f55]

    ??:? void tmpn61rnkmw.__unittest_L29_C1() [0x427b9f]

    ??:? void tmpn61rnkmw.__modtest() [0x427cd4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab82]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430148]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab59]

    ??:? runModuleUnitTests [0x42ba49]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428418]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long i = 0L;\n    long\
    \ substring_length = substring.length;\n    foreach(index, character; string)\n\
    \    {\n        if(character == substring[0])\n        {\n            if(string[index..index\
    \ + substring_length] == substring)\n            {\n                i++;\n   \
    \         }\n        }\n    }\n    return i;\n}\n/*\n    Find second occurence\
    \ of given substring in the original string. It\u2019s ok if the first occurence\
    \ is overlapping.\n    >>> second_occurence(\"a\", \"a\")\n    1L\n    >>> second_occurence(\"\
    aaaa\", \"aa\")\n    2L\n    >>> second_occurence(\"aaa\", \"aa\")\n    1L\n \
    \   >>> second_occurence(\"bananablaa\", \"na\")\n    5L\n*/\nlong second_occurence(string\
    \ string, string substring) \n{\n    long i = 0L;\n    long substring_length =\
    \ substring.length;\n    foreach(index, character; string)\n    {\n        if(character\
    \ == substring[0])\n        {\n            if(string[index..index + substring_length]\
    \ == substring)\n            {\n                i++;\n            }\n        }\n\
    \        if(i == 2)\n        {\n            return index;\n        }\n    }\n\
    \    return -1L;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpdqai3nl_.d(21): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4281b6]

    ??:? long tmpdqai3nl_.how_many_times(immutable(char)[], immutable(char)[]) [0x427b60]

    ??:? void tmpdqai3nl_.__unittest_L60_C1() [0x427d7a]

    ??:? void tmpdqai3nl_.__modtest() [0x427e84]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42be23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ad32]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fe49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4302f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fdd5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ad09]

    ??:? runModuleUnitTests [0x42bbf9]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long found = 0;\n \
    \   for (size_t i = 0; i < string.length;) \n    {\n        size_t index = string.find(substring,\
    \ i);\n        if (index == string.npos) \n        {\n            break;\n   \
    \     }\n        i = index + 1;\n        found++;\n    }\n    return found;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe8c895um.d(18): Error: no property `find` for type `string`

    /tmp/tmpe8c895um.d(19): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe8c895um.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long n = 0;\n    size_t\
    \ j = 0;\n    foreach (i, const ch; string) \n    {\n        if (ch == substring[j])\
    \ \n        {\n            if (++j == substring.length) \n            {\n    \
    \            ++n;\n                j = 0;\n            }\n        } \n       \
    \ else \n        {\n            j = 0;\n        }\n    }\n    return n;\n}\n/*\n\
    \    Check if a string is a palindrome.\n    >>> is_palindrome(\"abba\")\n   \
    \ true\n    >>> is_palindrome(\"abc\")\n    false\n    >>> is_palindrome(\"toot\"\
    )\n    true\n*/\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp21krkc0w.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e65]

    ??:? void tmp21krkc0w.__unittest_L43_C1() [0x427b90]

    ??:? void tmp21krkc0w.__modtest() [0x427be8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa92]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc25]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300d4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbb1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa69]

    ??:? runModuleUnitTests [0x42b9d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428328]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t last_idx = 0;\n\
    \    size_t substring_size = substring.length;\n    long count = 0;\n    while(true)\
    \ \n    {\n        size_t idx = string.find(substring, last_idx);\n        if(idx\
    \ == string.npos)\n            break;\n        count++;\n        last_idx = idx\
    \ + substring_size;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpftynchji.d(20): Error: no property `find` for type `string`

    /tmp/tmpftynchji.d(21): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpftynchji.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long begin = 0L;\n\
    \    long number_of_times = 0L;\n    while (true)\n    {\n        auto pos = string.find(substring,\
    \ begin);\n        if (pos == string.npos)\n            break;\n        begin\
    \ = pos + 1L;\n        number_of_times += 1L;\n    }\n    return number_of_times;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsweny0nt.d(19): Error: no property `find` for type `string`

    /tmp/tmpsweny0nt.d(20): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsweny0nt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long pos = 0;\n    while ((pos = string.find(substring, pos)) != string.npos)\
    \ \n    {\n        count++;\n        pos += substring.length();\n    }\n    return\
    \ count;\n}\n/*\nThis function should return all permutations of the string given\
    \ to it. The returned list should be sorted.\n    >>> sorted(permutations(\"a\"\
    ))\n    [\"a\"]\n    >>> sorted(permutations(\"ab\"))\n    [\"ab\", \"ba\"]\n\
    \    >>> sorted(permutations(\"abc\"))\n    [\"abc\", \"acb\", \"bac\", \"bca\"\
    , \"cab\", \"cba\"]\n*/\nstring[] permutations(string s) \n{\n    if (s.length\
    \ == 1) \n    {\n        return [s];\n    }\n    string[] result = [];\n    foreach\
    \ (char c; s) \n    {\n        string r = s;\n        r.remove(c);\n        foreach\
    \ (string perm; permutations(r)) \n        {\n            result ~= c ~ perm;\n\
    \        }\n    }\n    return result;\n}\n/*\nGiven a string, return the string\
    \ in reverse.\n    >>> reverse(\"a\")\n    \"a\"\n    >>> reverse(\"aa\")\n  \
    \  \"aa\"\n    >>> reverse(\"aaa\")\n    \"aaa\"\n    >>> reverse(\"ab\")\n  \
    \  \"ba\"\n    >>> reverse(\"aabb\")\n    \"bbaa\"\n    >>> reverse(\"aabbcc\"\
    )\n    \"ccbbaa\"\n*/\nstring reverse(string s) \n{\n    if (s.length == 1) \n\
    \    {\n        return s;\n    }\n    return reverse(s[1..$]) ~ s[0..0];\n}\n\
    /*\nThis function should return a string that is the concatenation of all the\
    \ strings given to it. But if any of the strings are None, they should be ignored.\n\
    \    >>> join_with_none(\"a\", None, \"b\")\n    \"ab\"\n    >>> join_with_none(\"\
    a\", \"b\", None)\n    \"ab\"\n    >>> join_with_none(\"a\", None, \"b\", None)\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp32z6xblc.d(74): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp32z6xblc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    size_t position = 0;\n    while(true)\n    {\n        position = string.find(substring,\
    \ position);\n        if(position == string.npos)\n            break;\n      \
    \  else \n        {\n            ++result;\n            ++position;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzoj6qz_r.d(19): Error: no property `find` for type `string`

    /tmp/tmpzoj6qz_r.d(20): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzoj6qz_r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string.length <\
    \ substring.length)\n        return 0L;\n    long counter = 0L;\n    for (size_t\
    \ s = 0; s < string.length; ++s) \n    {\n        if (string[s .. $] == substring)\n\
    \            ++counter;\n    }\n    return counter;\n}\n/*\n Returns how many\
    \ times a given substring is appearing in the original string. No overlap.\n \
    \   >>> how_many_times_non_overlapping(\"\", \"a\")\n    0L\n    >>> how_many_times_non_overlapping(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times_non_overlapping(\"aaaa\", \"aa\"\
    )\n    2L\n*/\nlong how_many_times_non_overlapping(string string, string substring)\
    \ \n{\n    if (string.length < substring.length)\n        return 0L;\n    long\
    \ counter = 0L;\n    for (size_t s = 0; s < string.length; ++s) \n    {\n    \
    \    if (string[s .. $] == substring)\n        {\n            ++counter;\n   \
    \         s += substring.length - 1;\n        }\n    }\n    return counter;\n\
    }\n/*\n Return how many times substring appears in string. Overlapping is allowed.\n\
    \    >>> how_many_times_v2(\"\", \"a\")\n    0L\n    >>> how_many_times_v2(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times_v2(\"aaaa\", \"aa\")\n    3L\n \
    \   \n    >>> how_many_times_v2(\"asdfghasdfgh\", \"as\")\n    2L\n*/\nlong how_many_times_v2(string\
    \ string, string substring) \n{\n    if (string.length < substring.length)\n \
    \       return 0L;\n    long counter = 0L;\n    for (size_t s = 0; s < string.length;\
    \ ++s) \n    {\n        if (string[s .. $].startsWith(substring))\n          \
    \  ++counter;\n    }\n    return counter;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfjp315t.d(68): Error: no property `startsWith` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfjp315t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong result = 0;\n\t\
    long length = string.length;\n\tlong substring_length = substring.length;\n\t\
    long substring_to_check_length = substring_length;\n\tif (substring_length ==\
    \ 0)\n\t{\n\t\treturn result;\n\t}\n\telse if (length < substring_length)\n\t\
    {\n\t\treturn result;\n\t}\n\telse\n\t{\n\t\twhile (substring_to_check_length\
    \ <= length)\n\t\t{\n\t\t\tif (string[substring_to_check_length - substring_length\
    \ .. substring_to_check_length] == substring)\n\t\t\t{\n\t\t\t\tresult++;\n\t\t\
    \t}\n\t\t\tsubstring_to_check_length++;\n\t\t}\n\t\treturn result;\n\t}\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\t//cout << \"how_many_times:\
    \ \" << string << \", \" << substring << endl;\n\tauto pos = 0L;\n\tauto count\
    \ = 0L;\n\twhile(true)\n\t{\n\t\t//cout << \"pos:\" << pos << endl;\n\t\tpos =\
    \ string.find(substring, pos);\n\t\tif(pos == -1)\n\t\t\tbreak;\n\t\t++count;\n\
    \t\tpos += substring.length;\n\t}\n\t//cout << \"how_many_times: \" << count <<\
    \ endl;\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn3qwg665.d(21): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn3qwg665.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   auto pos = 0;\n    while (true) \n    {\n        pos = string.find(substring,\
    \ pos);\n        if (pos == string.npos) break;\n        pos++;\n        count++;\n\
    \    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmsdt7kmp.d(19): Error: no property `find` for type `string`

    /tmp/tmpmsdt7kmp.d(20): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmsdt7kmp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (substring.length\
    \ == 0) \n    {\n        return 0;\n    }\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb8v1ar70.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb8v1ar70.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tint\
    \ index = 0;\n\tint prevIndex = 0;\n\tauto str = typeof(string)(string);\n\tauto\
    \ substr = typeof(string)(substring);\n\t\n\twhile (index = str.find(substr, prevIndex))\n\
    \t{\n\t\t++count;\n\t\tprevIndex = index + 1;\n\t}\n\treturn count;\n}\n/*\n \
    \   >>> how_many_times(\"\", \"\")\n    0L\n    >>> how_many_times(\"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppqixhf9z.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppqixhf9z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto sz = string.length;\n\
    \    auto ssz = substring.length;\n    if (ssz > sz) return 0;\n    long cnt =\
    \ 0;\n    for (size_t i = 0; i < sz - ssz + 1; i++)\n    {\n        if (string[i..ssz\
    \ + i] == substring) cnt++;\n    }\n    return cnt;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return string.count(substring);\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ibqvrfe.d(15): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ibqvrfe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string.empty) return\
    \ 0;\n    long n = 0;\n    foreach (i; 0 .. string.length - substring.length +\
    \ 1) \n    {\n        if (string[i .. i + substring.length - 1] == substring)\n\
    \            n++;\n    }\n    return n;\n}\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmparoe8vk7.d(15): Error: no property `empty` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmparoe8vk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tforeach(a;iota(string.length-substring.length+1))\n\
    \t{\n\t\tstring tstr = string[a..$];\n\t\tif(tstr.startsWith(substring))\n\t\t\
    \tcount++;\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3dj29tdc.d(16): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3dj29tdc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto count = 0L;\n\
    \    auto pos = find(string, substring);\n    while (pos != -1) \n    {\n    \
    \    count++;\n        pos = find(string[pos+1..$], substring);\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbfh9xpop.d(16): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbfh9xpop.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\timport std.range;\n\t\
    import std.array;\n\t\n\tint[string] table = substring.indexOf.sliced;\n\t\n\t\
    return string.indexOf.sliced\n\t.scan!(a => a + table.get(string[a], string.length))\n\
    \t.array.filter!(a => a < string.length)\n\t.length;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnwdh402e.d(18): Error: variable `string` cannot be read at compile
    time

    /tmp/tmpnwdh402e.d(18): Error: no property `indexOf` for type `string`

    /tmp/tmpnwdh402e.d(20): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwdh402e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long times = 0;\n \
    \   foreach(i;0..(string.length - substring.length + 1))\n    {\n        if(string[i..i+substring.length-1]\
    \ == substring)\n        {\n            times++;\n        }\n    }\n    return\
    \ times;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqdgypsks.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f65]

    ??:? void tmpqdgypsks.__unittest_L25_C1() [0x427baf]

    ??:? void tmpqdgypsks.__modtest() [0x427ce4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab92]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430158]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab69]

    ??:? runModuleUnitTests [0x42ba59]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428428]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong l, r;\n\tl = r =\
    \ 0;\n\tlong cnt = 0;\n\twhile (l < string.length) \n\t{\n\t\tr = find(string,\
    \ substring, l, l);\n\t\tif (r < 0) break;\n\t\tcnt++;\n\t\tl = r + 1;\n\t}\n\t\
    return cnt;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdxzcma9u.d(20): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdxzcma9u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return countOverlappingOccurrences(string,\
    \ substring);\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp24o4vq85.d(15): Error: undefined identifier `countOverlappingOccurrences`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp24o4vq85.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nin {\n    assert(substring.length\
    \ != 0);\n}\nout (size_t result) {\n    assert(result <= string.length);\n}\n\
    body {\n    return size_t(count(string.findall(substring)));\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa60fkvoa.d(17): Error: found `result` when expecting `)`

    /tmp/tmpa60fkvoa.d(17): Error: statement expected to be `{ }`, not `)`

    /tmp/tmpa60fkvoa.d(17): Error: found `)` instead of statement

    /tmp/tmpa60fkvoa.d(19): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa60fkvoa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long counter = 0;\n\
    \    long substring_size = substring.length;\n    long string_size = string.length;\n\
    \    long k = 0;\n    // If substring is bigger than string then we stop\n   \
    \ if (substring_size > string_size) \n    {\n        return 0;\n    }\n    for\
    \ (long i = 0; i < string_size; i++) \n    {\n        // If we have found the\
    \ substring in the current location\n        if (substring[k] == string[i]) \n\
    \        {\n            k++;\n            // If we have checked every letter of\
    \ the substring\n            if (k == substring_size) \n            {\n      \
    \          counter++;\n                k = 0;\n            }\n        }\n    \
    \    else \n        {\n            k = 0;\n        }\n    }\n    return counter;\n\
    }\n/*\nYou are given a string. You need to check if the string is a palindrome\
    \ or not. You need to ignore punctuation marks while checking the same.\n    >>>\
    \ palindrome_check(\"\")\n    true\n    >>> palindrome_check(\"a\")\n    true\n\
    \    >>> palindrome_check(\"aa\")\n    true\n    >>> palindrome_check(\"a.\")\n\
    \    true\n    >>> palindrome_check(\"ab\")\n    false\n    >>> palindrome_check(\"\
    aba\")\n    true\n    >>> palindrome_check(\"aba.\")\n    true\n    >>> palindrome_check(\"\
    aba!\")\n    true\n    >>> palindrome_check(\"aba!!!\")\n    true\n*/\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj_mjch_m.d(71): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e7d]

    ??:? void tmpj_mjch_m.__unittest_L65_C1() [0x427ba8]

    ??:? void tmpj_mjch_m.__modtest() [0x427c00]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc17]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aaaa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc3d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbc9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa81]

    ??:? runModuleUnitTests [0x42b9ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong n = 0;\n\tauto pos\
    \ = string.find(substring);\n\tif (pos == string.length)\n\t\treturn n;\n\t\t\n\
    \tn++;\n\twhile (pos < string.length)\n\t{\n\t\tauto pos2 = string.find(substring,\
    \ pos + 1);\n\t\tif (pos2 == string.length)\n\t\t\tbreak;\n\t\tn++;\n\t\tpos =\
    \ pos2;\n\t}\n\treturn n;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxwuq2lde.d(16): Error: no property `find` for type `string`

    /tmp/tmpxwuq2lde.d(23): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxwuq2lde.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\t\n\tlong times = 0;\n\
    \t\n\tif(string.length >= substring.length)\n\t{\n\t\t\n\t\tauto max = string.length\
    \ - substring.length;\n\t\t\n\t\tfor(long i = 0; i <= max; i++)\n\t\t{\n\t\t\t\
    \n\t\t\tif(string[i .. i + substring.length] == substring)\n\t\t\t{\n\t\t\t\t\n\
    \t\t\t\ttimes++;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\treturn times;\n\
    \t\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long cnt = 0;\n   \
    \ long max = string.length - substring.length;\n    foreach (i; 0..max)\n    {\n\
    \        if (string[i..i+substring.length] == substring)\n            cnt++;\n\
    \    }\n    return cnt;\n}\n/*\nSum the values in the input string, assume that\
    \ the input string has only digits. If the input is \"\", assume its value to\
    \ be 0.\n    >>> sum_digits(\"\")\n    0L\n    >>> sum_digits(\"a\")\n    0L\n\
    \    >>> sum_digits(\"123456789\")\n    45L\n*/\nlong sum_digits(string string)\
    \ \n{\n    long sum = 0;\n    foreach (i; 0..string.length)\n    {\n        if\
    \ (isDigit(string[i]))\n            sum += to!long(string[i]);\n    }\n    return\
    \ sum;\n}\n/*\n    Write a function that returns the longest substring that is\
    \ a palindrome.\n        >>> longest_palindrome(\"aaa\")\n        \"aaa\"\n  \
    \      >>> longest_palindrome(\"aba\")\n        \"aba\"\n        >>> longest_palindrome(\"\
    aabbaad\")\n        \"aabbaa\"\n*/\nstring longest_palindrome(string string) \n\
    {\n    // TODO: Your code here\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp09h8nkae.d(38): Error: undefined identifier `isDigit`

    /tmp/tmp09h8nkae.d(39): Error: template instance `to!long` template `to` is not
    defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp09h8nkae.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int pos = 0;\n    while (pos < string.length) \n    {\n        pos = string.find(substring,\
    \ pos);\n        if (pos == -1) \n        {\n            break;\n        }\n \
    \       count += 1;\n        pos += 1;\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4jfi76of.d(19): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4jfi76of.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long n = 0;\n    for\
    \ (long i = 0; i < string.length; i++)\n    {\n        size_t found = string.find(substring,\
    \ i);\n        if (found != string.npos)\n        {\n            n++;\n      \
    \      i = found;\n        }\n        else\n        {\n            break;\n  \
    \      }\n    }\n    return n;\n}\n/*\nGiven a list of numbers, return a list\
    \ where\nall adjacent == elements have been reduced to a single element,\nso [1,\
    \ 2, 2, 3] returns [1, 2, 3]. You may create a new list or\nmodify the passed\
    \ in list.\n    >>> remove_adjacent([1, 2, 2, 3])\n    [1, 2, 3]\n    >>> remove_adjacent([2,\
    \ 2, 3, 3, 3])\n    [2, 3]\n    >>> remove_adjacent([])\n    []\n*/\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu4g02uaq.d(18): Error: no property `find` for type `string`

    /tmp/tmpu4g02uaq.d(19): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu4g02uaq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return count(reduce!((a,\
    \ x) => a.opCat(x))(map!(c => to!string(c))(iota(0L, string.length - substring.length\
    \ + 1L))));\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6vof9aq7.d(15): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6vof9aq7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nnothrow \npure \nin {\n  \
    \  assert(string.length > 0);\n    assert(substring.length > 0);\n}\nout (result)\
    \ {\n    assert(result >= 0);\n}\nbody {\n    long result = 0;\n    foreach (index;\
    \ 0 .. string.length) {\n        if (string[index .. $].startsWith(substring))\n\
    \            result++;\n    }\n    return result;\n}\n@safe unittest {\n    assert(how_many_times(\"\
    \", \"a\") == 0);\n    assert(how_many_times(\"aaa\", \"a\") == 3);\n    assert(how_many_times(\"\
    aaaa\", \"aa\") == 3);\n}\n/*\n Find the number of occurrences of a given substring\
    \ inside a string.\n    >>> string_occurrences(\"\", \"abc\")\n    0L\n    >>>\
    \ string_occurrences(\"abc\", \"\")\n    0L\n    >>> string_occurrences(\"\",\
    \ \"\")\n    0L\n    >>> string_occurrences(\"abc\", \"abc\")\n    1L\n    >>>\
    \ string_occurrences(\"aabc\", \"abc\")\n    1L\n    >>> string_occurrences(\"\
    aabcabc\", \"abc\")\n    2L\n    >>> string_occurrences(\"ababab\", \"aba\")\n\
    \    2L\n    >>> string_occurrences(\"bababa\", \"aba\")\n    2L\n    >>> string_occurrences(\"\
    bababa\", \"abab\")\n    0L\n    >>> string_occurrences(\"bababa\", \"ab\")\n\
    \    3L\n*/\nlong string_occurrences(string string, string substring) \nnothrow\
    \ \npure \nin {\n    assert(string.length > 0);\n    assert(substring.length >\
    \ 0);\n}\nout (result) {\n    assert(result >= 0);\n}\nbody {\n    long result\
    \ = 0;\n    foreach (index; 0 .. string.length) {\n        if (string[index ..\
    \ $].startsWith(substring))\n            result++;\n    }\n    return result;\n\
    }\n@safe unittest {\n    assert(string_occurrences(\"\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqqks2jc4.d(83): Error: Implicit string concatenation is deprecated,
    use "\x0aunittest\x0a{\x0a    alias candidate = how_many_times;\x0a\x0a    assert(candidate("
    ~ ", " instead

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character '')'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''='' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''='' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''L'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character '')'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character '';'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''s'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''s'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''r'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''t'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''('' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-hex character ''n'' in hex string

    /tmp/tmpqqks2jc4.d(83): Error: non-'
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\t\tif (substring.length\
    \ == 0)\n\t\t\treturn 0;\n\t\tlong result = 0;\n\t\tsize_t pos = 0;\n\t\twhile\
    \ (true)\n\t\t{\n\t\t\tpos = string.find(substring, pos);\n\t\t\tif (pos == string.npos)\n\
    \t\t\t\tbreak;\n\t\t\tresult++;\n\t\t\tpos++;\n\t\t}\n\t\treturn result;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmy47u253.d(21): Error: no property `find` for type `string`

    /tmp/tmpmy47u253.d(22): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy47u253.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \nin \n{\n    assert(!is(typeof(substring)\
    \ == ubyte[]));\n    assert(!is(typeof(substring) == dchar[]));\n    assert(!is(typeof(substring)\
    \ == wchar[]));\n    assert(!is(typeof(substring) == char[]));\n    assert(!is(typeof(substring)\
    \ == void[]));\n    assert(!is(typeof(substring) == bool[]));\n    assert(!is(typeof(substring)\
    \ == float[]));\n    assert(!is(typeof(substring) == double[]));\n    assert(!is(typeof(substring)\
    \ == real[]));\n    assert(!is(typeof(substring) == ifloat[]));\n    assert(!is(typeof(substring)\
    \ == idouble[]));\n    assert(!is(typeof(substring) == ireal[]));\n    assert(!is(typeof(substring)\
    \ == cfloat[]));\n    assert(!is(typeof(substring) == cdouble[]));\n    assert(!is(typeof(substring)\
    \ == creal[]));\n    assert(!is(typeof(substring) == short[]));\n    assert(!is(typeof(substring)\
    \ == ushort[]));\n    assert(!is(typeof(substring) == int[]));\n    assert(!is(typeof(substring)\
    \ == uint[]));\n    assert(!is(typeof(substring) == long[]));\n    assert(!is(typeof(substring)\
    \ == ulong[]));\n    assert(!is(typeof(substring) == cent[]));\n    assert(!is(typeof(substring)\
    \ == ucent[]));\n    assert(!is(typeof(substring) == bool[]));\n    assert(!is(typeof(substring)\
    \ == byte[]));\n    assert(!is(typeof(substring) == size_t[]));\n    assert(!is(typeof(substring)\
    \ == dchar[]));\n    assert(\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnf4978py.d(44): Error: expression expected, not `unittest`

    /tmp/tmpnf4978py.d(45): Error: found `{` when expecting `)`

    /tmp/tmpnf4978py.d(46): Error: found `alias` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnf4978py.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long n=0L;\n    long\
    \ size = string.length;\n    long size_substring = substring.length;\n    for(long\
    \ i=0L; i<size; i++)\n    {\n        if(string[i..i+size_substring] == substring)\n\
    \        {\n            n+=1L;\n        }\n    }\n    return n;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpb_ro_iiq.d(20): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x427ffe]

    ??:? long tmpb_ro_iiq.how_many_times(immutable(char)[], immutable(char)[]) [0x427abc]

    ??:? void tmpb_ro_iiq.__unittest_L27_C1() [0x427bc6]

    ??:? void tmpb_ro_iiq.__modtest() [0x427cd0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab7a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430140]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab51]

    ??:? runModuleUnitTests [0x42ba41]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long ret = 0;\n   \
    \ size_t p = 0;\n    while (p < string.length)\n    {\n        if (string[p..$].startsWith(substring))\n\
    \        {\n            ++ret;\n            p += substring.length;\n        }\n\
    \        else\n        {\n            ++p;\n        }\n    }\n    return ret;\n\
    }\n/*\nImplement the Caesar cipher.\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo9kbpi6u.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo9kbpi6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long found = 0;\n \
    \   size_t len = string.length;\n    size_t sublen = substring.length;\n    if\
    \ (len < sublen) \n    {\n        return 0;\n    }\n    size_t j = 0;\n    size_t\
    \ k = 0;\n    while (j < len) \n    {\n        if (string[j] == substring[k])\
    \ \n        {\n            j++;\n            k++;\n            if (k == sublen)\
    \ \n            {\n                found++;\n                k = 0;\n        \
    \    }\n        } \n        else \n        {\n            j = j - k + 1;\n   \
    \         k = 0;\n        }\n    }\n    return found;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmnrxr3oh.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e95]

    ??:? void tmpmnrxr3oh.__unittest_L44_C1() [0x427bc0]

    ??:? void tmpmnrxr3oh.__modtest() [0x427c18]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc2f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aac2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc55]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbe1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa99]

    ??:? runModuleUnitTests [0x42ba05]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (size_t pos = 0; pos < string.length; pos++) \n    {\n        if (string[pos\
    \ .. $] < substring) \n        {\n            break;\n        }\n        else\
    \ if (string[pos .. $].startsWith(substring)) \n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times2(string string, string\
    \ substring) \n{\n    long count = 0;\n    size_t pos = 0;\n    while (pos !=\
    \ string.length) \n    {\n        if (string[pos .. $] < substring) \n       \
    \ {\n            break;\n        }\n        else if (string[pos .. $].startsWith(substring))\
    \ \n        {\n            count++;\n            pos += substring.length;\n  \
    \      }\n        else \n        {\n            pos++;\n        }\n    }\n   \
    \ return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n   \
    \ assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptq3gqey8.d(22): Error: no property `startsWith` for type `string`

    /tmp/tmptq3gqey8.d(49): Error: no property `startsWith` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptq3gqey8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tif(substring.length ==\
    \ 0)\n\t\treturn 0;\n\tlong ret = 0;\n\tsize_t pos = 0;\n\twhile(true)\n\t{\n\t\
    \tpos = string.find(substring, pos);\n\t\tif(pos == string.npos)\n\t\t\tbreak;\n\
    \t\t++ret;\n\t\t++pos;\n\t}\n\treturn ret;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnsdilm2a.d(21): Error: no property `find` for type `string`

    /tmp/tmpnsdilm2a.d(22): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnsdilm2a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string haystack = string;\n\
    \    string needle = substring;\n    long k = 0;\n    for (int i = 0; i <= haystack.length-needle.length;\
    \ ++i)\n    {\n        if (haystack[i..i+needle.length] == needle)\n        {\n\
    \            k++;\n        }\n    }\n    return k;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2h13i1it.d(15): Error: `string` is used as a type

    /tmp/tmp2h13i1it.d(16): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2h13i1it.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return string.count(substring);\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ibqvrfe.d(15): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ibqvrfe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string remaining_string\
    \ = string;\n    long num_times = 0L;\n    while (remaining_string != \"\") \n\
    \    {\n        immutable index = remaining_string.find(substring);\n        if\
    \ (index == -1) \n        {\n            break;\n        }\n        num_times\
    \ += 1L;\n        immutable substring_length = substring.length;\n        remaining_string\
    \ = remaining_string[index + substring_length .. $];\n    }\n    return num_times;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgvrsayp1.d(15): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgvrsayp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long pos = 0;\n    long substring_len = substring.length;\n    long string_len\
    \ = string.length;\n    long string_len_minus_substring_len = string_len - substring_len;\n\
    \    while (pos <= string_len_minus_substring_len) \n    {\n        if (string[pos..pos\
    \ + substring_len] == substring) \n        {\n            count += 1;\n      \
    \      pos += substring_len;\n        } \n        else \n        {\n         \
    \   pos += 1;\n        }\n    }\n    return count;\n}\n/*\n    >>> dedup(\"aaabbc\"\
    )\n    \"abc\"\n    >>> dedup(\"aaab\")\n    \"ab\"\n    >>> dedup(\"aabc\")\n\
    \    \"abc\"\n*/\nstring dedup(string string)\n{\n    string res = \"\";\n   \
    \ long pos = 0;\n    while (pos < string.length) \n    {\n        long next_pos\
    \ = pos + 1;\n        while (next_pos < string.length && string[pos] == string[next_pos])\
    \ \n        {\n            next_pos += 1;\n        }\n        res ~= string[pos];\n\
    \        pos = next_pos;\n    }\n    return res;\n}\n/*\n    >>> is_isogram(\"\
    Dermatoglyphics\")\n    true\n    >>> is_isogram(\"aba\")\n    false\n    >>>\
    \ is_isogram(\"moOse\")\n    false\n*/\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8zh1p7l5.d(44): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8zh1p7l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n    in (string.length > 0\
    \ && substring.length > 0) \n{\n    return cast(long)std.algorithm.count(string.chunks(substring.length),\
    \ string.chunks(substring.length).length, s => s == substring);\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9wp0d7ww.d(16): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9wp0d7ww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long ret = 0;\n   \
    \ for (size_t i = 0; i < string.length; i++) \n    {\n        if (string[i..i\
    \ + substring.length] == substring)\n            ret++;\n    }\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp2dbh3ghd.d(18): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x427ffe]

    ??:? long tmp2dbh3ghd.how_many_times(immutable(char)[], immutable(char)[]) [0x427abd]

    ??:? void tmp2dbh3ghd.__unittest_L23_C1() [0x427bc6]

    ??:? void tmp2dbh3ghd.__modtest() [0x427cd0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab7a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430140]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab51]

    ??:? runModuleUnitTests [0x42ba41]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto end = string.length;\n\
    \    if(substring.length > end) return 0;\n    long count = 0;\n    long index\
    \ = 0;\n    while(index < end)\n    {\n        auto pos = string.indexOf(substring,\
    \ index);\n        if(pos == -1) break;\n        count++;\n        index = pos\
    \ + 1;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprnr6dqcl.d(21): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprnr6dqcl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return size_t.popCount(string.countUntil(substring));\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8hi21sfx.d(15): Error: no property `popCount` for type `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8hi21sfx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    long last = string.length - substring.length;\n    foreach (i, __; i <= last;\
    \ ++i) \n    {\n        if (string[i .. i + substring.length] == substring)\n\
    \            ++result;\n    }\n    return result;\n}\n// how_many_times\n \n/*\n\
    \ Find the largest substring with the same number of \"0\" and \"1\" characters.\n\
    \    >>> largest_binary_substring(\"0011000101\")\n    \"0011\"\n    >>> largest_binary_substring(\"\
    00001101101\")\n    \"000011\"\n*/\nstring largest_binary_substring(string s)\
    \ \n{\n    string result = \"\";\n    long size = 0;\n    long len = s.length;\n\
    \    long last = len - 1;\n    foreach (left, right; right <= last; ++right) \n\
    \    {\n        if (s[right] == '0') \n        {\n            if (s[left] == '1')\
    \ \n            {\n                ++left;\n                if (left > right)\n\
    \                    continue;\n            }\n        } \n        else \n   \
    \     {\n            if (s[left] == '0') \n            {\n                ++left;\n\
    \                if (left > right)\n                    continue;\n          \
    \  }\n        }\n        long cnt = how_many_times(s[left .. right], \"00\");\n\
    \        cnt += how_many_times(s[left .. right], \"11\");\n        long new_size\
    \ = right - left + 1 - 2 * cnt;\n        if (new_size > size) \n        {\n  \
    \          size = new_size;\n            result = s[left .. right];\n        }\n\
    \    }\n    return result;\n}\n// largest_binary_substring\n \n/*\n Provide the\
    \ Boggle class which will allow other people to write code like the following:\n\
    \    >>> import std.stdio;\n    >>> import std.range;\n    >>> import std.algorithm;\n\
    \    >>> import std.file;\n    >>> import std.typecons;\n    >>> \n    >>> auto\
    \ board = Boggle([\n\nunittest\n{\n    alias candidate = how_many_times;\n\n \
    \   assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsf620vh4.d(17): Error: found `;` when expecting `)`

    /tmp/tmpsf620vh4.d(17): Error: found `)` when expecting `;` following statement

    /tmp/tmpsf620vh4.d(39): Error: found `;` when expecting `)`

    /tmp/tmpsf620vh4.d(39): Error: found `)` when expecting `;` following statement

    /tmp/tmpsf620vh4.d(72): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsf620vh4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return split(string,\
    \ substring).length;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgg2zpzlf.d(15): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgg2zpzlf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    //LUCIUS: return count(filter!(a\
    \ => a == substring)(iota(0, string.length - substring.length + 1)\n\t// .map!(a\
    \ => string[a .. a + substring.length - 1])));\n\tlong count = 0;\n\tfor(size_t\
    \ i = 0; i < string.length - substring.length + 1; i++)\n\t{\n\t\tif(string[i\
    \ .. i + substring.length - 1] == substring)\n\t\t\tcount++;\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpslywgmgk.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f5d]

    ??:? void tmpslywgmgk.__unittest_L25_C1() [0x427ba7]

    ??:? void tmpslywgmgk.__modtest() [0x427cdc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab8a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430150]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab61]

    ??:? runModuleUnitTests [0x42ba51]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428420]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int sub_length = substring.length;\n\
    \    int length = string.length;\n    auto string_begin = string.toUTF8z.save;\n\
    \    auto string_end = string_begin + length;\n    auto sub_begin = substring.toUTF8z.save;\n\
    \    auto sub_end = sub_begin + sub_length;\n    int count = 0;\n    while(string_begin\
    \ != string_end)\n    {\n        auto it = search(string_begin, string_end, sub_begin,\
    \ sub_end);\n        if(it == string_end)\n            break;\n        count++;\n\
    \        string_begin = it + sub_length;\n    }\n    return count;\n}\n/*\n  \
    \  Flip a binary tree upside down.\n    >>> auto t = Node(1, Node(2, Node(3, Node(4,\
    \ Node(5, Node(6, Node(7, null, null), null), null), null), null), null), null);\n\
    \    >>> auto t2 = flipTree(t);\n    >>> map!(x => x.value)(t2.children)\n   \
    \ [6, 7]\n    >>> map!(x => x.value)(t2.children[0].children)\n    [5]\n    >>>\
    \ map!(x => x.value)(t2.children[0].children[0].children)\n    [4]\n    >>> map!(x\
    \ => x.value)(t2.children[0].children[0].children[0].children)\n    [3]\n    >>>\
    \ map!(x => x.value)(t2.children[0].children[0].children[0].children[0].children)\n\
    \    [2]\n    >>> map!(x => x.value)(t2.children[0].children[0].children[0].children[0].children[0].children)\n\
    \    [1]\n*/\nstruct Node {\n    int value;\n    Node* left;\n    Node* right;\n\
    \    Node(int value, Node* left, Node* right)\n    {\n        this.value = value;\n\
    \        this.left = left;\n        this.right = right;\n    }\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo9ia5aea.d(53): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpo9ia5aea.d(54): Error: no identifier for declarator `Node(int value, Node*
    left, Node* right)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo9ia5aea.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n    pure nothrow @safe @nogc\n\
    {\n    long count = 0;\n    foreach(i; 0 .. string.length - substring.length +\
    \ 1) \n    {\n        if(string[i .. i + substring.length - 1] == substring) \n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n \n\
    /*\n    >>> egyptian_fraction(2, 3)\n    [\"1/2\", \"1/6\"]\n    >>> egyptian_fraction(8,\
    \ 11)\n    [\"1/2\", \"1/7\", \"1/59\", \"1/5163\", \"1/53307975\"]\n    >>> egyptian_fraction(3,\
    \ 5)\n    [\"1/2\", \"1/3\"]\n    >>> egyptian_fraction(10, 6)\n    [\"1/2\",\
    \ \"1/3\"]\n    >>> egyptian_fraction(10, 3)\n    [\"1/3\", \"1/6\", \"1/12\"\
    , \"1/24\", \"1/480\", \"1/9600\", \"1/1920000\", \"1/384000000\", \"1/76800000000\"\
    , \"1/15360000000000\", \"1/3072000000000000\", \"1/614400000312475200\", \"1/12288000062495001600\"\
    , \"1/24576000012999000320000\", \"1/4915200002599800064000000\", \"1/983040000519920012800000\"\
    , \"1/19660800001039840256000000\", \"1/39321600002079680512000000\", \"1/78643200004159361025000000\"\
    , \"1/1572864000083187222000000\", \"1/314572800016637444300000\", \"1/629145605933140564800000\"\
    , \"1/125829121186628113000000\", \"1/251658242371356226000000\", \"1/50331648474213524600000\"\
    , \"1/10066329694832705000000\", \"1/2013265938966540000000\", \"1/4026531877933080000000\"\
    , \"\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphs4oazzk.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphs4oazzk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164106
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long occurences = 0;\n\
    \    long start = 0;\n    while(1) \n    {\n        start = find(string, substring,\
    \ start);\n        if(start == -1)\n            break;\n        occurences++;\n\
    \        start++;\n    }\n    return occurences;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptxpcessn.d(19): Error: undefined identifier `find`, did you mean
    template `Bind(alias Template, args1...)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxpcessn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long n = 0;\n    long\
    \ pos = 0;\n    while(true)\n    {\n        long found = string.find(substring,\
    \ pos);\n        if(found == string.npos) break;\n        n++;\n        pos =\
    \ found + 1;\n    }\n    return n;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long res = 0;\n   \
    \ size_t idx = 0;\n    while ( (idx = string.find(substring, idx)) != string.npos\
    \ )\n    {\n        res++;\n        idx += substring.length();\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpll84lxwa.d(17): Error: no property `find` for type `string`

    /tmp/tmpll84lxwa.d(17): Error: no property `npos` for type `string`

    /tmp/tmpll84lxwa.d(20): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpll84lxwa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count;\n    for\
    \ (auto pos = 0; pos < string.length;) \n    {\n        auto found = string.find(substring,\
    \ pos);\n        if (found == -1)\n            break;\n        count++;\n    \
    \    pos = found + 1;\n    }\n    return count;\n}\nlong how_many_times(string\
    \ string, string substring) \n{\n    long count;\n    for (auto pos = 0; pos <\
    \ string.length;) \n    {\n        auto found = string.find(substring, pos);\n\
    \        if (found == -1)\n            break;\n        count++;\n        pos =\
    \ found + 1;\n    }\n    return count;\n}\nlong how_many_times(string string,\
    \ string substring) \n{\n    long count;\n    for (auto pos = 0; pos < string.length;)\
    \ \n    {\n        auto found = string.find(substring, pos);\n        if (found\
    \ == -1)\n            break;\n        count++;\n        pos = found + 1;\n   \
    \ }\n    return count;\n}\nlong how_many_times(string string, string substring)\
    \ \n{\n    long count;\n    for (auto pos = 0; pos < string.length;) \n    {\n\
    \        auto found = string.find(substring, pos);\n        if (found == -1)\n\
    \            break;\n        count++;\n        pos = found + 1;\n    }\n    return\
    \ count;\n}\nlong how_many_times(string string, string substring) \n{\n    long\
    \ count;\n    for (auto pos = 0; pos < string.length;) \n    {\n        auto found\
    \ = string.find(substring, pos);\n        if (found == -1)\n            break;\n\
    \        count++;\n        pos = found + 1;\n    }\n    return count;\n}\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count;\n    for\
    \ (auto pos = 0; pos < string.length;) \n    {\n        auto found = string.find(substring,\
    \ pos);\n        if (found == -1)\n           \nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp672c3ba3.d(86): Error: found `unittest` instead of statement

    /tmp/tmp672c3ba3.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp672c3ba3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long index = 0;\n    while (true) \n    {\n        index = string.find(substring,\
    \ index);\n        if (index == string.npos) \n        {\n            break;\n\
    \        }\n        ++count;\n        ++index;\n    }\n    return count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqwhajr0i.d(19): Error: no property `find` for type `string`

    /tmp/tmpqwhajr0i.d(20): Error: no property `npos` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqwhajr0i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long overlaps = 0;\n\
    \    long i = 0;\n    auto pos = string.find(substring);\n    while (pos != string.npos)\
    \ \n    {\n        overlaps += 1;\n        i = pos + 1;\n        pos = string.find(substring,\
    \ i);\n    }\n    return overlaps;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Do not count overlaping cases.\n    >>>\
    \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
    \    1L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    2L\n    >>> how_many_times(\"\
    ababab\", \"aba\")\n    2L\n    \n*/\nlong how_many_times(string string, string\
    \ substring) \n{\n    long overlaps = 0;\n    long i = 0;\n    auto pos = string.find(substring);\n\
    \    while (pos != string.npos) \n    {\n        overlaps += 1;\n        i = pos\
    \ + substring.length;\n        pos = string.find(substring, i);\n    }\n    return\
    \ overlaps;\n}\n// Substitute the first occurrence of a substring with another\
    \ substring.\nstring substitute(string string, string substring, string new_substring)\
    \ \n{\n    auto pos = string.find(substring);\n    if (pos != string.npos)\n \
    \       return string.substr(0, pos) + new_substring + string.substr(pos + substring.length);\n\
    \    return string;\n}\n/*\n Substitute all occurrences of a substring with another\
    \ substring.\n    >>> substitute(\"aba\", \"a\", \"\")\n    \"b\"\n    >>> substitute(\"\
    aba\", \"a\", \"A\")\n    \"AbA\"\n    >>> substitute(\"ababa\", \"aba\", \"\"\
    )\n    \"\"\n    >>> substitute(\"ababa\", \"aba\", \"A\")\n    \"AA\"\n    >>>\
    \ substitute(\"abcabcabc\", \"abc\", \"\")\n    \"\"\n    >>> substitute(\"abcabcabc\"\
    , \"abc\", \"A\")\n    \"AAA\"\n    >>> substitute\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe1fb2k45.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe1fb2k45.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n    in(string, substring)\
    \ out(string, substring)\n{\n    long count = 0;\n    string searchString = string;\n\
    \    while (searchString.length)\n    {\n        if (searchString.startsWith(substring))\n\
    \        {\n            count++;\n            searchString = searchString[substring.length..$];\n\
    \        }\n        else \n        {\n            searchString = searchString[1..$];\n\
    \        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_nuy9opv.d(14): Error: found `,` when expecting `)`

    /tmp/tmp_nuy9opv.d(14): Error: statement expected to be `{ }`, not `substring`

    /tmp/tmp_nuy9opv.d(14): Error: found `)` when expecting `;` following statement

    /tmp/tmp_nuy9opv.d(15): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_nuy9opv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return count(string.chunks(substring.length));\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgatu4_79.d(15): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgatu4_79.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    auto find_index = 0;\n    auto substr_len = substring.length;\n    while\
    \ (find_index != -1) \n    {\n        find_index = string.find(substring, find_index);\n\
    \        if (find_index != -1) \n        {\n            result += 1;\n       \
    \     find_index += substr_len;\n        }\n    }\n    return result;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times_2(string string, string substring) \n{\n    long result\
    \ = 0;\n    int position = 0;\n    while (true) \n    {\n        position = string.find(substring,\
    \ position);\n        if (position != -1) \n        {\n            result += 1;\n\
    \            position += substring.length;\n        }\n        else \n       \
    \ {\n            break;\n        }\n    }\n    return result;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times_3(string string, string substring) \n{\n    int start_pos\
    \ = 0;\n    int next_index = string.indexOf(substring, start_pos);\n    if (next_index\
    \ == -1) \n    {\n        return 0;\n    }\n    return 1 + how_many_times_3(string[start_pos\
    \ .. $].replaceFirst(substring, \"\"), substring);\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>>\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwr2bibl0.d(78): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwr2bibl0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    immutable n = string.length;\n\
    \    immutable m = substring.length;\n    long matches = 0;\n    if (n < m) return\
    \ 0;\n    for (int i = 0; i < n - m + 1; i++) \n    {\n        if (string[i ..\
    \ i + m] == substring)\n            matches++;\n    }\n    return matches;\n}\n\
    /*\n Check if a given substring can be found in the original string.\n    >>>\
    \ is_in(\"\", \"a\")\n    false\n    >>> is_in(\"a\", \"a\")\n    true\n    >>>\
    \ is_in(\"aaa\", \"a\")\n    true\n*/\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long _substring = substring.length;\n    long index = 0;\n    while(index\
    \ < string.length)\n    {\n        if(string[index .. index + _substring] == substring)\n\
    \        {\n            count++;\n            index += _substring;\n        }\n\
    \        else\n        {\n            index++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvcm_3yr6.d(20): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42800e]

    ??:? long tmpvcm_3yr6.how_many_times(immutable(char)[], immutable(char)[]) [0x427abc]

    ??:? void tmpvcm_3yr6.__unittest_L32_C1() [0x427bd6]

    ??:? void tmpvcm_3yr6.__modtest() [0x427ce0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab8a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430150]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab61]

    ??:? runModuleUnitTests [0x42ba51]

    ??:? void rt.dmain2._d_run_main(int, c'
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string.empty) return\
    \ 0;\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplb6c7g7s.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplb6c7g7s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
