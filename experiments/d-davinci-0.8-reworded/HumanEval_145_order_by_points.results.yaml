name: HumanEval_145_order_by_points
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] l = new int[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        int sum = 0;\n        while (nums[i] != 0)\n        {\n\
    \            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n   \
    \     l[i] = sum;\n    }\n    Tuple!(int, long)[] sorted = sort!((t) => t[0],\
    \ Tuple!(int, long)(l, nums));\n    return sorted[$].tupleof[1];\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsh3_0hrd.d(30): Error: template instance `sort!((t) => t[0],\
    \ Tuple!(int, long)(l, nums))` template `sort` is not defined, did you mean sqrt?\\\
    n/tmp/tmpsh3_0hrd.d(31): Error: cannot implicitly convert expression `sorted[__dollar].__expand_field_1`\
    \ of type `long` to `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpsh3_0hrd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    static struct Pair {\n        long num;\n        int digitsSum;\n\
    \        string toString() { return format(\"(%s, %s)\", num, digitsSum); }\n\
    \    }\n    static auto sum = (int n) {\n        if (n < 10)\n            return\
    \ n;\n        else\n            return n % 10 + sum(n / 10);\n    };\n    if (nums.length\
    \ == 0)\n        return nums;\n    auto p = nums.map!(n => Pair(n, sum(abs(n))));\n\
    \    auto p2 = p.sort!((a, b) => a.digitsSum > b.digitsSum || (a.digitsSum ==\
    \ b.digitsSum && a.num > b.num));\n    return p2.map!(x => x.num).array;\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph4s1tjlf.d(22): Error: undefined identifier `format`\\n/tmp/tmph4s1tjlf.d(28):\
    \ Error: undefined identifier `sum`\\n/tmp/tmph4s1tjlf.d(32): Error: no property\
    \ `map` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmph4s1tjlf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // your code here\n    typeof(return) result = new typeof(return)(nums.length);\n\
    \    int[] points = new int[nums.length];\n    int[] indices = new int[nums.length];\n\
    \    foreach(int i,long n; zip(i,nums))\n    {\n        indices[i] = i;\n    \
    \    points[i] = n.abs().sumDigits();\n    }\n    std.algorithm.sort(zip(points,indices));\n\
    \    foreach(i,p;points)\n    {\n        result[i] = nums[p];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjzvbhy1v.d(23): Error: undefined identifier `zip`\\n/tmp/tmpjzvbhy1v.d(28):\
    \ Error: undefined identifier `algorithm` in package `std`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjzvbhy1v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // return sort!((x, y) => sumDigits(x) < sumDigits(y))(nums);\n\
    \    auto my_tuple = zip(nums, iota(nums.length))\n            .map!(tuple =>\
    \ tupleof(tuple[0], sumDigits(tuple[0]), tuple[1]))\n            .sort!((t1, t2)\
    \ => t1[1] < t2[1] || (t1[1] == t2[1] && t1[2] < t2[2]));\n    return my_tuple.map!(tuple\
    \ => tuple[0]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmbcaibtn.d(20): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmbcaibtn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] res = new long[nums.length];\n    int[] sums = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        sums[i] = sumOfDigits(nums[i]);\n\
    \    }\n    string[] sumsStrs = sums.map!(to!string);\n    string[] numsStrs =\
    \ nums.map!(to!string);\n    string[] zipped = zip(sumsStrs, numsStrs).map!((a,\
    \ b) => a ~ b).sort.map!(to!string);\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        res[i] = to!long(zipped[i][1 .. $]);\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwrhtl9q3.d(23): Error: undefined identifier `sumOfDigits`\\n/tmp/tmpwrhtl9q3.d(25):\
    \ Error: no property `map` for type `int[]`\\n/tmp/tmpwrhtl9q3.d(26): Error: no\
    \ property `map` for type `long[]`\\n/tmp/tmpwrhtl9q3.d(27): Error: undefined\
    \ identifier `zip`\\n/tmp/tmpwrhtl9q3.d(30): Error: template instance `to!long`\
    \ template `to` is not defined, did you mean No?\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwrhtl9q3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  auto y = nums.map!(x => tuple(x, x.digits.sum())).sort!((a, b)\
    \ => a[1] < b[1]);\n  return y.map!(x => x[0]).array;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4895z2iw.d(19): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4895z2iw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result = nums;\n    static struct Item\n    {\n      \
    \  int value;\n        int position;\n    }\n    struct Item item;\n    Item[]\
    \ items = new Item[];\n    int i = 0;\n    foreach(n; nums)\n    {\n        item.value\
    \ = n;\n        item.position = i;\n        items ~= item;\n        i++;\n   \
    \ }\n    auto sort_fn = (a, b) => (a.value.digits.sum).cmp(b.value.digits.sum);\n\
    \    items.sort(sort_fn);\n    i = 0;\n    foreach(item; items)\n    {\n     \
    \   result[i] = item.value;\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp71a12x43.d(25): Error: { } expected following `struct` declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp71a12x43.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int n = nums.length;\n    if (n == 0) \n        return nums;\n\
    \    static struct Pair { int num; int index; } \n    Pair[] newArr = new Pair[n];\n\
    \    //int[] newArr = new int[n];\n    int j = 0;\n    for (int i = 0; i < n;\
    \ i++) \n    {\n        //newArr[i] = nums[i];\n        newArr[i].num = nums[i];\n\
    \        newArr[i].index = i;\n    }\n    //\n    int sumDigits(int val) \n  \
    \  {\n        int sum = 0;\n        int sign = 1;\n        if (val < 0) \n   \
    \     {\n            sign = -1;\n            val = val * sign;\n        }\n  \
    \      while (val != 0) \n        {\n            sum += val % 10;\n          \
    \  val /= 10;\n        }\n        return sum * sign;\n    }\n    //\n    //auto\
    \ newArr = nums.dup;\n    newArr.sort!(\n        (a, b) => (sumDigits(a.num) ==\
    \ sumDigits(b.num)) ?\n            a.index < b.index :\n            sumDigits(a.num)\
    \ < sumDigits(b.num)\n    );\n    foreach (i; 0 .. n) \n    {\n        nums[i]\
    \ = newArr[i].num;\n    }\n    return nums;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi8b8znar.d(19): Error: cannot implicitly convert expression `nums.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpi8b8znar.d(29): Error: cannot implicitly\
    \ convert expression `nums[cast(ulong)i]` of type `long` to `int`\\n/tmp/tmpi8b8znar.d(51):\
    \ Error: no property `sort` for type `Pair[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpi8b8znar.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) \n    {\n        return [];\n    }\n  \
    \  else\n    {\n        return nums.sort!((a, b) => a.to!string.sum(&unparsed\
    \ => cast(long) unparsed) < b.to!string.sum(&unparsed => cast(long) unparsed));\n\
    \    }\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnxf49jgb.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnxf49jgb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[ubyte] points = new long[ubyte];\n    foreach(i, v; nums)\n\
    \    {\n        long point = 0;\n        foreach(auto d; v.to!string())\n    \
    \    {\n            if(d.isDigit)\n                point += d.getDigit;\n    \
    \    }\n        points[i] = point;\n    }\n    auto m = zip(points, nums);\n \
    \   m.sort!((a, b) => a[0] > b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return\
    \ m.map!(a => a[1]).array;\n}\n \n/*\n    Write a function that takes in a string\
    \ and returns a map of the form\n    char => int, where int is the number of times\
    \ the char appears in the string.\n    If string is empty, return an empty map.\n\
    \    Ignore spaces, punctuation and other non-letter characters.\n    \n    For\
    \ example:\n    >>> letter_count(\"The quick brown fox\")\n    ['h': 1, 'e': 1,\
    \ 'q': 1, 'u': 1, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 1, 'o': 2, 'w': 1, 'n':\
    \ 1, 'f': 1, 'x': 1]\n    >>> letter_count(\"the king and the royal family\")\n\
    \    ['t': 1, 'h': 2, 'e': 3, 'k': 1, 'i': 1, 'n': 2, 'g': 2, 'a': 1, 'd': 1,\
    \ 'r': 2, 'o': 2, 'y': 1, 'l': 1, 'f': 1, 'm': 1]\n    >>> letter_count(\"aa bb\
    \ cc\")\n    ['a': 2, 'b': 2, 'c': 2]\n    >>> letter_count(\"\")\n    []\n*/\n\
    long[char] letter_count(string s) \n{\n    long[char] ret = new long[char];\n\
    \    foreach(c; s.lower)\n    {\n        if(c.isLetter)\n            ret[\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt6dd1nto.d(19): Error: need size of rightmost array, not type\
    \ `ubyte`\\n/tmp/tmpt6dd1nto.d(23): Error: basic type expected, not `auto`\\n/tmp/tmpt6dd1nto.d(23):\
    \ Error: no identifier for declarator `_error_`\\n/tmp/tmpt6dd1nto.d(23): Error:\
    \ found `auto` when expecting `;`\\n/tmp/tmpt6dd1nto.d(23): Error: found `;` when\
    \ expecting `)`\\n/tmp/tmpt6dd1nto.d(23): Error: found `)` when expecting `;`\
    \ following statement\\n/tmp/tmpt6dd1nto.d(53): Error: need size of rightmost\
    \ array, not type `char`\\n/tmp/tmpt6dd1nto.d(58): Error: expression expected,\
    \ not `unittest`\\n/tmp/tmpt6dd1nto.d(59): Error: found `{` when expecting `,`\\\
    n/tmp/tmpt6dd1nto.d(60): Error: expression expected, not `alias`\\n/tmp/tmpt6dd1nto.d(60):\
    \ Error: found `candidate` when expecting `,`\\n/tmp/tmpt6dd1nto.d(60): Error:\
    \ expression expected, not `=`\\n/tmp/tmpt6dd1nto.d(60): Error: found `order_by_points`\
    \ when expecting `,`\\n/tmp/tmpt6dd1nto.d(60): Error: expression expected, not\
    \ `;`\\n/tmp/tmpt6dd1nto.d(62): Error: found `assert` when expecting `,`\\n/tmp/tmpt6dd1nto.d(62):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmpt6dd1nto.d(63): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmpt6dd1nto.d(64): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmpt6dd1nto.d(65): Error: found `;` when expecting `,`\\n/tmp/tmpt6dd1nto.d(66):\
    \ Error: found `;` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpt6dd1nto.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.sort!((a, b) => sumDigits(a) < sumDigits(b));\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpclydaj1w.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpclydaj1w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] nums_copy = nums.dup;\n    int[] indices = iota(nums.length);\n\
    \    sort!(nums, (x, y) => sum(x.digits) < sum(y.digits));\n    sort!(indices,\
    \ (x, y) => sum(nums[x].digits) < sum(nums[y].digits));\n    return indices.map!(i\
    \ => nums_copy[i]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkdkrg0yr.d(20): Error: undefined identifier `iota`\\n/tmp/tmpkdkrg0yr.d(21):\
    \ Error: template instance `sort!(nums, (x, y) => sum(x.digits) < sum(y.digits))`\
    \ template `sort` is not defined, did you mean sqrt?\\n/tmp/tmpkdkrg0yr.d(22):\
    \ Error: template instance `sort!(indices, (x, y) => sum(nums[x].digits) < sum(nums[y].digits))`\
    \ template `sort` is not defined, did you mean sqrt?\\n/tmp/tmpkdkrg0yr.d(23):\
    \ Error: no property `map` for type `int[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpkdkrg0yr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    struct Point\n    {\n        int value;\n        int idx;\n \
    \   }\n    auto points = new Point[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        points[i].value = nums[i];\n        points[i].idx = i;\n\
    \    }\n    sort!((a, b) => {\n                int ai = a.value;\n           \
    \     int bi = b.value;\n                bool neg = false;\n                if\
    \ (ai < 0)\n                {\n                    ai = -ai;\n               \
    \     neg = true;\n                }\n                if (bi < 0)\n          \
    \      {\n                    bi = -bi;\n                    neg = true;\n   \
    \             }\n                int da = 0;\n                int db = 0;\n  \
    \              while (ai != 0)\n                {\n                    da += ai\
    \ % 10;\n                    ai /= 10;\n                }\n                while\
    \ (bi != 0)\n                {\n                    db += bi % 10;\n         \
    \           bi /= 10;\n                }\n                if (neg)\n         \
    \       {\n                    da = -da;\n                    db = -db;\n    \
    \            }\n                if (da == db)\n                    return a.idx\
    \ < b.idx;\n                return da < db;\n            })(points);\n    auto\
    \ result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \        result[i] = points[i].value;\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkqdsr2_a.d(27): Error: cannot implicitly convert expression `nums[cast(ulong)i]`\
    \ of type `long` to `int`\\n/tmp/tmpkqdsr2_a.d(30): Error: template instance `sort!((a,\
    \ b) => ()\\n{\\nint ai = a.value;\\nint bi = b.value;\\nbool neg = false;\\nif\
    \ (ai < 0)\\n{\\nai = -ai;\\nneg = true;\\n}\\nif (bi < 0)\\n{\\nbi = -bi;\\nneg\
    \ = true;\\n}\\nint da = 0;\\nint db = 0;\\nwhile (ai != 0)\\n{\\nda += ai % 10;\\\
    nai /= 10;\\n}\\nwhile (bi != 0)\\n{\\ndb += bi % 10;\\nbi /= 10;\\n}\\nif (neg)\\\
    n{\\nda = -da;\\ndb = -db;\\n}\\nif (da == db)\\nreturn a.idx < b.idx;\\nreturn\
    \ da < db;\\n}\\n)` template `sort` is not defined, did you mean sqrt?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkqdsr2_a.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    struct\
    \ Pair{\n        long nums;\n        long index;\n    }\n    \n    long[] sums\
    \ = new long[nums.length];\n    int j = 0;\n    foreach(index, num; nums)\n  \
    \  {\n        long sum = 0;\n        while(num != 0)\n        {\n            sum\
    \ += num % 10;\n            num /= 10;\n        }\n        sums[j] = sum;\n  \
    \      j++;\n    }\n    \n    Pair[] pairs = new Pair[nums.length];\n    for(int\
    \ i = 0; i < nums.length; i++)\n    {\n        pairs[i].nums = nums[i];\n    \
    \    pairs[i].index = i;\n    }\n    \n    int i = 0;\n    foreach(index, p; pairs)\n\
    \    {\n        long sum = 0;\n        while(p.nums != 0)\n        {\n       \
    \     sum += p.nums % 10;\n            p.nums /= 10;\n        }\n        sums[i]\
    \ = sum;\n        i++;\n    }\n    \n    i = 0;\n    foreach(num; sums)\n    {\n\
    \        sums[i] += pairs[i].index;\n        i++;\n    }\n    \n    std.algorithm.sort!(\"\
    a < b\")(sums);\n    \n    foreach(num; sums)\n    {\n        writeln(num);\n\
    \    }\n    \n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps3pw70k6.d(75): Error: undefined identifier `algorithm` in package\
    \ `std`\\n/tmp/tmps3pw70k6.d(79): Error: `writeln` is not defined, perhaps `import\
    \ std.stdio;` is needed?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmps3pw70k6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) return nums;\n    return zip(nums, map!(a\
    \ => (a < 0 ? sum((-a).to!string.split(\"\").map!(to!long)) : sum(a.to!string.split(\"\
    \").map!(to!long)))(a)).array)().sort!q{a[1] < b[1]}.map!q{a[0]}.array;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiumt37y0.d(20): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiumt37y0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // assign points to array of integers\n    long[] pointArray\
    \ = [];\n    long[] sortedArray = [];\n    long[] pointArraySort = [];\n    long[]\
    \ sortedArraySort = [];\n    int count = 0;\n    foreach(nums, x)\n    {\n   \
    \     long point = 0;\n        point = x;\n        pointArray ~= point;\n    \
    \    foreach(to!string(x),y)\n        {\n            point += digitValue(y);\n\
    \        }\n        pointArray[count] = point;\n        count++;\n    }\n    //sort\
    \ points array\n    pointArraySort = sort(pointArray);\n    //sort array\n   \
    \ int numsCount = 0;\n    foreach(pointArraySort, x)\n    {\n        int index\
    \ = 0;\n        foreach(pointArray, y)\n        {\n            if(x == y)\n  \
    \          {\n                sortedArray ~= nums[index];\n                break;\n\
    \            }\n            index++;\n        }\n    }\n    return sortedArray;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7r6zs4qi.d(25): Error: no identifier for declarator `x`\\n/tmp/tmp7r6zs4qi.d(25):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp7r6zs4qi.d(30): Error: function\
    \ declaration without return type. (Note that constructors are always named `this`)\\\
    n/tmp/tmp7r6zs4qi.d(30): Error: no identifier for declarator `to!string(x)`\\\
    n/tmp/tmp7r6zs4qi.d(30): Error: no identifier for declarator `y`\\n/tmp/tmp7r6zs4qi.d(30):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp7r6zs4qi.d(34): Error: found `pointArray`\
    \ when expecting `)`\\n/tmp/tmp7r6zs4qi.d(38): Error: found `pointArraySort` when\
    \ expecting `)`\\n/tmp/tmp7r6zs4qi.d(38): Error: found `=` instead of statement\\\
    n/tmp/tmp7r6zs4qi.d(41): Error: no identifier for declarator `x`\\n/tmp/tmp7r6zs4qi.d(41):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp7r6zs4qi.d(44): Error: no identifier\
    \ for declarator `y`\\n/tmp/tmp7r6zs4qi.d(44): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp7r6zs4qi.d(53): Error: found `}` when expecting `)`\\n/tmp/tmp7r6zs4qi.d(56):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmp7r6zs4qi.d(67): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7r6zs4qi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int r = 0;\n    int g = 0;\n    long l = 0;\n    long[][] q =\
    \ new long[nums.length][2];\n    for (int i = 0; i < nums.length; i++)\n    {\n\
    \        l = nums[i];\n        while (l != 0)\n        {\n            r = (int)(l\
    \ % 10);\n            l = (long)(l / 10);\n            g += r;\n        }\n  \
    \      q[i][0] = g;\n        q[i][1] = nums[i];\n        g = 0;\n    }\n    sort(q);\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        nums[i] = q[i][1];\n\
    \    }\n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7uxmmsk8.d(28): Error: C style cast illegal, use `cast(int)(l\
    \ % 10)`\\n/tmp/tmp7uxmmsk8.d(29): Error: C style cast illegal, use `cast(long)(l\
    \ / 10)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7uxmmsk8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    \n    bool[]\
    \ nagative = new bool[nums.length];\n    int[] sum = new int[nums.length];\n \
    \   long[] result = new long[nums.length];\n    \n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        nagative[i] = nums[i] < 0;\n        nums[i] = abs(nums[i]);\n\
    \        sum[i] = (int)(nums[i] % 10);\n        nums[i] /= 10;\n        while\
    \ (nums[i] != 0)\n        {\n            sum[i] += (int)(nums[i] % 10);\n    \
    \        nums[i] /= 10;\n        }\n    }\n    \n    int[] map = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n        map[i] = i;\n    sort(map,\
    \ (a, b) => sum[a] != sum[b] ? sum[a] - sum[b] : a - b);\n    \n    for (int i\
    \ = 0; i < nums.length; i++)\n    {\n        int idx = map[i];\n        result[i]\
    \ = nagative[idx] ? -nums[idx] : nums[idx];\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm9dradgx.d(30): Error: C style cast illegal, use `cast(int)(nums[i]\
    \ % 10)`\\n/tmp/tmpm9dradgx.d(34): Error: C style cast illegal, use `cast(int)(nums[i]\
    \ % 10)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm9dradgx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result;\n    foreach(int i, long num; nums)\n    {\n \
    \       long x = 0;\n        while(num > 0)\n        {\n            x += num %\
    \ 10;\n            num /= 10;\n        }\n        nums[i] = x;\n    }\n    auto\
    \ cmp = (x, y) => x[0] < y[0] || (x[0] == y[0] && x[1] < y[1]);\n    auto zipped\
    \ = zip(nums, iota(nums.length));\n    zipped.sort(cmp);\n    foreach(i, tuple!(long,\
    \ long) value; zipped)\n    {\n        nums[i] = value[1];\n    }\n    return\
    \ nums;\n}\n/*\n    Write a function that takes in an array of integers and returns\
    \ the\n    length of the longest peak in the array. A peak is defined as adjacent\n\
    \    integers in the array that are strictly increasing until they reach a\n \
    \   tip (the highest value in the peak), at which point they become\n    strictly\
    \ decreasing. At least three integers are required to form a peak.\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp876xxivm.d(39): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp876xxivm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return std.typecons.map!((n) => n[0])(\n                std.algorithm.sort!((a,\
    \ b) => a[1] < b[1])(\n                    std.array.filter!((n) => n[1] != 0)(\n\
    \                        std.typecons.zip(nums, std.algorithm.map!((n) => n.digits.fold!q{a\
    \ + b}(0))(nums)))));\n}\n \n \n \n \n/*\n    A Pythagorean triplet is a set of\
    \ three natural numbers,\n    a < b < c, for which, a2 + b2 = c2\n    For example,\
    \ 32 + 42 = 9 + 16 = 25 = 52.\n    There exists exactly one Pythagorean triplet\
    \ for which a + b + c = 1000.\n    Find the product abc.\n*/\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn9wddd12.d(19): Error: undefined identifier `map` in module `std.typecons`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn9wddd12.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
