language: d
name: HumanEval_145_order_by_points
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] l = new int[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        int sum = 0;\n        while (nums[i] != 0)\n        {\n\
    \            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n   \
    \     l[i] = sum;\n    }\n    Tuple!(int, long)[] sorted = sort!((t) => t[0],\
    \ Tuple!(int, long)(l, nums));\n    return sorted[$].tupleof[1];\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvbrzy6u1.d(30): Error: template instance `sort!((t) => t[0], Tuple!(int,
    long)(l, nums))` template `sort` is not defined, did you mean sqrt?

    /tmp/tmpvbrzy6u1.d(31): Error: cannot implicitly convert expression `sorted[__dollar].__expand_field_1`
    of type `long` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvbrzy6u1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    static struct Pair {\n        long num;\n        int digitsSum;\n\
    \        string toString() { return format(\"(%s, %s)\", num, digitsSum); }\n\
    \    }\n    static auto sum = (int n) {\n        if (n < 10)\n            return\
    \ n;\n        else\n            return n % 10 + sum(n / 10);\n    };\n    if (nums.length\
    \ == 0)\n        return nums;\n    auto p = nums.map!(n => Pair(n, sum(abs(n))));\n\
    \    auto p2 = p.sort!((a, b) => a.digitsSum > b.digitsSum || (a.digitsSum ==\
    \ b.digitsSum && a.num > b.num));\n    return p2.map!(x => x.num).array;\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpktxg2u7p.d(22): Error: undefined identifier `format`

    /tmp/tmpktxg2u7p.d(28): Error: undefined identifier `sum`

    /tmp/tmpktxg2u7p.d(32): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpktxg2u7p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // your code here\n    typeof(return) result = new typeof(return)(nums.length);\n\
    \    int[] points = new int[nums.length];\n    int[] indices = new int[nums.length];\n\
    \    foreach(int i,long n; zip(i,nums))\n    {\n        indices[i] = i;\n    \
    \    points[i] = n.abs().sumDigits();\n    }\n    std.algorithm.sort(zip(points,indices));\n\
    \    foreach(i,p;points)\n    {\n        result[i] = nums[p];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyuuot9e.d(23): Error: undefined identifier `zip`

    /tmp/tmpxyuuot9e.d(28): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyuuot9e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // return sort!((x, y) => sumDigits(x) < sumDigits(y))(nums);\n\
    \    auto my_tuple = zip(nums, iota(nums.length))\n            .map!(tuple =>\
    \ tupleof(tuple[0], sumDigits(tuple[0]), tuple[1]))\n            .sort!((t1, t2)\
    \ => t1[1] < t2[1] || (t1[1] == t2[1] && t1[2] < t2[2]));\n    return my_tuple.map!(tuple\
    \ => tuple[0]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdkzupe0n.d(20): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdkzupe0n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] res = new long[nums.length];\n    int[] sums = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        sums[i] = sumOfDigits(nums[i]);\n\
    \    }\n    string[] sumsStrs = sums.map!(to!string);\n    string[] numsStrs =\
    \ nums.map!(to!string);\n    string[] zipped = zip(sumsStrs, numsStrs).map!((a,\
    \ b) => a ~ b).sort.map!(to!string);\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        res[i] = to!long(zipped[i][1 .. $]);\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp31kew9vj.d(23): Error: undefined identifier `sumOfDigits`

    /tmp/tmp31kew9vj.d(25): Error: no property `map` for type `int[]`

    /tmp/tmp31kew9vj.d(26): Error: no property `map` for type `long[]`

    /tmp/tmp31kew9vj.d(27): Error: undefined identifier `zip`

    /tmp/tmp31kew9vj.d(30): Error: template instance `to!long` template `to` is not
    defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp31kew9vj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  auto y = nums.map!(x => tuple(x, x.digits.sum())).sort!((a, b)\
    \ => a[1] < b[1]);\n  return y.map!(x => x[0]).array;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplaxhxpet.d(19): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplaxhxpet.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result = nums;\n    static struct Item\n    {\n      \
    \  int value;\n        int position;\n    }\n    struct Item item;\n    Item[]\
    \ items = new Item[];\n    int i = 0;\n    foreach(n; nums)\n    {\n        item.value\
    \ = n;\n        item.position = i;\n        items ~= item;\n        i++;\n   \
    \ }\n    auto sort_fn = (a, b) => (a.value.digits.sum).cmp(b.value.digits.sum);\n\
    \    items.sort(sort_fn);\n    i = 0;\n    foreach(item; items)\n    {\n     \
    \   result[i] = item.value;\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmce4ee0g.d(25): Error: { } expected following `struct` declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmce4ee0g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int n = nums.length;\n    if (n == 0) \n        return nums;\n\
    \    static struct Pair { int num; int index; } \n    Pair[] newArr = new Pair[n];\n\
    \    //int[] newArr = new int[n];\n    int j = 0;\n    for (int i = 0; i < n;\
    \ i++) \n    {\n        //newArr[i] = nums[i];\n        newArr[i].num = nums[i];\n\
    \        newArr[i].index = i;\n    }\n    //\n    int sumDigits(int val) \n  \
    \  {\n        int sum = 0;\n        int sign = 1;\n        if (val < 0) \n   \
    \     {\n            sign = -1;\n            val = val * sign;\n        }\n  \
    \      while (val != 0) \n        {\n            sum += val % 10;\n          \
    \  val /= 10;\n        }\n        return sum * sign;\n    }\n    //\n    //auto\
    \ newArr = nums.dup;\n    newArr.sort!(\n        (a, b) => (sumDigits(a.num) ==\
    \ sumDigits(b.num)) ?\n            a.index < b.index :\n            sumDigits(a.num)\
    \ < sumDigits(b.num)\n    );\n    foreach (i; 0 .. n) \n    {\n        nums[i]\
    \ = newArr[i].num;\n    }\n    return nums;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjjgwftbr.d(19): Error: cannot implicitly convert expression `nums.length`
    of type `ulong` to `int`

    /tmp/tmpjjgwftbr.d(29): Error: cannot implicitly convert expression `nums[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmpjjgwftbr.d(51): Error: no property `sort` for type `Pair[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjgwftbr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) \n    {\n        return [];\n    }\n  \
    \  else\n    {\n        return nums.sort!((a, b) => a.to!string.sum(&unparsed\
    \ => cast(long) unparsed) < b.to!string.sum(&unparsed => cast(long) unparsed));\n\
    \    }\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg9r0t76n.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9r0t76n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[ubyte] points = new long[ubyte];\n    foreach(i, v; nums)\n\
    \    {\n        long point = 0;\n        foreach(auto d; v.to!string())\n    \
    \    {\n            if(d.isDigit)\n                point += d.getDigit;\n    \
    \    }\n        points[i] = point;\n    }\n    auto m = zip(points, nums);\n \
    \   m.sort!((a, b) => a[0] > b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return\
    \ m.map!(a => a[1]).array;\n}\n \n/*\n    Write a function that takes in a string\
    \ and returns a map of the form\n    char => int, where int is the number of times\
    \ the char appears in the string.\n    If string is empty, return an empty map.\n\
    \    Ignore spaces, punctuation and other non-letter characters.\n    \n    For\
    \ example:\n    >>> letter_count(\"The quick brown fox\")\n    ['h': 1, 'e': 1,\
    \ 'q': 1, 'u': 1, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 1, 'o': 2, 'w': 1, 'n':\
    \ 1, 'f': 1, 'x': 1]\n    >>> letter_count(\"the king and the royal family\")\n\
    \    ['t': 1, 'h': 2, 'e': 3, 'k': 1, 'i': 1, 'n': 2, 'g': 2, 'a': 1, 'd': 1,\
    \ 'r': 2, 'o': 2, 'y': 1, 'l': 1, 'f': 1, 'm': 1]\n    >>> letter_count(\"aa bb\
    \ cc\")\n    ['a': 2, 'b': 2, 'c': 2]\n    >>> letter_count(\"\")\n    []\n*/\n\
    long[char] letter_count(string s) \n{\n    long[char] ret = new long[char];\n\
    \    foreach(c; s.lower)\n    {\n        if(c.isLetter)\n            ret[\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpvr31j8.d(19): Error: need size of rightmost array, not type `ubyte`

    /tmp/tmpnpvr31j8.d(23): Error: basic type expected, not `auto`

    /tmp/tmpnpvr31j8.d(23): Error: no identifier for declarator `_error_`

    /tmp/tmpnpvr31j8.d(23): Error: found `auto` when expecting `;`

    /tmp/tmpnpvr31j8.d(23): Error: found `;` when expecting `)`

    /tmp/tmpnpvr31j8.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmpnpvr31j8.d(53): Error: need size of rightmost array, not type `char`

    /tmp/tmpnpvr31j8.d(58): Error: expression expected, not `unittest`

    /tmp/tmpnpvr31j8.d(59): Error: found `{` when expecting `,`

    /tmp/tmpnpvr31j8.d(60): Error: expression expected, not `alias`

    /tmp/tmpnpvr31j8.d(60): Error: found `candidate` when expecting `,`

    /tmp/tmpnpvr31j8.d(60): Error: expression expected, not `=`

    /tmp/tmpnpvr31j8.d(60): Error: found `order_by_points` when expecting `,`

    /tmp/tmpnpvr31j8.d(60): Error: expression expected, not `;`

    /tmp/tmpnpvr31j8.d(62): Error: found `assert` when expecting `,`

    /tmp/tmpnpvr31j'
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.sort!((a, b) => sumDigits(a) < sumDigits(b));\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqzggsdi5.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqzggsdi5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] nums_copy = nums.dup;\n    int[] indices = iota(nums.length);\n\
    \    sort!(nums, (x, y) => sum(x.digits) < sum(y.digits));\n    sort!(indices,\
    \ (x, y) => sum(nums[x].digits) < sum(nums[y].digits));\n    return indices.map!(i\
    \ => nums_copy[i]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjegmid0p.d(20): Error: undefined identifier `iota`

    /tmp/tmpjegmid0p.d(21): Error: template instance `sort!(nums, (x, y) => sum(x.digits)
    < sum(y.digits))` template `sort` is not defined, did you mean sqrt?

    /tmp/tmpjegmid0p.d(22): Error: template instance `sort!(indices, (x, y) => sum(nums[x].digits)
    < sum(nums[y].digits))` template `sort` is not defined, did you mean sqrt?

    /tmp/tmpjegmid0p.d(23): Error: no property `map` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjegmid0p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    struct Point\n    {\n        int value;\n        int idx;\n \
    \   }\n    auto points = new Point[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        points[i].value = nums[i];\n        points[i].idx = i;\n\
    \    }\n    sort!((a, b) => {\n                int ai = a.value;\n           \
    \     int bi = b.value;\n                bool neg = false;\n                if\
    \ (ai < 0)\n                {\n                    ai = -ai;\n               \
    \     neg = true;\n                }\n                if (bi < 0)\n          \
    \      {\n                    bi = -bi;\n                    neg = true;\n   \
    \             }\n                int da = 0;\n                int db = 0;\n  \
    \              while (ai != 0)\n                {\n                    da += ai\
    \ % 10;\n                    ai /= 10;\n                }\n                while\
    \ (bi != 0)\n                {\n                    db += bi % 10;\n         \
    \           bi /= 10;\n                }\n                if (neg)\n         \
    \       {\n                    da = -da;\n                    db = -db;\n    \
    \            }\n                if (da == db)\n                    return a.idx\
    \ < b.idx;\n                return da < db;\n            })(points);\n    auto\
    \ result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \        result[i] = points[i].value;\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvi2rl7oy.d(27): Error: cannot implicitly convert expression `nums[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmpvi2rl7oy.d(30): Error: template instance `sort!((a, b) => ()

    {

    int ai = a.value;

    int bi = b.value;

    bool neg = false;

    if (ai < 0)

    {

    ai = -ai;

    neg = true;

    }

    if (bi < 0)

    {

    bi = -bi;

    neg = true;

    }

    int da = 0;

    int db = 0;

    while (ai != 0)

    {

    da += ai % 10;

    ai /= 10;

    }

    while (bi != 0)

    {

    db += bi % 10;

    bi /= 10;

    }

    if (neg)

    {

    da = -da;

    db = -db;

    }

    if (da == db)

    return a.idx < b.idx;

    return da < db;

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvi2rl7oy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    struct\
    \ Pair{\n        long nums;\n        long index;\n    }\n    \n    long[] sums\
    \ = new long[nums.length];\n    int j = 0;\n    foreach(index, num; nums)\n  \
    \  {\n        long sum = 0;\n        while(num != 0)\n        {\n            sum\
    \ += num % 10;\n            num /= 10;\n        }\n        sums[j] = sum;\n  \
    \      j++;\n    }\n    \n    Pair[] pairs = new Pair[nums.length];\n    for(int\
    \ i = 0; i < nums.length; i++)\n    {\n        pairs[i].nums = nums[i];\n    \
    \    pairs[i].index = i;\n    }\n    \n    int i = 0;\n    foreach(index, p; pairs)\n\
    \    {\n        long sum = 0;\n        while(p.nums != 0)\n        {\n       \
    \     sum += p.nums % 10;\n            p.nums /= 10;\n        }\n        sums[i]\
    \ = sum;\n        i++;\n    }\n    \n    i = 0;\n    foreach(num; sums)\n    {\n\
    \        sums[i] += pairs[i].index;\n        i++;\n    }\n    \n    std.algorithm.sort!(\"\
    a < b\")(sums);\n    \n    foreach(num; sums)\n    {\n        writeln(num);\n\
    \    }\n    \n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbvoeh9mx.d(75): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpbvoeh9mx.d(79): Error: `writeln` is not defined, perhaps `import std.stdio;`
    is needed?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbvoeh9mx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) return nums;\n    return zip(nums, map!(a\
    \ => (a < 0 ? sum((-a).to!string.split(\"\").map!(to!long)) : sum(a.to!string.split(\"\
    \").map!(to!long)))(a)).array)().sort!q{a[1] < b[1]}.map!q{a[0]}.array;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7c2i3w0.d(20): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7c2i3w0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // assign points to array of integers\n    long[] pointArray\
    \ = [];\n    long[] sortedArray = [];\n    long[] pointArraySort = [];\n    long[]\
    \ sortedArraySort = [];\n    int count = 0;\n    foreach(nums, x)\n    {\n   \
    \     long point = 0;\n        point = x;\n        pointArray ~= point;\n    \
    \    foreach(to!string(x),y)\n        {\n            point += digitValue(y);\n\
    \        }\n        pointArray[count] = point;\n        count++;\n    }\n    //sort\
    \ points array\n    pointArraySort = sort(pointArray);\n    //sort array\n   \
    \ int numsCount = 0;\n    foreach(pointArraySort, x)\n    {\n        int index\
    \ = 0;\n        foreach(pointArray, y)\n        {\n            if(x == y)\n  \
    \          {\n                sortedArray ~= nums[index];\n                break;\n\
    \            }\n            index++;\n        }\n    }\n    return sortedArray;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp09_kvd65.d(25): Error: no identifier for declarator `x`

    /tmp/tmp09_kvd65.d(25): Error: found `)` when expecting `;`

    /tmp/tmp09_kvd65.d(30): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp09_kvd65.d(30): Error: no identifier for declarator `to!string(x)`

    /tmp/tmp09_kvd65.d(30): Error: no identifier for declarator `y`

    /tmp/tmp09_kvd65.d(30): Error: found `)` when expecting `;`

    /tmp/tmp09_kvd65.d(34): Error: found `pointArray` when expecting `)`

    /tmp/tmp09_kvd65.d(38): Error: found `pointArraySort` when expecting `)`

    /tmp/tmp09_kvd65.d(38): Error: found `=` instead of statement

    /tmp/tmp09_kvd65.d(41): Error: no identifier for declarator `x`

    /tmp/tmp09_kvd65.d(41): Error: found `)` when expecting `;`

    /tmp/tmp09_kvd65.d(44): Error: no identifier for declarator `y`

    /tmp/tmp09_kvd65.d(44): Error: found `)` when expecting `;`

    /tmp/tmp09_kvd65.d(53): Error: found `}` when expecting `)`

    /tmp/tmp09_kvd65.d(56): Error: found `unittest` when expecting `)`

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int r = 0;\n    int g = 0;\n    long l = 0;\n    long[][] q =\
    \ new long[nums.length][2];\n    for (int i = 0; i < nums.length; i++)\n    {\n\
    \        l = nums[i];\n        while (l != 0)\n        {\n            r = (int)(l\
    \ % 10);\n            l = (long)(l / 10);\n            g += r;\n        }\n  \
    \      q[i][0] = g;\n        q[i][1] = nums[i];\n        g = 0;\n    }\n    sort(q);\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        nums[i] = q[i][1];\n\
    \    }\n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qvvv1ko.d(28): Error: C style cast illegal, use `cast(int)(l %
    10)`

    /tmp/tmp6qvvv1ko.d(29): Error: C style cast illegal, use `cast(long)(l / 10)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qvvv1ko.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    \n    bool[]\
    \ nagative = new bool[nums.length];\n    int[] sum = new int[nums.length];\n \
    \   long[] result = new long[nums.length];\n    \n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        nagative[i] = nums[i] < 0;\n        nums[i] = abs(nums[i]);\n\
    \        sum[i] = (int)(nums[i] % 10);\n        nums[i] /= 10;\n        while\
    \ (nums[i] != 0)\n        {\n            sum[i] += (int)(nums[i] % 10);\n    \
    \        nums[i] /= 10;\n        }\n    }\n    \n    int[] map = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n        map[i] = i;\n    sort(map,\
    \ (a, b) => sum[a] != sum[b] ? sum[a] - sum[b] : a - b);\n    \n    for (int i\
    \ = 0; i < nums.length; i++)\n    {\n        int idx = map[i];\n        result[i]\
    \ = nagative[idx] ? -nums[idx] : nums[idx];\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpej3cyn30.d(30): Error: C style cast illegal, use `cast(int)(nums[i]
    % 10)`

    /tmp/tmpej3cyn30.d(34): Error: C style cast illegal, use `cast(int)(nums[i] %
    10)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpej3cyn30.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result;\n    foreach(int i, long num; nums)\n    {\n \
    \       long x = 0;\n        while(num > 0)\n        {\n            x += num %\
    \ 10;\n            num /= 10;\n        }\n        nums[i] = x;\n    }\n    auto\
    \ cmp = (x, y) => x[0] < y[0] || (x[0] == y[0] && x[1] < y[1]);\n    auto zipped\
    \ = zip(nums, iota(nums.length));\n    zipped.sort(cmp);\n    foreach(i, tuple!(long,\
    \ long) value; zipped)\n    {\n        nums[i] = value[1];\n    }\n    return\
    \ nums;\n}\n/*\n    Write a function that takes in an array of integers and returns\
    \ the\n    length of the longest peak in the array. A peak is defined as adjacent\n\
    \    integers in the array that are strictly increasing until they reach a\n \
    \   tip (the highest value in the peak), at which point they become\n    strictly\
    \ decreasing. At least three integers are required to form a peak.\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcxi53lne.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcxi53lne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return std.typecons.map!((n) => n[0])(\n                std.algorithm.sort!((a,\
    \ b) => a[1] < b[1])(\n                    std.array.filter!((n) => n[1] != 0)(\n\
    \                        std.typecons.zip(nums, std.algorithm.map!((n) => n.digits.fold!q{a\
    \ + b}(0))(nums)))));\n}\n \n \n \n \n/*\n    A Pythagorean triplet is a set of\
    \ three natural numbers,\n    a < b < c, for which, a2 + b2 = c2\n    For example,\
    \ 32 + 42 = 9 + 16 = 25 = 52.\n    There exists exactly one Pythagorean triplet\
    \ for which a + b + c = 1000.\n    Find the product abc.\n*/\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjvhznoyi.d(19): Error: undefined identifier `map` in module `std.typecons`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjvhznoyi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto t = std.typecons.Tuple!(long, int)(0,0);\n    return nums.sort!(a\
    \ => std.math.reduce!((a, b) => a + b)(a.toString().map!(x => to!int(x.toString())).array()),\
    \ b => std.math.reduce!((a, b) => a + b)(b.toString().map!(x => to!int(x.toString())).array())).array();\n\
    }\n \nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbd9g5a1b.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbd9g5a1b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto sums = new long[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        auto n = nums[i];\n        long s = 0;\n        while (n\
    \ != 0)\n        {\n            s += n % 10;\n            n /= 10;\n        }\n\
    \        sums[i] = s;\n    }\n    return zip(sums, nums).sort!q{ a[0] < b[0] ||\
    \ (a[0] == b[0] && a[1] < b[1]) }.map!q{ a[1] }.array;\n}\n \nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0pckpwzi.d(31): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0pckpwzi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  nums.sort!((a, b) => \n  {\n    int sumA = 0;\n    int sumB = 0;\n\
    \    foreach(n; a.toString.split(\"\").map!(\"to!int\")[])\n      sumA += n;\n\
    \    foreach(n; b.toString.split(\"\").map!(\"to!int\")[])\n      sumB += n;\n\
    \    return sumA < sumB;\n  });\n  return nums;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wepplii.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wepplii.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] sums = new int[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        long num = nums[i];\n        while (num != 0)\n       \
    \ {\n            sums[i] += num % 10;\n            num /= 10;\n        }\n   \
    \ }\n    auto result = tuple(nums, sums);\n    result = sort(result, (t1, t2)\
    \ => t1[1] < t2[1] || (t1[1] == t2[1] && t1[0] < t2[0]));\n    return result.map!(t\
    \ => t[0]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n\
    \    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps_il6fks.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmps_il6fks.d(31): Error: no property `map` for type `Tuple!(long[], int[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps_il6fks.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length < 2)\n        return nums;\n    return nums.sort!((a,\
    \ b) => digits(a) < digits(b) || (digits(a) == digits(b) && a < b));\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp612ygqvu.d(21): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp612ygqvu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result;\n    int[] sums;\n    auto[res, sum] = std.typecons.tuple(result,\
    \ sums);\n    foreach(n; nums)\n    {\n        int sum_digits = 0;\n        if(n\
    \ < 0)\n        {\n            long pos = -n;\n            while(pos)\n      \
    \      {\n                sum_digits += cast(int)(pos % 10);\n               \
    \ pos /= 10;\n            }\n        }\n        else\n        {\n            while(n)\n\
    \            {\n                sum_digits += cast(int)(n % 10);\n           \
    \     n /= 10;\n            }\n        }\n        res ~= n;\n        sum ~= sum_digits;\n\
    \    }\n    int[] sorted_indexes = sort!((a, b) => sum[a] < sum[b])(iota(sum.length));\n\
    \    for(int i = 0; i < res.length; i++)\n    {\n        result[i] = res[sorted_indexes[i]];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6s24vv02.d(21): Error: basic type expected, not `[`

    /tmp/tmp6s24vv02.d(21): Error: found `,` when expecting `]`

    /tmp/tmp6s24vv02.d(21): Error: semicolon expected, not `]`

    /tmp/tmp6s24vv02.d(21): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6s24vv02.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] out = nums.dup;\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4105y3_j.d(19): Error: no identifier for declarator `int[]`

    /tmp/tmp4105y3_j.d(19): Error: found `out` instead of statement

    /tmp/tmp4105y3_j.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4105y3_j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    /*return nums.sort!((a, b) => \n    {\n        int aSum = 0;\n\
    \        int bSum = 0;\n        foreach(var el; nums)\n        {\n           \
    \ aSum += a % 10;\n            bSum += b % 10;\n        }\n        return aSum\
    \ == bSum ? a.idx > b.idx : aSum > bSum;\n    });*/\n    \n    return nums.sort!((a,\
    \ b) => (a % 10) + (a / 10) > (b % 10) + (b / 10) ? 1 : (a % 10) + (a / 10) <\
    \ (b % 10) + (b / 10) ? -1 : 0);\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ps90ky4.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ps90ky4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    nums = nums.copy();\n    nums.sort!(x => std.math.sum(x.digits))();\n\
    \    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n\
    \    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvzd79npr.d(19): Error: no property `copy` for type `long[]`

    /tmp/tmpvzd79npr.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzd79npr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result;\n    result = new long[nums.length];\n    int\
    \ i, j, temp;\n    for (i = 0; i < nums.length; i++)\n    {\n        for (j =\
    \ i + 1; j < nums.length; j++)\n        {\n            if (abs(nums[i]) > abs(nums[j]))\n\
    \            {\n                temp = nums[i];\n                nums[i] = nums[j];\n\
    \                nums[j] = temp;\n            }\n        }\n    }\n    return\
    \ nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfi9mihva.d(28): Error: cannot implicitly convert expression `nums[cast(ulong)i]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfi9mihva.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  // Write your solution here.\n  long[] index_array = new long[nums.length];\n\
    \  long[] sum_array = new long[nums.length];\n  long[] result = new long[nums.length];\n\
    \  for(int i = 0; i < nums.length; i++)\n  {\n    index_array[i] = i;\n    sum_array[i]\
    \ = 0;\n    long n = nums[i];\n    if(n < 0)\n    {\n      n = -n;\n    }\n  \
    \  while(n != 0)\n    {\n      sum_array[i] += n % 10;\n      n /= 10;\n    }\n\
    \  }\n  sort!(\"a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]\")(zip(sum_array,\
    \ index_array));\n  for(int i = 0; i < nums.length; i++)\n  {\n    result[i] =\
    \ nums[index_array[i]];\n  }\n  return result;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgtf9gtu3.d(38): Error: template instance `sort!"a[0] < b[0] ||
    (a[0] == b[0] && a[1] < b[1]"` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgtf9gtu3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    else\n    {\n\
    \        long[] result = new long[nums.length];\n        std.sort!(\"a.sumDigits().cmp(b.sumDigits())\"\
    )(nums);\n        foreach (i, e; nums)\n            result[i] = e;\n        return\
    \ result;\n    }\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n \
    \   assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h9h4e81.d(24): Error: undefined identifier `sort` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h9h4e81.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    //Tuple!(long, long)[] temp = new Tuple!(long, long)[nums.length];\n\
    \    //Tuple!(long, long)[] result = new Tuple!(long, long)[nums.length];\n  \
    \  Tuple!(long, long)[] temp = nums.map!(a => tuple(a, 0L)).array;\n    Tuple!(long,\
    \ long)[] result = new Tuple!(long, long)[nums.length];\n    long digitsum;\n\
    \    foreach(it, i; temp)\n    {\n        digitsum = 0L;\n        foreach(digit;\
    \ to!string(it[0]).split(\"\"))\n        {\n            digitsum += to!long(digit);\n\
    \        }\n        it[1] = digitsum;\n    }\n    temp.sort!(\"a[1] < b[1] ||\
    \ (a[1] == b[1] && a[0] < b[0])\");\n    foreach(it, i; temp)\n    {\n       \
    \ result[i] = tuple(it[0], i);\n    }\n    result.sort!(\"a[1] < b[1]\");\n  \
    \  return result.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate =\
    \ order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpevdhqput.d(21): Error: no property `map` for type `long[]`

    /tmp/tmpevdhqput.d(27): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpevdhqput.d(31): Error: only one index allowed to index `ulong`

    /tmp/tmpevdhqput.d(33): Error: no property `sort` for type `Tuple!(long, long)[]`

    /tmp/tmpevdhqput.d(36): Error: cannot implicitly convert expression `i` of type
    `Tuple!(long, long)` to `ulong`

    /tmp/tmpevdhqput.d(38): Error: no property `sort` for type `Tuple!(long, long)[]`

    /tmp/tmpevdhqput.d(39): Error: no property `map` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpevdhqput.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{ \n    // Type your solution here.\n    enum Item(long num, long points)\n\
    \    {\n        this(long num)\n        {\n            this.num = num;\n     \
    \       this.points = to!int(num).byValue.map!(int => abs(int)).sum;\n       \
    \ }\n    }\n    auto range = nums.map!(num => Item(num));\n    return range.map!(item\
    \ => item.num).sort!((a, b) => a.points < b.points).array;\n}\n \nunittest\n{\n\
    \    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp35a0f3mn.d(22): Error: found `num` when expecting `.` following
    long

    /tmp/tmp35a0f3mn.d(22): Error: found `)` when expecting identifier following `long`.

    /tmp/tmp35a0f3mn.d(23): Error: found `{` when expecting `,`

    /tmp/tmp35a0f3mn.d(24): Error: found `;` when expecting `,`

    /tmp/tmp35a0f3mn.d(25): Error: found `=>` when expecting `.` following int

    /tmp/tmp35a0f3mn.d(25): Error: found `)` when expecting `.` following int

    /tmp/tmp35a0f3mn.d(25): Error: found `)` when expecting identifier following `int`.

    /tmp/tmp35a0f3mn.d(25): Error: found `;` when expecting `,`

    /tmp/tmp35a0f3mn.d(26): Error: expression expected, not `}`

    /tmp/tmp35a0f3mn.d(27): Error: found `}` when expecting `,`

    /tmp/tmp35a0f3mn.d(28): Error: expression expected, not `auto`

    /tmp/tmp35a0f3mn.d(28): Error: found `range` when expecting `,`

    /tmp/tmp35a0f3mn.d(28): Error: expression expected, not `=`

    /tmp/tmp35a0f3mn.d(28): Error: found `nums` when expecting `,`

    /tmp/tmp35a0f3mn.d(28): Error: found `;` when expecting `,`

    /tmp/tmp35a0f3mn.d('
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return [];\n    \n    auto a =\
    \ nums.map!(x => tuple(x, x.abs.sum)).array();\n    a.sort!((a, b) => a[1] < b[1]\
    \ || a[1] == b[1] && a[0] < b[0]);\n    return a.map!(x => x[0]).array();\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprolxgz64.d(22): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprolxgz64.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) return nums;\n    int[] sum_digits = new\
    \ int[nums.length];\n    foreach (index, item; nums) {\n        sum_digits[index]\
    \ = reduce!((a, b) => a + b)(map!(a => a - '0')(to!string(item)));\n    }\n  \
    \  return nums[array(zip(sum_digits, iota(nums.length))).sort.map!(a => a[1])];\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9v_883y.d(22): Error: template instance `reduce!((a, b) => a +
    b)` template `reduce` is not defined

    /tmp/tmpi9v_883y.d(24): Error: undefined identifier `array`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9v_883y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    static struct SumDigits\n    {\n        long sum;\n        long\
    \ index;\n    }\n    SumDigits[] sumDigitsList = nums.map!(n => SumDigits(n.abs.sumOfDigits,\
    \ n)).array;\n    auto sorted_list = sort!((a, b) => a.sum < b.sum || (a.sum ==\
    \ b.sum && a.index < b.index))(sumDigitsList);\n    return sorted_list.map!(e\
    \ => e.index).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk8rf9v7i.d(24): Error: no property `map` for type `long[]`

    /tmp/tmpk8rf9v7i.d(25): Error: template instance `sort!((a, b) => a.sum < b.sum
    || a.sum == b.sum && (a.index < b.index))` template `sort` is not defined, did
    you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk8rf9v7i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.sort!((n1, n2) => n1.sumOfDigits.compare(n2.sumOfDigits));\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptdamevi_.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptdamevi_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return new long[0];\n    \n  \
    \  alias Tuple!(long, long) Item;\n    Item[] items = new Item[nums.length];\n\
    \    int i = 0;\n    foreach (l; nums)\n    {\n        items[i] = tuple(l, 0);\n\
    \        if (l >= 0)\n        {\n            while (l)\n            {\n      \
    \          items[i].tupleof[1] += l % 10;\n                l /= 10;\n        \
    \    }\n        }\n        else\n        {\n            while (l)\n          \
    \  {\n                items[i].tupleof[1] -= l % 10;\n                l /= 10;\n\
    \            }\n        }\n        i++;\n    }\n    \n    items.sort!(\"a.tupleof[1]\
    \ < b.tupleof[1]\");\n    long[] res = new long[nums.length];\n    i = 0;\n  \
    \  foreach (item; items)\n    {\n        res[i] = item.tupleof[0];\n        i++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprftcdjh8.d(47): Error: no property `sort` for type `Tuple!(long,
    long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprftcdjh8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto arr = zip(iota(nums.length), nums);\n    arr.sort!((a, b)\
    \ =>\n    {\n        auto [i,x] = a;\n        auto [j,y] = b;\n        return\
    \ sumOfDigits(x) < sumOfDigits(y) || (sumOfDigits(x) == sumOfDigits(y) && i <\
    \ j);\n    });\n    return arr.map!((a) => a[1]).array;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprfghkqki.d(22): Error: basic type expected, not `[`

    /tmp/tmprfghkqki.d(22): Error: found `,` when expecting `]`

    /tmp/tmprfghkqki.d(22): Error: semicolon expected, not `]`

    /tmp/tmprfghkqki.d(22): Error: found `]` instead of statement

    /tmp/tmprfghkqki.d(23): Error: basic type expected, not `[`

    /tmp/tmprfghkqki.d(23): Error: found `,` when expecting `]`

    /tmp/tmprfghkqki.d(23): Error: semicolon expected, not `]`

    /tmp/tmprfghkqki.d(23): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprfghkqki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  int[] a = new int[nums.length];\n  int[int] b = new int[int];\n\
    \  long[] result = new long[nums.length];\n  int sum = 0;\n  for (int i = 0; i\
    \ < nums.length; i++) {\n    long number = nums[i];\n    for (int j = 0; j < i;\
    \ j++) {\n      if (number == a[j]) {\n        break;\n      }\n    }\n    while\
    \ (number != 0) {\n      sum += cast(int) number % 10;\n      number /= 10;\n\
    \    }\n    b[sum] = i;\n    a[i] = sum;\n    sum = 0;\n  }\n  sort(a);\n  for\
    \ (int i = 0; i < nums.length; i++) {\n    result[i] = nums[b[a[i]]];\n  }\n \
    \ return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n \
    \   assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_zm4ne02.d(20): Error: need size of rightmost array, not type `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_zm4ne02.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    enum Nums(long num, int sum) \n    {\n        Nums(long num,\
    \ int sum) \n        {\n            this.num = num;\n            this.sum = sum;\n\
    \        }\n    }\n    auto sorted_nums = Nums[nums.length];\n    foreach(i, num;\
    \ nums) \n    {\n        auto sum = 0;\n        foreach(digit; num.to!string())\
    \ \n        {\n            sum += digit.to!int() - '0'.to!int();\n        }\n\
    \        sorted_nums[i] = Nums(num, sum);\n    }\n    sorted_nums.sort!((a, b)\
    \ { return a.sum < b.sum || (a.sum == b.sum && a.num < b.num); });\n    return\
    \ sorted_nums.map!(a => a.num).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptgq90t1l.d(21): Error: found `num` when expecting `.` following
    long

    /tmp/tmptgq90t1l.d(21): Error: found `,` when expecting identifier following `long`.

    /tmp/tmptgq90t1l.d(21): Error: found `int` when expecting `,`

    /tmp/tmptgq90t1l.d(22): Error: found `{` when expecting `;` following statement

    /tmp/tmptgq90t1l.d(28): Error: declaration expected, not `foreach`

    /tmp/tmptgq90t1l.d(28): Error: no identifier for declarator `nums`

    /tmp/tmptgq90t1l.d(28): Error: declaration expected, not `)`

    /tmp/tmptgq90t1l.d(31): Error: declaration expected, not `foreach`

    /tmp/tmptgq90t1l.d(31): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmptgq90t1l.d(31): Error: no identifier for declarator `num.to!string()`

    /tmp/tmptgq90t1l.d(31): Error: semicolon expected following function declaration

    /tmp/tmptgq90t1l.d(31): Error: declaration expected, not `)`

    /tmp/tmptgq90t1l.d(34): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptgq90t1l.'
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.map!(n => tuple(n, n.abs.to!string.map!(c => c.to!long).sum)).sort!((t1,\
    \ t2) => t1[1] > t2[1] || (t1[1] == t2[1] && t1[0] > t2[0])).map!(t => t[0]).array;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmvnk768c.d(19): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmvnk768c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    \n    /*\n \
    \   This uses a bit of indirection, but is way simpler to code than \n    trying\
    \ to work out how to use range.sort\n    */\n    auto indices = iota(nums.length);\n\
    \    static bool cmp(ref long a, ref long b)\n    {\n        if (sumDigits(a)\
    \ == sumDigits(b))\n            return a < b;\n        return sumDigits(a) < sumDigits(b);\n\
    \    }\n    sort(indices, cmp);\n    long[] result = new long[nums.length];\n\
    \    foreach (i, idx; indices)\n        result[i] = nums[idx];\n    return result;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeunm8naz.d(26): Error: undefined identifier `iota`

    /tmp/tmpeunm8naz.d(29): Error: undefined identifier `sumDigits`

    /tmp/tmpeunm8naz.d(29): Error: undefined identifier `sumDigits`

    /tmp/tmpeunm8naz.d(31): Error: undefined identifier `sumDigits`

    /tmp/tmpeunm8naz.d(31): Error: undefined identifier `sumDigits`

    /tmp/tmpeunm8naz.d(33): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeunm8naz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto nums_indices = zip(nums, iota(nums.length));\n    auto nums_indices_sum\
    \ = nums_indices.sort!((a, b) => sumDigits(a[0]) < sumDigits(b[0]) || (sumDigits(a[0])\
    \ == sumDigits(b[0]) && a[1] < b[1]));\n    return nums_indices_sum.map!(x =>\
    \ x[0]).array;\n}\nlong sumDigits(long num)\n{\n    long result = 0;\n    foreach(i;\
    \ num.digits)\n    {\n        result += i;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgmjrbdsy.d(19): Error: undefined identifier `zip`

    /tmp/tmpgmjrbdsy.d(26): Error: no property `digits` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgmjrbdsy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    import std.algorithm.sorting;\n    import std.algorithm.comparison;\n\
    \    import std.math;\n    import std.array;\n    import std.conv;\n    import\
    \ std.range;\n    import std.stdio;\n    struct Pair\n    {\n        long a;\n\
    \        long b;\n    }\n    auto len = nums.length;\n    if(len == 0)\n     \
    \   return nums;\n    auto pair = new Pair[len];\n    for(int i = 0; i < len;\
    \ i++)\n    {\n        pair[i].a = nums[i];\n        pair[i].b = 0;\n        string\
    \ str = nums[i].to!string;\n        foreach(c; str)\n        {\n            pair[i].b\
    \ += c.to!long;\n        }\n    }\n    pair.sort!((x, y) => (x.b < y.b));\n  \
    \  long[] res = new long[len];\n    for(int i = 0; i < len; i++)\n    {\n    \
    \    res[i] = pair[i].a;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfhom76p1.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x437e51]

    ??:? void tmpfhom76p1.__unittest_L53_C1() [0x42fafd]

    ??:? void tmpfhom76p1.__modtest() [0x436300]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x43db3f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4375ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43ab51]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43ace4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43aadd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4375a5]

    ??:? runModuleUnitTests [0x43d915]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4389f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    struct IntDescriptor{long[] digits; int index;long fullNumber;}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4xt4d0bd.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xt4d0bd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] num_copy = nums.dup;\n    //insertion sort\n    for (int\
    \ i = 1; i < num_copy.length; i++)\n    {\n        long temp = num_copy[i];\n\
    \        int j = i - 1;\n        while (j >= 0 && temp < num_copy[j])\n      \
    \  {\n            num_copy[j + 1] = num_copy[j];\n            j = j - 1;\n   \
    \     }\n        num_copy[j + 1] = temp;\n    }\n    return num_copy;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5lna0rux.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x4299b9]

    ??:? void tmp5lna0rux.__unittest_L34_C1() [0x42822d]

    ??:? void tmp5lna0rux.__modtest() [0x42892c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e59b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x429642]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b325]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b3b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b2b1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429619]

    ??:? runModuleUnitTests [0x42e371]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429ed0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    //return nums.sort!((n, m) => { return n.sumDigits().cmp(m.sumDigits());\
    \ });\n    const IndexedValue!long[] c = nums.map!(n => { return tuple(n.sumDigits(),\
    \ n); });\n    return c.sort!((n, m) => { return n[0].cmp(m[0]); }).map!(t =>\
    \ { return t[1]; }).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnn9ybgb.d(20): Error: template instance `IndexedValue!long` template
    `IndexedValue` is not defined

    /tmp/tmplnn9ybgb.d(20): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnn9ybgb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // your code goes here\n    import std.typecons : tuple;\n  \
    \  import std.algorithm : sort;\n    auto nums_tuples = nums.map!(a => tuple(a,\
    \ abs(a)));\n    auto nums_tuples_sum = nums_tuples.map!(a => tuple(a, a[1].sumDigits));\n\
    \    nums_tuples_sum.sort!(a => a[1][1]);\n    nums_tuples_sum.sort!(a => a[1][0]);\n\
    \    auto result = nums_tuples_sum.map!(a => a[0][0]).array;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphnccr9bo.d(22): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphnccr9bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // mixin(typeof(std.typecons.getTuple));\n    auto r = nums.map!(e\
    \ => Tuple(e, sumDigits(e)));\n    std.algorithm.sort!(a => (a[1], a[0]))(r);\n\
    \    return r.map!(e => e[0]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptlehjwjn.d(20): Error: no property `map` for type `long[]`

    /tmp/tmptlehjwjn.d(21): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptlehjwjn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) return new long[0];\n    else\n    {\n\
    \        long[] nums_out = new long[nums.length];\n        for (int i = 0; i <\
    \ nums.length; i++)\n        {\n            nums_out[i] = nums[i];\n        }\n\
    \        long[] counts = new long[nums.length];\n        for (int i = 0; i < nums.length;\
    \ i++)\n        {\n            long[] digits = to(nums[i].abs, (x) => x % 10L);\n\
    \            counts[i] = digits.sum();\n        }\n        auto max = counts.max();\n\
    \        long[] counts_sorted = new long[nums.length];\n        for (int i = 0;\
    \ i < nums.length; i++)\n        {\n            counts_sorted[i] = counts[i];\n\
    \        }\n        counts_sorted.sort;\n        long min_index = counts.indexOf(counts_sorted[0]);\n\
    \        for (int i = 0; i < nums.length; i++)\n        {\n            long min_count\
    \ = counts_sorted[i];\n            nums_out[i] = nums[min_index];\n          \
    \  counts[min_index] = max + 1;\n            long[] new_counts = new long[nums.length];\n\
    \            for (int j = 0; j < nums.length; j++)\n            {\n          \
    \      new_counts[j] = counts[j];\n            }\n            new_counts.sort;\n\
    \            min_index = counts.indexOf(new_counts[0]);\n        }\n        return\
    \ nums_out;\n    }\n}\n \n/* \n    In mathematics, the factorial of a non-negative\
    \ integer\n    n, denoted by n!, is the product of all positive integers\n   \
    \ less than or equal to n. For example:\n    >>> factorial(1)\n    1\n    >>>\
    \ factorial(3)\n    6\n    >>> factorial(5)\n    120\n*/\nlong factorial(long\
    \ n) \n{\n    if (n == 0) return\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr0_lfqcy.d(72): Error: expression expected, not `unittest`

    /tmp/tmpr0_lfqcy.d(73): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr0_lfqcy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    nums = nums.dup;\n    nums.sort!((a, b) =>\n    {\n        long\
    \ sum1 = a.abs.digits.sum;\n        long sum2 = b.abs.digits.sum;\n        return\
    \ (sum1 == sum2) ? a < b : sum1 < sum2;\n    });\n    return nums;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpasb6mf2f.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasb6mf2f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) return nums;\n    int[] sum = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        int val = cast(int)nums[i];\n\
    \        if (val < 0) val = -val;\n        while (val)\n        {\n          \
    \  sum[i] += val % 10;\n            val /= 10;\n        }\n    }\n    int[] idx\
    \ = new int[nums.length];\n    for (int i = 0; i < idx.length; i++) idx[i] = i;\n\
    \    std.algorithm.sort!(\"a[a0] > b[a0] || (a[a0] == b[a0] && a[a1] < b[a1])\"\
    )(tuple(sum, idx));\n    return idx.map!(a => nums[a]).array;\n}\nunittest\n{\n\
    \    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi1w2s_og.d(33): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpi1w2s_og.d(34): Error: no property `map` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi1w2s_og.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.dup.sort!q{a + sumDigits(a) < b + sumDigits(b)};\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3i8me6jp.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3i8me6jp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    \n    Map!(long,\
    \ long[]) points = new Map!(long, long[]);\n    foreach (index, item; nums)\n\
    \    {\n        long point = to!string(abs(item)).reduce!q{ a + b }.to!long;\n\
    \        if (points.count(point) == 0)\n            points[point] = new long[];\n\
    \        points[point] ~= item;\n    }\n    \n    long[] result = new long[];\n\
    \    foreach (item; points.byKey)\n    {\n        foreach (i; item[1])\n     \
    \       result ~= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj0aqbprr.d(22): Error: template instance `Map!(long, long[])` template
    `Map` is not defined

    /tmp/tmpj0aqbprr.d(22): Error: template instance `Map!(long, long[])` template
    `Map` is not defined

    /tmp/tmpj0aqbprr.d(25): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    /tmp/tmpj0aqbprr.d(31): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj0aqbprr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    static struct MyTuple \n    {\n        long num;\n        long\
    \ index;\n    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiobe2fxw.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiobe2fxw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] ret;\n    int[] points;\n    foreach(idx, item; nums)\n\
    \    {\n        points ~= abs(item);\n    }\n    ret = nums[].sort!(a, b => points[a]\
    \ > points[b]);\n    ret = ret[].sort!(a, b => points[a] < points[b]);\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc7qpr_or.d(23): Error: cannot append type `long` to type `int[]`

    /tmp/tmpc7qpr_or.d(25): Error: no property `sort` for type `long[]`

    /tmp/tmpc7qpr_or.d(26): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc7qpr_or.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto memo = nums.map!(x => tuple(x, x.abs.sum.toString)).sort!((x,\
    \ y) => x[1] < y[1]);\n    return memo.map!(x => x[0]).array;\n}\nunittest\n{\n\
    \    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo3m1gjax.d(19): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo3m1gjax.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    struct Point\n    {\n        long number;\n        int sum;\n\
    \        ulong index;\n    }\n    struct ComparePoint\n    {\n        int opCmp(Point\
    \ p1, Point p2)\n        {\n            if (p1.sum == p2.sum)\n            {\n\
    \                return p1.index > p2.index ? 1 : -1;\n            }\n       \
    \     return p1.sum > p2.sum ? 1 : -1;\n        }\n    }\n    Point[] points =\
    \ new Point[nums.length];\n    foreach (i, n; nums)\n    {\n        Point p;\n\
    \        p.number = n;\n        p.sum = 0;\n        foreach (j, d; to!string(n).dchars)\n\
    \        {\n            p.sum += d.to!int - '0';\n        }\n        p.index =\
    \ i;\n        points[i] = p;\n    }\n    std.algorithm.sort!(ComparePoint)(points);\n\
    \    long[] result = new long[nums.length];\n    foreach (i, p; points)\n    {\n\
    \        result[i] = p.number;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9gz5w9dj.d(42): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmp9gz5w9dj.d(49): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9gz5w9dj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    struct Item\n    {\n        long num;\n        int index;\n \
    \       long sum;\n    }\n    long[] res;\n    auto items = nums.map!(a => Item(a,\
    \ a.countDigits(), a.countDigits().to!long)).sort!((a, b) => a.sum < b.sum);\n\
    \    //auto items = nums.map!(a => Item(a, a.countDigits(), a.countDigits().to!long)).array.sort!((a,\
    \ b) => a.sum < b.sum);\n    foreach(item; items)\n    {\n        res ~= item.num;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpksexzw16.d(26): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpksexzw16.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto toInt = new std.conv.to();\n    auto toSum = new int[](toInt(nums).map!(x\
    \ => x.map!((y) => y - '0').sum()));\n    return toInt(toSum).enumerate.sort!((a,\
    \ b) => (a[1] == b[1]) ? (a[0] < b[0]) : (a[1] < b[1])).map!(x => x[0]).map!(x\
    \ => nums[x]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkbmcr64q.d(19): Error: undefined identifier `conv` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkbmcr64q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // Assuming that the size of the array won't be that large\n\
    \    // The upperbound is 7 * 100 = 700\n    auto result = new long[nums.length];\n\
    \    auto indices = new int[nums.length];\n    auto lookup = new int[700];\n \
    \   for (int i = 0; i < nums.length; i++)\n    {\n        int temp = nums[i].sumDigits();\n\
    \        indices[i] = i;\n        result[i] = nums[i];\n        lookup[temp] =\
    \ temp;\n    }\n    auto toSort = zip(indices, result);\n    std.algorithm.sort!((int,\
    \ long)a, (int, long)b => to!int(a[1]) < to!int(b[1]));\n    return toSort.map!(e\
    \ => e[1]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n\
    \    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgwyaj8t7.d(32): Error: found `,` when expecting `.` following int

    /tmp/tmpgwyaj8t7.d(32): Error: found `long` when expecting identifier following
    `int`.

    /tmp/tmpgwyaj8t7.d(32): Error: found `a` when expecting `)` following template
    argument list

    /tmp/tmpgwyaj8t7.d(32): Error: found `,` when expecting `.` following int

    /tmp/tmpgwyaj8t7.d(32): Error: found `long` when expecting identifier following
    `int`.

    /tmp/tmpgwyaj8t7.d(32): Error: found `b` when expecting `;` following statement

    /tmp/tmpgwyaj8t7.d(32): Error: found `=>` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgwyaj8t7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    //Convert an\
    \ array of longs to an array of Tuple with the sum of digits and the original\
    \ value\n    Tuple!(ulong, long)[nums.length] numsTuple = new Tuple!(ulong, long)[nums.length];\n\
    \    foreach (i, number; nums)\n    {\n        ulong sum = 0;\n        //check\
    \ if nums[i] is greater than 0\n        if (nums[i] >= 0)\n        {\n       \
    \     //get the sum of digits\n            while (nums[i] > 0)\n            {\n\
    \                sum += nums[i] % 10;\n                nums[i] /= 10;\n      \
    \      }\n        }\n        else\n        {\n            //get the sum of digits\n\
    \            while (nums[i] < 0)\n            {\n                sum += -(nums[i]\
    \ % 10);\n                nums[i] /= 10;\n            }\n        }\n        //Convert\
    \ long to ulong for sort with Tuple\n        numsTuple[i] = tuple(sum, nums[i]);\n\
    \    }\n    //custom sort function\n    auto sortFunction = (a, b) =>\n    {\n\
    \        if (a[0] == b[0])\n            return a[1] < b[1];\n        return a[0]\
    \ < b[0];\n    };\n    numsTuple.sort(sortFunction);\n    //convert back to a\
    \ long[] array\n    long[] result = new long[nums.length];\n    foreach (i, item;\
    \ numsTuple)\n    {\n        result[i] = item[1];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgc6hhs0f.d(22): Error: variable `nums` cannot be read at compile
    time

    /tmp/tmpgc6hhs0f.d(49): Error: variable `tmpgc6hhs0f.order_by_points.sortFunction`
    type `void` is inferred from initializer `(a, b) => ()

    {

    if (a[0] == b[0])

    return a[1] < b[1];

    return a[0] < b[0];

    }

    `, and variables cannot be of type `void`

    /tmp/tmpgc6hhs0f.d(49): Error: template lambda has no value

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgc6hhs0f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto function_copy = nums.dup;\n    long temp = 0;\n    while(function_copy.length\
    \ > 0)\n    {\n        temp = function_copy[0];\n        function_copy.remove(0);\n\
    \        for(int i = 0; i < function_copy.length; i++)\n        {\n          \
    \  if(sumDigits(temp) > sumDigits(function_copy[i]))\n            {\n        \
    \        temp = function_copy[i];\n                function_copy.remove(i);\n\
    \                function_copy.insert(i, temp);\n            }\n        }\n  \
    \      function_copy.insert(0, temp);\n    }\n    return function_copy;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2kb9wnx_.d(24): Error: no property `remove` for type `long[]`

    /tmp/tmp2kb9wnx_.d(27): Error: undefined identifier `sumDigits`

    /tmp/tmp2kb9wnx_.d(27): Error: undefined identifier `sumDigits`

    /tmp/tmp2kb9wnx_.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmp2kb9wnx_.d(31): Error: no property `insert` for type `long[]`

    /tmp/tmp2kb9wnx_.d(34): Error: no property `insert` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2kb9wnx_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] array = new long[1];\n    int index = 0;\n    int sum\
    \ = 0;\n    foreach(l; nums)\n    {\n        sum = 0;\n        int L = l.to!int;\n\
    \        int[] digits = to!int(std.string.toString(L))\n            .split(\"\"\
    )\n            .retro\n            .map!(a => a.to!int)\n            .array;\n\
    \        foreach(d; digits)\n        {\n            sum += d;\n        }\n   \
    \     array ~= sum;\n    }\n    index = array.minIndex();\n    if(index != -1)\n\
    \    {\n        return [nums[index]] ~ order_by_points(nums[0..index] ~ nums[index+1..$]);\n\
    \    }\n    else\n    {\n        return [];\n    }\n    \n}\nunittest\n{\n   \
    \ alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp91k6wxdp.d(25): Error: no property `to` for type `long`

    /tmp/tmp91k6wxdp.d(26): Error: template instance `to!int` template `to` is not
    defined, did you mean No?

    /tmp/tmp91k6wxdp.d(37): Error: no property `minIndex` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp91k6wxdp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    \n    const uint MAX = 100;\n    uint[] counts = new uint[MAX];\n\
    \    int[] hash = new int[MAX];\n    int[] indices = new int[nums.length];\n \
    \   long[] temp = new long[nums.length];\n    int[] result = new int[nums.length];\n\
    \    int x;\n    int y;\n    for (int i = 0; i < nums.length; i++) {\n       \
    \ indices[i] = i;\n        temp[i] = abs(nums[i]);\n    }\n    for (int i = 0;\
    \ i < nums.length; i++) {\n        counts[temp[i] % 10]++;\n    }\n    for (int\
    \ i = 1; i < MAX; i++) {\n        counts[i] += counts[i - 1];\n    }\n    for\
    \ (int i = nums.length - 1; i >= 0; i--) {\n        x = temp[i] % 10;\n      \
    \  y = counts[x] - 1;\n        hash[y] = temp[i];\n        counts[x]--;\n    }\n\
    \    for (int i = 0; i < MAX; i++) {\n        counts[i] = 0;\n    }\n    for (int\
    \ i = 0; i < nums.length; i++) {\n        counts[hash[i] / 10]++;\n    }\n   \
    \ for (int i = 1; i < MAX; i++) {\n        counts[i] += counts[i - 1];\n    }\n\
    \    for (int i = nums.length - 1; i >= 0; i--) {\n        x = hash[i] / 10;\n\
    \        y = counts[x] - 1;\n        result[y] = indices[i];\n        counts[x]--;\n\
    \    }\n    for (int i = 0; i < nums.length; i++) {\n        indices[i] = i;\n\
    \    }\n    for (int i = 0; i < nums.length; i++) {\n        x = result[i];\n\
    \        result[i] = indices[x];\n        indices[x] = -1;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpddxj5_ma.d(38): Error: cannot implicitly convert expression `nums.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpddxj5_ma.d(41): Error: cannot implicitly convert expression `temp[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmpddxj5_ma.d(53): Error: cannot implicitly convert expression `nums.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpddxj5_ma.d(67): Error: cannot implicitly convert expression `result` of
    type `int[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpddxj5_ma.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{ \n    int[] indexArr = new int[nums.length];\n    //Initialize the\
    \ index array\n    for(int i = 0; i < indexArr.length; i++)\n    {\n        indexArr[i]\
    \ = i;\n    }\n    //Tuple of the index array and the array of numbers\n    Tuple!(int[],\
    \ long[]) tuple = tuple(indexArr, nums);\n    //Define the array of tuples\n \
    \   Tuple!(int[], long[])[] tuples = new Tuple!(int[], long[])[nums.length];\n\
    \    //Populate the array of tuples\n    for(int i = 0; i < tuples.length; i++)\n\
    \    {\n        tuples[i] = tuple;\n    }\n    //Sort the array of tuples\n  \
    \  std.algorithm.sort!((t1, t2) => sumDigits(t1[1][t1[0][0]]) < sumDigits(t2[1][t2[0][0]]))(tuples);\n\
    \    //Checking the first tuple\n    writeln(tuples[0][0][0]);\n    writeln(tuples[0][1][tuples[0][0][0]]);\n\
    \    writeln(sumDigits(tuples[0][1][tuples[0][0][0]]));\n    //Using the array\
    \ of tuples to get the index of the sorted array and return\n    //the sorted\
    \ array\n    long[] sortedArray = new long[nums.length];\n    foreach(i, tup;\
    \ tuples)\n    {\n        sortedArray[i] = tup[1][tup[0][0]];\n    }\n    return\
    \ sortedArray;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n   \
    \ assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpol330uwa.d(35): Deprecation: package `std.algorithm` is not accessible
    here

    /tmp/tmpol330uwa.d(35): Error: undefined identifier `sort` in package `std.algorithm`

    /tmp/tmpol330uwa.d(37): Error: `writeln` is not defined, perhaps `import std.stdio;`
    is needed?

    /tmp/tmpol330uwa.d(38): Error: `writeln` is not defined, perhaps `import std.stdio;`
    is needed?

    /tmp/tmpol330uwa.d(39): Error: `writeln` is not defined, perhaps `import std.stdio;`
    is needed?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpol330uwa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto l = nums.length;\n    static struct pair\n    {\n      \
    \  long data;\n        long index;\n    }\n    tuple!(long, long)[][] arr = new\
    \ tuple!(long, long)[][](l);\n    foreach(i, v; nums)\n    {\n        long digit\
    \ = 0;\n        while(v != 0)\n        {\n            digit += v % 10;\n     \
    \       v /= 10;\n        }\n        int j = 0;\n        while(j < l && tuple!(long,\
    \ long)(digit, i) > arr[j])\n        {\n            j++;\n        }\n        arr.insert(j,\
    \ tuple!(long, long)(digit, i));\n    }\n    long[] ans = new long[](l);\n   \
    \ foreach(i, v; arr)\n    {\n        ans[i] = nums[v.index];\n    }\n    return\
    \ ans;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdp0ogxsp.d(25): Error: `tuple!(long, long)` is used as a type

    /tmp/tmpdp0ogxsp.d(25): Error: `tuple!(long, long)` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdp0ogxsp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    /*TypeTuple!(long[], long[]) TT = std.algorithm.topN!(long[],\
    \ greater_sum, 2)(nums);\n    return TT[0];*/\n    auto cmp = (l, r) => l > r;\n\
    \    auto cmp2 = (l, r) => l.sum > r.sum;\n    auto sum = (l) => l.sum;\n    auto\
    \ arr = nums.map!(a => typeof(return) (a, a.sum));\n    arr.sort(cmp2);\n    return\
    \ arr.map!(a => a.n).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmb2quise.d(21): Error: variable `tmpmb2quise.order_by_points.cmp`
    type `void` is inferred from initializer `(l, r) => l > r`, and variables cannot
    be of type `void`

    /tmp/tmpmb2quise.d(21): Error: template lambda has no value

    /tmp/tmpmb2quise.d(22): Error: variable `tmpmb2quise.order_by_points.cmp2` type
    `void` is inferred from initializer `(l, r) => l.sum > r.sum`, and variables cannot
    be of type `void`

    /tmp/tmpmb2quise.d(22): Error: template lambda has no value

    /tmp/tmpmb2quise.d(23): Error: variable `tmpmb2quise.order_by_points.sum` type
    `void` is inferred from initializer `(l) => l.sum`, and variables cannot be of
    type `void`

    /tmp/tmpmb2quise.d(23): Error: template lambda has no value

    /tmp/tmpmb2quise.d(24): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmb2quise.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] array = (long[])nums.dup;\n    long[] sum = new long[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        for (int j = 0; j <\
    \ (nums[i]).to!string.length; j++)\n        {\n            sum[i] += (nums[i]).to!string[j].to!long\
    \ - '0'.to!long;\n        }\n    }\n    sort(array, sum);\n    return array;\n\
    }\n// Better solution by Tofe\nlong[] order_by_points2(long[] nums) \n{\n    long[]\
    \ result = (long[])nums.dup;\n    sort!((a, b) => tuple(a.sumDigits(), a) > tuple(b.sumDigits(),\
    \ b))(result);\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_p_xe5q2.d(19): Error: C style cast illegal, use `cast(long[])nums.dup`

    /tmp/tmp_p_xe5q2.d(34): Error: C style cast illegal, use `cast(long[])nums.dup`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_p_xe5q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // sort array by the sum of the digits of the elements, if sums\
    \ are equal\n    // keep the original order\n    auto comp = (a, b) => a[0] <\
    \ b[0] || (a[0] == b[0] && a[1] < b[1]);\n    int N = nums.length;\n    int[]\
    \ sum_index = new int[][];\n    for (int i = 0; i < N; i++) {\n        int sum\
    \ = 0;\n        int n = abs(nums[i]);\n        while (n != 0) {\n            sum\
    \ += n % 10;\n            n /= 10;\n        }\n        sum_index[i] = tuple(sum,\
    \ i);\n    }\n    sum_index = sort(sum_index, comp);\n    long[] result = new\
    \ long[N];\n    for (int i = 0; i < N; i++) {\n        result[i] = nums[sum_index[i][1]];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpotmv0o6y.d(21): Error: variable `tmpotmv0o6y.order_by_points.comp`
    type `void` is inferred from initializer `(a, b) => a[0] < b[0] || a[0] == b[0]
    && (a[1] < b[1])`, and variables cannot be of type `void`

    /tmp/tmpotmv0o6y.d(21): Error: template lambda has no value

    /tmp/tmpotmv0o6y.d(22): Error: cannot implicitly convert expression `nums.length`
    of type `ulong` to `int`

    /tmp/tmpotmv0o6y.d(23): Error: new can only create structs, dynamic arrays or
    class objects, not `int[][]`''s

    /tmp/tmpotmv0o6y.d(26): Error: cannot implicitly convert expression `abs(nums[cast(ulong)i])`
    of type `long` to `int`

    /tmp/tmpotmv0o6y.d(31): Error: cannot implicitly convert expression `tuple(sum,
    i)` of type `Tuple!(int, int)` to `int`

    /tmp/tmpotmv0o6y.d(33): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpotmv0o6y.d(36): Error: only one index allowed to index `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpotmv0o6y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // create mapping from item to it's sum of digits\n    long[long]\
    \ sums = new long[long];\n    foreach(n; nums) {\n        long s = 0;\n      \
    \  foreach(c; to!string(n)) s += c - '0';\n        sums[n] = s;\n    }\n    //\
    \ create array of items sorted by sum of digits\n    auto sorted = nums.dup;\n\
    \    sorted.sort!((x, y) => sums[x] < sums[y]);\n    // create mapping from item\
    \ to it's original index\n    long[long] indexes = new long[long];\n    foreach(i,\
    \ n; nums) indexes[n] = i;\n    // sort items by their original index\n    sorted.sort!((x,\
    \ y) => indexes[x] < indexes[y]);\n    return sorted;\n}\n \n/*\n    You were\
    \ given a tree and a value.\n    Your task is to find a path in the tree where\
    \ sum of numbers on the path\n    is equal to the given value.\n    The nodes\
    \ of the tree are integers.\n    The function should return an array of nodes\
    \ that form the path.\n    If there are several paths with the same sum, return\
    \ the longest one.\n    If the sum is not found, return the shortest.\n    If\
    \ there are several shortest paths, return the one that has the largest index.\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp65ixjo5q.d(20): Error: need size of rightmost array, not type `long`

    /tmp/tmp65ixjo5q.d(30): Error: need size of rightmost array, not type `long`

    /tmp/tmp65ixjo5q.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp65ixjo5q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    size_t[] points = new size_t[nums.length];\n    size_t i = 0;\n\
    \    foreach(n; nums)\n    {\n        points[i] = 0;\n        foreach(c; n.to!string)\n\
    \        {\n            points[i] += c.to!long - 48;\n        }\n        i++;\n\
    \    }\n    i = 0;\n    size_t[] points_order = new size_t[nums.length];\n   \
    \ foreach(p; points)\n    {\n        size_t j = 0;\n        foreach(po; points_order)\n\
    \        {\n            if(points[j] < p)\n            {\n                points_order[i]\
    \ = j;\n                i++;\n                break;\n            }\n        \
    \    j++;\n        }\n    }\n    long[] result = new long[nums.length];\n    i\
    \ = 0;\n    foreach(po; points_order)\n    {\n        result[i] = nums[po];\n\
    \        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp955f45b5.d(24): Error: no property `to` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp955f45b5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] sums = nums.map!(n => n.sumOfDigits).array;\n    return\
    \ nums.sort!((a, b) => sums[a] < sums[b] || sums[a] == sums[b] && a < b).array;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1stlmrir.d(19): Error: no property `map` for type `long[]`

    /tmp/tmp1stlmrir.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1stlmrir.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] d = new int[nums.length];\n    int[] n = new int[nums.length];\n\
    \    foreach(int i, long num; nums)\n    {\n        d[i] = num;\n        n[i]\
    \ = abs(num);\n    }\n    while(1)\n    {\n        bool swapped = false;\n   \
    \     foreach(int i; 1..nums.length-1)\n        {\n            if (n[i] % 10 +\
    \ n[i+1] % 10 > 9)\n            {\n                int tmp = n[i];\n         \
    \       n[i] = n[i+1];\n                n[i+1] = tmp;\n                tmp = d[i];\n\
    \                d[i] = d[i+1];\n                d[i+1] = tmp;\n             \
    \   swapped = true;\n            }\n        }\n        if (!swapped)\n       \
    \     break;\n    }\n    return d;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjwrzabyx.d(23): Error: cannot implicitly convert expression `num`
    of type `long` to `int`

    /tmp/tmpjwrzabyx.d(24): Error: cannot implicitly convert expression `abs(num)`
    of type `long` to `int`

    /tmp/tmpjwrzabyx.d(29): Error: cannot implicitly convert expression `nums.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpjwrzabyx.d(45): Error: cannot implicitly convert expression `d` of type
    `int[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwrzabyx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    alias IndexedLong\
    \ = Tuple!(int, long);\n    IndexedLong[] indexedLongs = new IndexedLong[];\n\
    \    foreach (int i, long n; nums)\n    {\n        static if (n < 0)\n       \
    \     n = -n;\n        int num = n;\n        int sum = 0;\n        while (num\
    \ > 0)\n        {\n            sum += num % 10;\n            num /= 10;\n    \
    \    }\n        indexedLongs ~= tuple(sum, n);\n    }\n    std.algorithm.sort!((a,\
    \ b) => a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]))(indexedLongs);\n    long[]\
    \ ret = new long[];\n    foreach (IndexedLong a; indexedLongs)\n        ret ~=\
    \ a[1];\n    return ret;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_hbpmhhp.d(22): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(int, long)[]`''s

    /tmp/tmp_hbpmhhp.d(25): Error: variable `n` cannot be read at compile time

    /tmp/tmp_hbpmhhp.d(27): Error: cannot implicitly convert expression `n` of type
    `long` to `int`

    /tmp/tmp_hbpmhhp.d(36): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp_hbpmhhp.d(37): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hbpmhhp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    \n    auto cmp\
    \ = typeof(this).structof.dup;\n    cmp.points = 0;\n    cmp.index = 0;\n    \n\
    \    auto cmp_t = typeof(cmp).init;\n    auto arr = nums.dup;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        cmp.points = 0;\n        cmp.index\
    \ = i;\n        long val = arr[i];\n        if (val < 0)\n            val = -val;\n\
    \        while (val > 0)\n        {\n            cmp.points += val % 10;\n   \
    \         val /= 10;\n        }\n        arr[i] = cmp_t(cmp);\n    }\n    arr.sort!(a,\
    \ b => a.points == b.points ? a.index < b.index : a.points < b.points);\n    return\
    \ arr.map!(a => nums[a.index]).array;\n}\n/*\n    Write a function which returns\
    \ all numbers from 1 to 100 which\n    are divisible by both 3 and 7.\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb11_faz7.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb11_faz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return [];\n    else if (nums.length\
    \ == 1)\n        return nums;\n    else\n    {\n        import std.algorithm;\n\
    \        int[] indices = iota(nums.length);\n        long[] sums = new long[nums.length];\n\
    \        for (int i = 0; i < sums.length; i++)\n        {\n            sums[i]\
    \ = nums[i] < 0 ? \n                - nums[i].abs.to!string.array\n          \
    \      .map!(\"to!int\")\n                .reduce!(\"a + b\") :\n            \
    \    nums[i].to!string.array\n                .map!(\"to!int\")\n            \
    \    .reduce!(\"a + b\");\n        }\n        auto t = tuple(sums, indices);\n\
    \        t.sort;\n        long[] res = new long[nums.length];\n        foreach\
    \ (i, item; sums)\n        {\n            res[i] = nums[t[i][1]];\n        }\n\
    \        return res;\n    }\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp26mwcnji.d(26): Error: undefined identifier `iota`

    /tmp/tmp26mwcnji.d(31): Error: no property `to` for type `long`

    /tmp/tmp26mwcnji.d(34): Error: no property `to` for type `long`

    /tmp/tmp26mwcnji.d(39): Error: template `std.algorithm.sorting.sort` cannot deduce
    function from argument types `!()(Tuple!(long[], int[]))`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/sorting.d(1847):        `std.algorithm.sorting.sort(alias
    less = "a < b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range r) if ((ss
    == SwapStrategy.unstable && (hasSwappableElements!Range || hasAssignableElements!Range)
    || ss != SwapStrategy.unstable && hasAssignableElements!Range) && isRandomAccessRange!Range
    && hasSlicing!Range && hasLength!Range)`

    /tmp/tmp26mwcnji.d(43): Error: variable `i` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26mwcnji.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums\n        .map!(a => Tuple!(int, long)(a.sumDigits,\
    \ a))\n        .sort!((a, b) => (a[0] < b[0] || (a[0] == b[0] && a[1] < b[1])))\n\
    \        .map!(a => a[1])\n        .array;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_gtjif1w.d(20): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_gtjif1w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // Your code here\n    return ();\n}\n \nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphqy02z0z.d(20): Error: expression expected, not `)`

    /tmp/tmphqy02z0z.d(20): Error: found `;` when expecting `)`

    /tmp/tmphqy02z0z.d(21): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmphqy02z0z.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphqy02z0z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums\n        .retro\n        .sort!(a => digits_sum(a),\
    \ b => digits_sum(b))\n        .array;\n}\nunittest\n{\n    alias candidate =\
    \ order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjbv_50ko.d(20): Error: no property `retro` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjbv_50ko.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    /*\n        Arrays are too slow for that task.\n        So we\
    \ use associative array instead.\n        We will encode the original index of\
    \ each number as a tuple,\n        e.g.:\n        >>> nums = [1L, 11L, -1L, -11L,\
    \ -12L]\n        >>> keys = nums.map!((x) => tuple(abs(x).sumDigits, typeof(nums).indexOf(x)));\n\
    \        >>> keys;\n        [tuple(2, 0), tuple(2, 1), tuple(2, 2), tuple(3, 3),\
    \ tuple(4, 4)]\n        The 'tuple' will be sorted by the first tuple item.\n\
    \        The 'tuple.length' is equal to 2, so the second item\n        (which\
    \ keeps the original index) will be used to break ties.\n    */\n    const uint\
    \ len = nums.length;\n    const uint z = tuple(0, 0); // default tuple value\n\
    \    ulong[][] keys = new ulong[][](len); // associated array for the 'keys'\n\
    \    foreach (i, ref num; nums) {\n        const uint key = abs(num).sumDigits;\n\
    \        keys[key] ~= tuple(key, i);\n    }\n    /*\n        Let's use merge sort\
    \ to sort the array with tuples.\n        It would be nice if it will be done\
    \ in-place.\n        Keep in mind that the order of the arrays elements\n    \
    \    is important (it keeps the order of the original numbers).\n    */\n    ulong[][]\
    \ merge(ulong[][] a, ulong[][] b) {\n        ulong[][] r = new ulong[][](a.length\
    \ + b.length);\n        uint i, j, k;\n        i = j = k = 0;\n        while (i\
    \ < a.length && j < b.length) {\n            if (a[i][0] <= b[j][0]) {\n     \
    \           r[k] = a[i];\n                ++i;\n            } else {\n       \
    \         r[k] = b[j];\n                ++j;\n            }\n            ++k;\n\
    \        }\n        while (\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcnckmtsl.d(60): Error: expression expected, not `unittest`

    /tmp/tmpcnckmtsl.d(61): Error: found `{` when expecting `)`

    /tmp/tmpcnckmtsl.d(71): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcnckmtsl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto nums_with_points = typeof(nums_with_points)();\n    foreach(i,\
    \ num; nums)\n    {\n        nums_with_points ~= typeof(nums_with_points).init(num,\
    \ 0);\n        foreach(ch; num.to!string)\n        {\n            nums_with_points[i].sum\
    \ += ch.to!int - '0'.to!int;\n        }\n    }\n    sort!((x, y) => x.sum > y.sum\
    \ || (x.sum == y.sum && x.idx > y.idx))(nums_with_points);\n    foreach(i, num;\
    \ nums_with_points)\n    {\n        nums[i] = num.num;\n    }\n    return nums;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8cpdtu9b.d(19): Error: undefined identifier `nums_with_points`

    /tmp/tmp8cpdtu9b.d(23): Error: no property `to` for type `long`

    /tmp/tmp8cpdtu9b.d(28): Error: template instance `sort!((x, y) => x.sum > y.sum
    || x.sum == y.sum && (x.idx > y.idx))` template `sort` is not defined, did you
    mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8cpdtu9b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    struct Item\n    {\n        long[] points;\n        long num;\n\
    \    }\n    static bool opCmp(Item a, Item b)\n    {\n        if (a.points[0]\
    \ != b.points[0])\n            return a.points[0] < b.points[0];\n        return\
    \ a.points[1] < b.points[1];\n    }\n    auto items = new Item[](nums.length);\n\
    \    foreach (idx, num; nums)\n    {\n        long sum = 0;\n        while (num\
    \ != 0)\n        {\n            sum += num % 10;\n            num /= 10;\n   \
    \     }\n        items[idx].points = [sum, idx];\n        items[idx].num = nums[idx];\n\
    \    }\n    std.algorithm.sort(items, &opCmp);\n    auto result = new long[](nums.length);\n\
    \    foreach (idx, item; items)\n        result[idx] = item.num;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpna0khe4v.d(42): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpna0khe4v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // YOUR CODE HERE\n    return [];\n}\nstatic assert(order_by_points([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n \n/*\nunittest\n{\n\
    \    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7fw2hi0.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7fw2hi0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    \n    struct Entry\n    {\n        long num;\n        long digitSum;\n\
    \        int index;\n    }\n    \n    auto counter = 0;\n    Entry[] input = nums.map!(n\
    \ => Entry(n, n.sumDigits, counter++));\n    \n    input.sort!((a, b) =>\n   \
    \     a.digitSum < b.digitSum ||\n        (a.digitSum == b.digitSum && a.index\
    \ < b.index));\n    \n    return input.map!(e => e.num).array;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmr1_uk53.d(28): Error: no property `map` for type `long[]`

    /tmp/tmpmr1_uk53.d(30): Error: no property `sort` for type `Entry[]`

    /tmp/tmpmr1_uk53.d(34): Error: no property `map` for type `Entry[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmr1_uk53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] numsClone = nums.dup;\n    if (nums.length == 0) return\
    \ numsClone;\n    long[] sums = [];\n    int i = 0;\n    foreach (num; nums)\n\
    \    {\n        long sum = 0;\n        foreach (digit; num.to!string)\n      \
    \  {\n            sum += digit.to!long;\n        }\n        sums ~= sum;\n   \
    \ }\n    auto sort = sort!(\"a < b\");\n    sort(sums);\n    numsClone.sort!(\"\
    a.to!string < b.to!string\");\n    return numsClone;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2fvia_03.d(26): Error: no property `to` for type `long`

    /tmp/tmp2fvia_03.d(32): Error: template instance `sort!"a < b"` template `sort`
    is not defined, did you mean sqrt?

    /tmp/tmp2fvia_03.d(34): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2fvia_03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  import std.algorithm;\n  import std.array;\n  import std.conv;\n\
    \  import std.range;\n  import std.string;\n  import std.typecons;\n  auto zipped\
    \ = zip(nums, iota(nums.length))\n    .map!(t => tuple(t[0], t[1],\n      t[0].to!string.map!(to!int).sum));\n\
    \  return zipped.sort!((t1, t2) => t1[2] < t2[2] ||\n    (t1[2] == t2[2] && t1[1]\
    \ < t2[1]))\n    .map!(t => t[0]).array;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0qsvehqm.d(28): Error: template `std.algorithm.sorting.sort` cannot
    deduce function from argument types `!((t1, t2) => t1[2] < t2[2] || t1[2] == t2[2]
    && (t1[1] < t2[1]))(MapResult!(__lambda2, ZipShortest!(cast(Flag)true, long[],
    Result)))`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/sorting.d(1847):        `std.algorithm.sorting.sort(alias
    less = "a < b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range r) if ((ss
    == SwapStrategy.unstable && (hasSwappableElements!Range || hasAssignableElements!Range)
    || ss != SwapStrategy.unstable && hasAssignableElements!Range) && isRandomAccessRange!Range
    && hasSlicing!Range && hasLength!Range)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0qsvehqm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    const long magic = '0';\n    long totalDigits = nums.length;\n\
    \    long[] numsAndSumOfDigits = new long[totalDigits];\n    foreach(i, num; nums)\n\
    \    {\n        numsAndSumOfDigits[i] = num + (sum(digits(num) [char] magic) *\
    \ 10_000_000_000_000_000);\n    }\n    sort(numsAndSumOfDigits);\n    foreach(j,\
    \ num; numsAndSumOfDigits)\n    {\n        numsAndSumOfDigits[j] = num / 10_000_000_000_000_000;\n\
    \    }\n    return numsAndSumOfDigits;\n}\n// version with key=\nlong[] order_by_points2(long[]\
    \ nums) \n{\n    return sort(nums, (a, b) => (sum(digits(a) [char] '0')).cmp(sum(digits(b)\
    \ [char] '0')));\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n \
    \   assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc0jzkmf8.d(24): Error: found `]` when expecting `.` following char

    /tmp/tmpc0jzkmf8.d(24): Error: found `)` when expecting `,`

    /tmp/tmpc0jzkmf8.d(24): Error: found `)` when expecting `,`

    /tmp/tmpc0jzkmf8.d(24): Error: expression expected, not `;`

    /tmp/tmpc0jzkmf8.d(25): Error: found `}` when expecting `,`

    /tmp/tmpc0jzkmf8.d(26): Error: found `;` when expecting `,`

    /tmp/tmpc0jzkmf8.d(27): Error: expression expected, not `foreach`

    /tmp/tmpc0jzkmf8.d(27): Error: found `;` when expecting `,`

    /tmp/tmpc0jzkmf8.d(28): Error: found `{` when expecting `,`

    /tmp/tmpc0jzkmf8.d(29): Error: found `;` when expecting `,`

    /tmp/tmpc0jzkmf8.d(30): Error: expression expected, not `}`

    /tmp/tmpc0jzkmf8.d(31): Error: found `return` when expecting `,`

    /tmp/tmpc0jzkmf8.d(31): Error: found `;` when expecting `,`

    /tmp/tmpc0jzkmf8.d(32): Error: expression expected, not `}`

    /tmp/tmpc0jzkmf8.d(34): Error: found `long` when expecting `,`

    /tmp/tmpc0jzkmf8.d(34): Error: found `order_by_points2` when expecting `,`

    /tmp/tmpc0jzkmf8.d(3'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    const int MAX_DIGITS = 12;\n    if (nums.length == 0)\n     \
    \   return nums;\n    long[MAX_DIGITS][nums.length] sums;\n    foreach (i, n;\
    \ nums)\n    {\n        long sum = 0;\n        long nn = abs(n);\n        for\
    \ (; nn > 0; nn /= 10)\n            sum += nn % 10;\n        sums[sum][i] = n;\n\
    \    }\n    long[] result;\n    foreach (i; 0 .. MAX_DIGITS)\n    {\n        foreach\
    \ (e; sums[i])\n        {\n            if (e != 0)\n                result ~=\
    \ e;\n        }\n    }\n    return result;\n}\n/*\n    Write a function which\
    \ checks whether the given string is a palindrome.\n    Note: a palindrome is\
    \ a string that reads the same backward or forward.\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7tlfsypr.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7tlfsypr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  auto comp_type = tuple(long,long);\n  auto comparator = (typeof(comp_type)\
    \ l, typeof(comp_type) r) {\n    return l[0] < r[0] ? 1 : (l[0] > r[0] ? -1 :\
    \ (l[1] < r[1] ? 1 : -1));\n  };\n  long[] result = new long[nums.length];\n \
    \ auto helper = new typeof(comp_type)[];\n  long sum = 0;\n  foreach(i,n; nums)\
    \ {\n    int s = n;\n    sum = 0;\n    while(s != 0) {\n      sum += s % 10;\n\
    \      s /= 10;\n    }\n    helper ~= typeof(comp_type)(sum,i);\n  }\n  helper.sort(comparator);\n\
    \  foreach(i,t; helper)\n    result[i] = nums[t[1]];\n  return result;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_uja0ieq.d(19): Error: found `,` when expecting `.` following long

    /tmp/tmp_uja0ieq.d(19): Error: found `long` when expecting identifier following
    `long`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_uja0ieq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] indices = new int[nums.length];\n    int[] sums = new int[nums.length];\n\
    \    long[] res = new long[nums.length];\n    foreach(int i, long j; nums)\n \
    \   {\n        indices[i] = i;\n        sums[i] = 0;\n        foreach(char c;\
    \ to!string(j))\n        {\n            sums[i] += c - '0';\n        }\n    }\n\
    \    enum Func\n    {\n        Less,\n        Greater\n    }\n    auto sort_indices(int[]\
    \ a, int[] b, Func func)\n    {\n        assert(a.length == b.length);\n     \
    \   int tmp;\n        for(int i = 0; i < a.length; i++)\n        {\n         \
    \   for(int j = 0; j < a.length; j++)\n            {\n                switch(func)\n\
    \                {\n                    case Func.Less:\n                    \
    \    if(a[i] < a[j])\n                        {\n                            tmp\
    \ = a[i];\n                            a[i] = a[j];\n                        \
    \    a[j] = tmp;\n                            tmp = b[i];\n                  \
    \          b[i] = b[j];\n                            b[j] = tmp;\n           \
    \             }\n                        break;\n                    case Func.Greater:\n\
    \                        if(a[i] > a[j])\n                        {\n        \
    \                    tmp = a[i];\n                            a[i] = a[j];\n \
    \                           a[j] = tmp;\n                            tmp = b[i];\n\
    \                            b[i] = b[j];\n                            b[j] =\
    \ tmp;\n                        }\n                        break;\n          \
    \      }\n            }\n        }\n    }\n    sort_indices(sums, indices, Func.Less);\n\
    \    foreach(int i; indices)\n    {\n        res[i] = nums[indices[i]];\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n \
    \   assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpueiab7q4.d(26): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpueiab7q4.d(44): Error: `switch` statement without a `default`; use `final
    switch` or add `default: assert(0);` or add `default: break;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpueiab7q4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return \n    nums\n    .map!(n => tuple(n, n.to!string.map!(c\
    \ => c.to!int).sum))\n    .sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0]\
    \ < b[0]))\n    .map!(t => t[0]);\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpguplcdvt.d(21): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpguplcdvt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    //static assert(nums.length < 2*10_000);\n    int[][] nums_pairs;\n\
    \    foreach(i, n; nums)\n    {\n        nums_pairs ~= [i, n];\n    }\n    sort!((p1,\
    \ p2) => \n    {\n        int sum1 = sum(digits(p1[1]));\n        int sum2 = sum(digits(p2[1]));\n\
    \        if(sum1 == sum2)\n        {\n            return p1[0] < p2[0];\n    \
    \    }\n        return sum1 < sum2;\n    })(nums_pairs);\n    long[] res;\n  \
    \  foreach(p; nums_pairs)\n    {\n        res ~= p[1];\n    }\n    return res;\n\
    }\n \n```\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp861fa5uz.d(43): Error: declaration expected, not `""`

    /tmp/tmp861fa5uz.d(43): Error: unterminated string constant starting at /tmp/tmp861fa5uz.d(43)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp861fa5uz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  struct num\n  {\n    long num;\n    int sum;\n    int index;\n\
    \  }\n  auto nums_array = num[nums.length];\n  for(int i = 0; i < nums.length;\
    \ i++)\n  {\n    auto n = num(nums[i], getSum(nums[i]), i);\n    nums_array[i]\
    \ = n;\n  }\n  nums_array.sort!((a, b) =>\n    ((a.sum == b.sum)?(a.index < b.index):(a.sum\
    \ < b.sum))\n  );\n  long[] result = new long[nums.length];\n  for(int i = 0;\
    \ i < nums.length; i++)\n  {\n    result[i] = nums_array[i].num;\n  }\n  return\
    \ result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxcbdofos.d(25): Error: no `[]` operator overload for type `num`

    /tmp/tmpxcbdofos.d(28): Error: undefined identifier `getSum`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxcbdofos.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    if (nums.length\
    \ == 1)\n        return nums;\n    alias Pair = Tuple!(long, long);\n    long[][long]\
    \ a;\n    foreach (i, x; nums)\n    {\n        long sum = 0;\n        foreach\
    \ (ch; to!string(x))\n            sum += ch - '0';\n        a[sum].insert(i);\n\
    \    }\n    long[] b;\n    foreach (x; sort(a.keys))\n        foreach (i; a[x])\n\
    \            b ~= nums[i];\n    return b;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdfch7ji1.d(28): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpdfch7ji1.d(30): Error: no property `insert` for type `long[]`

    /tmp/tmpdfch7ji1.d(33): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdfch7ji1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n\tint[] sumOfDigits = new int[nums.length];\n\tint[] index = new\
    \ int[nums.length];\n\tint[] temp = new int[nums.length];\n\tfor(int i = 0; i\
    \ < nums.length; i++)\n\t{\n\t\t// write your code here\n\t\tif(nums[i] < 0)\n\
    \t\t{\n\t\t\tnums[i] = -nums[i];\n\t\t}\n\t\tsumOfDigits[i] = nums[i] % 10;\n\t\
    \tnums[i] /= 10;\n\t\twhile(nums[i] > 0)\n\t\t{\n\t\t\tsumOfDigits[i] += nums[i]\
    \ % 10;\n\t\t\tnums[i] /= 10;\n\t\t}\n\t\tindex[i] = i;\n\t}\n\tint tempValue;\n\
    \tfor(int i = 0; i < sumOfDigits.length; i++)\n\t{\n\t\tfor(int j = i + 1; j <\
    \ sumOfDigits.length; j++)\n\t\t{\n\t\t\tif(sumOfDigits[i] > sumOfDigits[j])\n\
    \t\t\t{\n\t\t\t\ttempValue = sumOfDigits[i];\n\t\t\t\tsumOfDigits[i] = sumOfDigits[j];\n\
    \t\t\t\tsumOfDigits[j] = tempValue;\n\t\t\t\ttempValue = index[i];\n\t\t\t\tindex[i]\
    \ = index[j];\n\t\t\t\tindex[j] = tempValue;\n\t\t\t}\n\t\t}\n\t}\n\tlong[] temp1\
    \ = new long[nums.length];\n\tfor(int i = 0; i < nums.length; i++)\n\t{\n\t\t\
    temp1[i] = nums[index[i]];\n\t}\n\treturn temp1;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphcw92mbn.d(65): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmphcw92mbn.__unittest_L61_C1() [0x428691]

    ??:? void tmphcw92mbn.__modtest() [0x428c1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d15f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bff2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43127d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43172c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x431209]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bfc9]

    ??:? runModuleUnitTests [0x42cf35]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n\t// long[] result = new long[nums.length];\n\t// for (int i = 0;\
    \ i < nums.length; i++) {\n\t// \tresult[i] = sumDigits(nums[i]);\n\t// }\n\t\
    // for (int i = 0; i < nums.length; i++) {\n\t// \tfor (int j = i + 1; j < nums.length;\
    \ j++) {\n\t// \t\tif (result[i] < result[j]) {\n\t// \t\t\tlong temp = result[i];\n\
    \t// \t\t\tresult[i] = result[j];\n\t// \t\t\tresult[j] = temp;\n\t// \t\t}\n\t\
    // \t}\n\t// }\n\t// for (int i = 0; i < nums.length; i++) {\n\t// \tfor (int\
    \ j = i + 1; j < nums.length; j++) {\n\t// \t\tif (result[i] == result[j]) {\n\
    \t// \t\t\tif (nums[i] > nums[j]) {\n\t// \t\t\t\tlong temp = nums[i];\n\t// \t\
    \t\t\tnums[i] = nums[j];\n\t// \t\t\t\tnums[j] = temp;\n\t// \t\t\t}\n\t// \t\t\
    }\n\t// \t}\n\t// }\n\t// return nums;\n\treturn nums.sort!((x, y) => sumDigits(x)\
    \ > sumDigits(y) || sumDigits(x) == sumDigits(y) && x > y);\n}\nlong sumDigits(long\
    \ num) {\n\tlong sum = 0;\n\tint sign = signbit(num);\n\tnum = abs(num);\n\twhile\
    \ (num > 0) {\n\t\tsum += num % 10;\n\t\tnum /= 10;\n\t}\n\treturn sign ? -sum\
    \ : sum;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeq935sk8.d(44): Error: no property `sort` for type `long[]`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271):
    Error: no property `epsilon` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums\n        .map!(n => (n, sum(digits(n))))\n      \
    \  .enumerate\n        .sort!((a, b) => (a[1][1] == b[1][1]) ? a[0] < b[0] : a[1][1]\
    \ < b[1][1])\n        .map!(p => p[1][0])\n        .array;\n}\n \nlong[] digits(long\
    \ n) \n{\n    long[] result;\n    auto s = to!string(n);\n    foreach (c; s)\n\
    \        result ~= c.to!long;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxjwpc0az.d(20): Error: no property `map` for type `long[]`

    /tmp/tmpxjwpc0az.d(30): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxjwpc0az.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] input = nums;\n    //Tuple!(long, long) temp;\n    long[]\
    \ sums = new long[input.length];\n    /*\n    temp = new Tuple!(long, long);\n\
    \    temp[0] = sum;\n    temp[1] = index;\n    */\n    for (int i = 0; i < input.length;\
    \ i++)\n    {\n        long sum = 0;\n        long num = abs(input[i]);\n    \
    \    while (num != 0)\n        {\n            sum += num % 10;\n            num\
    \ /= 10;\n        }\n        sums[i] = sum;\n    }\n    for (int i = 0; i < input.length;\
    \ i++)\n    {\n        for (int j = 0; j < input.length; j++)\n        {\n   \
    \         if (sums[i] < sums[j])\n            {\n                long temp = sums[i];\n\
    \                sums[i] = sums[j];\n                sums[j] = temp;\n       \
    \         temp = input[i];\n                input[i] = input[j];\n           \
    \     input[j] = temp;\n            }\n        }\n    }\n    return input;\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoi2hjte4.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x428a15]

    ??:? void tmpoi2hjte4.__unittest_L55_C1() [0x4281f5]

    ??:? void tmpoi2hjte4.__modtest() [0x428798]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42caf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430c11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4310c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430b9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b95d]

    ??:? runModuleUnitTests [0x42c8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ed8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  if (nums.length==0)\n    return nums;\n  else\n  {\n    auto tmp=new\
    \ long[nums.length];\n    for (int i=0;i<nums.length;i++)\n    {\n      tmp[i]=nums[i];\n\
    \    }\n    auto arr = std.sort(tmp, (a, b) => {\n      if (sum_of_digits(a)==sum_of_digits(b))\n\
    \        return 0;\n      else if (sum_of_digits(a)<sum_of_digits(b))\n      \
    \  return -1;\n      else\n        return 1;\n    });\n    return arr;\n  }\n\
    }\nlong sum_of_digits(long n)\n{\n  long num=abs(n);\n  long sum=0;\n  while (num!=0)\n\
    \  {\n    sum+=num%10;\n    num/=10;\n  }\n  return sum;\n}\nunittest\n{\n   \
    \ alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9byop0mj.d(28): Error: undefined identifier `sort` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9byop0mj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[][] sums_and_indexes = new int[][](nums.length);\n    for\
    \ (int i = 0; i < nums.length; i++) {\n        int sum = 0;\n        long num\
    \ = nums[i];\n        if (num < 0) num = -num;\n        while (num != 0) {\n \
    \           sum += num % 10;\n            num /= 10;\n        }\n        sums_and_indexes[i]\
    \ = [sum, i];\n    }\n    return sort!(\"(a, b) => (a[0] == b[0]) ? (a[1] < b[1])\
    \ : (a[0] < b[0])\")(sums_and_indexes)\n            .map!(t => nums[t[1]]).array;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz0jjhu96.d(30): Error: template instance `sort!"(a, b) => (a[0]
    == b[0]) ? (a[1] < b[1]) : (a[0] < b[0])"` template `sort` is not defined, did
    you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz0jjhu96.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] list = new long[nums.length];\n    list = nums;\n    int[]\
    \ digits = new int[nums.length];\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        int total = 0;\n        foreach(char c; to!string(abs(nums[i])))\n\
    \        {\n            total += c.to!int;\n        }\n        digits[i] = total;\n\
    \    }\n    int[][] combined = [digits,list];\n    for (int j = 0; j < combined[0].length;\
    \ j++)\n    {\n        for (int k = j + 1; k < combined[0].length; k++)\n    \
    \    {\n            if (combined[0][j] > combined[0][k])\n            {\n    \
    \            combined[0][j] += combined[0][k];\n                combined[0][k]\
    \ = combined[0][j] - combined[0][k];\n                combined[0][j] -= combined[0][k];\n\
    \                combined[1][j] += combined[1][k];\n                combined[1][k]\
    \ = combined[1][j] - combined[1][k];\n                combined[1][j] -= combined[1][k];\n\
    \            }\n        }\n    }\n    long[] finalList = new long[combined[1].length];\n\
    \    for (int l = 0; l < combined[1].length; l++)\n    {\n        finalList[l]\
    \ = combined[1][l];\n    }\n    return finalList;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0rvs9m_y.d(25): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmp0rvs9m_y.d(31): Error: incompatible types for `(digits) : (list)`: `int[]`
    and `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0rvs9m_y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result;\n    auto t = new Tuple!(ulong, long)(0, 0);\n\
    \    auto map = nums.map!(a => tuple(a.sumDigits(), a)).sort!(a => a[0]).array;\n\
    \    result = map.map!(a => a[1]).array;\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmg03mg0_.d(21): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmg03mg0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] new_nums;\n    if (nums.length > 0) {\n        new_nums\
    \ = nums.dup;\n        new_nums.sort!((x, y) => {\n            auto sum_x = x.digits().sum;\n\
    \            auto sum_y = y.digits().sum;\n            if (sum_x > sum_y) {\n\
    \                return 1;\n            } else if (sum_x < sum_y) {\n        \
    \        return -1;\n            } else {\n                return 0;\n       \
    \     }\n        });\n    } else {\n        new_nums = [];\n    }\n    return\
    \ new_nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjrbzg6_m.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjrbzg6_m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    nums = nums.dup;\n    if (nums.length > 1)\n    {\n        auto\
    \ sums = nums.map!((x) => (sumDigits(x), x)).enumerate;\n        sums.sort!((lhs,\
    \ rhs) => (lhs[0] == rhs[0]) ? (lhs[1] < rhs[1]) : (lhs[0] < rhs[0]));\n     \
    \   auto order = sums.map!((x) => x[1]).enumerate;\n        order.sort!((lhs,\
    \ rhs) => lhs[0] < rhs[0]);\n        return order.map!((x) => x[1]).array;\n \
    \   }\n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv8t7tba4.d(22): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv8t7tba4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.\n        zip(iota(nums.length)).\n        sort!((a,\
    \ b) => (sumDigits(a[0]) == sumDigits(b[0])) ? a[1] < b[1] : sumDigits(a[0]) <\
    \ sumDigits(b[0])).\n        map!(e => e[0]).\n        array;\n}\nlong sumDigits(long\
    \ n)\n{\n    return n > 0 ? n % 10 + sumDigits(n / 10) : 0;\n}\nunittest\n{\n\
    \    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoide1nas.d(19): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoide1nas.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  struct Container(long item, int points, int index)\n  {\n    long\
    \ item;\n    int points;\n    int index;\n  }\n  if (nums.length == 0)\n    return\
    \ [];\n  auto a = new Container[nums.length];\n  for (int i = 0; i < nums.length;\
    \ i++)\n  {\n    auto item = nums[i];\n    int points = 0;\n    while (item !=\
    \ 0)\n    {\n      points += item % 10;\n      item /= 10;\n    }\n    a[i] =\
    \ Container(nums[i], points, i);\n  }\n  a.sort!((ref a, ref b) => a.points <\
    \ b.points);\n  long[] result = new long[nums.length];\n  foreach (j, ref i; a)\n\
    \    result[j] = i.item;\n  return result;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz5fce7pr.d(27): Error: template struct `tmpz5fce7pr.order_by_points.Container(long
    item, int points, int index)` is used as a type without instantiation; to instantiate
    it use `Container!(arguments)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz5fce7pr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    \n    auto sorted\
    \ = nums.dup;\n    auto sort_function = (int x, int y) {\n        auto ax = x.to!string;\n\
    \        auto ay = y.to!string;\n        auto sum_x = ax.map!(a => a.to!int).sum;\n\
    \        auto sum_y = ay.map!(a => a.to!int).sum;\n        return sum_x < sum_y\
    \ || (sum_x == sum_y && x < y);\n    };\n    std.algorithm.sort!sort_function(sorted);\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n\
    \    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpek27uctd.d(24): Error: no property `to` for type `int`

    /tmp/tmpek27uctd.d(25): Error: no property `to` for type `int`

    /tmp/tmpek27uctd.d(30): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpek27uctd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) return nums;\n    auto t = new Tuple!(long,\
    \ long)(0, 0);\n    auto arr = new Tuple!(long, long)[nums.length];\n    long\
    \ index = 0;\n    foreach (item; nums) {\n        t[0] = item;\n        t[1] =\
    \ item;\n        if (item < 0) t[1] = -t[1];\n        arr[index] = t;\n      \
    \  index++;\n    }\n    sort!((a, b) => {\n        auto da = 0L;\n        auto\
    \ db = 0L;\n        while (a[1] > 0) {\n            da += a[1] % 10;\n       \
    \     a[1] /= 10;\n        }\n        while (b[1] > 0) {\n            db += b[1]\
    \ % 10;\n            b[1] /= 10;\n        }\n        return (da == db) ? (a[0]\
    \ < b[0]) : (da < db);\n    })(arr);\n    return arr.map!(t => t[0]).array;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm1gjbnam.d(24): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(long)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmpm1gjbnam.d(25): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(long)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmpm1gjbnam.d(26): Error: `t[1]` is not of arithmetic type, it is a `Tuple!(long,
    long)`

    /tmp/tmpm1gjbnam.d(27): Error: templat'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // write your code here\n    int[] sum_of_nums = new int[nums.length];\n\
    \    int[] sum_of_nums_copy = new int[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++) {\n        sum_of_nums[i] = (int) (nums[i] % 10) + (int) ((nums[i] / 10)\
    \ % 10) + (int) ((nums[i] / 100) % 10);\n        sum_of_nums_copy[i] = sum_of_nums[i];\n\
    \    }\n    sort(sum_of_nums);\n    long[] result = new long[nums.length];\n \
    \   for (int i = 0; i < nums.length; i++) {\n        for (int j = 0; j < nums.length;\
    \ j++) {\n            if (sum_of_nums[i] == sum_of_nums_copy[j]) {\n         \
    \       result[i] = nums[j];\n                sum_of_nums_copy[j] = 0;\n     \
    \           break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyhbnr3mh.d(23): Error: C style cast illegal, use `cast(int)(nums[i]
    % 10)`

    /tmp/tmpyhbnr3mh.d(23): Error: C style cast illegal, use `cast(int)(nums[i] /
    10 % 10)`

    /tmp/tmpyhbnr3mh.d(23): Error: C style cast illegal, use `cast(int)(nums[i] /
    100 % 10)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhbnr3mh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto nums2 = nums.dup;\n    for (int i = 0; i < nums.length;\
    \ i++) \n    {\n        long n = nums[i];\n        long total = 0;\n        while\
    \ (n != 0)\n        {\n            total += n % 10;\n            n /= 10;\n  \
    \      }\n        nums2[i] = total;\n    }\n    auto r = sort!(\"a[0] > b[0] ||\
    \ (a[0] == b[0] && a[1] < b[1]\")\n            ([tuple(nums2[i], i) for (i = 0;\
    \ i < nums.length)]);\n    long[] res = new long[](nums.length);\n    for (int\
    \ i = 0; i < nums.length; i++)\n    {\n        res[i] = nums[r[i][1]];\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n \
    \   assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ojpvirs.d(32): Error: found `for` when expecting `,`

    /tmp/tmp7ojpvirs.d(32): Error: found `;` when expecting `)`

    /tmp/tmp7ojpvirs.d(32): Error: found `i` when expecting `,`

    /tmp/tmp7ojpvirs.d(32): Error: expression expected, not `<`

    /tmp/tmp7ojpvirs.d(32): Error: found `nums` when expecting `,`

    /tmp/tmp7ojpvirs.d(32): Error: found `)` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ojpvirs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    /*\n    long[] res = [];\n    for (i in nums)\n    {\n      \
    \  if (nums[i] < 0)\n        {\n            res.insert(0, nums[i]);\n        }\n\
    \        else\n        {\n            res.insert(1, nums[i]);\n        }\n   \
    \ }\n    return res;\n    */\n    if (nums.length == 0)\n    {\n        return\
    \ nums;\n    }\n    int len = nums.length;\n    for (int i = 0; i < len; i++)\n\
    \    {\n        for (int j = i + 1; j < len; j++)\n        {\n            if (sum(abs(nums[i]))\
    \ > sum(abs(nums[j])))\n            {\n                long tmp = nums[i];\n \
    \               nums[i] = nums[j];\n                nums[j] = tmp;\n         \
    \   }\n        }\n    }\n    return nums;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv24vz9cn.d(38): Error: cannot implicitly convert expression `nums.length`
    of type `ulong` to `int`

    /tmp/tmpv24vz9cn.d(43): Error: undefined identifier `sum`

    /tmp/tmpv24vz9cn.d(43): Error: undefined identifier `sum`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv24vz9cn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long d_size = nums.length;\n    long[] result = new long[d_size];\n\
    \    typeof(result) indexs = new typeof(result);\n    for (size_t i = 0; i < d_size;\
    \ i++)\n    {\n        result[i] = 0;\n        indexs[i] = i;\n    }\n    foreach\
    \ (i, ref s; result)\n    {\n        long temp = nums[i];\n        if (temp <\
    \ 0)\n            temp = -temp;\n        for (; temp > 0; temp /= 10)\n      \
    \      s += temp % 10;\n    }\n    quickSort(result, indexs);\n    foreach (i,\
    \ ref s; indexs)\n        s = nums[s];\n    return indexs;\n}\nunittest\n{\n \
    \   alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7nneji95.d(21): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp7nneji95.d(35): Error: undefined identifier `quickSort`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nneji95.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] res = new long[nums.length];\n    Tuple!(long, long)[]\
    \ nums2 = new Tuple!(long, long)[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        long sum = 0;\n        foreach (long d; to!long(i.to!string))\n\
    \        {\n            sum += d;\n        }\n        nums2[i] = tuple(nums[i],\
    \ sum);\n    }\n    nums2.sort!((a, b) => a[1] < b[1]);\n    for (int i = 0; i\
    \ < nums.length; i++)\n    {\n        res[i] = nums2[i][0];\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptzselhb_.d(24): Error: template instance `to!long` template `to`
    is not defined, did you mean No?

    /tmp/tmptzselhb_.d(30): Error: no property `sort` for type `Tuple!(long, long)[]`

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] points;\n    long[][] digits;\n    foreach(n; nums)\n\
    \    {\n        points ~= n.abs.sumDigits;\n        digits ~= n.digits;\n    }\n\
    \    long[][] indices = points.tupleof.zip.sort;\n    return indices.map!((tuple)\
    \ => nums[tuple[1]])();\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp507aycwl.d(23): Error: no property `sumDigits` for type `long`

    /tmp/tmp507aycwl.d(24): Error: no property `digits` for type `long`

    /tmp/tmp507aycwl.d(26): Error: no property `tupleof` for type `long[]`

    /tmp/tmp507aycwl.d(27): Error: no property `map` for type `long[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp507aycwl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.sort!\"a.sumOfDigits > b.sumOfDigits || a.sumOfDigits\
    \ == b.sumOfDigits && a > b\".array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9w887ewm.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9w887ewm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    auto nums_with_points\
    \ = nums.map!(n => tuple(n, nums.sum, n));\n    nums_with_points.sort!(a => a[1]);\n\
    \    return nums_with_points.map!(t => t[2]).array;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgajxlcn.d(21): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgajxlcn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result = new long[nums.length];\n    int[] sum = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++) {\n        long temp = nums[i];\n \
    \       int tempsum = 0;\n        while (temp > 0) {\n            tempsum += temp\
    \ % 10;\n            temp /= 10;\n        }\n        sum[i] = tempsum;\n    }\n\
    \    size_t[] indices = new size_t[nums.length];\n    foreach(index, value; sum)\
    \ {\n        indices[index] = index;\n    }\n    std.algorithm.sort!(\"a[i] <\
    \ a[j]\")(indices, sum);\n    foreach(index, value; indices) {\n        result[index]\
    \ = nums[value];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvwo1r7av.d(34): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwo1r7av.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] points = new int[nums.length];\n    //int[] index = new\
    \ int[nums.length];\n    //for (int i = 0; i < nums.length; i++) {\n        //index[i]\
    \ = i;\n    //}\n    for (int i = 0; i < nums.length; i++) {\n        long x =\
    \ nums[i];\n        int sum = 0;\n        while (x != 0) {\n            sum +=\
    \ x % 10;\n            x /= 10;\n        }\n        points[i] = sum;\n    }\n\
    \    long[] nums_new = nums[0..nums.length];\n    sort(nums_new, (a, b) => a.to!int\
    \ == b.to!int ? 0 : (a.to!int < b.to!int ? -1 : 1));\n    return nums_new;\n}\n\
    /*\n    Write a function which takes an integer `x` and returns the next\n   \
    \ power of 2 of it (if `x` is already a power of 2, leave it as is).\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp933mpzfh.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp933mpzfh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    struct Item {\n        long sum;\n        long index;\n    }\n\
    \    auto compareItem = (Item a, Item b) => a.sum < b.sum ? -1 : 1;\n    auto\
    \ items = nums.map!(x => Item(x.sumDigits, x.index)).array;\n    sort(items, compareItem);\n\
    \    return items.map!(x => nums[x.index]).array;\n}\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf3dvm3k9.d(24): Error: no property `map` for type `long[]`

    /tmp/tmpf3dvm3k9.d(25): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf3dvm3k9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  int[] nums_int = nums.map!((x) => x.to!int).array;\n  long[] result;\n\
    \  ulong[] nums_uint;\n  long[] sum_digits;\n  static int sum(int x) \n  {\n \
    \   int sum = 0;\n    if (x < 0)\n    {\n      x = -x;\n    }\n    while (x >\
    \ 0)\n    {\n      sum += x % 10;\n      x /= 10;\n    }\n    return sum;\n  }\n\
    \  result = nums.dup;\n  nums_uint = nums.map!((x) => (x < 0) ? -x : x).map!((x)\
    \ => x.to!ulong).array;\n  sum_digits = nums_uint.map!((x) => sum(x.to!int)).array;\n\
    \  sort!(\"(a, b) => b - a\")(sum_digits, result);\n  return result;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv1rqycgw.d(19): Error: no property `map` for type `long[]`

    /tmp/tmpv1rqycgw.d(38): Error: no property `map` for type `long[]`

    /tmp/tmpv1rqycgw.d(39): Error: no property `map` for type `ulong[]`

    /tmp/tmpv1rqycgw.d(40): Error: template instance `sort!"(a, b) => b - a"` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv1rqycgw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) \n    {\n        return [];\n    }\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5v491lb3.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5v491lb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[long[]] nums_container = new long[nums.length][];\n    foreach(idx,\
    \ n; nums) {\n        nums_container[idx] = [n, sumOfDigits(n)];\n    }\n    nums_container.sort!(\"\
    a[1] < b[1]\");\n    long[] result = new long[nums.length];\n    foreach(idx,\
    \ n; nums_container) {\n        result[idx] = n[0];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdriafhbc.d(19): Error: variable `nums` cannot be read at compile
    time

    /tmp/tmpdriafhbc.d(21): Error: cannot implicitly convert expression `idx` of type
    `ulong` to `const(long)[]`

    /tmp/tmpdriafhbc.d(23): Error: no property `sort` for type `long[const(long)[]]`

    /tmp/tmpdriafhbc.d(26): Error: cannot implicitly convert expression `idx` of type
    `const(long)[]` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdriafhbc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result = new long[nums.length];\n    int[] sumDigit =\
    \ new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n       \
    \ int sum = 0;\n        long x = nums[i];\n        for (int j = 0; j < nums.length;\
    \ j++) {\n            if (x < 0) {\n                x = -x;\n            }\n \
    \           sum += x % 10;\n            x /= 10;\n        }\n        sumDigit[i]\
    \ = sum;\n    }\n    int[] index = new int[nums.length];\n    for (int i = 0;\
    \ i < nums.length; i++) {\n        int min = sumDigit[i];\n        int point =\
    \ 0;\n        for (int j = i; j < nums.length; j++) {\n            if (min > sumDigit[j])\
    \ {\n                min = sumDigit[j];\n                point = j;\n        \
    \    }\n        }\n        index[i] = point;\n        sumDigit[point] = 999;\n\
    \    }\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[index[i]];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg5_b7bu2.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x428c8d]

    ??:? void tmpg5_b7bu2.__unittest_L51_C1() [0x428485]

    ??:? void tmpg5_b7bu2.__modtest() [0x428a10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cf4f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bde2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43106d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43151c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bdb9]

    ??:? runModuleUnitTests [0x42cd25]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429150]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{ \n    enum KeyType = tuple!(long, long);\n    auto original_order\
    \ = new KeyType[](nums.length);\n    for (int i = 0; i < nums.length; i++)\n \
    \   {\n        original_order[i] = tuple(nums[i], i);\n    }\n    return original_order.sort!((a,\
    \ b) =>\n    {\n        int aSum = 0;\n        int bSum = 0;\n        int num\
    \ = a[0];\n        while (num != 0)\n        {\n            aSum += num % 10;\n\
    \            num /= 10;\n        }\n        num = b[0];\n        while (num !=\
    \ 0)\n        {\n            bSum += num % 10;\n            num /= 10;\n     \
    \   }\n        if (aSum == bSum)\n        {\n            return a[1] > b[1];\n\
    \        }\n        return aSum > bSum;\n    }).map!(x => x[0]).array;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5h4lblha.d(20): Error: `KeyType` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5h4lblha.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  return nums.sort!((a, b) => sumDigits(a) < sumDigits(b));\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmposwny9n1.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmposwny9n1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto reversed = map!q{a => a[0]}\n    (sort!q{(a, b) => (b[1]\
    \ > a[1]) || (b[1] == a[1] && b[0] > a[0])}\n    (map!q{a => tuple(a, reduce!((a,\
    \ b) => a + b)(a.digits))}\n    (nums)));\n    return map!q{a => reversed[a]}\n\
    \    (iota(nums.length));\n}\n/*\n    How many zeros at the end of the factorial\
    \ of a given number?\nunittest\n{\n    alias candidate = order_by_points;\n\n\
    \    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuitff4cy.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuitff4cy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.sort!((a, b) => a.length > b.length)[0];\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_osve9si.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_osve9si.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) return nums;\n    nums[].sort( (x, y) =>\n\
    \    {\n        int xd = sum(x.digits);\n        int yd = sum(y.digits);\n   \
    \     return xd < yd ? -1 : xd > yd ? 1 : 0;\n    });\n    return nums;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5o6fhtoq.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5o6fhtoq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto digit_sum = (long x) =>\n    {\n        long result = 0;\n\
    \        while (x != 0)\n        {\n            result += x % 10;\n          \
    \  x /= 10;\n        }\n        return result;\n    };\n    return sort(nums,\
    \ (a, b) => tuple(digit_sum(a), a).opCmp(tuple(digit_sum(b), b)));\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9_wwkifz.d(29): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_wwkifz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    /*\n        Sums is used to hold the sums of the digits of each\
    \ number in the array.\n        We pre-initialize the array of sums to the length\
    \ of the nums array.\n        Sorted_nums is used to hold the sorted numbers from\
    \ lowest to highest.\n        We pre-initialize the array of sorted_nums to the\
    \ length of the nums array.\n        Greatest_sum is a variable used to hold the\
    \ value of the greatest sum of digits\n        in the array.\n        Smallest_sum\
    \ is a variable used to hold the value of the smallest sum of digits\n       \
    \ in the array.\n        The variable i is used to index through the arrays.\n\
    \        The variable j is used to check whether the nums array has been completely\n\
    \        iterated through.\n        The variable k is used to check whether the\
    \ sums array has been completely\n        iterated through.\n        The variable\
    \ digit_sum is used to hold the sum of the digits in the current\n        index\
    \ of the nums array.\n        The variable starting_index is used to hold the\
    \ starting index of the \n        first number with the same sum of digits in\
    \ the array.\n        The variable ending_index is used to hold the ending index\
    \ of the \n        first number with the same sum of digits in the array.\n  \
    \      The variable starting_sum is used to hold the sum of the digits of the\
    \ \n        number at the starting_index.\n        The variable ending_sum is\
    \ used to hold the sum of the digits of the \n        number at the ending_index.\n\
    \        The variable index_num is used to track how many index numbers there\
    \ are\n        with the same digit sum.\n    */\n    long[] sums = new long[nums.length];\n\
    \    long[] sorted_nums = new long[nums.length];\n    long greatest_sum = 0;\n\
    \    long smallest_sum = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    long digit_sum = 0;\n    int starting_index = 0;\n    int ending_index =\
    \ 0;\n    long starting_sum = 0;\n    long ending_sum = 0;\n    int index_num\
    \ = 0;\n    //This loop iterates through the nums array, counting the sum of the\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxsl7117r.d(60): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxsl7117r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // Sort the array of tuples `nums` by their second element (its\
    \ sum of digits)\n    // Return the sorted array of tuples\n    auto mapArray\
    \ = zip(nums, nums.map!((x) => to!string(x).split(\"\").map!(x => to!int(x)).sum()).array);\n\
    \    sort!((x, y) => (x[1] < y[1] || (x[1] == y[1] && x[0] > y[0])));\n    return\
    \ mapArray.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg6tbq_4_.d(21): Error: undefined identifier `zip`

    /tmp/tmpg6tbq_4_.d(22): Error: template instance `sort!((x, y) => x[1] < y[1]
    || x[1] == y[1] && (x[0] > y[0]))` template `sort` is not defined, did you mean
    sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg6tbq_4_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] sums;\n    sums.length = nums.length;\n    for (long i\
    \ = 0; i < nums.length; i++)\n    {\n        sums[i] = sum(typeof(nums[i]).digits(nums[i]));\n\
    \    }\n    auto zipped = zip(sums, nums);\n    sort!(\"a[0] < b[0]\")(zipped);\n\
    \    long[] result;\n    result.length = nums.length;\n    for (long i = 0; i\
    \ < nums.length; i++)\n    {\n        result[i] = zipped[i][1];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2gncw1oe.d(23): Error: undefined identifier `sum`, did you mean
    variable `sums`?

    /tmp/tmp2gncw1oe.d(25): Error: undefined identifier `zip`

    /tmp/tmp2gncw1oe.d(26): Error: template instance `sort!"a[0] < b[0]"` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2gncw1oe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] res = new long[nums.length];\n    immutable int[] digits;\n\
    \    immutable int sum;\n    int[] sums = new int[nums.length];\n    int[] sums_ind\
    \ = new int[nums.length];\n    int j = 0;\n    foreach(immutable int i; 0..nums.length)\n\
    \    {\n        sum = 0;\n        digits = nums[i].toString().map!(i => i.to!int()).array;\n\
    \        foreach(immutable int n; digits)\n        {\n            sum += n;\n\
    \        }\n        sums[j] = sum;\n        sums_ind[j] = i;\n        j++;\n \
    \   }\n    return std.algorithm.sort!((a, b) => a[0] < b[0])(tuple(sums, sums_ind))[1].array.map!(i\
    \ => nums[i]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjlqt4ccj.d(25): Error: cannot implicitly convert expression `nums.length`
    of type `ulong` to `immutable(int)`

    /tmp/tmpjlqt4ccj.d(37): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjlqt4ccj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long maxDigits(long n)\n    {\n        long ret = 0;\n      \
    \  while(n > 0)\n        {\n            ret += n % 10;\n            n /= 10;\n\
    \        }\n        return ret;\n    }\n    return sort!(((a, b) => a.item1.idx\
    \ > b.item1.idx))(nums.map!(x => tuple(x, maxDigits(x))));\n}\nunittest\n{\n \
    \   alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgn4kawpn.d(29): Error: template instance `sort!((a, b) => a.item1.idx
    > b.item1.idx)` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgn4kawpn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto sorted = nums.dup;\n    auto points = sorted.map!((i) =>\
    \ new Tuple!(int, int)(sumOfDigits(i), i));\n    points.sort!((a, b) => a[0] <\
    \ b[0] || (a[0] == b[0] && a[1] < b[1]));\n    sorted = points.map!((i) => i[1]).array;\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n\
    \    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2on2c7nv.d(20): Error: no property `map` for type `long[]`

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[][] copy = [];\n    nums.sort();\n    foreach(num; nums)\n\
    \    {\n        if(copy.length == 0)\n        {\n            copy ~= [num,num.digits];\n\
    \        }\n        else\n        {\n            bool placed = false;\n      \
    \      foreach(i,cpy; copy)\n            {\n                if(num.digits >= cpy[1])\n\
    \                {\n                    copy.insert(i,[num,num.digits]);\n   \
    \                 placed = true;\n                    break;\n               \
    \ }\n            }\n            if(!placed)\n            {\n                copy\
    \ ~= [num,num.digits];\n            }\n        }\n    }\n    return copy.map!(tuple\
    \ => tuple[0]);\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n  \
    \  assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp18gk2wgm.d(20): Error: no property `sort` for type `long[]`

    /tmp/tmp18gk2wgm.d(25): Error: no property `digits` for type `long`

    /tmp/tmp18gk2wgm.d(32): Error: no property `digits` for type `long`

    /tmp/tmp18gk2wgm.d(34): Error: no property `insert` for type `long[][]`

    /tmp/tmp18gk2wgm.d(41): Error: no property `digits` for type `long`

    /tmp/tmp18gk2wgm.d(45): Error: no property `map` for type `long[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18gk2wgm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return nums.sort!((x, y) => sumDigits(x) < sumDigits(y)).array;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9x6ptw8.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9x6ptw8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto key = (l) =>\n    {\n        l = abs(l);\n        long sum\
    \ = 0;\n        while (l != 0)\n        {\n            sum += l % 10;\n      \
    \      l /= 10;\n        }\n        return sum;\n    };\n    auto cmp = (a, b)\
    \ =>\n    {\n        if (key(a) < key(b)) return -1;\n        if (key(a) > key(b))\
    \ return 1;\n        return a < b ? -1 : 1;\n    };\n    return nums.quicksort(cmp);\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm36uego0.d(19): Error: variable `tmpm36uego0.order_by_points.key`
    type `void` is inferred from initializer `(l) => ()

    {

    l = abs(l);

    long sum = 0;

    while (l != 0)

    {

    sum += l % 10;

    l /= 10;

    }

    return sum;

    }

    `, and variables cannot be of type `void`

    /tmp/tmpm36uego0.d(19): Error: template lambda has no value

    /tmp/tmpm36uego0.d(30): Error: variable `tmpm36uego0.order_by_points.cmp` type
    `void` is inferred from initializer `(a, b) => ()

    {

    if (key(a) < key(b))

    return -1;

    if (key(a) > key(b))

    return 1;

    return a < b ? -1 : 1;

    }

    `, and variables cannot be of type `void`

    /tmp/tmpm36uego0.d(30): Error: template lambda has no value

    /tmp/tmpm36uego0.d(36): Error: no property `quicksort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm36uego0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    \n    ulong[] result = new ulong[];\n    auto digits=nums.map!((n)=>\n\
    \    {\n        ulong r = 0;\n        for(int i=0;i<4;i++)\n        {\n      \
    \      r+=n%10;\n            n/=10;\n        }\n        return r;\n    });\n \
    \   auto t=typeof(digits);\n    auto t2=typeof(nums);\n    for(int i=0;i<digits.length;i++)\n\
    \    {\n        int min_pos=i;\n        for(int j=i+1;j<digits.length;j++)\n \
    \       {\n            if(digits[j]<digits[min_pos])\n            {\n        \
    \        min_pos=j;\n            }\n        }\n        ulong temp=digits[i];\n\
    \        digits[i]=digits[min_pos];\n        digits[min_pos]=temp;\n        ulong\
    \ temp2=nums[i];\n        nums[i]=nums[min_pos];\n        nums[min_pos]=temp2;\n\
    \    }\n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjb2yo7df.d(20): Error: new can only create structs, dynamic arrays
    or class objects, not `ulong[]`''s

    /tmp/tmpjb2yo7df.d(21): Error: no property `map` for type `long[]`

    /tmp/tmpjb2yo7df.d(32): Error: type `long[]` has no value

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjb2yo7df.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) return new long[0];\n    auto temp = nums.dup;\n\
    \    auto temp2 = nums.dup;\n    for (int i = 0; i < nums.length; i++) \n    {\n\
    \        auto pos = 0;\n        for (int j = 0; j < temp.length; j++) \n     \
    \   {\n            if (temp[i] >= temp[j]) pos++;\n        }\n        temp2[pos]\
    \ = temp[i];\n    }\n    return temp2;\n}\nunittest\n{\n    alias candidate =\
    \ order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpakjcwv96.d(29): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x429a52]

    ??:? long[] tmpakjcwv96.order_by_points(long[]) [0x4280f3]

    ??:? void tmpakjcwv96.__unittest_L33_C1() [0x4281a4]

    ??:? void tmpakjcwv96.__modtest() [0x428918]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e5df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42962a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b369]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b3f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b2f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429601]

    ??:? runModuleUnitTests [0x42e3b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto cmp = (T)(T n1, T n2) {\n        return T.length < n2.length\
    \ ? -1 : T.length > n2.length ? 1 : 0;\n    };\n    return sort!cmp(nums);\n}\n\
    /*\n    Write a function named `rps` (rock paper scissors) which takes an integer\n\
    \    (representing the number of rounds) and two functions as arguments.\n   \
    \ It should play the Rock-Paper-Scissors game with provided functions as players\n\
    \    and return true if the first player wins and false otherwise.\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5kjqy_ww.d(21): Error: C style cast illegal, use `cast(T)(T n1,
    T n2)

    {

    return T.length < n2.length ? -1 : T.length > n2.length ? 1 : 0;

    }

    `

    /tmp/tmp5kjqy_ww.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5kjqy_ww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] sums = new int[nums.length];\n    auto points = new int[];\n\
    \    auto result = new long[];\n    for (int i = 0; i < nums.length; i++)\n  \
    \  {\n        int sum = 0;\n        foreach (c; nums[i].to!string)\n        {\n\
    \            if (isDigit(c))\n            {\n                sum += c.to!int -\
    \ '0'.to!int;\n            }\n        }\n        sums[i] = sum;\n        points\
    \ ~= i;\n    }\n    auto toSort = zip(sums, points);\n    std.algorithm.sort!((x,\
    \ y) => x[0] > y[0] || (x[0] == y[0] && x[1] > y[1]))(toSort);\n    foreach (i;\
    \ toSort)\n    {\n        result ~= nums[i[1]];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd1k5wz2g.d(20): Error: new can only create structs, dynamic arrays
    or class objects, not `int[]`''s

    /tmp/tmpd1k5wz2g.d(21): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpd1k5wz2g.d(25): Error: no property `to` for type `long`

    /tmp/tmpd1k5wz2g.d(35): Error: undefined identifier `zip`

    /tmp/tmpd1k5wz2g.d(36): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd1k5wz2g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto l1 = new Array!(tuple(long, size_t))(nums.length);\n   \
    \ foreach(i, e; nums)\n    {\n        auto sum = 0L;\n        foreach(c; e.to!string())\n\
    \        {\n            if(c.isDigit)\n                sum += c.to!long;\n   \
    \     }\n        l1[i] = tuple(e, sum);\n    }\n    auto l2 = l1.sort!(\"a[1]\
    \ < b[1]\");\n    return l2.map!(a => a[0]).array;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl76fujh_.d(19): Error: found `,` when expecting `.` following long

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl76fujh_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    size_t i;\n    long[] res;\n    if(nums.length == 0)\n      \
    \  return nums;\n    else\n    {\n        res = new long[nums.length];\n     \
    \   foreach(ref item; nums)\n        {\n            if(item < 0)\n           \
    \     item = -item;\n            res ~= item;\n        }\n        auto result\
    \ = std.algorithm.sort!((x, y) => (x%10 + x/10) < (y%10 + y/10))(res);\n     \
    \   auto origIndex = std.algorithm.sort!((x, y) => x < y)(result.save);\n    \
    \    return nums[origIndex];\n    }\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0es7f1t9.d(32): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmp0es7f1t9.d(33): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0es7f1t9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto v = nums.map!(n => tuple(n, n.sumOfDigits)).sort!((a, b)\
    \ => a[1] < b[1]);\n    return v.map!(t => t[0]).array;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ajp_uwz.d(19): Error: no property `map` for type `long[]`

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // TODO\n}\n/*\n    The lenght of the given array is checked,\
    \ if it is not 0, then the array is sorted\n    according to the sum of its digits,\
    \ if several items have similar sum, the order is based\n    on their index in\
    \ the original array.\n*/\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpux_06rqp.d(17): Error: function `tmpux_06rqp.order_by_points` has
    no `return` statement, but is expected to return a value of type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpux_06rqp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n\ttypeof(nums) numeros = [ 3L, 2L, 1L ];\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm1x77hib.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm1x77hib.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    import std.algorithm;\n    import std.conv;\n    import std.array;\n\
    \    auto converted_nums = nums.map!(i => tuple(i, i.to!string().map!(c => c.to!int()).sum)).\n\
    \        enforce!(tuple!(long, int)).\n        sort!(t => t[1]);\n    return converted_nums.map!(i\
    \ => i[0]).array;\n}\n \nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3jt9do1e.d(22): Error: no property `enforce` for type `MapResult!(__lambda2,
    long[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3jt9do1e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{ \n    // your code goes here\n    long[] temp=new long[nums.length];\n\
    \    foreach(int i, ref long num; nums)\n    {\n        temp[i]=num;\n    }\n\
    \    sort(nums,(lhs,rhs)=>sum_digits(lhs)<sum_digits(rhs));\n    return nums;\n\
    } \nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_97nric8.d(25): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_97nric8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    double[] points;\n    long[] idx;\n    nums.size();\n    // Allocate\
    \ a set of points based on the number of elements\n    // present in the nums\
    \ array. This is effectively a 1-1 mapping\n    // of an index to an element.\n\
    \    points = new double[nums.size()];\n    long i = 0;\n    foreach(long n; nums)\n\
    \    {\n        double p = 0;\n        do\n        {\n            p += n % 10;\n\
    \            n /= 10;\n        }\n        while(n != 0);\n        points[i] =\
    \ p;\n        i++;\n    }\n    idx = idx = new long[nums.size()];\n    for(i =\
    \ 0; i < nums.size(); i++)\n    {\n        idx[i] = i;\n    }\n    // Bubble sort\
    \ the points in descending order,\n    // swapping their indices at the same time.\n\
    \    auto swaps = true;\n    while(swaps)\n    {\n        swaps = false;\n   \
    \     for(i = 0; i < nums.size() - 1; i++)\n        {\n            if(points[i]\
    \ < points[i + 1])\n            {\n                auto temp = points[i];\n  \
    \              points[i] = points[i + 1];\n                points[i + 1] = temp;\n\
    \                temp = idx[i];\n                idx[i] = idx[i + 1];\n      \
    \          idx[i + 1] = temp;\n                swaps = true;\n            }\n\
    \        }\n    }\n    // I'm a big dummy, so instead of sorting it in place,\n\
    \    // I'm going to create a new sorted array with the\n    // elements from\
    \ the nums array.\n    auto sorted = new long[nums.size()];\n    for(i = 0; i\
    \ < nums.size(); i++)\n    {\n        sorted[i] = nums[idx[i]];\n    }\n    return\
    \ sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaoz9u10b.d(21): Error: no property `size` for type `long[]`

    /tmp/tmpaoz9u10b.d(25): Error: no property `size` for type `long[]`

    /tmp/tmpaoz9u10b.d(39): Error: no property `size` for type `long[]`

    /tmp/tmpaoz9u10b.d(40): Error: no property `size` for type `long[]`

    /tmp/tmpaoz9u10b.d(50): Error: no property `size` for type `long[]`

    /tmp/tmpaoz9u10b.d(59): Error: cannot implicitly convert expression `temp` of
    type `double` to `long`

    /tmp/tmpaoz9u10b.d(67): Error: no property `size` for type `long[]`

    /tmp/tmpaoz9u10b.d(68): Error: no property `size` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaoz9u10b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    const int[] SUM_DIGITS = nums.map!(p => p.to!string.map!(ch =>\
    \ ch.to!int - '0'.to!int).sum.to!int).array;\n    auto result = nums.dup;\n  \
    \  sort!((a, b) => {\n        const int A = SUM_DIGITS[a];\n        const int\
    \ B = SUM_DIGITS[b];\n        return A < B || (A == B && a < b);\n    })(result);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n\
    \    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr2ebo74h.d(19): Error: no property `map` for type `long[]`

    /tmp/tmpr2ebo74h.d(21): Error: template instance `sort!((a, b) => ()

    {

    const int A = SUM_DIGITS[a];

    const int B = SUM_DIGITS[b];

    return A < B || A == B && (a < b);

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr2ebo74h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length < 2)\n        return nums;\n    long[] workingCopy\
    \ = nums.dup;\n    sort(workingCopy, (a, b) => sumDigits(a) < sumDigits(b));\n\
    \    return workingCopy;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqn2j61cv.d(22): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqn2j61cv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{ \n    long sum = 0; \n    long[] sumArray = new long[nums.length];\
    \ \n    for (int i = 0; i < nums.length; i++) \n    { \n        sum = 0; \n  \
    \      while (nums[i] != 0) \n        { \n            sum += nums[i] % 10; \n\
    \            nums[i] /= 10; \n        } \n        sumArray[i] = sum; \n    } \n\
    \    int[] newSumArray = zip!(nums, sumArray); \n    sort!(\"a[1] < b[1] || (a[1]\
    \ == b[1] && a[0] < b[0]\"); \n    return newSumArray.map!(a => a[0]).array; \n\
    } \nlong[] order_by_points(long[] nums) \n{ \n    long sum = 0; \n    long[] sumArray\
    \ = new long[nums.length]; \n    for (int i = 0; i < nums.length; i++) \n    {\
    \ \n        sum = 0; \n        while (nums[i] != 0) \n        { \n           \
    \ sum += nums[i] % 10; \n            nums[i] /= 10; \n        } \n        sumArray[i]\
    \ = sum; \n    } \n    int[] newSumArray = zip!(nums, sumArray); \n    sort!(\"\
    a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]\"); \n    return newSumArray.map!(a\
    \ => a[0]).array; \n} \nlong[] order_by_points(long[] nums) \n{ \n    long sum\
    \ = 0; \n    long[] sumArray = new long[nums.length]; \n    for (int i = 0; i\
    \ < nums.length; i++) \n    { \n        sum = 0; \n        while (nums[i] != 0)\
    \ \n        { \n            sum += nums[i] % 10; \n            nums[\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppvtbhtqo.d(64): Error: expression expected, not `unittest`

    /tmp/tmppvtbhtqo.d(65): Error: found `{` when expecting `,`

    /tmp/tmppvtbhtqo.d(66): Error: expression expected, not `alias`

    /tmp/tmppvtbhtqo.d(66): Error: found `candidate` when expecting `,`

    /tmp/tmppvtbhtqo.d(66): Error: expression expected, not `=`

    /tmp/tmppvtbhtqo.d(66): Error: found `order_by_points` when expecting `,`

    /tmp/tmppvtbhtqo.d(66): Error: expression expected, not `;`

    /tmp/tmppvtbhtqo.d(68): Error: found `assert` when expecting `,`

    /tmp/tmppvtbhtqo.d(68): Error: found `;` when expecting `,`

    /tmp/tmppvtbhtqo.d(69): Error: found `;` when expecting `,`

    /tmp/tmppvtbhtqo.d(70): Error: found `;` when expecting `,`

    /tmp/tmppvtbhtqo.d(71): Error: found `;` when expecting `,`

    /tmp/tmppvtbhtqo.d(72): Error: found `;` when expecting `,`

    /tmp/tmppvtbhtqo.d(73): Error: found `;` when expecting `,`

    /tmp/tmppvtbhtqo.d(74): Error: expression expected, not `}`

    /tmp/tmppvtbhtqo.d(75): Error: found `void` when expecting `,`

    /tmp/tmppvtbhtqo.d(75):'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] sums = new long[nums.length];\n    for (int i = 0; i <\
    \ nums.length; i++) {\n        long n = nums[i];\n        long s = 0;\n      \
    \  while (n != 0) {\n            s += n % 10;\n            n /= 10;\n        }\n\
    \        sums[i] = s;\n    }\n    auto ord = tuple(sums, nums);\n    std.algorithm.sort!(\"\
    a < b\")(ord);\n    return ord[1];\n}\n/*\n    Write a function which takes a\
    \ string and a non-negative integer as parameters,\n    and returns a string with\
    \ a maximum length of the integer,\n    consisting of the first n non-whitespace\
    \ characters of the string.\n    If the string has less than n non-whitespace\
    \ characters, just return the whole string.\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8q1lnfei.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8q1lnfei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    ulong[] sums\
    \ = new ulong[nums.length];\n    int[] indexes = new int[nums.length];\n    foreach\
    \ (i, v; nums)\n    {\n        sums[i] = abs(v).to!ulong;\n        indexes[i]\
    \ = i;\n    }\n    for (int i = 0; i < nums.length; i++)\n    {\n        for (int\
    \ j = 0; j < nums.length - 1; j++)\n        {\n            if (sums[j] > sums[j\
    \ + 1])\n            {\n                swap(sums[j], sums[j + 1]);\n        \
    \        swap(indexes[j], indexes[j + 1]);\n            }\n        }\n    }\n\
    \    long[] new_nums = new long[nums.length];\n    foreach (i, v; indexes)\n \
    \   {\n        new_nums[i] = nums[v];\n    }\n    return new_nums;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9dsprlz1.d(25): Error: no property `to` for type `long`

    /tmp/tmp9dsprlz1.d(26): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp9dsprlz1.d(34): Error: undefined identifier `swap`, did you mean template
    `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?

    /tmp/tmp9dsprlz1.d(35): Error: undefined identifier `swap`, did you mean template
    `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9dsprlz1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    alias Pair = Tuple!(long, int);\n    auto numsByPoints = array(nums.map!(x\
    \ => Pair(x, reduce!((a, b) => a + b, x.toString().map!(n => n.to!int - '0'.to!int).array).array)))\n\
    \                     .sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] <\
    \ b[0]));\n    return numsByPoints.map!(x => x[0]).array;\n}\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0d7gha5x.d(20): Error: undefined identifier `array`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0d7gha5x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    static auto getSum = (long num) => \n    {\n        long sum\
    \ = 0;\n        for (; num != 0; num /= 10)\n            sum += num % 10;\n  \
    \      return sum;\n    };\n    return nums\n        .map!(num => tuple(num, getSum(num)))\n\
    \        .sort!((a, b) => a[1] == b[1] ? a[0] < b[0] : a[1] < b[1])\n        .map!(x\
    \ => x[0])\n        .array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbnz1fo60.d(27): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbnz1fo60.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto s = nums.map!((x) => tuple(x, sum([(x % 10).abs, ((x / 10)\
    \ % 10).abs, (x / 100).abs])));\n    s.sort!((a, b) => a[1] == b[1] ? a[0] < b[0]\
    \ : a[1] < b[1]);\n    return s.map!((x) => x[0]).array;\n}\nunittest\n{\n   \
    \ alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz35tfthp.d(19): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz35tfthp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{ \n    long[] sums = new long[nums.length];\n    foreach(immutable\
    \ i, ref a; nums)\n    {\n        long sum = 0;\n        if(a < 0)\n         \
    \   a = abs(a);\n        while(a > 0)\n        {\n            sum += a % 10;\n\
    \            a /= 10;\n        }\n        sums[i] = sum;\n    }\n    auto pairs\
    \ = new typeof(nums.zip(sums));\n    pairs.sort!\"a.item2\";\n    foreach(pair;\
    \ pairs)\n        nums[pair.item1] = pair.item0;\n    return nums;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptzkv8lnv.d(32): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptzkv8lnv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  long[] points = new long[nums.length];\n  foreach(int i, long e;\
    \ nums)\n  {\n    points[i] = std.math.abs(e);\n  }\n  int[][] zipped = zip(nums,\
    \ points);\n  std.sort(zipped, (int[] a, int[] b) {\n    return a[1] - b[1];\n\
    \  });\n  long[] ordered = new long[nums.length];\n  foreach(int i, int[] e; zipped)\n\
    \  {\n    ordered[i] = e[0];\n  }\n  return ordered;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptn4fmyqf.d(24): Error: undefined identifier `zip`

    /tmp/tmptn4fmyqf.d(25): Error: undefined identifier `sort` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptn4fmyqf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return new long[0];\n    long[]\
    \ result = new long[nums.length];\n    int[] sums = new int[nums.length];\n  \
    \  for (int i = 0; i < nums.length; i++)\n    {\n        sums[i] = 0;\n      \
    \  if (nums[i] < 0)\n            nums[i] *= -1;\n        while (nums[i] != 0)\n\
    \        {\n            sums[i] += nums[i] % 10;\n            nums[i] /= 10;\n\
    \        }\n    }\n    assert(result.length == nums.length);\n    assert(result.length\
    \ == sums.length);\n    auto list = zip(sums, nums);\n    sort!((a, b) => a[0]\
    \ < b[0] || (a[0] == b[0] && a[1] < b[1]))(list);\n    foreach (i, val; list)\n\
    \    {\n        result[i] = val[1];\n    }\n    return result;\n}\n// void main()\n\
    // {\n//     writeln(order_by_points([1L, 11L, -1L, -11L, -12L]));\n//     writeln(order_by_points([]));\n\
    // }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2tt5f78f.d(36): Error: undefined identifier `zip`

    /tmp/tmp2tt5f78f.d(37): Error: template instance `sort!((a, b) => a[0] < b[0]
    || a[0] == b[0] && (a[1] < b[1]))` template `sort` is not defined, did you mean
    sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2tt5f78f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) \n    {\n        return nums;\n    }\n\
    \    else \n    {\n        Tuple!(long, long[])[] sums = new Tuple!(long, long[])[nums.length];\n\
    \        for (int i = 0; i < nums.length; i++) \n        {\n            long[]\
    \ arr = nums[i].toString().byCode.map!(c => to!long(c)).array;\n            long\
    \ sum = arr.reduce!((a, b) => a + b)();\n            sums[i] = tuple(sum, arr);\n\
    \        }\n        Sort!((a, b) => a[0] < b[0], int[])(sums);\n        long[]\
    \ result = new long[nums.length];\n        int j = 0;\n        foreach (tup; sums)\
    \ \n        {\n            foreach (item; tup[1]) \n            {\n          \
    \      result[j] = item;\n                j++;\n            }\n        }\n   \
    \     return result;\n    }\n}\n/*\n    Write a function which concatenates two\
    \ given strings, \n    removing the characters from the first string if the\n\
    \    second string is already present in the first string.\n    For example:\n\
    \    >>> concatenate_strings(\"abc\", \"xyz\")\n    \"xyz\"\n    >>> concatenate_strings(\"\
    abz\", \"xyz\")\n    \"abzxyz\"\n    >>> concatenate_strings(\"abc\", \"abz\"\
    )\n    \"abc\"\n    >>> concatenate_strings(\"\", \"xyz\")\n    \"xyz\"\n    >>>\
    \ concatenate_strings(\"\", \"\")\n    \"\"\n*/\nstring concatenate_strings(string\
    \ first, string second) \n{\n    foreach (char; second) \n    {\n        first\
    \ = first.replace(char, \"\");\n    }\n    return first ~ second;\n}\n/*\n   \
    \ Write a function which returns the third largest element\n    in a given array\
    \ of integers. If there are less than three\n    distinct integers in the array,\
    \ return -1.\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpocgl7zf5.d(64): Error: no identifier for declarator `char`

    /tmp/tmpocgl7zf5.d(66): Error: found `,` when expecting `.` following char

    /tmp/tmpocgl7zf5.d(66): Error: found `""` when expecting identifier following
    `char`.

    /tmp/tmpocgl7zf5.d(70): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocgl7zf5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // TODO: implement order_by_points()\n    return null;\n}\n//\
    \ test\n/*\n    import std.stdio;\n    import std.math;\n    import std.typecons;\n\
    \    void main()\n    {\n        writeln(order_by_points([1L, 11L, -1L, -11L,\
    \ -12L]));\n        writeln(order_by_points([]));\n    }\n*/\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkv4l88m4.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpkv4l88m4.__unittest_L33_C1() [0x427f05]

    ??:? void tmpkv4l88m4.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c71b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430741]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430bf0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c4f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] result = nums.dup;\n    result.sort((a, b) => cast(int)sumDigits(a)\
    \ - cast(int)sumDigits(b));\n    return result;\n}\nlong sumDigits(long num)\n\
    {\n    long result = 0;\n    foreach(digit; num.toString().chars.map!((c) => cast(long)(c\
    \ - '0')))\n    {\n        result += digit;\n    }\n    return result;\n}\n//\
    \ More compact version\nlong[] order_by_points2(long[] nums) \n{\n    long[] result\
    \ = nums.dup;\n    result.sort((a, b) => cast(int)sumDigits2(a) - cast(int)sumDigits2(b));\n\
    \    return result;\n}\nlong sumDigits2(long num)\n{\n    return num.toString().chars.map!((c)\
    \ => cast(long)(c - '0')).sum;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9lb6ge3.d(20): Error: no property `sort` for type `long[]`

    /tmp/tmpi9lb6ge3.d(26): Error: no property `toString` for type `long`

    /tmp/tmpi9lb6ge3.d(36): Error: no property `sort` for type `long[]`

    /tmp/tmpi9lb6ge3.d(41): Error: no property `toString` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9lb6ge3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    else\n    {\n\
    \        int[] sums = new int[nums.length];\n        foreach (i, item; nums)\n\
    \        {\n            int sum = 0;\n            foreach (j, digit; item.to!string)\n\
    \                sum += to!int(digit);\n            sums[i] = sum;\n        }\n\
    \        // https://stackoverflow.com/questions/17547112/how-to-generate-all-permutations-of-set-of-natural-numbers-without-repetitions\n\
    \        // Create the Permutations of the Nums array based on the sums of the\
    \ digits.\n        int[][] permutations = permutationsOf(sums);\n        int[]\
    \ sumsOfPermutations = new int[permutations.length];\n        // Sum up each permutation\
    \ and store it in the sumsOfPermutations array.\n        foreach (i, sum; sumsOfPermutations)\n\
    \            foreach (j, permutation; permutations)\n                sumsOfPermutations[i]\
    \ += permutation[j];\n        // Find the lowest sum and its index\n        int\
    \ minSum = min(sumsOfPermutations);\n        int indexOfMinSum = 0;\n        foreach\
    \ (index, sum; sumsOfPermutations)\n            if (sum == minSum)\n         \
    \       indexOfMinSum = index;\n        // Return the permutation with the lowest\
    \ sum as an array.\n        return to!(long[])(permutations[indexOfMinSum]);\n\
    \    }\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg2h5ggbz.d(27): Error: no property `to` for type `long`

    /tmp/tmpg2h5ggbz.d(33): Error: undefined identifier `permutationsOf`

    /tmp/tmpg2h5ggbz.d(40): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpg2h5ggbz.d(44): Error: cannot implicitly convert expression `index` of
    type `ulong` to `int`

    /tmp/tmpg2h5ggbz.d(46): Error: template instance `to!(long[])` template `to` is
    not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg2h5ggbz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int n = nums.length;\n    long[][]pairs = new long[n][];\n  \
    \  foreach(i, x; nums)\n    {\n        pairs[i] = [i, x];\n    }\n    sort!(\"\
    a[1] > b[1] || (a[1] == b[1] && a[0] < b[0]\")(pairs);\n    long[]sorted = pairs.map!(x\
    \ => x[1]).array;\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq_picks_.d(19): Error: cannot implicitly convert expression `nums.length`
    of type `ulong` to `int`

    /tmp/tmpq_picks_.d(20): Error: variable `n` cannot be read at compile time

    /tmp/tmpq_picks_.d(25): Error: template instance `sort!"a[1] > b[1] || (a[1] ==
    b[1] && a[0] < b[0]"` template `sort` is not defined, did you mean sqrt?

    /tmp/tmpq_picks_.d(26): Error: no property `map` for type `long[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_picks_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[][] sums = new int[nums.length][2];\n    for (int i = 0;\
    \ i < nums.length; i++) {\n        sums[i][0] = sum(nums[i]);\n        sums[i][1]\
    \ = i;\n    }\n    auto comparator = (x, y) => x[0] == y[0] ?\n              \
    \                  x[1] - y[1] :\n                                x[0] - y[0];\n\
    \    std.array.sort(sums, comparator);\n    long[] res = new long[nums.length];\n\
    \    for (int i = 0; i < sums.length; i++) {\n        res[i] = nums[sums[i][1]];\n\
    \    }\n    return res;\n}\n/*\n    Write a function which maps the given array\
    \ of integers\n    to the following function:\n    f(x) = (x + 1) * (x + 2) *\
    \ ... * (x + n)\n    You may assume that all elements in array are non-negative.\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfmk5shza.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfmk5shza.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    /*\n        Write your code here.\n    */\n    if(nums.length\
    \ == 0) return nums;\n    long[] x = new long[nums.length];\n    long[] temp =\
    \ new long[nums.length];\n    long[] index = new long[nums.length];\n    for(int\
    \ i = 0; i < nums.length; i++)\n    {\n        if(nums[i] < 0) x[i] = abs(nums[i]);\n\
    \        else x[i] = nums[i];\n        index[i] = i;\n    }\n    for(int i = 0;\
    \ i < nums.length; i++)\n    {\n        int sum = 0;\n        while(x[i] > 0)\n\
    \        {\n            sum += x[i] % 10;\n            x[i] /= 10;\n        }\n\
    \        temp[i] = sum;\n    }\n    for(int i = 0; i < nums.length - 1; i++)\n\
    \    {\n        for(int j = i + 1; j < nums.length; j++)\n        {\n        \
    \    if(temp[i] > temp[j])\n            {\n                long t = temp[i];\n\
    \                temp[i] = temp[j];\n                temp[j] = t;\n          \
    \      t = nums[i];\n                nums[i] = nums[j];\n                nums[j]\
    \ = t;\n                t = index[i];\n                index[i] = index[j];\n\
    \                index[j] = t;\n            }\n            else if(temp[i] ==\
    \ temp[j])\n            {\n                if(index[i] > index[j])\n         \
    \       {\n                    long t = nums[i];\n                    nums[i]\
    \ = nums[j];\n                    nums[j] = t;\n                    t = index[i];\n\
    \                    index[i] = index[j];\n                    index[j] = t;\n\
    \                }\n            }\n        }\n    }\n    return nums;\n}\n//long[]\
    \ nums = [-1L, -11L, 1L, -12L, 11L\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzi7piazm.d(79): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e65]

    ??:? void tmpzi7piazm.__unittest_L75_C1() [0x428645]

    ??:? void tmpzi7piazm.__modtest() [0x428be8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cf43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bdd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x431061]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431510]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430fed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bdad]

    ??:? runModuleUnitTests [0x42cd19]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429328]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] res = new long[nums.length];\n    int[] sum = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++) {\n        sum[i] = nums[i] < 0 ? -nums[i]\
    \ : nums[i];\n        while (sum[i] > 0) {\n            sum[i] = sum[i] % 10 +\
    \ sum[i] / 10;\n        }\n    }\n    auto sorted = sort!(a => a[1])(zip(nums,\
    \ sum));\n    for (int i = 0; i < nums.length; i++) {\n        res[i] = sorted[i][0];\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpodb7rnma.d(22): Error: cannot implicitly convert expression `nums[cast(ulong)i]
    < 0L ? -nums[cast(ulong)i] : nums[cast(ulong)i]` of type `long` to `int`

    /tmp/tmpodb7rnma.d(27): Error: template instance `sort!((a) => a[1])` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpodb7rnma.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n  if (nums.length == 0)\n  {\n    return nums;\n  }\n  else\n  {\n\
    \    long[] theNew = new long[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n      theNew[i] = nums[i];\n    }\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n      long sum1 = 0;\n      long sum2 = 0;\n      long divisor\
    \ = 10;\n      while (theNew[i] > 0)\n      {\n        long remainder = theNew[i]\
    \ % divisor;\n        sum1 += remainder;\n        theNew[i] /= divisor;\n    \
    \  }\n      divisor = 10;\n      while (nums[i] > 0)\n      {\n        long remainder\
    \ = nums[i] % divisor;\n        sum2 += remainder;\n        nums[i] /= divisor;\n\
    \      }\n      if (sum1 < sum2)\n      {\n        long temp = theNew[i];\n  \
    \      theNew[i] = theNew[i+1];\n        theNew[i+1] = temp;\n      }\n    }\n\
    \    return theNew;\n  }\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppzzat9mu.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x4289bd]

    ??:? void tmppzzat9mu.__unittest_L58_C1() [0x4281b5]

    ??:? void tmppzzat9mu.__modtest() [0x428740]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430bb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430b45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b905]

    ??:? runModuleUnitTests [0x42c871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e80]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    else\n    {\n\
    \        long[] big = new long[nums.length];\n        for (int i = 0; i < nums.length;\
    \ i++)\n        {\n            long n = nums[i];\n            big[i] = n > 0 ?\
    \ n : -n;\n        }\n        return nums.dup.sort!((ref long a, ref long b) =>\
    \ \n        {\n            auto[sum_a, sum_b] = tuple(sum_digits(big[a]), sum_digits(big[b]));\n\
    \            if (sum_a == sum_b)\n                return a > b;\n            else\n\
    \                return sum_a > sum_b;\n        });\n    }\n}\nlong sum_digits(long\
    \ n)\n{\n    long s = 0;\n    do\n    {\n        s += n % 10;\n        n /= 10;\n\
    \    } while (n != 0);\n    return s;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmxp0y824.d(31): Error: basic type expected, not `[`

    /tmp/tmpmxp0y824.d(31): Error: found `,` when expecting `]`

    /tmp/tmpmxp0y824.d(31): Error: semicolon expected, not `]`

    /tmp/tmpmxp0y824.d(31): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmxp0y824.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    assert (nums != null);\n    // Sum the elements of the array\n\
    \    auto n = nums.length;\n    auto arr = new tuple!(long, long)[n];\n    foreach\
    \ (i, x; nums) {\n        arr[i] = tuple(x, x.sum_digits());\n    }\n    // Sort\
    \ the array by sum\n    auto cmp = (t1, t2) => {\n        if (t1[1] == t2[1])\
    \ return t1[0] > t2[0];\n        return t1[1] > t2[1];\n    };\n    sort(arr,\
    \ cmp);\n    // Return the sorted array\n    return arr.map!(t => t[0]).array;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy4b5e9ml.d(22): Error: `tuple!(long, long)` is used as a type

    /tmp/tmpy4b5e9ml.d(27): Error: variable `tmpy4b5e9ml.order_by_points.cmp` type
    `void` is inferred from initializer `(t1, t2) => ()

    {

    if (t1[1] == t2[1])

    return t1[0] > t2[0];

    return t1[1] > t2[1];

    }

    `, and variables cannot be of type `void`

    /tmp/tmpy4b5e9ml.d(27): Error: template lambda has no value

    /tmp/tmpy4b5e9ml.d(31): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy4b5e9ml.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] points=new int[nums.length];\n    for(int i=0;i<nums.length;i++)\n\
    \    {\n        int sum=0;\n        long tmp=abs(nums[i]);\n        while(tmp!=0)\n\
    \        {\n            sum+=(int)(tmp%10);\n            tmp/=10;\n        }\n\
    \        points[i]=sum;\n    }\n    long[] result=new long[nums.length];\n   \
    \ int[] p=new int[points.length];\n    for(int i=0;i<points.length;i++)\n    {\n\
    \        p[i]=i;\n    }\n    int[] pp=new int[points.length];\n    for(int i=0;i<points.length;i++)\n\
    \    {\n        int max=i;\n        for(int j=i+1;j<points.length;j++)\n     \
    \   {\n            if(points[j]<points[max])\n            {\n                max=j;\n\
    \            }\n        }\n        int tmp=points[i];\n        points[i]=points[max];\n\
    \        points[max]=tmp;\n        pp[i]=p[max];\n        p[max]=p[i];\n    }\n\
    \    for(int i=0;i<nums.length;i++)\n    {\n        result[i]=nums[pp[i]];\n \
    \   }\n    return result;\n}\n//end of solution\nunittest\n{\n    alias candidate\
    \ = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L,\
    \ -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L,\
    \ 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L,\
    \ 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6s929en5.d(26): Error: C style cast illegal, use `cast(int)(tmp
    % 10)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6s929en5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    import std.algorithm.sorting : sort;\n    import std.algorithm.comparison\
    \ : equal;\n    import std.traits : isIntegral;\n    import std.range : iota;\n\
    \    import std.typecons : Tuple;\n    import std.conv : to;\n    assert(nums.all!isIntegral);\n\
    \    static assert(is(typeof(unittest){}));\n    static if (nums.length)\n   \
    \ {\n        int[int] sum_map;\n        foreach (i, e; nums)\n        {\n    \
    \        int sum = 0;\n            foreach (c; to!string(e))\n               \
    \ sum += c.digit;\n            auto key = sum;\n            while (key in sum_map)\n\
    \                key++;\n            sum_map[key] = i;\n        }\n        long[]\
    \ res;\n        foreach (key; sort(sum_map.keys))\n            res ~= nums[sum_map[key]];\n\
    \        return res;\n    }\n    else\n        return [];\n}\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnk67a84i.d(26): Error: expression expected, not `unittest`

    /tmp/tmpnk67a84i.d(26): Error: found `{` when expecting `)`

    /tmp/tmpnk67a84i.d(26): Error: found `}` when expecting `)`

    /tmp/tmpnk67a84i.d(26): Error: found `)` when expecting `;`

    /tmp/tmpnk67a84i.d(26): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnk67a84i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    return sort(nums, (a, b) => \n    {\n        return sumDigits(a)\
    \ < sumDigits(b) ? -1 : sumDigits(a) > sumDigits(b) ? 1 : 0;\n    });\n}\nlong\
    \ sumDigits(long l)\n{\n    long result = 0;\n    while(l != 0)\n    {\n     \
    \   result += l % 10;\n        l /= 10;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_uxt46wd.d(19): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_uxt46wd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    return nums.sort!q{a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0])}()\n               .map!(i => i[1])();\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptob4rflj.d(21): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptob4rflj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    static struct Point(long[3] x) { long[] x; }\n    return nums.map!(x\
    \ => Point(x)).sort!(\"a.x[1] < b.x[1] || (a.x[1] == b.x[1] && a.x[2] < b.x[2])\"\
    ).map!(x => x.x[0]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy99w1ura.d(20): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy99w1ura.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    auto longest\
    \ = 0;\n    foreach (n; nums)\n    {\n        if (n.length > longest)\n      \
    \      longest = n.length;\n    }\n    long[][] matrix = new long[][](longest,\
    \ nums.length);\n    foreach (n; nums)\n    {\n        auto row = 0;\n       \
    \ foreach (d; n.toChars)\n        {\n            matrix[row][n] = d.to!long;\n\
    \            row++;\n        }\n    }\n    auto sums = matrix.map!((line) => line.sum);\n\
    \    auto indices = sums.enumerate.sort!((a, b) => a[1] < b[1]);\n    return indices.map!((a)\
    \ => nums[a[0]]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzukfq48d.d(24): Error: no property `length` for type `long`

    /tmp/tmpzukfq48d.d(25): Error: no property `length` for type `long`

    /tmp/tmpzukfq48d.d(31): Error: no property `toChars` for type `long`

    /tmp/tmpzukfq48d.d(37): Error: no property `map` for type `long[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzukfq48d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    immutable type Input = Tuple!(ulong, long);\nunittest\n{\n  \
    \  alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L,\
    \ -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L,\
    \ 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L,\
    \ 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprhs86w21.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprhs86w21.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0) \n    {\n        return nums;\n    }\n\
    \    Tuple!(int, long)[] tuples = new Tuple!(int, long)[nums.length];\n    for\
    \ (int i = 0; i < nums.length; i++) \n    {\n        tuples[i] = tuple(num2Int(nums[i]),\
    \ nums[i]);\n    }\n    tuples.sort!(\"a.tupleof[0] > b.tupleof[0] ? 1 : a.tupleof[0]\
    \ < b.tupleof[0] ? -1 : a.tupleof[1] > b.tupleof[1] ? 1 : a.tupleof[1] < b.tupleof[1]\
    \ ? -1 : 0\")(tuple2Comp);\n    long[] result = new long[nums.length];\n    for\
    \ (int i = 0; i < nums.length; i++) \n    {\n        result[i] = tuples[i].tupleof[1];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmn8vt7oq.d(26): Error: undefined identifier `num2Int`

    /tmp/tmpmn8vt7oq.d(28): Error: no property `sort` for type `Tuple!(int, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmn8vt7oq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] sum = [];\n    foreach(i; 0..nums.length)\n    {\n    \
    \    sum ~= nums[i].digits().sum;\n    }\n    int[] point = [];\n    foreach(i;\
    \ 0..nums.length)\n    {\n        point ~= i;\n    }\n    //sort\n    auto sort\
    \ = tuples!(int, \"a\", int, \"b\")(sum, point);\n    sort[] = sort[0 .. $].sort!((a,\
    \ b) => a[0] < b[0]);\n    int[] newpoint = [];\n    foreach(i; 0..nums.length)\n\
    \    {\n        newpoint ~= sort[i][1];\n    }\n    //int[] newnums = [];\n  \
    \  //foreach(i; 0..nums.length)\n    //{\n    //    newnums ~= nums[newpoint[i]];\n\
    \    //}\n    //return newnums;\n    return nums[newpoint];\n}\n \n \n \n \nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2cocdlae.d(22): Error: no property `digits` for type `long`

    /tmp/tmp2cocdlae.d(27): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmp2cocdlae.d(30): Error: template instance `tuples!(int, "a", int, "b")`
    template `tuples` is not defined, did you mean tuple(Names...)?

    /tmp/tmp2cocdlae.d(43): Error: cannot implicitly convert expression `newpoint`
    of type `int[]` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2cocdlae.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    long[] ans =\
    \ new long[nums.length];\n    int index = 0;\n    for (long n : nums)\n    {\n\
    \        ans[index] = n;\n        index++;\n    }\n    sort(ans);\n    index =\
    \ 0;\n    int[] sum = new int[nums.length];\n    for (long n : nums)\n    {\n\
    \        sum[index] = n.to!string.split(\"\").map!(a => a.to!int).sum();\n   \
    \     index++;\n    }\n    int[] mini = new int[nums.length];\n    index = 0;\n\
    \    for (int n : sum)\n    {\n        if (n == min(sum))\n        {\n       \
    \     mini[index] = 1;\n        }\n        index++;\n    }\n    int i = 0;\n \
    \   while (i < mini.length)\n    {\n        if (mini[i] == 1)\n        {\n   \
    \         break;\n        }\n        i++;\n    }\n    long temp = ans[i];\n  \
    \  ans[i] = ans[0];\n    ans[0] = temp;\n    for (int j = 1; j < ans.length; j++)\n\
    \    {\n        if (sum[j] == sum[j-1])\n        {\n            continue;\n  \
    \      }\n        for (int k = 0; k < ans.length; k++)\n        {\n          \
    \  if (sum[k] == sum[j])\n            {\n                temp = ans[k];\n    \
    \            ans[k] = ans[j];\n                ans[j] = temp;\n              \
    \  break;\n            }\n        }\n    }\n    return ans;\n}\nunittest\n{\n\
    \    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzy9zui0n.d(23): Error: semicolon expected, not `:`

    /tmp/tmpzy9zui0n.d(23): Error: expression expected, not `:`

    /tmp/tmpzy9zui0n.d(23): Error: found `nums` when expecting `;` following `for`
    condition

    /tmp/tmpzy9zui0n.d(31): Error: semicolon expected, not `:`

    /tmp/tmpzy9zui0n.d(31): Error: expression expected, not `:`

    /tmp/tmpzy9zui0n.d(31): Error: found `nums` when expecting `;` following `for`
    condition

    /tmp/tmpzy9zui0n.d(38): Error: semicolon expected, not `:`

    /tmp/tmpzy9zui0n.d(38): Error: expression expected, not `:`

    /tmp/tmpzy9zui0n.d(38): Error: found `sum` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzy9zui0n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] digit_sum = new int[nums.length];\n    for (int i = 0;\
    \ i < nums.length; i++)\n    {\n        int sum = 0;\n        foreach (char c;\
    \ to!string(nums[i]))\n        {\n            if (c == '-')\n                continue;\n\
    \            sum += c - '0';\n        }\n        digit_sum[i] = sum;\n    }\n\
    \    return nums.dup.sort!((a, b) => digit_sum[a] < digit_sum[b] || (digit_sum[a]\
    \ == digit_sum[b] && a < b));\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpim2qngut.d(23): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    /tmp/tmpim2qngut.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpim2qngut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length < 2)\n        return nums;\n    else\n    {\n\
    \        // create a new array of tuples\n        Tuple!(ulong, long)[nums.length]\
    \ tArr;\n        // loop through each item in the array,\n        // add the sum\
    \ of its digits to the same place in the tuple array\n        foreach (i, num;\
    \ nums)\n        {\n            long total = 0;\n            foreach (letter;\
    \ to!string(num))\n                total += letter.to!long;\n            tArr[i]\
    \ = tuple(total, num);\n        }\n        // sort the tuple array, using the\
    \ first element as the key\n        sort!(tArr, (a, b) => a[0] < b[0]);\n    \
    \    // pull the values out of the tuples and add them to the new long array\n\
    \        long[] ans;\n        foreach (t; tArr)\n            ans ~= t[1];\n  \
    \      return ans;\n    }\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa6s4w_s_.d(24): Error: variable `nums` cannot be read at compile
    time

    /tmp/tmpa6s4w_s_.d(30): Error: template instance `to!string` template `to` is
    not defined, did you mean No?

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return new long[0];\n    long[]\
    \ arr = new long[nums.length];\n    for (int i = 0; i < nums.length; i++)\n  \
    \  {\n        long n = nums[i];\n        if (n < 0)\n            n = -n;\n   \
    \     long sum = 0;\n        while (n != 0)\n        {\n            sum += n %\
    \ 10;\n            n /= 10;\n        }\n        arr[i] = sum;\n    }\n    int[]\
    \ idx = new int[nums.length];\n    for (int i = 0; i < nums.length; i++)\n   \
    \     idx[i] = i;\n    idx.sort!((a, b) => arr[a] < arr[b] || (arr[a] == arr[b]\
    \ && a < b));\n    long[] res = new long[nums.length];\n    for (int i = 0; i\
    \ < nums.length; i++)\n        res[i] = nums[idx[i]];\n    return res;\n}\nunittest\n\
    {\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp645mgl3v.d(38): Error: no property `sort` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp645mgl3v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] ret = nums.dup;\n    // Your code goes here\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdy_e_r1r.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x429889]

    ??:? void tmpdy_e_r1r.__unittest_L23_C1() [0x4280fd]

    ??:? void tmpdy_e_r1r.__modtest() [0x4287fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3f7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x429512]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b181]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b210]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b10d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4294e9]

    ??:? runModuleUnitTests [0x42e1cd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429d2c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    long[] sum;\n    foreach(el; nums)\n    {\n        if(el < 0)\n\
    \            sum ~= el.to!string.sum + -el;\n        else\n            sum ~=\
    \ el.to!string.sum + el;\n    }\n    assert(nums.length == sum.length);\n    long[][]\
    \ p = sort!(long[])(\"a[0] > b[0]\")(zip(sum, nums));\n    return p.map!((a) =>\
    \ a[1]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n   \
    \ assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpam9oij3g.d(23): Error: no property `to` for type `long`

    /tmp/tmpam9oij3g.d(25): Error: no property `to` for type `long`

    /tmp/tmpam9oij3g.d(28): Error: template instance `sort!(long[])` template `sort`
    is not defined, did you mean sqrt?

    /tmp/tmpam9oij3g.d(29): Error: no property `map` for type `long[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpam9oij3g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int n = nums.length;\n    int[] sums = new int[n];\n    for (int\
    \ i = 0; i < n; i++) {\n        sums[i] = sumDigits(nums[i]);\n    }\n    return\
    \ nums[sort(tuple(sums, nums))[$]];\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0jr9xome.d(19): Error: cannot implicitly convert expression `nums.length`
    of type `ulong` to `int`

    /tmp/tmp0jr9xome.d(22): Error: undefined identifier `sumDigits`

    /tmp/tmp0jr9xome.d(24): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0jr9xome.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    auto arr = nums.dup;\n    long[] result;\n    foreach(i; 0 ..\
    \ arr.length)\n    {\n        foreach(j; 0 .. arr.length - 1)\n        {\n   \
    \         if(sum(std.string.digits(to!string(arr[j]))) > sum(std.string.digits(to!string(arr[j\
    \ + 1]))))\n            {\n                long tmp = arr[j];\n              \
    \  arr[j] = arr[j + 1];\n                arr[j + 1] = tmp;\n            }\n  \
    \      }\n    }\n    return arr;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgsmozczc.d(25): Error: undefined identifier `sum`

    /tmp/tmpgsmozczc.d(25): Error: undefined identifier `sum`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgsmozczc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] a = new int[nums.length];\n    // sum of digits\n    for\
    \ (int i = 0; i < nums.length; i++)\n    {\n        int sum = 0;\n        foreach\
    \ (char ch; nums[i].to!string) \n        {\n            sum += ch.to!int - 48;\n\
    \        }\n        a[i] = sum;\n    }\n    // get min value\n    int min = int.max;\n\
    \    foreach (e; a) \n    {\n        if (e < min) \n        {\n            min\
    \ = e;\n        }\n    }\n    // get min value index\n    int[] min_index = [];\n\
    \    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == min) \n  \
    \      {\n            min_index ~= i;\n        }\n    }\n    // get result\n \
    \   long[] res = new long[nums.length];\n    int[] flag = new int[nums.length];\n\
    \    int len = min_index.length;\n    int j = 0;\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        if (i < len) \n        {\n            res[i] = nums[min_index[i]];\n\
    \            flag[min_index[i]] = 1;\n        }\n        else \n        {\n  \
    \          if (flag[j] == 0) \n            {\n                res[i] = nums[j];\n\
    \            }\n            else \n            {\n                i--;\n     \
    \       }\n            j++;\n        }\n    }\n    return res;\n}\n/*\n    Write\
    \ a function that, given an array A consisting of N integers,\n    returns the\
    \ number of distinct values in array A.\nunittest\n{\n    alias candidate = order_by_points;\n\
    \n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9cequ3ut.d(75): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9cequ3ut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return nums;\n    auto sumDigits\
    \ = (long num) => {\n        long sum = 0;\n        while (num != 0)\n       \
    \ {\n            sum += num % 10;\n            num /= 10;\n        }\n       \
    \ return sum;\n    };\n    return nums.sort!((a, b) => tuple(sumDigits(a), nums.indexOf(a))\
    \ < tuple(sumDigits(b), nums.indexOf(b)));\n}\n// (2 ms)\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpllwe6wza.d(30): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpllwe6wza.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    static struct Entry {\n        long sum;\n        size_t index;\n\
    \    }\n    auto entry = [](long sum, size_t index) {\n        Entry e;\n    \
    \    e.sum = sum;\n        e.index = index;\n        return e;\n    };\n    auto\
    \ comp = [](const Entry a, const Entry b) {\n        return a.sum < b.sum || (a.sum\
    \ == b.sum && a.index < b.index);\n    };\n    auto toLong = [](const Entry e)\
    \ {\n        return e.index;\n    };\n    return nums.map!(entry, toLong)(comp);\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkzl5myif.d(23): Error: found `sum` when expecting `.` following
    long

    /tmp/tmpkzl5myif.d(23): Error: found `,` when expecting identifier following `long`.

    /tmp/tmpkzl5myif.d(23): Error: found `size_t` when expecting `,`

    /tmp/tmpkzl5myif.d(23): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpkzl5myif.d(28): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpkzl5myif.d(29): Error: `(arguments)` expected following `const(Entry)`

    /tmp/tmpkzl5myif.d(29): Error: found `a` when expecting `,`

    /tmp/tmpkzl5myif.d(29): Error: expression expected, not `,`

    /tmp/tmpkzl5myif.d(29): Error: found `const` when expecting `,`

    /tmp/tmpkzl5myif.d(29): Error: found `b` when expecting `,`

    /tmp/tmpkzl5myif.d(29): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpkzl5myif.d(31): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpkzl5myif.d(32): Error: `(arguments)` expected following `const(Entry)`

    /tmp/tmpkzl5myif.d(32): Error: found `e` when expecting `,`

    /tmp/'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    static int getSum(long x) \n    {\n        int sum = 0;\n   \
    \     while (x != 0) \n        {\n            sum += cast(int)(x % 10);\n    \
    \        x /= 10;\n        }\n        return sum;\n    }\n    long[] temp = nums[];\n\
    \    sort!((int a, int b) => getSum(a) < getSum(b))(temp);\n    return temp;\n\
    }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpme2bcozt.d(30): Error: template instance `sort!((int a, int b)
    => getSum(a) < getSum(b))` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpme2bcozt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{ \n    int[] sums = new int[nums.length];\n    for (int i = 0; i <\
    \ nums.length; i++) {\n        sums[i] = nums[i].digits.sum;\n    }\n    auto\
    \ sorted = nums.zip(sums).sort!((x, y) => x[1] < y[1]);\n    return sorted.map!(x\
    \ => x[0]).array;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n\
    \    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n\
    \    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L,\
    \ 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L,\
    \ 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L,\
    \ 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L])\
    \ == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L,\
    \ 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwwac4wxb.d(21): Error: no property `digits` for type `long`

    /tmp/tmpwwac4wxb.d(23): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwwac4wxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    int[] index;\n    int[] sum;\n    int[] sorted;\n    long[] result;\n\
    \    int i, j;\n    result = new long[nums.length];\n    if (nums.length == 0)\n\
    \        return result;\n    index = new int[nums.length];\n    sum = new int[nums.length];\n\
    \    sorted = new int[nums.length];\n    for (i = 0; i < nums.length; i++)\n \
    \   {\n        sum[i] = 0;\n        if (nums[i] < 0)\n            index[i] = abs(nums[i]);\n\
    \        else\n            index[i] = nums[i];\n        while (index[i] != 0)\n\
    \        {\n            sum[i] += index[i] % 10;\n            index[i] /= 10;\n\
    \        }\n        sorted[i] = sum[i];\n    }\n    sort(sorted);\n    for (i\
    \ = 0; i < nums.length; i++)\n    {\n        for (j = 0; j < nums.length; j++)\n\
    \        {\n            if (sorted[i] == sum[j])\n            {\n            \
    \    result[i] = nums[j];\n                sum[j] = -1;\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L])\
    \ == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L,\
    \ 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L,\
    \ 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) ==\
    \ [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
    \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_3g7acyc.d(34): Error: cannot implicitly convert expression `abs(nums[cast(ulong)i])`
    of type `long` to `int`

    /tmp/tmp_3g7acyc.d(36): Error: cannot implicitly convert expression `nums[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmp_3g7acyc.d(44): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_3g7acyc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    // Write your solution here\n    return nums.sort!((x, y) =>\
    \ {\n        int xSum = x.digits().sum.to!int;\n        int ySum = y.digits().sum.to!int;\n\
    \        return xSum == ySum ? x > y : xSum > ySum;\n    });\n}\nunittest\n{\n\
    \    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L,\
    \ -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L,\
    \ 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
    \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgung77bw.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgung77bw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function which\
    \ sorts the given array of integers\n    in ascending order according to the sum\
    \ of their digits.\n    Note: if there are several items with similar sum of their\
    \ digits,\n    order them based on their index in original array.\n\n    For example:\n\
    \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
    \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
    \ nums) \n{\n    nums.sort!((n1, n2) => sumDigits(n1) > sumDigits(n2) || \n  \
    \                         (sumDigits(n1) == sumDigits(n2) && nums.indexOf(n1)\
    \ > nums.indexOf(n2))\n               );\n    return nums;\n}\nlong sumDigits(long\
    \ n)\n{\n    long sum = 0;\n    foreach(n; n.to!string)\n    {\n        if(n.to!char.isDigit)\n\
    \            sum += n.to!char.to!int - '0'.to!int;\n    }\n    return sum;\n}\n\
    unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
    \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
    \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) ==\
    \ [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L,\
    \ 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L,\
    \ 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) ==\
    \ [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzc8pb97b.d(19): Error: no property `sort` for type `long[]`

    /tmp/tmpzc8pb97b.d(27): Error: no property `to` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzc8pb97b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
