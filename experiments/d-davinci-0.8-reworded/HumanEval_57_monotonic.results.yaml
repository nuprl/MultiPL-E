language: d
name: HumanEval_57_monotonic
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ (l[1..$].zip(l[0..$-1]).every!((a, b) => a > b || a < b));\n}\n/*\nThis function\
    \ reads numbers from a file and writes it back to a file. It is based on\nstd.algorithm.map\
    \ to transform it to a new range.\n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_vld69nl.d(15): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_vld69nl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool found\
    \ = false;\n    foreach(int i, long e; l) \n    {\n        if (i != 0 && l[i -\
    \ 1] != e) \n        {\n            if (found) \n            {\n             \
    \   return false;\n            }\n            found = true;\n        }\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn1pjo8x4.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282ed]

    ??:? void tmpn1pjo8x4.__unittest_L29_C1() [0x427e04]

    ??:? void tmpn1pjo8x4.__modtest() [0x428070]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c36f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b202]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430395]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430844]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430321]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d9]

    ??:? runModuleUnitTests [0x42c145]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n  pure nothrow\
    \ @safe\n{\n  if (l.length <= 1) return true;\n  bool increasing = true;\n  bool\
    \ decreasing = true;\n  foreach (i, e; l[1..$])\n  {\n    if (e < l[i - 1]) increasing\
    \ = false;\n    if (e > l[i - 1]) decreasing = false;\n  }\n  return increasing\
    \ || decreasing;\n}\n/*\n{\n    return (l.length <= 1) ||\n        (l[0] < l[1]\
    \ && monotonic(l[1..$])) ||\n        (l[0] > l[1] && monotonic(l[1..$]));\n}\n\
    */\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp696crm40.d(21): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428426]

    ??:? pure nothrow @safe bool tmp696crm40.monotonic(long[]) [0x427db7]

    ??:? void tmp696crm40.__unittest_L33_C1() [0x427e75]

    ??:? void tmp696crm40.__modtest() [0x4280f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3f7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b28a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43041d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308cc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b261]

    ??:? runModuleUnitTests [0x42c1cd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ > 1)\n    {\n      long[] ll;\n      ll[] = l[0..l.length-1];\n      long[]\
    \ lr;\n      lr[] = l[1..l.length];\n      if (all!(a => b => a <= b)(ll[], lr[]))\n\
    \      {\n          if (all!(a => b => a >= b)(ll[], lr[]))\n          {\n   \
    \           return true;\n          }\n      }\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp17u1w9wp.d(21): Error: template instance `all!((a) => (b) => a
    <= b)` template `all` is not defined, did you mean ll?

    /tmp/tmp17u1w9wp.d(23): Error: template instance `all!((a) => (b) => a >= b)`
    template `all` is not defined, did you mean ll?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp17u1w9wp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin \n{\n    return\
    \ l.length == 0 || \n    (!all!(i => l[i] <= l[i + 1]) && !all!(i => l[i] >= l[i\
    \ + 1]));\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb87ez5oy.d(13): Error: function `tmpb87ez5oy.monotonic` `in` and
    `out` contracts can only appear without a body when they are virtual interface
    functions or abstract

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb87ez5oy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto direction\
    \ = 0;\n    foreach (i, ref a; l) {\n        if (i == 0) {\n            continue;\n\
    \        }\n        if (direction == 0) {\n            if (a > l[i - 1]) {\n \
    \               direction = 1;\n            } else if (a < l[i - 1]) {\n     \
    \           direction = -1;\n            }\n        } else if (direction == 1)\
    \ {\n            if (a < l[i - 1]) {\n                return false;\n        \
    \    }\n        } else if (direction == -1) {\n            if (a > l[i - 1]) {\n\
    \                return false;\n            }\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto res\
    \ = zip(l[0 .. $ - 1], l[1 .. $]);\n    foreach(res; (long a, long b))\n    {\n\
    \        if (a < b)\n        {\n            long[] temp_l;\n            foreach(res;\
    \ (long a, long b))\n            {\n                if (a > b)\n             \
    \   {\n                    return false;\n                }\n            }\n \
    \           return true;\n        }\n        else if (a > b)\n        {\n    \
    \        long[] temp_l;\n            foreach(res; (long a, long b))\n        \
    \    {\n                if (a < b)\n                {\n                    return\
    \ false;\n                }\n            }\n            return true;\n       \
    \ }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqx7z47q0.d(16): Error: found `a` when expecting `.` following long

    /tmp/tmpqx7z47q0.d(16): Error: found `,` when expecting identifier following `long`.

    /tmp/tmpqx7z47q0.d(16): Error: found `long` when expecting `)`

    /tmp/tmpqx7z47q0.d(16): Error: found `b` when expecting `)`

    /tmp/tmpqx7z47q0.d(16): Error: found `)` instead of statement

    /tmp/tmpqx7z47q0.d(21): Error: found `a` when expecting `.` following long

    /tmp/tmpqx7z47q0.d(21): Error: found `,` when expecting identifier following `long`.

    /tmp/tmpqx7z47q0.d(21): Error: found `long` when expecting `)`

    /tmp/tmpqx7z47q0.d(21): Error: found `b` when expecting `)`

    /tmp/tmpqx7z47q0.d(21): Error: found `)` instead of statement

    /tmp/tmpqx7z47q0.d(27): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqx7z47q0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ isMonotonic(l[], (a, b) => a < b) ||\n           isMonotonic(l[], (a, b) =>\
    \ a > b);\n}\n \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdjf1urj7.d(15): Error: undefined identifier `isMonotonic`

    /tmp/tmpdjf1urj7.d(16): Error: undefined identifier `isMonotonic`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjf1urj7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ isMonotonic(l);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0m0f73i_.d(15): Error: undefined identifier `isMonotonic`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0m0f73i_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ is(typeof(l[]) == long[]);\n}\n/*\nReturn true is array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    true\n    >>>\
    \ monotonic([1, 20, 4, 10])\n    false\n    >>> monotonic([4, 1, 0, -10])\n  \
    \  true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm1ymh1cx.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x428255]

    ??:? void tmpm1ymh1cx.__unittest_L27_C1() [0x427e07]

    ??:? void tmpm1ymh1cx.__modtest() [0x427fd8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c263]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b0f6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430289]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430738]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430215]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0cd]

    ??:? runModuleUnitTests [0x42c039]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4286a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ < 2) \n    {\n        return true;\n    } \n    else if(l[0] > l[1]) \n    {\n\
    \        auto flag = true;\n        foreach(index, val; l) \n        {\n     \
    \       if(index > 0) \n            {\n                if(l[index - 1] > l[index])\
    \ \n                {\n                    flag = true;\n                } \n\
    \                else \n                {\n                    flag = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return flag;\n    } \n    else \n    {\n        auto flag = true;\n    \
    \    foreach(index, val; l) \n        {\n            if(index > 0) \n        \
    \    {\n                if(l[index - 1] < l[index]) \n                {\n    \
    \                flag = true;\n                } \n                else \n   \
    \             {\n                    flag = false;\n                    break;\n\
    \                }\n            }\n        }\n        return flag;\n    }\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvhzni6ym.d(68): unittest failure

    ----------------

    ??:? _d_unittestp [0x42841d]

    ??:? void tmpvhzni6ym.__unittest_L60_C1() [0x428071]

    ??:? void tmpvhzni6ym.__modtest() [0x42819c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c49f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b332]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430974]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430451]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b309]

    ??:? runModuleUnitTests [0x42c275]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool inc\
    \ = true;\n\tbool dec = true;\n\t\n\tfor (int i = 0; i < l.length - 1; i++)\n\t\
    {\n\t\tif (l[i] > l[i + 1])\n\t\t{\n\t\t\tinc = false;\n\t\t}\n\t\tif (l[i] <\
    \ l[i + 1])\n\t\t{\n\t\t\tdec = false;\n\t\t}\n\t}\n\t\n\treturn inc || dec;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ <= 1) \n\t{\n\t\treturn true;\n\t}\n\t\n\timmutable inc = is(typeof(l[0]) ==\
    \ long);\n\tauto prev = l[0];\n\tforeach (cur; l[1 .. $]) \n\t{\n\t\tif (inc)\
    \ \n\t\t{\n\t\t\tif (cur < prev)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    } \n\t\telse \n\t\t{\n\t\t\tif (cur > prev)\n\t\t\t{\n\t\t\t\treturn false;\n\t\
    \t\t}\n\t\t}\n\t\tprev = cur;\n\t}\n\treturn true;\n}\n/*\nReturn the relative\
    \ height of pixels.\n    >>> heightmap([0, 1, 0, 2, 0, 2, 0, 1, 0])\n    [1, 0,\
    \ 1, 0, 1, 0, 1, 0, 1]\n    >>> heightmap([0, 1, 0, 2, 0, 2, 0, 1, 0])\n    [1,\
    \ 0, 1, 0, 1, 0, 1, 0, 1]\n*/\nlong[] heightmap(long[] ls) \n{\n\tlong[] res;\n\
    \tres.length = ls.length;\n\tforeach (immutable i, cur; ls) \n\t{\n\t\tres[i]\
    \ = cur;\n\t\tif (i > 0) \n\t\t{\n\t\t\tif (ls[i - 1] >= cur) \n\t\t\t{\n\t\t\t\
    \tres[i] = ls[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n/*\nReturn a\
    \ list of pixels representing a mountain.\n    >>> mountain(2, 3)\n    [1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> mountain(2, 3, peak_type='inverted_v')\n\
    \    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> mountain(2, 3, peak_type='sp\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6tyklbj0.d(66): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6tyklbj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ monotonic(map!((x) => x[0])(l.zip(l[1..$])));\n}\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([0, 0, 0, 0])\n\
    \    true\n    >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1, 20,\
    \ 4, 10])\n    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9va8pst8.d(15): Error: template instance `map!((x) => x[0])` template
    `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9va8pst8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  bool cmp_asc\
    \ = true;\n  bool cmp_desc = true;\n  bool cmp = true;\n  long prev;\n  foreach(index,\
    \ elem; l)\n  {\n    if(index == 0)\n    {\n      prev = elem;\n      continue;\n\
    \    }\n    cmp_asc &= elem > prev;\n    cmp_desc &= elem < prev;\n    prev =\
    \ elem;\n  }\n  cmp = cmp_asc | cmp_desc;\n  return cmp;\n}\nunittest\n{\n   \
    \ alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_qeob0w8.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282f5]

    ??:? void tmp_qeob0w8.__unittest_L33_C1() [0x427f4d]

    ??:? void tmp_qeob0w8.__modtest() [0x428078]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c303]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b196]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430329]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4307d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4302b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]

    ??:? runModuleUnitTests [0x42c0d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428744]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ (l[$-1] > l[0]) == all!((l[0] > a) => (a))(l);\n}\n \n/*\nReturn true if array\
    \ elements are strictly increasing.\n    >>> strictly_increasing([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> strictly_increasing([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> strictly_increasing([4L, 1L, 0L, -10L])\n    false\n    \n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpclt6m0_1.d(15): Error: found `>` when expecting `)`

    /tmp/tmpclt6m0_1.d(15): Error: missing `{ ... }` for function literal

    /tmp/tmpclt6m0_1.d(15): Error: found `a` when expecting `)` following template
    argument list

    /tmp/tmpclt6m0_1.d(15): Error: found `)` when expecting `;` following `return`
    statement

    /tmp/tmpclt6m0_1.d(15): Error: found `=>` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpclt6m0_1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint count1=0;\n\
    \tint count2=0;\n\tforeach(i; 1..l.length) \n\t{\n\t\tif(l[i]>l[i-1])\n\t\t\t\
    count1++;\n\t\telse if(l[i]<l[i-1])\n\t\t\tcount2++;\n\t}\n\tif(count1==0||count2==0)\n\
    \t\treturn true;\n\telse\n\t\treturn false;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length<2)\
    \ return true;\n    enum bool increasing = l[0]<l[1];\n    for (long n=2; n<l.length;\
    \ n++) {\n        if (increasing) {\n            if (l[n-1]>l[n]) return false;\n\
    \        } else {\n            if (l[n-1]<l[n]) return false;\n        }\n   \
    \ }\n    return true;\n}\n \n/*\nReturn true if array is sorted.\n    >>> sorted([1L,\
    \ 2L, 3L, 4L])\n    true\n    >>> sorted([-9L, 10L, 100L, 4L])\n    false\n  \
    \  >>> sorted([1L, 4L, 0L, -10L])\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpckstae8o.d(16): Error: variable `l` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpckstae8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (long i = 1; i < l.length; i++)\
    \ {\n        if (l[i - 1] > l[i]) {\n            increasing = false;\n       \
    \ }\n        if (l[i - 1] < l[i]) {\n            decreasing = false;\n       \
    \ }\n    }\n    return increasing || decreasing;\n}\n/*\nReturn true if the longest\
    \ monotonic subsequence of the array is increasing.\n    >>> monotonic_increasing([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L, 20L, 4L, 10L])\n\
    \    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n    false\n    \n\
    */\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto prev\
    \ = l[0];\n    auto increasing = true;\n    auto decreasing = true;\n    for (auto\
    \ current : l[1..$]) \n    {\n        if (current > prev) \n        {\n      \
    \      decreasing = false;\n        }\n        else if (current < prev) \n   \
    \     {\n            increasing = false;\n        }\n        prev = current;\n\
    \    }\n    return increasing || decreasing;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp_3m63n4.d(18): Error: no identifier for declarator `current`

    /tmp/tmpp_3m63n4.d(18): Error: expression expected, not `:`

    /tmp/tmpp_3m63n4.d(18): Error: found `l` when expecting `;` following `for` condition

    /tmp/tmpp_3m63n4.d(18): Error: found `..` when expecting `,`

    /tmp/tmpp_3m63n4.d(18): Error: `$` is valid only inside [] of index or slice

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp_3m63n4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ monotonic(array(l));\n}\n/*\nReturn true is array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n\
    \    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L,\
    \ 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc7ybwjk3.d(15): Error: undefined identifier `array`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc7ybwjk3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length==0)\
    \ return true; \n    bool monotonic = true;\n    long last = l[0];\n    for (int\
    \ i=1; i<l.length; i++)\n    {\n      if (last > l[i])\n      {\n        monotonic\
    \ = false;\n        break;\n      }\n      last = l[i];\n    }\n    return monotonic;\n\
    }\n/*\nReturn true is array elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic_str([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic_str([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic_str([4L, 1L, 0L, -10L])\n    true\n\
    \    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw6r0xx3e.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x42831d]

    ??:? void tmpw6r0xx3e.__unittest_L39_C1() [0x427f19]

    ??:? void tmpw6r0xx3e.__modtest() [0x42809c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c39f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b232]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430874]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b209]

    ??:? runModuleUnitTests [0x42c175]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    else \n    {\n        long x\
    \ = l[0];\n        long y = l[1];\n        int direction = compare(x, y);\n  \
    \      foreach (i, y; l[1..$]) \n        {\n            if (compare(x, y) != direction)\
    \ \n            {\n                return false;\n            }\n            x\
    \ = y;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptsqdv0lr.d(23): Error: undefined identifier `compare`

    /tmp/tmptsqdv0lr.d(24): Error: variable `y` is shadowing variable `tmptsqdv0lr.monotonic.y`

    /tmp/tmptsqdv0lr.d(26): Error: undefined identifier `compare`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptsqdv0lr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ temp = l[];\n    sort(temp);\n    if(l[0] == temp[0])\n    {\n        for(int\
    \ i = 0; i < l.length - 1; i++)\n        {\n            if(l[i] > l[i + 1])\n\
    \            {\n                return false;\n            }\n        }\n    \
    \    return true;\n    }\n    else\n    {\n        for(int i = 0; i < l.length\
    \ - 1; i++)\n        {\n            if(l[i] < l[i + 1])\n            {\n     \
    \           return false;\n            }\n        }\n        return true;\n  \
    \  }\n}\n/*\nReturn the index of the middle element of an array.\n    >>> middle([1L,\
    \ 2L, 3L, 4L, 5L])\n    2\n    >>> middle([1L, 4L, 3L, 2L, 5L])\n    2\n    >>>\
    \ middle([1L, 4L, 3L, 5L, 2L])\n    2\n    >>> middle([5L, 2L, 4L, 3L, 1L])\n\
    \    2\n    >>> middle([2L, 5L, 4L, 3L, 1L])\n    2\n*/\nlong middle(long[] l)\
    \ \n{\n    sort(l);\n    long len = l.length;\n    long middle = cast(long) floor(len\
    \ / 2);\n    return middle;\n}\n/*\nReturn the amount of primes in the range 1\
    \ - n.\n    >>> primeRange(0L)\n    0\n    >>> primeRange(1L)\n    0\n    >>>\
    \ primeRange(2L)\n    1\n    >>> primeRange(5L)\n    3\n    >>> primeRange(100L)\n\
    \    25\n*/\nlong primeRange(long n) \n{\n    long counter = 0;\n    if(n > 1)\n\
    \    {\n        foreach(i; 1 .. n + 1)\n        {\n            if(isPrime(i))\n\
    \            {\n                counter++;\n            }\n        }\n    }\n\
    \    return counter;\n}\n/*\nReturn true if a number is prime, false otherwise.\n\
    \    >>> isPrime\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdf8q22nr.d(88): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdf8q22nr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto old\
    \ = l[0];\n    long flag = 0;\n    foreach(old; l)\n    {\n        if(old < old)\n\
    \        {\n            flag = 1;\n        }\n        else if(old > old)\n   \
    \     {\n            flag = -1;\n        }\n        if(flag != 0 && flag != sign(old\
    \ - old))\n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n/*\nReturn true if array elements are monotonically increasing or\
    \ decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    true\n    >>> monotonic([1,\
    \ 20, 4, 10])\n    false\n    >>> monotonic([4, 1, 0, -10])\n    true\n    \n\
    */\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw2iakmdz.d(17): Error: variable `old` is shadowing variable `tmpw2iakmdz.monotonic.old`

    /tmp/tmpw2iakmdz.d(27): Error: undefined identifier `sign`, did you mean template
    `sgn(F)(F x)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw2iakmdz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n   bool up=true;\
    \ bool down=true;\n   if (l.length > 1)\n   {\n       for (size_t i=1; i<l.length;\
    \ i++)\n       {\n            if (l[i] > l[i-1]) { down=false; }\n           \
    \ if (l[i] < l[i-1]) { up=false; }\n            if ( (up==false) && (down==false)\
    \ ) { return false; }\n       }\n   }\n   return true;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ new_l = l.dup;\n    sort(new_l);\n    if(new_l == l)\n        return true;\n\
    \    reverse(new_l);\n    if(new_l == l)\n        return true;\n    return false;\n\
    }\n/*\n    Tuple of the first and last elements of the input array.\n    >>> first_last([0L,\
    \ 1L, 2L, 5L, 7L])\n    (0L, 7L)\n*/\ntuple(long, long) first_last(long[] l)\n\
    {\n    auto first = l[0];\n    auto last = l[$-1];\n    return tuple(first, last);\n\
    }\n/*\n    Return the index of the first element which is greater than\n    all\
    \ previous elements, starting from the end of the input array.\n    If no such\
    \ element exists, return -1.\n    >>> first_above([0L, 1L, 2L, 3L, 4L, 4L, 3L,\
    \ 2L, 1L, 0L])\n    4\n    >>> first_above([4L, 4L, 4L, 4L, 4L])\n    -1\n   \
    \ >>> first_above([5L, 4L, 3L, 2L, 1L])\n    -1\n*/\nlong first_above(long[] l)\n\
    {\n    int result = -1;\n    for(int i = $-1; i > 0; i--)\n    {\n        if(l[i]\
    \ > l[i-1])\n        {\n            result = i;\n            break;\n        }\n\
    \    }\n    return result;\n}\n/*\n    Return the sum of the absolute differences\
    \ between neighbouring\n    elements in the input array.\n    >>> sum_distances([1L,\
    \ 2L, 5L, 7L])\n    4\n    >>> sum_distances([-1L, 2L, 1L, 0L])\n    6\n*/\nlong\
    \ sum_distances(long[] l)\n{\n    long result = 0;\n    for(int i = 0; i < $-1;\
    \ i++)\n    {\n        result += abs(l[i+1] - l[i]);\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq_e9u1yk.d(29): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpq_e9u1yk.d(29): Error: no identifier for declarator `tuple(long, long)`

    /tmp/tmpq_e9u1yk.d(29): Error: semicolon expected following function declaration

    /tmp/tmpq_e9u1yk.d(29): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpq_e9u1yk.d(30): Error: no identifier for declarator `first_last(long[]
    l)`

    /tmp/tmpq_e9u1yk.d(49): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpq_e9u1yk.d(70): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpq_e9u1yk.d(73): Error: found `unittest` instead of statement

    /tmp/tmpq_e9u1yk.d(86): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_e9u1yk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164351
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool dir\
    \ = (l[0] < l[1]);\n    foreach(i; 1..$-1) \n    {\n        if (l[i-1] == l[i])\n\
    \            continue;\n        if (dir != (l[i-1] < l[i]))\n            return\
    \ false;\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplrdeng4o.d(16): Error: `$` is valid only inside [] of index or
    slice

    /tmp/tmplrdeng4o.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrdeng4o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  long i =\
    \ 0L;\n  long n = l.length;\n  while ((i < n - 1L))\n  {\n    if (((l[i] > l[i\
    \ + 1L]) && (i == 0L)))\n    {\n      i += 1L;\n      while ((i < n - 1L))\n \
    \     {\n        if ((l[i] < l[i + 1L]))\n        {\n          return false;\n\
    \        }\n        i += 1L;\n      }\n      return true;\n    }\n    else if\
    \ (((l[i] < l[i + 1L]) && (i == 0L)))\n    {\n      i += 1L;\n      while ((i\
    \ < n - 1L))\n      {\n        if ((l[i] > l[i + 1L]))\n        {\n          return\
    \ false;\n        }\n        i += 1L;\n      }\n      return true;\n    }\n  \
    \  else\n    {\n      return false;\n    }\n  }\n  return true;\n}\n/*\nReturns\
    \ true if the array is sorted in increasing order.\n    >>> is_sorted([1L, 2L,\
    \ 3L, 5L])\n    true\n    >>> is_sorted([1L, 2L, 3L, 5L, 4L])\n    false\n   \
    \ >>> is_sorted([1L, 2L, 3L, 5L, 3L])\n    false\n    \n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi07x80az.d(73): unittest failure

    ----------------

    ??:? _d_unittestp [0x42845d]

    ??:? void tmpi07x80az.__unittest_L62_C1() [0x4281c2]

    ??:? void tmpi07x80az.__modtest() [0x4281dc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b372]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430505]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430491]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b349]

    ??:? runModuleUnitTests [0x42c2b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428920]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\talias typ\
    \ = typeof(l[0]);\n\tauto diffs = l[1..$].map!((x) => cast(typ) (x - l[$ - 1]));\n\
    \treturn diffs.uniq.length <= 1;\n}\n/*\nReturn true if array of integers is a\
    \ permutation of range(n).\n    >>> isPermutation([1L, 2L, 3L, 4L])\n    true\n\
    \    >>> isPermutation([3L, 2L, 4L, 1L])\n    true\n    >>> isPermutation([4L,\
    \ 3L, 1L, 0L])\n    false\n    >>> isPermutation([1L, 2L, 3L, 2L])\n    false\n\
    \    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp89um1i93.d(16): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp89um1i93.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = false;\n    bool decreasing = false;\n    long prev;\n    int i;\n    if(l.length\
    \ > 1) \n    {\n        prev = l[0];\n        i = 1;\n        while(i < l.length)\
    \ \n        {\n            if(l[i] > prev) \n            {\n                increasing\
    \ = true;\n            }\n            else if(l[i] < prev) \n            {\n \
    \               decreasing = true;\n            }\n            prev = l[i];\n\
    \            i++;\n        }\n    }\n    else \n    {\n        return true;\n\
    \    }\n    return !increasing || !decreasing;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto i\
    \ = 0L;\n    auto j = 0L;\n    auto k = 0L;\n    auto incrementing = false;\n\
    \    auto decrementing = false;\n    if (l.length > 0L) \n    {\n        i = 1L;\n\
    \        j = l.length - 1L;\n        k = l[i] - l[i - 1L];\n        while (i <\
    \ j) \n        {\n            if (k > 0L) \n            {\n                incrementing\
    \ = true;\n                if (l[i] < l[i - 1L]) \n                {\n       \
    \             return false;\n                }\n            }\n            else\
    \ if (k < 0L) \n            {\n                decrementing = true;\n        \
    \        if (l[i] > l[i - 1L]) \n                {\n                    return\
    \ false;\n                }\n            }\n            if (incrementing && decrementing)\
    \ \n            {\n                return false;\n            }\n            i\
    \ = i + 1L;\n        }\n    }\n    return true;\n}\n/*\nReturn the running sum\
    \ of an array.\n    >>> running_sum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>>\
    \ running_sum([])\n    []\n*/\nlong[] running_sum(long[] l) \n{\n    auto out\
    \ = new long[](l.length);\n    if (l.length > 0L) \n    {\n        out[0L] = l[0L];\n\
    \        auto i = 1L;\n        while (i < l.length) \n        {\n            out[i]\
    \ = out[i - 1L] + l[i];\n            i = i + 1L;\n        }\n    }\n    return\
    \ out;\n}\n/*\nReturn the running product of an array.\n    >>> running_product([1,\
    \ 2, 3, 4])\n    [1, 2, 6, 24]\n    >>> running_product([])\n    []\n*/\nlong[]\
    \ running_product(long[] l) \n{\n    auto out = new long[](l.length);\n    if\
    \ (l.length > 0L) \n\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ipxd81d.d(61): Error: basic type expected, not `out`

    /tmp/tmp7ipxd81d.d(61): Error: no identifier for declarator `_error_`

    /tmp/tmp7ipxd81d.d(61): Error: found `out` instead of statement

    /tmp/tmp7ipxd81d.d(64): Error: found `out` instead of statement

    /tmp/tmp7ipxd81d.d(68): Error: found `out` instead of statement

    /tmp/tmp7ipxd81d.d(72): Error: expression expected, not `out`

    /tmp/tmp7ipxd81d.d(83): Error: basic type expected, not `out`

    /tmp/tmp7ipxd81d.d(83): Error: no identifier for declarator `_error_`

    /tmp/tmp7ipxd81d.d(83): Error: found `out` instead of statement

    /tmp/tmp7ipxd81d.d(86): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ipxd81d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \  l.length < 2 || reduce!(\"lhs < rhs\")(l);\n}\n/*\nFind the point of insertion.\n\
    \    >>> pointofinsertion([2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L,\
    \ 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L, 97L], 13L)\n\
    \    5\n    >>> pointofinsertion([2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L,\
    \ 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L, 97L],\
    \ 53L)\n    15\n    >>> pointofinsertion([2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L,\
    \ 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L,\
    \ 97L], 1L)\n    0\n    >>> pointofinsertion([2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L,\
    \ 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L,\
    \ 97L], 100L)\n    25\n*/\nlong pointofinsertion(long[] l, long x) \n{\n    size_t\
    \ insertPoint = 0;\n    foreach(range; 0 .. l.length) \n    {\n        if(l[range]\
    \ > x)\n            break;\n        insertPoint++;\n    }\n    return insertPoint;\n\
    }\n/*\nGiven a list, return a new list with a position move. A position move is\
    \ a tuple with two elements:\n    the position of the element to move, and\n \
    \   the destination position, where\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmhmuwl5h.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmhmuwl5h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool dec;\n\
    \    long prev, curr;\n    if (l.length < 2) return true;\n    curr = l[0];\n\
    \    dec = false;\n    foreach (i,e; l[1..$]) \n    {\n        prev = curr;\n\
    \        curr = e;\n        if (prev != curr) \n        {\n            if (dec\
    \ && prev < curr) return false;\n            if (!dec && prev > curr) return false;\n\
    \            dec = prev > curr;\n        }\n    }\n    return true;\n}\n/*\nReturn\
    \ true if array elements are monotonically increasing, monotonically decreasing\
    \ or are constant.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n\
    \    >>> monotonic([4L, 1L, 0L, -10L, -10L])\n    true\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L, -9L])\n    false\n    \n*/\nunittest\n{\n    alias candidate =\
    \ monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl8l0wnlp.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x428365]

    ??:? void tmpl8l0wnlp.__unittest_L47_C1() [0x427f61]

    ??:? void tmpl8l0wnlp.__modtest() [0x4280e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b27a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43040d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308bc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430399]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b251]

    ??:? runModuleUnitTests [0x42c1bd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428828]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    bool increasing = true;\n    long last = l[0];\n    foreach\
    \ (i; l[1..$]) {\n        if (last != i) increasing = last < i;\n        if (last\
    \ < i != increasing) return false;\n        last = i;\n    }\n    return true;\n\
    }\n/*\nReturn the length of the longest monotonic subsequence of the given array.\n\
    \    >>> longest_monotonic_subsequence([3L, 1L, 4L, 1L, 5L, 9L, 2L, 6L, 5L, 3L,\
    \ 5L, 8L, 9L, 7L, 9L])\n    7\n    >>> longest_monotonic_subsequence([])\n   \
    \ 0\n    >>> longest_monotonic_subsequence([1L])\n    1\n*/\nunittest\n{\n   \
    \ alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5zqfb0_i.d(20): Error: found `!=` when expecting `)`

    /tmp/tmp5zqfb0_i.d(20): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5zqfb0_i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    long[] w = l[];\n    if (w[0]\
    \ > w[1]) \n    {\n        reverse(w);\n    }\n    foreach (immutable i, immutable\
    \ x; w) \n    {\n        if (i > 0 && x < w[i - 1]) \n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n/*\nReturn the maximum value\
    \ of the elements in the array. If the array is empty,\n    return an empty optional.\n\
    \    >>> maximum([1L, 4L, 20L, -1L])\n    20L\n    >>> maximum([])\n    empty\n\
    \    \n*/\nTypeTuple!(long, bool) maximum(long[] l) \n{\n    if (l.length < 1)\
    \ \n    {\n        return tuple(0L, false);\n    }\n    long[] w = l[];\n    reverse(w);\n\
    \    return tuple(w[0], true);\n}\n/*\nCompute the mean (average) of the elements\
    \ in the array.\n    >>> mean([1L, 2L, 3L, 4L])\n    2.5\n    >>> mean([])\n \
    \   0.0\n    \n*/\ndouble mean(long[] l) \n{\n    if (l.length < 1) \n    {\n\
    \        return 0.0;\n    }\n    long[] w = l[];\n    return sum(w) / w.length;\n\
    }\n/*\nReturn the median (middle value) of the elements in the array. If the array\
    \ is\n    empty, return an empty optional.\n    >>> median([1L, 2L, 3L, 4L])\n\
    \    2L\n    >>> median([1L, 2L, 3L, 4L, 5L])\n    3L\n    >>> median([])\n  \
    \  empty\n    \n*/\nTypeTuple!(long, bool) median(long[] l) \n{\n    if (l.length\
    \ < 1) \n    {\n        return tuple(0L, false);\n    }\n    long[] w = l[];\n\
    \    sort(w);\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp797jvy9v.d(88): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp797jvy9v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0) return true;\n    long prev = l[0];\n    long direction = 0;\n    foreach\
    \ (i; 1..l.length) {\n        if (prev == l[i]) continue;\n        if (direction\
    \ == 0) {\n            direction = l[i] - prev;\n        } else if (direction\
    \ > 0 && l[i] - prev < 0) {\n            return false;\n        } else if (direction\
    \ < 0 && l[i] - prev > 0) {\n            return false;\n        }\n        prev\
    \ = l[i];\n    }\n    return true;\n}\n/*\nReturns a 2-tuple of two arrays, the\
    \ first containing those elements\n    in the input array `l` that are smaller\
    \ than `k`, the second of\n    which contains those elements in `l` that are larger\
    \ than `k`.\n    >>> partition([2L, 3L, 1L, 20L, 14L, 5L], 10L)\n    ([2L, 3L,\
    \ 1L, 5L], [20L, 14L])\n*/\nTuple!(long[], long[]) partition(long[] l, long k)\
    \ \n{\n    long[] small = [];\n    long[] large = [];\n    foreach (i; l) {\n\
    \        if (i < k) {\n            small ~= i;\n        } else {\n           \
    \ large ~= i;\n        }\n    }\n    return tuple(small, large);\n}\n/*\nReturns\
    \ a pair of lists, the first containing those elements in the\n    input list\
    \ `l` that are smaller than `k`, the second of which\n    contains those elements\
    \ in `l` that are larger than `k`.\n    >>> partition2([2L, 3L, 1L, 20L, 14L,\
    \ 5L], 10L)\n    ([2L, 3L, 1L, 5L], [20L, 14L])\n*/\nTuple!(Long[], Long[]) partition2(Long[]\
    \ l, long k) \n{\n    Long[] small = [];\n    Long[] large = [];\n    foreach\
    \ (i; l) {\n        if (i < k) {\n            small ~= i;\n        }\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd3hlgeru.d(66): Error: found `unittest` instead of statement

    /tmp/tmpd3hlgeru.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd3hlgeru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    int n = l.length;\n    for (int i\
    \ = 1; i < n; i++)\n    {\n        increasing &= l[i] >= l[i - 1];\n        decreasing\
    \ &= l[i] <= l[i - 1];\n    }\n    return increasing || decreasing;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyeq1_0hw.d(17): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyeq1_0hw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length<=1)\n\
    \        return true;\n    bool increasing=l[1]>l[0];\n    foreach(index,e;l[1..$])\n\
    \    {\n        if (e>l[index-1] && !increasing)\n            return false;\n\
    \        if (e<l[index-1] && increasing)\n            return false;\n    }\n \
    \   return true;\n}\n/*\nReturn true is array elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([\"a\", \"b\", \"c\", \"d\"])\n    true\n\
    \    >>> monotonic([\"a\", \"d\", \"c\", \"b\"])\n    false\n*/\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpkkkmttle.d(20): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428456]

    ??:? bool tmpkkkmttle.monotonic(long[]) [0x427de1]

    ??:? void tmpkkkmttle.__unittest_L34_C1() [0x427ea1]

    ??:? void tmpkkkmttle.__modtest() [0x428124]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c427]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2ba]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43044d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303d9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]

    ??:? runModuleUnitTests [0x42c1fd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n    {\n        return true;\n    }\n    return l[$-1] >= l[0] || l[$-1]\
    \ <= l[0];\n}\n/*\n    >>> monotonic([2L, 1L, -1L, -10L])\n    false\n    >>>\
    \ monotonic([3L, 3L, 3L, 3L])\n    true\n*/\n \n/*\nReturn true if the mean of\
    \ a series of values is close to the target value.\n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps9efreb5.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428315]

    ??:? void tmps9efreb5.__unittest_L31_C1() [0x427ec3]

    ??:? void tmps9efreb5.__modtest() [0x428094]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c397]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b22a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43086c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430349]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b201]

    ??:? runModuleUnitTests [0x42c16d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    switch\
    \ (l.length) \n    {\n        case 0:\n            return true;\n        case\
    \ 1:\n            return true;\n        default:\n            return l[0] < l[1]\
    \ ? std.all!(a => a < l[1])(l) : std.all!(a => a > l[1])(l);\n    }\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm5krukr4.d(22): Error: undefined identifier `all` in package `std`

    /tmp/tmpm5krukr4.d(22): Error: undefined identifier `all` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm5krukr4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ == 0)\n    {\n        return true;\n    }\n    long previousValue = l[0];\n\
    \    bool directionIsUp = false;\n    bool first = true;\n    foreach(const currentValue;\
    \ l)\n    {\n        if(!first)\n        {\n            if(currentValue < previousValue)\n\
    \            {\n                if(directionIsUp)\n                {\n       \
    \             return false;\n                }\n            }\n            else\
    \ if(currentValue > previousValue)\n            {\n                if(!directionIsUp)\n\
    \                {\n                    directionIsUp = true;\n              \
    \  }\n            }\n        }\n        else\n        {\n            first = false;\n\
    \        }\n        previousValue = currentValue;\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    long first = l[0];\n    bool inc = l[1] >= first;\n \
    \   for (long i = 1; i < l.length; i++)\n    {\n        long cur = l[i];\n   \
    \     if (cur == first) continue;\n        bool newInc = cur >= first;\n     \
    \   if (newInc != inc) return false;\n    }\n    return true;\n}\n/*\nReturn the\
    \ index of the first monotonic part of the array.\n    >>> first_monotonic([1L,\
    \ 20L, 4L, 10L])\n    1\n    >>> first_monotonic([1L, 1L, 1L, 1L])\n    0\n*/\n\
    long first_monotonic(long[] l) \n{\n    return first_monotonic(l, 0, l.length);\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5_5zp_b3.d(36): Error: function `tmp5_5zp_b3.first_monotonic(long[]
    l)` is not callable using argument types `(long[], int, ulong)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_5zp_b3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    // TODO:\
    \ use `zip` or maybe reduce\n    // TODO: use `if` instead of `continue`\n   \
    \ // TODO: use `break` instead of return\n    if (l.length < 2) return true;\n\
    \    bool increasing = true;\n    foreach (i, v; l) {\n        if (i==0) continue;\n\
    \        if (v < l[i-1]) {\n            increasing = false;\n            break;\n\
    \        }\n    }\n    if (increasing) return true;\n    bool decreasing = true;\n\
    \    foreach (i, v; l) {\n        if (i==0) continue;\n        if (v > l[i-1])\
    \ {\n            decreasing = false;\n            break;\n        }\n    }\n \
    \   return decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n \
    \   assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long n\
    \ = l.length;\n    /*\n    // can use this but not allowed in d language\n   \
    \ return all(l[i] < l[i+1] for i in range(n-1)) or all(l[i] > l[i+1] for i in\
    \ range(n-1));\n    */\n    bool increasing = true;\n    bool decreasing = true;\n\
    \    for (long i = 0; i < n-1; i++)\n    {\n        if(l[i] >= l[i+1])\n     \
    \       increasing = false;\n        if(l[i] <= l[i+1])\n            decreasing\
    \ = false;\n    }\n    return increasing || decreasing;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy_0wzc9_.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x42835d]

    ??:? void tmpy_0wzc9_.__unittest_L31_C1() [0x427fb1]

    ??:? void tmpy_0wzc9_.__modtest() [0x4280dc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b272]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b249]

    ??:? runModuleUnitTests [0x42c1b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428820]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    immutable\
    \ bool increasing = true;\n    immutable bool decreasing = true;\n    return l.length\
    \ < 2 || ((increasing && !std.algorithm.any!((a, b) => a > b)(l))\n          \
    \                  || (decreasing && !std.algorithm.any!((a, b) => a < b)(l)));\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpht5rps40.d(17): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpht5rps40.d(18): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpht5rps40.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool direction\
    \ = l[1] > l[0];\n\tforeach( long i, long j; l[1..$])\n\t{\n\t\ti = j;\n\t\tj\
    \ = l[$-1];\n\t\tif((i - j) * (1L - (1L - direction) * 2L) < 0L)\n\t\t\treturn\
    \ false;\n\t}\n\treturn true;\n}\n/*\nEliminate adjacent duplicates.\n    >>>\
    \ dedupe([1L, 2L, 2L, 1L, 2L, 1L, 1L, 2L, 3L, 3L, 3L, 4L, 5L, 5L, 3L, 3L, 1L,\
    \ 2L, 3L, 4L, 5L, 5L, 1L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 5L, 2L, 1L, 2L, 3L,\
    \ 4L, 5L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 5L, 4L,\
    \ 3L, 2L, 1L, 2L, 3L, 4L, 5L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L,\
    \ 3L, 4L, 5L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L,\
    \ 5L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 5L,\
    \ 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 4L, 3L, 2L, 1L, 2L, 3L, 4L, 5L, 5L, 4L, 3L,\
    \ 2L, 1\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprg56r1lb.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg56r1lb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool monotonic\
    \ = true;\n    long[] tmpL = l[$-1..$];\n    while (tmpL.length > 0)\n    {\n\
    \        auto min = min(tmpL);\n        auto pos = std.algorithm.find(tmpL, min);\n\
    \        if (pos.empty)\n        {\n            break;\n        }\n        auto\
    \ posLast = pos.front;\n        tmpL = tmpL[0..posLast];\n        if (posLast\
    \ > 0)\n        {\n            long[] tmp = tmpL[$-1..$];\n            long[]\
    \ minL = tmpL[0..$-1];\n            if (tmp > minL)\n            {\n         \
    \       monotonic = false;\n                break;\n            }\n        }\n\
    \    }\n    return monotonic;\n}\n/*\nReturn the first non-monotonic index.\n\
    \    >>> first_nonomonic_index([1L, 2L, 4L, 20L])\n    -1\n    >>> first_nonomonic_index([1L,\
    \ 20L, 4L, 10L])\n    1\n    >>> first_nonomonic_index([4L, 1L, 0L, -10L])\n \
    \   -1\n*/\nlong first_nonomonic_index(long[] l) \n{\n    bool monotonic = true;\n\
    \    long ind = -1;\n    long[] tmpL = l[$-1..$];\n    while (tmpL.length > 0)\n\
    \    {\n        auto min = min(tmpL);\n        auto pos = std.algorithm.find(tmpL,\
    \ min);\n        if (pos.empty)\n        {\n            break;\n        }\n  \
    \      auto posLast = pos.front;\n        tmpL = tmpL[0..posLast];\n        if\
    \ (posLast > 0)\n        {\n            long[] tmp = tmpL[$-1..$];\n         \
    \   long[] minL = tmpL[0..$-1];\n            if (tmp > minL)\n            {\n\
    \                monotonic = false;\n                ind = ind + posLast + 1;\n\
    \                break;\n            }\n        }\n        ind = ind + posLast\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm2_ftxve.d(76): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpm2_ftxve.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpm2_ftxve.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm2_ftxve.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ map!(a => a[0] > a[1])(zip(l[1 .. $], l[0 .. $ - 1])).all!((a) => !a);\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9n6g2er9.d(15): Error: template instance `map!((a) => a[0] > a[1])`
    template `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9n6g2er9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n    if (l.length\
    \ == 0) return true;\n    auto limit = l[0];\n    bool increasing = true;\n  \
    \  foreach (i, e; l) \n    {\n        if (e != limit) \n        {\n          \
    \  if (increasing) \n            {\n                if (e < limit) \n        \
    \        {\n                    increasing = false;\n                    if (e\
    \ < limit) return false;\n                }\n            } \n            else\
    \ \n            {\n                if (e > limit) return false;\n            }\n\
    \            limit = e;\n        }\n    }\n    return true;\n}\n/*\nReturn true\
    \ if given number is a prime.\n    >>> is_prime(2L)\n    true\n    >>> is_prime(3L)\n\
    \    true\n    >>> is_prime(4L)\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpojygesyr.d(14): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpojygesyr.d(14): Error: declaration expected, not `if`

    /tmp/tmpojygesyr.d(17): Error: declaration expected, not `foreach`

    /tmp/tmpojygesyr.d(17): Error: no identifier for declarator `l`

    /tmp/tmpojygesyr.d(17): Error: declaration expected, not `)`

    /tmp/tmpojygesyr.d(26): Error: declaration expected, not `if`

    /tmp/tmpojygesyr.d(27): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpojygesyr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n    pure nothrow\
    \ @safe @nogc\n{\n    bool increasing = true;\n    bool decreasing = true;\n \
    \   for (long i = 1; i < l.length; i++)\n    {\n        increasing &= l[i - 1]\
    \ <= l[i];\n        decreasing &= l[i - 1] >= l[i];\n    }\n    return increasing\
    \ || decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ < 2) return true;\n    long prev = l[0];\n    bool increase = true;\n    if(prev\
    \ > l[1]) increase = false;\n    prev = l[1];\n    int i = 2;\n    while(i < l.length)\
    \ {\n        if(increase && prev > l[i]) return false;\n        if(!increase &&\
    \ prev < l[i]) return false;\n        prev = l[i];\n        i++;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ <= 1) \n    {\n        return true;\n    }\n    size_t half = l.length / 2;\n\
    \    auto l1 = l[0 .. half];\n    auto l2 = l[half .. $];\n    return l1.back\
    \ <= l2.front && monotonic(l1) && monotonic(l2);\n}\n// Length of list l.\nsize_t\
    \ len(T)(T[] l) \n{\n    return l.length;\n}\n// Memory used by the list.\nlong\
    \ mem(T)(T[] l) \n{\n    return l.capacity * l.tupleof.sizeof;\n}\n// Test if\
    \ all items in l are unique.\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf37es_oc.d(22): Error: no property `back` for type `long[]`

    /tmp/tmpf37es_oc.d(22): Error: no property `front` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf37es_oc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool result;\n\
    \    auto l2 = sort(l);\n    if(l == l2)\n    {\n        result = true;\n    }\n\
    \    else\n    {\n        l2 = sort(l, std.less);\n        if(l == l2)\n     \
    \   {\n            result = true;\n        }\n        else\n        {\n      \
    \      result = false;\n        }\n    }\n    return result;\n}\n//Function that\
    \ converts an integer to a tuple.\nauto intToTuple(long l)\n{\n    long[] l2;\n\
    \    auto result = l2.init;\n    while(l > 0)\n    {\n        result ~= l % 10;\n\
    \        l /= 10;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ksf7n8a.d(16): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ksf7n8a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n   return\
    \ std.algorithm.isSorted(l, lt) \n      || std.algorithm.isSorted(l, gt);\n}\n\
    \ \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvdt_stvy.d(15): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpvdt_stvy.d(16): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvdt_stvy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto sign\
    \ = 0;\n    foreach (i, a; l) \n    {\n        if (i + 1 >= l.length)\n      \
    \      break;\n        if (a == l[i + 1])\n            continue;\n        if (sign\
    \ == 0)\n            sign = a < l[i + 1] ? 1 : -1;\n        if (sign != (a < l[i\
    \ + 1] ? 1 : -1))\n            return false;\n    }\n    return true;\n}\n/*\n\
    Return successive combination items:\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwannk083.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwannk083.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1)\n    {\n        return true;\n    }\n    long prev_elem = l[0];\n    long\
    \ prev_diff = 0;\n    foreach (elem; l[1..])\n    {\n        long diff = elem\
    \ - prev_elem;\n        if (prev_diff == 0)\n        {\n            prev_diff\
    \ = diff;\n        }\n        else if (prev_diff > 0 && diff < 0)\n        {\n\
    \            return false;\n        }\n        else if (prev_diff < 0 && diff\
    \ > 0)\n        {\n            return false;\n        }\n        prev_elem = elem;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp99kvmpda.d(21): Error: expression expected, not `]`

    /tmp/tmp99kvmpda.d(21): Error: found `)` when expecting `,`

    /tmp/tmp99kvmpda.d(38): Error: found `return` when expecting `,`

    /tmp/tmp99kvmpda.d(38): Error: found `;` when expecting `,`

    /tmp/tmp99kvmpda.d(39): Error: expression expected, not `}`

    /tmp/tmp99kvmpda.d(40): Error: found `unittest` when expecting `,`

    /tmp/tmp99kvmpda.d(53): Error: found `void` when expecting `,`

    /tmp/tmp99kvmpda.d(53): Error: found `{` when expecting `,`

    /tmp/tmp99kvmpda.d(53): Error: expression expected, not `}`

    /tmp/tmp99kvmpda.d(53): Error: found `End of File` when expecting `,`

    /tmp/tmp99kvmpda.d(53): Error: found `End of File` when expecting `]`

    /tmp/tmp99kvmpda.d(53): Error: found `End of File` when expecting `)`

    /tmp/tmp99kvmpda.d(53): Error: found `End of File` instead of statement

    /tmp/tmp99kvmpda.d(53): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp99kvmpda.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool ascending\
    \ = true;\n    bool descending = true;\n    if(l.length < 2)\n        return true;\n\
    \    auto a = l.dup;\n    auto b = l.dup;\n    sort(a);\n    sort(b,std.algorithm.greater!\"\
    a < b\");\n    if(a == l)\n        return true;\n    if(b == l)\n        return\
    \ true;\n    return false;\n}\n/*\nReturn true if array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1f, 2f, 4f, 20f])\n    true\n\
    \    >>> monotonic([1f, 20f, 4f, 10f])\n    false\n    >>> monotonic([4f, 1f,\
    \ 0f, -10f])\n    true\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpofsoma2l.d(21): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpofsoma2l.d(22): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpofsoma2l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \npure nothrow\
    \ @nogc @safe\n{\n    if (l.length == 0) \n    {\n        return true;\n    }\n\
    \    // assert(l.length != 0);\n    auto el = l[0];\n    foreach (i, ref a; l)\
    \ \n    {\n        if (a > el) \n        {\n            el = a;\n        }\n \
    \       else if (a < el) \n        {\n            return false;\n        }\n \
    \   }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1rw9k0q0.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428315]

    ??:? void tmp1rw9k0q0.__unittest_L35_C1() [0x427f11]

    ??:? void tmp1rw9k0q0.__modtest() [0x428094]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c397]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b22a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43086c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430349]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b201]

    ??:? runModuleUnitTests [0x42c16d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin {\n    assert(l.length\
    \ > 0);\n}\nout (bool result)\n{\n    assert(result == true);\n}\n{\n    bool\
    \ increasing = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length;\
    \ i++) {\n        if (l[i-1] > l[i]) {\n            increasing = false;\n    \
    \    }\n        if (l[i-1] < l[i]) {\n            decreasing = false;\n      \
    \  }\n    }\n    return increasing || decreasing;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwz9lnnd3.d(17): Error: `(identifier) { ... }` or `(identifier;
    expression)` following `out` expected, not `bool`

    /tmp/tmpwz9lnnd3.d(17): Error: found `result` when expecting `)`

    /tmp/tmpwz9lnnd3.d(17): Error: statement expected to be `{ }`, not `)`

    /tmp/tmpwz9lnnd3.d(17): Error: found `)` instead of statement

    /tmp/tmpwz9lnnd3.d(20): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwz9lnnd3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    foreach (i, j; zip(l[0..$-1], l[1..$]))\n    {\n        if (i >\
    \ j)\n        {\n            increasing = false;\n            break;\n       \
    \ }\n    }\n    if (increasing)\n        return true;\n    else\n    {\n     \
    \   bool decreasing = true;\n        foreach (i, j; zip(l[0..$-1], l[1..$]))\n\
    \        {\n            if (i < j)\n            {\n                decreasing\
    \ = false;\n                break;\n            }\n        }\n        return decreasing;\n\
    \    }\n}\n/*\nReturn true if list of numbers are in increasing order and adjacent\
    \ values are not equal.\n    >>> strict_monotonic([1L, 3L, 4L, 6L])\n    true\n\
    \    >>> strict_monotonic([1L, 3L, 4L, 4L])\n    false\n    >>> strict_monotonic([-10L,\
    \ -9L, -7L, -2L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoe2k_q65.d(16): Error: undefined identifier `zip`

    /tmp/tmpoe2k_q65.d(29): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoe2k_q65.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increase\
    \ = true;\n    bool decrease = true;\n    for (int i = 1; i < l.length; i++) {\n\
    \        increase &= l[i - 1] <= l[i];\n        decrease &= l[i - 1] >= l[i];\n\
    \    }\n    return increase || decrease;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ all(zip(l[0..$-1], l[1..$]).map!((a, b) { return b > a; }));\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp52ssz_jv.d(15): Error: undefined identifier `all`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp52ssz_jv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool up\
    \ = l[0] < l[1];\n    foreach(size_t i, long e; l) \n    {\n        if(up && e\
    \ < l[i - 1])\n            return false;\n        if(!up && e > l[i - 1])\n  \
    \          return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpbdsyxaof.d(18): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428426]

    ??:? bool tmpbdsyxaof.monotonic(long[]) [0x427dbd]

    ??:? void tmpbdsyxaof.__unittest_L25_C1() [0x427e75]

    ??:? void tmpbdsyxaof.__modtest() [0x4280f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3f7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b28a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43041d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308cc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b261]

    ??:? runModuleUnitTests [0x42c1cd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    auto sign = (l[1] - l[0]) / abs(l[1]\
    \ - l[0]);\n    if (sign == 0) \n    {\n        return false;\n    }\n    foreach\
    \ (i, val; l[1..]) \n    {\n        if (sign * (val - l[i - 1]) < 0) \n      \
    \  {\n            return false;\n        }\n    }\n    return true;\n}\n/*\nReturn\
    \ true if array elements are monotonically increasing or decreasing,\n    treating\
    \ elements as if they were in a circular list.\n    >>> circular_monotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> circular_monotonic([1L, 20L, 4L, 10L])\n  \
    \  false\n    >>> circular_monotonic([4L, 1L, 0L, -10L])\n    true\n    >>> circular_monotonic([4L,\
    \ 1L, -10L, 0L])\n    true\n    >>> circular_monotonic([1L, 20L, -10L, 10L])\n\
    \    true\n    >>> circular_monotonic([1L, -10L, 20L, 10L])\n    true\n    >>>\
    \ circular_monotonic([1L, 20L, -10L, -20L])\n    true\n    >>> circular_monotonic([1L,\
    \ -10L, -20L, 20L])\n    true\n    >>> circular_monotonic([1L, 10L, 20L, -10L])\n\
    \    true\n    >>> circular_monotonic([1L, -10L, 20L, 10L])\n    true\n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt1cnlooy.d(24): Error: expression expected, not `]`

    /tmp/tmpt1cnlooy.d(24): Error: found `)` when expecting `,`

    /tmp/tmpt1cnlooy.d(31): Error: found `return` when expecting `,`

    /tmp/tmpt1cnlooy.d(31): Error: found `;` when expecting `,`

    /tmp/tmpt1cnlooy.d(32): Error: expression expected, not `}`

    /tmp/tmpt1cnlooy.d(57): Error: found `unittest` when expecting `,`

    /tmp/tmpt1cnlooy.d(70): Error: found `void` when expecting `,`

    /tmp/tmpt1cnlooy.d(70): Error: found `{` when expecting `,`

    /tmp/tmpt1cnlooy.d(70): Error: expression expected, not `}`

    /tmp/tmpt1cnlooy.d(70): Error: found `End of File` when expecting `,`

    /tmp/tmpt1cnlooy.d(70): Error: found `End of File` when expecting `]`

    /tmp/tmpt1cnlooy.d(70): Error: found `End of File` when expecting `)`

    /tmp/tmpt1cnlooy.d(70): Error: found `End of File` instead of statement

    /tmp/tmpt1cnlooy.d(70): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt1cnlooy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ < 3) return true;\n    bool increasing = true;\n    long prev = l[0];\n    foreach(i,\
    \ cur; l[1..$])\n    {\n        if(prev > cur)\n        {\n            increasing\
    \ = false;\n            break;\n        }\n        prev = cur;\n    }\n    if(increasing)\
    \ return true;\n    bool decreasing = true;\n    prev = l[0];\n    foreach(i,\
    \ cur; l[1..$])\n    {\n        if(prev < cur)\n        {\n            decreasing\
    \ = false;\n            break;\n        }\n        prev = cur;\n    }\n    return\
    \ decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[long]\
    \ seqs;\n    long currentMax = -1;\n    foreach (i; l) \n    {\n        if (i\
    \ <= currentMax)\n        {\n            seqs[currentMax] = i;\n            currentMax\
    \ = i;\n        }\n        else\n        {\n            currentMax = i;\n    \
    \    }\n    }\n    return seqs.length == 0;\n}\n/*\nReturn true if array elements\
    \ are monotonically increasing or decreasing.\n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyu_p3eny.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428c71]

    ??:? void tmpyu_p3eny.__unittest_L34_C1() [0x427f89]

    ??:? void tmpyu_p3eny.__modtest() [0x42810c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dd53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ace]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ab05]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ab94]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aa91]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428aa5]

    ??:? runModuleUnitTests [0x42db29]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296d0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n  //std.algorithm.isSorted(l)\n\
    \  //return true;\n{\n    auto it = l.front.next;\n    bool ret = it.isValid;\n\
    \    while (it.isValid) {\n        bool cond;\n        cond = it.value > it.previous.value;\n\
    \        if (ret) ret = cond;\n        else ret = !cond;\n        it = it.next;\n\
    \    }\n    return ret;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp446owwhj.d(17): Error: no property `front` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp446owwhj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    size_t\
    \ i = 1L;\n    size_t l_len = l.length;\n    bool res = true;\n    while (i <\
    \ l_len)\n    {\n        if (l[i - 1L] > l[i])\n        {\n            res = false;\n\
    \            break;\n        }\n        i += 1L;\n    }\n    return res;\n}\n\
    /*\nReturn true is array elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L,\
    \ 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt2641vdi.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282f5]

    ??:? void tmpt2641vdi.__unittest_L39_C1() [0x427ef1]

    ??:? void tmpt2641vdi.__modtest() [0x428074]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c377]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b20a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43039d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43084c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430329]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e1]

    ??:? runModuleUnitTests [0x42c14d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    \n   \
    \ bool dir;\n    foreach(i,j; zip(l[0..$-1], l[1..$]))\n    {\n        if (i==0)\n\
    \        {\n            dir = (j-i > 0);\n        }\n        else\n        {\n\
    \            if (dir != (j-i > 0)) return false;\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn0fnfz6k.d(17): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn0fnfz6k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool up\
    \ = true;\n    bool down = true;\n    int last = l[0];\n    foreach(int v; l)\n\
    \    {\n        if (v > last)\n            down = false;\n        if (v < last)\n\
    \            up = false;\n        last = v;\n    }\n    return up || down;\n}\n\
    /*\nReturn true if array elements are monotonically increasing.\n    >>> strictly_monotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> strictly_monotonic([1L, 20L, 4L, 10L])\n  \
    \  false\n    >>> strictly_monotonic([4L, 1L, 0L, -10L])\n    false\n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5c82syxy.d(17): Error: cannot implicitly convert expression `l[0]`
    of type `long` to `int`

    /tmp/tmp5c82syxy.d(18): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5c82syxy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool descending;\n\
    \tif (l.length < 2) \n\t{\n\t\treturn true;\n\t}\n\tdescending = (l[0] > l[1]);\n\
    \tfor (size_t i = 1; i < l.length - 1; i++) \n\t{\n\t\tif ((descending && l[i]\
    \ < l[i + 1]) || (!descending && l[i] > l[i + 1])) \n\t\t{\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;\n}\n/*\n    >>> majorVersion(1L)\n    0\n    >>> majorVersion(10L)\n\
    \    1\n    >>> majorVersion(20L)\n    2\n*/\nsize_t majorVersion(long N) \n{\n\
    \tint count = 0;\n\tfor (; N > 1; N = N / 10) \n\t{\n\t\tcount++;\n\t}\n\treturn\
    \ count;\n}\n/*\n    >>> minVersion(0L)\n    1\n    >>> minVersion(1L)\n    10\n\
    \    >>> minVersion(2L)\n    20\n*/\nlong minVersion(long N) \n{\n\treturn 10L\
    \ ^ N;\n}\n/*\n    >>> maxVersion(0L)\n    9\n    >>> maxVersion(1L)\n    99\n\
    \    >>> maxVersion(2L)\n    999\n*/\nlong maxVersion(long N) \n{\n\tif (N ==\
    \ 0) \n\t{\n\t\treturn 9;\n\t}\n\treturn 10L ^ N - 1;\n}\n/*\n    >>> validVersions([0L,\
    \ 3L, 5L])\n    3\n    >>> validVersions([1L, 2L, 4L])\n    0\n    >>> validVersions([1L,\
    \ 2L, 3L])\n    1\n    >>> validVersions([2L, 3L, 4L])\n    2\n    >>> validVersions([3L,\
    \ 4L, 5L])\n    3\n    >>> validVersions([3L, 4L, 5L, 8L])\n    3\n    >>> validVersions([3L,\
    \ 4L, 5L, 6L])\n    4\n    >>> validVersions([3\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsddhtn3l.d(75): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsddhtn3l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool incr\
    \ = true;\n    bool decr = true;\n    bool first = true;\n    long prev = 0L;\n\
    \    foreach (i; l) \n    {\n        if (first) \n        {\n            first\
    \ = false;\n        } \n        else \n        {\n            if (prev > i)\n\
    \                incr = false;\n            if (prev < i)\n                decr\
    \ = false;\n        }\n        prev = i;\n    }\n    return incr or decr;\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmo6cgr76.d(34): Error: found `or` when expecting `;` following
    `return` statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmo6cgr76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool direction\
    \ = null;\n    if (l.length <= 1)\n    {\n        return true;\n    }\n    foreach\
    \ (i, elem; l)\n    {\n        if (i == 0)\n        {\n            continue;\n\
    \        }\n        if (elem < l[i - 1])\n        {\n            if (direction\
    \ is true)\n            {\n                return false;\n            }\n    \
    \        direction = false;\n        }\n        else if (elem > l[i - 1])\n  \
    \      {\n            if (direction is false)\n            {\n               \
    \ return false;\n            }\n            direction = true;\n        }\n   \
    \ }\n    return true;\n}\n/*\nTest if an array is sorted\n    >>> sorted([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> sorted([1L, 20L, 4L, 10L])\n    false\n   \
    \ >>> sorted([1L, 20L, 4L, 4L, 10L])\n    false\n    \n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmn_0rq42.d(15): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmn_0rq42.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin\n{\n    assert(l.length\
    \ > 0);\n}\nbody\n{\n    bool increasing = true;\n    bool decreasing = true;\n\
    \    for (int i = 1; i < l.length; i++)\n    {\n        if (l[i - 1] > l[i])\n\
    \        {\n            increasing = false;\n        }\n        if (l[i - 1] <\
    \ l[i])\n        {\n            decreasing = false;\n        }\n    }\n    return\
    \ increasing || decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ l[0] <= l[l.length - 1] \n        ? __monotonic(l) \n        : __monotonic(l.reversed);\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxu2f1z8e.d(16): Error: undefined identifier `__monotonic`, did
    you mean function `monotonic`?

    /tmp/tmpxu2f1z8e.d(17): Error: undefined identifier `__monotonic`, did you mean
    function `monotonic`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxu2f1z8e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ all(l[0..$-1] < l[1..$]) or all(l[0..$-1] > l[1..$]);\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwkw6ti1m.d(15): Error: found `or` when expecting `;` following
    `return` statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwkw6ti1m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin {\n  assert(l.length\
    \ > 0);\n}\nout {\n  assert(foreach (i, j; zip(l[0 .. $ - 1], l[1 .. $])) | i\
    \ < j);\n}\nbody {\n  bool increasing = true;\n  bool decreasing = true;\n  foreach\
    \ (i, j; zip(l[0 .. $ - 1], l[1 .. $])) {\n    if (i > j) {\n      increasing\
    \ = false;\n    } else if (i < j) {\n      decreasing = false;\n    }\n  }\n \
    \ return increasing || decreasing;\n}\n/*\nReturn the list of the maximal elements\
    \ of the array.\n    >>> maxima([0L, 1L, 2L, 3L, 3L, 2L, 1L, 0L])\n    [3L, 3L]\n\
    \    >>> maxima([1L, 2L, 3L, 3L, 3L, 2L, 1L, 0L])\n    [3L, 3L, 3L]\n    >>> maxima([])\n\
    \    []\n*/\nlong[] maxima(long[] l) \nin {\n  assert(l.length > 0);\n}\nout {\n\
    \  assert(foreach (i, j; zip(result[0 .. $ - 1], result[1 .. $])) | i < j);\n\
    }\nbody {\n  return [item for (item; l) if (item == maximum(l))];\n}\n/*\nLeft-rotate\
    \ the array by an integer number of elements.\nThe leftmost elements are wrapped\
    \ around to the right.\n    >>> rotateLeft([1L, 2L, 3L, 4L, 5L], 1)\n    [2L,\
    \ 3L, 4L, 5L, 1L]\n    >>> rotateLeft([1L, 2L, 3L, 4L, 5L], 4)\n    [5L, 1L, 2L,\
    \ 3L, 4L]\n    >>> rotateLeft([1L, 2L, 3L, 4L, 5L], -1)\n    [5L, 1L, 2L, 3L,\
    \ 4L]\n    >>> rotateLeft([1L, 2L, 3L, 4L, 5L\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpljxa9w2l.d(18): Error: expression expected, not `foreach`

    /tmp/tmpljxa9w2l.d(18): Error: found `;` when expecting `,`

    /tmp/tmpljxa9w2l.d(18): Error: `i < j` must be parenthesized when next to operator
    `|`

    /tmp/tmpljxa9w2l.d(46): Error: expression expected, not `foreach`

    /tmp/tmpljxa9w2l.d(46): Error: found `;` when expecting `,`

    /tmp/tmpljxa9w2l.d(46): Error: `i < j` must be parenthesized when next to operator
    `|`

    /tmp/tmpljxa9w2l.d(49): Error: found `for` when expecting `,`

    /tmp/tmpljxa9w2l.d(49): Error: found `;` when expecting `)`

    /tmp/tmpljxa9w2l.d(49): Error: found `l` when expecting `,`

    /tmp/tmpljxa9w2l.d(49): Error: expression expected, not `)`

    /tmp/tmpljxa9w2l.d(49): Error: found `if` when expecting `,`

    /tmp/tmpljxa9w2l.d(51): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpljxa9w2l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ all(l[1..l.length - 2] .map!(x => (x < l[0]) == (x < l[-1])));\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy7k270n7.d(15): Error: undefined identifier `all`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy7k270n7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool res\
    \ = true;\n    if(l.length != 0)\n    {\n\tlong ref = l[0];\n\tfor(long i = 1;\
    \ i < l.length; i++)\n\t{\n\t    if(ref < l[i])\n\t    {\n\t\tref = l[i];\n\t\
    \    }\n\t    else\n\t    {\n\t\tres = false;\n\t\tbreak;\n\t    }\n\t}\n    }\n\
    \    return res;\n}\n/*\nGenerate 'n' samples from unit gaussian.  Return array\
    \ of samples.\n    >>> unit_gaussian(5)\n    [-0.04682082121118954, -1.821595319174724,\
    \ -0.1530484645345898, 0.19459690547489435, -0.27678214812195586]\n    \n*/\n\
    long[] unit_gaussian(long n) \n{\n    long[] res = new long[n];\n    for(long\
    \ i = 0; i < n; i++)\n    {\n\tres[i] = (long)random();\n    }\n    return res;\n\
    }\n/*\nReturn the mean of a list of numbers.\n    >>> mean([1L, 2L, 3L, 4L, 5L])\n\
    \    3.0\n    \n*/\ndouble mean(long[] l) \n{\n    long sum = 0;\n    for(long\
    \ i = 0; i < l.length; i++)\n    {\n\tsum += l[i];\n    }\n    return (double)sum\
    \ / l.length;\n}\n/*\nReturn the covariance of a list of numbers.\n    >>> covariance([1L,\
    \ 2L, 3L, 4L, 5L], [1L, 2L, 3L, 4L, 5L])\n    2.5\n    \n*/\ndouble covariance(long[]\
    \ l1, long[] l2) \n{\n    assert(l1.length == l2.length);\n    double m1 = mean(l1);\n\
    \    double m2 = mean(l2);\n    double res = 0;\n    for(long i = 0; i < l1\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppq9bi2q7.d(18): Error: no identifier for declarator `long`

    /tmp/tmppq9bi2q7.d(18): Error: basic type expected, not `=`

    /tmp/tmppq9bi2q7.d(18): Error: no identifier for declarator `_error_`

    /tmp/tmppq9bi2q7.d(18): Error: found `=` instead of statement

    /tmp/tmppq9bi2q7.d(21): Error: expression expected, not `<`

    /tmp/tmppq9bi2q7.d(21): Error: found `l` when expecting `)`

    /tmp/tmppq9bi2q7.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmppq9bi2q7.d(23): Error: basic type expected, not `=`

    /tmp/tmppq9bi2q7.d(23): Error: no identifier for declarator `_error_`

    /tmp/tmppq9bi2q7.d(23): Error: found `=` instead of statement

    /tmp/tmppq9bi2q7.d(25): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmppq9bi2q7.d(32): Error: declaration expected, not `return`

    /tmp/tmppq9bi2q7.d(33): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppq9bi2q7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin {\n  assert(isValid(l));\n\
    }\nout {\n  assert(forall (a, b; 0 <= a < b < |l| ==> l[a] <= l[b]) ||\n\t forall\
    \ (a, b; 0 <= a < b < |l| ==> l[a] >= l[b]));\n}\ndo {\n  return (forall (a, b;\
    \ 0 <= a < b < |l| ==> l[a] <= l[b]) ||\n\t  forall (a, b; 0 <= a < b < |l| ==>\
    \ l[a] >= l[b]));\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp08fgtvla.d(18): Error: found `;` when expecting `,`

    /tmp/tmp08fgtvla.d(18): Error: found `<` when expecting `,`

    /tmp/tmp08fgtvla.d(18): Error: expression expected, not `|`

    /tmp/tmp08fgtvla.d(18): Error: found `l` when expecting `,`

    /tmp/tmp08fgtvla.d(18): Error: expression expected, not `|`

    /tmp/tmp08fgtvla.d(18): Error: expression expected, not `>`

    /tmp/tmp08fgtvla.d(18): Error: found `l` when expecting `,`

    /tmp/tmp08fgtvla.d(19): Error: found `;` when expecting `,`

    /tmp/tmp08fgtvla.d(19): Error: found `<` when expecting `,`

    /tmp/tmp08fgtvla.d(19): Error: expression expected, not `|`

    /tmp/tmp08fgtvla.d(19): Error: found `l` when expecting `,`

    /tmp/tmp08fgtvla.d(19): Error: expression expected, not `|`

    /tmp/tmp08fgtvla.d(19): Error: expression expected, not `>`

    /tmp/tmp08fgtvla.d(19): Error: found `l` when expecting `,`

    /tmp/tmp08fgtvla.d(22): Error: found `;` when expecting `,`

    /tmp/tmp08fgtvla.d(22): Error: found `<` when expecting `,`

    /tmp/tmp08fgtvla.d(22): Error: expression expected, not `|`

    /tmp'
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool mono\
    \ = true;\n    int i = 0;\n    while(i < l.length - 1)\n    {\n        if (l[i]\
    \ >= l[i+1])\n        {\n            mono = false;\n            break;\n     \
    \   }\n        i++;\n    }\n    return mono;\n}\n/*\nTest if an array is sorted.\n\
    \    >>> issorted([1L, 1L, 2L, 4L, 20L])\n    true\n    >>> issorted([1L, 20L,\
    \ 4L, 10L])\n    false\n    >>> issorted([4L, 1L, 0L, -10L])\n    false\n    >>>\
    \ issorted([1L, 1L, 2L, 4L, 20L], false)\n    true\n    >>> issorted([1L, 20L,\
    \ 4L, 10L], false)\n    false\n    >>> issorted([4L, 1L, 0L, -10L], false)\n \
    \   true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxcmacwp5.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282e5]

    ??:? void tmpxcmacwp5.__unittest_L44_C1() [0x427ee1]

    ??:? void tmpxcmacwp5.__modtest() [0x428064]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c367]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43038d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43083c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430319]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d1]

    ??:? runModuleUnitTests [0x42c13d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1)\n        return true;\n    \n    auto direction = l[1] - l[0];\n    foreach\
    \ (i, e; l[1..$])\n    {\n        if (i != 0 && direction * (e - l[i - 1]) < 0)\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr174emzk.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42835d]

    ??:? void tmpr174emzk.__unittest_L26_C1() [0x42801e]

    ??:? void tmpr174emzk.__modtest() [0x4280e0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b272]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b249]

    ??:? runModuleUnitTests [0x42c1b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428820]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\treturn l.all!\"\
    a < b\"(l);\n}\n \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyuvw30_4.d(15): Error: no property `all` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyuvw30_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool monotonic;\n\
    \    for (int i = 1; i < l.length; i++) {\n        if (!(l[i] >= l[i - 1])) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n/*\nReturn\
    \ true if array elements are decreasing.\n    >>> monotonic([1L, 20L, 4L, 10L])\n\
    \    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyw2zasch.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282dd]

    ??:? void tmpyw2zasch.__unittest_L31_C1() [0x427ed9]

    ??:? void tmpyw2zasch.__modtest() [0x42805c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c35f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430385]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430834]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430311]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]

    ??:? runModuleUnitTests [0x42c135]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ == 0)\n        return true;\n    bool is_monotonic = true;\n    bool increasing\
    \ = l[0] < l[1];\n    if(increasing)\n    {\n        for(int i = 1; i < l.length;\
    \ i++)\n        {\n            if(l[i] < l[i-1])\n            {\n            \
    \    is_monotonic = false;\n                break;\n            }\n        }\n\
    \    }\n    else\n    {\n        for(int i = 1; i < l.length; i++)\n        {\n\
    \            if(l[i] > l[i-1])\n            {\n                is_monotonic =\
    \ false;\n                break;\n            }\n        }\n    }\n    return\
    \ is_monotonic;\n}\n/*\nfind the first element in ascending order that is larger\
    \ than the key value. \nreturn 0 if the key value is the largest in the array.\n\
    \    >>> find_max_index_ascending([3L, 4L, 5L, 10L], 8L)\n    3\n    >>> find_max_index_ascending([3L,\
    \ 4L, 5L, 10L], 10L)\n    3\n    >>> find_max_index_ascending([3L, 4L, 5L, 10L],\
    \ 0L)\n    0\n    >>> find_max_index_ascending([3L, 4L, 5L, 10L], 5L)\n    2\n\
    */\nlong find_max_index_ascending(long[] l, long key)\n{\n    long hi = l.length\
    \ - 1;\n    if(key >= l[hi])\n        return hi;\n    long lo = 0;\n    while(lo\
    \ < hi)\n    {\n        long mid = (lo + hi) / 2;\n        if(l[mid] <= key)\n\
    \            lo = mid + 1;\n        else\n            hi = mid;\n    }\n    return\
    \ lo;\n}\n/*\nBinary search for key index in ascending ordered list. \nReturn\
    \ index of the matched value. If no match, return negative number \n    >>> binary_search_ascending([3L,\
    \ 4L, 5L, 10L\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ji5yvfq.d(71): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ji5yvfq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    \n   \
    \ if (l.length < 3)\n        return true;\n    \n    auto ids = std.algorithm.sort!((a,\
    \ b) => a < b)(iota(l.length));\n    bool sign = true;\n    bool old_sign = true;\n\
    \    bool res = true;\n    foreach (id; ids)\n    {\n        auto cur_i = id;\n\
    \        auto next_i = id + 1;\n        if (next_i >= l.length)\n            break;\n\
    \        auto cur = l[cur_i];\n        auto next = l[next_i];\n        sign =\
    \ cur < next;\n        if (old_sign != sign)\n        {\n            res = false;\n\
    \            break;\n        }\n        old_sign = sign;\n    }\n    return res;\n\
    }\n/*\nReturn true is array elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1.0, 2.0, 4.0, 20.0])\n    true\n    >>> monotonic([1.0, 20.0,\
    \ 4.0, 10.0])\n    false\n    >>> monotonic([4.0, 1.0, 0.0, -10.0])\n    true\n\
    \    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8cuq7h4p.d(19): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8cuq7h4p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto len\
    \ = l.length;\n    auto sign = l[1] > l[0] ? 1 : -1;\n    for (int i = 1; i <\
    \ len - 1; i++)\n    {\n        if (sign * (l[i + 1] - l[i]) < 0)\n        {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n/*\nReturn\
    \ true if the element of array is all the same.\n    >>> all_same([1L, 1L, 1L,\
    \ 1L])\n    true\n    >>> all_same([1L, 1L, 2L, 1L])\n    false\n    >>> all_same([1L,\
    \ 1L, -1L, 1L])\n    false\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ isIncreasing(l) || isDecreasing(l);\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5vxf0py7.d(15): Error: undefined identifier `isIncreasing`

    /tmp/tmp5vxf0py7.d(15): Error: undefined identifier `isDecreasing`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5vxf0py7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ > 1)\n    {\n        return equal(l, sort(l));\n    }\n    else \n    {\n  \
    \      return true;\n    }\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnystprr9.d(17): Error: undefined identifier `equal`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnystprr9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n    if (l.length\
    \ < 2) return true;\n    auto isLess = false;\n    auto isMore = false;\n    foreach\
    \ (idx, item; l)\n    {\n        if (idx == 0) continue;\n        if (item > l[idx\
    \ - 1]) isMore = true;\n        if (item < l[idx - 1]) isLess = true;\n      \
    \  if (isMore && isLess) return false;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpod9cldjw.d(14): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpod9cldjw.d(14): Error: declaration expected, not `if`

    /tmp/tmpod9cldjw.d(17): Error: declaration expected, not `foreach`

    /tmp/tmpod9cldjw.d(17): Error: no identifier for declarator `l`

    /tmp/tmpod9cldjw.d(17): Error: declaration expected, not `)`

    /tmp/tmpod9cldjw.d(20): Error: declaration expected, not `if`

    /tmp/tmpod9cldjw.d(21): Error: declaration expected, not `if`

    /tmp/tmpod9cldjw.d(22): Error: declaration expected, not `if`

    /tmp/tmpod9cldjw.d(23): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpod9cldjw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long diff\
    \ = l[1] - l[0];\n    for (int i = 1; i < l.length; i++)\n    {\n        if ((diff\
    \ > 0 && l[i] < l[i - 1]) || (diff < 0 && l[i] > l[i - 1]))\n        {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\n/*\nGenerate all\
    \ binomial coefficients of n\n    >>> pascal(5)\n    ((1,), (1, 1), (1, 2, 1),\
    \ (1, 3, 3, 1), (1, 4, 6, 4, 1))\n*/\nauto pascal(long n) \n{\n    //\n    //if\
    \ (n < 0)\n    //{\n    //    return null;\n    //}\n    //if (n == 0)\n    //{\n\
    \    //    return tuple(tuple(1L));\n    //}\n    //auto prev = pascal(n - 1);\n\
    \    //auto next = new long[prev.length + 1];\n    //next[0] = 1;\n    //next[next.length\
    \ - 1] = 1;\n    //for (int i = 1; i < next.length - 1; i++)\n    //{\n    //\
    \    next[i] = prev[i - 1] + prev[i];\n    //}\n    //return tuple(next);\n  \
    \  //\n    long[] prev = null;\n    foreach (dummy; 0..n + 1)\n    {\n       \
    \ long[] next = null;\n        if (dummy == 0)\n        {\n            next =\
    \ new long[1];\n            next[0] = 1;\n        }\n        else\n        {\n\
    \            next = new long[prev.length + 1];\n            next[0] = 1;\n   \
    \         next[next.length - 1] = 1;\n            for (int i = 1; i < next.length\
    \ - 1; i++)\n            {\n                next[i] = prev[i - 1] + prev[i];\n\
    \            }\n        }\n        yield tuple(next);\n        prev = next;\n\
    \    }\n}\n/*\nReturn a list of (n\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb9blu_9n.d(74): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9blu_9n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long diff\
    \ = 0L;\n    foreach (i, v; l) {\n        if (i == 0)\n            continue;\n\
    \        else if (i == 1) {\n            diff = v - l[i - 1];\n            continue;\n\
    \        }\n        else {\n            if (v - l[i - 1] != diff) {\n        \
    \        return false;\n            }\n        }\n    }\n    return true;\n}\n\
    /*\nis_square(n)\nDetermine if a number is square\n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5n4jgz_c.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x428345]

    ??:? void tmp5n4jgz_c.__unittest_L35_C1() [0x427e5c]

    ??:? void tmp5n4jgz_c.__modtest() [0x4280c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b25a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43089c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430379]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]

    ??:? runModuleUnitTests [0x42c19d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428808]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tassert(l.length\
    \ > 0);\n\tlong[] z = l.dup;\n\tz.sort;\n\treturn l == z || l == z.reverse;\n\
    }\n/*\nReturn true if sequence elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic('abcde')\n    true\n    >>> monotonic('abhjik')\n    false\n\
    \    >>> monotonic('hello')\n    false\n    >>> monotonic('zyxwvutsrqponmlkjihgfedcba')\n\
    \    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3uf8yujc.d(17): Error: no property `sort` for type `long[]`

    /tmp/tmp3uf8yujc.d(18): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3uf8yujc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin {\n    assert(l.length\
    \ > 0);\n}\nout(result) {\n    if (result)\n        assert(l.length > 0);\n}\n\
    {\n    return l.map!(a => a - l[0]).elementsAreEqual;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpql15lbqp.d(21): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpql15lbqp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n\
    \ = l.length;\n    bool increasing = true;\n    bool decreasing = true;\n    long\
    \ sign = 1L;\n    long prev = 0L;\n    long curr = 0L;\n    foreach (i, e; l)\
    \ {\n        curr = e;\n        if (i > 0) {\n            sign = (curr - prev)\
    \ / abs(curr - prev);\n            increasing = increasing && (sign > 0L);\n \
    \           decreasing = decreasing && (sign < 0L);\n        }\n        prev =\
    \ curr;\n    }\n    return increasing || decreasing;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9u6l1dmr.d(15): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9u6l1dmr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    bool ret;\n    long first = l[0];\n    ret = true;\n\
    \    foreach (i, value; l) {\n        if (value > first) {\n            if (ret\
    \ == false) return false;\n            ret = true;\n        }\n        else if\
    \ (value < first) {\n            if (ret == true) return false;\n            ret\
    \ = false;\n        }\n        first = value;\n    }\n    return true;\n}\n/*\n\
    Return true if 'n' is prime.\n    >>> isprime(2L)\n    true\n    >>> isprime(3L)\n\
    \    true\n    >>> isprime(4L)\n    false\n    >>> isprime(5L)\n    true\n   \
    \ >>> isprime(10L)\n    false\n    >>> isprime(100L)\n    false\n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy0kf6rzo.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x42831d]

    ??:? void tmpy0kf6rzo.__unittest_L47_C1() [0x427f19]

    ??:? void tmpy0kf6rzo.__modtest() [0x42809c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c39f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b232]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430874]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b209]

    ??:? runModuleUnitTests [0x42c175]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length==0)\
    \ \n        return true;\n    if (l.length==1) \n        return true;\n    if\
    \ (l.length==2) \n        return l[0] < l[1];\n    int direction = -1; // unknown\n\
    \    for (int i=1; i<l.length; i++) \n    {\n        if (l[i-1] == l[i]) \n  \
    \          continue;\n        if (direction == -1) \n            direction = l[i-1]\
    \ < l[i] ? 1 : 0;\n        if (direction == 0 && l[i-1] > l[i]) \n           \
    \ return false;\n        if (direction == 1 && l[i-1] < l[i]) \n            return\
    \ false;\n    }\n    return true;\n}\n/*\nReturn true if number is monotonically\
    \ increasing or decreasing.\n    >>> monotonic(3198)\n    true\n    >>> monotonic(2465)\n\
    \    false\n    >>> monotonic(7689)\n    true\n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbog2bdbn.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x428475]

    ??:? void tmpbog2bdbn.__unittest_L44_C1() [0x427f8c]

    ??:? void tmpbog2bdbn.__modtest() [0x4281f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4f7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b38a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43051d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309cc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b361]

    ??:? runModuleUnitTests [0x42c2cd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428938]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool result\
    \ = true;\n    long prev = l[0];\n    int i = 1;\n    for (; i < l.length; i++)\n\
    \    {\n        long curr = l[i];\n        if (prev > curr)\n        {\n     \
    \       result = false;\n            break;\n        }\n        prev = curr;\n\
    \    }\n    if (result)\n    {\n        return true;\n    }\n    result = true;\n\
    \    prev = l[0];\n    for (i = 1; i < l.length; i++)\n    {\n        long curr\
    \ = l[i];\n        if (prev < curr)\n        {\n            result = false;\n\
    \            break;\n        }\n        prev = curr;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tsize_t i;\
    \ \n\tsize_t size = l.length;\n\t\n\tif (size == 0) \n\t{\n\t\treturn true;\n\t\
    }\n\telse \n\t{\n\t\tlong x0 = l[0];\n\t\tbool increasing = true;\n\t\tbool decreasing\
    \ = true;\n\t\tforeach (x; l[1..$]) \n\t\t{\n\t\t\tif (x0 > x) \n\t\t\t{\n\t\t\
    \t\tincreasing = false;\n\t\t\t}\n\t\t\tif (x0 < x) \n\t\t\t{\n\t\t\t\tdecreasing\
    \ = false;\n\t\t\t}\n\t\t\tif (!increasing && !decreasing) \n\t\t\t{\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\tx0 = x;\n\t\t}\n\t\treturn true;\n\t}\n}\n/*\nReturn\
    \ the number of elements in array that are monotonically increasing.\n    >>>\
    \ count_increasing([1L, 2L, 4L, 20L])\n    3\n    >>> count_increasing([1L, 20L,\
    \ 4L, 10L])\n    2\n    >>> count_increasing([4L, 1L, 0L, -10L])\n    1\n    >>>\
    \ count_increasing([])\n    0\n*/\nsize_t count_increasing(long[] l) \n{\n\tsize_t\
    \ i; \n\tsize_t size = l.length;\n\tsize_t count = 0;\n\tif (size == 0) \n\t{\n\
    \t\treturn 0;\n\t}\n\telse \n\t{\n\t\tlong x0 = l[0];\n\t\tforeach (x; l[1..$])\
    \ \n\t\t{\n\t\t\tif (x0 <= x) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tx0 =\
    \ x;\n\t\t}\n\t\treturn count;\n\t}\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    //printf(\"\
    monotonic:%L\\n\", l);\n    bool increasing = true;\n    if (l.length == 0)\n\
    \        return true;\n    long val = l[0];\n    foreach (long i, idx; l)\n  \
    \  {\n        if (val != i)\n        {\n            if (val > i)\n           \
    \     increasing = false;\n            break;\n        }\n    }\n    if (increasing)\n\
    \    {\n        //printf(\"increasing:%L\\n\", l);\n        foreach (long i, idx;\
    \ l)\n        {\n            if (val < i)\n                return false;\n   \
    \         val = i;\n        }\n    }\n    else\n    {\n        //printf(\"decreasing:%L\\\
    n\", l);\n        foreach (long i, idx; l)\n        {\n            if (val > i)\n\
    \                return false;\n            val = i;\n        }\n    }\n    return\
    \ true;\n}\n/*\nReturn true if a sequence is monotonic.\n    >>> isMonotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> isMonotonic([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> isMonotonic([4L, 1L, 0L, -10L])\n    true\n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpksmyxzcq.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283bd]

    ??:? void tmpksmyxzcq.__unittest_L60_C1() [0x427ed4]

    ??:? void tmpksmyxzcq.__modtest() [0x428140]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c43f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430465]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430914]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2a9]

    ??:? runModuleUnitTests [0x42c215]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428880]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool b\
    \ = true;\n    foreach(immutable idx; 0 .. l.length - 1)\n    {\n        if(l[idx]\
    \ < l[idx + 1])\n        {\n            b = false;\n            break;\n     \
    \   }\n    }\n    return b;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl5fup_xk.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282ed]

    ??:? void tmpl5fup_xk.__unittest_L26_C1() [0x427e00]

    ??:? void tmpl5fup_xk.__modtest() [0x42806c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c36f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b202]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430395]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430844]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430321]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d9]

    ??:? runModuleUnitTests [0x42c145]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    long len = l.length;\n    if (len\
    \ == 0) \n    {\n        return true;\n    }\n    long last = l[0];\n    for (long\
    \ i = 1; i < len; i++) \n    {\n        if (l[i] < last) \n        {\n       \
    \     increasing = false;\n        }\n        if (l[i] > last) \n        {\n \
    \           decreasing = false;\n        }\n        last = l[i];\n    }\n    return\
    \ increasing || decreasing;\n}\n/*\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa7kshw6u.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa7kshw6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1) \n    {\n        return true;\n    }\n    else \n    {\n        auto it\
    \ = l.front;\n        auto next = l.popFront();\n        int change = 0;\n   \
    \     while (next !is null) \n        {\n            change += (next - it);\n\
    \            if (change < 0) \n            {\n                return false;\n\
    \            }\n            it = next;\n            next = l.popFront();\n   \
    \     }\n        return true;\n    }\n}\n/*\nGiven a list of numbers, return a\
    \ pair of numbers that have the lowest difference between them.\n    >>> min_difference([1L,\
    \ 3L, 20L, -11L, 100L, -120L])\n    [1L, 2L]\n    >>> min_difference([1L, 2L,\
    \ 4L, 20L])\n    [1L, 2L]\n    >>> min_difference([1L, 2L, 4L, 20L, 100L])\n \
    \   [1L, 2L]\n    >>> min_difference([1L, 2L, 4L, 20L, 101L])\n    [20L, 21L]\n\
    */\nTuple!(long, long) min_difference(long[] l) \n{\n    l.sort;\n    long[] differences\
    \ = [];\n    for (int i = 0; i < l.length - 1; i++) \n    {\n        differences\
    \ ~= l[i + 1] - l[i];\n    }\n    auto index = differences.indexOf(differences.min);\n\
    \    return tuple(l[index], l[index + 1]);\n}\n/*\nGiven a list of numbers, return\
    \ a pair of numbers that have the largest difference between them.\n    >>> max_difference([1L,\
    \ 3L, 20L, -11L, 100L, -120L])\n    [100L, 101L]\n    >>> max_difference([1L,\
    \ 2L, 4L, 20L])\n    [20L, 21L]\n    >>> max_difference([1L, 2L, 4L, 20L, 100L])\n\
    \    [100L, 101L]\n    >>>\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw8qgnzum.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw8qgnzum.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n    in \n   \
    \ {\n        assert(l.length > 0);\n    }\n    body \n    {\n        long[] a\
    \ = l[];\n        bool is_inc = l[0] < l[1];\n        for (size_t i = 1; i < a.length;\
    \ i++)\n        {\n            if ((is_inc && a[i] < a[i - 1]) || (!is_inc &&\
    \ a[i] > a[i - 1]))\n            {\n                return false;\n          \
    \  }\n        }\n        return true;\n    }\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool result\
    \ = false;\n    bool direction = true;\n    for (size_t i = 0; i < l.length -\
    \ 1; i++) \n    {\n        bool dir = l[i] < l[i + 1];\n        if(direction !=\
    \ dir) \n        {\n            if(result) \n            {\n                return\
    \ false;\n            }\n            result = true;\n            direction = dir;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n   bool monotonic\
    \ = true;\n   long[] diffs = [l[1] - l[0]];\n   for (int i = 1; i < l.length;\
    \ i++) \n   {\n      diffs ~= l[i] - l[i - 1];\n   }\n   for (int i = 1; i < diffs.length;\
    \ i++) \n   {\n      if (diffs[i] * diffs[i - 1] < 0) \n      {\n         monotonic\
    \ = false;\n         break;\n      }\n   }\n   return monotonic;\n}\n/*\nReturn\
    \ position indices of monotonically increasing or decreasing runs of\nlength >=\
    \ window.\n    >>> monotonic([1L, 2L, 4L, 20L], window=2)\n    [0, 1, 2]\n   \
    \ >>> monotonic([1L, 20L, 4L, 10L], window=2)\n    [0, 1]\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L], window=2)\n    [2, 3]\n*/\nlong[] monotonic(long[] l, long window)\
    \ \n{\n   long[] diffs = [l[1] - l[0]];\n   for (int i = 1; i < l.length; i++)\
    \ \n   {\n      diffs ~= l[i] - l[i - 1];\n   }\n   long[] idx = [];\n   long\
    \ sign_idx = -1;\n   for (int i = 0; i < diffs.length; i++) \n   {\n      if (diffs[i]\
    \ != 0) \n      {\n         if (sign_idx == -1) \n         {\n            sign_idx\
    \ = i;\n         }\n         else if (sign(diffs[i]) != sign(diffs[sign_idx]))\
    \ \n         {\n            if (i - sign_idx >= window) \n            {\n    \
    \           idx ~= range(sign_idx, i);\n            }\n            sign_idx =\
    \ i;\n         }\n      }\n   }\n   if (diffs.length - sign_id\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnbt5a4oy.d(69): Error: found `unittest` when expecting `)`

    /tmp/tmpnbt5a4oy.d(82): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnbt5a4oy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    foreach\
    \ (i, element; l) \n    {\n        if (i > 0) \n        {\n            if (element\
    \ < l[i - 1])\n                return false;\n        }\n    }\n    return true;\n\
    }\n/*\nRemove consecutive duplicates from the array.\n    >>> dedup([1L, 2L, 4L,\
    \ 4L, 20L])\n    [1L, 2L, 4L, 20L]\n*/\nlong[] dedup(long[] l) \n{\n    return\
    \ iota(l.length).filter!(i => l[i] != l[i + 1]).map!(i => l[i]).array;\n}\n/*\n\
    Compute the least common multiple (LCM) of the array elements.\n    >>> lcm([1L,\
    \ 2L, 3L, 4L])\n    12L\n*/\nlong lcm(long[] l) \n{\n    alias cur = l[0];\n \
    \   for (int i = 1; i < l.length; i++) \n    {\n        cur = cur.lcm(l[i]);\n\
    \    }\n    return cur;\n}\n/*\nCompute the greatest common divisor (GCD) of the\
    \ array elements.\n    >>> gcd([1L, 2L, 3L, 4L])\n    1L\n*/\nlong gcd(long[]\
    \ l) \n{\n    alias cur = l[0];\n    for (int i = 1; i < l.length; i++) \n   \
    \ {\n        cur = cur.gcd(l[i]);\n    }\n    return cur;\n}\n/*\nCompute the\
    \ greatest common divisor (GCD) of the array elements.\n*/\nlong gcd(long[][]\
    \ l) \n{\n    alias cur = gcd(l[0]);\n    for (int i = 1; i < l.length; i++) \n\
    \    {\n        cur = cur.gcd(gcd(l[i]));\n    }\n    return cur;\n}\n/*\nRemove\
    \ all elements from `x` which are not elements of `y`.\n    >>> intersection([1L,\
    \ 2L, 3L, 4L], [3L, 1\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf3qz6l6y.d(67): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpf3qz6l6y.d(74): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf3qz6l6y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164352
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    return l[0] < l[1] ? all!(a =>\
    \ a[0] < a[1])(zip(l[0 .. $ - 1], l[1 .. $])) : all!(a => a[0] > a[1])(zip(l[0\
    \ .. $ - 1], l[1 .. $]));\n}\n/*\nReturn true if the given array represents a\
    \ monotonic clockwise or counterclockwise spiral.\n    >>> clockwise_spiral([(0,\
    \ 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    true\n    >>> clockwise_spiral([(0,\
    \ 0), (0, 1), (1, 1), (1, 0), (1, 1)])\n    false\n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwistfyr7.d(19): Error: template instance `all!((a) => a[0] < a[1])`
    template `all` is not defined

    /tmp/tmpwistfyr7.d(19): Error: template instance `all!((a) => a[0] > a[1])` template
    `all` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwistfyr7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin \n{\n\tassert(l.length\
    \ > 0);\n}\nbody \n{\n    if (l.length <= 1) return true;\n    bool incr = l[0]\
    \ < l[1];\n    foreach (immutable i, ref x; l) {\n        if (incr && x < l[i-1])\
    \ return false;\n        if (!incr && x > l[i-1]) return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp7i8n4z2u.d(23): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42854a]

    ??:? bool tmp7i8n4z2u.monotonic(long[]) [0x427e1f]

    ??:? void tmp7i8n4z2u.__unittest_L28_C1() [0x427ee1]

    ??:? void tmp7i8n4z2u.__modtest() [0x428164]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c51b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430541]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b385]

    ??:? runModuleUnitTests [0x42c2f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ std.array.isSorted(l) || std.array.isSorted(l.length, l[0 .. l.length], std.array.Greater{long});\n\
    }\n/*\n    >>> someGreater([1L, 2L, 20L, 4L])\n    false\n    >>> someGreater([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> someGreater([4L, 1L, 0L, -10L])\n    false\n\
    \    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp736f8di5.d(15): Error: found `{` when expecting `,`

    /tmp/tmp736f8di5.d(15): Error: found `}` when expecting `.` following long

    /tmp/tmp736f8di5.d(15): Error: found `)` when expecting identifier following `long`.

    /tmp/tmp736f8di5.d(15): Error: found `;` when expecting `,`

    /tmp/tmp736f8di5.d(16): Error: expression expected, not `}`

    /tmp/tmp736f8di5.d(26): Error: found `unittest` when expecting `,`

    /tmp/tmp736f8di5.d(39): Error: found `void` when expecting `,`

    /tmp/tmp736f8di5.d(39): Error: found `{` when expecting `,`

    /tmp/tmp736f8di5.d(39): Error: expression expected, not `}`

    /tmp/tmp736f8di5.d(39): Error: found `End of File` when expecting `,`

    /tmp/tmp736f8di5.d(39): Error: found `End of File` when expecting `)`

    /tmp/tmp736f8di5.d(39): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmp736f8di5.d(39): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp736f8di5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin {\n    assert(l.length\
    \ > 0);\n}\nout (bool result)\n{\n    result == forall(i in 0 .. l.length - 2,\
    \ l[i] < l[i + 1]);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe2czz0cb.d(17): Error: `(identifier) { ... }` or `(identifier;
    expression)` following `out` expected, not `bool`

    /tmp/tmpe2czz0cb.d(17): Error: found `result` when expecting `)`

    /tmp/tmpe2czz0cb.d(17): Error: statement expected to be `{ }`, not `)`

    /tmp/tmpe2czz0cb.d(17): Error: found `)` instead of statement

    /tmp/tmpe2czz0cb.d(20): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe2czz0cb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \npure nothrow\
    \ \nin {\n    assert(l.length > 0);\n}\nout (bool result)\n{\n    enum bool decreasing\
    \ = false;\n    enum bool increasing = false;\n    enum bool isMonotonic = false;\n\
    \    long[] lCopy = l.dup;\n    long first = lCopy[0];\n    lCopy = lCopy[1..$];\n\
    \    decreasing = all!((a, b) => a > b)(lCopy);\n    increasing = all!((a, b)\
    \ => a < b)(lCopy);\n    if (decreasing)\n    {\n        isMonotonic = true;\n\
    \    }\n    else if (increasing)\n    {\n        isMonotonic = true;\n    }\n\
    \    else\n    {\n        isMonotonic = false;\n    }\n    return isMonotonic;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2kpmxv_p.d(18): Error: `(identifier) { ... }` or `(identifier;
    expression)` following `out` expected, not `bool`

    /tmp/tmp2kpmxv_p.d(18): Error: found `result` when expecting `)`

    /tmp/tmp2kpmxv_p.d(18): Error: statement expected to be `{ }`, not `)`

    /tmp/tmp2kpmxv_p.d(18): Error: found `)` instead of statement

    /tmp/tmp2kpmxv_p.d(25): Error: no identifier for declarator `lCopy`

    /tmp/tmp2kpmxv_p.d(25): Error: declaration expected, not `=`

    /tmp/tmp2kpmxv_p.d(26): Error: no identifier for declarator `decreasing`

    /tmp/tmp2kpmxv_p.d(26): Error: declaration expected, not `=`

    /tmp/tmp2kpmxv_p.d(27): Error: no identifier for declarator `increasing`

    /tmp/tmp2kpmxv_p.d(27): Error: declaration expected, not `=`

    /tmp/tmp2kpmxv_p.d(28): Error: declaration expected, not `if`

    /tmp/tmp2kpmxv_p.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2kpmxv_p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    bool inc = true;\n    bool dec = true;\n    for (size_t\
    \ i = 1; i < l.length; i++) {\n        inc &= l[i] >= l[i - 1];\n        dec &=\
    \ l[i] <= l[i - 1];\n    }\n    return inc || dec;\n}\n/*\nReturn true if a full\
    \ array is unique.\n    >>> unique([1L, 2L, 4L, 20L])\n    true\n    >>> unique([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> unique([4L, 1L, 0L, -10L])\n    true\n  \
    \  >>> unique([1L, 1L, 0L, -10L])\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin{\n    assert(l.length\
    \ > 0);\n}\nbody{\n    if (l.length == 1) return true;\n    bool increasing =\
    \ l[1] > l[0];\n    for (int i = 1; i < l.length; i++) {\n        if (increasing)\
    \ {\n            if (l[i] < l[i-1]) {\n                return false;\n       \
    \     }\n        } else {\n            if (l[i] > l[i-1]) {\n                return\
    \ false;\n            }\n        }\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = l[0] < l[1];\n    foreach (i, e; l)\n    {\n        if (i+1 >= l.length)\n\
    \            break;\n        if (increasing && e > l[i+1])\n            return\
    \ false;\n        if (!increasing && e < l[i+1])\n            return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0) \n    {\n        return true;\n    }\n    auto it = l.byKey();\n    auto\
    \ inc = it.next();\n    auto dec = it.next();\n    if (inc.value < dec.value)\
    \ \n    {\n        inc = it.next();\n        for (int i = inc.key + 1; i < l.length;\
    \ i++) \n        {\n            if (l[i] < l[i - 1]) \n            {\n       \
    \         return false;\n            }\n        }\n    }\n    else \n    {\n \
    \       dec = it.next();\n        for (int i = dec.key + 1; i < l.length; i++)\
    \ \n        {\n            if (l[i] > l[i - 1]) \n            {\n            \
    \    return false;\n            }\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfxw21pny.d(19): Error: template `object.byKey` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(2941):        `object.byKey(T
    : V[K], K, V)(T aa)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(2963):        `object.byKey(T
    : V[K], K, V)(T* aa)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfxw21pny.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    /* ... */\n    long[] copy = l.dup;\n\
    \    /* ... */\n    long first = copy[0];\n    long last = first;\n    /* ...\
    \ */\n    bool result = true;\n    /* ... */\n    foreach (i, n; copy)\n    {\n\
    \        if (n > last)\n        {\n            increasing = true;\n        }\n\
    \        else\n        {\n            increasing = false;\n        }\n       \
    \ if (n < last)\n        {\n            decreasing = true;\n        }\n      \
    \  else\n        {\n            decreasing = false;\n        }\n        last =\
    \ n;\n    }\n    if (!(increasing || decreasing))\n    {\n        result = false;\n\
    \    }\n    /* ... */\n    return result;\n}\n/*\nReturn true iff all array elements\
    \ are equal.\n    >>> all_equal([1L, 2L, 4L, 20L])\n    false\n    >>> all_equal([1L,\
    \ 1L, 1L, 1L])\n    true\n    >>> all_equal([4L, 4L, 4L, 4L])\n    true\n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpre0wz5h_.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x429491]

    ??:? void tmpre0wz5h_.__unittest_L61_C1() [0x4280bf]

    ??:? void tmpre0wz5h_.__modtest() [0x428404]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e073]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42911a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42adfd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ae8c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ad89]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4290f1]

    ??:? runModuleUnitTests [0x42de49]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4299a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool is_increasing\
    \ = false;\n\tbool is_decreasing = false;\n\tforeach(index, i; l) \n\t{\n\t\t\
    if(i == 0) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tlong diff = l[index - 1] - l[index];\n\
    \t\tif(diff > 0) \n\t\t{\n\t\t\tis_increasing = true;\n\t\t}\n\t\telse if(diff\
    \ < 0) \n\t\t{\n\t\t\tis_decreasing = true;\n\t\t}\n\t\tif(is_increasing & is_decreasing)\
    \ \n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n \
    \   alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmppaoudbx9.d(23): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4283de]

    ??:? bool tmppaoudbx9.monotonic(long[]) [0x427d78]

    ??:? void tmppaoudbx9.__unittest_L39_C1() [0x427e2d]

    ??:? void tmppaoudbx9.__modtest() [0x4280b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b242]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430884]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430361]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]

    ??:? runModuleUnitTests [0x42c185]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ s = l[].sort();\n    bool increasing = s == l;\n    bool decreasing = s == l[].reverse();\n\
    \    return increasing || decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpryay3wii.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpryay3wii.d(17): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpryay3wii.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int length\
    \ = l.length;\n    bool decrement = l[0] > l[length - 1];\n    int value = decrement\
    \ ? l[0] : l[length - 1];\n    foreach (i, v; l)\n    {\n        if (decrement)\n\
    \        {\n            if (v > value)\n                return false;\n      \
    \  }\n        else\n        {\n            if (v < value)\n                return\
    \ false;\n        }\n        value = v;\n    }\n    return true;\n}\n/*\nReturn\
    \ the indices where the two input arrays differ.\nIf they are the same return\
    \ array of length 0.\n    >>> list_of_differences([0L, 3L, 20L, 5L], [0L, 3L,\
    \ 10L, 5L])\n    [2L]\n    >>> list_of_differences([0L, 2L, 20L, 5L], [0L, 3L,\
    \ 10L, 5L])\n    [1L, 2L]\n    >>> list_of_differences([0L, 2L, 20L, 5L], [0L,\
    \ 2L, 20L, 5L])\n    []\n*/\nlong[] list_of_differences(long[] in1, long[] in2)\
    \ \n{\n    long[] l = new long[];\n    foreach (i, v; in1)\n    {\n        if\
    \ (v != in2[i])\n            l ~= i;\n    }\n    return l;\n}\n/*\nReturn indices\
    \ of consecutive differences in the input array.\n    >>> consecutive_differences([0L,\
    \ 2L, 20L, 5L])\n    [[0L, 1L], [2L, 3L]]\n    >>> consecutive_differences([0L,\
    \ 2L, 20L, 20L])\n    [[0L, 1L], [2L, 3L]]\n    >>> consecutive_differences([0L,\
    \ 2L, 20L, 21L])\n    [[0L, 1L], [2L, 3L]]\n    >>> consecutive_differences([0L,\
    \ 2L, 20L, 20L, 20L])\n    [[0L, 1L], [2L, 4L]]\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0q1jrdrq.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0q1jrdrq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ l.all!(e => e == l[0] || e == l[0] + 1 || e == l[0] - 1);\n}\nstatic assert(monotonic([4L,\
    \ 4L, 4L, 4L]));\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb89uuqhb.d(15): Error: no property `all` for type `long[]`

    /tmp/tmpb89uuqhb.d(17):        called from here: `monotonic([4L, 4L, 4L, 4L])`

    /tmp/tmpb89uuqhb.d(17):        while evaluating: `static assert(monotonic([4L,
    4L, 4L, 4L]))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb89uuqhb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    auto cmp = l[1] - l[0];\n    foreach (i, ref elem; l[1..$])\
    \ {\n        if (cmp * (elem - l[i]) < 0) return false;\n    }\n    return true;\n\
    }\n/*\nReturn true if array elements are increasing, false otherwise.\n    >>>\
    \ increasing([1L, 2L, 4L, 20L])\n    true\n    >>> increasing([1L, 20L, 4L, 10L])\n\
    \    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n     if(l.length\
    \ <= 2)\n        return true;\n    else\n    {\n        long d = l[1] - l[0];\n\
    \        foreach(i; 1..l.length-1)\n        {\n            if(l[i] - l[i-1] !=\
    \ d)\n                return false;\n        }\n        return true;\n    }\n\
    }\n/*\nis_reversed([1L, 2L, 4L, 20L]) === false\nis_reversed([1L, 20L, 4L, 10L])\
    \ === false\nis_reversed([4L, 1L, 0L, -10L]) === true\n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv5enhvf0.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x42833d]

    ??:? void tmpv5enhvf0.__unittest_L33_C1() [0x427e50]

    ??:? void tmpv5enhvf0.__modtest() [0x4280bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b252]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303e5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430894]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430371]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b229]

    ??:? runModuleUnitTests [0x42c195]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428800]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool inc\
    \ = 0;\n    bool dec = 0;\n    foreach(i, x; l)\n    {\n        if(i)\n      \
    \  {\n            if(x > l[i-1])\n            {\n                inc = 1;\n  \
    \          }\n            else if(x < l[i-1])\n            {\n               \
    \ dec = 1;\n            }\n        }\n    }\n    return inc || dec;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp70kpijcp.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x42833d]

    ??:? void tmp70kpijcp.__unittest_L33_C1() [0x427eef]

    ??:? void tmp70kpijcp.__modtest() [0x4280c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b252]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303e5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430894]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430371]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b229]

    ??:? runModuleUnitTests [0x42c195]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428800]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n  { \n  return\
    \ (l.max-l.min)>=0; \n  }\n//Status: Pass\nunittest\n{\n    alias candidate =\
    \ monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwy7w5g6.d(15): Error: no property `max` for type `long[]`

    /tmp/tmppwy7w5g6.d(15): Error: no property `min` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwy7w5g6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\
    \ {\n        if (l[i] < l[i - 1])\n            increasing = false;\n        if\
    \ (l[i] > l[i - 1])\n            decreasing = false;\n    }\n    return increasing\
    \ || decreasing;\n}\n// Check \"copy\" tag.\nstruct Pos(T)\n{\n    T x;\n    T\
    \ y;\n    this(T x, T y)\n    {\n        this.x = x;\n        this.y = y;\n  \
    \  }\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool incr\
    \ = true;\n\tif (l.length < 2) \n\t{\n\t\treturn incr;\n\t}\n\tforeach (immutable\
    \ index, item; l) \n\t{\n\t\tif (index > 0) \n\t\t{\n\t\t\tincr = l[index] > l[index\
    \ - 1];\n\t\t\tif (!incr) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif\
    \ (incr) \n\t{\n\t\treturn incr;\n\t}\n\tforeach (immutable index, item; l) \n\
    \t{\n\t\tif (index > 0) \n\t\t{\n\t\t\tincr = l[index] < l[index - 1];\n\t\t\t\
    if (!incr) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn incr;\n}\n\
    /*\nReturn true is the array contains the given value.\n    >>> contains([1L,\
    \ 2L, 4L, 20L], 4L)\n    true\n    >>> contains([1L, 20L, 4L, 10L], 3L)\n    false\n\
    */\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7wjrvq8w.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283dd]

    ??:? void tmp7wjrvq8w.__unittest_L55_C1() [0x428035]

    ??:? void tmp7wjrvq8w.__modtest() [0x428160]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c45f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430485]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430934]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430411]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2c9]

    ??:? runModuleUnitTests [0x42c235]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool status\
    \ = true;\n    for (int i = 1; i < l.length; i++)\n    {\n        if (l[i] > l[i\
    \ - 1])\n        {\n            status = true;\n        }\n        else if (l[i]\
    \ < l[i - 1])\n        {\n            status = true;\n        }\n        else\n\
    \        {\n            status = false;\n            break;\n        }\n    }\n\
    \    return status;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptcq9dzz9.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428345]

    ??:? void tmptcq9dzz9.__unittest_L34_C1() [0x427ef3]

    ??:? void tmptcq9dzz9.__modtest() [0x4280c4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b25a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43089c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430379]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]

    ??:? runModuleUnitTests [0x42c19d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428808]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length<2)\n\
    \        return true;\n    bool b=l[0]<l[1];\n    foreach(i;2..l.length)\n   \
    \     if (b!=(l[i-1]<l[i]))\n            return false;\n    return true;\n}\n\
    /*\nReturn the array of bins corresponding to the bins\nof the histogram argument.\n\
    \    >>> histogram_bins([3L, 5L, 7L, 8L])\n    [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5,\
    \ 5.5, 6.5, 7.5, 8.5, 9.5]\n    >>> histogram_bins([3L, 5L, 7L, 8L], True)\n \
    \   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> histogram_bins([3L, 5L, 7L, 8L],\
    \ False, 2)\n    [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5]\n  \
    \  >>> histogram_bins([3L, 5L, 7L, 8L], True, 2)\n    [0, 2, 4, 6, 8, 10]\n  \
    \  >>> histogram_bins([-3L, -5L, -7L, -8L], True, 2)\n    [-10, -8, -6, -4, -2,\
    \ 0]\n*/\nreal[] histogram_bins(long[] h, bool right=false, int width=1)\n{\n\
    \    assert(h.length>0);\n    if (right)\n        return array(iota(h[0]/width,\
    \ (h[$-1]+1)/width)).map!(x=>x*width);\n    else\n        return array(iota(h[0]/width-0.5,\
    \ (h[$-1]+1)/width-0.5)).map!(x=>x*width);\n}\n/*\nReturn the array of counts\
    \ corresponding to the bins\nof the hist\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb9i8vkj1.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9i8vkj1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    import\
    \ std.algorithm;\n    return minElement(l) == l[0] || maxElement(l) == l[$-1];\n\
    }\n/*\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpldoht9s6.d(18): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldoht9s6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\t\n\tauto\
    \ last = l[0];\n\tbool increasing = true;\n\t\n\tforeach(elem; l)\n\t{\n\t\tif(elem\
    \ < last)\n\t\t{\n\t\t\tincreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\tlast = elem;\n\
    \t}\n\t\n\tif(increasing)\n\t\treturn true;\n\t\t\n\tlast = l[0];\n\t\n\tforeach(elem;\
    \ l)\n\t{\n\t\tif(elem > last)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tlast =\
    \ elem;\n\t}\n\t\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0)\n    {\n        return true;\n    }\n    else\n    {\n        bool isincreasing\
    \ = l[0] < l[1];\n        auto prev = l[0];\n        foreach (cur; l[1..$])\n\
    \        {\n            if (cur > prev && !isincreasing)\n            {\n    \
    \            return false;\n            }\n            else if (cur < prev &&\
    \ isincreasing)\n            {\n                return false;\n            }\n\
    \            prev = cur;\n        }\n        return true;\n    }\n}\n/*\nReturn\
    \ true if elements are monotonically increasing or decreasing.\n    >>> monotonic_f([1.0,\
    \ 2.0, 4.0, 20.0])\n    true\n    >>> monotonic_f([1.0, 20.0, 4.0, 10.0])\n  \
    \  false\n    >>> monotonic_f([4.0, 1.0, 0.0, -10.0])\n    true\n    \n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    auto first = l[0];\n    if (first\
    \ < l[1]) \n    {\n        for (long i = 1; i < l.length; i++) \n        {\n \
    \           if (l[i] < l[i - 1]) \n            {\n                return false;\n\
    \            }\n        }\n    }\n    else \n    {\n        for (long i = 1; i\
    \ < l.length; i++) \n        {\n            if (l[i] > l[i - 1]) \n          \
    \  {\n                return false;\n            }\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin {\n    assert(l.length\
    \ > 0);\n}\nout(result) {\n    assert(result == false || result == true);\n}\n\
    {\n    long h = l[0];\n    bool positive = true;\n    for (long i = 1; i < l.length;\
    \ i++) {\n        if (l[i] < h) {\n            positive = false;\n        }\n\
    \        if (positive && l[i] < h) {\n            return false;\n        }\n \
    \       if (!positive && l[i] > h) {\n            return false;\n        }\n \
    \       h = l[i];\n    }\n    return true;\n}\n/*\nReturn a function that returns\
    \ True if given integer is in the list.\n    >>> isIn([1L, 2L, 4L, 20L])(4L)\n\
    \    true\n    >>> isIn([1L, 2L, 4L, 20L])(5L)\n    false\n    \n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp32l5rb5t.d(20): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp32l5rb5t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\treturn l.isSorted;\n\
    }\n/*\n  Return the number of elements in the array a that are greater than the\
    \ argument v.\n      >>> howManyGreaterThan(2L, [1L, 2L, 5L, 7L])\n      2\n \
    \     >>> howManyGreaterThan(0L, [])\n      0\n      >>> howManyGreaterThan(4L,\
    \ [4L, 4L, 4L, 4L])\n      0\n*/\nsize_t howManyGreaterThan(long v, long[] a)\
    \ \n{\n    return a.count!(x => x > v);\n}\n/*\n    Return the longest element\
    \ from an array of strings. If the array contains more than one such element,\
    \ return the first.\n        >>> longest(\"The\", \"quick\", \"brown\", \"fox\"\
    )\n        \"quick\"\n        >>> longest(\"The\", \"really quick\", \"brown\"\
    , \"fox\")\n        \"really quick\"\n        >>> longest(\"The\", \"quick\",\
    \ \"brown\", \"fox\", \"jumps\")\n        \"quick\"\n*/\nstring longest(string[]\
    \ a) \n{\n    return a.length ? a.max!(x => x.length) : null;\n}\n/*\n    Return\
    \ the number of vowels in a string.\n        >>> numVowels(\"The quick brown fox\"\
    )\n        5\n        >>> numVowels(\"The quick brown fox jummped over the lazy\
    \ dog\")\n        11\n        >>> numVowels(\"\")\n        0\n*/\nsize_t numVowels(string\
    \ s) \n{\n    return s.length ? s.filter!(x => \"aeiouAEIOU\".canFind(x)).length\
    \ : 0;\n}\n/*\n    Return true if the input string is a palindrome, and false\
    \ otherwise.\n        >>> isPalindrome(\"racecar\")\n        true\n        >>>\
    \ isPalindrome(\"balloon\")\n        false\n        >>> isPalindrome(\"\")\n \
    \       true\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp23vvthuq.d(15): Error: no property `isSorted` for type `long[]`

    /tmp/tmp23vvthuq.d(28): Error: no property `count` for type `long[]`

    /tmp/tmp23vvthuq.d(41): Error: no property `max` for type `string[]`

    /tmp/tmp23vvthuq.d(54): Error: no property `filter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23vvthuq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool result;\n\
    \    auto n = l.length;\n    if (n < 2) \n    {\n        result = true;\n    }\
    \ \n    else \n    {\n        if (l[0] < l[1]) \n        {\n            bool increasing\
    \ = true;\n            for (size_t i = 1; i < n - 1; i++) \n            {\n  \
    \              if (l[i] > l[i + 1]) \n                {\n                    increasing\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         result = increasing;\n        } \n        else \n        {\n       \
    \     bool decreasing = true;\n            for (size_t i = 1; i < n - 1; i++)\
    \ \n            {\n                if (l[i] < l[i + 1]) \n                {\n\
    \                    decreasing = false;\n                    break;\n       \
    \         }\n            }\n            result = decreasing;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  if (l.length\
    \ == 0) \n  {\n    return true;\n  }\n  const long threshold = 5;\n  int long_i_last\
    \ = l[0];\n  long long_delta_sum = 0;\n  foreach (i, long_i; l) \n  {\n    const\
    \ long long_delta = long_i - long_i_last;\n    long_delta_sum += long_delta;\n\
    \    if (long_delta_sum > threshold) \n    {\n      return false;\n    }\n   \
    \ long_i_last = long_i;\n  }\n  return true;\n}\n/*\nConvert an array of uniform\
    \ samples to an array of quantiles.\n    >>> uniform_to_quantile([0L, 0L, 1L,\
    \ 1L, 1L, 1L, 2L, 3L])\n    [0L, 0L, 0L, 0L, 0L, 0L, 1L, 1L]\n    \n*/\nlong[]\
    \ uniform_to_quantile(long[] u) \n{\n  const long n = u.length;\n  long[] q =\
    \ new long[n];\n  long long_quantile = 0;\n  long long_uniform = u[0];\n  long\
    \ long_repetitions = 0;\n  foreach (long_i; u) \n  {\n    if (long_i != long_uniform)\
    \ \n    {\n      for (long j = 0; j < long_repetitions; j++) \n      {\n     \
    \   q[j] = long_quantile;\n      }\n      long_quantile++;\n      long_uniform\
    \ = long_i;\n      long_repetitions = 0;\n    }\n    long_repetitions++;\n  }\n\
    \  for (long j = 0; j < long_repetitions; j++) \n  {\n    q[j] = long_quantile;\n\
    \  }\n  return q;\n}\n/*\nunittest\n{\n    alias candidate = monotonic;\n\n  \
    \  assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8hymeaom.d(67): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8hymeaom.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ < 2)\n        return true;\n    switch(sign(l[1] - l[0])) \n    {\n        case\
    \ 1: \n            foreach(n; l[1..$])\n                if(n < l[$-1])\n     \
    \               return false;\n            break;\n        case -1: \n       \
    \     foreach(n; l[1..$])\n                if(n > l[$-1])\n                  \
    \  return false;\n            break;\n        default: \n            foreach(n;\
    \ l[1..$])\n                if(n != l[$-1])\n                    return false;\n\
    \            break;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6vq1ooof.d(17): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ !uniq(sort(l)).empty;\n}\n/*\nReturn a sequence of corresponding values from\
    \ two input sequences.\n    >>> correspondence([1L, 1L, 2L, 2L, 3L, 3L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L])\n    [1L, 2L, 3L]\n    >>> correspondence([10L, 9L, 8L,\
    \ 7L, 6L, 5L], [10L, 10L, 10L, 7L, 7L, 5L])\n    [10L, 10L, 10L, 7L, 7L, 5L]\n\
    \    >>> correspondence([1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 2L, 2L, 3L, 3L])\n\
    \    [1L, 1L, 2L, 2L, 3L, 3L]\n*/\nlong[] correspondence(long[] x, long[] y) \n\
    {\n    size_t[] idx = sort(zip(y, iota(y.length)), true).map!(t => t[1]).array;\n\
    \    return x[idx];\n}\n/*\nReturn list of indices of values in list that are\
    \ below or equal to threshold.\n    >>> threshold_idx([1L, 2L, 3L, 4L, 5L], 3L)\n\
    \    [0L, 1L, 2L]\n    >>> threshold_idx([1L, 4L, 3L, 4L, 5L], 3L)\n    [0L, 2L]\n\
    \    >>> threshold_idx([5L, 4L, 3L, 2L, 1L], 3L)\n    [4L, 3L, 2L]\n*/\nsize_t[]\
    \ threshold_idx(long[] l, long threshold) \n{\n    return iota(l.length).filter!(i\
    \ => l[i] <= threshold).array;\n}\n/*\nReturn the sum of elements in a sequence.\n\
    \    >>> sum_seq([1L, 2L, 3L, 4L, 5L])\n    15L\n    >>> sum_seq([1L, 1L, 1L,\
    \ 1L, 1L])\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvelat4x.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvelat4x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing;\n\
    \    bool decreasing;\n    if (l.length > 1) {\n        increasing = decreasing\
    \ = true;\n        for (int i = 1; i < l.length; i++) {\n            if (l[i -\
    \ 1] > l[i]) {\n                increasing = false;\n            }\n         \
    \   if (l[i - 1] < l[i]) {\n                decreasing = false;\n            }\n\
    \        }\n        return increasing || decreasing;\n    }\n    return true;\n\
    }\n/*\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpytdms7r8.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpytdms7r8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool result\
    \ = true;\n\tfor (long i = 0; i < l.length - 1; i++)\n\t{\n\t\tif (l[i] > l[i\
    \ + 1])\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdlhf633i.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282e5]

    ??:? void tmpdlhf633i.__unittest_L26_C1() [0x427ee1]

    ??:? void tmpdlhf633i.__modtest() [0x428064]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c367]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43038d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43083c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430319]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d1]

    ??:? runModuleUnitTests [0x42c13d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    static\
    \ assert(l.length >= 2);\n    long[] _l = l.dup;\n    _l.sort;\n    if (_l[0]\
    \ == _l[$-1]) \n    {\n        return true;\n    }\n    else \n    {\n       \
    \ return l == _l || l == _l[0..$].reverse;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3u7y395j.d(15): Error: variable `l` cannot be read at compile time

    /tmp/tmp3u7y395j.d(15):        while evaluating: `static assert(l.length >= 2LU)`

    /tmp/tmp3u7y395j.d(17): Error: no property `sort` for type `long[]`

    /tmp/tmp3u7y395j.d(24): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3u7y395j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    foreach (i, n; 2 .. l.length)\n    {\n        if (l[i] < l[i -\
    \ 1])\n        {\n            increasing = false;\n            break;\n      \
    \  }\n    }\n    if (increasing)\n    {\n        return true;\n    }\n    // not\
    \ increasing\n    bool decreasing = true;\n    foreach (i, n; 2 .. l.length)\n\
    \    {\n        if (l[i] > l[i - 1])\n        {\n            decreasing = false;\n\
    \            break;\n        }\n    }\n    return decreasing;\n}\n/*\nReturn the\
    \ index of the first element of the array in which the elements are monotonically\
    \ increasing.\n    >>> monotonic_increase_index([1L, 2L, 4L, 20L])\n    0\n  \
    \  >>> monotonic_increase_index([1L, 20L, 4L, 10L])\n    2\n    >>> monotonic_increase_index([4L,\
    \ 1L, 0L, -10L])\n    3\n*/\nlong monotonic_increase_index(long[] l) \n{\n   \
    \ foreach (i, n; 1 .. l.length)\n    {\n        if (l[i] < l[i - 1])\n       \
    \ {\n            return i;\n        }\n    }\n    return l.length;\n}\n/*\nReturn\
    \ the index of the first element of the array in which the elements are monotonically\
    \ decreasing.\n    >>> monotonic_decrease_index([1L, 2L, 4L, 20L])\n    3\n  \
    \  >>> monotonic_decrease_index([1L, 20L, 4L, 10L])\n    1\n    >>> monotonic_decrease_index([4L,\
    \ 1L, 0L, -10L])\n    0\n*/\nlong monotonic_decrease_index(long[] l) \n{\n   \
    \ foreach (i, n; 1 .. l.length)\n    {\n        if (l[i] > l[i - 1])\n       \
    \ {\n            return i;\n        }\n    }\n    return l.length\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzjlqwp9n.d(16): Error: found `..` when expecting `)`

    /tmp/tmpzjlqwp9n.d(16): Error: found `)` when expecting `;` following statement

    /tmp/tmpzjlqwp9n.d(30): Error: found `..` when expecting `)`

    /tmp/tmpzjlqwp9n.d(30): Error: found `)` when expecting `;` following statement

    /tmp/tmpzjlqwp9n.d(51): Error: found `..` when expecting `)`

    /tmp/tmpzjlqwp9n.d(51): Error: found `)` when expecting `;` following statement

    /tmp/tmpzjlqwp9n.d(71): Error: found `..` when expecting `)`

    /tmp/tmpzjlqwp9n.d(71): Error: found `)` when expecting `;` following statement

    /tmp/tmpzjlqwp9n.d(79): Error: found `unittest` when expecting `;` following `return`
    statement

    /tmp/tmpzjlqwp9n.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjlqwp9n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ < 2) return true;\n    long prev = l[0];\n    long change = 0;\n    for(int\
    \ i = 1; i < l.length; i++) {\n        if(change == 0) {\n            if(l[i]\
    \ > prev)\n                change = 1;\n            else if(l[i] < prev)\n   \
    \             change = -1;\n        } else if(l[i] > prev && change < 0)\n   \
    \         return false;\n        else if(l[i] < prev && change > 0)\n        \
    \    return false;\n        prev = l[i];\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long n;\n\
    \    n = l.length;\n    if (n < 2) \n    {\n        return true;\n    }\n    if\
    \ (l[0] < l[1]) \n    {\n        for (size_t i = 1; i < n - 1; i++) \n       \
    \ {\n            if (l[i] > l[i + 1]) \n            {\n                return\
    \ false;\n            }\n        }\n    }\n    else \n    {\n        for (size_t\
    \ i = 1; i < n - 1; i++) \n        {\n            if (l[i] < l[i + 1]) \n    \
    \        {\n                return false;\n            }\n        }\n    }\n \
    \   return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int delta\
    \ = 0;\n    foreach (long x; l) {\n        if (delta == 0) {\n            delta\
    \ = (x - l[$ - 1]);\n        } else {\n            if (signbit(delta) != signbit(x\
    \ - l[$ - 1])) {\n                return false;\n            }\n        }\n  \
    \  }\n    return true;\n}\n//Return true if array elements are monotonically increasing.\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp15cikq5i.d(18): Error: cannot implicitly convert expression `x
    - l[__dollar - 1LU]` of type `long` to `int`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271):
    Error: no property `epsilon` for type `int`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272):
    Error: no property `mant_dig` for type `int`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292):
    Error: no property `mant_dig` for type `int`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335):
    Error: no property `mant_dig` for type `int`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrl'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool mono\
    \ = true;\n\tbool mono_increasing = true;\n\tbool mono_decreasing = true;\n\t\
    l = l.sort();\n\tfor (size_t i = 0, j = i + 1; i < l.length; i++, j++)\n\t{\n\t\
    \tif (l[i] > l[j])\n\t\t{\n\t\t\tmono_increasing = false;\n\t\t}\n\t\tif (l[i]\
    \ < l[j])\n\t\t{\n\t\t\tmono_decreasing = false;\n\t\t}\n\t}\n\treturn mono =\
    \ mono_increasing || mono_decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfid_pboo.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfid_pboo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n    @safe pure\
    \ nothrow \n{\n    enum op = (l[1] > l[0]) ? 1 : -1;\n    size_t i = 1;\n    foreach\
    \ (int j; l[1..$]) \n    {\n        if (op * (l[j] - l[j - 1]) < 0) \n       \
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n \n/*\n\
    Return the bin of the given value.\n   >>> bin(10L, [0L, 10L, 20L])\n   0\n  \
    \ >>> bin(18L, [0L, 10L, 20L])\n   1\n   >>> bin(20L, [0L, 10L, 20L])\n   2\n\
    */\nsize_t bin(long value, in long[] values) \n    @safe pure nothrow \n{\n  \
    \  import std.algorithm : binarySearch;\n    if (binarySearch(values, value) >=\
    \ 0)\n    {\n        return binarySearch(values, value);\n    }\n    return binarySearch(values,\
    \ value).anyPos;\n}\n \n/*\nReturns an array that contains the sequence: start,\
    \ start + step, ...\n   >>> arange(1L, 10L, 1L)\n   [1L, 2L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L]\n   >>> arange(2L, 10L, 2L)\n   [2L, 4L, 6L, 8L]\n   >>> arange(1L,\
    \ 10L, 3L)\n   [1L, 4L, 7L]\n*/\nlong[] arange(long start, long stop, long step)\
    \ \n    @safe pure nothrow \n{\n    long[] l;\n    l ~= start;\n    if (step ==\
    \ 0)\n    {\n        return l;\n    }\n    for (; start < stop; start += step)\n\
    \    {\n        l ~= start;\n    }\n    return l;\n}\n \n/*\nReturns a range that\
    \ contains the sequence: start, start + step, ...\n   >>> rarange(1L, 10L, 1\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpobj528w1.d(73): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobj528w1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tassert(l.length\
    \ > 1);\n\tbool increasing = l[0] < l[1];\n\tfor (long i = 1; i < l.length; i++)\n\
    \t{\n\t\tif (increasing)\n\t\t{\n\t\t\tif (l[i] < l[i - 1])\n\t\t\t{\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (l[i] > l[i - 1])\n\t\
    \t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ all(l[i] &lt;= l[i+1] for i in 0..l.length-2) || all(l[i] &gt;= l[i+1] for i\
    \ in 0..l.length-2);\n}\n/*\nGenerate polygon points by finding the intersections\
    \ of a circle and the\nline L = [x1, y1, x2, y2] (endpoints)\n*/\nTuple!(long[],\
    \ long[]) polygon_points(long x1, long y1, long x2, long y2, long r) \n{\n   \
    \ enum delta_x = abs(x2 - x1);\n    enum delta_y = abs(y2 - y1);\n    enum delta_x2\
    \ = delta_x * delta_x;\n    enum delta_y2 = delta_y * delta_y;\n    enum delta_r2\
    \ = r * r;\n    auto a = delta_y2 + delta_x2;\n    auto b = -2 * x1 * delta_y2\
    \ - 2 * y1 * delta_x2;\n    auto c = delta_y2 * x1 * x1 + delta_x2 * y1 * y1 -\
    \ delta_r2 * delta_y2;\n    double xm = (-b + sqrt(b * b - 4 * a * c)) / (2 *\
    \ a);\n    double xn = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);\n    double ym\
    \ = (delta_r2 - delta_x2 * xm) / delta_y2;\n    double yn = (delta_r2 - delta_x2\
    \ * xn) / delta_y2;\n    return tuple(long[](xm, ym), long[](xn, yn));\n}\n/*\n\
    Given x axis endpoints P = [x1, y1, x2, y2] (endpoints) and a set of points\n\
    representing the polygon S = [x1, y1, x2, y2, x3, y3, x4, y4]\n(clockwise), determine\
    \ the polygon intersection area.\n    >>> polygon_area(\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1nv4a8a0.d(15): Error: found `;` when expecting `,`

    /tmp/tmp1nv4a8a0.d(15): Error: expression expected, not `=`

    /tmp/tmp1nv4a8a0.d(15): Error: found `l` when expecting `,`

    /tmp/tmp1nv4a8a0.d(15): Error: found `for` when expecting `,`

    /tmp/tmp1nv4a8a0.d(15): Error: found `..` when expecting `,`

    /tmp/tmp1nv4a8a0.d(15): Error: found `;` when expecting `,`

    /tmp/tmp1nv4a8a0.d(15): Error: expression expected, not `=`

    /tmp/tmp1nv4a8a0.d(15): Error: found `l` when expecting `,`

    /tmp/tmp1nv4a8a0.d(15): Error: found `for` when expecting `,`

    /tmp/tmp1nv4a8a0.d(15): Error: found `..` when expecting `,`

    /tmp/tmp1nv4a8a0.d(35): Error: found `[` when expecting `.` following long

    /tmp/tmp1nv4a8a0.d(35): Error: found `]` when expecting identifier following `long`.

    /tmp/tmp1nv4a8a0.d(35): Error: found `[` when expecting `.` following long

    /tmp/tmp1nv4a8a0.d(35): Error: found `]` when expecting identifier following `long`.

    /tmp/tmp1nv4a8a0.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-"'
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint i =\
    \ 0;\n\tint j = 0;\n\tbool flag = false;\n\tif (l.length == 1) { return true;\
    \ }\n\tfor (int i = 0; i < l.length - 1; i++) {\n\t\tif (l[i] == l[i + 1]) { continue;\
    \ }\n\t\telse if (l[i] < l[i + 1]) {\n\t\t\tif (flag == false) { flag = true;\
    \ }\n\t\t\telse if (flag == true) { continue; }\n\t\t}\n\t\telse if (l[i] > l[i\
    \ + 1]) {\n\t\t\tif (flag == false) { flag = false; }\n\t\t\telse if (flag ==\
    \ true) { return false; }\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw9ah4yp1.d(19): Error: variable `i` is shadowing variable `tmpw9ah4yp1.monotonic.i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw9ah4yp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    enum bool\
    \ isIncreasing = l[0] < l[1];\n    foreach (index, element; l)\n    {\n      \
    \  if (isIncreasing)\n        {\n            if (element < l[index - 1])\n   \
    \         {\n                return false;\n            }\n        }\n       \
    \ else\n        {\n            if (element > l[index - 1])\n            {\n  \
    \              return false;\n            }\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp89l6fys.d(15): Error: variable `l` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp89l6fys.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    foreach\
    \ (e; l[1 .. $])\n    {\n        if (e < l[0]) \n        {\n            return\
    \ false;\n        }\n        l[0] = e;\n    }\n    return true;\n}\n/*\n    Return\
    \ true if the given sequence is monotonic,\n    that is, if it is strictly increasing\
    \ or decreasing.\n    Return false otherwise.\n    >>> monotonic([1L, 2L, 3L,\
    \ 4L])\n    true\n    >>> monotonic([2L, 2L, 4L, 10L])\n    true\n    >>> monotonic([4L,\
    \ 4L, 4L, 4L])\n    true\n    >>> monotonic([1L, 2L, -3L, -4L])\n    true\n  \
    \  >>> monotonic([4L, 1L, 10L, 0L])\n    false\n    >>> monotonic([4L, 3L, 2L,\
    \ 1L])\n    true\n    >>> monotonic([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L,\
    \ 11L, 12L, 13L, 14L, 15L, 16L, 17L, 18L, 19L, 20L, 21L, 22L, 23L, 24L, 25L, 26L,\
    \ 27L, 28L, 29L, 30L, 31L, 32L, 33L, 34L, 35L, 36L, 37L, 38L, 39L, 40L, 41L, 42L,\
    \ 43L, 44L, 45L, 46L, 47L, 48L, 49L, 50L, 51L, 52L, 53L, 54L, 55L, 56L, 57L, 58L,\
    \ 59L, 60L, 61L, 62L, 63L, 64L, 65L, 66L, 67L, 68L, 69L, 70L, 71L, 72L, 73L, 74L,\
    \ 75L, 76L, 77L, 78L, 79L, 80L, 81L, 82L, 83L, 84L, 85L, 86L, 87L, 88L, 89L, 90L,\
    \ 91L, 92L, 93L\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe3gu9hk2.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3gu9hk2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n        return true;\n    auto first = l[0];\n    auto inc = 0;\n    foreach\
    \ (i, el; l) \n    {\n        if (inc == 0) \n        {\n            inc = el\
    \ - first;\n            first = el;\n        }\n        else if (inc > 0) \n \
    \       {\n            if (el - first != inc)\n                return false;\n\
    \            first = el;\n        }\n        else if (inc < 0) \n        {\n \
    \           if (el - first != inc)\n                return false;\n          \
    \  first = el;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4k2ccy77.d(23): Error: cannot implicitly convert expression `el
    - first` of type `long` to `int`

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  /*\n  from\
    \ std.algorithm:\n    foldLeft(alias binaryFunctor = \"a.opBinary(\\\"+\\\")\"\
    , Range)(Range r, in T initial)\n    If Range is an input range, foldLeft will\
    \ iterate through the input range\n    r by repeatedly calling popFront. For each\
    \ iteration, the result value is\n    updated by calling binaryFunctor on the\
    \ result value and the next value\n    from the input range.\n  */\n  return [l[i]>l[i+1]?-1L:1L].foldLeft!(\"\
    a*b\")([0L]).array == [-1L,-1L];\n  // this is just a test. for the real function\
    \ use:\n  //std.algorithm.isSorted(l, std.sort.increasing);\n}\n/*\nFind the index\
    \ of the first element for which predicate is true.\n    >>> searchFirst([0L,\
    \ 1L, 2L, 2L, 2L, 3L, 4L, 5L], (a) => a == 2L)\n    2\n*/\nsize_t searchFirst(long[]\
    \ l, alias pred)\n{\n  return l.find!pred;\n}\n/*\nFind the index of the last\
    \ element for which predicate is true.\n    >>> searchLast([0L, 1L, 2L, 2L, 2L,\
    \ 3L, 4L, 5L], (a) => a == 2L)\n    4\n*/\nsize_t searchLast(long[] l, alias pred)\n\
    {\n  return l.rfind!pred;\n}\n/*\nFind the first element in the input range that\
    \ has a value greater than or\nequal to the specified value.\n    >>> searchLe([0L,\
    \ 1L, 2L, 2L, 2L, 3L, 4L, 5L], 2L)\n    2\n*/\nsize_t searchLe(long[] l, long\
    \ a)\n{\n  return searchFirst(l, (x)=>a>=x);\n}\n/*\nFind the first element in\
    \ the input range that has a value greater than the\nspecified value.\n    >>>\
    \ searchLt([0L, 1L, 2L, 2L, 2L, 3L, 4L, 5L], 2\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_k6pt6cc.d(32): Error: basic type expected, not `alias`

    /tmp/tmp_k6pt6cc.d(32): Error: found `alias` when expecting `)`

    /tmp/tmp_k6pt6cc.d(32): Error: semicolon expected following function declaration

    /tmp/tmp_k6pt6cc.d(32): Error: no identifier for declarator `pred`

    /tmp/tmp_k6pt6cc.d(32): Error: declaration expected, not `)`

    /tmp/tmp_k6pt6cc.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_k6pt6cc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0) return true;\n    long first = l[0];\n    bool pos = false;\n    foreach\
    \ (i, e; l) {\n        if (i != 0) {\n            if (e > first) pos = true;\n\
    \            else if (e < first) pos = false;\n            else return false;\n\
    \        }\n        if (i != 0 && ((pos && e < l[i - 1]) || (!pos && e > l[i -\
    \ 1]))) return false;\n    }\n    return true;\n}\n \nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcys1dzmo.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x42839d]

    ??:? void tmpcys1dzmo.__unittest_L29_C1() [0x428102]

    ??:? void tmpcys1dzmo.__modtest() [0x42811c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c41f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2b2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430445]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303d1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]

    ??:? runModuleUnitTests [0x42c1f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428860]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    long a = l[0];\n    long b = l[1];\n    if (a == b) return\
    \ monotonic(l[1..$]);\n    return l.reduce!((c, d) => (c == d) || (c < d) == (a\
    \ < b) ? d : c) == l[$ - 1];\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt2fq9j3g.d(19): Error: no property `reduce` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt2fq9j3g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool up\
    \ = false;\n    bool down = false;\n    for (auto i = 1; i < l.length; i++) \n\
    \    {\n        if (l[i] > l[i - 1]) \n        {\n            up = true;\n   \
    \     }\n        else if (l[i] < l[i - 1]) \n        {\n            down = true;\n\
    \        }\n        if (up && down) \n        {\n            return false;\n \
    \       }\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate =\
    \ monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm7t07y9j.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm7t07y9j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\treturn \
    \ monoCheck(0L, l[0L], 0L, l.length);\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp__xps83r.d(15): Error: undefined identifier `monoCheck`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp__xps83r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long last\
    \ = l[0];\n    bool increasing = true;\n    foreach(i, current; l) {\n       \
    \ if (last > current) {\n            increasing = false;\n            break;\n\
    \        }\n        last = current;\n    }\n    if (increasing) return true;\n\
    \    last = l[0];\n    foreach(i, current; l) {\n        if (last < current) return\
    \ false;\n        last = current;\n    }\n    return true;\n}\n// Ditto, but returns\
    \ a tuple\nTuple!(bool, bool) monotonic2(long[] l) {\n    long last = l[0];\n\
    \    bool increasing = true;\n    bool decreasing = true;\n    foreach(i, current;\
    \ l) {\n        if (last > current) increasing = false;\n        if (last < current)\
    \ decreasing = false;\n        last = current;\n    }\n    return tuple(increasing,\
    \ decreasing);\n}\n/*\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplcci335s.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplcci335s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \npure nothrow\
    \ @nogc\n{\n    enum prev = l[0];\n    foreach(current; l[1 .. $]) \n    {\n \
    \       if(current < prev) \n        {\n            return false;\n        }\n\
    \        prev = current;\n    }\n    return true;\n}\n/*\nReturn true is array\
    \ elements are monotonically increasing or decreasing.\n    >>> monotonic([1,\
    \ 2, 4, 20])\n    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    >>>\
    \ monotonic([4, 1, 0, -10])\n    true\n    \n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpasld1a38.d(16): Error: variable `l` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasld1a38.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto is_monotonic\
    \ = true;\n    for (size_t i = 0, j = i + 1; i < l.length - 1; i++, j = i + 1)\
    \ \n    {\n        if (l[i] > l[j]) \n        {\n            is_monotonic = false;\n\
    \            break;\n        }\n    }\n    return is_monotonic;\n}\n/*\nReturn\
    \ n-th prime number.\n    >>> nth_prime(0)\n    2\n    >>> nth_prime(1)\n    3\n\
    \    >>> nth_prime(5)\n    11\n    >>> nth_prime(10)\n    29\n*/\nlong nth_prime(long\
    \ n) \n{\n    long prime = 0L;\n    long count = 0L;\n    long num = 2L;\n   \
    \ while (true) \n    {\n        if (is_prime(num)) \n        {\n            count\
    \ += 1L;\n            if (count > n) \n            {\n                break;\n\
    \            }\n            prime = num;\n        }\n        num += 1L;\n    }\n\
    \    return prime;\n}\n/*\nReturns the sum of the digits of a number.\n    >>>\
    \ digits_sum(123)\n    6\n    >>> digits_sum(100100)\n    2\n    >>> digits_sum(12348963)\n\
    \    45\n*/\nlong digits_sum(long n) \n{\n    return sum(digits(n));\n}\n/*\n\
    Return true if a number is a prime number.\n    >>> is_prime(2)\n    true\n  \
    \  >>> is_prime(1)\n    false\n    >>> is_prime(0)\n    false\n    >>> is_prime(15485863)\n\
    \    true\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptieq5_hb.d(44): Error: undefined identifier `is_prime`

    /tmp/tmptieq5_hb.d(68): Error: undefined identifier `sum`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptieq5_hb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n    pure nothrow\n\
    {\n    bool state = true;\n    enum dir = 1;\n    foreach(i, e; l) {\n       \
    \ if (i == 0) {\n            continue;\n        }\n        if (e > l[i - 1]) {\n\
    \            if (dir == -1) {\n                state = false;\n              \
    \  break;\n            }\n            else {\n                dir = 1;\n     \
    \       }\n        }\n        else if (e < l[i - 1]) {\n            if (dir ==\
    \ 1) {\n                state = false;\n                break;\n            }\n\
    \            else {\n                dir = -1;\n            }\n        }\n   \
    \ }\n    return state;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n \
    \   assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7b0f4q6o.d(28): Error: cannot modify constant `dir`

    /tmp/tmp7b0f4q6o.d(37): Error: cannot modify constant `dir`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7b0f4q6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool inc\
    \ = true;\n    bool dec = true;\n    for (size_t i = 1; i < l.length; i++) {\n\
    \        inc &= l[i] >= l[i - 1];\n        dec &= l[i] <= l[i - 1];\n    }\n \
    \   return inc || dec;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n \
    \   assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ l.canFind(i => l[i] > l[i+1]) == l.canFind(i => l[i] < l[i+1]);\n}\n/*\nScales\
    \ the values of the array elements so that they add up to 1.\n    >>> normalize([0.1,\
    \ 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n    [0.1, 0.1, 0.1, 0.1, 0.1,\
    \ 0.1, 0.1, 0.1, 0.1, 0.1]\n    >>> normalize([-1.0, 1.0, 0.0])\n    [0.0, 1.0,\
    \ 0.0]\n*/\ndouble[] normalize(double[] a)\n{\n    return a.map!((double f) =>\
    \ f / a.sum)();\n}\n/*\nFor every element in x, return its distance to the closest\
    \ element in y.\n    >>> x = dmd.range(0L, 10L)\n    >>> y = dmd.range(2L, 5L)\n\
    \    >>> closest(x, y)\n    [2, 1, 0, 0, 0, 1, 2, 3, 4, 4]\n    >>> closest(y,\
    \ x)\n    [2, 2, 1, 0, 0]\n*/\nlong[] closest(long[] x, long[] y)\n{\n    auto\
    \ z = new long[x.length];\n    for (long i = 0; i < x.length; i++) {\n       \
    \ z[i] = (i, i => abs(x[i] - y[i])).min().item1;\n    }\n    return z;\n}\n/*\n\
    Compute the sum of squares of a given array.\n    >>> squared(1..5)\n    55\n\
    */\nlong squared(long[] l) \n{\n    return l.sum!((long n) => n * n)();\n}\n/*\n\
    Returns the consecutive numbers of the largest segment in which all the \nvalues\
    \ are identical.\n    >>> largestSegment([\"a\", \"a\", \"b\", \"c\", \"b\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3uvgy4vk.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3uvgy4vk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ ar = l;\n    long[] ar2 = l;\n    for (int i = 0; i < ar.length; i++)\n    {\n\
    \        if (ar[i] > ar[i+1])\n        {\n            long t = ar[i];\n      \
    \      ar[i] = ar[i+1];\n            ar[i+1] = t;\n        }\n    }\n    for (int\
    \ j = 0; j < ar2.length; j++)\n    {\n        if (ar2[j] < ar2[j+1])\n       \
    \ {\n            long t = ar2[j];\n            ar2[j] = ar2[j+1];\n          \
    \  ar2[j+1] = t;\n        }\n    }\n    if (ar.equals(l) || ar2.equals(l))\n \
    \   {\n        return true;\n    }\n    else\n    {\n        return false;\n \
    \   }\n}\n \n/*\nReturn a list of indices where the array breaks monotonicity\n\
    \    >>> monotonic_breaks([1L, 2L, 4L, 20L])\n    []\n    >>> monotonic_breaks([1L,\
    \ 20L, 4L, 10L])\n    [1]\n    >>> monotonic_breaks([4L, 1L, 0L, -10L])\n    [1]\n\
    \    >>> monotonic_breaks([1L, 2L, 20L, 4L, 10L])\n    [2]\n*/\nlong[] monotonic_breaks(long[]\
    \ l) \n{\n    long[] ar = l;\n    long[] ar2 = l;\n    for (int i = 0; i < ar.length;\
    \ i++)\n    {\n        if (ar[i] > ar[i+1])\n        {\n            long t = ar[i];\n\
    \            ar[i] = ar[i+1];\n            ar[i+1] = t;\n        }\n    }\n  \
    \  for (int j = 0; j < ar2.length; j++)\n    {\n        if (ar2[j] < ar2[j+1])\n\
    \        {\n            long t = ar2[j\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp10zjr4zx.d(74): Error: found `unittest` when expecting `,`

    /tmp/tmp10zjr4zx.d(87): Error: found `void` when expecting `,`

    /tmp/tmp10zjr4zx.d(87): Error: found `{` when expecting `,`

    /tmp/tmp10zjr4zx.d(87): Error: expression expected, not `}`

    /tmp/tmp10zjr4zx.d(87): Error: found `End of File` when expecting `,`

    /tmp/tmp10zjr4zx.d(87): Error: found `End of File` when expecting `]`

    /tmp/tmp10zjr4zx.d(87): Error: semicolon expected, not `End of File`

    /tmp/tmp10zjr4zx.d(87): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp10zjr4zx.d(87): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp10zjr4zx.d(87): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp10zjr4zx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    assert(l.length\
    \ > 0);\n    bool increasing = true;\n    foreach(i, e; l) \n    {\n        if\
    \ (e < l[0]) \n        {\n            increasing = false;\n            break;\n\
    \        }\n    }\n    if (increasing) \n    {\n        return true;\n    }\n\
    \    else \n    {\n        foreach(i, e; l) \n        {\n            if (e > l[0])\
    \ \n            {\n                return false;\n            }\n        }\n \
    \       return true;\n    }\n}\n/*\nReturn true if array elements are equal\n\
    \    >>> equal([1L, 1L, 1L, 1L])\n    true\n    >>> equal([1L, 1L, 2L, 1L])\n\
    \    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp216vkghq.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x428449]

    ??:? void tmp216vkghq.__unittest_L48_C1() [0x427f47]

    ??:? void tmp216vkghq.__modtest() [0x428118]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4cb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b35e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43047d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b335]

    ??:? runModuleUnitTests [0x42c2a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42890c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \nin \n{\n    if(l.length<=1)\
    \ return true;\n    else return l[0] < l[1] ? isSorted!(\">=\")(l) : isSorted!(\"\
    <=\")(l);\n}\n/*\n    Provide a recursive way to calculate fibonacci\n    >>>\
    \ fibonacci(10)\n    55\n    >>> fibonacci(0)\n    0\n    >>> fibonacci(1)\n \
    \   1\n    >>> fibonacci(2)\n    1\n*/\nlong fibonacci(long n) \nin\n{\n    if(n==0)\
    \ return 0;\n    else if(n==1) return 1;\n    else return fibonacci(n-1) + fibonacci(n-2);\n\
    }\n/*\n    Provide a recursive way to calculate factorial\n    >>> factorial(10)\n\
    \    3628800\n    >>> factorial(0)\n    1\n    >>> factorial(1)\n    1\n    >>>\
    \ factorial(2)\n    2\n*/\nlong factorial(long n) \nin\n{\n    if(n<=1) return\
    \ 1;\n    else return n * factorial(n-1);\n}\n/*\n    Check if a number is prime\
    \ or not\n    >>> is_prime(5)\n    true\n    >>> is_prime(6)\n    false\n    >>>\
    \ is_prime(1)\n    false\n    >>> is_prime(2)\n    true\n*/\nunittest\n{\n   \
    \ alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjaxfz3_3.d(13): Error: function `tmpjaxfz3_3.monotonic` `in` and
    `out` contracts can only appear without a body when they are virtual interface
    functions or abstract

    /tmp/tmpjaxfz3_3.d(30): Error: function `tmpjaxfz3_3.fibonacci` `in` and `out`
    contracts can only appear without a body when they are virtual interface functions
    or abstract

    /tmp/tmpjaxfz3_3.d(48): Error: function `tmpjaxfz3_3.factorial` `in` and `out`
    contracts can only appear without a body when they are virtual interface functions
    or abstract

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjaxfz3_3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n     bool\
    \ m=true;\n     bool increase=true;\n     \n     if(l.length>1)\n     {\n    \
    \    for(int i=0;i<l.length-1;i++)\n        {\n            if(l[i]<l[i+1])\n \
    \           {\n                increase=true;\n            }\n            else\
    \ if(l[i]>l[i+1])\n            {\n                increase=false;\n          \
    \  }\n            else\n            {\n                m=false;\n            \
    \    break;\n            }\n            \n            if(i==0)\n            {\n\
    \                m=true;\n            }\n            else\n            {\n   \
    \             if(increase!=increase[i-1])\n                {\n               \
    \     m=false;\n                    break;\n                }\n            }\n\
    \        }\n     }\n     return m;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp8umgpwk.d(42): Error: only one index allowed to index `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp8umgpwk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i\
    \ = 1;\n    int size = l.length;\n    if(size == 1) \n    {\n        return true;\n\
    \    }\n    else \n    {\n        if(l[i] > l[i - 1]) \n        {\n          \
    \  while(i < size) \n            {\n                if(l[i] < l[i - 1]) \n   \
    \             {\n                    return false;\n                }\n      \
    \          i++;\n            }\n        }\n        else \n        {\n        \
    \    while(i < size) \n            {\n                if(l[i] > l[i - 1]) \n \
    \               {\n                    return false;\n                }\n    \
    \            i++;\n            }\n        }\n    }\n    return true;\n}\n// Return\
    \ true if all elements of a are greater than or equal to b.\nunittest\n{\n   \
    \ alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm1asmbfu.d(16): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm1asmbfu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ copy = l.dup;\n    copy.sort;\n    return copy == l || copy == l.reverse;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6t33fpcf.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp6t33fpcf.d(17): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6t33fpcf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool isMonotonic;\n\
    \    if(l.length <= 1)\n    {\n        isMonotonic = true;\n    }\n    else\n\
    \    {\n        isMonotonic = true;\n        bool isIncreasing = l[0] < l[1];\n\
    \        foreach(i, elem; l)\n        {\n            if(i < l.length - 1)\n  \
    \          {\n                if(isIncreasing)\n                {\n          \
    \          if(l[i] > l[i + 1])\n                    {\n                      \
    \  isMonotonic = false;\n                        break;\n                    }\n\
    \                }\n                else\n                {\n                \
    \    if(l[i] < l[i + 1])\n                    {\n                        isMonotonic\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return isMonotonic;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool isAscending\
    \ = true;\n    bool isDescending = true;\n    for (size_t i = 1; i < l.length;\
    \ i++) {\n        if (l[i] < l[i - 1]) {\n            isAscending = false;\n \
    \       }\n        if (l[i] > l[i - 1]) {\n            isDescending = false;\n\
    \        }\n    }\n    return isAscending || isDescending;\n}\nunittest\n{\n \
    \   alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1)\n    {\n        return true;\n    }\n    return l[0] < l[1] ? l[0] < l[$\
    \ - 1] : l[0] > l[$ - 1];\n}\n//pure @safe unittest\n//{\n//    assert(monotonic([1L,\
    \ 2L, 4L, 20L]));\n//    assert(!monotonic([1L, 20L, 4L, 10L]));\n//    assert(monotonic([4L,\
    \ 1L, 0L, -10L]));\n//}\nunittest\n{\n    alias candidate = monotonic;\n\n   \
    \ assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpis5zdszu.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x42834d]

    ??:? void tmpis5zdszu.__unittest_L27_C1() [0x427efb]

    ??:? void tmpis5zdszu.__modtest() [0x4280cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b262]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303f5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308a4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430381]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b239]

    ??:? runModuleUnitTests [0x42c1a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428810]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1)\n        return true;\n    auto increasing = (l[0] < l[1]);\n    for (size_t\
    \ i = 1; i < l.length - 1; i++) \n    {\n        if (increasing && l[i] > l[i\
    \ + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool isIncreasing\
    \ = true;\n    foreach(ulong i, ref long e1; l)\n    {\n        if(e1 != null)\n\
    \        {\n            auto e2 = l[i+1];\n            if(e2 != null)\n      \
    \      {\n                auto diff = e2 - e1;\n                if(!diff) \n \
    \               {\n                    continue;\n                }\n        \
    \        else if(diff > 0)\n                {\n                    if(!isIncreasing)\n\
    \                    {\n                        return false;\n              \
    \      }\n                }\n                else\n                {\n       \
    \             if(isIncreasing)\n                    {\n                      \
    \  isIncreasing = false;\n                    }\n                }\n         \
    \   }\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxx283l7_.d(18): Error: incompatible types for `(e1) != (null)`:
    `long` and `typeof(null)`

    /tmp/tmpxx283l7_.d(21): Error: incompatible types for `(e2) != (null)`: `long`
    and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxx283l7_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164353
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool is_inc\
    \ = l[0] < l[1];\n    bool is_dec = l[0] > l[1];\n    foreach (i, n; l[1..$])\n\
    \    {\n        if (l[i] < l[i - 1])\n            is_inc = false;\n        if\
    \ (l[i] > l[i - 1])\n            is_dec = false;\n    }\n    return is_inc ||\
    \ is_dec;\n}\n/*\nReturn true if array elements are monotonically increasing.\n\
    \    >>> increasing([-1L, -2L, -4L, -20L])\n    true\n    >>> increasing([-1L,\
    \ -20L, -4L, -10L])\n    false\n    >>> increasing([0L, 1L, 2L, 4L, 20L])\n  \
    \  true\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpc5h1aj53.d(19): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4284ce]

    ??:? bool tmpc5h1aj53.monotonic(long[]) [0x427e41]

    ??:? void tmpc5h1aj53.__unittest_L35_C1() [0x427f19]

    ??:? void tmpc5h1aj53.__modtest() [0x42819c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c49f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b332]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430974]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430451]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b309]

    ??:? runModuleUnitTests [0x42c275]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto isMonotonic\
    \ = true;\n    auto sgn = 0;\n    auto l0 = l.front;\n    for (auto v : l[1 ..\
    \ $]) \n    {\n        auto sgnNew = sign(v - l0);\n        if (sgn && sgn !=\
    \ sgnNew) \n        {\n            isMonotonic = false;\n            break;\n\
    \        }\n        sgn = sgnNew;\n        l0 = v;\n    }\n    return isMonotonic;\n\
    }\n/*\nReturn index of largest value in array.\n    >>> maxIdx([1L, 2L, 4L, 20L])\n\
    \    3\n    >>> maxIdx([1L, 20L, 4L, 10L])\n    1\n    >>> maxIdx([4L, 1L, 0L,\
    \ -10L])\n    0\n*/\nsize_t maxIdx(long[] l) \n{\n    auto maxIdx = 0;\n    auto\
    \ max = l.front;\n    size_t i = 0;\n    for (auto v : l) \n    {\n        if\
    \ (v > max) \n        {\n            max = v;\n            maxIdx = i;\n     \
    \   }\n        i++;\n    }\n    return maxIdx;\n}\n/*\nReturn index of smallest\
    \ value in array.\n    >>> minIdx([1L, 2L, 4L, 20L])\n    0\n    >>> minIdx([1L,\
    \ 20L, 4L, 10L])\n    0\n    >>> minIdx([4L, 1L, 0L, -10L])\n    3\n*/\nsize_t\
    \ minIdx(long[] l) \n{\n    auto minIdx = 0;\n    auto min = l.front;\n    size_t\
    \ i = 0;\n    for (auto v : l) \n    {\n        if (v < min) \n        {\n   \
    \         min = v;\n            minIdx = i;\n        }\n        i++;\n    }\n\
    \    return minIdx;\n}\n//----------------------------------------------------------------------\n\
    // String operations\n//----------------------------------------------------------------------\n\
    /*\nReturn true if string s has prefix prefix.\n    >>> has\nunittest\n{\n   \
    \ alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpig0pjkgs.d(18): Error: no identifier for declarator `v`

    /tmp/tmpig0pjkgs.d(18): Error: expression expected, not `:`

    /tmp/tmpig0pjkgs.d(18): Error: found `l` when expecting `;` following `for` condition

    /tmp/tmpig0pjkgs.d(18): Error: found `..` when expecting `,`

    /tmp/tmpig0pjkgs.d(18): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpig0pjkgs.d(45): Error: no identifier for declarator `v`

    /tmp/tmpig0pjkgs.d(45): Error: expression expected, not `:`

    /tmp/tmpig0pjkgs.d(45): Error: found `l` when expecting `;` following `for` condition

    /tmp/tmpig0pjkgs.d(70): Error: no identifier for declarator `v`

    /tmp/tmpig0pjkgs.d(70): Error: expression expected, not `:`

    /tmp/tmpig0pjkgs.d(70): Error: found `l` when expecting `;` following `for` condition

    /tmp/tmpig0pjkgs.d(84): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpig0pjkgs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool result\
    \ = true;\n    if (l.length == 1)\n    {\n        return true;\n    }\n    bool\
    \ asc = l[0] < l[1];\n    foreach (int i, long value; l)\n    {\n        if (i\
    \ == 0)\n        {\n            continue;\n        }\n        if (asc)\n     \
    \   {\n            if (l[i] < l[i - 1])\n            {\n                result\
    \ = false;\n                break;\n            }\n        }\n        else\n \
    \       {\n            if (l[i] > l[i - 1])\n            {\n                result\
    \ = false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn true if a is a subset of b\n    >>> subset([1L, 2L, 4L],\
    \ [1L, 2L, 4L, 20L])\n    true\n    >>> subset([1L, 4L, 20L], [1L, 2L, 4L])\n\
    \    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    l = l.sort();\n\
    \    return true;\n}\n \n/*\nReturn true if array elements are monotonically increasing.\n\
    \    >>> monotonic_increasing([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n\
    \    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphywsx06j.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphywsx06j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    //for(long\
    \ i=0; i < l.length - 1; i++)\n    //  if(l[i+1] > l[i])\n    //      return false;\n\
    \    //  return true;\n    \n    long first = l[0];\n    foreach(i; l[1..$])\n\
    \    {\n        if(i < first)\n            return false;\n        first = i;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppr65vt8m.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x428305]

    ??:? void tmppr65vt8m.__unittest_L29_C1() [0x427f01]

    ??:? void tmppr65vt8m.__modtest() [0x428084]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c387]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b21a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43085c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430339]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]

    ??:? runModuleUnitTests [0x42c15d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ <= 1)\n    {\n        return true;\n    }\n    int direction = l[1] - l[0];\n\
    \    foreach(int i, long element; l)\n    {\n        if((i != 0) && (element -\
    \ l[i - 1]) * direction < 0)\n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n/*\n    >>> second(['a', 'b', 'c'])\n    'b'\n  \
    \  >>> second(['a'])\n    Traceback (most recent call last):\n        ...\n  \
    \  IndexError: list index out of range\n*/\nchar second(char[] l)\n{\n    if(l.length\
    \ < 2)\n    {\n        throw new IndexError(\"list index out of range\");\n  \
    \  }\n    return l[1];\n}\n/*\n    >>> swap(['a', 'b', 'c'])\n    ['b', 'a', 'c']\n\
    \    >>> swap(['a'])\n    ['a']\n*/\nchar[] swap(char[] l)\n{\n    if(l.length\
    \ == 0)\n    {\n        return l;\n    }\n    char[] res = new char[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(i == 0)\n        {\n\
    \            res[i] = l[1];\n        }\n        else if(i == 1)\n        {\n \
    \           res[i] = l[0];\n        }\n        else\n        {\n            res[i]\
    \ = l[i];\n        }\n    }\n    return res;\n}\n/*\n    >>> is_ascending(['a',\
    \ 'b', 'c'])\n    True\n    >>> is_ascending(['a', 'b', 'b'])\n    False\n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ebsbmec.d(19): Error: cannot implicitly convert expression `l[1]
    - l[0]` of type `long` to `int`

    /tmp/tmp8ebsbmec.d(41): Error: undefined identifier `IndexError`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ebsbmec.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing;\n\
    \    long n = 0L;\n    if (l.length == 0) \n    {\n        throw new Exception(\"\
    Cannot calculate monotonicity of empty list\");\n    }\n    increasing = l[0]\
    \ < l[1];\n    foreach (i; 1..l.length) \n    {\n        if (l[i - 1] != l[i])\
    \ \n        {\n            if (increasing) \n            {\n                if\
    \ (l[i - 1] > l[i]) \n                {\n                    return false;\n \
    \               }\n            }\n            else \n            {\n         \
    \       if (l[i - 1] < l[i]) \n                {\n                    return false;\n\
    \                }\n            }\n        }\n        n = n + 1L;\n    }\n   \
    \ return true;\n}\n/*\nReturn true if two lists have the same length and each\
    \ element is the same.\n    >>> is_same([0, 1, 2], [0, 1, 2])\n    true\n    >>>\
    \ is_same([0, 1, 2], [0, 1, 3])\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ sign = Array(long)();\n    foreach (i,el; l) \n    {\n        if (i > 0) \n\
    \        {\n            sign ~= (el - l[i-1L]);\n        }\n    }\n    return\
    \ sign.uniq.length == 1L;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbg39x4rg.d(15): Error: found `)` when expecting `.` following long

    /tmp/tmpbg39x4rg.d(15): Error: found `(` when expecting identifier following `long`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbg39x4rg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = false;\n    bool decreasing = false;\n    bool nonIncrease = false;\n    bool\
    \ nonDecrease = false;\n    long current_element = l[0];\n    if (l.length ==\
    \ 1) \n    {\n        return true;\n    }\n    foreach (element; l[1..$]) \n \
    \   {\n        if (element > current_element) \n        {\n            increasing\
    \ = true;\n            if (nonDecrease)\n            {\n                return\
    \ false;\n            }\n        }\n        else if (element < current_element)\
    \ \n        {\n            decreasing = true;\n            if (nonIncrease)\n\
    \            {\n                return false;\n            }\n        }\n    \
    \    else \n        {\n            if (increasing)\n            {\n          \
    \      nonIncrease = true;\n            }\n            if (decreasing)\n     \
    \       {\n                nonDecrease = true;\n            }\n        }\n   \
    \     current_element = element;\n    }\n    return true;\n}\n/*\nReturn a random\
    \ permutation of the input array.\n*/\nlong[] permutation(long[] l) \n{\n    auto\
    \ index = new long[l.length];\n    foreach (i, t; index) \n    {\n        index[i]\
    \ = i;\n    }\n    shuffle(index);\n    auto result = new long[l.length];\n  \
    \  foreach (i, t; index) \n    {\n        result[i] = l[index[i]];\n    }\n  \
    \  return result;\n}\n/*\nMultiply array by scalar.\n*/\nlong[] multiply(long[]\
    \ array, long factor) \n{\n    foreach (j, i; array) \n    {\n        array[j]\
    \ = i * factor;\n    }\n    return array;\n}\n/*\nReturn true if array is sorted\
    \ low to high.\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprtimdeze.d(67): Error: undefined identifier `shuffle`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprtimdeze.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\
    \ {\n        if (l[i] < l[i - 1]) {\n            increasing = false;\n       \
    \ }\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n       \
    \ }\n    }\n    return increasing || decreasing;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1) \n    {\n        return true;\n    }\n    long first = l[0];\n    long\
    \ last = l[l.length - 1];\n    long[] positive = l.filter!(e => e > 0).array;\n\
    \    long[] negative = l.filter!(e => e < 0).array;\n    long[] positive_increasing\
    \ = positive.filter!(e => e >= first).array;\n    long[] positive_decreasing =\
    \ positive.filter!(e => e <= first).array;\n    long[] negative_increasing = negative.filter!(e\
    \ => e >= last).array;\n    long[] negative_decreasing = negative.filter!(e =>\
    \ e <= last).array;\n    return positive_increasing.length == positive.length\
    \ || positive_decreasing.length == positive.length || negative_increasing.length\
    \ == negative.length || negative_decreasing.length == negative.length;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1r0vgeve.d(21): Error: no property `filter` for type `long[]`

    /tmp/tmp1r0vgeve.d(22): Error: no property `filter` for type `long[]`

    /tmp/tmp1r0vgeve.d(23): Error: no property `filter` for type `long[]`

    /tmp/tmp1r0vgeve.d(24): Error: no property `filter` for type `long[]`

    /tmp/tmp1r0vgeve.d(25): Error: no property `filter` for type `long[]`

    /tmp/tmp1r0vgeve.d(26): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1r0vgeve.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (size_t i = 1; i < l.length; i++)\
    \ \n    {\n        if (l[i] < l[i - 1])\n            increasing = false;\n   \
    \     if (l[i] > l[i - 1])\n            decreasing = false;\n    }\n    return\
    \ increasing || decreasing;\n}\n/*\nReturn the largest odd integer that is less\
    \ than x\n    >>> largest_odd(10L)\n    9L\n    >>> largest_odd(9L)\n    7L\n\
    \    >>> largest_odd(6L)\n    5L\n    >>> largest_odd(5L)\n    5L\n    >>> largest_odd(4L)\n\
    \    3L\n    >>> largest_odd(3L)\n    3L\n*/\nlong largest_odd(long x) \n{\n \
    \   if (x & 1)\n        return x;\n    else\n        return x - 2;\n}\n/*\nReturn\
    \ a tuple representing an interval\n    >>> interval(10L, 2L)\n    (10L, 2L)\n\
    \    >>> interval(10L, 5L)\n    (10L, 5L)\n    >>> interval(10L, 10L)\n    (10L,\
    \ 10L)\n    >>> interval(5L, 10L)\n    (5L, 10L)\n    >>> interval(5L, 10L, False)\n\
    \    (10L, 5L)\n*/\nTuple!(long, long) interval(long a, long b, bool asc = true)\
    \ \n{\n    if (asc || a == b)\n        return tuple(a, b);\n    else\n       \
    \ return tuple(b, a);\n}\n/*\nReturn true if the elements of a sequence are unique.\n\
    \    >>> unique([1L, 2L, 4L, 6L])\n    true\n    >>> unique([1L, 2L, 4L, 6L, 2L])\n\
    \    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    immutable(bool)\
    \ fb = l[0] < l[1];\n    foreach(i, ref elt; l[1..$])\n    {\n        if(elt <\
    \ l[i-1] != fb)\n            return false;\n    }\n    return true;\n}\n/*\nCheck\
    \ if an array is sorted.\n    >>> isSorted([1L, 2L, 4L, 20L])\n    true\n    >>>\
    \ isSorted([1L, 20L, 4L, 10L])\n    false\n    >>> isSorted([4L, 1L, 0L, -10L])\n\
    \    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2gpxxo3e.d(18): Error: found `!=` when expecting `)`

    /tmp/tmp2gpxxo3e.d(18): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2gpxxo3e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  if (l.length\
    \ < 2) return true;\n  int k = l[0] > l[1] ? -1 : 1;\n  for (size_t i = 2; i <\
    \ l.length; i++) \n  {\n    if ((k * l[i-1]) < (k * l[i])) return false;\n  }\n\
    \  return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n        return true;\n    bool d0 = l[0] < l[1];\n    for (size_t i =\
    \ 1; i < l.length - 1; i++) \n    {\n        bool di = l[i] < l[i + 1];\n    \
    \    if (di != d0)\n            return false;\n    }\n    return true;\n}\n/*\n\
    Return true if an element in array is monotonically increasing or decreasing.\n\
    \    >>> monotonicIncreasing([1L, 2L, 4L, 20L])\n    true\n    >>> monotonicIncreasing([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonicIncreasing([4L, 1L, 0L, -10L])\n\
    \    false\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  return monotonic!(\"\
    a < b\")(l);\n}\n/*\nReturn true is array elements are monotonically increasing\
    \ or decreasing.\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3ec2aq0.d(15): Error: template instance `monotonic!"a < b"` `monotonic`
    is not a template declaration, it is a function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3ec2aq0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ > 1)\n    {\n        auto cmp = cmp(i, j);\n        if (cmp == 1)\n        {\n\
    \            auto temp = l[0];\n            foreach (immutable j, immutable k;\
    \ l)\n            {\n                if (temp > k)\n                {\n      \
    \              return false;\n                }\n                temp = k;\n \
    \           }\n        }\n        else if (cmp == -1)\n        {\n           \
    \ auto temp = l[0];\n            foreach (immutable j, immutable k; l)\n     \
    \       {\n                if (temp < k)\n                {\n                \
    \    return false;\n                }\n                temp = k;\n           \
    \ }\n        }\n        else\n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n/*\nReturn true is array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1.0, 2.0, 4.0, 20.0])\n    true\n\
    \    >>> monotonic([1.0, 20.0, 4.0, 10.0])\n    false\n    >>> monotonic([4.0,\
    \ 1.0, 0.0, -10.0])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4eev98nz.d(17): Error: undefined identifier `i`

    /tmp/tmp4eev98nz.d(17): Error: undefined identifier `j`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4eev98nz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    bool asc = (l[1] - l[0]) > 0;\n    for (int i = 2; i\
    \ < l.length; i++) {\n        bool cur = (l[i] - l[i - 1]) > 0;\n        if (cur\
    \ != asc) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ <= 1) return true;\n    bool is_increasing = l[0] < l[1];\n    for(int i = 1;\
    \ i < l.length - 1; i++)\n    {\n        if(is_increasing)\n        {\n      \
    \      if(l[i] > l[i + 1]) return false;\n        }\n        else\n        {\n\
    \            if(l[i] < l[i + 1]) return false;\n        }\n    }\n    return true;\n\
    }\n/*\nReturn a string that can be used as either a scalar variable or \nan array\
    \ variable.\n    >>> make_varname(\"hello\")\n    'hello'\n    >>> make_varname(\"\
    hello[x]\")\n    'hello[x]'\n    >>> make_varname(\"hello[1]\")\n    'hello[1]'\n\
    \    >>> make_varname(\"hello['1']\")\n    'hello[\"1\"]'\n    >>> make_varname(\"\
    hello[x[1]]\")\n    'hello[x[1]]'\n    >>> make_varname(\"hello['x[1]']\")\n \
    \   'hello[\"x[1]\"]'\n    >>> make_varname(\"hello['2\\\\'4']\")\n    'hello[\"\
    2\\'4\"]'\n    >>> make_varname(\"hello['2\\\\'4']\")\n    'hello[\"2\\'4\"]'\n\
    */\nstring make_varname(string s) \n{\n    string rs = \"\";\n    auto len = s.length;\n\
    \    bool in_quote = false;\n    bool can_quote = false;\n    bool must_quote\
    \ = false;\n    bool needs_escape = false;\n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(in_quote)\n        {\n            if(s[i] == '\\'')\n     \
    \       {\n                if(s[i + 1] == '\\'')\n                {\n        \
    \            rs ~= \"\\\\'\";\n                    i++;\n                }\n \
    \               else\n                {\n                    rs ~= '\\'';\n  \
    \                  in_quote = false;\n                }\n            }\n     \
    \       else\n\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc07y4xbt.d(77): Error: found `unittest` instead of statement

    /tmp/tmpc07y4xbt.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpc07y4xbt.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc07y4xbt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool direction\
    \ = l[0] < l[1];\n    foreach(i, x; l) \n    {\n        if(i != 0) \n        {\n\
    \            if(x < l[i - 1] == direction)\n                return false;\n  \
    \      }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp66s4tisw.d(20): Error: found `==` when expecting `)`

    /tmp/tmp66s4tisw.d(20): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp66s4tisw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto l1\
    \ = l[0];\n    auto m = l[0] > l[1];\n    foreach(t; l[1..$])\n    {\n       \
    \ if(m != (l1 > t))\n            return false;\n        l1 = t;\n    }\n    return\
    \ true;\n}\n/*\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdpczd_7x.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdpczd_7x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ compare(l) == 0L || compare(l) == 1L || compare(l) == -1L;\n}\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8qaxkpa9.d(15): Error: undefined identifier `compare`

    /tmp/tmp8qaxkpa9.d(15): Error: undefined identifier `compare`

    /tmp/tmp8qaxkpa9.d(15): Error: undefined identifier `compare`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8qaxkpa9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ sort(l).isSorted;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxemjj20a.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxemjj20a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164354
