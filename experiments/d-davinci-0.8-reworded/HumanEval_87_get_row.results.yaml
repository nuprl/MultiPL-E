name: HumanEval_87_get_row
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    foreach(rowIndex, row;\
    \ lst)\n    {\n        foreach(colIndex, item; row)\n        {\n            if(item\
    \ == x)\n            {\n                res ~= tuple(rowIndex, colIndex);\n  \
    \          }\n        }\n    }\n    res.sort!((a, b) => a[0] == b[0] ? a[1] >\
    \ b[1] : a[0] < b[0]);\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7nnee_2l.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\n/tmp/tmp7nnee_2l.d(36): Error: no property\
    \ `sort` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp7nnee_2l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto ret = appender!(Tuple!(long, long)[])();\n    for\
    \ (long row = 0; row < lst.length; row++)\n    {\n        for (long col = 0; col\
    \ < lst[row].length; col++)\n        {\n            if (lst[row][col] == x)\n\
    \            {\n                ret.put(tuple(row, col));\n            }\n   \
    \     }\n    }\n    return ret.data.sort(a => a[0]).sort(a => -a[1]);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp288jxubu.d(25): Error: template instance `appender!(Tuple!(long,\
    \ long)[])` template `appender` is not defined\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp288jxubu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto lst_ret = Tuple!(long, long)[]();\n    for (long\
    \ i = 0L; i < lst.length; i++)\n    {\n        for (long j = 0L; j < lst[i].length;\
    \ j++)\n        {\n            if (lst[i][j] == x)\n            {\n          \
    \      lst_ret ~= tuple(i, j);\n            }\n        }\n    }\n    return lst_ret.sort!((a,\
    \ b) => a[0] == b[0] ? b[1] < a[1] : a[0] < b[0]);\n}\n/*\n    Expected Output:\n\
    \    (tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L))\n\
    */\n \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxx06u5rn.d(25): Error: function expected before `()`, not `Tuple!(long,\
    \ long)[]` of type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpxx06u5rn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long[][] coords;\n    for (long i = 0L; i < lst.length;\
    \ i++)\n    {\n        if (lst[i].count(x) != 0L)\n        {\n            coords\
    \ ~= lst[i].retroFind(x);\n        }\n    }\n    std.algorithm.sort!((a, b) =>\
    \ a[0] < b[0]);\n    foreach (row; coords)\n    {\n        std.algorithm.sort!((a,\
    \ b) => a[1] > b[1]);\n    }\n    return coords;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp43t24iev.d(28): Error: no property `count` for type `long[]`\\\
    n/tmp/tmp43t24iev.d(30): Error: no property `retroFind` for type `long[]`\\n/tmp/tmp43t24iev.d(33):\
    \ Error: undefined identifier `algorithm` in package `std`\\n/tmp/tmp43t24iev.d(36):\
    \ Error: undefined identifier `algorithm` in package `std`\\n/tmp/tmp43t24iev.d(38):\
    \ Error: cannot implicitly convert expression `coords` of type `long[][]` to `Tuple!(long,\
    \ long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43t24iev.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(immutable long\
    \ i, immutable row; lst)\n    {\n        immutable long[] indexes = row.indexOf(x);\n\
    \        if(indexes.length > 0)\n        {\n            foreach(immutable index;\
    \ indexes)\n            {\n                auto t = tuple(i, index);\n       \
    \         result ~= t;\n            }\n        }\n    }\n    return result.sort();\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9dqux4x6.d(26): Error: cannot implicitly convert expression `__r91[cast(ulong)__key90]`\
    \ of type `long[]` to `immutable(long[])`\\n/tmp/tmp9dqux4x6.d(28): Error: no\
    \ property `indexOf` for type `immutable(long[])`\\n/tmp/tmp9dqux4x6.d(34): Error:\
    \ cannot append type `Tuple!(immutable(long), immutable(long))` to type `Tuple!(long,\
    \ long)[]`\\n/tmp/tmp9dqux4x6.d(38): Error: no property `sort` for type `Tuple!(long,\
    \ long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9dqux4x6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n    if (is(typeof(std.algorithm.find(lst, x).front.front) : long))\n\
    {\n    Tuple!(long, long)[] result;\n    long x_idx;\n    long y_idx;\n    for\
    \ (size_t i = 0; i < lst.length; i++) \n    {\n        foreach (j; lst[i]) \n\
    \        {\n            if (j == x) \n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result;\n}\n \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppb3utjof.d(24): Error: cannot use function constraints for non-template\
    \ functions. Use `static if` instead\\n/tmp/tmppb3utjof.d(24): Error: declaration\
    \ expected, not `if`\\n/tmp/tmppb3utjof.d(29): Error: declaration expected, not\
    \ `for`\\n/tmp/tmppb3utjof.d(29): Error: no identifier for declarator `i`\\n/tmp/tmppb3utjof.d(29):\
    \ Error: declaration expected, not `<`\\n/tmp/tmppb3utjof.d(29): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmppb3utjof.d(29): Error: declaration expected, not\
    \ `++`\\n/tmp/tmppb3utjof.d(31): Error: no identifier for declarator `lst[i]`\\\
    n/tmp/tmppb3utjof.d(31): Error: declaration expected, not `)`\\n/tmp/tmppb3utjof.d(36):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmppb3utjof.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long[] ys;\n    foreach(idx, inner; lst) \n    {\n   \
    \     foreach(jdx, num; inner) \n        {\n            if(num == x) \n      \
    \      {\n                ys ~= tuple(idx, jdx);\n            }\n        }\n \
    \   }\n    return ys.sort!((a, b) => (a[0] == b[0]) ? b[1] < a[1] : a[0] < b[0]);\n\
    }\n// \u0412\u044B \u0434\u0430\u043D\u044B \u0447\u0438\u0441\u043B\u0430, \u043A\
    \u0430\u043A \u0432\u043B\u043E\u0436\u0435\u043D\u043D\u044B\u0435 \u043C\u0430\
    \u0441\u0441\u0438\u0432\u044B,\n// \u043A\u043E\u0442\u043E\u0440\u044B\u0435\
    \ \u043D\u0430\u043F\u043E\u043C\u0438\u043D\u0430\u044E\u0442 \u043C\u0430\u0442\
    \u0440\u0438\u0446\u044B, \u043E\u0434\u043D\u0430\u043A\u043E, \u0432 \u043E\u0442\
    \u043B\u0438\u0447\u0438\u0435 \u043E\u0442 \u043C\u0430\u0442\u0440\u0438\u0446\
    ,\n// \u043A\u0430\u0436\u0434\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430\
    \ \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\
    \u044C \u0440\u0430\u0437\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\
    \u0441\u0442\u0432\u043E \u0441\u0442\u043E\u043B\u0431\u0446\u043E\u0432.\n//\
    \ \u0414\u0430\u043D\u043E lst, \u0438 \u0446\u0435\u043B\u043E\u0435 \u0447\u0438\
    \u0441\u043B\u043E x, \u043D\u0430\u0439\u0434\u0438\u0442\u0435 \u0446\u0435\u043B\
    \u044B\u0435 \u0447\u0438\u0441\u043B\u0430 x \u0432 \u043C\u0430\u0441\u0441\u0438\
    \u0432\u0435,\n// \u0438 \u0432\u0435\u0440\u043D\u0438\u0442\u0435 \u043C\u0430\
    \u0441\u0441\u0438\u0432 \u043A\u043E\u0440\u0442\u0435\u0436\u0435\u0439, [(x1,\
    \ y1), (x2, y2) ...] \u0442\u0430\u043A,\n// \u0447\u0442\u043E \u043A\u0430\u0436\
    \u0434\u044B\u0439 \u043A\u043E\u0440\u0442\u0435\u0436 - \u044D\u0442\u043E \u043A\
    \u043E\u043E\u0440\u0434\u0438\u043D\u0430\u0442\u0430 - (\u0441\u0442\u0440\u043E\
    \u043A\u0430, \u0441\u0442\u043E\u043B\u0431\u0435\u0446), \u043D\u0430\u0447\u0438\
    \u043D\u0430\u044F \u0441 0.\n// \u0421\u043E\u0440\u0442\u0438\u0440\u0443\u0439\
    \u0442\u0435 \u043A\u043E\u043E\u0440\u0434\u0438\u043D\u0430\u0442\u044B \u0432\
    \u043D\u0430\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnmk_zbgw.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `long[]`\\n/tmp/tmpnmk_zbgw.d(36): Error: no property `sort` for type\
    \ `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnmk_zbgw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto res = new Tuple!(long, long)[];\n    foreach(i, e;\
    \ lst)\n    {\n        if(i < 0) continue;\n        auto indices = e.indexOf(x);\n\
    \        foreach(j, v; indices)\n        {\n            res ~= tuple(i, j);\n\
    \        }\n    }\n    res.sort!((a, b) => a[0] < b[0] || (a[0] == b[0] && a[1]\
    \ > b[1]));\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5hoqhwfg.d(25): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmp5hoqhwfg.d(29): Error:\
    \ no property `indexOf` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp5hoqhwfg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    import std.algorithm.iteration : filter, map;\n    import\
    \ std.algorithm.comparison : equal;\n    import std.range.primitives : iota;\n\
    \    import std.range : zip;\n    import std.algorithm.mutation : sort;\n    import\
    \ std.typecons : tuple;\n    auto result = lst.filter!(r => r.equal(x)).map!(r\
    \ => tuple(r.length, r.filter!(e => e == x).length)).sort!((a, b) => a[0] < b[0]\
    \ || a[0] == b[0] && a[1] > b[1]);\n    auto result2 = result.zip(iota(0L, result.length)).map!(t\
    \ => tuple(t[1], t[0][0])).sort!((a, b) => a[0] < b[0] || a[0] == b[0] && a[1]\
    \ > b[1]);\n    return result2;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4o4_3826.d(27): Error: module `std.range.primitives` import `iota`\
    \ not found\\n/tmp/tmp4o4_3826.d(29): Error: module `std.algorithm.mutation` import\
    \ `sort` not found\\n/tmp/tmp4o4_3826.d(31): Error: template `std.algorithm.comparison.equal`\
    \ cannot deduce function from argument types `!()(long[], long)`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/comparison.d(900):\
    \        `std.algorithm.comparison.equal(alias pred = \"a == b\")`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):\
    \        instantiated from here: `FilterResult!(__lambda3, long[][])`\\n/tmp/tmp4o4_3826.d(31):\
    \        instantiated from here: `filter!(long[][])`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4o4_3826.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n\
    \    for (long i = 0; i < lst.length; i++) \n    {\n        for (long j = 0; j\
    \ < lst[i].length; j++) \n        {\n            if (lst[i][j] == x) \n      \
    \      {\n                ret ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    ret.sort!((a, b) => a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]));\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk4nslz6i.d(36): Error: no property `sort` for type `Tuple!(long,\
    \ long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk4nslz6i.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    import std.algorithm : sort;\n    import std.typecons\
    \ : tuple;\n    import std.math : max;\n    import std.range : iota;\n    import\
    \ std.algorithm : filter;\n    import std.algorithm : join;\n    auto row = lst.filter!(a\
    \ => a.arrayof.find(x) != a.arrayof.length).enumerate;\n    foreach(i, a; row)\n\
    \    {\n        row[i].y = a.y.find(x);\n    }\n    row.sort!((a, b) => \n   \
    \           (a.x > b.x) || \n              (a.x == b.x && a.y > b.y)\n       \
    \      );\n    return row;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe3d1utn1.d(27): Error: module `std.math` import `max` not found,\
    \ did you mean function `std.math.fmax`?\\n/tmp/tmpe3d1utn1.d(30): Error: module\
    \ `std.algorithm` import `join` not found, did you mean template `std.algorithm.comparison.min(T...)(T\
    \ args) if (T.length >= 2)`?\\n/tmp/tmpe3d1utn1.d(31): Error: no property `arrayof`\
    \ for type `long[]`\\n/tmp/tmpe3d1utn1.d(31): Error: no property `arrayof` for\
    \ type `long[]`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):\
    \        instantiated from here: `FilterResult!(__lambda3, long[][])`\\n/tmp/tmpe3d1utn1.d(31):\
    \        instantiated from here: `filter!(long[][])`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpe3d1utn1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    int count = 0;\n   \
    \ for (int i = 0; i < lst.length; i++)\n    {\n        for (int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if (lst[i][j] == x)\n            {\n          \
    \      count++;\n            }\n        }\n    }\n    result = new Tuple!(long,\
    \ long)[count];\n    int c = 0;\n    for (int i = 0; i < lst.length; i++)\n  \
    \  {\n        for (int j = 0; j < lst[i].length; j++)\n        {\n           \
    \ if (lst[i][j] == x)\n            {\n                result[c] = tuple(i, j);\n\
    \                c++;\n            }\n        }\n    }\n    int asc(Tuple!(long,\
    \ long) a, Tuple!(long, long) b)\n    {\n        return a[0] - b[0];\n    }\n\
    \    sort(result, asc);\n    int desc(Tuple!(long, long) a, Tuple!(long, long)\
    \ b)\n    {\n        return a[1] - b[1];\n    }\n    stable_sort(result, desc);\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp85osa5a4.d(62): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp85osa5a4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, ref row;\
    \ lst) \n    {\n        foreach(j, r; row) \n        {\n            if(r == x)\n\
    \                result ~= tuple(i, j);\n        }\n    }\n    sort!(\"a.length\
    \ > b.length\", \"a > b\")(result);\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp57fdmcs4.d(31): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\n/tmp/tmp57fdmcs4.d(34): Error: template instance\
    \ `sort!(\"a.length > b.length\", \"a > b\")` template `sort` is not defined,\
    \ did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57fdmcs4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    auto res = new Tuple!(long, long)[];\n    long y = 0;\n\
    \    foreach(row; lst)\n    {\n        long x = 0;\n        foreach(item; row)\n\
    \        {\n            if(item == x)\n            {\n                res ~= tuple(y,\
    \ x);\n            }\n            x++;\n        }\n        y++;\n    }\n    std.algorithm.sort!(\"\
    a.tupleof[0] < b.tupleof[0] || (a.tupleof[0] == b.tupleof[0] && a.tupleof[1] >\
    \ b.tupleof[1])\")(res);\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpasm0q9vx.d(25): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmpasm0q9vx.d(29): Error:\
    \ variable `x` is shadowing variable `tmpasm0q9vx.get_row.x`\\n/tmp/tmpasm0q9vx.d(40):\
    \ Error: undefined identifier `algorithm` in package `std`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpasm0q9vx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long row = 0;\n    Tuple!(long, long)[] result = [];\n\
    \    foreach(sublst; lst)\n    {\n        long column = 0;\n        foreach(subsublst;\
    \ sublst)\n        {\n            if(subsublst == x)\n            {\n        \
    \        result ~= tuple(row, column);\n            }\n            column++;\n\
    \        }\n        row++;\n    }\n    return result.sort!((a, b) => a[0] < b[0]).sort!((a,\
    \ b) => a[1] > b[1]);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp35hdo0r4.d(40): Error: no property `sort` for type `Tuple!(long,\
    \ long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp35hdo0r4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    // add your code here\n    auto ret = appender!(Tuple!(long,\
    \ long)[])();\n    long indx = 0;\n    for(auto i : lst)\n    {\n        auto\
    \ col = 0;\n        for(auto j : i)\n        {\n            if(j == x)\n     \
    \       {\n                ret.put(tuple(indx, col));\n            }\n       \
    \     col++;\n        }\n        indx++;\n    }\n    std.algorithm.sort!(\"a.b\
    \ > b.b\")(ret.data);\n    std.algorithm.sort!(\"a.a < b.a\")(ret.data);\n   \
    \ return ret.data;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6pp5ho71.d(28): Error: no identifier for declarator `i`\\n/tmp/tmp6pp5ho71.d(28):\
    \ Error: expression expected, not `:`\\n/tmp/tmp6pp5ho71.d(28): Error: found `lst`\
    \ when expecting `;` following `for` condition\\n/tmp/tmp6pp5ho71.d(31): Error:\
    \ no identifier for declarator `j`\\n/tmp/tmp6pp5ho71.d(31): Error: expression\
    \ expected, not `:`\\n/tmp/tmp6pp5ho71.d(31): Error: found `i` when expecting\
    \ `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp6pp5ho71.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] rows = [];\n    foreach(ind; 0 ..\
    \ lst.length) \n    {\n        foreach(jnd; 0 .. lst[ind].length) \n        {\n\
    \            if(lst[ind][jnd] == x) \n            {\n                rows ~= tuple(ind,\
    \ jnd);\n            }\n        }\n    }\n    //Pragma(msg, rows);\n    rows.sort!((a,\
    \ b) => a[0] < b[0] || a[0] == b[0] && a[1] > b[1]);\n    return rows;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxuaf9f7q.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\n/tmp/tmpxuaf9f7q.d(37): Error: no property\
    \ `sort` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpxuaf9f7q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    foreach(i, long[] row;\
    \ lst)\n    {\n        foreach(j, long v; row)\n        {\n            if(v ==\
    \ x)\n            {\n                result ~= tuple(i, j);\n            }\n \
    \       }\n    }\n    return sort!((a, b) => (a[0] == b[0]) ? b[1] < a[1] : a[0]\
    \ < b[0])(result);\n}\n// ---\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv57yw1ml.d(32): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\n/tmp/tmpv57yw1ml.d(36): Error: template instance\
    \ `sort!((a, b) => a[0] == b[0] ? b[1] < a[1] : a[0] < b[0])` template `sort`\
    \ is not defined, did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpv57yw1ml.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] arr;\n    bool temp = false;\n  \
    \  foreach(row; 0..lst.length) \n    {\n        foreach(num; 0..lst[row].length)\
    \ \n        {\n            if(lst[row][num] == x) \n            {\n          \
    \      temp = true;\n                arr ~= tuple(row, num);\n            }\n\
    \        }\n    }\n    if(temp)\n    {\n        sort!(\"a[0] < b[0] || a[0] ==\
    \ b[0] && a[1] > b[1]\")(arr);\n        return arr;\n    }\n    else\n    {\n\
    \        return [];\n    }\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd3u0c29n.d(34): Error: cannot append type `Tuple!(ulong, ulong)`\
    \ to type `Tuple!(long, long)[]`\\n/tmp/tmpd3u0c29n.d(40): Error: template instance\
    \ `sort!\"a[0] < b[0] || a[0] == b[0] && a[1] > b[1]\"` template `sort` is not\
    \ defined, did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpd3u0c29n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    import std.algorithm;\n    import std.range;\n    import\
    \ std.array;\n    return lst.map!(r => r.enumerate().filter!(t => t[1] == x).map!(t\
    \ => tuple(r.length, t[0]))).\n        filter!(t => t.length > 0).\n        array.\n\
    \        transposed.\n        map!(t => t.tupleof).\n        sort!((a, b) => a[0]\
    \ > b[0] || (a[0] == b[0] && a[1] < b[1])).\n        array;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfqyuo33o.d(29): Error: no property `length` for type `MapResult!(__lambda3,\
    \ FilterResult!(__lambda2, Result))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/iteration.d(1122):\
    \        instantiated from here: `FilterResult!(__lambda4, MapResult!(__lambda3,\
    \ long[][]))`\\n/tmp/tmpfqyuo33o.d(28):        instantiated from here: `filter!(MapResult!(__lambda3,\
    \ long[][]))`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfqyuo33o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
