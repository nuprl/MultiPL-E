language: d
name: HumanEval_76_is_simple_power
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 1L)\n        return x == 1L;\n    if (x == 0L)\n        return false;\n \
    \   if (x == 1L)\n        return true;\n    if (n == 0L)\n        return x ==\
    \ 0L;\n    if (n == 2L)\n        return true;\n    if (n % 2 == 0L)\n        return\
    \ false;\n    for (long i = 3L; i <= n; i += 2L)\n    {\n        if (x % i ==\
    \ 0L)\n            return false;\n    }\n    return (x % n == 0L) && is_simple_power(x\
    \ / n, n);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp20m2k3w0.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ec5]

    ??:? void tmp20m2k3w0.__unittest_L43_C1() [0x427b59]

    ??:? void tmp20m2k3w0.__modtest() [0x427c44]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa55]

    ??:? runModuleUnitTests [0x42b9c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428314]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ < 1)\n        return false;\n    if (n == 1)\n        return x == 1;\n    if\
    \ (n == 0)\n        return x == 0;\n    if (x == 1)\n        return true;\n  \
    \  if (n == 1)\n        return false;\n    long exponent = 1;\n    long temp =\
    \ n;\n    while (temp * n <= x)\n    {\n        temp *= n;\n        exponent++;\n\
    \    }\n    return temp == x;\n}\n/*\n Your task is to write a function that returns\
    \ true if a number x is a power of n and false in other cases.\n    x is a power\
    \ of n if n**i=x, where i is a natural number\n    For example:\n    >>> is_power(1L,\
    \ 4L)\n    true\n    >>> is_power(2L, 2L)\n    true\n    >>> is_power(8L, 2L)\n\
    \    true\n    >>> is_power(3L, 2L)\n    false\n    >>> is_power(3L, 1L)\n   \
    \ false\n    >>> is_power(5L, 3L)\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x==1)\
    \ return true;\n    if(n==1) return false;\n    if(x==n) return true;\n    return\
    \ is_simple_power(x, cast(long)log(cast(real)x)/log(cast(real)n));\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnez75ro7.d(27): Error: function `tmpnez75ro7.is_simple_power(long
    x, long n)` is not callable using argument types `(long, real)`

    /tmp/tmpnez75ro7.d(27):        cannot pass argument `cast(real)cast(long)log(cast(real)x)
    / log(cast(real)n)` of type `real` to parameter `long n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnez75ro7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ res;\n    long result=0;\n    if( x==1L || x==n )\n    {\n        res=true;\n\
    \    }\n    else\n    {\n        result=log2(x)/log2(n);\n        res= ( n**result\
    \ == x) ? true : false;\n    }\n    return res;\n}\n \n \n/*\n    https://www.daniweb.com/programming/software-development/threads/252679/c-program-to-check-whether-a-number-is-a-power-of-another\n\
    \    http://stackoverflow.com/questions/101439/the-most-efficient-way-to-implement-an-integer-based-power-function-powint-int\n\
    \    http://stackoverflow.com/questions/10030783/fast-and-elegant-integer-power-function-in-c-c\n\
    */\n \n \nlong power(long n,long p)\n{\n    long res;\n    res=pow(n,p);\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd4ec5u4_.d(32): Error: cannot implicitly convert expression `log2(cast(real)x)
    / log2(cast(real)n)` of type `real` to `long`

    /tmp/tmpd4ec5u4_.d(33): Error: can only `*` a pointer, not a `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd4ec5u4_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    const\
    \ double xt = x;\n    const double nt = n;\n    const double num = log(xt) / log(nt);\n\
    \    const uint numi = num;\n    const double numt = numi;\n    return numt ==\
    \ num;\n}\nstatic assert(is_simple_power(1L, 4L));\nstatic assert(is_simple_power(2L,\
    \ 2L));\nstatic assert(is_simple_power(8L, 2L));\nstatic assert(!is_simple_power(3L,\
    \ 2L));\nstatic assert(!is_simple_power(3L, 1L));\nstatic assert(!is_simple_power(5L,\
    \ 3L));\n/*\nfrom std.typecons:\n    auto tup(T1)(T1 x1) { return tuple(x1); }\n\
    \    auto tup(T1, T2)(T1 x1, T2 x2) { return tuple(x1, x2); }\n    auto tup(T1,\
    \ T2, T3)(T1 x1, T2 x2, T3 x3) { return tuple(x1, x2, x3); }\n    auto tup(T1,\
    \ T2, T3, T4)(T1 x1, T2 x2, T3 x3, T4 x4) { return tuple(x1, x2, x3, x4); }\n\
    \    auto tup(T1, T2, T3, T4, T5)(T1 x1, T2 x2, T3 x3, T4 x4, T5 x5) { return\
    \ tuple(x1, x2, x3, x4, x5); }\n    auto tup(T1, T2, T3, T4, T5, T6)(T1 x1, T2\
    \ x2, T3 x3, T4 x4, T5 x5, T6 x6) { return tuple(x1, x2, x3, x4, x5, x6); }\n\
    \    auto tup(T1, T2, T3, T4, T5, T6, T7)(T1 x1, T2 x2, T3 x3, T\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbrhzcjyf.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbrhzcjyf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    immutable\
    \ long num = x;\n    immutable long pow = n;\n    return x != 0 && n != 0 && num\
    \ != 1 ? x != 1 && n != 1 && pow != 1 ? num % n == 0 ? x % n == 0 ? log(num) /\
    \ log(n) % 1 == 0 ? true : false : false : false : false : false;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpx3qa54r_.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f0d]

    ??:? void tmpx3qa54r_.__unittest_L28_C1() [0x427c53]

    ??:? void tmpx3qa54r_.__modtest() [0x427c8c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc47]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aada]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc6d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43011c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbf9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aab1]

    ??:? runModuleUnitTests [0x42ba1d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42835c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x > 0 && (x==1 || (n != 1 && x % n == 0 && is_simple_power(x/n, n)));\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x==1?true:is_simple_power(x,n, 1);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbxu9r_4r.d(24): Error: function `tmpbxu9r_4r.is_simple_power(long
    x, long n)` is not callable using argument types `(long, long, int)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbxu9r_4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\t \n\t\
    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8n8ofb6l.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e05]

    ??:? void tmp8n8ofb6l.__unittest_L27_C1() [0x427a31]

    ??:? void tmp8n8ofb6l.__modtest() [0x427b88]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9be]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb51]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430000]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fadd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a995]

    ??:? runModuleUnitTests [0x42b901]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428254]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 1)\n        return true;\n    else if(x == 0 || n == 0)\n        return false;\n\
    \    else if(n == 1)\n        return false;\n    else\n    {\n        bool res\
    \ = false;\n        double result = 1;\n        for(long i = 0; i <= x; i++)\n\
    \        {\n            result = pow(n, i);\n            if(result == x)\n   \
    \         {\n                res = true;\n                break;\n           \
    \ }\n        }\n        return res;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n==0L)return\
    \ x==1L;\n    if(n==1L)return x==1L;\n    while(true)\n    {\n        auto r =\
    \ x % n;\n        if(r == 0L)\n        {\n            x = x / n;\n           \
    \ if(x == 1L)\n                return true;\n        }\n        else\n       \
    \     return false;\n    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu7z73l0h.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e5d]

    ??:? void tmpu7z73l0h.__unittest_L39_C1() [0x427bc7]

    ??:? void tmpu7z73l0h.__modtest() [0x427bdc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430058]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ed]

    ??:? runModuleUnitTests [0x42b959]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\treturn\
    \ x == (long)pow(n,(int)log(x)/(int)log(n));\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn6gu253b.d(24): Error: C style cast illegal, use `cast(int)log(x)`

    /tmp/tmpn6gu253b.d(24): Error: C style cast illegal, use `cast(int)log(n)`

    /tmp/tmpn6gu253b.d(24): Error: C style cast illegal, use `cast(long)pow(n, cast(int)log(x)
    / cast(int)log(n))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn6gu253b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    immutable\
    \ int_ = (int)log(x) / log(n);\n    return pow(n, int_) == x;\n}\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpok28dn4e.d(24): Error: C style cast illegal, use `cast(int)log(x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpok28dn4e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tdouble\
    \ result = log(x)/log(n);\n\tif(result == int(result)){\n\t\treturn true;\n\t\
    }\n\treturn false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz8asg77o.d(25): Error: cannot implicitly convert expression `result`
    of type `double` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz8asg77o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (\
    \ x == 1 || x == n)\n    {\n        return true;\n    }\n    else if (x < n)\n\
    \    {\n        return false;\n    }\n    else\n    {\n        bool retVal = false;\n\
    \        bool loopFlag = true;\n        int i = 2;\n        while (loopFlag)\n\
    \        {\n            if ( (n ** i) == x)\n            {\n                retVal\
    \ = true;\n                loopFlag = false;\n            }\n            else\
    \ if ( (n ** i) > x)\n            {\n                loopFlag = false;\n     \
    \       }\n            else\n            {\n                i++;\n           \
    \ }\n        }\n        return retVal;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2dyg620e.d(39): Error: can only `*` a pointer, not a `int`

    /tmp/tmp2dyg620e.d(44): Error: can only `*` a pointer, not a `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2dyg620e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    enum\
    \ x = x;\n    enum n = n;\n    if(n == 1 && x == 1)\n        return true;\n  \
    \  if(n > x)\n        return false;\n    long left = n;\n    long right = x;\n\
    \    while(left < right)\n    {\n        left *= n;\n        if(left == right)\n\
    \            return true;\n    }\n    return false;\n}\n/*\nYou have a lot of\
    \ apples (1.5 kg) and you want to distribute them among a number of your colleagues.\n\
    \    The only condition is that the colleague with the smallest number of apples\
    \ is at least three times less than the colleague with the largest number of apples.\n\
    \    Your task is to find such a number of colleagues. If there is no such number\
    \ return 0.\n    >>> distribute_apples(1.5)\n    2\n    >>> distribute_apples(9)\n\
    \    3\n    >>> distribute_apples(6)\n    3\n    >>> distribute_apples(0)\n  \
    \  0\n    >>> distribute_apples(2)\n    0\n    >>> distribute_apples(11)\n   \
    \ 5\n    >>> distribute_apples(24)\n    10\n    >>> distribute_apples(80)\n  \
    \  28\n    >>> distribute_apples(103)\n    31\n    >>> distribute_apples(30)\n\
    \    10\n    >>> distribute_apples(102)\n    31\n    >>> distribute_apples(9.5)\n\
    \    3\n    >>> distribute_apples(24.5)\n    10\n*/\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8t6ero1y.d(24): Error: variable `x` cannot be read at compile time

    /tmp/tmp8t6ero1y.d(24): Error: variable `x` is shadowing variable `tmp8t6ero1y.is_simple_power.x`

    /tmp/tmp8t6ero1y.d(25): Error: variable `n` cannot be read at compile time

    /tmp/tmp8t6ero1y.d(25): Error: variable `n` is shadowing variable `tmp8t6ero1y.is_simple_power.n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8t6ero1y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ nn = long.abs(n);\n    long xx = long.abs(x);\n    if (nn == 0)\n        return\
    \ xx == 1;\n    if (xx < 1)\n        return false;\n    long i = 1;\n    long\
    \ pow = nn;\n    long last_pow = pow;\n    while (pow <= xx)\n    {\n        if\
    \ (pow == xx)\n            return true;\n        last_pow = pow;\n        pow\
    \ *= nn;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmoi6iib7.d(24): Error: cannot pass type `long` as a function argument

    /tmp/tmpmoi6iib7.d(25): Error: cannot pass type `long` as a function argument

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmoi6iib7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n  //x=n**i\n\
    \  //i=log(x)/log(n)\n  static long double log_n=log(n);\n  long double log_x=log(x);\n\
    \  long double i=log_x/log_n;\n  if (i==(long long)i && i>0)\n    return true;\n\
    \  return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n \
    \   assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr_452k4e.d(26): Error: use `real` instead of `long double`

    /tmp/tmpr_452k4e.d(27): Error: use `real` instead of `long double`

    /tmp/tmpr_452k4e.d(28): Error: use `real` instead of `long double`

    /tmp/tmpr_452k4e.d(29): Error: found `long` when expecting `.` following long

    /tmp/tmpr_452k4e.d(29): Error: found `)` when expecting identifier following `long`.

    /tmp/tmpr_452k4e.d(29): Error: found `i` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_452k4e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ n == 1 || x == n || (x > 1 && x % n == 0 && is_simple_power(x / n, n));\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0s0619ag.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e45]

    ??:? void tmp0s0619ag.__unittest_L26_C1() [0x427baf]

    ??:? void tmp0s0619ag.__modtest() [0x427bc4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430040]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9d5]

    ??:? runModuleUnitTests [0x42b941]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428294]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    int\
    \ p = 1;\n    long r = 1;\n    while (r < x)\n    {\n        p++;\n        r =\
    \ power(n, p);\n    }\n    return (r == x) ? true : false;\n}\nunittest\n{\n \
    \   alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkbwpfnh_.d(29): Error: undefined identifier `power`, did you mean
    template `pow(F, G)(F x, G n) if (isFloatingPoint!F && isIntegral!G)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkbwpfnh_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x==1)\n\
    \        return true;\n    else if(x==n)\n        return true;\n    else if(n==1)\n\
    \        return false;\n    else if(n==0)\n        return false;\n    else if(x%n\
    \ != 0)\n        return false;\n    else\n        return is_simple_power(x/n,\
    \ n);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tfloat\
    \ exponent = log(x)/log(n);\n\tif(long(exponent) == exponent)\n\t\treturn true;\n\
    \treturn false;\n}\n/*\nYour task is to write a function that returns true if\
    \ a number x is a multiple\n    of n and false in other cases.\n    x is a multiple\
    \ of n if n % x = 0\n    For example:\n    >>> is_multiple(1L, 1L)\n    true\n\
    \    >>> is_multiple(4L, 2L)\n    true\n    >>> is_multiple(4L, 3L)\n    false\n\
    \    >>> is_multiple(4L, 4L)\n    true\n    >>> is_multiple(0L, 1L)\n    true\n\
    \    >>> is_multiple(0L, 0L)\n    true\n*/\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnw6u5l9z.d(25): Error: cannot implicitly convert expression `exponent`
    of type `float` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnw6u5l9z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ pow(n, cast(double)log(x) / log(n)) == x;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnsr76p2p.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x428a75]

    ??:? void tmpnsr76p2p.__unittest_L26_C1() [0x427e39]

    ??:? void tmpnsr76p2p.__modtest() [0x4287f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c857]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43087d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d2c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430809]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6c1]

    ??:? runModuleUnitTests [0x42c62d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ec4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ <= 0 || n <= 0)\n        return false;\n    \n    long sq = n;\n    while (sq\
    \ < x)\n        sq *= n;\n    \n    return sq == x;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyip7ent0.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e55]

    ??:? void tmpyip7ent0.__unittest_L33_C1() [0x427bbf]

    ??:? void tmpyip7ent0.__modtest() [0x427bd4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430050]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9e5]

    ??:? runModuleUnitTests [0x42b951]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ == 1L && x != 1L) return false;\n    //if(n == 1L && x == 1L) return true;\n\
    \    auto res = long(log(x) / log(n));\n    auto res2 = pow(n, res);\n    if(res2\
    \ == x) return true;\n    return false;\n}\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsdlkq1_n.d(26): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsdlkq1_n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ num = 0;\n    foreach(immutable digit; x.to!string)\n    {\n        num *= 10;\n\
    \        num += digit - '0';\n    }\n    return num % n == 0;\n}\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiqvumy7a.d(25): Error: no property `to` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiqvumy7a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    static\
    \ if (is(typeof(x) == long))\n    {\n        static if (n == 0L)\n        {\n\
    \            return false;\n        }\n        static if (n == 1L)\n        {\n\
    \            return x == 1L;\n        }\n        static if (n > 1L)\n        {\n\
    \            if (x == 0L)\n            {\n                return true;\n     \
    \       }\n            double l = log(cast(double)x) / log(cast(double)n);\n \
    \           static if (is(l is integral))\n            {\n                if (cast(long)l\
    \ == 0L)\n                {\n                    return false;\n             \
    \   }\n                if (cast(long)l == 1L)\n                {\n           \
    \         return true;\n                }\n                long p = 1L;\n    \
    \            long i = 2L;\n                while (i <= cast(long)l)\n        \
    \        {\n                    p *= n;\n                    if (p == x)\n   \
    \                 {\n                        return true;\n                  \
    \  }\n                    ++i;\n                }\n                return false;\n\
    \            }\n            else\n            {\n                return false;\n\
    \            }\n        }\n        else\n        {\n            return false;\n\
    \        }\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwyl4oxau.d(41): Error: found `is` when expecting `)`

    /tmp/tmpwyl4oxau.d(41): Error: found `integral` when expecting `)`

    /tmp/tmpwyl4oxau.d(41): Error: found `)` instead of statement

    /tmp/tmpwyl4oxau.d(69): Error: declaration expected, not `else`

    /tmp/tmpwyl4oxau.d(72): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwyl4oxau.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ n == 1 && x == 1 || n != 1 && x == n ^^ int(log(x) / log(n));\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo3nethd1.d(24): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo3nethd1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ == 0) \n        return true;\n    while(x % n == 0) \n        x /= n;\n    return\
    \ x == 1;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 1)\n        return false;\n    long n1 = 1;\n    long n2 = n;\n    long n3\
    \ = n * n;\n    if (x < n1)\n        return false;\n    if (x == n1)\n       \
    \ return true;\n    while (x >= n3)\n    {\n        n1 = n2;\n        n2 = n3;\n\
    \        n3 *= n;\n    }\n    if (x >= n2 && x < n3)\n        return true;\n \
    \   return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu27vcpeo.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e9d]

    ??:? void tmpu27vcpeo.__unittest_L43_C1() [0x427ae9]

    ??:? void tmpu27vcpeo.__modtest() [0x427c1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbc3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430098]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb75]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa2d]

    ??:? runModuleUnitTests [0x42b999]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x == 1L && n == 1L ? true : (x == n && n == 1L ? true : (x == n*n ? true : (x==n*n*n\
    \ ? true : (x==n*n*n*n ? true : (x==n*n*n*n*n ? true : (x==n*n*n*n*n*n ? true\
    \ : (x==n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n\
    \ ? true : (x==n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n ? true :\
    \ (x==n*n*n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n ? true :\
    \ (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n ?\
    \ true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ ? true : (x==n*n*n*n*n*n*\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgbve4c6p.d(25): Error: expression expected, not `unittest`

    /tmp/tmpgbve4c6p.d(24): Error: found `{` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `alias` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `candidate` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `;` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `assert` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `;` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `assert` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `;` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `assert` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `;` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `assert` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `;` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `assert` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `;` when expecting `)`

    /tmp/tmpgbve4c6p.d(24): Error: found `assert` when expecting `)`

    /tmp/tmpgbve4c6'
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ ((x == 1L) || ( n == 1L)) ? true : (x % n == 0) ? is_simple_power(x / n, n)\
    \ : false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ x = cast(long)log(x);\n    long y = cast(long)log(n);\n    return x % y == 0;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmcpyc1ig.d(24): Error: variable `x` is shadowing variable `tmpmcpyc1ig.is_simple_power.x`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmcpyc1ig.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // Do\
    \ your magic here\n    return std.math.isPowerOf(x, n);\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpous990hk.d(25): Error: undefined identifier `isPowerOf` in module
    `std.math`, did you mean template `isPowerOf2(X)(const X x) if (isNumeric!X)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpous990hk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x==1)\
    \ return true;\n    if (n==1) return false;\n    if (n==x) return true;\n    if\
    \ (n==0) return false;\n    int i = 1;\n    while (n**i < x) \n    {\n       \
    \ i++;\n    }\n    return n**i == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9hvxnts.d(29): Error: can only `*` a pointer, not a `int`

    /tmp/tmpl9hvxnts.d(33): Error: can only `*` a pointer, not a `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9hvxnts.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    enum\
    \ bool retVal = false;\n    ulong temp = 0;\n    if (x == 1) return true;\n  \
    \  if (x > 0 && n > 0)\n    {\n        for (ulong i = 2; i < x; i++)\n       \
    \ {\n            temp = i;\n            for (ulong j = 1; j < n; j++)\n      \
    \      {\n                temp *= i;\n                if (temp == x) return true;\n\
    \            }\n        }\n    }\n    return retVal;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n  int y\
    \ = x;\n  long z = 0;\n  long a = y;\n  int i = 1;\n  for(int i=1; i<=y; i++)\n\
    \  {\n    a = a * n;\n    if(a==x)\n    {\n      return true;\n    }\n  }\n  return\
    \ false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3plftzyq.d(24): Error: cannot implicitly convert expression `x`
    of type `long` to `int`

    /tmp/tmp3plftzyq.d(28): Error: variable `i` is shadowing variable `tmp3plftzyq.is_simple_power.i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3plftzyq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ < 0 || n < 0) return false;\n    if(n == 0) return true;\n    for(int i = 1;\
    \ i < 16; i++)\n    {\n        if(pow(n, i) == x)\n            return true;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp174x58x_.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f2d]

    ??:? void tmp174x58x_.__unittest_L33_C1() [0x427c03]

    ??:? void tmp174x58x_.__modtest() [0x427cb0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aae6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc79]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430128]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc05]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aabd]

    ??:? runModuleUnitTests [0x42ba29]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42837c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x == n**cast(int)log(n,x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpapulacwy.d(24): Error: function `std.math.log(real x)` is not callable
    using argument types `(long, long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpapulacwy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ <= 0 || n <= 0) return false;\n    if (x == 1) return true;\n    long xx = x;\n\
    \    while (xx % n == 0)\n    {\n        xx /= n;\n        if (xx == 1) return\
    \ true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    while(x%n==0)\n\
    \        x/=n;\n    return x==1L;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ pow = Math.pow(x,1.0);\n    long p = x;\n    if(p == n)\n    {\n        return\
    \ true;\n    }\n    else \n    {\n        return false;\n    }\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpis5u9d86.d(24): Error: undefined identifier `Math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpis5u9d86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x==1\
    \ && n==1) return true;\n    while (true)\n    {\n        x /= n;\n        if\
    \ (x==1) return true;\n        if (x<1) return false;\n    }\n}\n/*\n    The function\
    \ is_simple_power is written without any loops and without the\n    if statement.\n\
    */\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpizqnjsa8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e45]

    ??:? void tmpizqnjsa8.__unittest_L36_C1() [0x427b25]

    ??:? void tmpizqnjsa8.__modtest() [0x427bc8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9fe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430040]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9d5]

    ??:? runModuleUnitTests [0x42b941]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428294]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ logn = log(n);\n    return n == 1 ? x == 1 : (floor(log(x) / logn) == log(x)\
    \ / logn);\n}\n/*\n// alternativ\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj12n3esk.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj12n3esk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ tmp=n;\n    if(x==0)\n        return true;\n    if(x==1)\n        return true;\n\
    \    while(x>tmp)\n    {\n        tmp=tmp*n;\n    }\n    if(tmp==x)\n        return\
    \ true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // your\
    \ code\n    /*\n    // x is a simple power of n if n**int=x\n    // long x = 2;\n\
    \    // long n = 2;\n    // Find root of n to the power of power=x.\n    long\
    \ power = x;\n    auto root = log(n);\n    long nroot = std.math.pow(n, power);\n\
    \    if (nroot == x) {\n        return true;\n    }\n    return false;\n    */\n\
    \    /*\n    // x is a simple power of n if n**int=x\n    // long x = 8;\n   \
    \ // long n = 2;\n    // Find root of n to the power of power=x.\n    long power\
    \ = x;\n    auto root = log(n);\n    long nroot = std.math.pow(n, power);\n  \
    \  if (nroot == x) {\n        return true;\n    }\n    return false;\n    */\n\
    \    // x is a simple power of n if n**int=x\n    // long x = 2;\n    // long\
    \ n = 2;\n    // Find root of n to the power of power=x.\n    // long power =\
    \ x;\n    long power = (long) log(x) / log(n);\n    long nroot = (long) std.math.pow(n,\
    \ power);\n    if (nroot == x) {\n        return true;\n    }\n    return false;\n\
    \    /*\n    // Tuple\n    int x = 8;\n    int n = 2;\n    // Convert x and n\
    \ to tuple.\n    typeof((x, n)) tupl = (x, n);\n    // unpack tuple\n    int xtupl\
    \ = tupl[0];\n    int ntupl = tupl[1];\n    // Find root of n to the power of\
    \ power=x.\n    int power = x;\n    auto root = log(n);\n    int nroot = std.math.pow(n,\
    \ power);\n    if (nroot == x) {\n        return true;\n    }\n    return false;\n\
    \    */\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps4ygezud.d(56): Error: C style cast illegal, use `cast(long)log(x)`

    /tmp/tmps4ygezud.d(57): Error: C style cast illegal, use `cast(long)std.math.pow(n,
    power)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps4ygezud.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n  /*\n \
    \ auto b = static_cast(n);\n  auto a = static_cast(x);\n  if(a == 0) return false;\n\
    \  if(b == 0) return false;\n  else if (b == 1) return true;\n  else if (b ==\
    \ 2)\n  {\n    return (a.isPowerOfTwo);\n  }\n  else\n  {\n    auto c = a/b;\n\
    \    if(c*b == a) return true;\n    else return false;\n  }\n  */\n  return x\
    \ == pow(n, cast(uint) floor(log(x) / log(n)));\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1) \n        return true;\n    if (n == 1) \n        return false;\n    if\
    \ (n < 1 || x < 1) \n        return false;\n    long p = n;\n    while (p < x)\
    \ \n        p *= n;\n    return p == x;\n}\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ == 1)\n        return x == 1;\n    \n    else if(x == 1)\n        return false;\n\
    \    \n    else if(x == n)\n        return true;\n    \n    else if(is_pow(x,\
    \ 1/n))\n        return true;\n    else\n        return false;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplplzbp2l.d(33): Error: undefined identifier `is_pow`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplplzbp2l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ k = std.math.sqrt(x);\n    if (k*k != x) return false;\n    while (k > 1) {\n\
    \        k /= n;\n        if (k*n != (int)k) return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp839vj5xe.d(28): Error: C style cast illegal, use `cast(int)k`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp839vj5xe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n==0)\n\
    \        return false;\n    if(x==1)\n        return true;\n    auto len=log(x)/log(n);\n\
    \    if(is(typeof(n) == int) && len-cast(int)len!=0)\n        return false;\n\
    \    if(is(typeof(n) == long) && len-cast(long)len!=0)\n        return false;\n\
    \    if(is(typeof(n) == float) && len-cast(float)len!=0)\n        return false;\n\
    \    if(is(typeof(n) == double) && len-cast(double)len!=0)\n        return false;\n\
    \    if(is(typeof(n) == real) && len-cast(real)len!=0)\n        return false;\n\
    \    return true;\n}\n/*\n    Another solution \n    The 'is' operator checks\
    \ if type1 is same as type2.\n*/\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tif (x\
    \ == 0) return false;\n\tif (n == 0) return true;\n\tif (x == 1 && n == 1) return\
    \ true;\n\tint res = log(x)/log(n);\n\tif (res == 0) return false;\n\treturn pow(n,\
    \ res) == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp93lxvirf.d(27): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp93lxvirf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ true_false = tuple!bool(true, false);\n    auto remainder_division = (x % n).tupleof;\n\
    \    auto loop = [=](auto y, auto a)\n    {\n        enum log_n = log(n);\n  \
    \      if (a < log_n)\n        {\n            auto f = (x % y) == 0;\n       \
    \     return f ? loop(y * n, a + 1) : false_tuple;\n        }\n        return\
    \ true_false;\n    };\n    auto [remainder, quotient] = remainder_division;\n\
    \    auto is_n = n == quotient;\n    auto is_x = x == n;\n    return is_n || (is_x\
    \ && remainder == 0) || (n > 1 && remainder == 0 && loop(n, 1)[0]);\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedipg2fq.d(26): Error: expression expected, not `=`

    /tmp/tmpedipg2fq.d(26): Error: expression expected, not `auto`

    /tmp/tmpedipg2fq.d(26): Error: found `y` when expecting `,`

    /tmp/tmpedipg2fq.d(26): Error: expression expected, not `,`

    /tmp/tmpedipg2fq.d(26): Error: found `auto` when expecting `,`

    /tmp/tmpedipg2fq.d(27): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpedipg2fq.d(35): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpedipg2fq.d(36): Error: basic type expected, not `[`

    /tmp/tmpedipg2fq.d(36): Error: found `,` when expecting `]`

    /tmp/tmpedipg2fq.d(36): Error: semicolon expected, not `]`

    /tmp/tmpedipg2fq.d(36): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedipg2fq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ == 1) return x == 1;\n    long i = log(x)/log(n);\n    return i == pow(n, i);\n\
    }\nstatic assert(is_simple_power(1L, 4L));\nstatic assert(is_simple_power(2L,\
    \ 2L));\nstatic assert(is_simple_power(8L, 2L));\nstatic assert(!is_simple_power(3L,\
    \ 2L));\nstatic assert(!is_simple_power(3L, 1L));\nstatic assert(!is_simple_power(5L,\
    \ 3L));\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwkc0v2tf.d(25): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `long`

    /tmp/tmpwkc0v2tf.d(28):        called from here: `is_simple_power(1L, 4L)`

    /tmp/tmpwkc0v2tf.d(28):        while evaluating: `static assert(is_simple_power(1L,
    4L))`

    /tmp/tmpwkc0v2tf.d(29): Error: CTFE failed because of previous errors in `is_simple_power`

    /tmp/tmpwkc0v2tf.d(29):        while evaluating: `static assert(is_simple_power(2L,
    2L))`

    /tmp/tmpwkc0v2tf.d(30): Error: CTFE failed because of previous errors in `is_simple_power`

    /tmp/tmpwkc0v2tf.d(30):        while evaluating: `static assert(is_simple_power(8L,
    2L))`

    /tmp/tmpwkc0v2tf.d(31): Error: CTFE failed because of previous errors in `is_simple_power`

    /tmp/tmpwkc0v2tf.d(31):        while evaluating: `static assert(!is_simple_power(3L,
    2L))`

    /tmp/tmpwkc0v2tf.d(32): Error: CTFE failed because of previous errors in `is_simple_power`

    /tmp/tmpwkc0v2tf.d(32):        while evaluating: `static assert(!is_simple_power(3L,
    1L))`

    /t'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n==0)\n\
    \        return x==1;\n    if(n==1)\n        return x==1;\n    if(x==1)\n    \
    \    return true;\n    if(n==x)\n        return true;\n    if(x%n!=0)\n      \
    \  return false;\n    long power;\n    power=cast(long)log(x)/log(n);\n    return\
    \ power==cast(long)log(x)/log(n);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0scl3547.d(35): Error: cannot implicitly convert expression `cast(real)cast(long)log(cast(real)x)
    / log(cast(real)n)` of type `real` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0scl3547.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    /*\n\
    \    long double y = pow(n, (int)(log(x)/log(n)));\n    y = trunc(y);\n    return\
    \ x == y;\n    */\n    long double y = log(x)/log(n);\n    y = trunc(y);\n   \
    \ return x == pow(n, (int)y);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5wn6_tam.d(29): Error: use `real` instead of `long double`

    /tmp/tmp5wn6_tam.d(31): Error: C style cast illegal, use `cast(int)y`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5wn6_tam.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ a = pow(n, int(log(x) / log(n)));\n    if (a == x)\n        return true;\n \
    \   return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe2chmyzj.d(24): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe2chmyzj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ res = false;\n    if(n == 1)\n    {\n        if(x == 1)\n            res = true;\n\
    \    }\n    else\n    {\n        if(x % n == 0)\n        {\n            if(log(x)/log(n)\
    \ == int(log(x)/log(n)))\n                res = true;\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvmd0698i.d(34): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvmd0698i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // not\
    \ really what I want to do here, but it works\n    while(x%n == 0)\n    {\n  \
    \      x /= n;\n    }\n    return x == 1;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ ret=false;\n    double tmp=(double)x/n;\n    int ipow=0;\n    if(x>0 && n>0)\n\
    \    {\n        if(modf(tmp,ipow)==0)\n        {\n            ret=true;\n    \
    \    }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsv6sra7x.d(25): Error: C style cast illegal, use `cast(double)x`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv6sra7x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1)\n        return true;\n    \n    long factor = n;\n    long result = 1;\n\
    \    while (result < x)\n    {\n        result *= factor;\n    }\n    \n    return\
    \ result == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n   \
    \ assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n\
    \    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L) == true);\n\
    \    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L, 2L) == false);\n\
    \    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L, 6L) == false);\n\
    \    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L, 12L) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\t//TODO:\
    \ Fill in this function\n\t// Note: You are not allowed to use pow and math.\n\
    \    if (x == 0)\n        return false;\n    if (n == 0)\n        return false;\n\
    \    int counter = 0;\n    bool isPower = false;\n    while (true)\n    {\n  \
    \      if (pow(n, counter) == x)\n        {\n            isPower = true;\n   \
    \         break;\n        }\n        else if (pow(n, counter) > x)\n        {\n\
    \            break;\n        }\n        else\n        {\n            counter++;\n\
    \        }\n    }\n    return isPower;\n}\n/*\nYour task is to return a list of\
    \ all prime numbers of an argument.\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ne64ijh.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ne64ijh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\t// TODO\n\
    \tif (x==1) return true;\n\tif (n==1) return false;\n\tif (x<n) return false;\n\
    \t\n\tTuple!(long,long) tup = std.math.divRem(x,n);\n\tlong q = tup[0];\n\tlong\
    \ r = tup[1];\n\t\n\t//writefln(\"q=%s, r=%s\",q,r);\n\t\n\tif (r!=0) return false;\n\
    \telse\n\t\treturn is_simple_power(q,n);\n\t\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpht4v1cep.d(29): Error: undefined identifier `divRem` in module
    `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpht4v1cep.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ temp=x;\n    while(temp>1)\n    {\n        if(temp%n!=0)\n            return\
    \ false;\n        temp=temp/n;\n    }\n    return temp==1;\n}\nunittest\n{\n \
    \   alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // write\
    \ your code here\n    return x==pow(n,(int)log(x)/(int)log(n));\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpubnnq_o0.d(25): Error: C style cast illegal, use `cast(int)log(x)`

    /tmp/tmpubnnq_o0.d(25): Error: C style cast illegal, use `cast(int)log(n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpubnnq_o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x==1)\
    \ return true;\n    else if(x==0) return false;\n    else if(n==0) return false;\n\
    \    else if(n==1) return false;\n    else\n    {\n        long sum,sum1,sum2;\n\
    \        long int log,log1,log2;\n        sum = 0;\n        sum1 = 0;\n      \
    \  sum2 = 0;\n        log = std.math.log(x);\n        log1 = std.math.log(n);\n\
    \        log2 = log/log1;\n        sum = pow(n,log2);\n        if(sum == x) return\
    \ true;\n        else return false;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq8gj_jpx.d(31): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8gj_jpx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\t// long\
    \ temp = 1;\n\t// long counter = 0;\n\t// long answer = 0;\n\t// long d = 0;\n\
    \t// long c = 0;\n\t// long divisor = 0;\n\t// bool result = false;\n\t//\n\t\
    //\n\t// while(temp < x){\n\t// \ttemp = temp * n;\n\t// \tcounter++;\n\t// }\n\
    \t//\n\t// if(temp == x){\n\t// \tresult = true;\n\t// }\n\t// else{\n\t// \t\
    if(counter == 0){\n\t// \t\treturn false;\n\t// \t}\n\t// \tdivisor = x / n;\n\
    \t// \twhile(divisor != 1){\n\t// \t\tif(divisor % n != 0){\n\t// \t\t\treturn\
    \ false;\n\t// \t\t}\n\t// \t\tdivisor = divisor / n;\n\t// \t}\n\t// }\n\t//\n\
    \t// return result;\n\t\n\treturn isSimplePower(x, n);\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpes8b7svp.d(56): Error: undefined identifier `isSimplePower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpes8b7svp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 0)\n    {\n        return false;\n    }\n    while (n != 0)\n    {\n    \
    \    if (n % x != 0)\n        {\n            return false;\n        }\n      \
    \  n /= x;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqxwwnjuq.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e4d]

    ??:? void tmpqxwwnjuq.__unittest_L38_C1() [0x427a75]

    ??:? void tmpqxwwnjuq.__modtest() [0x427bcc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9dd]

    ??:? runModuleUnitTests [0x42b949]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    while(true)\n    {\n        result = result * n;\n        if(result\
    \ == x)\n            return true;\n        if(result > x)\n            return\
    \ false;\n    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptxprr93y.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e3d]

    ??:? void tmptxprr93y.__unittest_L34_C1() [0x427bab]

    ??:? void tmptxprr93y.__modtest() [0x427bc0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9f6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb89]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430038]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb15]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9cd]

    ??:? runModuleUnitTests [0x42b939]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42828c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1)\n        return true;\n    if (n == 1)\n        return false;\n    long\
    \ res = 1;\n    for (size_t i = 0; res <= x; i++)\n    {\n        res = long(pow(n,\
    \ i));\n        if (res == x)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    static\
    \ struct @safe _pair_find_the_highest_bit\n    {\n        @property bool val()\
    \ @safe pure nothrow\n        {\n            return true;\n        }\n       \
    \ @property long val() @safe pure nothrow\n        {\n            return this.m_n;\n\
    \        }\n        @property long exp() @safe pure nothrow\n        {\n     \
    \       return this.m_p;\n        }\n        this(long x)\n        {\n       \
    \     const long max = 1000000000;\n            this.m_n = x;\n            this.m_p\
    \ = 0;\n            for( long i = max; i >= 1; i /= 10 )\n            {\n    \
    \            if( this.m_n / i > 0 )\n                {\n                    this.m_p\
    \ = i;\n                    break;\n                }\n            }\n       \
    \ }\n        private:\n            long m_n;\n            long m_p;\n    }\n \
    \   long a = _pair_find_the_highest_bit(n).n;\n    long b = _pair_find_the_highest_bit(n).p;\n\
    \    long c = _pair_find_the_highest_bit(x).n;\n    long d = _pair_find_the_highest_bit(x).p;\n\
    \    static struct @safe _pair_find_the_lowest_bit\n    {\n        @property bool\
    \ val() @safe pure nothrow\n        {\n            return true;\n        }\n \
    \       @property long val() @safe pure nothrow\n        {\n            return\
    \ this.m_n;\n        }\n        @property long exp() @safe pure nothrow\n    \
    \    {\n            return this.m_p;\n        }\n        this(long x)\n      \
    \  {\n            const long max = 1000000000;\n            this.m_n = x;\n  \
    \          this.m_p = 0;\n            for( long i = 1; i <= max; i *= 10 )\n \
    \           {\n                if( this.m_n / i > 0 )\n                {\n   \
    \                 this.m_p = i;\n                    break;\n                }\n\
    \            }\n        }\n        private:\n            long m_n\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpokajjxyv.d(24): Error: { } expected following `struct` declaration

    /tmp/tmpokajjxyv.d(25): Error: no identifier for declarator `_pair_find_the_highest_bit`

    /tmp/tmpokajjxyv.d(38): Error: found `x` when expecting `.` following long

    /tmp/tmpokajjxyv.d(38): Error: found `)` when expecting identifier following `long`.

    /tmp/tmpokajjxyv.d(39): Error: found `{` when expecting `,`

    /tmp/tmpokajjxyv.d(40): Error: `(arguments)` expected following `const(long)`

    /tmp/tmpokajjxyv.d(40): Error: found `max` when expecting `,`

    /tmp/tmpokajjxyv.d(40): Error: expression expected, not `=`

    /tmp/tmpokajjxyv.d(40): Error: found `1000000000` when expecting `,`

    /tmp/tmpokajjxyv.d(40): Error: expression expected, not `;`

    /tmp/tmpokajjxyv.d(41): Error: found `this` when expecting `,`

    /tmp/tmpokajjxyv.d(41): Error: found `;` when expecting `,`

    /tmp/tmpokajjxyv.d(42): Error: found `;` when expecting `,`

    /tmp/tmpokajjxyv.d(43): Error: expression expected, not `for`

    /tmp/tmpokajjxyv.d(43): Error: found `i` when expecting `.` follow'
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ i = 0L;\n    auto l = 1L;\n    auto p = 0L;\n    auto q = 1L;\n    auto r =\
    \ 0L;\n    auto s = 1L;\n    auto t = 0L;\n    auto u = 0L;\n    auto v = 1L;\n\
    \    auto y = 0L;\n    auto z = x;\n    auto b = 0L;\n    if (x == 0L) \n    {\n\
    \        return true;\n    }\n    while (z != 0L) \n    {\n        t = z / n;\n\
    \        u = z - t * n;\n        v = s * u + t * r;\n        q = q * v;\n    \
    \    r = s * v;\n        s = s * u + t * r;\n        z = t;\n        if (s ==\
    \ 1L) \n        {\n            break;\n        }\n    }\n    if (z == 0L) \n \
    \   {\n        return true;\n    }\n    else \n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpe4ycu7c7.d(68): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ebd]

    ??:? void tmpe4ycu7c7.__unittest_L63_C1() [0x427b09]

    ??:? void tmpe4ycu7c7.__modtest() [0x427c3c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbe3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc09]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb95]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa4d]

    ??:? runModuleUnitTests [0x42b9b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42830c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1 && n == 1)\n        return true;\n    if (x == 1 && n != 1)\n        return\
    \ false;\n    if (n == 1 && x != 1)\n        return false;\n    if (n == 0 &&\
    \ x != 1)\n        return false;\n    int xx = cast(int)x;\n    int nn = cast(int)n;\n\
    \    int result = cast(int)xx ** cast(int)nn;\n    if (result == xx)\n       \
    \ return true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppp9n1tjm.d(34): Error: can only `*` a pointer, not a `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppp9n1tjm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    enum\
    \ { infinity = typeof(n) == double ? DBL_MAX : LLONG_MAX };\n    if (n == 0L)\n\
    \        return x == 1L;\n    auto max_exp = log(infinity) / log(n);\n    auto\
    \ base = n^cast(typeof(x))max_exp;\n    if (base == x)\n        return true;\n\
    \    auto max_exp_int = cast(int)max_exp;\n    foreach (int i; 0 .. max_exp_int)\n\
    \    {\n        if (n^i == x)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpax9o089b.d(24): Error: found `?` when expecting `.` following double

    /tmp/tmpax9o089b.d(24): Error: found `:` when expecting `,`

    /tmp/tmpax9o089b.d(24): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpax9o089b.d(34): Error: `i == x` must be parenthesized when next to operator
    `^`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpax9o089b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    //auto\
    \ is_simple_power(\n    //        long x, long n)\n    //{\n    //    if(n==0)\n\
    \    //        return false;\n    //    else\n    //        return (x**(1.0/n)).floor\
    \ == (x**(1.0/n));\n    //}\n}\n//fibo\n/*\n    Your task is to write a function\
    \ that returns true if a number x is a fibonacci number and false in other cases.\n\
    \    x is a fibonacci number if it exists in Fibonacci sequence.\n    This sequence\
    \ is defined by next formula Fn=Fn-1+Fn-2, where F0=0 and F1=1.\n    For example:\n\
    \    >>> is_fibonacci(2L)\n    true\n    >>> is_fibonacci(0L)\n    true\n    >>>\
    \ is_fibonacci(1L)\n    true\n    >>> is_fibonacci(3L)\n    true\n    >>> is_fibonacci(4L)\n\
    \    false\n    >>> is_fibonacci(5L)\n    true\n    >>> is_fibonacci(6L)\n   \
    \ false\n    >>> is_fibonacci(7L)\n    false\n    >>> is_fibonacci(8L)\n    true\n\
    \    >>> is_fibonacci(9L)\n    false\n    >>> is_fibonacci(34L)\n    true\n*/\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppiujzfwe.d(22): Error: function `tmppiujzfwe.is_simple_power` has
    no `return` statement, but is expected to return a value of type `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppiujzfwe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    enum\
    \ y = 0;\n    if(n == 0 || x == 0)\n    {\n        return false;\n    }\n    if(x\
    \ == 1)\n    {\n        return true;\n    }\n    y = int(log(x) / log(n));\n \
    \   return n**y == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpibsd1bxp.d(33): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    /tmp/tmpibsd1bxp.d(34): Error: can only `*` a pointer, not a `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpibsd1bxp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    //without\
    \ using the pow() function\n    long temp;\n    if (n == 0 || x == 0) return false;\
    \ //0 is not a power\n    if (n == 1) return true; //1 is a power of any number\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2eys6d20.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2eys6d20.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163951
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ <= 0 || x <= 0)\n        return false;\n    if(n == 1 && x == 1)\n        return\
    \ true;\n    if(x == 1)\n        return false;\n    if(isPowerOfTwo(n))\n    {\n\
    \        while(x > 1)\n        {\n            if(!isPowerOfTwo(x))\n         \
    \       return false;\n            x >>= 1;\n        }\n        return true;\n\
    \    }\n    else\n    {\n        long mul = 1;\n        while(mul < x)\n     \
    \   {\n            mul *= n;\n            if(mul == x)\n                return\
    \ true;\n        }\n        return false;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvo95t_dm.d(30): Error: undefined identifier `isPowerOfTwo`

    /tmp/tmpvo95t_dm.d(34): Error: undefined identifier `isPowerOfTwo`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvo95t_dm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ tmp;\n    tmp = 1;\n    while (tmp < x)\n    {\n        tmp *= n;\n    }\n \
    \   if (tmp == x)\n        return true;\n    else\n        return false;\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tlong x1\
    \ = x;\n\tlong n1 = n;\n\tif (x == 1L)\n\t{\n\t\treturn true;\n\t}\n\telse if\
    \ (n == 1L)\n\t{\n\t\treturn false;\n\t}\n\telse if (log(n1) / log(x1) == floor(log(n1)\
    \ / log(x1)))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t\
    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj8kigpb0.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428045]

    ??:? void tmpj8kigpb0.__unittest_L43_C1() [0x427c71]

    ??:? void tmpj8kigpb0.__modtest() [0x427dc8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bf07]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ad9a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff2d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303dc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42feb9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ad71]

    ??:? runModuleUnitTests [0x42bcdd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ < 0 || n <= 0)\n        return false;\n    \n    while(x % n == 0)\n    {\n\
    \        x /= n;\n    }\n    \n    return x == 1;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163967
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ (floor(log(x)/log(n)) ==  log(x)/log(n));\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp322jglps.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x428035]

    ??:? void tmp322jglps.__unittest_L26_C1() [0x427d7f]

    ??:? void tmp322jglps.__modtest() [0x427db8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bef7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ad8a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff1d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303cc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fea9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ad61]

    ??:? runModuleUnitTests [0x42bccd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428484]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    assert(n\
    \ != 0);\n    return x >= 1 && log(x) / log(n) % 1 == 0;\n}\nunittest\n{\n   \
    \ alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqj0sedh9.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f91]

    ??:? void tmpqj0sedh9.__unittest_L27_C1() [0x427c27]

    ??:? void tmpqj0sedh9.__modtest() [0x427c60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bccb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcf1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4301a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc7d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab35]

    ??:? runModuleUnitTests [0x42baa1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283e0]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n  long result\
    \ = 1;\n  for (int i = 1; result <= x; i++) {\n    result = result * n;\n    if\
    \ (result == x) {\n      return true;\n    }\n  }\n  return false;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu2fypuuz.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e4d]

    ??:? void tmpu2fypuuz.__unittest_L33_C1() [0x427bb7]

    ??:? void tmpu2fypuuz.__modtest() [0x427bcc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9dd]

    ??:? runModuleUnitTests [0x42b949]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ < 1 || n < 1 || x == n)\n        return false;\n    auto exp = cast(int)log(x)\
    \ / log(n);\n    return power(n, exp) == x;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw63p48gh.d(27): Error: undefined identifier `power`, did you mean
    template `pow(F, G)(F x, G n) if (isFloatingPoint!F && isIntegral!G)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw63p48gh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    double\
    \ y;\n    y = log(x) / log(n);\n    return is(typeof(y) == long);\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0mohr4zq.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e85]

    ??:? void tmp0mohr4zq.__unittest_L28_C1() [0x427aad]

    ??:? void tmp0mohr4zq.__modtest() [0x427c04]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbbf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa52]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430094]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb71]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa29]

    ??:? runModuleUnitTests [0x42b995]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282d4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: -8
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ is_ok = true;\n    long tmp_x;\n    auto tmp_num = n;\n    long factor;\n  \
    \  /*\n    for (int i = 1; i < x; i++)\n    {\n        if(x == pow(n, i))\n  \
    \      {\n            return true;\n        }\n    }\n    */\n    /*\n    if(x\
    \ > 1)\n    {\n        while(x != 1)\n        {\n            factor = x % n;\n\
    \            if(factor == 0)\n            {\n                factor = n;\n   \
    \         }\n            x /= factor;\n            n = factor;\n        }\n  \
    \  }\n    else\n    {\n        return false;\n    }\n    */\n    if(x < 0)\n \
    \   {\n        x = abs(x);\n    }\n    if(n < 0)\n    {\n        n = abs(n);\n\
    \    }\n    if(x == 1 || n == 1)\n    {\n        return false;\n    }\n    while(true)\n\
    \    {\n        tmp_x = x;\n        while(tmp_x != 1)\n        {\n           \
    \ if(tmp_x % n == 0)\n            {\n                tmp_x /= n;\n           \
    \ }\n            else\n            {\n                is_ok = false;\n       \
    \         break;\n            }\n        }\n        if(is_ok)\n        {\n   \
    \         break;\n        }\n        else\n        {\n            is_ok = true;\n\
    \            n = n * tmp_num;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ res = true;\n    // Check for n<0\n    if (n <= 0) return false;\n    // Check\
    \ if x is a power of n\n    while (x > 1) {\n        if (n % x != 0) {\n     \
    \       res = false;\n            break;\n        }\n        n /= x;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n \
    \   assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpe440mx9e.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e55]

    ??:? void tmpe440mx9e.__unittest_L37_C1() [0x427a7d]

    ??:? void tmpe440mx9e.__modtest() [0x427bd4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430050]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9e5]

    ??:? runModuleUnitTests [0x42b951]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(\
    \ n < 1)\n        return false;\n    if(x < 1)\n        return false;\n    //guard\
    \ is_simple_power(1L, 4L)\n    if(x == 1 && n != 1)\n        return true;\n  \
    \  // check if the power of n is the same as x\n    // is 2^3 == 8?\n    long\
    \ tmp = n;\n    for( int i = 1; tmp < x; i++)\n    {\n        tmp *= n;\n    \
    \    if(tmp == x)\n            return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpybknuw63.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e65]

    ??:? void tmpybknuw63.__unittest_L42_C1() [0x427baf]

    ??:? void tmpybknuw63.__modtest() [0x427be8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430060]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9f5]

    ??:? runModuleUnitTests [0x42b961]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x==0\
    \ || n==0)\n        return false;\n    else if(n==1)\n        return true;\n \
    \   else if(x==n)\n        return true;\n    else if(x%n!=0)\n        return false;\n\
    \    else\n        return is_simple_power(x/n,n);\n}\n/*\nWrite a function that\
    \ extracts unique elements of the given sequence and puts them in the resulting\
    \ sequence.\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb439qtm3.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb439qtm3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    //condition\
    \ for n==1\n    if(n==1) return true;\n    //condition for x==0\n    if(x==0)\
    \ return false;\n    //condition for x<0 or n<0\n    if(x<0 || n<0) return false;\n\
    \    //condition for x==1\n    if(x==1) return true;\n    //condition for n==0\n\
    \    if(n==0) return false;\n    //variable for result\n    long result=1;\n \
    \   long b=n;\n    //cycle for count power\n    for(int i=0; i<33; i++)\n    {\n\
    \        result*=b;\n        if(result==x)\n        {\n            return true;\n\
    \        }\n        if(result>x)\n        {\n            return false;\n     \
    \   }\n    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq7xi95fn.d(22): Error: function `tmpq7xi95fn.is_simple_power` no
    `return exp;` or `assert(0);` at end of function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7xi95fn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0L)\n        return false;\n    if (x == 1L)\n        return true;\n    long\
    \ power = 1L;\n    long multiplier = n;\n    while (power < x) {\n        power\
    \ *= multiplier;\n    }\n    return power == x;\n}\n/*\nWrite a function that\
    \ is given a number x and a double precision number eps\n    and finds a positive\
    \ number k such that (k-1)**3 < x and k**3 >= x,\n    and abs(k**3 - x) < eps.\n\
    \    >>> find_root(1L, 10**(-6))\n    1L\n    >>> find_root(2L, 10**(-6))\n  \
    \  2L\n    >>> find_root(3L, 10**(-6))\n    2L\n    >>> find_root(3L, 0.01)\n\
    \    2L\n    >>> find_root(3L, 0.001)\n    2L\n    >>> find_root(3L, 0.0001)\n\
    \    2L\n    >>> find_root(1L, 0.0001)\n    1L\n    >>> find_root(1L, 0.01)\n\
    \    1L\n    >>> find_root(2L, 0.01)\n    2L\n    >>> find_root(2L, 0.001)\n \
    \   2L\n    >>> find_root(2L, 0.0001)\n    2L\n    >>> find_root(1.41421L, 0.000001)\n\
    \    1L\n    >>> find_root(1.41421L, 0.0001)\n    1L\n    >>> find_root(1.41421L,\
    \ 0.01)\n    1L\n    >>> find_root(1.41421L, 0.1)\n    1L\n    >>> find_root(1.41421L,\
    \ 1)\n    1L\n    >>> find_root(1.41421L, 10)\n    1L\n*/\nlong find_root(long\
    \ x, double eps) \n{\n    if (x < 0L)\n        throw new Exception(\"x is not\
    \ positive!\");\n    if (eps <= 0.0)\n        throw new Exception(\"\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfhxnfqt0.d(79): Error: unterminated string constant starting at
    /tmp/tmpfhxnfqt0.d(79)

    /tmp/tmpfhxnfqt0.d(95): Error: found `End of File` when expecting `,`

    /tmp/tmpfhxnfqt0.d(95): Error: found `End of File` when expecting `)`

    /tmp/tmpfhxnfqt0.d(95): Error: found `End of File` when expecting `;` following
    `throw` statement

    /tmp/tmpfhxnfqt0.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfhxnfqt0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 1 && x != 1) return false;\n    if (n != 1 && x == 1) return false;\n   \
    \ if (n == 1 && x == 1) return true;\n    long a = n;\n    while (n < x) n *=\
    \ a;\n    if (n == x) return true;\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpby8uxuma.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e85]

    ??:? void tmpby8uxuma.__unittest_L32_C1() [0x427bef]

    ??:? void tmpby8uxuma.__modtest() [0x427c04]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430080]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb5d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa15]

    ??:? runModuleUnitTests [0x42b981]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282d4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ b;\n    if (x == 1)\n        b = true;\n    else if (x % n != 0)\n        b\
    \ = false;\n    else\n        b = is_simple_power(x / n, n);\n    return b;\n\
    }\n/*\nThere is no need to read anything from standard input.\nYou need to implement\
    \ only this function in your code.\n*/\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 1)\n    {\n        return x == 1;\n    }\n    else\n    {\n        long base\
    \ = n;\n        while (base < x)\n        {\n            base *= n;\n        }\n\
    \        return base == x;\n    }\n}\n/*\n    The function should_correct_predict(songs,\
    \ k, precision, recall) \n    should accept next arguments:\n    songs - a set\
    \ of songs in the following format:\n    {\n      \"artist_name\": \"artist\"\
    ,\n      \"track_name\": \"track\",\n      \"user_name\": \"user\",\n      \"\
    user_playcount\": 10,\n      \"similar_artists\": [\"artist_0\", \"artist_1\"\
    , ..., \"artist_n\"]\n    }\n    k - the number of top-k recommendations,\n  \
    \  precision - an expected precision,\n    recall - an expected recall.\n    The\
    \ function should return true if the expected precision and recall \n    are lower\
    \ or equal to the actual precision and recall and false in other cases.\n    The\
    \ actual precision and recall are calculated as follows:\n    - For each user\
    \ from the set of users who listen to all the songs \n    from the song set, we\
    \ generate a list of recommendations.\n    - We take the intersection of the recommended\
    \ songs and the songs that \n    the user listened to.\n    - We calculate the\
    \ actual precision as the ratio of the number of the recommended songs \n    to\
    \ the number of the user's listened songs.\n    - We calculate the actual recall\
    \ as the ratio of the number of the recommended songs \n    to the number of the\
    \ recommended songs that the user has listened to.\n    - We calculate the mean\
    \ value of the actual precision and the actual recall.\n    For example:\n   \
    \ >>> songs = [{\"artist_name\": \"artist1\",\n    ...           \"track_name\"\
    : \"track1\",\n    ...           \"user_name\": \"user1\",\n    ...          \
    \ \"user_playcount\": 1,\n    ...           \"similar_artists\": [\"artist1\"\
    , \"artist2\"]},\n    ...          {\"artist_name\": \"artist2\",\n    ...   \
    \        \"track_name\": \"track2\",\n    ...           \"user_name\": \"user1\"\
    ,\n    ...\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfqg0vtn.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfqg0vtn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x==1)\n\
    \        return true;\n    if(n==1)\n        return false;\n    long i=1L;\n \
    \   long val=n;\n    while(val<=x)\n    {\n        if(val==x)\n            return\
    \ true;\n        val*=n;\n    }\n    return false;\n}\n// @@@LICENSE\n//\n// \
    \     Copyright (c) 2010-2013 LG Electronics, Inc.\n//\n// Licensed under the\
    \ Apache License, Version 2.0 (the \"License\");\n// you may not use this file\
    \ except in compliance with the License.\n// You may obtain a copy of the License\
    \ at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required\
    \ by applicable law or agreed to in writing, software\n// distributed under the\
    \ License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS\
    \ OF ANY KIND, either express or implied.\n// See the License for the specific\
    \ language governing permissions and\n// limitations under the License.\n//\n\
    // LICENSE@@@\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\treturn\
    \ pow(n, int(log(x) / log(n))) == x ? true : false;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj6mcsl7d.d(24): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6mcsl7d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 1) \n    {\n        return true;\n    }\n    if(x > 1 && n == 1) \n    {\n\
    \        return false;\n    }\n    if(x == n) \n    {\n        return true;\n\
    \    }\n    if(x < n) \n    {\n        return false;\n    }\n    long aux, power;\n\
    \    power = 1;\n    aux = n;\n    while(x >= aux) \n    {\n        aux *= n;\n\
    \        power++;\n    }\n    return aux == x;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpejooavl1.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e95]

    ??:? void tmpejooavl1.__unittest_L50_C1() [0x427abd]

    ??:? void tmpejooavl1.__modtest() [0x427c14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430090]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa25]

    ??:? runModuleUnitTests [0x42b991]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    double\
    \ dbl_x = cast(double)x;\n    double dbl_n = cast(double)n;\n    if (dbl_x ==\
    \ 0)\n        return true;\n    else\n        return dbl_x == pow(dbl_n, cast(double)int(log(dbl_x)\
    \ / log(dbl_n)));\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp72oe1nw1.d(29): Error: cannot implicitly convert expression `log(cast(real)dbl_x)
    / log(cast(real)dbl_n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72oe1nw1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \  pow(n, round(log(x) / log(n))) == x ? true : false;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxx3p7u5s.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x428b25]

    ??:? void tmpxx3p7u5s.__unittest_L26_C1() [0x427f53]

    ??:? void tmpxx3p7u5s.__modtest() [0x4288a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c91f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b7b2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430945]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430df4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4308d1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b789]

    ??:? runModuleUnitTests [0x42c6f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428f74]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ == 1)\n        return false;\n    if(x == n)\n        return true;\n    if(x\
    \ > n)\n    {\n        int i = 2;\n        while(x > n)\n        {\n         \
    \   long test = 1;\n            foreach(a; 0 .. i)\n            {\n          \
    \      test *= n;\n            }\n            if(test == x)\n                return\
    \ true;\n            i++;\n        }\n    }\n    return false;\n}\n//****************************************************************************\n\
    /*\nThis is the first part of this kata series. Second part is here and third\n\
    \    part is here\n    Add two English words together!\n    Implement a class\
    \ Arith (struct struct Arith{value : &'static str,} in Rust)\n    such that\n\
    \    //javascript\n    var k = new Arith(\"three\");\n    k.add(\"seven\"); //this\
    \ should return \"ten\"\n    //c++\n    Arith* k = new Arith(\"three\");\n   \
    \ k->add(\"seven\"); //this should return string \"ten\"\n    //Rust\n    let\
    \ c = Arith{value: \"three\"};\n    c.add(\"seven\") // this should return &str\
    \ \"ten\"\n    Input - Will be between zero and ten and will always be in lower\
    \ case\n    Output - Word representation of result, e.g. \"two\"\n    More examples\
    \ in test cases. Good luck!\n*/\nstruct Arith {\n    value : &'static str,\n}\n\
    impl Arith {\n    fn add(&self, rhs : &str) -> &'static str {\n        match self.value\n\
    \        {\n            \"zero\" => match rhs\n            {\n               \
    \ \"zero\" => \"zero\",\n                \"one\" => \"one\",\n               \
    \ \"two\" => \"two\",\n                \"three\" => \"three\",\n             \
    \   \"four\" => \"four\",\n                \"five\" => \"five\",\n           \
    \     \"six\" => \"six\",\n                \"seven\" => \"seven\",\n         \
    \       \"eight\" => \"eight\",\n                \"nine\" => \"nine\",\n     \
    \           \"ten\" => \"ten\",\n                _ => \"\"\n            },\n \
    \           \"one\" => match rhs\n            {\n                \"\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk_gecdnv.d(66): Error: no identifier for declarator `value`

    /tmp/tmpk_gecdnv.d(66): Error: declaration expected, not `:`

    /tmp/tmpk_gecdnv.d(66): Error: unterminated character constant

    /tmp/tmpk_gecdnv.d(69): Error: unterminated character constant

    /tmp/tmpk_gecdnv.d(89): Error: unterminated string constant starting at /tmp/tmpk_gecdnv.d(89)

    /tmp/tmpk_gecdnv.d(105): Error: `}` expected following members in `struct` declaration
    at /tmp/tmpk_gecdnv.d(65)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_gecdnv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // //\
    \ I should reduce the algorithm to the smallest size I can think of.\n    // //\
    \ Let me assume that n > 0 and x>0.\n    // // I would use math.pow.\n    // //\
    \ How would I work with powers of 2: \n    // // 2**4 = 16\n    // // 2**3 = 8\n\
    \    // // 2**2 = 4\n    // // 2**1 = 2\n    // // 2**0 = 1\n    // // I could\
    \ see that x is a power of n if I could compute the log \n    // // of x with\
    \ base n and get an integer.\n    // // I have math.log.\n    // // math.log is\
    \ a log base e. \n    // // So I should divide it by math.log(n) to get the\n\
    \    // // log base n. \n    // // I should round it to see if it is an integer.\n\
    \    // // Let me first figure out a way to round a float.\n    // // I could\
    \ use floor and add 0.5.\n    // // I should do it with a template because\n \
    \   // // I might want to use a float for it.\n    // // Now I need to test for\
    \ is_integer.\n    // // I could use mod to test it.\n    // // Yes that would\
    \ work.\n    // // Yes but I need to be careful with rounding errors.\n    //\
    \ // Let me do it with a template.\n    // // I could build a function that returns\
    \ true or false.\n    // // And then I could use that to see if the log is\n \
    \   // // an integer.\n    // // Let me test the pow_is_integer() first.\n   \
    \ // // Looks like it works with int, long, and float\n    // // looks like it\
    \ works with bigInt too\n    // // Maybe I should use long.\n    // // Math.log\
    \ returns a double by default.\n    // // Maybe I should cast it to a long.\n\
    \    // // Now I should check the x == 0 case.\n    // // Then I should check\
    \ the n == 0 case.\n    // // Then I should check the n == 1 case.\n    // //\
    \ Then I should check the n == 1 and x == 0 case.\n    // // Then I should\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgca46mkt.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgca46mkt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ is_true = false;\n    foreach(i; 0 .. x)\n    {\n        if(x == n ** i)\n \
    \       {\n            is_true = true;\n            break;\n        }\n    }\n\
    \    return is_true;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_n_hwmk0.d(27): Error: can only `*` a pointer, not a `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_n_hwmk0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x == 0 ? n == 0 : n == 1 ? true : x == pow(n, to!int(log(x) / log(n)));\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsowefw3p.d(24): Error: template instance `to!int` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsowefw3p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ p;\n    if ( x == 0 ) return true;\n    if (n == 0) return false;\n    while\
    \ (x > 1) {\n        p = n;\n        while (true) {\n            if (x % p ==\
    \ 0) {\n                x /= p;\n                break;\n            }\n     \
    \       p += n;\n        }\n    }\n    return x == 1;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163967
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 0)\n        return false;\n    if (n == 0)\n        return true;\n    auto\
    \ result = x;\n    while (result % n == 0)\n    {\n        result /= n;\n    }\n\
    \    return result == 1;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163967
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 1L)\n        return true;\n    if(n < 2L)\n        return false;\n    long\
    \ temp = n;\n    while(temp <= x)\n    {\n        if(temp == x)\n            return\
    \ true;\n        temp *= n;\n    }\n    return false;\n}\n/*\nImplement a function\
    \ called square_sum which takes a list of numbers and\n    returns the sum of\
    \ the squares of those numbers.\n    >>> square_sum([1, 2, 3])\n    14\n    >>>\
    \ square_sum([1, -2, 3])\n    10\n    >>> square_sum([])\n    0\n*/\nlong square_sum(List!int\
    \ list)\n{\n    if(list.length == 0)\n        return 0;\n    long temp = 0;\n\
    \    for(int i = 0; i < list.length; i++)\n    {\n        temp += (list[i] * list[i]);\n\
    \    }\n    return temp;\n}\n/*\nYour task is to create a function called is_symmetric\
    \ that will return true\n    if the input array is symmetric and false if it is\
    \ not.\n    An array is symmetric if it is the same forwards as it is backwards,\n\
    \    e.g. [1, 2, 3, 3, 2, 1]\n    >>> is_symmetric([1, 2, 3, 3, 2, 1])\n    true\n\
    \    >>> is_symmetric([1, 2, 3, 1, 2, 3])\n    false\n    >>> is_symmetric([1,\
    \ 2, 3, 2, 1])\n    false\n    >>> is_symmetric([])\n    true\n*/\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqvb006o2.d(47): Error: template instance `List!int` template `List`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqvb006o2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ < 0 || n < 0)\n        return false;\n    if (x == 0)\n        return true;\n\
    \    auto i = n;\n    for (;x % i == 0; i *= n);\n    return i == x;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwmosgfn0.d(29): Error: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwmosgfn0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ c=((n==0) || ((x==1) && (n==1)));\n    while (x>1 && n>1)\n    {\n      c=false;\n\
    \      if (x%n==0)\n      {\n        x/=n;\n        c=true;\n      }\n      else\
    \ if (n%x==0)\n      {\n        n/=x;\n        c=true;\n      }\n      else\n\
    \      {\n        break;\n      }\n    }\n    return c;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcjt7285k.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e9d]

    ??:? void tmpcjt7285k.__unittest_L45_C1() [0x427b9d]

    ??:? void tmpcjt7285k.__modtest() [0x427c1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbc3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430098]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb75]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa2d]

    ??:? runModuleUnitTests [0x42b999]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return x == 1;\n    if (n == 1)\n        return x == 1;\n   \
    \ if (x == 0)\n        return false;\n    long p = cast(long)ceil(log(x) / log(n));\n\
    \    long y = pow(n, p);\n    return x == y;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    static\
    \ int log2(int x) {\n       return int(log(x) / log(2));\n    }\n    if (n ==\
    \ 0 && x == 1)\n        return true;\n    if (x < 1 || n < 1)\n        return\
    \ false;\n    if (log2(x) % log2(n) == 0)\n        return true;\n    return false;\n\
    }\n/*\nCheck if the given string is a correct time representation of the 24-hour\
    \ clock.\n    Example\n    >>> is_correct_time('15:59')\n    True\n    >>> is_correct_time('11:7')\n\
    \    False\n*/\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoeaolwqx.d(25): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(2.00000L)` of type `real` to `int`

    /tmp/tmpoeaolwqx.d(31): Error: function `tmpoeaolwqx.is_simple_power.log2(int
    x)` is not callable using argument types `(long)`

    /tmp/tmpoeaolwqx.d(31):        cannot pass argument `x` of type `long` to parameter
    `int x`

    /tmp/tmpoeaolwqx.d(31): Error: function `tmpoeaolwqx.is_simple_power.log2(int
    x)` is not callable using argument types `(long)`

    /tmp/tmpoeaolwqx.d(31):        cannot pass argument `n` of type `long` to parameter
    `int x`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoeaolwqx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ <= 0L) return false;\n    auto tmp = x;\n    while (tmp >= n)\n    {\n     \
    \   if (tmp % n != 0L) return false;\n        tmp /= n;\n    }\n    return tmp\
    \ == 1L;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163967
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    import\
    \ std.algorithm.iteration;\n    import std.range;\n    import std.math;\n    import\
    \ std.typecons;\n    import std.algorithm;\n    import std.math;\n    import std.stdio;\n\
    \    import std.conv;\n    import std.bigint;\n    import std.exception;\n   \
    \ import std.algorithm.comparison;\n    import std.algorithm.searching;\n    import\
    \ std.typecons;\n    if(n==1L)\n        return true;\n    if(n==0L)\n        return\
    \ false;\n    if(n==x)\n        return true;\n    if(x==1L)\n        return true;\n\
    \    if(x<=0L)\n        return false;\n    BigInt b2=x;\n    BigInt b1=n;\n  \
    \  BigInt b3;\n    try\n    {\n        b3=b1.pow(uint(log(x)/log(n)));\n    }\n\
    \    catch(Exception ex)\n    {\n        b3=b1.pow(uint(log(x)/log(n))-1);\n \
    \   }\n    return b3==b2;\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi_byjx1n.d(52): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `uint`

    /tmp/tmpi_byjx1n.d(56): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `uint`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi_byjx1n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\treturn\
    \ is(typeof(pow(n, 1))==typeof(x)) && is(typeof(pow(n, 2))==typeof(x)) && is(typeof(pow(n,\
    \ 3))==typeof(x)) && is(typeof(pow(n, 4))==typeof(x)) &&\n\t\tpow(n, 1)==x &&\
    \ pow(n, 2)!=x && pow(n, 3)!=x && pow(n, 4)!=x;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp09bx2v8f.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f45]

    ??:? void tmp09bx2v8f.__unittest_L27_C1() [0x427ad5]

    ??:? void tmp09bx2v8f.__modtest() [0x427cc4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc6b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aafe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc91]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430140]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc1d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aad5]

    ??:? runModuleUnitTests [0x42ba41]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428394]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    /*\n\
    \    bool bresult = false;\n    foreach(i;0..x)\n    {\n        bresult =  pow(n,i)\
    \ == x;\n        if(bresult)\n            break;\n    }\n    return bresult;\n\
    \    */\n    if( n==1 && x==1)\n        return true;\n    if(x == 1)\n       \
    \ return false;\n    auto sqrt = cast(uint) sqrt(x);\n    foreach(i;0..sqrt)\n\
    \    {\n        if( pow(n,i) == x)\n            return true;\n    }\n    return\
    \ false;\n}\n/*\nYour task is to write a function that returns true if a number\
    \ is\n    a power of 3 and false in other cases.\n    For example:\n    >>> is_power_of_3(1L)\n\
    \    true\n    >>> is_power_of_3(2L)\n    false\n    >>> is_power_of_3(3L)\n \
    \   true\n    >>> is_power_of_3(4L)\n    false\n    >>> is_power_of_3(5L)\n  \
    \  false\n    >>> is_power_of_3(6L)\n    false\n    >>> is_power_of_3(7L)\n  \
    \  false\n    >>> is_power_of_3(8L)\n    false\n    >>> is_power_of_3(9L)\n  \
    \  true\n    >>> is_power_of_3(10L)\n    false\n    >>> is_power_of_3(11L)\n \
    \   false\n    >>> is_power_of_3(12L)\n    false\n    >>> is_power_of_3(13L)\n\
    \    false\n    >>> is_power_of_3(14L)\n    false\n    >>> is_power_of_3(15L)\n\
    \    false\n    >>> is_power_of_3(16L)\n    false\n    >>> is_power_of_3(17L)\n\
    \    false\n    >>> is_power_of_3(18L)\n    false\n    >>> is_power_of_3(19L)\n\
    \    false\n   \nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp61y5a4sp.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61y5a4sp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ res = log(x) / log(n);\n    res = auto(res) > long(res) ? auto(res) + 1 : long(res);\n\
    \    return  long(pow(n, res)) == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5xbs2dl9.d(25): Error: expression expected, not `auto`

    /tmp/tmp5xbs2dl9.d(25): Error: expression expected, not `auto`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xbs2dl9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    static\
    \ assert(isIntegral!n);\n    static assert(isIntegral!x);\n    static assert(n\
    \ > 0);\n    static assert(x > 0);\n    foreach(i; 1 .. 100) \n    {\n       \
    \ if( pow(n, i) == x )\n            return true;\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8x02mofk.d(24): Error: template instance `isIntegral!n` template
    `isIntegral` is not defined

    /tmp/tmp8x02mofk.d(24):        while evaluating: `static assert(isIntegral!n)`

    /tmp/tmp8x02mofk.d(25): Error: template instance `isIntegral!x` template `isIntegral`
    is not defined

    /tmp/tmp8x02mofk.d(25):        while evaluating: `static assert(isIntegral!x)`

    /tmp/tmp8x02mofk.d(26): Error: variable `n` cannot be read at compile time

    /tmp/tmp8x02mofk.d(26):        while evaluating: `static assert(n > 0L)`

    /tmp/tmp8x02mofk.d(27): Error: variable `x` cannot be read at compile time

    /tmp/tmp8x02mofk.d(27):        while evaluating: `static assert(x > 0L)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8x02mofk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ (x==1L) ? true : \n    (n==1L) ? false : \n    pow(n,floor(log(x)/log(n)))==x;\n\
    }\n/*\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi0biswsf.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi0biswsf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    enum\
    \ num = x;\n    static if(n==0)\n    {\n        return false;\n    }\n    else\
    \ if(n == 1)\n    {\n        return true;\n    }\n    else\n    {\n        int\
    \ counter = 0;\n        while(num > 1)\n        {\n            num = num/n;\n\
    \            counter += 1;\n        }\n        return num == 1;\n    }\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqmrd6crd.d(24): Error: variable `x` cannot be read at compile time

    /tmp/tmpqmrd6crd.d(25): Error: variable `n` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqmrd6crd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tif (x==1&&n==1)\
    \ return true;\n\telse if (x==1&&n!=1) return false;\n\telse if (n==1) return\
    \ false;\n\telse \n\t{\n\t\twhile (x!=n)\n\t\t{\n\t\t\tint f1=n%x;\n\t\t\tint\
    \ f2=x%n;\n\t\t\tif (f1==0&&f2==0) return false;\n\t\t\telse if (f1==0) x=x/n;\n\
    \t\t\telse if (f2==0) n=n/x;\n\t\t\telse return false;\n\t\t}\n\t\treturn true;\n\
    \t}\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp8ksbvfm.d(31): Error: cannot implicitly convert expression `n
    % x` of type `long` to `int`

    /tmp/tmpp8ksbvfm.d(32): Error: cannot implicitly convert expression `x % n` of
    type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp8ksbvfm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ (x == 1 || (x != 0 && isPow(n, ceil(log(x) / log(n))))) ? true : false;\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuupyvirq.d(24): Error: undefined identifier `isPow`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuupyvirq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return false;\n    else if (n == 1)\n        return x == 1;\n\
    \    else if (x == 0)\n        return false;\n    else if (x == 1)\n        return\
    \ true;\n    else if (x == n)\n        return true;\n    else if (x % n != 0)\n\
    \        return false;\n    else\n        return is_simple_power(x / n, n);\n\
    \    \n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163953
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tlong result\
    \ = x;\n\tlong num = n;\n\tif (n == 1)\n\t{\n\t\treturn true;\n\t}\n\twhile (result\
    \ > 1)\n\t{\n\t\tif (result % n != 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\
    result = result / n;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1) return true;\n    if (n == 1) return false;\n    long i = 2;\n    while\
    \ (true)\n    {\n        long pow = static_cast!long(pow(n, i));\n        if (pow\
    \ == x) return true;\n        if (pow > x) return false;\n        i++;\n    }\n\
    \    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd4cy6qza.d(29): Error: template instance `static_cast!long` template
    `static_cast` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd4cy6qza.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ y = long(log(x)/log(n));\n    return x == pow(n, y);\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_p38heeh.d(24): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_p38heeh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // find\
    \ the base and the exponent of x, then compare them\n    // returns false if x<0\
    \ or n<0\n    // if n==0, compare x to 0 or 1\n    auto xx = x < 0L ? (-x) : x;\n\
    \    auto nn = n < 0L ? (-n) : n;\n    return xx==0L ? (nn==0L) : (xx==1L) ? (nn==1L)\
    \ : nn==0L ? false : std.math.frexp(xx).1 == std.math.frexp(nn).1;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpml1l79hv.d(29): Error: found `0.1` when expecting `;` following
    `return` statement

    /tmp/tmpml1l79hv.d(29): Error: found `==` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpml1l79hv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ r = std.math.sqrt(double(x));\n    auto d = double(n);\n    return r == int(r)\
    \ && x == n**int(r);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn2jih08b.d(26): Error: cannot implicitly convert expression `r`
    of type `double` to `int`

    /tmp/tmpn2jih08b.d(26): Error: cannot implicitly convert expression `r` of type
    `double` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn2jih08b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ (x == 1) ? true : ( (x != n) ? false : true );\n}\n/*\nYou need to implement\
    \ a function that returns true when the first parameter\n    is equal to the square\
    \ of the second parameter.\n    For example:\n    >>> is_square(4, 2)\n    true\n\
    \    >>> is_square(5, 2)\n    false\n    >>> is_square(5, 3)\n    false\n    >>>\
    \ is_square(9, 3)\n    true\n    >>> is_square(2, 3)\n    false\n*/\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmut0p3nk.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e1d]

    ??:? void tmpmut0p3nk.__unittest_L41_C1() [0x427a45]

    ??:? void tmpmut0p3nk.__modtest() [0x427b9c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb69]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430018]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faf5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ad]

    ??:? runModuleUnitTests [0x42b919]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42826c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 1L)\n        return false;\n    else if (x == 1L)\n        return true;\n\
    \    else if (n == x)\n        return true;\n    else if (x < n)\n        return\
    \ false;\n    long pow = 1L;\n    long power = 1L;\n    for (; power <= x; power\
    \ *= n)\n    {\n        if (power == x)\n            return true;\n    }\n   \
    \ return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplogj6tww.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e85]

    ??:? void tmplogj6tww.__unittest_L41_C1() [0x427bcf]

    ??:? void tmplogj6tww.__modtest() [0x427c08]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430080]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb5d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa15]

    ??:? runModuleUnitTests [0x42b981]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282d4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // Simple\
    \ caclulation, removed std.math.log, change to std.math.log2.\n    return (x ==\
    \ 1) ? true : (long)log2(x) % (long)log2(n) == 0;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw1udp68q.d(25): Error: C style cast illegal, use `cast(long)log2(x)`

    /tmp/tmpw1udp68q.d(25): Error: C style cast illegal, use `cast(long)log2(n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw1udp68q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // if\
    \ (n == 1) return true;\n    // int i = 1;\n    // long result = n;\n    // while\
    \ (result != x) {\n    //     result *= n;\n    //     if (result == x) return\
    \ true;\n    //     i++;\n    // }\n    // return false;\n    if (x == 1) return\
    \ true;\n    if (n == 1) return false;\n    return (pow(n, int(log(x) / log(n)))\
    \ == x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnt7q4gpm.d(35): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnt7q4gpm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x<n){\n\
    \        return false;\n    }\n    if(x%n!=0){\n        return false;\n    }\n\
    \    while(x%n==0){\n        x=x/n;\n    }\n    if(x==1){\n        return true;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163968
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\t//double\
    \ temp = pow(n, cast(int) floor(log(x) / log(n)));\n\t//double temp = pow(n, cast(int)\
    \ floor(log(x) / log(n)));\n\tdouble temp = 1.0;\n\tfor (int i = 0; i < cast(int)\
    \ floor(log(x) / log(n)); i++)\n\t{\n\t\ttemp *= n;\n\t}\n\treturn cast(long)\
    \ temp == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 1)\n    {\n        return true;\n    }\n    else\n    {\n        for (int\
    \ i = 1; (n^i) <= x; i++)\n        {\n            if ((n^i) == x)\n          \
    \  {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphf9k4tey.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e4d]

    ??:? void tmphf9k4tey.__unittest_L40_C1() [0x427a75]

    ??:? void tmphf9k4tey.__modtest() [0x427bcc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9dd]

    ??:? runModuleUnitTests [0x42b949]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 0) \n    {\n        return false;\n    }\n    //vector matchs :\n    //auto\
    \ matchs = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"\
    9\"];\n    auto tt = x.to!string;\n    //std.regex matchs = std.regex(\"\\\\d+\"\
    );\n    std.regex r = \"\\\\d\";\n    std.regex.Match[] m = r.matchAll(tt);\n\
    \    std.regex.Match[] nn = r.matchAll(n.to!string);\n    if (m.length != nn.length)\n\
    \    {\n        return false;\n    }\n    foreach(ref mm; m)\n    {\n        bool\
    \ f = false;\n        foreach(ref nnn; nn)\n        {\n            if (mm.to !string\
    \ == nnn.to !string)\n            {\n                f = true;\n             \
    \   break;\n            }\n        }\n        if (!f)\n        {\n           \
    \ return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1vq9sbzh.d(30): Error: no property `to` for type `long`

    /tmp/tmp1vq9sbzh.d(32): Error: undefined identifier `regex` in package `std`

    /tmp/tmp1vq9sbzh.d(33): Error: undefined identifier `regex` in package `std`

    /tmp/tmp1vq9sbzh.d(34): Error: undefined identifier `regex` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1vq9sbzh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x > 0 ? pow(n,log(x)/log(n)) == x : x == 0;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo7e0u4gh.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x428a85]

    ??:? void tmpo7e0u4gh.__unittest_L26_C1() [0x427e49]

    ??:? void tmpo7e0u4gh.__modtest() [0x428804]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c867]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43088d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430819]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6d1]

    ??:? runModuleUnitTests [0x42c63d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ed4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // your\
    \ code here...\n    return isPow(x,n);\n}\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsksmk0g5.d(25): Error: undefined identifier `isPow`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsksmk0g5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ == 0)\n        return false;\n    if(x == 1)\n        return true;\n    if(x\
    \ == n)\n        return true;\n    if(log(x)/log(n) != floor(log(x)/log(n)))\n\
    \        return false;\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163953
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 1)\n        return true;\n    long result;\n    bool ret = false;\n    long\
    \ checker = (n*n);\n    while(checker <= x)\n    {\n        if(checker == x)\n\
    \        {\n            ret = true;\n            break;\n        }\n        else\n\
    \        {\n            ret = false;\n            checker *= n;\n        }\n \
    \   }\n    return ret;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ i = n;\n    double j = (double)x;\n    while (i <= j)\n    {\n        if (i\
    \ == j)\n            return true;\n        i = i * n;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptpdwnfxv.d(25): Error: C style cast illegal, use `cast(double)x`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptpdwnfxv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163952
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // Your\
    \ code here.\n    return (log(x) / log(n)) % 1.0 == 0.0;\n}\nunittest\n{\n   \
    \ alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmkydjhgo.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e95]

    ??:? void tmpmkydjhgo.__unittest_L27_C1() [0x427bdb]

    ??:? void tmpmkydjhgo.__modtest() [0x427c14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbcf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa62]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbf5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300a4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb81]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa39]

    ??:? runModuleUnitTests [0x42b9a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    \n \
    \   \n    if(x%n!=0) return false;\n    long t=log(x)/log(n);\n    //if(t-int(t)!=0)\
    \ return false;\n    return (t-int(t))==0;\n    \n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp42ijliax.d(27): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `long`

    /tmp/tmp42ijliax.d(29): Error: cannot implicitly convert expression `t` of type
    `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp42ijliax.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ (x == 1) ? n == 1 : is(n == 1) ? false : x == 0 ? false :\n        ((x > n)\
    \ ? is_simple_power(x / n, n) : (x == n));\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr0i5gxju.d(24): Error: basic type expected, not `1`

    /tmp/tmpr0i5gxju.d(24): Error: found `1` when expecting `)`

    /tmp/tmpr0i5gxju.d(24): Error: found `)` when expecting `;` following `return`
    statement

    /tmp/tmpr0i5gxju.d(24): Error: found `?` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr0i5gxju.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    assert(n\
    \ > 0);\n    assert(x > 0);\n    import std.math : log;\n    long res = cast(long)log(x)\
    \ / log(n);\n    return n ^^ res == x;\n}\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr6_z6li4.d(27): Error: cannot implicitly convert expression `cast(real)cast(long)log(cast(real)x)
    / log(cast(real)n)` of type `real` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr6_z6li4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    /*\n\
    \    if(x == 1L)\n    {\n        return true;\n    }\n    else if(x < 1L)\n  \
    \  {\n        return false;\n    }\n    else\n    {\n        if(n == 1L)\n   \
    \     {\n            return false;\n        }\n        else if(n == 0L)\n    \
    \    {\n            return false;\n        }\n        else\n        {\n      \
    \      if(x % n == 0L)\n            {\n                long newX = x / n;\n  \
    \              if(newX == 1L)\n                {\n                    return true;\n\
    \                }\n                else\n                {\n                \
    \    return is_simple_power(newX, n);\n                }\n            }\n    \
    \        else\n            {\n                return false;\n            }\n \
    \       }\n    }\n    */\n    if(n == 1L)\n    {\n        return x == 1L;\n  \
    \  }\n    else if(n == 0L)\n    {\n        return false;\n    }\n    else\n  \
    \  {\n        auto result = x % n;\n        if(result == 0L)\n        {\n    \
    \        auto newX = x / n;\n            return is_simple_power(newX, n);\n  \
    \      }\n        else\n        {\n            return false;\n        }\n    }\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphf28avkq.d(90): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e4d]

    ??:? void tmphf28avkq.__unittest_L86_C1() [0x427a79]

    ??:? void tmphf28avkq.__modtest() [0x427bd0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9dd]

    ??:? runModuleUnitTests [0x42b949]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ == 1)\n        return false;\n    long result = 1;\n    for(int i = 0; i < 64;\
    \ i++)\n    {\n        result *= n;\n        if(result == x)\n            return\
    \ true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1tv_ogtb.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e4d]

    ??:? void tmp1tv_ogtb.__unittest_L35_C1() [0x427b97]

    ??:? void tmp1tv_ogtb.__modtest() [0x427bd0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9dd]

    ??:? runModuleUnitTests [0x42b949]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1)\n    {\n        return true;\n    }\n    else if (x == 0)\n    {\n   \
    \     return false;\n    }\n    else if (x > 1)\n    {\n        foreach(int i;1...isqrt(x))\n\
    \        {\n            if (n ** i == x)\n            {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpttqy_xzm.d(34): Error: found `...` when expecting `)`

    /tmp/tmpttqy_xzm.d(34): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttqy_xzm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n==1L)\n\
    \        return false;\n    int i=1;\n    long p = n;\n    while(p < x)\n    {\n\
    \        p*=n;\n        if(p==x)\n            return true;\n    }\n    return\
    \ false;\n}\n/*\nimport std.stdio;\nimport std.math;\nimport std.typecons;\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmldvtb33.d(36): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmldvtb33.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // Constraints\n\
    \    assert(0L <= x, \"invalid range for x\");\n    assert(1L <= n, \"invalid\
    \ range for n\");\n    //if x is 0, then it is a power of any number\n    if(x\
    \ == 0)\n        return true;\n    //we cannot use a variable of type int, because\
    \ the variable y may be too big.\n    //for example: y = 2**70 is too big for\
    \ int, because the biggest int is 2**31 - 1\n    long y = 1L;\n    //check if\
    \ any power of n is x. We check powers of n until n**x is larger than x.\n   \
    \ while(y <= x)\n    {\n        //if the power of n is x, then x is a simple power\
    \ of n.\n        if(y == x)\n            return true;\n        //if x is not a\
    \ simple power of n, then check if the next power of n is x.\n        else\n \
    \           y *= n;\n    }\n    //if n**x is larger than x, then x is not a simple\
    \ power of n.\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ res = false;\n    int iter = 0;\n    long val = 1;\n    if (n == 0)\n    {\n\
    \        res = false;\n    }\n    else if (n == 1)\n    {\n        res = false;\n\
    \    }\n    else if (x == 0)\n    {\n        res = false;\n    }\n    else if\
    \ (x == 1)\n    {\n        res = true;\n    }\n    else if (x == 2)\n    {\n \
    \       res = false;\n    }\n    else\n    {\n        do\n        {\n        \
    \    val = val * n;\n            iter++;\n        } while (val < x);\n       \
    \ if (val == x)\n        {\n            res = true;\n        }\n        else\n\
    \        {\n            res = false;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptcgff0a6.d(77): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e95]

    ??:? void tmptcgff0a6.__unittest_L65_C1() [0x427bdb]

    ??:? void tmptcgff0a6.__modtest() [0x427c14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430090]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa25]

    ??:? runModuleUnitTests [0x42b991]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ mod = x % n;\n    long xmod = x / n;\n    if (n == 1) return false;\n    if\
    \ (xmod == 1) return true;\n    if (mod == 0) return is_simple_power(xmod, n);\n\
    \    return false;\n}\n/*\nYour task is to write a function that sorts a list\
    \ of positive integers.\n>>> sort_digits([1,5,7,2,5,2,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqomkrvbm.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqomkrvbm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tbool ret\
    \ = false;\n\t//for (long i = 1; i <= x; i++)\n\t//{\n\t//\tif (pow(n, i) == x)\n\
    \t//\t{\n\t//\t\treturn true;\n\t//\t}\n\t//}\n\t//long total = 1;\n\t//for (long\
    \ i = 1; i <= n; i++)\n\t//{\n\t//\ttotal *= i;\n\t//\tif (total == x)\n\t//\t\
    {\n\t//\t\treturn true;\n\t//\t}\n\t//}\n\t//return false;\n\tTuple!(long, long)\
    \ res = std.math.powmod(n, x);\n\treturn res[0] == 1 && res[1] == 0;\n}\nstatic\
    \ assert(is_simple_power(1L, 4L));\nstatic assert(is_simple_power(2L, 2L));\n\
    static assert(is_simple_power(8L, 2L));\nstatic assert(!is_simple_power(3L, 2L));\n\
    static assert(!is_simple_power(3L, 1L));\nstatic assert(!is_simple_power(5L, 3L));\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp769dgcda.d(42): Error: template `std.math.powmod` cannot deduce
    function from argument types `!()(long, long)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(7505):        `std.math.powmod(F,
    G, H)(F x, G n, H m) if (isUnsigned!F && isUnsigned!G && isUnsigned!H)`

    /tmp/tmp769dgcda.d(45):        called from here: `is_simple_power(1L, 4L)`

    /tmp/tmp769dgcda.d(45):        while evaluating: `static assert(is_simple_power(1L,
    4L))`

    /tmp/tmp769dgcda.d(46): Error: CTFE failed because of previous errors in `is_simple_power`

    /tmp/tmp769dgcda.d(46):        while evaluating: `static assert(is_simple_power(2L,
    2L))`

    /tmp/tmp769dgcda.d(47): Error: CTFE failed because of previous errors in `is_simple_power`

    /tmp/tmp769dgcda.d(47):        while evaluating: `static assert(is_simple_power(8L,
    2L))`

    /tmp/tmp769dgcda.d(48): Error: CTFE failed because of previous errors in `is_simple_power`

    /tmp/tmp769d'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    double\
    \ pow = std.math.pow(n, 1.0);\n    double c = std.math.pow(x, 1.0);\n    if (c\
    \ == pow)\n        return true;\n    else\n        return false;\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2wgq9mih.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2wgq9mih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ ret = false;\n    auto temp = pow(x, 1.0/n);\n    if(float(cast(uint)temp) ==\
    \ temp)\n        ret = true;\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuaf5kmzw.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428a45]

    ??:? void tmpuaf5kmzw.__unittest_L30_C1() [0x427dbd]

    ??:? void tmpuaf5kmzw.__modtest() [0x4287c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c813]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430839]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430ce8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4307c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b67d]

    ??:? runModuleUnitTests [0x42c5e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e94]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x!=1L && (n==1L || x==n) || n==1L && x==1L || n != 1L && x != 1L && n != x &&\
    \ (x % n == 0L) && (is_simple_power(x / n, n));\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpksscz501.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e5d]

    ??:? void tmpksscz501.__unittest_L26_C1() [0x427bcb]

    ??:? void tmpksscz501.__modtest() [0x427be0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430058]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ed]

    ??:? runModuleUnitTests [0x42b959]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // your\
    \ code here\n    if (x == 1) return true;\n    long i = 2;\n    while (n ** i\
    \ < x) i++;\n    return n ** i == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_89sk37i.d(27): Error: can only `*` a pointer, not a `long`

    /tmp/tmp_89sk37i.d(28): Error: can only `*` a pointer, not a `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_89sk37i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ std.math.log(x) / std.math.log(n) == std.math.floor(std.math.log(x) / std.math.log(n));\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpplu96ct7.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x428035]

    ??:? void tmpplu96ct7.__unittest_L26_C1() [0x427d7f]

    ??:? void tmpplu96ct7.__modtest() [0x427db8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bef7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ad8a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff1d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303cc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fea9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ad61]

    ??:? runModuleUnitTests [0x42bccd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428484]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ (log(x)/log(n))%1==0;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwelmwucu.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e95]

    ??:? void tmpwelmwucu.__unittest_L26_C1() [0x427bdb]

    ??:? void tmpwelmwucu.__modtest() [0x427c14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbcf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa62]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbf5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300a4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb81]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa39]

    ??:? runModuleUnitTests [0x42b9a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n==0\
    \ || x==0)\n    {\n        return false;\n    }\n    if (x==1)\n    {\n      \
    \  return true;\n    }\n    //if (n==1)\n    //{\n    //    return true;\n   \
    \ //}\n    if (x<n)\n    {\n        return false;\n    }\n    while (x % n ==\
    \ 0)\n    {\n        x /= n;\n    }\n    if (x==1)\n    {\n        return true;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    \n \
    \   if(n == 0L)\n    {\n        return (x == 1L);\n    }\n    else if(x == 0L)\n\
    \    {\n        return false;\n    }\n    else if(x == 1L)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return cast(bool)(x / n == pow(n, cast(int)(log(x)\
    \ / log(n))));\n    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkf17pqa6.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x427fb5]

    ??:? void tmpkf17pqa6.__unittest_L42_C1() [0x427b49]

    ??:? void tmpkf17pqa6.__modtest() [0x427d38]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bcef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab82]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fd15]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4301c4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fca1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab59]

    ??:? runModuleUnitTests [0x42bac5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428404]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ <= 0 || n <= 0) return false;\n    return !int(log(x) / log(n)) % 1.0;\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgw3lo0u4.d(25): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgw3lo0u4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ log = pow(log(n), -1); // 1 / ln(n)\n    return x != 0 && (x == 1 || log * log(x)\
    \ == round(log * log(x)));\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_yzw7_dw.d(25): Error: function expected before `()`, not `log`
    of type `real`

    /tmp/tmp_yzw7_dw.d(25): Error: function expected before `()`, not `log` of type
    `real`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_yzw7_dw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ tmp = n;\n    while(tmp < x)\n    {\n        tmp *= n;\n    }\n    return (tmp\
    \ == x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpe43vb2fi.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e3d]

    ??:? void tmpe43vb2fi.__unittest_L31_C1() [0x427ba7]

    ??:? void tmpe43vb2fi.__modtest() [0x427bbc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9f6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb89]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430038]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb15]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9cd]

    ??:? runModuleUnitTests [0x42b939]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42828c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tif (n\
    \ <= 0)\n\t\treturn false;\n\tif (n == 1)\n\t\treturn true;\n\tif (x == 0)\n\t\
    \treturn false;\n\tif (x == 1)\n\t\treturn true;\n\t\n\tauto tuple = std.math.frexp(x);\n\
    \tdouble fraction = std.get!0(tuple);\n\tlong exponent = std.get!1(tuple);\n\t\
    \n\treturn (fraction == 1 && exponent != 0 && exponent % n == 0);\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt7xispg4.d(33): Error: template `std.math.frexp` cannot deduce
    function from argument types `!()(long)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(2829):        `std.math.frexp(T)(const
    T value, out int exp) if (isFloatingPoint!T)`

    /tmp/tmpt7xispg4.d(34): Error: undefined identifier `get` in package `std`

    /tmp/tmpt7xispg4.d(35): Error: undefined identifier `get` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt7xispg4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\t//return\
    \ (n > 1 && (log(x) / log(n)) == round(log(x) / log(n)));\n\t/*\n\ta ** b == c\n\
    \tc == log(a) * b\n\t*/\n\treturn n>1&&log(x)/log(n)==round(log(x)/log(n));\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4qq8tnww.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f85]

    ??:? void tmp4qq8tnww.__unittest_L31_C1() [0x427ccb]

    ??:? void tmp4qq8tnww.__modtest() [0x427d04]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bcd7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab6a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcfd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4301ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc89]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab41]

    ??:? runModuleUnitTests [0x42baad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283d4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    int\
    \ i;\n    float pow;\n    if(x == 1)\n    {\n        return true;\n    }\n   \
    \ if(n == 1)\n    {\n        return false;\n    }\n    pow = n;\n    while(pow\
    \ < x)\n    {\n        pow = pow * n;\n    }\n    if(pow == x)\n    {\n      \
    \  return true;\n    }\n    return false;\n}\n//\n// void main()\n// {\n//   \
    \  bool r = is_simple_power(1L, 4L);\n//     r = is_simple_power(2L, 2L);\n//\
    \     r = is_simple_power(8L, 2L);\n//     r = is_simple_power(3L, 2L);\n//  \
    \   r = is_simple_power(3L, 1L);\n//     r = is_simple_power(5L, 3L);\n// }\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tlong result\
    \ = 1;\n\tint pow = 1;\n\twhile (result <= x)\n\t{\n\t\tresult = (long)pow(n,\
    \ pow);\n\t\tif (result == x)\n\t\t\treturn true;\n\t\tpow++;\n\t}\n\treturn false;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp64b4hd8a.d(28): Error: C style cast illegal, use `cast(long)pow(n,
    pow)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp64b4hd8a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ (x != 0 && (isPow(x, n) != -1));\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjzsca0e5.d(24): Error: undefined identifier `isPow`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjzsca0e5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    \n \
    \   \n    if (n == 1L)\n        return false;\n    if (x == 1L)\n        return\
    \ true;\n    if (n == 0L)\n        return true;\n    if (n < 0L)\n        return\
    \ false;\n    if (x < 0L)\n        return false;\n    \n    if (n == x)\n    \
    \    return true;\n    if (n == 2L)\n        return isPowerOfTwo(x);\n    if (n\
    \ == 3L)\n        return isPowerOfThree(x);\n    if (n == 4L)\n        return\
    \ isPowerOfFour(x);\n    if (n == 5L)\n        return isPowerOfFive(x);\n    if\
    \ (n == 6L)\n        return isPowerOfSix(x);\n    if (n == 7L)\n        return\
    \ isPowerOfSeven(x);\n    if (n == 8L)\n        return isPowerOfEight(x);\n  \
    \  if (n == 9L)\n        return isPowerOfNine(x);\n    if (n == 10L)\n       \
    \ return isPowerOfTen(x);\n    \n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwp7yt8k7.d(40): Error: undefined identifier `isPowerOfTwo`

    /tmp/tmpwp7yt8k7.d(42): Error: undefined identifier `isPowerOfThree`

    /tmp/tmpwp7yt8k7.d(44): Error: undefined identifier `isPowerOfFour`

    /tmp/tmpwp7yt8k7.d(46): Error: undefined identifier `isPowerOfFive`

    /tmp/tmpwp7yt8k7.d(48): Error: undefined identifier `isPowerOfSix`

    /tmp/tmpwp7yt8k7.d(50): Error: undefined identifier `isPowerOfSeven`

    /tmp/tmpwp7yt8k7.d(52): Error: undefined identifier `isPowerOfEight`

    /tmp/tmpwp7yt8k7.d(54): Error: undefined identifier `isPowerOfNine`

    /tmp/tmpwp7yt8k7.d(56): Error: undefined identifier `isPowerOfTen`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwp7yt8k7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ res = x/n;\n    if (res*n == x)\n    {\n        if (isPow(res, n))\n       \
    \     return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdmo2lgs_.d(27): Error: undefined identifier `isPow`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdmo2lgs_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 1 && n != 0)\n        return true;\n    \n    if(n == 0 && x != 1)\n    \
    \    return false;\n        \n    if(n == 0 && x == 1)\n        return true;\n\
    \    \n    long k = 1;\n    while(k * n <= x)\n    {\n        if(k * n == x)\n\
    \            return true;\n        k++;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg9zk3_ko.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e75]

    ??:? void tmpg9zk3_ko.__unittest_L42_C1() [0x427b55]

    ??:? void tmpg9zk3_ko.__modtest() [0x427bf8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430070]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa05]

    ??:? runModuleUnitTests [0x42b971]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n<0\
    \ or x<0) return false;\n    if(n==0) return false;\n    if(n==1) return true;\n\
    \    long int xc = cast(long) log(x);\n    long int yc = cast(long) log(n);\n\
    \    return (xc/yc==xc/yc.to!double);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprmtjfdlq.d(24): Error: found `or` when expecting `)`

    /tmp/tmprmtjfdlq.d(24): Error: found `)` when expecting `;` following statement

    /tmp/tmprmtjfdlq.d(27): Error: no identifier for declarator `long`

    /tmp/tmprmtjfdlq.d(28): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprmtjfdlq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0) return false;\n    if (x == 1) return true;\n    if (x % n == 0)\n   \
    \ {\n        long temp = x / n;\n        //math.sqrt(n)\n        if (std.typecons.is(temp,\
    \ long) || temp == 1) return true;\n        else return false;\n    }\n    else\
    \ return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu4ahh2rz.d(30): Error: identifier expected following `.`, not `is`

    /tmp/tmpu4ahh2rz.d(30): Error: found `)` when expecting `.` following long

    /tmp/tmpu4ahh2rz.d(30): Error: found `||` when expecting identifier following
    `long`.

    /tmp/tmpu4ahh2rz.d(30): Error: found `temp` when expecting `,`

    /tmp/tmpu4ahh2rz.d(30): Error: expression expected, not `==`

    /tmp/tmpu4ahh2rz.d(30): Error: found `1` when expecting `,`

    /tmp/tmpu4ahh2rz.d(30): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu4ahh2rz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    // can\
    \ we take the root?\n    static assert(isIntegral!(int), \"int is not an integral\
    \ type!\");\n    static assert(is(typeof(pow(1,1))==long), \"pow() returns another\
    \ type!\");\n    if (n == 0) return false;\n    if (x == 1) return true;\n   \
    \ int y = log(x) / log(n);\n    return pow(n, y) == x;\n}\n//void main() {}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv5y1iqux.d(25): Error: template instance `isIntegral!int` template
    `isIntegral` is not defined

    /tmp/tmpv5y1iqux.d(25):        while evaluating: `static assert(isIntegral!int)`

    /tmp/tmpv5y1iqux.d(26): Error: static assert:  "pow() returns another type!"

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv5y1iqux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ <= 0 || n <= 0)\n        return false;\n    else if (x == 1)\n        return\
    \ true;\n    else if (n == 1)\n        return false;\n    while (x % n == 0)\n\
    \    {\n        x /= n;\n        if (x == 1)\n            return true;\n    }\n\
    \    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ isPow(n, x);\n}\n \nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8xdli26k.d(24): Error: undefined identifier `isPow`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8xdli26k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 0) return false;\n    if (n == 0) return true;\n    long pow = 1;\n    int\
    \ i = 0;\n    do {\n        i++;\n        pow *= n;\n    } while (pow < x);\n\
    \    return pow == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzv16yio3.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e55]

    ??:? void tmpzv16yio3.__unittest_L34_C1() [0x427bc3]

    ??:? void tmpzv16yio3.__modtest() [0x427bd8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430050]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9e5]

    ??:? runModuleUnitTests [0x42b951]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163954
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x==1)\n\
    \        return true;\n    if (n == 1)\n        return false;\n    while(true)\n\
    \    {\n        if (x%n == 0)\n        {\n            if (x/n == n)\n        \
    \        return true;\n            x = x/n;\n        }\n        else\n       \
    \     return false;\n    }\n}\n \nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163954
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tif(x ==\
    \ 1)\n\t\treturn true;\n\tif(n == 1)\n\t\treturn false;\n\twhile(true)\n\t{\n\t\
    \tif(x % n != 0)\n\t\t\treturn false;\n\t\tx /= n;\n\t\tif(x == 1)\n\t\t\treturn\
    \ true;\n\t}\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0L)\n        return false;\n    long is_power = std.math.pow(n, std.math.log(x)/std.math.log(n));\n\
    \    return is_power == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx_y9wpqt.d(26): Error: cannot implicitly convert expression `pow(n,
    log(cast(real)x) / log(cast(real)n))` of type `real` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_y9wpqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    //return(x\
    \ & (x - 1)) == 0;\n    return(x%n == 0 && log2(x/n) == int(log2(x/n)));\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpcjne9b.d(25): Error: cannot implicitly convert expression `log2(cast(real)(x
    / n))` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpcjne9b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ result = false;\n    if (n == 1L)\n    {\n        if (x == 1L)\n        {\n\
    \            result = true;\n        }\n    }\n    else if (n > 1L)\n    {\n \
    \       double power = std.math.log(x)/std.math.log(n);\n        if (power ==\
    \ (long)power)\n        {\n            result = true;\n        }\n    }\n    return\
    \ result;\n}\n/*\nYou should implement a function that takes a string as an argument\
    \ and\n    calculates the length of the longest substring which consists of only\n\
    \    distinct characters.\n    >>> \"aa\"\n    1\n    >>> \"aaa\"\n    1\n   \
    \ >>> \"abcabcbb\"\n    3\n    >>> \"abcabcabcd\"\n    4\n    >>> \"bbbbb\"\n\
    \    1\n    >>> \"pwwkew\"\n    3\n    >>> \"c\"\n    1\n    >>> \"dvdf\"\n  \
    \  3\n*/\nsize_t length_of_longest_substring(string str) \n{\n    auto maxLen\
    \ = 0;\n    auto curLen = 0;\n    auto pos = 0;\n    for (size_t i = 0; i < str.length;\
    \ i++)\n    {\n        auto found = false;\n        for (size_t j = pos; j < i;\
    \ j++)\n        {\n            if (str[i] == str[j])\n            {\n        \
    \        found = true;\n                pos = j + 1;\n                break;\n\
    \            }\n        }\n        if (!found)\n        {\n            curLen++;\n\
    \        }\n        else\n        {\n            if (curLen > maxLen)\n      \
    \      {\n                maxLen = curLen;\n            }\n            curLen\
    \ = i - pos + 1;\n        }\n    }\n    if (curLen > maxLen)\n    {\n        maxLen\
    \ = curLen;\n    }\n    return maxLen;\n}\n/*\nGiven a positive integer n, find\
    \ the number of integers in the range 1..n\n    (inclusive) which have exactly\
    \ 4 divisors.\n    Note: the function should return 0 for the edge case n = 1\
    \ (\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbmwxrltf.d(35): Error: C style cast illegal, use `cast(long)power`

    /tmp/tmpbmwxrltf.d(99): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbmwxrltf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163953
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\treturn(!(1L\
    \ % n) && !(x % pow(n, int(log(x) / log(n)))));\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkfkejt8y.d(24): Error: cannot implicitly convert expression `log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkfkejt8y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163954
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ n>0 && n <= x && x%n==0 ? is_simple_power(x/n, n) : x==1;\n}\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660163969
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    auto\
    \ p = pow(n, cast(double)log(x) / log(n));\n    return p - cast(long)p == 0;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqnczb3b6.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ab5]

    ??:? void tmpqnczb3b6.__unittest_L27_C1() [0x427e79]

    ??:? void tmpqnczb3b6.__modtest() [0x428834]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c897]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b72a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430849]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b701]

    ??:? runModuleUnitTests [0x42c66d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428f04]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 0) \n        return false;\n    if (n == 0) \n        return false;\n   \
    \ if (x == 1) \n        return true;\n    if (n == 1) \n        return false;\n\
    \    if (x == n) \n        return true;\n    if (x < n) \n        return false;\n\
    \    bool result = false;\n    int count = 0;\n    //printf(\"x=%ld, n=%ld\\n\"\
    , x, n);\n    for (; n < x; n += n) \n    {\n        ++count;\n        //printf(\"\
    n=%ld\\n\", n);\n        if (n == x) \n        {\n            result = true;\n\
    \            break;\n        }\n    }\n    //printf(\"count = %d\\n\", count);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiz1jv2c0.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ead]

    ??:? void tmpiz1jv2c0.__unittest_L52_C1() [0x427ad9]

    ??:? void tmpiz1jv2c0.__modtest() [0x427c30]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbd3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbf9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300a8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb85]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa3d]

    ??:? runModuleUnitTests [0x42b9a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163954
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 0 && n != 0) return false;\n    if (x == 0 && n == 0) return true;\n    if\
    \ (n == 0) return false;\n    if (x == 1) return true;\n    if (n == 1) return\
    \ false;\n    if (n == x) return true;\n    long result = n;\n    for (; result\
    \ <= x;)\n    {\n        if (result == x) return true;\n        result *= n;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163954
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x == 0 ? false : x == 1 ? true : x % n == 0 ? is_simple_power(x / n, n) : false;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ (x == 1) ? n == 1 : (x > 1) ? (((long)(log(x) / log(n))) == (log(x) / log(n)))\
    \ ? pow(n, log(x) / log(n)) == x : false : false;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkc9pvtf_.d(24): Error: C style cast illegal, use `cast(long)(log(x)
    / log(n))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkc9pvtf_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    //check\
    \ if x is a simple power of n\n    if(n == 1)\n        return false;\n    float\
    \ res = log(x) / log(n);\n    return(res == cast(long)res);\n}\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp46_yszvl.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ead]

    ??:? void tmp46_yszvl.__unittest_L30_C1() [0x427bf7]

    ??:? void tmp46_yszvl.__modtest() [0x427c30]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbe7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa7a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc0d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300bc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb99]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa51]

    ??:? runModuleUnitTests [0x42b9bd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 0) return false;\n    if(n == 0) return false;\n    if(x == 1) return true;\n\
    \    if(n == 1) return true;\n    int counter = 0;\n    while(n <= x)\n    {\n\
    \        n *= n;\n        counter++;\n    }\n    return counter == 1;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt5cidgf2.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e65]

    ??:? void tmpt5cidgf2.__unittest_L36_C1() [0x427a91]

    ??:? void tmpt5cidgf2.__modtest() [0x427be8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430060]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9f5]

    ??:? runModuleUnitTests [0x42b961]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n==1)\
    \ return false;\n    if(x==1) return true;\n    int temp = 0;\n    while(x>1)\n\
    \    {\n        if(x%n==0)\n        {\n            x=x/n;\n            temp++;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    if(temp==1) return true;\n    else return false;\n}\nunittest\n{\n \
    \   alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnmdtvf8p.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e65]

    ??:? void tmpnmdtvf8p.__unittest_L42_C1() [0x427a91]

    ??:? void tmpnmdtvf8p.__modtest() [0x427be8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430060]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9f5]

    ??:? runModuleUnitTests [0x42b961]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163954
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 1) return true;\n    while(x > 1)\n    {\n        if(x % n != 0)\n      \
    \      return false;\n        x /= n;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x == long.pow(n, cast(int)std.math.log(x) / std.math.log(n));\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6ec7wni.d(24): Error: cannot pass type `long` as a function argument

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6ec7wni.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 1L && n == 1L)\n        return true;\n    else if(x == 1L)\n        return\
    \ false;\n    else if(n == 1L)\n        return false;\n    auto power = (long)log(x)\
    \ / log(n);\n    return pow(n, power) == x;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpajd6x7jo.d(30): Error: C style cast illegal, use `cast(long)log(x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajd6x7jo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n\
    \ == 1 && x == n)\n        return true;\n    if(x < n)\n        return false;\n\
    \    int m = cast(int)log(x)/log(n);\n    if(pow(n, m) == x)\n        return true;\n\
    \    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1m_106e.d(28): Error: cannot implicitly convert expression `cast(real)cast(int)log(cast(real)x)
    / log(cast(real)n)` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1m_106e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ !(x < 1 || n < 1) && x == n ** cast(int) cast(log)(x) / cast(log)(n);\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxna97f38.d(24): Error: function `std.math.log` is used as a type

    /tmp/tmpxna97f38.d(24): Error: function `std.math.log` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxna97f38.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    double\
    \ x_ = x;\n    double n_ = n;\n    return cast(double)round(log(x_) / log(n_))\
    \ == log(x_) / log(n_);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbc4dj26y.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f85]

    ??:? void tmpbc4dj26y.__unittest_L28_C1() [0x427ccb]

    ??:? void tmpbc4dj26y.__modtest() [0x427d04]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bcd7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab6a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcfd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4301ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc89]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ab41]

    ??:? runModuleUnitTests [0x42baad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283d4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163954
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    double\
    \ nn = n;\n    double xx = x;\n    double r = log(xx) / log(nn);\n    if (r !=\
    \ cast(long)r) return false;\n    return r == cast(long)r;\n}\nunittest\n{\n \
    \   alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfbui42rm.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ed5]

    ??:? void tmpfbui42rm.__unittest_L30_C1() [0x427c1b]

    ??:? void tmpfbui42rm.__modtest() [0x427c54]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc0f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aaa2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc35]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbc1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa79]

    ??:? runModuleUnitTests [0x42b9e5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428324]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163954
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tint t\
    \ = 1;\n\tif (x == 1)\n\t\treturn true;\n\telse\n\t{\n\t\twhile (x != n)\n\t\t\
    {\n\t\t\tn *= n;\n\t\t\tif (n > x)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\
    \t}\n\t\t\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163954
