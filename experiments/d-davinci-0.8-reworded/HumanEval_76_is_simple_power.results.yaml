name: HumanEval_76_is_simple_power
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 1L)\n        return x == 1L;\n    if (x == 0L)\n        return false;\n \
    \   if (x == 1L)\n        return true;\n    if (n == 0L)\n        return x ==\
    \ 0L;\n    if (n == 2L)\n        return true;\n    if (n % 2 == 0L)\n        return\
    \ false;\n    for (long i = 3L; i <= n; i += 2L)\n    {\n        if (x % i ==\
    \ 0L)\n            return false;\n    }\n    return (x % n == 0L) && is_simple_power(x\
    \ / n, n);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplejdugzo.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ec5]\\n??:? void tmplejdugzo.__unittest_L43_C1()\
    \ [0x427b59]\\n??:? void tmplejdugzo.__modtest() [0x427c44]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bbeb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc11]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4300c0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb9d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa55]\\n??:? runModuleUnitTests [0x42b9c1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428314]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42829b]\\n??:? _d_run_main [0x428206]\\n??:? main [0x427c57]\\\
    n??:? __libc_start_main [0xf3474554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ < 1)\n        return false;\n    if (n == 1)\n        return x == 1;\n    if\
    \ (n == 0)\n        return x == 0;\n    if (x == 1)\n        return true;\n  \
    \  if (n == 1)\n        return false;\n    long exponent = 1;\n    long temp =\
    \ n;\n    while (temp * n <= x)\n    {\n        temp *= n;\n        exponent++;\n\
    \    }\n    return temp == x;\n}\n/*\n Your task is to write a function that returns\
    \ true if a number x is a power of n and false in other cases.\n    x is a power\
    \ of n if n**i=x, where i is a natural number\n    For example:\n    >>> is_power(1L,\
    \ 4L)\n    true\n    >>> is_power(2L, 2L)\n    true\n    >>> is_power(8L, 2L)\n\
    \    true\n    >>> is_power(3L, 2L)\n    false\n    >>> is_power(3L, 1L)\n   \
    \ false\n    >>> is_power(5L, 3L)\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x==1)\
    \ return true;\n    if(n==1) return false;\n    if(x==n) return true;\n    return\
    \ is_simple_power(x, cast(long)log(cast(real)x)/log(cast(real)n));\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbd9pdvkv.d(27): Error: function `tmpbd9pdvkv.is_simple_power(long\
    \ x, long n)` is not callable using argument types `(long, real)`\\n/tmp/tmpbd9pdvkv.d(27):\
    \        cannot pass argument `cast(real)cast(long)log(cast(real)x) / log(cast(real)n)`\
    \ of type `real` to parameter `long n`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpbd9pdvkv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    bool\
    \ res;\n    long result=0;\n    if( x==1L || x==n )\n    {\n        res=true;\n\
    \    }\n    else\n    {\n        result=log2(x)/log2(n);\n        res= ( n**result\
    \ == x) ? true : false;\n    }\n    return res;\n}\n \n \n/*\n    https://www.daniweb.com/programming/software-development/threads/252679/c-program-to-check-whether-a-number-is-a-power-of-another\n\
    \    http://stackoverflow.com/questions/101439/the-most-efficient-way-to-implement-an-integer-based-power-function-powint-int\n\
    \    http://stackoverflow.com/questions/10030783/fast-and-elegant-integer-power-function-in-c-c\n\
    */\n \n \nlong power(long n,long p)\n{\n    long res;\n    res=pow(n,p);\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjkux5xue.d(32): Error: cannot implicitly convert expression `log2(cast(real)x)\
    \ / log2(cast(real)n)` of type `real` to `long`\\n/tmp/tmpjkux5xue.d(33): Error:\
    \ can only `*` a pointer, not a `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpjkux5xue.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    const\
    \ double xt = x;\n    const double nt = n;\n    const double num = log(xt) / log(nt);\n\
    \    const uint numi = num;\n    const double numt = numi;\n    return numt ==\
    \ num;\n}\nstatic assert(is_simple_power(1L, 4L));\nstatic assert(is_simple_power(2L,\
    \ 2L));\nstatic assert(is_simple_power(8L, 2L));\nstatic assert(!is_simple_power(3L,\
    \ 2L));\nstatic assert(!is_simple_power(3L, 1L));\nstatic assert(!is_simple_power(5L,\
    \ 3L));\n/*\nfrom std.typecons:\n    auto tup(T1)(T1 x1) { return tuple(x1); }\n\
    \    auto tup(T1, T2)(T1 x1, T2 x2) { return tuple(x1, x2); }\n    auto tup(T1,\
    \ T2, T3)(T1 x1, T2 x2, T3 x3) { return tuple(x1, x2, x3); }\n    auto tup(T1,\
    \ T2, T3, T4)(T1 x1, T2 x2, T3 x3, T4 x4) { return tuple(x1, x2, x3, x4); }\n\
    \    auto tup(T1, T2, T3, T4, T5)(T1 x1, T2 x2, T3 x3, T4 x4, T5 x5) { return\
    \ tuple(x1, x2, x3, x4, x5); }\n    auto tup(T1, T2, T3, T4, T5, T6)(T1 x1, T2\
    \ x2, T3 x3, T4 x4, T5 x5, T6 x6) { return tuple(x1, x2, x3, x4, x5, x6); }\n\
    \    auto tup(T1, T2, T3, T4, T5, T6, T7)(T1 x1, T2 x2, T3 x3, T\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi8xxm74g.d(37): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi8xxm74g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    immutable\
    \ long num = x;\n    immutable long pow = n;\n    return x != 0 && n != 0 && num\
    \ != 1 ? x != 1 && n != 1 && pow != 1 ? num % n == 0 ? x % n == 0 ? log(num) /\
    \ log(n) % 1 == 0 ? true : false : false : false : false : false;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphzjg985f.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f0d]\\n??:? void tmphzjg985f.__unittest_L28_C1()\
    \ [0x427c53]\\n??:? void tmphzjg985f.__modtest() [0x427c8c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc47]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aada]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc6d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43011c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fbf9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aab1]\\n??:? runModuleUnitTests [0x42ba1d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42835c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282e3]\\n??:? _d_run_main [0x42824e]\\n??:? main [0x427c9f]\\\
    n??:? __libc_start_main [0xc3b87554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x > 0 && (x==1 || (n != 1 && x % n == 0 && is_simple_power(x/n, n)));\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ x==1?true:is_simple_power(x,n, 1);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9qhtygsa.d(24): Error: function `tmp9qhtygsa.is_simple_power(long\
    \ x, long n)` is not callable using argument types `(long, long, int)`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9qhtygsa.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\t \n\t\
    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnng038wp.d(31): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e05]\\n??:? void tmpnng038wp.__unittest_L27_C1()\
    \ [0x427a31]\\n??:? void tmpnng038wp.__modtest() [0x427b88]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb2b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9be]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb51]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430000]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fadd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a995]\\n??:? runModuleUnitTests [0x42b901]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428254]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281db]\\n??:? _d_run_main [0x428146]\\n??:? main [0x427b9b]\\\
    n??:? __libc_start_main [0x1d1b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(x\
    \ == 1)\n        return true;\n    else if(x == 0 || n == 0)\n        return false;\n\
    \    else if(n == 1)\n        return false;\n    else\n    {\n        bool res\
    \ = false;\n        double result = 1;\n        for(long i = 0; i <= x; i++)\n\
    \        {\n            result = pow(n, i);\n            if(result == x)\n   \
    \         {\n                res = true;\n                break;\n           \
    \ }\n        }\n        return res;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if(n==0L)return\
    \ x==1L;\n    if(n==1L)return x==1L;\n    while(true)\n    {\n        auto r =\
    \ x % n;\n        if(r == 0L)\n        {\n            x = x / n;\n           \
    \ if(x == 1L)\n                return true;\n        }\n        else\n       \
    \     return false;\n    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpa8y1fzry.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e5d]\\n??:? void tmpa8y1fzry.__unittest_L39_C1()\
    \ [0x427bc7]\\n??:? void tmpa8y1fzry.__modtest() [0x427bdc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fba9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9ed]\\n??:? runModuleUnitTests [0x42b959]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428233]\\n??:? _d_run_main [0x42819e]\\n??:? main [0x427bef]\\\
    n??:? __libc_start_main [0x85363554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\treturn\
    \ x == (long)pow(n,(int)log(x)/(int)log(n));\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyl7s_uqa.d(24): Error: C style cast illegal, use `cast(int)log(x)`\\\
    n/tmp/tmpyl7s_uqa.d(24): Error: C style cast illegal, use `cast(int)log(n)`\\\
    n/tmp/tmpyl7s_uqa.d(24): Error: C style cast illegal, use `cast(long)pow(n, cast(int)log(x)\
    \ / cast(int)log(n))`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyl7s_uqa.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    immutable\
    \ int_ = (int)log(x) / log(n);\n    return pow(n, int_) == x;\n}\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmpfgp5qm.d(24): Error: C style cast illegal, use `cast(int)log(x)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpfgp5qm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n\tdouble\
    \ result = log(x)/log(n);\n\tif(result == int(result)){\n\t\treturn true;\n\t\
    }\n\treturn false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp126ugx3h.d(25): Error: cannot implicitly convert expression `result`\
    \ of type `double` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp126ugx3h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (\
    \ x == 1 || x == n)\n    {\n        return true;\n    }\n    else if (x < n)\n\
    \    {\n        return false;\n    }\n    else\n    {\n        bool retVal = false;\n\
    \        bool loopFlag = true;\n        int i = 2;\n        while (loopFlag)\n\
    \        {\n            if ( (n ** i) == x)\n            {\n                retVal\
    \ = true;\n                loopFlag = false;\n            }\n            else\
    \ if ( (n ** i) > x)\n            {\n                loopFlag = false;\n     \
    \       }\n            else\n            {\n                i++;\n           \
    \ }\n        }\n        return retVal;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5ekwa8m2.d(39): Error: can only `*` a pointer, not a `int`\\\
    n/tmp/tmp5ekwa8m2.d(44): Error: can only `*` a pointer, not a `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ekwa8m2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    enum\
    \ x = x;\n    enum n = n;\n    if(n == 1 && x == 1)\n        return true;\n  \
    \  if(n > x)\n        return false;\n    long left = n;\n    long right = x;\n\
    \    while(left < right)\n    {\n        left *= n;\n        if(left == right)\n\
    \            return true;\n    }\n    return false;\n}\n/*\nYou have a lot of\
    \ apples (1.5 kg) and you want to distribute them among a number of your colleagues.\n\
    \    The only condition is that the colleague with the smallest number of apples\
    \ is at least three times less than the colleague with the largest number of apples.\n\
    \    Your task is to find such a number of colleagues. If there is no such number\
    \ return 0.\n    >>> distribute_apples(1.5)\n    2\n    >>> distribute_apples(9)\n\
    \    3\n    >>> distribute_apples(6)\n    3\n    >>> distribute_apples(0)\n  \
    \  0\n    >>> distribute_apples(2)\n    0\n    >>> distribute_apples(11)\n   \
    \ 5\n    >>> distribute_apples(24)\n    10\n    >>> distribute_apples(80)\n  \
    \  28\n    >>> distribute_apples(103)\n    31\n    >>> distribute_apples(30)\n\
    \    10\n    >>> distribute_apples(102)\n    31\n    >>> distribute_apples(9.5)\n\
    \    3\n    >>> distribute_apples(24.5)\n    10\n*/\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzxwyn276.d(24): Error: variable `x` cannot be read at compile\
    \ time\\n/tmp/tmpzxwyn276.d(24): Error: variable `x` is shadowing variable `tmpzxwyn276.is_simple_power.x`\\\
    n/tmp/tmpzxwyn276.d(25): Error: variable `n` cannot be read at compile time\\\
    n/tmp/tmpzxwyn276.d(25): Error: variable `n` is shadowing variable `tmpzxwyn276.is_simple_power.n`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzxwyn276.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ nn = long.abs(n);\n    long xx = long.abs(x);\n    if (nn == 0)\n        return\
    \ xx == 1;\n    if (xx < 1)\n        return false;\n    long i = 1;\n    long\
    \ pow = nn;\n    long last_pow = pow;\n    while (pow <= xx)\n    {\n        if\
    \ (pow == xx)\n            return true;\n        last_pow = pow;\n        pow\
    \ *= nn;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5m1hnpm4.d(24): Error: cannot pass type `long` as a function\
    \ argument\\n/tmp/tmp5m1hnpm4.d(25): Error: cannot pass type `long` as a function\
    \ argument\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5m1hnpm4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n  //x=n**i\n\
    \  //i=log(x)/log(n)\n  static long double log_n=log(n);\n  long double log_x=log(x);\n\
    \  long double i=log_x/log_n;\n  if (i==(long long)i && i>0)\n    return true;\n\
    \  return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n \
    \   assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbmml7bqm.d(26): Error: use `real` instead of `long double`\\\
    n/tmp/tmpbmml7bqm.d(27): Error: use `real` instead of `long double`\\n/tmp/tmpbmml7bqm.d(28):\
    \ Error: use `real` instead of `long double`\\n/tmp/tmpbmml7bqm.d(29): Error:\
    \ found `long` when expecting `.` following long\\n/tmp/tmpbmml7bqm.d(29): Error:\
    \ found `)` when expecting identifier following `long`.\\n/tmp/tmpbmml7bqm.d(29):\
    \ Error: found `i` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpbmml7bqm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    return\
    \ n == 1 || x == n || (x > 1 && x % n == 0 && is_simple_power(x / n, n));\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_9mr0f1v.d(39): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e45]\\n??:? void tmp_9mr0f1v.__unittest_L26_C1()\
    \ [0x427baf]\\n??:? void tmp_9mr0f1v.__modtest() [0x427bc4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb6b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9fe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb91]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430040]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb1d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9d5]\\n??:? runModuleUnitTests [0x42b941]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428294]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42821b]\\n??:? _d_run_main [0x428186]\\n??:? main [0x427bd7]\\\
    n??:? __libc_start_main [0x45ca8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    int\
    \ p = 1;\n    long r = 1;\n    while (r < x)\n    {\n        p++;\n        r =\
    \ power(n, p);\n    }\n    return (r == x) ? true : false;\n}\nunittest\n{\n \
    \   alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjzlwx69h.d(29): Error: undefined identifier `power`, did you\
    \ mean template `pow(F, G)(F x, G n) if (isFloatingPoint!F && isIntegral!G)`?\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjzlwx69h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
