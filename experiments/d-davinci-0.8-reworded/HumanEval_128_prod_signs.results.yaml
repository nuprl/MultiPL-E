language: d
name: HumanEval_128_prod_signs
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n  \
    \      auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppz1eypwr.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz1eypwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    //write your\
    \ code here\n    auto signs = arr.map!(x => sign(x));\n    auto total = 1L;\n\
    \    foreach(num; signs)\n    {\n        total *= num;\n    }\n    if(total !=\
    \ 0)\n    {\n        return arr.map!(abs).sum * total;\n    }\n    else\n    {\n\
    \        return null;\n    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgliv4qka.d(22): Error: no property `map` for type `long[]`

    /tmp/tmpgliv4qka.d(30): Error: no property `map` for type `long[]`

    /tmp/tmpgliv4qka.d(34): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgliv4qka.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n  \
    \      auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppz1eypwr.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz1eypwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long prod_signs\
    \ = 1L;\n        long magn = 0L;\n        foreach (num; arr) \n        {\n   \
    \         magn += abs(num);\n            prod_signs *= sign(num);\n        }\n\
    \        return nullable(magn * prod_signs);\n    }\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo2wruyeh.d(32): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpo2wruyeh.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo2wruyeh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \nin\n{\n    assert(arr.length\
    \ < 100);\n}\nout(result)\n{\n    assert(result is null || (result >= 0L && result\
    \ <= 300L));\n}\nbody\n{\n    if (arr.length == 0)\n        return Nullable!(long).init;\n\
    \    long sum = 0L;\n    long sign = 1L;\n    foreach (elem; arr)\n    {\n   \
    \     sign *= elem >= 0L ? 1L : -1L;\n        sum += abs(elem);\n    }\n    return\
    \ sum * sign;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4746ls6m.d(39): Error: cannot implicitly convert expression `sum
    * sign` of type `long` to `Nullable!long`

    /tmp/tmp4746ls6m.d(26): Error: incompatible types for `(result) is (null)`: `const(Nullable!long)`
    and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4746ls6m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long total\
    \ = 0;\n    long sign = 1;\n    foreach(long i; arr) \n    {\n        if (i >\
    \ 0) \n        {\n            sign *= 1;\n        } \n        else if (i < 0)\
    \ \n        {\n            sign *= -1;\n        } \n        else \n        {\n\
    \            sign = 0;\n        }\n        total += i.abs;\n    }\n    return\
    \ sign ? total * sign : null;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzirhjbj_.d(39): Error: incompatible types for `(total * sign) :
    (null)`: `long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzirhjbj_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long signs\
    \ = 1L;\n    long magnitude = 0L;\n    foreach(i; arr) \n    {\n        if(i >\
    \ 0) \n        {\n            signs *= 1L;\n            magnitude += i;\n    \
    \    } \n        else if(i < 0) \n        {\n            signs *= -1L;\n     \
    \       magnitude += -i;\n        } \n        else \n        {\n            signs\
    \ *= 0L;\n        }\n    }\n    if(signs == 0L) \n    {\n        return Nullable!(long)(0L);\n\
    \    }\n    return Nullable!(long)(magnitude * signs);\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq3ka77q7.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x455b79]

    ??:? void tmpq3ka77q7.__unittest_L46_C1() [0x4419b7]

    ??:? void tmpq3ka77q7.__modtest() [0x453684]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45eb7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4551a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45a3bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45a44c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45a349]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x45517d]

    ??:? runModuleUnitTests [0x45e951]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x456b04]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    auto signs\
    \ = arr.map!(a => sign(a));\n    auto magnitudes = arr.map!(a => abs(a));\n  \
    \  return magnitudes.sum * product(signs);\n}\n \n/*\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0hyumzd3.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hyumzd3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    return arr.length\
    \ == 0 \n                ? null \n                : arr.map!((l) => l > 0 ? l\
    \ : abs(l)).product \n                * arr.map!((l) => l == 0 ? 0 : (l > 0 ?\
    \ 1 : -1)).product;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n\
    \        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt_5a1a3s.d(23): Error: no property `map` for type `long[]`

    /tmp/tmpt_5a1a3s.d(24): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_5a1a3s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long[] signs\
    \ = arr.map!((x) => x < 0 ? -1L : x > 0 ? 1L : 0L)();\n    return arr.empty ?\
    \ null : signs.product * signs.map!(abs).sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg36v4p3g.d(21): Error: no property `map` for type `long[]`

    /tmp/tmpg36v4p3g.d(22): Error: no property `empty` for type `long[]`

    /tmp/tmpg36v4p3g.d(22): Error: no property `product` for type `long[]`

    /tmp/tmpg36v4p3g.d(22): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg36v4p3g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (a; arr)\n\
    \    {\n        sum += abs(a);\n        prod *= sign(a);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp59dxwmwb.d(27): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmp59dxwmwb.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmp59dxwmwb.d(29): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp59dxwmwb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n\tif (arr.length\
    \ == 0) return null;\n\tint prod = 1;\n\tlong sum = 0;\n\tforeach (i; arr)\n\t\
    {\n\t\tsum += abs(i);\n\t\tprod *= sign(i);\n\t}\n\treturn make!(Nullable)(sum\
    \ * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsz7dqypv.d(27): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpsz7dqypv.d(29): Error: template instance `make!Nullable` template `make`
    is not defined, did you mean main?

    /tmp/tmpsz7dqypv.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsz7dqypv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long num\
    \ = 1;\n    long den = 1;\n    if (arr.length == 0)\n        return null;\n  \
    \  foreach (long n; arr)\n    {\n        num *= n;\n        den *= (n == 0) ?\
    \ 1 : (n < 0) ? -1 : 1;\n    }\n    return num * den;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xg1z2ab.d(24): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp7xg1z2ab.d(30): Error: cannot implicitly convert expression `num * den`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xg1z2ab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    int prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            continue;\n    \
    \    sum += abs(i);\n    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmn_com1y.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmn_com1y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    else\n    {\n        size_t t = arr.length;\n\
    \        long result = 1L;\n        for (size_t i = 0; i < t; i++)\n        {\n\
    \            auto number = arr[i];\n            if (number > 0)\n            \
    \    result *= 1L;\n            else if (number < 0)\n                result *=\
    \ -1L;\n            else\n                result *= 0L;\n        }\n        return\
    \ result;\n    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n   \
    \     auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoj177y_o.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpoj177y_o.d(37): Error: cannot implicitly convert expression `result` of
    type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoj177y_o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \nin {\n    assert(arr.length\
    \ > 0);\n} \nout(result) \n{\n    assert(result is null || result >= 0);\n}\n\
    body {\n    if (arr.length > 0) {\n        long res = 1;\n        long prod =\
    \ 1;\n        foreach (l; arr) {\n            res += abs(l);\n            prod\
    \ *= sign(l);\n        }\n        return check(res * prod);\n    }\n    return\
    \ null;\n}\n \n/*\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n     \
    \   auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3jdxticd.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3jdxticd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n    return reduce!\"\
    a + b\"(map!\"abs(a) * b\"(arr, 1L), 0L);\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9xsls78_.d(21): Error: template instance `reduce!"a + b"` template
    `reduce` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xsls78_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // setup\
    \ variables to calculate our final value\n    long product = 1L;\n    long sum\
    \ = 0L;\n    long zero_count = 0L;\n    //loop over input array and do work to\
    \ setup final variables\n    foreach(num; arr)\n    {\n        //check if 0\n\
    \        if(num == 0L)\n        {\n            zero_count += 1L;\n        }\n\
    \        //check if negative and multiply by -1\n        else if(num < 0L)\n \
    \       {\n            product *= -1L;\n            sum += abs(num);\n       \
    \ }\n        //else number is positive so just add the magnitude to sum\n    \
    \    else\n        {\n            sum += num;\n        }\n    }\n    //check if\
    \ we had any 0's\n    if(zero_count > 0L)\n    {\n        return Nullable!(long)();\n\
    \    }\n    //return null for empty array\n    else if(arr.length == 0)\n    {\n\
    \        return Nullable!(long)();\n    }\n    //return the final product\n  \
    \  else\n    {\n        return Nullable!(long)(product * sum);\n    }\n    \n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbp3o543l.d(73): unittest failure

    ----------------

    ??:? _d_unittestp [0x455bf9]

    ??:? void tmpbp3o543l.__unittest_L62_C1() [0x441939]

    ??:? void tmpbp3o543l.__modtest() [0x453704]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45ebfb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x455226]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45a43d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45a4cc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45a3c9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4551fd]

    ??:? runModuleUnitTests [0x45e9d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x456b84]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    else\n    {\n        long sum = 0L;\n     \
    \   long prod = 1L;\n        foreach (i; arr)\n        {\n            sum += abs(i);\n\
    \            if (i != 0)\n                prod *= sign(i);\n        }\n      \
    \  return sum * prod;\n    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppa9wu9cj.d(31): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmppa9wu9cj.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmppa9wu9cj.d(33): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppa9wu9cj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long prod\
    \ = 1L;\n        long sum = 0L;\n        foreach (i; arr) \n        {\n      \
    \      prod *= (i < 0) ? -1L : i == 0 ? 0L : 1L;\n            sum += abs(i);\n\
    \        }\n        return tuple(sum, prod)();\n    }\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaynlx9e1.d(34): Error: function expected before `()`, not `((Tuple!(long,
    long) __tup107 = tuple(sum, prod);), tuple(__tup107.__expand_field_0, __tup107.__expand_field_1))`
    of type `(long, long)`

    /tmp/tmpaynlx9e1.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaynlx9e1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long prod\
    \ = 1L;\n    long sum = 0L;\n    foreach(el; arr)\n    {\n        if(el == 0L)\n\
    \        {\n            return 0L;\n        }\n        sum += abs(el);\n     \
    \   prod *= el / abs(el);\n    }\n    return nullable(prod * sum);\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp65e344k4.d(27): Error: cannot implicitly convert expression `0L`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp65e344k4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    static assert(arr.length\
    \ == 0, \"nullable\");\n    long res = 1L;\n    long tmp = 0L;\n    foreach(elem;\
    \ arr) \n    {\n        if(elem > 0) \n        {\n            res *= 1L;\n   \
    \         tmp += elem;\n        }\n        else if(elem < 0) \n        {\n   \
    \         res *= -1L;\n            tmp += -elem;\n        }\n        else \n \
    \       {\n            res *= 0L;\n            tmp += 0L;\n        }\n    }\n\
    \    return make!Nullable(res * tmp);\n}\n/*\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ew2yrbu.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ew2yrbu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuloxi_3o.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuloxi_3o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.math\
    \ : abs;\n    import std.algorithm : map, reduce;\n    return arr.empty ? null\
    \ :\n        arr.map!(abs).reduce!(a, b => a * b) * arr.map!(el => el == 0 ? 0\
    \ : el < 0 ? -1 : 1).reduce!(a, b => a * b);\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjlux_nq0.d(23): Error: no property `empty` for type `long[]`

    /tmp/tmpjlux_nq0.d(24): Error: undefined identifier `a`

    /tmp/tmpjlux_nq0.d(24): Error: undefined identifier `a`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjlux_nq0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    auto prod = 1;\n    foreach (el; arr) \n  \
    \  {\n        prod *= sign(el);\n    }\n    auto res = 0;\n    foreach (el; arr)\
    \ \n    {\n        res += abs(el);\n    }\n    return res * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpej82vz0i.d(26): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpej82vz0i.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpej82vz0i.d(33): Error: cannot implicitly convert expression `res * prod`
    of type `int` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpej82vz0i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length==0)\n\
    \        return Nullable!(long)().init;\n    long p = 1;\n    long s = 0;\n  \
    \  foreach (z; arr)\n    {\n        if (z > 0)\n            p = p * 1;\n     \
    \   else if (z < 0)\n            p = p * -1;\n        else\n            continue;\n\
    \        s = s + abs(z);\n    }\n    return Nullable!(long)(p * s);\n}\n \nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpggkuq_lx.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x455bc9]

    ??:? void tmpggkuq_lx.__unittest_L38_C1() [0x441909]

    ??:? void tmpggkuq_lx.__modtest() [0x4536d4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45ebcb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4551f6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45a40d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45a49c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45a399]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4551cd]

    ??:? runModuleUnitTests [0x45e9a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x456b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // your code\
    \ here\n    if (arr.length == 0)\n    {\n        return null;\n    }\n    else\n\
    \    {\n        long sum = 0;\n        foreach (elem; arr)\n        {\n      \
    \      if (elem != 0)\n            {\n                sum += abs(elem);\n    \
    \        }\n        }\n        double prod = 1;\n        foreach (elem; arr)\n\
    \        {\n            if (elem != 0)\n            {\n                prod *=\
    \ elem / abs(elem);\n            }\n        }\n        return sum * prod;\n  \
    \  }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo0i85soq.d(24): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpo0i85soq.d(44): Error: cannot implicitly convert expression `cast(double)sum
    * prod` of type `double` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo0i85soq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum\
    \ = 0L;\n    long prod = 1L;\n    foreach(value; arr) \n    {\n        if (value\
    \ != 0L) \n        {\n            auto tmp = value / abs(value);\n           \
    \ sum += abs(value);\n            prod *= tmp;\n        }\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphs9xguuf.d(32): Error: cannot implicitly convert expression `sum
    * prod` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphs9xguuf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long sum_of_magnitudes\
    \ = 0;\n        long product_of_signs = 1;\n        foreach (i; arr) \n      \
    \  {\n            long sign = sign(i);\n            sum_of_magnitudes += abs(i);\n\
    \            product_of_signs *= sign;\n        }\n        return product_of_signs\
    \ * sum_of_magnitudes;\n    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ts9396x.d(31): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmp0ts9396x.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmp0ts9396x.d(35): Error: cannot implicitly convert expression `product_of_signs
    * sum_of_magnitudes` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ts9396x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \nin {\n    assert(arr\
    \ != null);\n}\nout (result) \ninout(arr) {\n    assert(arr != null);\n    assert(result\
    \ == null || result is long);\n}\nbody {\n    if (arr.length == 0) {\n       \
    \ return null;\n    } else {\n        Nullable!(long) signs = product_of_signs(arr);\n\
    \        Nullable!(long) magnitudes = sum_of_magnitudes(arr);\n        if (signs\
    \ is long && magnitudes is long) {\n            return magnitudes * signs;\n \
    \       } else {\n            return null;\n        }\n    }\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_zeiztak.d(24): Error: statement expected to be `{ }`, not `inout`

    /tmp/tmp_zeiztak.d(24): Error: no identifier for declarator `inout(arr)`

    /tmp/tmp_zeiztak.d(24): Error: missing `do { ... }` after `in` or `out`

    /tmp/tmp_zeiztak.d(26): Error: found `)` when expecting `.` following long

    /tmp/tmp_zeiztak.d(26): Error: found `;` when expecting identifier following `long`.

    /tmp/tmp_zeiztak.d(27): Error: found `}` when expecting `)`

    /tmp/tmp_zeiztak.d(28): Error: found `body` when expecting `;` following statement

    /tmp/tmp_zeiztak.d(34): Error: found `&&` when expecting `.` following long

    /tmp/tmp_zeiztak.d(34): Error: found `is` when expecting `)`

    /tmp/tmp_zeiztak.d(34): Error: no identifier for declarator `long`

    /tmp/tmp_zeiztak.d(34): Error: found `)` instead of statement

    /tmp/tmp_zeiztak.d(36): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmp_zeiztak.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_zeiztak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    static if(arr.length\
    \ > 0)\n    {\n        long[] signs = [];\n        foreach(i; 0 .. arr.length)\n\
    \        {\n            static if(arr[i] > 0)\n            {\n               \
    \ signs ~= 1L;\n            }\n            else static if(arr[i] < 0)\n      \
    \      {\n                signs ~= -1L;\n            }\n            else static\
    \ if(arr[i] == 0)\n            {\n                signs ~= 0L;\n            }\n\
    \        }\n        long prod_signs = product(signs);\n        long[] array_abs\
    \ = map!(abs)(arr);\n        long sum_abs = reduce!q{a + b}(array_abs);\n    \
    \    return Tuple!(long, long)(sum_abs, prod_signs);\n    }\n    else\n    {\n\
    \        return null;\n    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxeea33i0.d(21): Error: variable `arr` cannot be read at compile
    time

    /tmp/tmpxeea33i0.d(46): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxeea33i0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \nin {\n    assert(arr.length\
    \ > 0);\n} \nout (result) {\n    assert(result is null || result > 0);\n}\nbody\
    \ {\n    long signs = 1L;\n    long magnitude = 0L;\n    foreach (elem; arr) {\n\
    \        if (elem > 0) {\n            signs *= 1L;\n        }\n        else if\
    \ (elem < 0) {\n            signs *= -1L;\n        }\n        else {\n       \
    \     signs *= 0L;\n        }\n        magnitude += abs(elem);\n    }\n    if\
    \ (signs == 0L) {\n        return null;\n    }\n    return signs * magnitude;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiik75pxk.d(42): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpiik75pxk.d(44): Error: cannot implicitly convert expression `signs * magnitude`
    of type `long` to `Nullable!long`

    /tmp/tmpiik75pxk.d(24): Error: incompatible types for `(result) is (null)`: `const(Nullable!long)`
    and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiik75pxk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    typeof(null)\
    \ res = null;\n    long mult = 1L;\n    long sum = 0L;\n    long sign = 0L;\n\
    \    foreach(num; arr)\n    {\n        if(num < 0L)\n        {\n            sign\
    \ = -1L;\n        }\n        else if(num > 0L)\n        {\n            sign =\
    \ 1L;\n        }\n        else\n        {\n            sign = 0L;\n        }\n\
    \        mult *= sign;\n        sum += abs(num);\n    }\n    if(arr.length !=\
    \ 0)\n    {\n        res = sum * mult;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyjg13pxu.d(44): Error: cannot implicitly convert expression `sum
    * mult` of type `long` to `typeof(null)`

    /tmp/tmpyjg13pxu.d(46): Error: cannot implicitly convert expression `res` of type
    `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyjg13pxu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (int i, x; arr) \n    {\n        sum += abs(x);\n        prod *= sign(x);\n\
    \    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi86w1cu4.d(28): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpi86w1cu4.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpi86w1cu4.d(30): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi86w1cu4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.conv\
    \ : to;\n    import std.algorithm : map;\n    import std.numeric : product;\n\
    \    import std.range : empty;\n    if (arr.empty)\n        return null;\n   \
    \ return product(arr.map!(to!(int)()).map!(signbit));\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj0x4yiek.d(23): Error: module `std.numeric` import `product` not
    found

    /tmp/tmpj0x4yiek.d(26): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj0x4yiek.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ ret;\n    long prod_signs;\n    long sum_magn;\n    if (arr.length == 0)\n \
    \   {\n        ret = null;\n    }\n    else\n    {\n        // Make all signs\
    \ in the array positive\n        // and get the product of all signs\n       \
    \ sum_magn = 0;\n        prod_signs = 1;\n        foreach (l; arr)\n        {\n\
    \            if (l < 0)\n            {\n                l = abs(l);\n        \
    \        prod_signs *= -1;\n            }\n            sum_magn += l;\n      \
    \  }\n        ret = prod_signs * sum_magn;\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp61n89grw.d(26): Error: template `std.typecons.Nullable!long.Nullable.opAssign`
    cannot deduce function from argument types `!()(typeof(null))`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(2804):        `std.typecons.Nullable!long.Nullable.opAssign()(T
    value)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61n89grw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0L;\n    long prd = 1L;\n    foreach (v;\
    \ arr) \n    {\n        if (v > 0) sum += v;\n        else if (v < 0) { sum +=\
    \ v.abs; prd *= -1; }\n    }\n    return tuple(sum, prd).opMul;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_rlsxqze.d(29): Error: no property `opMul` for type `Tuple!(long,
    long)`

    /tmp/tmp_rlsxqze.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_rlsxqze.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long product\
    \ = 1L;\n    long sum = 0L;\n    Nullable!(long) total;\n    foreach(index, value;\
    \ arr)\n    {\n        if(value == 0L)\n        {\n            product *= 1L;\n\
    \        }\n        else if(value > 0L)\n        {\n            product *= 1L;\n\
    \        }\n        else if(value < 0L)\n        {\n            product *= -1L;\n\
    \        }\n        sum += abs(value);\n    }\n    total = product * sum;\n  \
    \  return total;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n   \
    \     auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplk6auqf9.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x455c01]

    ??:? void tmplk6auqf9.__unittest_L43_C1() [0x441935]

    ??:? void tmplk6auqf9.__modtest() [0x453710]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45ec03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x45522e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45a445]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45a4d4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45a3d1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x455205]

    ??:? runModuleUnitTests [0x45e9d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x456b8c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ko_p_wp.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ko_p_wp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n\tif (arr.length\
    \ == 0)\n\t\treturn null;\n\tlong ret = 0;\n\tlong cur = 1;\n\tforeach (a; arr)\
    \ \n\t{\n\t\tif (a < 0) \n\t\t{\n\t\t\tret += cur * abs(a);\n\t\t\tcur *= -1;\n\
    \t\t}\n\t\telse if (a > 0) \n\t\t{\n\t\t\tret += cur * a;\n\t\t}\n\t\telse if\
    \ (a == 0) \n\t\t{\n\t\t\tret = 0;\n\t\t\tcur = 1;\n\t\t}\n\t}\n\treturn ret;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsinbqho_.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpsinbqho_.d(42): Error: cannot implicitly convert expression `ret` of type
    `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsinbqho_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable.init;\n    }\n    long sum = 0;\n   \
    \ long prod = 1;\n    foreach (l; arr) \n    {\n        sum += abs(l);\n     \
    \   prod *= sign(l);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpifjq7kpy.d(23): Error: template `Nullable(T)` does not have property
    `init`

    /tmp/tmpifjq7kpy.d(30): Error: undefined identifier `sign`, did you mean template
    `sgn(F)(F x)`?

    /tmp/tmpifjq7kpy.d(32): Error: cannot implicitly convert expression `prod * sum`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpifjq7kpy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    return arr.empty\
    \ ? null : arr.map!(a => abs(a) * product(arr.map!(b => sign(b))).to!long)().sum();\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk_1tan4d.d(21): Error: no property `empty` for type `long[]`

    /tmp/tmpk_1tan4d.d(21): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_1tan4d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long res;\n\
    \    if (arr.length == 0)\n        return null;\n    else\n    {\n        foreach\
    \ (i; arr)\n        {\n            if (i != 0)\n                res *= i / abs(i);\n\
    \            else\n                res *= i;\n        }\n        foreach (i; arr)\n\
    \        {\n            if (i != 0)\n                res *= abs(i);\n        }\n\
    \        return res;\n    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9vdur16b.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp9vdur16b.d(38): Error: cannot implicitly convert expression `res` of type
    `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9vdur16b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        i > 0 ? prod *= 1 : i < 0 ? prod *= -1 : prod *= 0;\n\
    \        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprfdowyxi.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmprfdowyxi.d(30): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprfdowyxi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ x;\n    long res = 0;\n    foreach(i; arr)\n    {\n        if(i != 0)\n    \
    \    {\n            res += abs(i);\n            x = (cast(long)sgn(i));\n    \
    \        res *= x;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfb8zkm27.d(32): Error: cannot implicitly convert expression `res`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfb8zkm27.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\n    long sum = 0;\n\
    \    long prod = 1;\n    for (long i = 0; i < arr.length; i++) \n    {\n     \
    \   if (arr[i] < 0) \n        {\n            prod *= -1;\n        }\n        else\
    \ if (arr[i] == 0) \n        {\n            return 0;\n        }\n        sum\
    \ += abs(arr[i]);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpki9s64p6.d(35): Error: cannot implicitly convert expression `0`
    of type `int` to `Nullable!long`

    /tmp/tmpki9s64p6.d(39): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpki9s64p6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.math;\n    import\
    \ std.typecons;\n    /*\n        Convert signs to [-1L, 1L].\n        Sum up magnitudes\
    \ of all integers.\n        Multiply magnitudes by product of all signs.\n   \
    \     Divide product by 2.\n        Return sum.\n    */\n    static long magnitude_and_sign(long\
    \ n) {\n        auto s = signbit(n);\n        auto m = abs(n);\n        return\
    \ (n == 0L) ? 0L : (s ? -m : m);\n    }\n    if (arr.empty)\n        return Nullable!(long)();\n\
    \    auto ms = arr.map!magnitude_and_sign;\n    return ms.sum() * product(ms)\
    \ / 2L;\n}\n \n/*\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n     \
    \   auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjstzcn8d.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjstzcn8d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long product = 1;\n    long sum = 0;\n    foreach (i;\
    \ arr)\n    {\n        long sign = signbit(i) ? -1 : 1;\n        product *= sign;\n\
    \        sum += abs(i);\n    }\n    return sum * product;\n}\n \n/*\n    You are\
    \ given two strings s and t, each of them composed of \"-\" or \"+\" symbols.\n\
    \    If the strings are equal return \"0\", if the first string is greater return\
    \ \"1\", if\n    the second string is greater return \"-1\".\nunittest\n{\n  \
    \  alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpda0jzl3o.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpda0jzl3o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum\
    \ = 0L;\n    long sign = 1L;\n    foreach(value; arr)\n    {\n        if(value\
    \ < 0L)\n        {\n            sign *= -1L;\n        }\n        sum += abs(value);\n\
    \    }\n    if(arr.length == 0)\n    {\n        return null;\n    }\n    return\
    \ sign * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkx8_q8cu.d(33): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpkx8_q8cu.d(35): Error: cannot implicitly convert expression `sign * sum`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkx8_q8cu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    return cast(Nullable!(long))\
    \ (arr.length \n                              ? arr.map!(a => \n             \
    \                       cast(tuple(long, int))([abs(a), sign(a)]))\n         \
    \                           .fold!((t, s) => [t[0] + s[0], t[1] * s[1]])\n   \
    \                                 .reduce!((a, b) => a * b)\n                \
    \              : null);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptx6agn47.d(23): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptx6agn47.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n    long sum\
    \ = 0L;\n    long prod = 1L;\n    foreach(i; arr)\n    {\n        // Replaced\
    \ by 'i!=0' after DIP 1018,\n        // DIP 1036 or DIP 1043, depending on\n \
    \       // their future fate.\n        if (i != 0) \n        {\n            sum\
    \ += abs(i);\n            prod *= i/abs(i);\n        }\n    }\n    return Nullable!(long)(prod\
    \ * sum);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6enz9hk8.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x455ba9]

    ??:? void tmp6enz9hk8.__unittest_L36_C1() [0x4418e9]

    ??:? void tmp6enz9hk8.__modtest() [0x4536b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45ebab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4551d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45a3ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45a47c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45a379]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4551ad]

    ??:? runModuleUnitTests [0x45e981]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x456b34]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length==0)\
    \ \n        return null;\n    auto r = 1L;\n    for (auto e : arr)\n        r*=sign(e);\n\
    \    return abs(r)*sum(map!abs(a => a)(arr));\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_c2ydp4v.d(24): Error: no identifier for declarator `e`

    /tmp/tmp_c2ydp4v.d(24): Error: expression expected, not `:`

    /tmp/tmp_c2ydp4v.d(24): Error: found `arr` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_c2ydp4v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    auto sign = long.sign;\n   \
    \ auto signs = arr.map!(a => sign(a)).array;\n    long prod = product(signs);\n\
    \    long abs_sum = abs(arr).sum;\n    return prod * abs_sum;\n}\nlong product(long[]\
    \ arr) \n{\n    long prod = 1L;\n    foreach (idx, x; arr) \n    {\n        prod\
    \ *= x;\n    }\n    return prod;\n}\nlong abs(long[] arr) \n{\n    return arr.map!(a\
    \ => a < 0 ? -a : a).array;\n}\nlong sum(long[] arr) \n{\n    long sum = 0L;\n\
    \    foreach (idx, x; arr) \n    {\n        sum += x;\n    }\n    return sum;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa6ppycn9.d(25): Error: no property `sign` for type `long`

    /tmp/tmpa6ppycn9.d(26): Error: no property `map` for type `long[]`

    /tmp/tmpa6ppycn9.d(28): Error: function `tmpa6ppycn9.sum(long[] arr)` is not callable
    using argument types `(long)`

    /tmp/tmpa6ppycn9.d(28):        cannot pass argument `abs(arr)` of type `long`
    to parameter `long[] arr`

    /tmp/tmpa6ppycn9.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpa6ppycn9.d(29): Error: cannot implicitly convert expression `prod * abs_sum`
    of type `long` to `Nullable!long`

    /tmp/tmpa6ppycn9.d(42): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa6ppycn9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    int sign = 1;\n    long mags =\
    \ 0;\n    foreach (el; arr)\n    {\n        sign *= sign(el);\n        mags +=\
    \ abs(el);\n    }\n    return Nullable!(long)(sign * mags);\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph_dvuynb.d(27): Error: function expected before `()`, not `sign`
    of type `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph_dvuynb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    auto result\
    \ = 1L;\n    auto sum_magnitudes = 0L;\n    if (arr.length == 0) return null;\n\
    \    foreach (el; arr) \n    {\n        sum_magnitudes += el > 0 ? el : -el;\n\
    \        result *= el < 0 ? -1 : el > 0 ? 1 : 0;\n    }\n    return result * sum_magnitudes;\n\
    }\n/*\n    You are given an array of integers that you want to process\n    with\
    \ a function f .\n    Write a function process that takes an alias to a function\
    \ f and\n    an array arr and returns a tuple with the result of f applied to\n\
    \    each element of arr and the length of arr.\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz99_1pjs.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz99_1pjs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    int len =\
    \ arr.length;\n    if (len == 0) return typeof(return).init;\n    long sum = 0L;\n\
    \    long prod = 1L;\n    foreach (ref int x; arr) \n    {\n        if (x > 0)\
    \ \n        {\n            prod *= 1L;\n            sum += x;\n        }\n   \
    \     else if (x < 0) \n        {\n            prod *= -1L;\n            sum +=\
    \ x.abs;\n        }\n        else \n        {\n            prod *= 0L;\n     \
    \   }\n    }\n    return prod*sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv3f2jajh.d(21): Error: cannot implicitly convert expression `arr.length`
    of type `ulong` to `int`

    /tmp/tmpv3f2jajh.d(25): Error: argument type mismatch, `long` to `ref int`

    /tmp/tmpv3f2jajh.d(42): Error: cannot implicitly convert expression `prod * sum`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv3f2jajh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (item;\
    \ arr) \n    {\n        if (item > 0) prod *= 1;\n        else if (item < 0) prod\
    \ *= -1;\n        else prod *= 0;\n        sum += abs(item);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps264ns_3.d(21): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmps264ns_3.d(31): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps264ns_3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long prod\
    \ = 1;\n    long sum = 0;\n    foreach(x; arr)\n    {\n        if(x == 0)\n  \
    \      {\n            prod = 0;\n            sum = 0;\n            break;\n  \
    \      }\n        else if(x < 0)\n        {\n            prod *= -1;\n       \
    \     sum += abs(x);\n        }\n        else\n        {\n            sum += x;\n\
    \        }\n    }\n    auto r = sum * prod;\n    if(arr.length == 0) return null;\n\
    \    return r;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n     \
    \   auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl82udztj.d(42): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpl82udztj.d(43): Error: cannot implicitly convert expression `r` of type
    `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl82udztj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    static int\
    \ sign(long x) \n    {\n        if (x == 0) return 0;\n        return x > 0 ?\
    \ 1 : -1;\n    }\n    if (arr.length == 0) return null;\n    long p = 1;\n   \
    \ long s = 0;\n    foreach (i; arr) \n    {\n        p *= sign(i);\n        s\
    \ += abs(i);\n    }\n    return s * p;\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5gox1gwq.d(26): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp5gox1gwq.d(34): Error: cannot implicitly convert expression `s * p` of
    type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5gox1gwq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n    // your\
    \ code here \n    if (arr.length == 0)\n    {\n        return null;\n    }\n \
    \   long p = 1;\n    long s = 0;\n    foreach (x; arr)\n    {\n        if (x <\
    \ 0)\n        {\n            p *= -1;\n        }\n        else if (x > 0)\n  \
    \      {\n            p *= 1;\n        }\n        else\n        {\n          \
    \  p *= 0;\n        }\n        s += abs(x);\n    }\n    return p * s;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3k4l6z9n.d(24): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp3k4l6z9n.d(44): Error: cannot implicitly convert expression `p * s` of
    type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3k4l6z9n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ final_sum;\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnq3ggsxq.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnq3ggsxq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long magnitudeSum\
    \ = 0L;\n    long product = 1L;\n    foreach(idx,elem; arr)\n    {\n        if(elem\
    \ > 0)\n        {\n            magnitudeSum += elem;\n            product *= 1L;\n\
    \        }\n        else if(elem < 0)\n        {\n            magnitudeSum +=\
    \ abs(elem);\n            product *= -1L;\n        }\n        else \n        {\n\
    \            product *= 0L;\n        }\n    }\n    if(arr.length == 0)\n    {\n\
    \        return null;\n    }\n    return product * magnitudeSum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51bm0csf.d(42): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp51bm0csf.d(44): Error: cannot implicitly convert expression `product *
    magnitudeSum` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51bm0csf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    return reduce!(\"a * b\", arr.map!(abs)).product() *\
    \ \n        reduce!(\"a * b\", arr.map!(a => a > 0 ? 1 : (a < 0 ? -1 : 0)));\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2pw75khs.d(22): Error: template instance `reduce!("a * b", arr.map!abs)`
    template `reduce` is not defined

    /tmp/tmp2pw75khs.d(23): Error: template instance `reduce!("a * b", arr.map!((a)
    => a > 0 ? 1 : a < 0 ? -1 : 0))` template `reduce` is not defined

    /tmp/tmp2pw75khs.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2pw75khs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ result = 0L;\n    long[] signs = map!((x) => if (x < 0) -1L else if (x > 0)\
    \ 1L else 0L)(arr);\n    long prodSigns = product(signs);\n    if (prodSigns ==\
    \ 0L) \n    {\n        return result;\n    }\n    long[] magnitudes = map!((x)\
    \ => abs(x))(arr);\n    long sumMagnitudes = sum(magnitudes);\n    result = sumMagnitudes\
    \ * prodSigns;\n    return result;\n}\n// TESTING\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe0jy4dcz.d(22): Error: expression expected, not `if`

    /tmp/tmpe0jy4dcz.d(22): Error: found `else` when expecting `)` following template
    argument list

    /tmp/tmpe0jy4dcz.d(22): Error: semicolon expected, not `if`

    /tmp/tmpe0jy4dcz.d(22): Error: found `else` when expecting `;` following statement

    /tmp/tmpe0jy4dcz.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0jy4dcz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long res;\n\
    \        res = arr[0];\n        foreach (i; 1 .. arr.length) \n        {\n   \
    \         res *= sign(arr[i]);\n        }\n        foreach (i; 0 .. arr.length)\
    \ \n        {\n            res *= abs(arr[i]);\n        }\n        return res;\n\
    \    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpumtirssr.d(31): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpumtirssr.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpumtirssr.d(37): Error: cannot implicitly convert expression `res` of type
    `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpumtirssr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // Convert\
    \ long[] to some long[].\n    auto someArr = to!(Some!(long[]))(arr);\n    //\
    \ Calculate product of signs of numbers in the array.\n    return someArr.map!(a\
    \ => a.magnitude).reduce!q{a + b}\n        * arr.map!q{a == 0 ? 0 : a > 0 ? 1\
    \ : -1}.reduce!q{a * b};\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_h8k65am.d(22): Error: template instance `to!(Some!(long[]))` template
    `to` is not defined, did you mean No?

    /tmp/tmp_h8k65am.d(25): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_h8k65am.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n    if (arr.length\
    \ == 0) \n        return null;\n    \n    Tuple!(int, long)[] arr2 = new Tuple!(int,\
    \ long)[arr.length];\n    for (int i = 0; i < arr.length; i++) \n    {\n     \
    \   if (arr[i] > 0) \n            arr2[i] = tuple(1, arr[i]);\n        else if\
    \ (arr[i] < 0) \n            arr2[i] = tuple(-1, arr[i]);\n        else\n    \
    \        arr2[i] = tuple(0, arr[i]);\n    }\n    \n    int product = 1;\n    long\
    \ sum = 0;\n    foreach (a; arr2) \n    {\n        product *= a[0];\n        sum\
    \ += abs(a[1]);\n    }\n    \n    return product * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp34jwmjnj.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp34jwmjnj.d(43): Error: cannot implicitly convert expression `cast(long)product
    * sum` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp34jwmjnj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.algorithm;\n\
    \    if (arr.empty)\n        return null;\n    return arr.map!(x => x < 0 ? -1\
    \ : (x > 0 ? 1 : 0))\n    .reduce!((a, b) => a * b) * arr.map!abs.reduce!((a,\
    \ b) => a + b);\n}\n/*\n    Given two arrays, write a function to compute their\
    \ intersection.\n    Example:\n    >>> intersect([1, 2, 2, 1], [2, 2])\n    [2L,\
    \ 2L]\n    >>> intersect([4, 9, 5], [9, 4, 9, 8, 4])\n    [4L, 9L]\n    >>> intersect([3,\
    \ 2, 3], [3, 3])\n    [3L, 3L]\n*/\nlong[] intersect(long[] nums1, long[] nums2)\
    \ \n{\n    import std.algorithm;\n    import std.array;\n    import std.range;\n\
    \    import std.conv;\n    if (nums1.empty || nums2.empty)\n        return [];\n\
    \    nums1.sort;\n    nums2.sort;\n    auto[i, j] = tuple(0, 0);\n    int n1 =\
    \ nums1.length;\n    int n2 = nums2.length;\n    long[] result;\n    while(i <\
    \ n1 && j < n2) \n    {\n        while(i < n1 && j < n2 && nums1[i] < nums2[j])\n\
    \            i++;\n        while(i < n1 && j < n2 && nums1[i] > nums2[j])\n  \
    \          j++;\n        if (i < n1 && j < n2 && nums1[i] == nums2[j]) \n    \
    \    {\n            result ~= nums1[i];\n            i++;\n            j++;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Return the maximum sum of three\
    \ non-overlapping subarrays.\n    Example:\n    >>> maxSumOfThreeSubarrays([1,\
    \ 2, 1, 2, 6, 7, 5\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n    \
    \    auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpllw4bnec.d(47): Error: basic type expected, not `[`

    /tmp/tmpllw4bnec.d(47): Error: found `,` when expecting `]`

    /tmp/tmpllw4bnec.d(47): Error: semicolon expected, not `]`

    /tmp/tmpllw4bnec.d(47): Error: found `]` instead of statement

    /tmp/tmpllw4bnec.d(66): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpllw4bnec.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    int sign\
    \ = 1;\n    long magnitude = 0;\n    foreach(x; arr) \n    {\n        if (x <\
    \ 0) \n        {\n            sign *= -1;\n            magnitude += abs(x);\n\
    \        }\n        else if (x > 0) \n        {\n            magnitude += x;\n\
    \        }\n        else\n        {\n            return Nullable!(long)();\n \
    \       }\n    }\n    return Nullable!(long)(sign * magnitude);\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpypo9y0m_.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x455bb1]

    ??:? void tmpypo9y0m_.__unittest_L41_C1() [0x4418f1]

    ??:? void tmpypo9y0m_.__modtest() [0x4536bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45ebb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4551de]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45a3f5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45a484]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45a381]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4551b5]

    ??:? runModuleUnitTests [0x45e989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x456b3c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ result = Nullable!(long)(null);\n    long prod = 1L;\n    long sum = 0L;\n \
    \   foreach(var val; arr) \n    {\n        sum += abs(val);\n        prod *= sign(val);\n\
    \    }\n    if(arr.length > 0)\n        result = Nullable!(long)(sum * prod);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n\
    \        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzemxecrd.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpzemxecrd.d(24): Error: undefined identifier `var`

    /tmp/tmpzemxecrd.d(27): Error: undefined identifier `sign`, did you mean template
    `sgn(F)(F x)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzemxecrd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    //TODO: return\
    \ product of all signs multiplied by sum of all magnitude.\n    return null;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_x9d75fp.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_x9d75fp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    \n    auto res = 1L;\n    foreach (i; arr)\n\
    \    {\n        if (i < 0)\n            res *= -1;\n        else if (i == 0)\n\
    \            res = 0;\n        res *= abs(i);\n    }\n    return res;\n}\n/*\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdidb3cxx.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdidb3cxx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164089
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // Your code\
    \ goes here\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long\
    \ s = 0;\n    foreach (x; arr)\n    {\n        if (x > 0)\n        {\n       \
    \     prod *= 1;\n            s += x;\n        }\n        else if (x < 0)\n  \
    \      {\n            prod *= -1;\n            s += abs(x);\n        }\n     \
    \   else\n        {\n            prod *= 0;\n        }\n    }\n    return prod\
    \ * s;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmsxw9djo.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpmsxw9djo.d(42): Error: cannot implicitly convert expression `prod * s`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmsxw9djo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sign,\
    \ prod, sum;\n    for (int i = 0; i < arr.length; i++)\n    {\n        sign =\
    \ arr[i] == 0 ? 0 : arr[i] < 0 ? -1 : 1;\n        prod *= sign;\n        sum +=\
    \ sign == 0 ? 0 : abs(arr[i]);\n    }\n    return sum == 0 ? null : sum * prod;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp321njxy0.d(28): Error: incompatible types for `(null) : (sum *
    prod)`: `typeof(null)` and `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp321njxy0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (a; arr) \n    {\n        if (a == 0) \n        {\n            prod = 0;\n \
    \           break;\n        }\n        sum += abs(a);\n        prod *= (a < 0)\
    \ ? -1 : 1;\n    }\n    return make!(Nullable)(sum * prod);\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwdy_vxdd.d(35): Error: template instance `make!Nullable` template
    `make` is not defined, did you mean main?

    /tmp/tmpwdy_vxdd.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwdy_vxdd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod_signs = 1L;\n    long prod_mag = 1L;\n   \
    \ for (long l : arr)\n    {\n        prod_signs *= sign(l);\n        prod_mag\
    \ *= abs(l);\n    }\n    return make!Nullable(prod_signs * prod_mag);\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1j6r6_v4.d(24): Error: semicolon expected, not `:`

    /tmp/tmp1j6r6_v4.d(24): Error: expression expected, not `:`

    /tmp/tmp1j6r6_v4.d(24): Error: found `arr` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1j6r6_v4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n    if (arr.length\
    \ == 0) return null;\n    long s = product(map!((x) => sign(x))(arr));\n    long\
    \ m = sum(map!((x) => abs(x))(arr));\n    return s * m;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppx_sce6e.d(22): Error: undefined identifier `product`

    /tmp/tmppx_sce6e.d(23): Error: undefined identifier `sum`

    /tmp/tmppx_sce6e.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmppx_sce6e.d(24): Error: cannot implicitly convert expression `s * m` of
    type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppx_sce6e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n    auto res\
    \ = arr.map!((n) => n == 0 ? 0 : n > 0 ? 1 : -1).product;\n    return arr.empty\
    \ ? null : res * arr.map!((n) => abs(n)).sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx1st1lgw.d(21): Error: no property `map` for type `long[]`

    /tmp/tmpx1st1lgw.d(22): Error: no property `empty` for type `long[]`

    /tmp/tmpx1st1lgw.d(22): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx1st1lgw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ prod_signs = long.init;\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxpgtwbj9.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxpgtwbj9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // Your code\
    \ here\n    int product = 1;\n    long sum = 0;\n    foreach(num; arr)\n    {\n\
    \        product *= sign(num);\n        sum += num;\n    }\n    if(sum == 0)\n\
    \        return null;\n    return sum * product;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp23__w92u.d(26): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmp23__w92u.d(30): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmp23__w92u.d(31): Error: cannot implicitly convert expression `sum * cast(long)product`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23__w92u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n  \
    \      auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppz1eypwr.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz1eypwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return typeof(return).init;\n    long mag = 0L;\n    int sign = 1;\n \
    \   foreach (i; arr) \n    {\n        if (i == 0) continue;\n        sign *= signbit(i)\
    \ ? -1 : 1;\n        mag += abs(i);\n    }\n    return mag * sign;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271):
    Error: no property `epsilon` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(353):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(371):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(6254):
    Error: template instance `std.math.floatTraits!long` error instantiating

    /tmp/tmpoo106cq5.d(27):        instantiated from here: `signbit!long`

    /tmp/tmpoo106cq5.d(30): Error: cannot implicitly convert expression `mag * cast(long)sign`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoo106cq5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    else \n    {\n        long res = 1;\n     \
    \   long sum = 0;\n        foreach (elem; arr) \n        {\n            if (elem\
    \ > 0)\n                res *= 1;\n            else if (elem < 0)\n          \
    \      res *= -1;\n            else\n                res *= 0;\n            sum\
    \ += abs(elem);\n        }\n        return sum*res;\n    }\n}\nunittest\n{\n \
    \   alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmm0vc37z.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpmm0vc37z.d(37): Error: cannot implicitly convert expression `sum * res`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmm0vc37z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    long prod = 1L;\n    long sum\
    \ = 0L;\n    foreach (idx, val; arr)\n    {\n        if (val > 0)\n          \
    \  prod *= 1L;\n        else if (val < 0)\n            prod *= -1L;\n        else\n\
    \            prod *= 0L;\n        sum += abs(val);\n    }\n    return Nullable!(long)(sum\
    \ * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n\tif (arr.length\
    \ == 0) return null;\n\tlong sum = 0L;\n\tlong prod = 1L;\n\tforeach (i; arr)\
    \ \n\t{\n\t\tsum += i > 0 ? i : -i;\n\t\tprod *= sign(i);\n\t}\n\treturn tuple(sum,\
    \ prod).product;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n   \
    \     auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplrogut04.d(27): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmplrogut04.d(29): Error: no property `product` for type `Tuple!(long, long)`

    /tmp/tmplrogut04.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrogut04.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // write\
    \ your code here\n    // Return null for empty arr\n    if (arr.length == 0) return\
    \ null;\n    Nullable!(long) res;\n    long sum = 0;\n    long prod = 1;\n   \
    \ foreach (elem; arr)\n    {\n        if (elem > 0) \n        {\n            sum\
    \ += elem;\n            prod *= 1;\n        }\n        else if (elem < 0) \n \
    \       {\n            sum += abs(elem);\n            prod *= -1;\n        }\n\
    \        else\n        {\n            prod *= 0;\n        }\n    }\n    if (prod\
    \ == 0) return 0;\n    res = sum * prod;\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk2j9t7hx.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpk2j9t7hx.d(44): Error: cannot implicitly convert expression `0` of type
    `int` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk2j9t7hx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \nin {\n  assert(arr.length\
    \ == 0 || arr.length > 0);\n}\nout(result) {\n  assert(arr.length == 0 || result\
    \ == null || (result > 0 && result % 1 == 0));\n}\n{\n  if (arr.length == 0) {\n\
    \    return null;\n  }\n  else {\n    long sign_product = 1;\n    long mag_sum\
    \ = 0;\n    for (long n in arr) {\n      sign_product *= sign(n);\n      mag_sum\
    \ += abs(n);\n    }\n    return mag_sum * sign_product;\n  }\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpryutd5si.d(26): Error: missing `do { ... }` after `in` or `out`

    /tmp/tmpryutd5si.d(33): Error: semicolon expected, not `in`

    /tmp/tmpryutd5si.d(33): Error: expression expected, not `in`

    /tmp/tmpryutd5si.d(33): Error: found `arr` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpryutd5si.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164090
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum\
    \ = 0;\n    long prod = 1;\n    foreach(i; arr) \n    {\n        if (i > 0) \n\
    \        {\n            sum += i;\n        }\n        else if (i < 0) \n     \
    \   {\n            sum += -i;\n            prod *= -1;\n        }\n        else\
    \ \n        {\n            return null;\n        }\n    }\n    return make!Nullable(sum\
    \ * prod);\n}\n/*\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n     \
    \   auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5np3kj6f.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5np3kj6f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long res = 1;\n    long sum = 0;\n    foreach\
    \ (l; arr) \n    {\n        int sign = (l > 0) ? 1 : -1;\n        sum += sign\
    \ * abs(l);\n        res *= sign;\n    }\n    return sum * res;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9s8en6c0.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp9s8en6c0.d(31): Error: cannot implicitly convert expression `sum * res`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9s8en6c0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    /*\n    return\
    \ -1L;\n    */\n    Nullable!(long) rval = Nullable!(long)();\n    if (arr.length\
    \ == 0)\n    {\n        rval = Nullable!(long)();\n    }\n    else\n    {\n  \
    \      long sum = 0L;\n        long prod = 1L;\n        foreach (a; arr)\n   \
    \     {\n            sum += abs(a);\n            prod *= sign(a);\n        }\n\
    \        rval = Nullable!(long)(sum * prod);\n    }\n    return rval;\n}\nstatic\
    \ assert(prod_signs([1L, 2L, 2L, -4L]) == 9L);\nstatic assert(prod_signs([0L,\
    \ 1L]) == 0L);\nstatic assert(prod_signs([]) is null);\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp08liboz4.d(36): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmp08liboz4.d(42):        called from here: `prod_signs([1L, 2L, 2L, -4L])`

    /tmp/tmp08liboz4.d(42):        while evaluating: `static assert(prod_signs([1L,
    2L, 2L, -4L]) == 9L)`

    /tmp/tmp08liboz4.d(43): Error: CTFE failed because of previous errors in `prod_signs`

    /tmp/tmp08liboz4.d(43):        while evaluating: `static assert(prod_signs([0L,
    1L]) == 0L)`

    /tmp/tmp08liboz4.d(44): Error: incompatible types for `(prod_signs([])) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp08liboz4.d(44):        while evaluating: `static assert(prod_signs([])
    is null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp08liboz4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (elem;\
    \ arr)\n    {\n        int sign = elem == 0 ? 0 : elem > 0 ? 1 : -1;\n       \
    \ sum += abs(elem);\n        prod *= sign;\n    }\n    return sum * prod;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpprlfg1d9.d(21): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpprlfg1d9.d(30): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpprlfg1d9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    \n    long prodSigns = 1L;\n    long sumMagnitudes\
    \ = 0L;\n    foreach (index, val; arr)\n    {\n        if (val == 0)\n       \
    \     continue;\n        if (val < 0)\n            prodSigns *= -1;\n        sumMagnitudes\
    \ += abs(val);\n    }\n    return sumMagnitudes * prodSigns;\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuujnvlh0.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpuujnvlh0.d(34): Error: cannot implicitly convert expression `sumMagnitudes
    * prodSigns` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuujnvlh0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    return arr.map!(abs).product * arr.map!(x => signbit(x)\
    \ ? -1 : 1).product;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n\
    \        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqnpbx7vw.d(22): Error: no property `map` for type `long[]`

    /tmp/tmpqnpbx7vw.d(22): Error: no property `map` for type `long[]`

    /tmp/tmpqnpbx7vw.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqnpbx7vw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.algorithm\
    \ : map, reduce;\n    return arr.length ? reduce!((a, b) => a * b)(arr.map!(i\
    \ => sign(i)) * arr.map!(i => abs(i))) : null;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5r97w2r9.d(22): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):        instantiated
    from here: `MapResult!(__lambda3, long[])`

    /tmp/tmp5r97w2r9.d(22):        instantiated from here: `map!(long[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5r97w2r9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr)\n    {\n        prod *= sign(i);\n        sum += abs(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbaxao6v3.d(27): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpbaxao6v3.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpbaxao6v3.d(30): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbaxao6v3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    /*\n    long\
    \ output = 0;\n    if (arr.length == 0) return null;\n    foreach (i; arr) {\n\
    \        switch (sign(i)) {\n            case -1:\n                output += abs(i);\n\
    \                break;\n            case 0:\n                continue;\n    \
    \        case 1:\n                output += abs(i);\n                break;\n\
    \        }\n    }\n    return output;\n    */\n    if (arr.length == 0) return\
    \ null;\n    return arr.map!(abs).sum;\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv90ml0y2.d(39): Error: no property `map` for type `long[]`

    /tmp/tmpv90ml0y2.d(38): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv90ml0y2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    auto prod\
    \ = 1L;\n    auto sum = 0L;\n    auto e = arr.empty;\n    if(e)\n        return\
    \ null;\n    else\n    {\n        foreach(l; arr)\n        {\n            auto\
    \ s = abs(l) / l;\n            if(s == 0)\n                continue;\n       \
    \     else\n            {\n                sum += abs(l);\n                prod\
    \ *= s;\n            }\n        }\n        return sum * prod;\n    }\n}\n/*\n\
    \    Function that receives array of integers and returns true\n    if the array\
    \ is sorted, otherwise returns false.\n    Note: return true for empty arr.\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps6kjt7ju.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps6kjt7ju.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ res = Nullable!(long)();\n    if(arr.length == 0)\n        return res;\n   \
    \ long prod = 1L;\n    long sum = 0L;\n    foreach(i; arr)\n    {\n        if(i\
    \ < 0)\n            prod *= -1L;\n        else if(i == 0)\n            prod =\
    \ 0L;\n        sum += abs(i);\n    }\n    res.set(sum * prod);\n    return res;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8kw0vnwi.d(34): Error: no property `set` for type `Nullable!long`,
    did you mean `std.typecons.Nullable!long.Nullable.get`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8kw0vnwi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \nin\n{\n    assert(arr.length\
    \ == 0 || arr.length >= 2);\n}\nout\n(result)\n{\n    assert(result != null);\n\
    }\ndo\n{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod\
    \ = 1;\n    foreach (index, element; arr)\n    {\n        if (element == 0) continue;\n\
    \        sum += abs(element);\n        prod *= sign(element);\n    }\n    return\
    \ product(sum, prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n\
    \        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps8ti8_r_.d(38): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmps8ti8_r_.d(40): Error: undefined identifier `product`

    /tmp/tmps8ti8_r_.d(31): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmps8ti8_r_.d(27): Error: template `std.typecons.Nullable!long.Nullable.opEquals`
    cannot deduce function from argument types `!()(typeof(null)) const`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(2611):        `std.typecons.Nullable!long.Nullable.opEquals()(auto
    ref const(typeof(this)) rhs)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(2621):        `std.typecons.Nullable!long.Nullable.opEquals(U)(auto
    ref const(U) rhs) if (is(typeof(this.get == rhs)))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps8ti8_r_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.algorithm;\n\
    \    import std.conv;\n    import std.math;\n    import std.typecons;\n    if\
    \ (arr.length == 0)\n        return null;\n    return arr.map!(a => (a > 0) ?\
    \ 1L : (a < 0) ? -1L : 0L).product() * arr.map!(abs).sum();\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9urovq80.d(27): Error: no property `product` for type `MapResult!(__lambda2,
    long[])`

    /tmp/tmp9urovq80.d(26): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9urovq80.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n\tlong sum =\
    \ 0;\n\tlong prod = 1;\n\tforeach(num; arr)\n\t{\n\t\tif(num > 0)\n\t\t{\n\t\t\
    \tsum += num;\n\t\t\tprod *= 1;\n\t\t}\n\t\telse if(num < 0)\n\t\t{\n\t\t\tsum\
    \ += abs(num);\n\t\t\tprod *= -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += 0;\n\t\
    \t\tprod *= 0;\n\t\t}\n\t}\n\tif(arr.length == 0)\n\t{\n\t\treturn null;\n\t}\n\
    \telse\n\t{\n\t\treturn (sum * prod);\n\t}\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6m00vqz3.d(43): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp6m00vqz3.d(47): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6m00vqz3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum_magnitudes = 0;\n    long product_signs\
    \ = 1;\n    foreach (ele; arr) \n    {\n        long sign = signbit(ele) ? -1\
    \ : 1;\n        long magnitude = abs(ele);\n        product_signs *= sign;\n \
    \       sum_magnitudes += magnitude;\n    }\n    return make!(Nullable)(sum_magnitudes\
    \ * product_signs);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n\
    \        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271):
    Error: no property `epsilon` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(353):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(371):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(6254):
    Error: template instance `std.math.floatTraits!long` error instantiating

    /tmp/tmpgkw0q62v.d(27):        instantiated from here: `signbit!long`

    /tmp/tmpgkw0q62v.d(32): Error: template instance `make!Nullable` template `make`
    is not defined, did you mean main?

    /tmp/tmpgkw0q62v.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgkw0q62v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long prod\
    \ = 1L;\n    long sum = 0L;\n    long[] arr;\n    foreach(el; arr)\n    {\n  \
    \      if(el < 0)\n        {\n            prod *= -1;\n        }\n        else\
    \ if(el == 0)\n        {\n            prod = 0;\n        }\n        sum += abs(el);\n\
    \    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl214pizv.d(23): Error: variable `arr` is shadowing variable `tmpl214pizv.prod_signs.arr`

    /tmp/tmpl214pizv.d(36): Error: cannot implicitly convert expression `prod * sum`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl214pizv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.algorithm\
    \ : reduce;\n    import std.conv : text;\n    import std.range : zip;\n    import\
    \ std.typecons : tuple;\n    if (arr.length == 0)\n        return null;\n    else\n\
    \    {\n        auto signs = arr.map!((e) => tuple(e, (e > 0) ? 1 : (e < 0) ?\
    \ -1 : 0));\n        return signs.reduce!((a, b) => tuple(a[0], a[1] * b[1])).map!((a)\
    \ => a[0] * a[1]).array;\n    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb9h61c4c.d(29): Error: no property `map` for type `long[]`

    /tmp/tmpb9h61c4c.d(26): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9h61c4c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // TODO\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf55x8vda.d(19): Error: function `tmpf55x8vda.prod_signs` has no
    `return` statement, but is expected to return a value of type `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf55x8vda.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n\tlong cumProd\
    \ = 1L;\n\tlong cumSum = 0L;\n\tif (arr.length == 0)\n\t{\n\t\treturn null;\n\t\
    }\n\telse\n\t{\n\t\tforeach (element; arr)\n\t\t{\n\t\t\tcumProd *= sign(element);\n\
    \t\t\tcumSum += abs(element);\n\t\t}\n\t\treturn cumProd * cumSum;\n\t}\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaqdqjh62.d(31): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpaqdqjh62.d(25): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpaqdqjh62.d(34): Error: cannot implicitly convert expression `cumProd *
    cumSum` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaqdqjh62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ result = Nullable!(long)(0L);\n    foreach(n; arr)\n    {\n        if(n > 0)\n\
    \        {\n            result.assign(result.get!(long) + n);\n        } else\
    \ if(n < 0)\n        {\n            result.assign(result.get!(long) - n);\n  \
    \      }\n    }\n    return result;\n}\n/*\n    You are given two lists a and\
    \ b. If a[0] is 0, then b[0] should be returned\n    as result, if a[1] is 0,\
    \ then b[1] should be returned as result, etc.\n    If no numbers in a is 0, then\
    \ return 0.\n    Example:\n    >>> bingo([1L, 2L, 0L, 4L, 0L], [9L, 7L, 5L, 3L,\
    \ 1L])\n    5L\n    >>> bingo([0L, 1L, 2L, 3L, 4L], [5L, 6L, 7L, 8L, 9L])\n  \
    \  5L\n    >>> bingo([1L, 2L, 3L, 4L, 5L], [6L, 7L, 8L, 9L, 10L])\n    0L\n  \
    \  >>> bingo([], [])\n    0L\n*/\nlong bingo(long[] a, long[] b) \n{\n    foreach(i,\
    \ value; a)\n    {\n        if(value == 0)\n        {\n            return b[i];\n\
    \        }\n    }\n    return 0L;\n}\n/*\n    Given an array of integers, return\
    \ the sum of products of all non-unique numbers\n    Example:\n    >>> sum_of_nonunique_products([1L,\
    \ 2L, 3L, 2L, 4L])\n    12L\n    >>> sum_of_nonunique_products([1L, 2L, 3L, 3L,\
    \ 4L])\n    11L\n    >>> sum_of_nonunique_products([1L, 2L, 3L, 1L, 4L])\n   \
    \ 10L\n    >>> sum_of_nonunique_products([1L, 2L\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ja2d98g.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ja2d98g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164091
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    Tuple!(long, int) fold_f(Tuple!(long,\
    \ int) acc, long x) \n    {\n        return tuple(acc[0] + abs(x), acc[1] * sign(x));\n\
    \    }\n    auto sum_prod = arr.fold!fold_f(tuple(0L, 1));\n    return sum_prod[0]\
    \ * sum_prod[1];\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n   \
    \     auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiv4iepwc.d(27): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpiv4iepwc.d(29): Error: no property `fold` for type `long[]`

    /tmp/tmpiv4iepwc.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiv4iepwc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long mul = 1;\n    long sum = 0;\n    foreach\
    \ (elem; arr) \n    {\n        if (elem > 0)\n            mul *= 1;\n        else\
    \ if (elem < 0)\n            mul *= -1;\n        else\n            mul *= 0;\n\
    \        sum += abs(elem);\n    }\n    return sum * mul;\n}\nunittest\n{\n   \
    \ alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0ly2tfw.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpa0ly2tfw.d(35): Error: cannot implicitly convert expression `sum * mul`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0ly2tfw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    size_t prod = 1;\n    long result\
    \ = 0;\n    for (int i = 0; i < arr.length; i++) \n    {\n        if (arr[i] <\
    \ 0) \n        {\n            prod *= -1;\n        }\n        if (arr[i] != 0)\
    \ \n        {\n            result += abs(arr[i]);\n        }\n    }\n    return\
    \ prod * result;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n   \
    \     auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm4_99h58.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpm4_99h58.d(38): Error: cannot implicitly convert expression `prod * cast(ulong)result`
    of type `ulong` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm4_99h58.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ val = 0L;\n    if (arr.length == 0)\n        return null;\n    else\n    {\n\
    \        for (long d : arr)\n        {\n            val.assign(abs(d) * (val.isNull\
    \ ? 1L : val.get) * sign(d));\n        }\n        return val;\n    }\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq5b6it4a.d(26): Error: semicolon expected, not `:`

    /tmp/tmpq5b6it4a.d(26): Error: expression expected, not `:`

    /tmp/tmpq5b6it4a.d(26): Error: found `arr` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq5b6it4a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ signs = product(0L, arr.length, (idx) => {\n        if (arr[idx] < 0)\n    \
    \        return -1L;\n        else if (arr[idx] > 0)\n            return 1L;\n\
    \        else\n            return 0L;\n    });\n    Nullable!(long) magnitudes\
    \ = sum(0L, arr.length, (idx) => abs(arr[idx]));\n    return nullableFun1(signs,\
    \ (x) => nullableFun1(magnitudes, (y) => x * y));\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsptcju5q.d(21): Error: undefined identifier `product`

    /tmp/tmpsptcju5q.d(29): Error: undefined identifier `sum`

    /tmp/tmpsptcju5q.d(30): Error: undefined identifier `nullableFun1`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsptcju5q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long magnitudes = 0;\n    long signs = 1;\n    foreach\
    \ (i; arr) \n    {\n        magnitudes += abs(i);\n        signs *= sign(i);\n\
    \    }\n    return magnitudes * signs;\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv_7g78vc.d(27): Error: undefined identifier `sign`, did you mean
    variable `signs`?

    /tmp/tmpv_7g78vc.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpv_7g78vc.d(29): Error: cannot implicitly convert expression `magnitudes
    * signs` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv_7g78vc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ko_p_wp.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ko_p_wp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach (num;\
    \ arr)\n    {\n        if (num < 0) prod *= -1;\n        if (num == 0) prod =\
    \ 0;\n        sum += abs(num);\n    }\n    return prod * sum;\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5zbxp0d7.d(21): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp5zbxp0d7.d(30): Error: cannot implicitly convert expression `prod * sum`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5zbxp0d7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n\tif (arr.length\
    \ == 0)\n\t{\n\t\treturn Nullable!(long)();\n\t}\n\tlong[] signs = arr.map!(x\
    \ =>\n\t{\n\t\tif (x == 0)\n\t\t{\n\t\t\treturn long(0);\n\t\t}\n\t\treturn (x\
    \ > 0) ? long(1) : long(-1);\n\t});\n\tlong sum = arr.map!(x => abs(x)).sum;\n\
    \tlong prod = signs.product;\n\treturn Nullable!(long)(sum * prod);\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx7ys305c.d(25): Error: no property `map` for type `long[]`

    /tmp/tmpx7ys305c.d(33): Error: no property `map` for type `long[]`

    /tmp/tmpx7ys305c.d(34): Error: no property `product` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx7ys305c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach (elem;\
    \ arr) \n    {\n        sum += abs(elem);\n        prod *= sign(elem);\n    }\n\
    \    return tuple(sum, prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_dpe9ct0.d(27): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmp_dpe9ct0.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmp_dpe9ct0.d(29): Error: cannot implicitly convert expression `tuple(sum,
    prod)` of type `Tuple!(long, long)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_dpe9ct0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long[] signs;\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] > 0)\n  \
    \      {\n            sign = 1;\n        }\n        else if (arr[i] < 0)\n   \
    \     {\n            sign = -1;\n        }\n        else\n        {\n        \
    \    sign = 0;\n        }\n        signs ~= sign;\n    }\n    int product = 1;\n\
    \    for (int i = 0; i < signs.length; i++)\n    {\n        product *= signs[i];\n\
    \    }\n    long magnitude = 0;\n    for (int i = 0; i < arr.length; i++)\n  \
    \  {\n        magnitude += abs(arr[i]);\n    }\n    return product * magnitude;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9nn1769w.d(26): Error: undefined identifier `sign`, did you mean
    variable `signs`?

    /tmp/tmp9nn1769w.d(30): Error: undefined identifier `sign`, did you mean variable
    `signs`?

    /tmp/tmp9nn1769w.d(34): Error: undefined identifier `sign`, did you mean variable
    `signs`?

    /tmp/tmp9nn1769w.d(36): Error: undefined identifier `sign`, did you mean variable
    `signs`?

    /tmp/tmp9nn1769w.d(48): Error: cannot implicitly convert expression `cast(long)product
    * magnitude` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9nn1769w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum  = 0;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\n \nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9xkulbr8.d(28): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmp9xkulbr8.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmp9xkulbr8.d(30): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xkulbr8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1L;\n    long sum\
    \ = 0L;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n      \
    \      prod *= 1L;\n        } \n        else if (i < 0) \n        {\n        \
    \    prod *= -1L;\n        } \n        else \n        {\n            prod *= 0L;\n\
    \        }\n        sum += i.abs;\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9417u55h.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp9417u55h.d(43): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9417u55h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ko_p_wp.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ko_p_wp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.range;\n\
    \    import std.algorithm;\n    return arr.empty ? null : \n           product!((a,\
    \ b) => a * b)(\n               arr.map!(abs)\n                  .zip(arr.map!(x\
    \ => \n                         x > 0L ? 1L : (x < 0L ? -1L : 0L)))\n        \
    \          .map!(a => a[0] * a[1]));\n}\n \nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkpbmy4h2.d(24): Error: template instance `product!((a, b) => a
    * b)` template `product` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkpbmy4h2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    auto sign\
    \ = 1;\n    long sum = 0;\n    foreach(el; arr)\n    {\n        sign *= el < 0\
    \ ? -1 : el == 0 ? 0 : 1;\n        sum += abs(el);\n    }\n    return sign !=\
    \ 0 ? sum * sign : null;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq7ejuniz.d(28): Error: incompatible types for `(sum * cast(long)sign)
    : (null)`: `long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7ejuniz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // 1. calculate\
    \ product of signs\n    // 2. calculate sum of magnitudes\n    // 3. return product\
    \ of 1 and 2\n    if (arr.length == 0)\n        return null;\n    \n    auto sign_product\
    \ = 1L;\n    auto magnitude_sum = 0L;\n    foreach (v; arr) \n    {\n        auto\
    \ sign = v > 0 ? 1L : (v < 0 ? -1L : 0L);\n        sign_product *= sign;\n   \
    \     magnitude_sum += abs(v);\n    }\n    return sign_product * magnitude_sum;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm3rio4n.d(25): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpvm3rio4n.d(35): Error: cannot implicitly convert expression `sign_product
    * magnitude_sum` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm3rio4n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long prod\
    \ = 1L;\n    long sum = 0L;\n    // Iterating through array and assigning elements\
    \ \n    // to 'x' variable.\n    foreach(long x; arr) \n    {\n        if (x <\
    \ 0)\n        {\n            prod *= -1;\n        }\n        else if (x == 0)\n\
    \        {\n            return 0L;\n        }\n        sum += abs(x);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ny4h4xu.d(33): Error: cannot implicitly convert expression `0L`
    of type `long` to `Nullable!long`

    /tmp/tmp2ny4h4xu.d(37): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ny4h4xu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    if (arr.length == 1)\n        return arr[0];\n\
    \    int prod;\n    long sum;\n    auto signs = arr.map!(a => abs(a)/a);\n   \
    \ prod = reduce!((a, b) => a * b)(signs);\n    sum = reduce!((a, b) => a + b)(arr.map!(a\
    \ => abs(a)));\n    return sum * prod;\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdz33lqj9.d(27): Error: no property `map` for type `long[]`

    /tmp/tmpdz33lqj9.d(28): Error: template instance `reduce!((a, b) => a * b)` template
    `reduce` is not defined

    /tmp/tmpdz33lqj9.d(29): Error: template instance `reduce!((a, b) => a + b)` template
    `reduce` is not defined

    /tmp/tmpdz33lqj9.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpdz33lqj9.d(24): Error: cannot implicitly convert expression `arr[0]` of
    type `long` to `Nullable!long`

    /tmp/tmpdz33lqj9.d(30): Error: cannot implicitly convert expression `sum * cast(long)prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdz33lqj9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n\tif (arr.length\
    \ == 0)\n\t\treturn null;\n\t\n\tlong product = 1;\n\tlong sum = 0;\n\t\n\tfor\
    \ (long element; element in arr) \n\t{\n\t\tlong val = abs(element);\n\t\t\n\t\
    \tif (element == 0)\n\t\t\tval = 1;\n\t\t\n\t\tsum += val;\n\t\tproduct *= sign(element);\n\
    \t}\n\t\n\treturn sum * product;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4r2quevx.d(27): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp4r2quevx.d(38): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4r2quevx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    /*\n    long prod = 0L;\n    long sum = 0L;\n\
    \    long sign = 0L;\n    foreach (i; arr) \n    {\n        if (i > 0)\n     \
    \       sign = 1L;\n        else if (i < 0)\n            sign = -1L;\n       \
    \ else\n            sign = 0L;\n        prod *= sign;\n        sum += i;\n   \
    \ }\n    return prod * sum;\n    */\n    long prod = arr.map!(sign)().product;\n\
    \    long sum = arr.map!(abs).sum;\n    return prod * sum;\n}\n// you can also\
    \ write a function for sign of a number\nlong sign(long i) \n{\n    if (i > 0)\n\
    \        return 1L;\n    else if (i < 0)\n        return -1L;\n    else\n    \
    \    return 0L;\n}\n```\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n\
    \        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3u15ahk3.d(54): Error: declaration expected, not `""`

    /tmp/tmp3u15ahk3.d(54): Error: unterminated string constant starting at /tmp/tmp3u15ahk3.d(54)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3u15ahk3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \nin\n{\n    assert(arr.length\
    \ > 0);\n}\nout\n(\n    long result\n)\n{\n    result = 0L;\n    foreach (i, v;\
    \ arr) {\n        switch (v)\n        {\n            case 0L:\n              \
    \  break;\n            case -1L:\n                result += abs(v);\n        \
    \        break;\n            default:\n                result += abs(v);\n   \
    \             break;\n        }\n    }\n}\nbody\n{\n    long value = 1L;\n   \
    \ foreach (i, v; arr) {\n        switch (v)\n        {\n            case 0L:\n\
    \                result = 0L;\n                break;\n            case -1L:\n\
    \                value *= -1L;\n                break;\n            default:\n\
    \                break;\n        }\n    }\n    result *= value;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbmbd1fia.d(26): Error: `(identifier) { ... }` or `(identifier;
    expression)` following `out` expected, not `long`

    /tmp/tmpbmbd1fia.d(26): Error: found `result` when expecting `)`

    /tmp/tmpbmbd1fia.d(27): Error: statement expected to be `{ }`, not `)`

    /tmp/tmpbmbd1fia.d(27): Error: found `)` instead of statement

    /tmp/tmpbmbd1fia.d(30): Error: declaration expected, not `foreach`

    /tmp/tmpbmbd1fia.d(30): Error: no identifier for declarator `arr`

    /tmp/tmpbmbd1fia.d(30): Error: declaration expected, not `)`

    /tmp/tmpbmbd1fia.d(35): Error: declaration expected, not `case`

    /tmp/tmpbmbd1fia.d(37): Error: declaration expected, not `break`

    /tmp/tmpbmbd1fia.d(38): Error: declaration expected, not `default`

    /tmp/tmpbmbd1fia.d(40): Error: declaration expected, not `break`

    /tmp/tmpbmbd1fia.d(41): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbmbd1fia.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long product = 1;\n    long sum = 0;\n    foreach (i;\
    \ arr) \n    {\n        if (i > 0) product *= 1;\n        else if (i < 0) product\
    \ *= -1;\n        else product *= 0;\n        sum += abs(i);\n    }\n    return\
    \ product * sum;\n}\n \n/*\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvn5zwopt.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvn5zwopt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    auto sign_prod = -1L;\n    auto\
    \ sum_of_magnitudes = 0L;\n    for (long elem; arr) \n    {\n        auto sign\
    \ = (elem > 0) ? 1L : -1L;\n        sign_prod *= sign;\n        sum_of_magnitudes\
    \ += abs(elem);\n    }\n    return sign_prod * sum_of_magnitudes;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu5xrc8fw.d(27): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmpu5xrc8fw.d(33): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu5xrc8fw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164092
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ result = null;\n    long sumMagnitudes = 0;\n    long prodSigns = 1;\n    foreach(idx,\
    \ val; arr) \n    {\n        sumMagnitudes += abs(val);\n        prodSigns *=\
    \ sign(val);\n    }\n    result = sumMagnitudes * prodSigns;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqlm61bym.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpqlm61bym.d(27): Error: undefined identifier `sign`, did you mean template
    `sgn(F)(F x)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqlm61bym.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ sum = Nullable!(long).init;\n    long[] signs = arr.map!(a => sign(a));\n  \
    \  if(signs.length == 0)\n        return sum;\n    else\n    {\n        sum =\
    \ signs.product * signs.map!(a => abs(a)).sum;\n        return sum;\n    }\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxj35606.d(22): Error: no property `map` for type `long[]`

    /tmp/tmpaxj35606.d(27): Error: no property `product` for type `long[]`

    /tmp/tmpaxj35606.d(27): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxj35606.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n\tif (arr.length\
    \ == 0)\n\t\treturn null;\n\telse\n\t{\n\t\tlong sum = 0L;\n\t\tlong prod = 1L;\n\
    \t\tforeach (i; arr)\n\t\t{\n\t\t\tsum += abs(i);\n\t\t\tif (i != 0)\n\t\t\t\t\
    prod *= i < 0 ? -1 : 1;\n\t\t}\n\t\treturn sum * prod;\n\t}\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphzx5cruf.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmphzx5cruf.d(33): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphzx5cruf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n\
    \    {\n        sum += i.abs;\n        prod *= i.sign;\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn2_e_bnm.d(27): Error: no property `sign` for type `long`

    /tmp/tmpn2_e_bnm.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpn2_e_bnm.d(29): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn2_e_bnm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    else\n    {\n        long sign = 1;\n     \
    \   long magnitude = 0;\n        foreach (n; arr)\n        {\n            sign\
    \ *= n > 0 ? 1 : n < 0 ? -1 : 0;\n            magnitude += abs(n);\n        }\n\
    \        return magnitude * sign;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1gn1qbig.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp1gn1qbig.d(32): Error: cannot implicitly convert expression `magnitude
    * sign` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1gn1qbig.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    return std.algorithm.reduce!((prev,\
    \ num) => \n    {\n        if (prev is null)\n            return num;\n      \
    \  else if (num is null)\n            return null;\n        else\n           \
    \ return prev + abs(num);\n    })(arr);\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp79kk94lb.d(21): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp79kk94lb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    static assert(arr.length\
    \ >= 0);\n    static if (arr.length == 0)\n        return null;\n    else\n  \
    \  {\n        long prodSigns = 1L;\n        long sumMagnitudes = 0L;\n       \
    \ foreach (int index, ref long value; arr)\n        {\n            if (value >\
    \ 0)\n                prodSigns *= 1L;\n            else if (value < 0)\n    \
    \            prodSigns *= -1L;\n            else if (value == 0)\n           \
    \     prodSigns *= 0L;\n            sumMagnitudes += abs(value);\n        }\n\
    \        return sumMagnitudes * prodSigns;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tan56ng.d(21): Error: variable `arr` cannot be read at compile
    time

    /tmp/tmp_tan56ng.d(21):        while evaluating: `static assert(arr.length >=
    0LU)`

    /tmp/tmp_tan56ng.d(22): Error: variable `arr` cannot be read at compile time

    /tmp/tmp_tan56ng.d(38): Error: cannot implicitly convert expression `sumMagnitudes
    * prodSigns` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tan56ng.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ result = Nullable!(long)(long.init);\n    if(arr.length == 0L)\n    {\n    \
    \    return null;\n    }\n    long signs = 1L;\n    long mags = 0L;\n    foreach(num;\
    \ arr)\n    {\n        if(num < 0L)\n        {\n            signs *= -1L;\n  \
    \      }\n        else if(num == 0L)\n        {\n            signs = 0L;\n   \
    \     }\n        mags += abs(num);\n    }\n    result.some = signs * mags;\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n \
    \       auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdv7y_zxq.d(40): Error: no property `some` for type `Nullable!long`

    /tmp/tmpdv7y_zxq.d(24): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdv7y_zxq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum\
    \ = 0;\n    long prod = 1;\n    if (arr.length == 0) \n    {\n        return typeof(return).init;\n\
    \    }\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n       \
    \     sum += i;\n        } \n        else if (i < 0) \n        {\n           \
    \ sum += abs(i);\n            prod *= -1;\n        }\n    }\n    return sum *\
    \ prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwot2s2yj.d(39): Error: cannot implicitly convert expression `sum
    * prod` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwot2s2yj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // can be\
    \ simplified using std.functional.map.reduce\n    if (arr.length == 0) return\
    \ null;\n    return arr.map!(a => (a < 0) ? -1 : (a > 0) ? 1 : 0).reduce!((a,\
    \ b) => a * b)(0) * arr.map!(a => abs(a)).reduce!((a, b) => a + b)(0);\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoub6yy9s.d(23): Error: no property `map` for type `long[]`

    /tmp/tmpoub6yy9s.d(23): Error: no property `map` for type `long[]`

    /tmp/tmpoub6yy9s.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoub6yy9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long result\
    \ = 1L;\n    foreach(num; arr) \n    {\n        if (num > 0) \n        {\n   \
    \         result *= num;\n        } \n        else if (num < 0) \n        {\n\
    \            result *= -num;\n        } \n        else \n        {\n         \
    \   return tuple(result, 0L).idup;\n        }\n    }\n    return tuple(result,\
    \ 1L).idup;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ngblzyz.d(34): Error: template `object.idup` cannot deduce function
    from argument types `!()(Tuple!(long, long))`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(4308):        `object.idup(T)(T[]
    a)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(4321):        `object.idup(T
    : void)(const(T)[] a)`

    /tmp/tmp0ngblzyz.d(37): Error: template `object.idup` cannot deduce function from
    argument types `!()(Tuple!(long, long))`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(4308):        `object.idup(T)(T[]
    a)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(4321):        `object.idup(T
    : void)(const(T)[] a)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ngblzyz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n  if (arr.length\
    \ == 0)\n    return null;\n  else \n  {\n    long prod = 1L;\n    long res = 0L;\n\
    \    foreach (num; arr) \n    {\n      prod *= sign(num);\n      res += abs(num);\n\
    \    }\n    return make!Nullable(res * prod);\n  }\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfrrafp7s.d(29): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpfrrafp7s.d(32): Error: template instance `make!Nullable` template `make`
    is not defined, did you mean main?

    /tmp/tmpfrrafp7s.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfrrafp7s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ none;\n    if (arr.length == 0)\n        return none;\n    long sign_prod =\
    \ 1L;\n    long mag_sum = 0L;\n    foreach (index, value; arr) \n    {\n     \
    \   sign_prod *= sign(value);\n        mag_sum += abs(value);\n    }\n    return\
    \ tup(sign_prod * mag_sum);\n}\n/*\n    Answer:\n    >>> prod_signs([1L, 2L, 2L,\
    \ -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n*/\n// Example of chained function calls with if/else\n// functions\
    \ can be defined in any order.\n// main is executed last.\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpcf0m0l.d(28): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpnpcf0m0l.d(31): Error: undefined identifier `tup`, did you mean template
    `dup(T : V[K], K, V)(T aa)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpcf0m0l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n  \
    \      auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppz1eypwr.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz1eypwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    \n    long magnitude = 0L;\n    long product\
    \ = 1L;\n    foreach (long index, int value; arr)\n    {\n        if (value >\
    \ 0)\n            product *= 1;\n        else if (value < 0)\n            product\
    \ *= -1;\n        else \n            product *= 0;\n        \n        magnitude\
    \ += abs(value);\n    }\n    \n    return makeNullable!(long)(magnitude * product);\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpejgtn0v2.d(26): Error: cannot implicitly convert expression `__r74[cast(ulong)__key73]`
    of type `long` to `int`

    /tmp/tmpejgtn0v2.d(38): Error: template instance `makeNullable!long` template
    `makeNullable` is not defined

    /tmp/tmpejgtn0v2.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpejgtn0v2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return typeof(return).init;\n    }\n    int prod = 1;\n\
    \    ulong sum = 0UL;\n    foreach (elem; arr) \n    {\n        if (elem == 0)\
    \ \n        {\n            prod = 0;\n            break;\n        }\n        if\
    \ (elem < 0) \n        {\n            prod *= -1;\n        }\n        sum += cast(ulong)abs(elem);\n\
    \    }\n    return (sum * cast(ulong)prod);\n}\n/*\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsbujgn57.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsbujgn57.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long sign_prod = 1L;\n    long\
    \ sum_magn = 0L;\n    foreach (el; arr) \n    {\n        sum_magn += el.abs;\n\
    \        sign_prod *= el.sign;\n    }\n    return sum_magn * sign_prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ny0sqf3.d(30): Error: no property `sign` for type `long`

    /tmp/tmp8ny0sqf3.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmp8ny0sqf3.d(32): Error: cannot implicitly convert expression `sum_magn
    * sign_prod` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ny0sqf3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    long\
    \ temp;\n    for (auto i = 0; i < arr.length; i++) \n    {\n        temp = arr[i];\n\
    \        if (temp < 0)\n            prod *= -1;\n        sum += abs(temp);\n \
    \   }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuwafqg_3.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpuwafqg_3.d(33): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwafqg_3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ res = Nullable!(long)();\n    if (arr.length > 0)\n    {\n        long sign_prod\
    \ = 1L;\n        long abs_sum = 0L;\n        foreach (x; arr)\n        {\n   \
    \         sign_prod *= (x == 0) ? 0 : ((x > 0) ? 1 : -1);\n            abs_sum\
    \ += abs(x);\n        }\n        res = Nullable!(long)(sign_prod * abs_sum);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    long prod = 1;\n    long sum \
    \ = 0;\n    foreach (i; arr) \n    {\n        if (i == 0)\n            continue;\n\
    \        sum += abs(i);\n        prod *= i >= 0 ? 1 : -1;\n    }\n    return Nullable!(long)(sum\
    \ * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnnr0vv3i.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x455bc1]

    ??:? void tmpnnr0vv3i.__unittest_L34_C1() [0x441901]

    ??:? void tmpnnr0vv3i.__modtest() [0x4536cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45ebc3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4551ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45a405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45a494]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45a391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4551c5]

    ??:? runModuleUnitTests [0x45e999]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x456b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1L;\n    foreach\
    \ (item; arr) \n    {\n        prod *= item < 0 ? -1L : item > 0 ? 1L : 0L;\n\
    \    }\n    if (prod == 0L) \n    {\n        return 0L;\n    }\n    long sum =\
    \ 0L;\n    foreach (item; arr) \n    {\n        sum += item * (item < 0 ? -1L\
    \ : 1L);\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnywzcyj2.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpnywzcyj2.d(32): Error: cannot implicitly convert expression `0L` of type
    `long` to `Nullable!long`

    /tmp/tmpnywzcyj2.d(39): Error: cannot implicitly convert expression `sum` of type
    `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnywzcyj2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long r;\n\
    \    if (arr.length == 0) \n    {\n        return null;\n    }\n    r = arr[0];\n\
    \    foreach (i; 1 .. arr.length) \n    {\n        auto t = arr[i];\n        r\
    \ *= t / abs(t);\n    }\n    return map!(a => abs(a))(arr).reduce!(\"a + b\")\
    \ * r;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfo8wg_el.d(32): Error: template instance `map!((a) => abs(a))`
    template `map` is not defined

    /tmp/tmpfo8wg_el.d(24): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfo8wg_el.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    Nullable!(long) product = Nullable!(long)(1L);\n\
    \    long sum = 0L;\n    for (long i = 0L; i < arr.length; i++)\n    {\n     \
    \   if (arr[i] == 0L)\n            product = null;\n        if (arr[i] < 0L)\n\
    \            product *= -1L;\n        sum += abs(arr[i]);\n    }\n    if (product\
    \ is null)\n        return 0L;\n    return product * sum;\n}\nunittest\n{\n  \
    \  alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkgvn387f.d(28): Error: template `std.typecons.Nullable!long.Nullable.opAssign`
    cannot deduce function from argument types `!()(typeof(null))`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(2804):        `std.typecons.Nullable!long.Nullable.opAssign()(T
    value)`

    /tmp/tmpkgvn387f.d(33): Error: incompatible types for `(product) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmpkgvn387f.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpkgvn387f.d(34): Error: cannot implicitly convert expression `0L` of type
    `long` to `Nullable!long`

    /tmp/tmpkgvn387f.d(35): Error: cannot implicitly convert expression `product.get()
    * sum` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkgvn387f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    return abs(arr.product) * arr.sum;\n\
    }\n \n/*\n*   Write a function, which takes two objects and checks if they have\
    \ the same\n*   properties and values.\n*/\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpek6rk19m.d(23): Error: no property `product` for type `long[]`

    /tmp/tmpek6rk19m.d(23): Error: no property `sum` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpek6rk19m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long[] signs = arr.map!(a => a < 0 ? -1L :\
    \ a > 0 ? 1L : 0L);\n    long product = signs.reduce!((a, b) => a * b)(1L);\n\
    \    long sum_magnitudes = arr.map!(a => a < 0 ? -a : a).reduce!((a, b) => a +\
    \ b)(0L);\n    return product * sum_magnitudes;\n}\n \nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppkhcjzfb.d(23): Error: no property `map` for type `long[]`

    /tmp/tmppkhcjzfb.d(24): Error: no property `reduce` for type `long[]`

    /tmp/tmppkhcjzfb.d(25): Error: no property `map` for type `long[]`

    /tmp/tmppkhcjzfb.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmppkhcjzfb.d(26): Error: cannot implicitly convert expression `product *
    sum_magnitudes` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppkhcjzfb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // if the\
    \ array is empty return null\n    if (arr.length == 0) return null;\n    // initialize\
    \ a product to 1\n    long product = 1;\n    // initialize a sum of magnitudes\
    \ to 0\n    long sum_of_magnitudes = 0;\n    // for each value in the array\n\
    \    foreach (value; arr)\n    {\n        // add the magnitude of the value to\
    \ the sum\n        sum_of_magnitudes += abs(value);\n        // multiply the product\
    \ by the sign of the value\n        product *= (long)sign(value);\n    }\n   \
    \ // return the product of the sign times the sum of the magnitudes\n    return\
    \ product * sum_of_magnitudes;\n}\n/*\n    You are given an array, which will\
    \ contain either positive or\n    negative integers or empty strings.\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxs3m6mrb.d(33): Error: C style cast illegal, use `cast(long)sign(value)`

    /tmp/tmpxs3m6mrb.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxs3m6mrb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    // Alternative:\n    // if (arr.empty)\n  \
    \  //     return null;\n    // if (arr.length == 0)\n    //     return null;\n\
    \    long prod_signs = 1L;\n    long sum_magnitudes = 0L;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        long sign = signbit(arr[i]);\n        if\
    \ (sign == 0)\n            sign = 1L;\n        else if (sign == 1)\n         \
    \   sign = -1L;\n        prod_signs *= sign;\n        sum_magnitudes += abs(arr[i]);\n\
    \    }\n    return sum_magnitudes * prod_signs;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271):
    Error: no property `epsilon` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(353):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(371):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(6254):
    Error: template instance `std.math.floatTraits!long` error instantiating

    /tmp/tmpoh7eh2o9.d(32):        instantiated from here: `signbit!long`

    /tmp/tmpoh7eh2o9.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpoh7eh2o9.d(40): Error: cannot implicitly convert expression `sum_magnitudes
    * prod_signs` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoh7eh2o9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ prod = Nullable!(long)(1L);\n    Nullable!(long) mag = Nullable!(long)(0L);\n\
    \    for (long index = 0; index < arr.length; index++) \n    {\n        if (arr[index]\
    \ > 0)\n        {\n            prod = prod.get * 1L;\n            mag = mag.get\
    \ + arr[index];\n        } \n        else if (arr[index] < 0)\n        {\n   \
    \         prod = prod.get * -1L;\n            mag = mag.get + abs(arr[index]);\n\
    \        }\n        else\n        {\n            prod = Nullable!(long)();\n \
    \           mag = Nullable!(long)();\n            break;\n        }\n    }\n \
    \   return prod * mag;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8x0gxup9.d(42): Error: cannot implicitly convert expression `prod.get()
    * mag.get()` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8x0gxup9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    \n    long prod = 1;\n    foreach (num; arr)\
    \ \n    {\n        if (num > 0)\n            prod *= 1;\n        else if (num\
    \ < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n    }\n\
    \    \n    long sum = 0;\n    foreach (num; arr) \n    {\n        if (num > 0)\n\
    \            sum += num;\n        else if (num < 0)\n            sum += -num;\n\
    \        else\n            sum += 0;\n    }\n    \n    return sum * prod;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4987y1gn.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp4987y1gn.d(46): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4987y1gn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\n    long sum = 0;\n\
    \    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i == 0) \n    \
    \    {\n            prod = 0;\n            break;\n        }\n        if (i <\
    \ 0) \n        {\n            prod *= -1;\n        }\n        sum += abs(i);\n\
    \    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\n    long[] signs =\
    \ map!(sign)(arr);\n    long signs_product = reduce!(mul)(signs);\n    long[]\
    \ magnitudes = map!(abs)(arr);\n    long magnitudes_sum = reduce!(add)(magnitudes);\n\
    \    return Nullable!(long)(magnitudes_sum * signs_product);\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6_4imq5g.d(25): Error: template instance `map!sign` template `map`
    is not defined

    /tmp/tmp6_4imq5g.d(26): Error: template instance `reduce!mul` template `reduce`
    is not defined

    /tmp/tmp6_4imq5g.d(27): Error: template instance `map!abs` template `map` is not
    defined

    /tmp/tmp6_4imq5g.d(28): Error: template instance `reduce!add` template `reduce`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6_4imq5g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // You need\
    \ to write your code here\n    if (arr.length == 0) \n    {\n        return null;\n\
    \    }\n    else \n    {\n        long result = 0;\n        long product = 1;\n\
    \        foreach (long i; arr) \n        {\n            if (i != 0) \n       \
    \     {\n                result += abs(i);\n                product *= i / abs(i);\n\
    \            }\n        }\n        return result * product;\n    }\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprhnfe01t.d(24): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmprhnfe01t.d(38): Error: cannot implicitly convert expression `result *
    product` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprhnfe01t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long ret;\n\
    \    int i;\n    int p;\n    if (arr.length == 0)\n        return null;\n    ret\
    \ = 0;\n    p = 1;\n    for (i = 0; i < arr.length; i++)\n    {\n        ret +=\
    \ arr[i] * arr[i];\n        if (arr[i] > 0)\n            p *= 1;\n        else\
    \ if (arr[i] < 0)\n            p *= -1;\n        else\n            p *= 0;\n \
    \   }\n    return ret * p;\n}\n/*\n    You are given an array of ints.\n    You\
    \ are to return the sum of all positive numbers in the array,\n    or null if\
    \ the array is empty.\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n \
    \       auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqvbhzjdi.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqvbhzjdi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164093
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    auto prod = 1L;\n    auto sum = 0L;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1L;\n        else if\
    \ (i < 0)\n            prod *= -1L;\n        else\n            prod *= 0L;\n \
    \       sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqaqr8iry.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpqaqr8iry.d(35): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqaqr8iry.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0L;\n    long prod = 1L;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp07s0adrx.d(28): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmp07s0adrx.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmp07s0adrx.d(30): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp07s0adrx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.range;\n    import std.range.primitives;\n\
    \    import std.typecons;\n    import std.numeric;\n    import std.numeric.interval;\n\
    \    alias null long;\n    long default_value = null;\n    if (arr.empty) \n \
    \   {\n        return default_value;\n    }\n    long result = reduce!\"*\"(map!\"\
    abs(a) * signum(a)\".array(arr));\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmjgvsvcv.d(28): Error: basic type expected, not `null`

    /tmp/tmpmjgvsvcv.d(28): Error: no identifier for declarator `_error_`

    /tmp/tmpmjgvsvcv.d(28): Error: semicolon expected to close `alias` declaration

    /tmp/tmpmjgvsvcv.d(28): Error: found `long` when expecting `;` following statement

    /tmp/tmpmjgvsvcv.d(28): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjgvsvcv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long product\
    \ = 1L;\n        long sum = 0L;\n        foreach (element; arr) \n        {\n\
    \            product *= element >= 0 ? 1L : -1L;\n            sum += abs(element);\n\
    \        }\n        return product * sum;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqwscyo4d.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpqwscyo4d.d(34): Error: cannot implicitly convert expression `product *
    sum` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqwscyo4d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuloxi_3o.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuloxi_3o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    else\n    {\n        long prod = 1L;\n    \
    \    long sum = 0L;\n        foreach (num; arr)\n        {\n            if (num\
    \ > 0)\n                prod *= 1L;\n            else if (num < 0)\n         \
    \       prod *= -1L;\n            else\n                prod *= 0L;\n        \
    \    sum += abs(num);\n        }\n        return sum * prod;\n    }\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7z_2y6b3.d(22): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp7z_2y6b3.d(37): Error: cannot implicitly convert expression `sum * prod`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7z_2y6b3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    auto prod = new product(arr);\n\
    \    return prod.get_sum();\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphzi_nfk6.d(25): Error: undefined identifier `product`

    /tmp/tmphzi_nfk6.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphzi_nfk6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long prod\
    \ = 1;\n    long sum = 0;\n    if (arr.length == 0)\n        return Nullable!(long)();\n\
    \    foreach (elem; arr)\n    {\n        prod *= signbit(elem);\n        sum +=\
    \ abs(elem);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271):
    Error: no property `epsilon` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(353):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(371):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(6254):
    Error: template instance `std.math.floatTraits!long` error instantiating

    /tmp/tmp1elzav4q.d(27):        instantiated from here: `signbit!long`

    /tmp/tmp1elzav4q.d(30): Error: cannot implicitly convert expression `prod * sum`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1elzav4q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sign = 1;\n    foreach (i; arr) \n   \
    \ {\n        sign *= i < 0 ? -1 : i > 0 ? 1 : 0;\n    }\n    long abs_sum = 0;\n\
    \    foreach (i; arr) \n    {\n        abs_sum += abs(i);\n    }\n    return sign\
    \ * abs_sum;\n}\n/*\n    You are given an array arr of integers.\n    Your task\
    \ is to sort the array by first odd numbers\n    in ascending order and then even\
    \ numbers in descending order.\n    If there are no odd numbers, you should sort\
    \ all elements in ascending order.\n    If there are no even numbers, you should\
    \ sort all elements in descending order.\n    Note: return sorted array.\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpohvas_ay.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpohvas_ay.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    else \n    {\n        long prod = 1;\n        long sum\
    \ = 0;\n        foreach (el; arr) \n        {\n            if (el == 0) continue;\n\
    \            else if (el > 0) \n            {\n                prod *= 1;\n  \
    \              sum += el;\n            }\n            else \n            {\n \
    \               prod *= -1;\n                sum += -el;\n            }\n    \
    \    }\n        return make!(Nullable)(sum * prod);\n    }\n}\nunittest\n{\n \
    \   alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzm9cdigw.d(40): Error: template instance `make!Nullable` template
    `make` is not defined, did you mean main?

    /tmp/tmpzm9cdigw.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzm9cdigw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long acc_magn\
    \ = 1;\n    long acc_sign = 1;\n    if (arr.length == 0) \n    {\n        return\
    \ null;\n    }\n    foreach (l; arr) \n    {\n        acc_magn *= abs(l);\n  \
    \      acc_sign *= sign(l);\n    }\n    return acc_magn * acc_sign;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwvfnfaf.d(30): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmppwvfnfaf.d(25): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmppwvfnfaf.d(32): Error: cannot implicitly convert expression `acc_magn
    * acc_sign` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwvfnfaf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n  \
    \      auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppz1eypwr.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz1eypwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164087
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ prod_signs(long[] arr) \n    {\n        import std.algorithm.iteration : filter,\
    \ map, reduce;\n        import std.math : sign;\n        import std.array : array;\n\
    \        import std.conv : to;\n        if (arr.empty) return null;\n        return\
    \ arr.map!(a => abs(a))\n            .reduce!((a, b) => a * b)(1) * \n       \
    \     arr.filter!(a => a != 0)\n                .map!(a => sign(a))\n        \
    \        .reduce!((a, b) => a * b)(1);\n    }\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3z7rmtr.d(24): Error: module `std.math` import `sign` not found,
    did you mean template `std.math.sgn(F)(F x)`?

    /tmp/tmpk3z7rmtr.d(27): Error: no property `empty` for type `long[]`

    /tmp/tmpk3z7rmtr.d(29): Error: template `tmpk3z7rmtr.prod_signs.prod_signs.reduce!((a,
    b) => a * b).reduce` cannot deduce function from argument types `!()(MapResult!(__lambda2,
    long[]), int)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(2838):        `tmpk3z7rmtr.prod_signs.prod_signs.reduce!((a,
    b) => a * b).reduce(R)(R r) if (isIterable!R)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(2883):        `tmpk3z7rmtr.prod_signs.prod_signs.reduce!((a,
    b) => a * b).reduce(S, R)(S seed, R r) if (isIterable!R)`

    /tmp/tmpk3z7rmtr.d(32): Error: template `tmpk3z7rmtr.prod_signs.prod_signs.reduce!((a,
    b) => a * b).reduce` cannot deduce function from argument types `!()(MapResult!(__lambda5,
    FilterResult!(__lambda4, long[])), int)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(2838):        `tmpk3z7rmtr.prod_signs.prod_signs.reduce!((a,
    b) => a * b).reduce(R)(R r) if (isIterable!R)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(2883):        `tmpk3z7rmtr.prod_signs.prod_signs.reduce!((a,
    b) => a * b).reduce(S, R)(S seed, R r) if (isIterable!R)`

    /tmp/tmpk3z7rmtr.d(27): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpk3z7rmtr.d(19): Error: function `tmpk3z7rmtr.prod_signs` has no `return`
    statement, but is expected to return a value of type `Nullable!long`

    Failed: ["dmd", "-unitte'
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.algorithm\
    \ : map, reduce;\n    return arr.empty ? null : \n        arr.map!((n) => tuple(n,\
    \ n.sign)).reduce!((a, b) => \n            tuple(a[0] * a[1] + b[0] * b[1], a[1]\
    \ * b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n   \
    \     reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a,\
    \ b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0]\
    \ * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1] *\
    \ b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n     \
    \   reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b)\
    \ => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] *\
    \ b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n\
    \        reduce!((a, b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a,\
    \ b) => tuple(a[0] * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0]\
    \ * b[1], a[1] * b[1])).\n        reduce!((a, b) => tuple(a[0] * b[1], a[1\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc0x_hd7r.d(39): Error: found `unittest` when expecting `,`

    /tmp/tmpc0x_hd7r.d(84): Error: found `void` when expecting `,`

    /tmp/tmpc0x_hd7r.d(84): Error: found `{` when expecting `,`

    /tmp/tmpc0x_hd7r.d(84): Error: expression expected, not `}`

    /tmp/tmpc0x_hd7r.d(84): Error: found `End of File` when expecting `,`

    /tmp/tmpc0x_hd7r.d(84): Error: found `End of File` when expecting `]`

    /tmp/tmpc0x_hd7r.d(84): Error: found `End of File` when expecting `,`

    /tmp/tmpc0x_hd7r.d(84): Error: found `End of File` when expecting `)`

    /tmp/tmpc0x_hd7r.d(84): Error: found `End of File` when expecting `)` following
    template argument list

    /tmp/tmpc0x_hd7r.d(84): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmpc0x_hd7r.d(84): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc0x_hd7r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prodSigns = 1;\n    long sum = 0;\n  \
    \  foreach (num; arr) \n    {\n        prodSigns *= sign(num);\n        sum +=\
    \ abs(num);\n    }\n    return tuple(sum, prodSigns);\n}\n \n/*\n    We have n\
    \ bananas with identical shape but different weights\n    (weights are given in\
    \ array arr), and m people.\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ihao5w0.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ihao5w0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164094
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sumOfMagnitudes = 0;\n    long productOfSigns =\
    \ 1;\n    foreach (i; arr)\n    {\n        sumOfMagnitudes += abs(i);\n      \
    \  if (i != 0) productOfSigns *= sign(i);\n    }\n    return sumOfMagnitudes *\
    \ productOfSigns;\n}\n \nunittest\n{\n    alias candidate = prod_signs;\n\n{\n\
    \        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8gngu5p4.d(27): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmp8gngu5p4.d(21): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmp8gngu5p4.d(29): Error: cannot implicitly convert expression `sumOfMagnitudes
    * productOfSigns` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gngu5p4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.typecons;\n\
    \    import std.algorithm;\n    import std.math;\n    Nullable!(long) result =\
    \ reduce!((a, b) => a * b)(map!(i => sign(i))(arr));\n    if (arr.length > 0)\
    \ \n    {\n        return result * reduce!((a, b) => a + b)(map!(i => abs(i))(arr));\n\
    \    }\n    else\n    {\n        return null;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1j9o1r0q.d(24): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):        instantiated
    from here: `MapResult!(__lambda3, long[])`

    /tmp/tmp1j9o1r0q.d(24):        instantiated from here: `map!(long[])`

    /tmp/tmp1j9o1r0q.d(27): Error: cannot implicitly convert expression `result.get()
    * reduce(map(arr))` of type `long` to `Nullable!long`

    /tmp/tmp1j9o1r0q.d(31): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1j9o1r0q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    import std.math\
    \ : abs;\n    import std.typecons : toNullable;\n    if (arr.length > 0)\n   \
    \ {\n        long prod = 1L;\n        long sum = 0L;\n        foreach (num; arr)\n\
    \        {\n            prod *= num.sign;\n            sum += abs(num);\n    \
    \    }\n        return toNullable(sum * prod);\n    }\n    return null;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkqnqbnpa.d(22): Error: module `std.typecons` import `toNullable`
    not found, did you mean struct `std.typecons.Nullable(T)`?

    /tmp/tmpkqnqbnpa.d(29): Error: no property `sign` for type `long`

    /tmp/tmpkqnqbnpa.d(34): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkqnqbnpa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    static import\
    \ std.array : all;\n    static import std.math : sign;\n    static import std.conv\
    \ : to;\n    import std.typecons : Nullable;\n    alias long ntype = long;\n \
    \   long signs = arr.map!(sign).all!((a, b) => a * b).to!ntype;\n    Nullable!ntype\
    \ result = Nullable!ntype();\n    if (arr.length == 0)\n        return null;\n\
    \    foreach (elem; arr)\n    {\n        result.get!ntype += abs(elem);\n    }\n\
    \    return result.get!ntype * signs;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx0egxj9z.d(21): Error: static import `std` cannot have an import
    bind list

    /tmp/tmpx0egxj9z.d(22): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0egxj9z.d(23): Error: static import `std` cannot have an import bind
    list

    /tmp/tmpx0egxj9z.d(25): Error: found `;` when expecting `.` following long

    /tmp/tmpx0egxj9z.d(26): Error: found `long` when expecting identifier following
    `long`.

    /tmp/tmpx0egxj9z.d(26): Error: alias cannot have initializer

    /tmp/tmpx0egxj9z.d(26): Error: semicolon expected to close `alias` declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0egxj9z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    //int product = 1;\n    long product = 1L;\n\
    \    long sum = 0L;\n    foreach (int i, int x; arr)\n    {\n        if (x ==\
    \ 0)\n            continue;\n        if (x > 0)\n            product *= 1;\n \
    \       else if (x < 0)\n            product *= -1;\n        sum += abs(x);\n\
    \    }\n    return product * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplq1aqbm6.d(26): Error: cannot implicitly convert expression `__r74[cast(ulong)__key73]`
    of type `long` to `int`

    /tmp/tmplq1aqbm6.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmplq1aqbm6.d(36): Error: cannot implicitly convert expression `product *
    sum` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplq1aqbm6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ko_p_wp.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ko_p_wp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164088
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    auto res = arr[0];\n    for\
    \ (auto i = 1; i < arr.length; i++) \n    {\n        res *= arr[i];\n    }\n \
    \   if (res < 0) \n    {\n        res = -res;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9y4hlf2_.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmp9y4hlf2_.d(34): Error: cannot implicitly convert expression `res` of type
    `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9y4hlf2_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum\
    \ = 0;\n    long prod = 1;\n    foreach(i; arr)\n    {\n        if(i != 0)\n \
    \       {\n            sum += abs(i);\n            prod *= i > 0 ? 1 : -1;\n \
    \       }\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuo60gi70.d(31): Error: cannot implicitly convert expression `prod
    * sum` of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuo60gi70.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    else\n    {\n        long sign,\
    \ res;\n        sign = 1;\n        res = 0;\n        foreach (idx, elem; arr)\n\
    \        {\n            if (elem == 0)\n            {\n                continue;\n\
    \            }\n            else if (elem < 0)\n            {\n              \
    \  sign *= -1;\n                res += abs(elem);\n            }\n           \
    \ else \n            {\n                res += elem;\n            }\n        }\n\
    \        return tuple(res, sign).expand;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzm471zbq.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpzm471zbq.d(46): Error: cannot implicitly convert expression `((Tuple!(long,
    long) __tup107 = tuple(res, sign);), tuple(__tup107.__expand_field_0, __tup107.__expand_field_1))`
    of type `(long, long)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzm471zbq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    auto prod\
    \ = 1;\n    auto sm = 0;\n    foreach(n; arr) \n    {\n        prod *= n < 0 ?\
    \ -1 : n > 0 ? 1 : 0;\n        sm += abs(n);\n    }\n    return prod * sm;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjwx991g7.d(28): Error: cannot implicitly convert expression `prod
    * sm` of type `int` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwx991g7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ res = null;\n    if (arr.length > 0) \n    {\n        long sign = 1;\n     \
    \   long mul = 1;\n        for (i; arr.length) \n        {\n            long tmp\
    \ = arr[i];\n            if (tmp > 0)\n                sign *= 1;\n          \
    \  else if (tmp < 0)\n                sign *= -1;\n            else\n        \
    \        sign *= 0;\n            mul *= tmp;\n        }\n        res = abs(mul)\
    \ * sign;\n    }\n    return res;\n}\n/*\n    1. i, mul and sign are initialized\
    \ to 0 and 1 respectively.\n    2. Iterate over all elements of the array.\n \
    \   3. If the value is positive, the sign is multiplied by 1,\n       if negative\
    \ by -1, otherwise by 0.\n    4. The value is multiplied to the product.\n   \
    \ 5. The result is calculated as the product sign multiplied by\n       the absolute\
    \ value of the product.\n*/\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwwdm0c6b.d(26): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmpwwdm0c6b.d(37): Error: found `res` when expecting `)`

    /tmp/tmpwwdm0c6b.d(37): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwwdm0c6b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{ \n    return arr.length\
    \ == 0 ? null : \n    (arr.map!(a => a > 0 ? 1L : (a < 0 ? -1L : 0L)).product)\
    \ *\n    (arr.map!(a => abs(a)).sum);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp94mbr3oo.d(22): Error: no property `map` for type `long[]`

    /tmp/tmp94mbr3oo.d(23): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp94mbr3oo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ result = Nullable!(long)();\n    if (arr.length > 0) \n    {\n        long prod\
    \ = 1L;\n        long sum = 0L;\n        foreach (i; arr) \n        {\n      \
    \      prod *= typeof(i) == int ? i.sign : 1L;\n            sum += abs(i);\n \
    \       }\n        result = sum * prod;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp04uqoala.d(28): Error: found `?` when expecting `.` following int

    /tmp/tmp04uqoala.d(28): Error: found `:` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp04uqoala.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // TODO:\
    \ implement your solution here.\n    if (arr.length == 0)\n        return null;\n\
    \    if (arr.length == 1)\n        return arr[0];\n    auto sign = 1;\n    auto\
    \ sum = 0;\n    foreach (val; arr)\n    {\n        if (val < 0)\n            sign\
    \ *= -1;\n        sum += abs(val);\n    }\n    return sum * sign;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa2rbo1by.d(23): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    /tmp/tmpa2rbo1by.d(25): Error: cannot implicitly convert expression `arr[0]` of
    type `long` to `Nullable!long`

    /tmp/tmpa2rbo1by.d(34): Error: cannot implicitly convert expression `sum * sign`
    of type `int` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa2rbo1by.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0L;\n    int sign = 1;\n    foreach (i; arr)\n\
    \    {\n        if (i != 0)\n        {\n            sum += abs(i);\n         \
    \   sign *= signbit(i) ? -1 : 1;\n        }\n    }\n    return sum * sign;\n}\n\
    \ \n// Function prod_signs should work with any array of signed integers.\nstatic\
    \ assert(prod_signs(cast(int[])[]) is null);\nstatic assert(prod_signs(cast(int[])[0,\
    \ 1]) == 0);\nstatic assert(prod_signs(cast(int[])[1, 2, 2, -4]) == 9);\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqyi57i9k.d(36): Error: incompatible types for `(prod_signs([]))
    is (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmpqyi57i9k.d(36):        while evaluating: `static assert(prod_signs([])
    is null)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271):
    Error: no property `epsilon` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335):
    Error: no property `mant_dig` for type `long`

    /'
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    // TODO\n\
    \    return null;\n}\n \n/*\n    You are given an array arr of integers and you\
    \ need to return\n    true if array contains a subset with sum of integers equals\
    \ to 0.\n    Note: return null for empty arr.\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpolj86cpv.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpolj86cpv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long res\
    \ = 1L;\n    long abs_sum = 0L;\n    if (arr.length == 0)\n        return null;\n\
    \    foreach (idx, val; arr)\n    {\n        if (val > 0)\n            res *=\
    \ 1L;\n        else if (val < 0)\n            res *= -1L;\n        else\n    \
    \        res *= 0L;\n        abs_sum += abs(val);\n    }\n    return Nullable!(long)(res\
    \ * abs_sum);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdk2ry9h_.d(24): Error: cannot implicitly convert expression `null`
    of type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdk2ry9h_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long total = 1;\n    long sum_of_magnitudes\
    \ = 0;\n    foreach (num; arr) \n    {\n        if (num != 0) \n        {\n  \
    \          sum_of_magnitudes += abs(num);\n            total *= sign(num);\n \
    \       }\n    }\n    return total * sum_of_magnitudes;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9i9h64n.d(30): Error: undefined identifier `sign`, did you mean
    template `sgn(F)(F x)`?

    /tmp/tmpl9i9h64n.d(22): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpl9i9h64n.d(33): Error: cannot implicitly convert expression `total * sum_of_magnitudes`
    of type `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9i9h64n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    //TODO: write\
    \ body of prod_signs\n    //\n    long i = 0;\n    Nullable!(long) s = null;\n\
    \    if (arr.length < 1)\n        return null;\n    else {\n        while (i <\
    \ arr.length) {\n            if (s is null) {\n                s = sign(arr[i]);\n\
    \            }\n            else {\n                s *= sign(arr[i]);\n     \
    \       }\n            i++;\n        }\n        return s * product(map!(abs)(arr));\n\
    \    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfvw7rgft.d(24): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpfvw7rgft.d(29): Error: incompatible types for `(s) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmpfvw7rgft.d(30): Error: undefined identifier `sign`, did you mean template
    `sgn(F)(F x)`?

    /tmp/tmpfvw7rgft.d(33): Error: undefined identifier `sign`, did you mean template
    `sgn(F)(F x)`?

    /tmp/tmpfvw7rgft.d(37): Error: undefined identifier `product`

    /tmp/tmpfvw7rgft.d(26): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfvw7rgft.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \nin {\n    if (arr.length\
    \ > 0)\n    {\n        long x = arr[0];\n        int v1 = (x > 0L) ? 1 : ((x <\
    \ 0L) ? -1 : 0);\n        if (v1 == 0) return true;\n        foreach (i, x; arr[1\
    \ .. $]) \n        {\n            int v2 = (x > 0L) ? 1 : ((x < 0L) ? -1 : 0);\n\
    \            if (v2 == 0) return true;\n            if (v1 == v2) return true;\n\
    \            v1 = v2;\n        }\n    }\n    return true;\n} \nout (Nullable!(long)\
    \ result) \n{\n    if (arr.length == 0) {\n        result = null;\n    }\n   \
    \ else \n    {\n        long sum_of_magnitudes = 0L;\n        int product_of_signs\
    \ = 1;\n        foreach (x; arr) \n        {\n            if (x == 0L) { product_of_signs\
    \ = 0; }\n            else \n            {\n                sum_of_magnitudes\
    \ += abs(x);\n                product_of_signs *= sign(x);\n            }\n  \
    \      }\n        result = product_of_signs * sum_of_magnitudes;\n    }\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpny_7gqvb.d(36): Error: found `!` when expecting `)`

    /tmp/tmpny_7gqvb.d(36): Error: statement expected to be `{ }`, not `(`

    /tmp/tmpny_7gqvb.d(36): Error: C style cast illegal, use `cast(long)result`

    /tmp/tmpny_7gqvb.d(36): Error: found `)` when expecting `;` following statement

    /tmp/tmpny_7gqvb.d(37): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpny_7gqvb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164095
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return null for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long res = 1;\n    foreach (num;\
    \ arr) \n    {\n        long sign = signbit(num) ? -1 : 1;\n        long mag =\
    \ num * sign;\n        res *= mag;\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271):
    Error: no property `epsilon` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(353):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(371):
    Error: no property `mant_dig` for type `long`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(6254):
    Error: template instance `std.math.floatTraits!long` error instantiating

    /tmp/tmpin0_2977.d(28):        instantiated from here: `signbit!long`

    /tmp/tmpin0_2977.d(23): Error: cannot implicitly convert expression `null` of
    type `typeof(null)` to `Nullable!long`

    /tmp/tmpin0_2977.d(32): Error: cannot implicitly convert expression `res` of type
    `long` to `Nullable!long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpin0_2977.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164096
