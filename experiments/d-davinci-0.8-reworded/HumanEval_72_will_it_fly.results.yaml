name: HumanEval_72_will_it_fly
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n   \
    \     return false;\n    else if(q.length == 1)\n        return q[0] <= w;\n \
    \   else\n    {\n        long sum = q.sum;\n        if(sum > w)\n            return\
    \ false;\n        else\n        {\n            long[] result = q.sort;\n     \
    \       long[] result2 = q.dup.sort;\n            foreach(i,e; result)\n     \
    \       {\n                if(result[i] != result2[i])\n                    return\
    \ false;\n            }\n            return true;\n        }\n    }\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpunzbo3zz.d(34): Error: no property `sum` for type `long[]`\\\
    n/tmp/tmpunzbo3zz.d(39): Error: no property `sort` for type `long[]`\\n/tmp/tmpunzbo3zz.d(40):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpunzbo3zz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    long s = 0;\n    foreach(var\
    \ x; q) \n    {\n        s += x;\n    }\n    return s <= w && q == q.dup.reverse;\n\
    }\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuz5msnvi.d(29): Error: undefined identifier `var`\\n/tmp/tmpuz5msnvi.d(33):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpuz5msnvi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    long size = q.length;\n\
    \    if (q.length == 1L)\n        return q[0L] <= w;\n    else \n    {\n     \
    \   long left_sum = 0L;\n        long right_sum = 0L;\n        for (long i = 0L;\
    \ i < size; i++)\n        {\n            left_sum += q[i];\n            right_sum\
    \ += q[size - i - 1L];\n            if (left_sum == right_sum && left_sum <= w)\n\
    \                return true;\n        }\n        return false;\n    }\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpncg0v507.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428215]\\n??:? void tmpncg0v507.__unittest_L45_C1()\
    \ [0x427e68]\\n??:? void tmpncg0v507.__modtest() [0x427f98]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c273]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b106]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430299]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430748]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430225]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b0dd]\\n??:? runModuleUnitTests [0x42c049]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4286d8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42865f]\\n??:? _d_run_main [0x4285ca]\\n??:? main [0x427fab]\\\
    n??:? __libc_start_main [0xa1e2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    long sum = q.sum();\n \
    \   bool isPalindrome = q.equal(q.reversed);\n    return (sum <= w) && isPalindrome;\n\
    }\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7mhgi7ph.d(28): Error: no property `sum` for type `long[]`\\\
    n/tmp/tmp7mhgi7ph.d(29): Error: no property `equal` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mhgi7ph.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    long sum = 0;\n    foreach(long\
    \ n; q)\n    {\n        sum += n;\n    }\n    if(sum > w)\n    {\n        return\
    \ false;\n    }\n    else\n    {\n        long[] q2 = q[0..$/2];\n        long[]\
    \ q3 = q[$/2..$];\n        return equal(q2, reverse(q3));\n    }\n}\n/*\n    Write\
    \ a function that returns the maximum possible weight w for the object q to fly.\n\
    unittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L,\
    \ 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj5u5x1c9.d(44): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj5u5x1c9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    long m = q.fold!((a, b)\
    \ => max(a, b))();\n    long sum = q.sum;\n    bool p = q.arrayIsPalindrome();\n\
    \    return p && sum <= w && m <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\
    \n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L,\
    \ 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L,\
    \ 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n\
    \    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6pqp1lyp.d(28): Error: no property `fold` for type `long[]`\\\
    n/tmp/tmp6pqp1lyp.d(29): Error: no property `sum` for type `long[]`\\n/tmp/tmp6pqp1lyp.d(30):\
    \ Error: no property `arrayIsPalindrome` for type `long[]`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6pqp1lyp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    w -= q.sum;\n    return\
    \ w > 0 && (q.size % 2 == 0 || q[q.size / 2] * 2 <= w);\n}\nunittest\n{\n    alias\
    \ candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n\
    \    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L)\
    \ == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpar1g_lts.d(28): Error: no property `sum` for type `long[]`\\\
    n/tmp/tmpar1g_lts.d(29): Error: no property `size` for type `long[]`\\n/tmp/tmpar1g_lts.d(29):\
    \ Error: no property `size` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpar1g_lts.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    static assert(q.length\
    \ >= 1);\n    static assert(w >= 0);\n    bool sum=false;\n    foreach(int i;0..q.length)\n\
    \    {\n        sum+=q[i];\n    }\n    if(sum>w)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        int lo = 0;\n        int hi = q.length - 1;\n\
    \        while (lo < hi) {\n        if (q[lo] != q[hi]) {\n        return false;\n\
    \        }\n        lo += 1;\n        hi -= 1;\n        }\n        return true;\n\
    \    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfrbyih83.d(28): Error: variable `q` cannot be read at compile\
    \ time\\n/tmp/tmpfrbyih83.d(28):        while evaluating: `static assert(q.length\
    \ >= 1LU)`\\n/tmp/tmpfrbyih83.d(29): Error: variable `w` cannot be read at compile\
    \ time\\n/tmp/tmpfrbyih83.d(29):        while evaluating: `static assert(w >=\
    \ 0L)`\\n/tmp/tmpfrbyih83.d(31): Error: cannot implicitly convert expression `q.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfrbyih83.d(42): Error: cannot implicitly\
    \ convert expression `q.length - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfrbyih83.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    long qweight = 0;\n   \
    \ for (long i = 0; i < q.length; i++)\n    {\n        qweight += q[i];\n    }\n\
    \    if (qweight > w)\n    {\n        return false;\n    }\n    return q.equal(q.dup.reverse);\n\
    }\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxbgdgx1l.d(37): Error: no property `equal` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxbgdgx1l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    long sum = 0;\n    foreach(long\
    \ x; q)\n    {\n        sum += x;\n    }\n    int n = q.length;\n    for(int i\
    \ = 0; i < n / 2; i++)\n    {\n        if(q[i] != q[n - i - 1])\n        {\n \
    \           return false;\n        }\n    }\n    return sum <= w;\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa8my0jhv.d(33): Error: cannot implicitly convert expression `q.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpa8my0jhv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n  long sum = reduce!(\"a +\
    \ b\")(q);\n  wchar[] qq = map!(\"to!(wchar)(a)\")(q);\n  return sum <= w && qq.equal(qq.dup.reverse);\n\
    }\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnxc_vq4c.d(28): Error: template instance `reduce!\"a + b\"` template\
    \ `reduce` is not defined\\n/tmp/tmpnxc_vq4c.d(29): Error: template instance `map!\"\
    to!(wchar)(a)\"` template `map` is not defined\\n/tmp/tmpnxc_vq4c.d(30): Error:\
    \ no property `equal` for type `wchar[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpnxc_vq4c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    long suma = 0;\n    long\
    \ max_weight = 0;\n    foreach(i;q)\n    {\n        suma += i;\n        if(max_weight<i)\n\
    \        {\n            max_weight = i;\n        }\n    }\n    if(suma>w)\n  \
    \  {\n        return false;\n    }\n    if(suma<=w)\n    {\n        int i = 0;\n\
    \        int j = q.length-1;\n        while(i<=j)\n        {\n            if(q[i]!=q[j])\n\
    \            {\n                return false;\n            }\n            i++;\n\
    \            j--;\n        }\n        return true;\n    }\n}\nunittest\n{\n  \
    \  alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) ==\
    \ true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp82ur6181.d(45): Error: cannot implicitly convert expression `q.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp82ur6181.d(26): Error: function `tmp82ur6181.will_it_fly`\
    \ no `return exp;` or `assert(0);` at end of function\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp82ur6181.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    return false;\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0dvvxijo.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42812d]\\n??:? void tmp0dvvxijo.__unittest_L30_C1()\
    \ [0x427d38]\\n??:? void tmp0dvvxijo.__modtest() [0x427eb0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c117]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42afaa]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43013d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4305ec]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4300c9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42af81]\\n??:? runModuleUnitTests [0x42beed]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42857c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428503]\\n??:? _d_run_main [0x42846e]\\n??:? main [0x427ec3]\\\
    n??:? __libc_start_main [0xea80b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    return q.sum() <= w &&\
    \ q.length > 1 ? is(typeof(q.front) == typeof(q.back)) : false;\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd6o_bv6l.d(28): Error: no property `sum` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd6o_bv6l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    auto n = q.length;\n  \
    \  long sum = 0;\n    foreach(i, ref x; q)\n    {\n        sum += x;\n    }\n\
    \    if(sum > w)\n    {\n        return false;\n    }\n    auto q2 = q.dup;\n\
    \    q2.sort();\n    long sum2 = 0;\n    foreach(i, ref x; q2)\n    {\n      \
    \  sum2 += x;\n    }\n    if(sum != sum2)\n    {\n        return false;\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqtf2sxxg.d(39): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqtf2sxxg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    static struct Check\n \
    \   {\n        bool balanced = false;\n        bool max_possible_weight = false;\n\
    \    } check;\n    \n    auto sum = q.sum;\n    auto len = q.length;\n    return\
    \ check(sum, len, w);\n    \n    bool check(long sum, size_t len, long w)\n  \
    \  {\n        bool ok = false;\n        switch(len)\n        {\n            case\
    \ 0:\n                ok = true;\n                break;\n            case 1:\n\
    \                ok = q[0] <= w;\n                break;\n            default:\n\
    \                ok = checkBalanced(q, w);\n                break;\n        }\n\
    \        return ok;\n    }\n    \n    bool checkBalanced(long[] array, long w)\n\
    \    {\n        import std.algorithm;\n        import std.array;\n        auto\
    \ len = array.length;\n        auto half = len / 2;\n        auto firstHalf =\
    \ array[0 .. half];\n        auto secondHalf = array[half .. len];\n        auto\
    \ leftBalanced = firstHalf.equal(secondHalf.retro);\n        auto sum = array.sum;\n\
    \        auto maxWeight = sum <= w;\n        return leftBalanced && maxWeight;\n\
    \    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpps9dy3z4.d(32): Error: undefined identifier `check`, did you\
    \ mean struct `Check`?\\n/tmp/tmpps9dy3z4.d(34): Error: no property `sum` for\
    \ type `long[]`\\n/tmp/tmpps9dy3z4.d(36): Error: undefined identifier `check`,\
    \ did you mean struct `Check`?\\n/tmp/tmpps9dy3z4.d(50): Error: undefined identifier\
    \ `checkBalanced`\\n/tmp/tmpps9dy3z4.d(64): Error: no property `retro` for type\
    \ `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpps9dy3z4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    //long [] q = q.array;\n\
    \    //q.sort(q);\n    //q.sort(q, less, Noaa);\n    int n=q.length;\n    //q[n]=q[n]/2;\n\
    \    //q.insert(0,w);\n    //q.insert(1,w);\n    //return q.sum;\n    //int i=0;\n\
    \    //foreach(i,e;q)\n    //{\n    //    q[i] = q[i]/2;\n    //}\n    //return\
    \ q.sum;\n    //long[] r = q.dup;\n    //std.array.sort(r);\n    //auto y=r.dup;\n\
    \    //auto z=r.dup;\n    //y.sort(less, Noaa);\n    //y.sort(greater, Noaa);\n\
    \    //r.sort;\n    //r.sort(less, Noaa);\n    //r.sort(greater, Noaa);\n    //y.sort(Noaa);\n\
    \    //z.sort(Noaa);\n    //y.sort(greater, Noaa);\n    //y.reverse;\n    //y.reverse(Noaa);\n\
    \    //y.sort(greater, Noaa);\n    //y.reverse;\n    //y.reverse(Noaa);\n    //auto\
    \ test = y.opEquals(z);\n    //auto test = y.opEquals(r);\n    //int k=0;\n  \
    \  //foreach(i,e;r)\n    //{\n    //  r[i] += r[k];\n    //  k++;\n    //}\n \
    \   //auto test = y.opEquals(r);\n    //if(test == true)\n    //{\n    //  if(r.sum\
    \ <= w)\n    //  {\n    //    return true;\n    //  }\n    //  else\n    //  {\n\
    \    //    return false;\n    //  }\n    //}\n    //else\n    //{\n    //  return\
    \ false;\n    //}\n    //auto x = q.dup;\n   \nunittest\n{\n    alias candidate\
    \ = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L,\
    \ 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L,\
    \ 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n\
    \    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj6jq1uq9.d(85): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj6jq1uq9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    // check if array is palindromic\n\
    \    // w: weight\n    assert(q.length > 0);\n    assert(w > 0);\n    // palette\n\
    \    // return q.length == 1 || q.length == 2 && q[0] == q[1];\n    for (int i\
    \ = 0; i < q.length / 2; i++)\n    {\n        if (q[i] != q[q.length - i - 1])\
    \ return false;\n    }\n    // check if array is balanced\n    // return q.length\
    \ == 1 || q.length == 2 && q[0] == q[1];\n    long sum = q.sum;\n    if (sum <=\
    \ w)\n    {\n        return true;\n    }\n    return false;\n}\n/*\n    \n   \
    \ Write a function that returns the number of steps you need to do in order to\
    \ reach the end of the array.\n    Each step, you must go to the next or the previous\
    \ element, i.e. you can only move one element of the array at a time.\n    You\
    \ can only go forward if the current element is an even number and you can only\
    \ go backward if the current element is an odd number.\n    If you can't reach\
    \ the end of the array, the function should return -1.\nunittest\n{\n    alias\
    \ candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n\
    \    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L)\
    \ == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfhl07lu8.d(47): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfhl07lu8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    auto leftSideSum = q[0];\n\
    \    auto rightSideSum = q[q.length - 1];\n    for (int i = 1; i <= q.length /\
    \ 2; i++) \n    {\n        leftSideSum += q[i];\n        rightSideSum += q[q.length\
    \ - i - 1];\n        if(leftSideSum == rightSideSum && q.length % 2 == 0)\n  \
    \      {\n            if(leftSideSum + rightSideSum <= w)\n            {\n   \
    \             return true;\n            }\n            return false;\n       \
    \ }\n        if(leftSideSum > rightSideSum)\n        {\n            return false;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\
    \n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L,\
    \ 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L,\
    \ 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n\
    \    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp79dgec6i.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428255]\\n??:? void tmp79dgec6i.__unittest_L49_C1()\
    \ [0x427e5c]\\n??:? void tmp79dgec6i.__modtest() [0x427fd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c2b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b146]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4302d9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430265]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b11d]\\n??:? runModuleUnitTests [0x42c089]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428718]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42869f]\\n??:? _d_run_main [0x42860a]\\n??:? main [0x427fe7]\\\
    n??:? __libc_start_main [0x8f953554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic array) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    >>>\
    \ will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible\
    \ weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n\
    \    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n\
    \    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n\
    \    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n\
    \    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    auto max_possible_weight\
    \ = q.sum();\n    return q.isPalindrome() && max_possible_weight <= w;\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplkf5o5c7.d(28): Error: no property `sum` for type `long[]`\\\
    n/tmp/tmplkf5o5c7.d(29): Error: no property `isPalindrome` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplkf5o5c7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
