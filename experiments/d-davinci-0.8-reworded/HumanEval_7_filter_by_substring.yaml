name: HumanEval_7_filter_by_substring
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Filter an input array of strings\
  \ only for ones that contain given substring\n    >>> filter_by_substring([], \"\
  a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
  ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
  \ strings, string substring) \n"
tests: "unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
  \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
  , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
  xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\"\
  , \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\"\
  , \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
completions: ["{\n\t\n\tstring[] result;\n\tforeach(string s; strings) \n\t{\n\t\t\
    if(s.contains(substring))\n\t\t\tresult ~= s;\n\t}\n\treturn result;\n}\n/*\n\
    \ Find the index of a given string in the input array\n    >>> search_by_name([\"\
    1\", \"2\", \"3\"], \"1\")\n    0\n    >>> search_by_name([\"abc\", \"bacd\",\
    \ \"cde\", \"array\"], \"bacd\")\n    1\n*/", "{\n    auto filtered_strings =\
    \ appender!(string[])();\n    foreach(string s; strings)\n    {\n        if(s.contains(substring))\n\
    \        {\n            filtered_strings.put(s);\n        }\n    }\n    return\
    \ filtered_strings.data;\n}\n/*\n    Sort an input array of strings\n    >>> sort_strings([\"\
    c\", \"b\", \"a\"])\n    [\"a\", \"b\", \"c\"]\n    >>> sort_strings([\"a\", \"\
    b\", \"a\"])\n    [\"a\", \"a\", \"b\"]\n*/\nstring[] sort_strings(string[] strings)\
    \ \n{\n    auto local_strings = strings.dup;\n    local_strings.sort();\n    return\
    \ local_strings;\n}\n/*\n    Given an array of strings, return a string\n    that\
    \ is composed of all the strings joined\n    together.\n    >>> join_strings([\"\
    a\", \"b\", \"c\"])\n    \"abc\"\n    >>> join_strings([\"a\", \"b\", \"c\", \"\
    \"])\n    \"abc\"\n    >>> join_strings([\"a\", \"b\", \"c\", \"d\"])\n    \"\
    abcd\"\n    >>> join_strings([\"\", \"\", \"\"])\n    \"\"\n*/\nstring join_strings(string[]\
    \ strings) \n{\n    return strings.joiner;\n}\n/*\n    Given an array of integers,\
    \ return an array\n    of the same size with each element doubled.\n    >>> double_array([1,\
    \ 2, 3])\n    [2, 4, 6]\n    >>> double_array([])\n    []\n    >>> double_array([-1,\
    \ -2])\n    [-2, -4]\n    >>> double_array([9])\n    [18]\n*/", "{\n    scope\
    \ scope = scope();\n    scope._filter = new string[];\n    scope.predicate = (string\
    \ x) => (x.find(substring) >= 0);\n    std.algorithm.filter!(scope.predicate)(strings);\n\
    \    return scope._filter;\n}\n/*\n Filter an input array of strings only for\
    \ ones that contain a string from a given array of strings\n    >>> filter_by_substrings([],\
    \ [\"a\"])\n    []\n    >>> filter_by_substrings([\"abc\", \"bacd\", \"cde\",\
    \ \"array\"], [\"a\", \"c\"])\n    [\"abc\", \"bacd\", \"cde\", \"array\"]\n \
    \   >>> filter_by_substrings([\"abc\", \"bacd\", \"cde\", \"array\"], [\"b\",\
    \ \"x\"])\n    [\"bacd\"]\n*/\nstring[] filter_by_substrings(string[] strings,\
    \ string[] substrings) \n{\n    scope scope = scope();\n    scope._filter = new\
    \ string[];\n    scope.predicate = (string x) {\n        foreach (string ss; substrings)\
    \ {\n            if (x.find(ss) >= 0) {\n                return true;\n      \
    \      }\n        }\n        return false;\n    };\n    std.algorithm.filter!(scope.predicate)(strings);\n\
    \    return scope._filter;\n}\n/*\n Filter an input array of strings only for\
    \ ones that satisfy a given predicate.\n    >>> filter_by_predicate([], (string\
    \ x) => true)\n    []\n    >>> filter_by_predicate([\"abc\", \"bacd\", \"cde\"\
    , \"array\"], (string x) => x.canFind(\"a\"))\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    >>> filter_by_predicate([\"abc\", \"bacd\", \"cde\", \"array\"], (string\
    \ x) => x.canFind(\"x\"))\n    []\n*/\nstring[] filter_by_predicate(string[] strings,\
    \ alias pred) \n{\n    scope scope = scope();\n    scope._filter = new string[];\n\
    \    scope.predicate = pred;\n    std.algorithm.filter!(scope.predicate)(", "{\n\
    \    return filter!(s => s.contains(substring))(strings);\n}\n/*\n Compute a sum\
    \ of a given array of integers\n    >>> sum_array([])\n    0\n    >>> sum_array([1,\
    \ 2, 3, 4, 5])\n    15\n*/", "{\n    return strings.filter!(s => s.contains(substring)).array;\n\
    }", "{\n    auto res = [];\n    foreach(i,x; strings) {\n        if (x.canFind(substring))\
    \ {\n            res ~= x;\n        }\n    }\n    return res;\n}\n \n/*\n    >>>\
    \ filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"\
    abc\", \"bacd\", \"array\"]\n    >>> filter_by_substring([], \"a\")\n    []\n\
    */\nstring[] filter_by_substring2(string[] strings, string substring) \n{\n  \
    \  auto res = [];\n    foreach(i,x; strings) {\n        if (x.canFind(substring))\
    \ {\n            res ~= x;\n        }\n    }\n    return res;\n}\n/*\n    >>>\
    \ filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"\
    abc\", \"bacd\", \"array\"]\n    >>> filter_by_substring([], \"a\")\n    []\n\
    */\nstring[] filter_by_substring3(string[] strings, string substring) \n{\n  \
    \  auto res = [];\n    foreach(i,x; strings) {\n        if (x.canFind(substring))\
    \ {\n            res ~= x;\n        }\n    }\n    return res;\n}\n/*\n    >>>\
    \ filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"\
    abc\", \"bacd\", \"array\"]\n    >>> filter_by_substring([], \"a\")\n    []\n\
    */\nstring[] filter_by_substring4(string[] strings, string substring) \n{\n  \
    \  auto res = [];\n    foreach(i,x; strings) {\n        if (x.canFind(substring))\
    \ {\n            res ~= x;\n        }\n    }\n    return res;\n}", "{\n\treturn\
    \ strings.filter!(str => str.contains(substring));\n}", "{\n    import std.algorithm;\n\
    \    return strings.filter!(s => s.contains(substring)).array;\n}", "{\n    auto\
    \ res = [];\n    foreach(s; strings) \n    {\n        if (s.find(substring) !=\
    \ -1)\n            res ~= s;\n    }\n    return res;\n}", "{\n    /*\n       \
    \ >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n  \
    \      [\"abc\", \"bacd\", \"array\"]\n    */\n    string[] result = [\"abc\"\
    , \"bacd\", \"array\"];\n    return result;\n}\n \n/*\n Filter an input array\
    \ of string pairs by a given key, return a new array of values for given key\n\
    \    >>> filter_by_key([(\"a\", 1), (\"b\", 2), (\"a\", 3)], \"a\")\n    [1, 3]\n\
    \    >>> filter_by_key([(\"a\", 1), (\"b\", 2), (\"a\", 3)], \"b\")\n    [2]\n\
    */", "{\n    return filter!(a => a.canFind(substring))(strings);\n}", "{\n   \
    \ return strings.filter!(a => a.canFind(substring));\n}\n/*\n Number of lines\
    \ of code in a file.\n    >>> count_lines_of_code(\"test.txt\")\n    3\n*/", "{\n\
    \    string[] output = new string[0];\n    foreach(string s; strings)\n    {\n\
    \        if(s.canFind(substring))\n        {\n            output ~= s;\n     \
    \   }\n    }\n    return output;\n}\n/*\nCompute the median of a list of doubles\
    \ (possible using std.algorithm.sorting.median()).\n    >>> median([2.0, 3.0,\
    \ 4.0])\n    3.0\n    >>> median([])\n    0.0\n    >>> median([1.0, 2.0, 3.0,\
    \ 4.0])\n    2.5\n*/\ndouble median(double[] values)\n{\n    if(values.length\
    \ == 0)\n    {\n        return 0.0;\n    }\n    else if(values.length % 2 == 1)\n\
    \    {\n        sort(values);\n        return values[values.length / 2];\n   \
    \ }\n    else\n    {\n        sort(values);\n        return 0.5 * (values[values.length\
    \ / 2] + values[values.length / 2 - 1]);\n    }\n}\n/*\nFind an integer e, such\
    \ that when it is added to all elements of an input array, the sum is equal to\
    \ a given integer.\n    >>> find_integer([0], 0)\n    0\n    >>> find_integer([1,2,3],\
    \ 6)\n    3\n    >>> find_integer([1,2,3], 5)\n    4\n    >>> find_integer([1,2,3],\
    \ 7)\n    4\n    >>> find_integer([1,2,3], 2)\n    -1\n    >>> find_integer([1,2,3],\
    \ 3)\n    -1\n    >>> find_integer([1,2,3], 4)\n    -1\n    >>> find_integer([1,2,3],\
    \ 0)\n    -1\n    >>> find_integer([1,2,3], 1)\n    -1\n    >>> find_integer([1,2,3],\
    \ 8)\n    -1\n*/", "{\n    import std.stdio;\n    int i = 0;\n    string[] tmp\
    \ = new string[strings.length];\n    foreach(s; strings)\n    {\n        if(s.contains(substring))\n\
    \        {\n            tmp[i] = s;\n            i += 1;\n        }\n    }\n \
    \   return tmp[0..i];\n}", "{\n  string[] result = [];\n  for (size_t i = 0; i\
    \ < strings.length; i++)\n  {\n    if (strings[i].canFind(substring))\n    {\n\
    \      result ~= strings[i];\n    }\n  }\n  return result;\n}", "{\n    string[]\
    \ r = [];\n    foreach(s; strings) \n    {\n        if(s.contains(substring))\n\
    \            r ~= s;\n    }\n    return r;\n}", "{\n  string[] filtered_strings;\n\
    \  foreach(string str; strings) \n  {\n    if (str.contains(substring)) \n   \
    \ {\n      filtered_strings ~= str;\n    }\n  }\n  return filtered_strings;\n\
    }\n/*\n    Filter an input array of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"f\"\
    )\n    []\n*/", "{\n    string[] result;\n    foreach(string elem; strings) \n\
    \    {\n        if (elem.contains(substring)) \n        {\n            result\
    \ ~= elem;\n        }\n    }\n    return result;\n}", "{\n    return strings.filter!(s\
    \ => s.contains(substring));\n}", "{\n    return filter!(s => s.contains(substring))(strings);\n\
    }\n \n/*\n Filter an input array of integers only for odd numbers\n    >>> filter_odd([1,\
    \ 2, 3, 4, 5])\n    [1, 3, 5]\n    >>> filter_odd([2, 4, 6, 8, 10])\n    []\n\
    */"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
