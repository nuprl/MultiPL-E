name: HumanEval_79_decimal_to_binary
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number in\
  \ decimal form and your task is to convert it to\n    binary format. The function\
  \ should return a string, with each character representing a binary\n    number.\
  \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
  \ couple of characters 'db' at the beginning and at the end of the string.\n   \
  \ The extra characters are there to help with the format.\n\n    Examples:\n   \
  \ >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
  \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n"
tests: "unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
  \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
  \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
completions: ["{\n    string binary = \"db\";\n    while(decimal > 0)\n    {\n   \
    \     int i = decimal % 2;\n        binary ~= i.to!string;\n        decimal /=\
    \ 2;\n    }\n    binary ~= \"db\";\n    return binary.dup.reverse;\n}", "{\n\t\
    \n\tstring s = \"db\";\n\treturn s + to!string(decimal,2) + \"db\";\n}", "{\n\
    \    return \"db\" ~ to!string(decimal, 2) ~ \"db\";\n}", "{\n    string result\
    \ = \"db\";\n    while(decimal > 0) {\n        if(decimal % 2 == 0) {\n      \
    \      result = \"0\" ~ result;\n        } else {\n            result = \"1\"\
    \ ~ result;\n        }\n        decimal /= 2;\n    }\n    return result ~ \"db\"\
    ;\n}\n/*\n    >>>decimal_to_binary(15L)\n    \"db1111db\"\n    >>>decimal_to_binary(32L)\n\
    \    \"db100000db\"\n*/", "{\n    int size = log(decimal)/log(2) + 1;\n    char[]\
    \ result = new char[size];\n    result[] = '0';\n    for (int i = size - 1; i\
    \ >= 0; i--)\n    {\n        result[i] = (decimal & 1) ? '1' : '0';\n        decimal\
    \ >>= 1;\n    }\n    return \"db\" ~ result.idup ~ \"db\";\n}", "{\n    string\
    \ ret;\n    ret ~= \"db\";\n    if (decimal==0) {\n        ret ~= \"0\";\n   \
    \ } else {\n        while (decimal!=0) {\n            ret ~= cast(string)(decimal%2);\n\
    \            decimal/=2;\n        }\n    }\n    ret ~= \"db\";\n    return std.algorithm.reverse(ret);\n\
    }\n/*\nYou will be given a string in binary format, and your task is to convert\
    \ it to\n    decimal format. The function should return a long number, that represents\
    \ the decimal\n    representation of the given binary string.", "{\n    import\
    \ std.string : to;\n    import std.conv : to;\n    import std.format : format;\n\
    \    string s = \"\";\n    if (decimal == 0)\n        return \"db0db\";\n    else\n\
    \    {\n        foreach(i; 0..64)\n        {\n            if (decimal & (1L <<\
    \ i))\n                s ~= \"1\";\n            else\n                s ~= \"\
    0\";\n        }\n        //removing left zeros\n        while (s[$-1] == '0')\n\
    \            s = s[0..$-1];\n        //adding db at the beginning and the end\n\
    \        s = \"db\" ~ s.reverse ~ \"db\";\n        return s;\n    }\n}", "{\n\
    \    if (decimal < 0) return \"\";\n    string result = \"db\";\n    while (decimal\
    \ > 0) {\n        result += (decimal % 2 == 0) ? \"0\" : \"1\";\n        decimal\
    \ /= 2;\n    }\n    return result ~ \"db\";\n}", "{\n    string result;\n    const\
    \ int [] base = [ 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192,\
    \ 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,\
    \ 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824 ];\n\
    \    int size = base.length;\n    foreach(int i; 0..size)\n    {\n        if(decimal\
    \ == 0)\n            break;\n        else if(decimal >= base[i])\n        {\n\
    \            decimal -= base[i];\n            result ~= \"1\";\n        }\n  \
    \      else\n            result ~= \"0\";\n    }\n    return \"db\" ~ result ~\
    \ \"db\";\n}", "{\n\tenum {binary, octal, hexadecimal} num_type;\n\tnum_type =\
    \ binary;\n\tstring[] prefixes = { \"db\", \"ob\", \"ox\", \"x\" };\n\tstring\
    \ prefix = prefixes[num_type];\n\tchar[] digits = { '0', '1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\tstring res = \"\";\n\t\
    while (decimal != 0) {\n\t\tres = digits[decimal % 16] ~ res;\n\t\tdecimal /=\
    \ 16;\n\t}\n\tres = prefix ~ res ~ prefix;\n\treturn res;\n}", "{\n  char[] binary\
    \ = new char[32];\n  int start = 0;\n  int end = binary.length - 1;\n  for (long\
    \ i = 0; i < binary.length; i++)\n  {\n    long bit = decimal % 2;\n    decimal\
    \ /= 2;\n    binary[start] = (bit == 0) ? '0' : '1';\n    binary[end] = binary[start];\n\
    \    start++;\n    end--;\n  }\n  return format(\"db%sdb\", binary);\n}", "{\n\
    \    string s=\"db\";\n    while(decimal>0)\n    {\n        s+=to!string(decimal%2);\n\
    \        decimal/=2;\n    }\n    reverse(s.length-1);\n    s+=\"db\";\n    return\
    \ s;\n}", "{\n    auto result = \"db\";\n    while (decimal > 0)\n    {\n    \
    \    if (decimal % 2 == 0)\n            result ~= \"0\";\n        else\n     \
    \       result ~= \"1\";\n        decimal /= 2;\n    }\n    result ~= \"db\";\n\
    \    return result.dup.idup.rev;\n}", "{\n    string binary = \"db\";\n    if\
    \ (decimal == 0)\n        return binary + \"0\" + binary;\n    while (decimal\
    \ > 0)\n    {\n        binary += \"1\";\n        decimal -= pow(2L, find(decimal));\n\
    \    }\n    binary += \"db\";\n    return binary;\n}", "{\n    string binary;\n\
    \    binary ~= \"db\";\n    while(decimal >= 1)\n    {\n        if(decimal % 2\
    \ == 0)\n        {\n            binary ~= \"0\";\n        }\n        else\n  \
    \      {\n            binary ~= \"1\";\n        }\n        decimal /= 2;\n   \
    \ }\n    binary ~= \"db\";\n    return binary;\n}\n/*\nYou will be given a string\
    \ of binary numbers. Your task is to write a function which converts\n    it to\
    \ a decimal number.", "{\n    auto str = to!string(decimal);\n    int[] result\
    \ = new int[str.length];\n    int i = 0;\n    while (decimal > 0)\n    {\n   \
    \     result[i] = decimal % 2;\n        decimal /= 2;\n        i++;\n    }\n \
    \   string str2 = \"db\";\n    for (int j = result.length - 1; j >= 0; j--)\n\
    \    {\n        str2 ~= result[j];\n    }\n    str2 ~= \"db\";\n    return str2;\n\
    }\n \n/*\nYou are in a life or death situation and a mysterious wise man gives\
    \ you the following riddle:", "{\n    if (decimal == 0)\n        return \"db0db\"\
    ;\n    \n    enum binaryLength = to!uint(ceil(log(decimal)/log(2)));\n    string\
    \ binary = \"db\";\n    binary.length = binaryLength + 4;\n    binary[1 .. $ -\
    \ 2] = '0';\n    binary[$ - 1] = 'd';\n    binary[$ - 2] = 'b';\n    \n    while\
    \ (decimal != 0)\n    {\n        immutable remainder = cast(char)(decimal % 2);\n\
    \        if (remainder == 1)\n            binary[binaryLength] = '1';\n      \
    \  else\n            binary[binaryLength] = '0';\n        decimal /= 2;\n    \
    \    binaryLength--;\n    }\n    return binary;\n}", "{\n    enum type_symbol_long\
    \ : long \n    {\n        zero = 0L,\n        one = 1L,\n        two = 2L,\n \
    \       three = 3L,\n        four = 4L,\n        five = 5L,\n        six = 6L,\n\
    \        seven = 7L,\n        eight = 8L,\n        nine = 9L,\n        ten = 10L,\n\
    \        eleven = 11L,\n        twelve = 12L,\n        thirteen = 13L,\n     \
    \   fourteen = 14L,\n        fifteen = 15L,\n        sixteen = 16L,\n        seventeen\
    \ = 17L,\n        eighteen = 18L,\n        nineteen = 19L,\n        twenty = 20L,\n\
    \        thirty = 30L,\n        forty = 40L,\n        fifty = 50L,\n        sixty\
    \ = 60L,\n        seventy = 70L,\n        eighty = 80L,\n        ninety = 90L,\n\
    \        hundred = 100L,\n        thousand = 1000L,\n        million = 1000000L,\n\
    \        billion = 1000000000L,\n        trillion = 1000000000000L,\n        quadrillion\
    \ = 1000000000000000L,\n        quintillion = 1000000000000000000L,\n        sextillion\
    \ = 1000000000000000000000L,\n        septillion = 1000000000000000000000000L,\n\
    \        octillion = 1000000000000000000000000000L,\n        nonillion = 1000000000000000000000000000000L,\n\
    \        decillion = 1000000000000000000000000000000000L,\n        undecillion\
    \ = 1000000000000000000000000000000000000L,\n        duodecillion = 1000000000000000000000000000000000000000L,\n\
    \        tredecillion = 1000000000000000000000000000000000000000000L,\n      \
    \  quattuordecillion = 1000000000000000000000000000000000000000000000L,\n    \
    \    quindecillion = 1000000000000000000000000000000000000000000000000000L,\n\
    \        sexdecillion = 1000000000000000000000000000000000000000000000000000000L,\n\
    \        septendecillion = 1000000000000000000000000000000000000000000000000000000000L,\n\
    \        octodecillion = 10000000000000000000000000000000000000000000000000000000000000L,\n\
    \        novemdecillion = 10000000000000000000000000000000000000000000000000000000000000000L,\n\
    \        vigintillion = 100000000000000000000000000000000000000000000000000000000000000000000000L,\n\
    \        centillion = 1000000000000000000000000000000000000000000000000000000000000000000000000000000L,\n\
    \    };\n    string binary = \"db\";\n    for (int i = 1; i < 64; i++)\n    {",
  "{\n    string binary = \"db\";\n    while(decimal != 0)\n    {\n        if(decimal\
    \ % 2 == 0)\n            binary = \"0\" ~ binary;\n        else\n            binary\
    \ = \"1\" ~ binary;\n        decimal /= 2;\n    }\n    return binary ~ \"db\"\
    ;\n}\n/*\nYou will be given a list of digits in the form of a string, your task\
    \ is to add the digits up and return\n    the result. The input will be in the\
    \ form of a string, and the output should be an integer.\n    Examples:\n    >>>\
    \ add_digits(\"1234\")\n    10\n    >>> add_digits(\"423\")\n    9\n*/", "{\n\
    \    auto binary = typeof(decimal)();\n    while (decimal != 0) \n    {\n    \
    \    binary.insertFront(decimal % 2);\n        decimal /= 2;\n    }\n    return\
    \ \"db\" ~ binary.text ~ \"db\";\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
