name: HumanEval_79_decimal_to_binary
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou will be given a number in\
  \ decimal form and your task is to convert it to\n    binary format. The function\
  \ should return a string, with each character representing a binary\n    number.\
  \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
  \ couple of characters 'db' at the beginning and at the end of the string.\n   \
  \ The extra characters are there to help with the format.\n\n    Examples:\n   \
  \ >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
  \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n"
tests: "unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
  \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
  \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
completions: ["{\n    string binary = \"db\";\n    while(decimal > 0)\n    {\n   \
    \     int i = decimal % 2;\n        binary ~= i.to!string;\n        decimal /=\
    \ 2;\n    }\n    binary ~= \"db\";\n    return binary.dup.reverse;\n}", "{\n\t\
    \n\tstring s = \"db\";\n\treturn s + to!string(decimal,2) + \"db\";\n}", "{\n\
    \    return \"db\" ~ to!string(decimal, 2) ~ \"db\";\n}", "{\n    string result\
    \ = \"db\";\n    while(decimal > 0) {\n        if(decimal % 2 == 0) {\n      \
    \      result = \"0\" ~ result;\n        } else {\n            result = \"1\"\
    \ ~ result;\n        }\n        decimal /= 2;\n    }\n    return result ~ \"db\"\
    ;\n}\n/*\n    >>>decimal_to_binary(15L)\n    \"db1111db\"\n    >>>decimal_to_binary(32L)\n\
    \    \"db100000db\"\n*/", "{\n    int size = log(decimal)/log(2) + 1;\n    char[]\
    \ result = new char[size];\n    result[] = '0';\n    for (int i = size - 1; i\
    \ >= 0; i--)\n    {\n        result[i] = (decimal & 1) ? '1' : '0';\n        decimal\
    \ >>= 1;\n    }\n    return \"db\" ~ result.idup ~ \"db\";\n}", "{\n    string\
    \ ret;\n    ret ~= \"db\";\n    if (decimal==0) {\n        ret ~= \"0\";\n   \
    \ } else {\n        while (decimal!=0) {\n            ret ~= cast(string)(decimal%2);\n\
    \            decimal/=2;\n        }\n    }\n    ret ~= \"db\";\n    return std.algorithm.reverse(ret);\n\
    }\n/*\nYou will be given a string in binary format, and your task is to convert\
    \ it to\n    decimal format. The function should return a long number, that represents\
    \ the decimal\n    representation of the given binary string.", "{\n    import\
    \ std.string : to;\n    import std.conv : to;\n    import std.format : format;\n\
    \    string s = \"\";\n    if (decimal == 0)\n        return \"db0db\";\n    else\n\
    \    {\n        foreach(i; 0..64)\n        {\n            if (decimal & (1L <<\
    \ i))\n                s ~= \"1\";\n            else\n                s ~= \"\
    0\";\n        }\n        //removing left zeros\n        while (s[$-1] == '0')\n\
    \            s = s[0..$-1];\n        //adding db at the beginning and the end\n\
    \        s = \"db\" ~ s.reverse ~ \"db\";\n        return s;\n    }\n}", "{\n\
    \    if (decimal < 0) return \"\";\n    string result = \"db\";\n    while (decimal\
    \ > 0) {\n        result += (decimal % 2 == 0) ? \"0\" : \"1\";\n        decimal\
    \ /= 2;\n    }\n    return result ~ \"db\";\n}", "{\n    string result;\n    const\
    \ int [] base = [ 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192,\
    \ 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,\
    \ 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824 ];\n\
    \    int size = base.length;\n    foreach(int i; 0..size)\n    {\n        if(decimal\
    \ == 0)\n            break;\n        else if(decimal >= base[i])\n        {\n\
    \            decimal -= base[i];\n            result ~= \"1\";\n        }\n  \
    \      else\n            result ~= \"0\";\n    }\n    return \"db\" ~ result ~\
    \ \"db\";\n}", "{\n\tenum {binary, octal, hexadecimal} num_type;\n\tnum_type =\
    \ binary;\n\tstring[] prefixes = { \"db\", \"ob\", \"ox\", \"x\" };\n\tstring\
    \ prefix = prefixes[num_type];\n\tchar[] digits = { '0', '1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\tstring res = \"\";\n\t\
    while (decimal != 0) {\n\t\tres = digits[decimal % 16] ~ res;\n\t\tdecimal /=\
    \ 16;\n\t}\n\tres = prefix ~ res ~ prefix;\n\treturn res;\n}", "{\n  char[] binary\
    \ = new char[32];\n  int start = 0;\n  int end = binary.length - 1;\n  for (long\
    \ i = 0; i < binary.length; i++)\n  {\n    long bit = decimal % 2;\n    decimal\
    \ /= 2;\n    binary[start] = (bit == 0) ? '0' : '1';\n    binary[end] = binary[start];\n\
    \    start++;\n    end--;\n  }\n  return format(\"db%sdb\", binary);\n}", "{\n\
    \    string s=\"db\";\n    while(decimal>0)\n    {\n        s+=to!string(decimal%2);\n\
    \        decimal/=2;\n    }\n    reverse(s.length-1);\n    s+=\"db\";\n    return\
    \ s;\n}", "{\n    auto result = \"db\";\n    while (decimal > 0)\n    {\n    \
    \    if (decimal % 2 == 0)\n            result ~= \"0\";\n        else\n     \
    \       result ~= \"1\";\n        decimal /= 2;\n    }\n    result ~= \"db\";\n\
    \    return result.dup.idup.rev;\n}", "{\n    string binary = \"db\";\n    if\
    \ (decimal == 0)\n        return binary + \"0\" + binary;\n    while (decimal\
    \ > 0)\n    {\n        binary += \"1\";\n        decimal -= pow(2L, find(decimal));\n\
    \    }\n    binary += \"db\";\n    return binary;\n}", "{\n    string binary;\n\
    \    binary ~= \"db\";\n    while(decimal >= 1)\n    {\n        if(decimal % 2\
    \ == 0)\n        {\n            binary ~= \"0\";\n        }\n        else\n  \
    \      {\n            binary ~= \"1\";\n        }\n        decimal /= 2;\n   \
    \ }\n    binary ~= \"db\";\n    return binary;\n}\n/*\nYou will be given a string\
    \ of binary numbers. Your task is to write a function which converts\n    it to\
    \ a decimal number.", "{\n    auto str = to!string(decimal);\n    int[] result\
    \ = new int[str.length];\n    int i = 0;\n    while (decimal > 0)\n    {\n   \
    \     result[i] = decimal % 2;\n        decimal /= 2;\n        i++;\n    }\n \
    \   string str2 = \"db\";\n    for (int j = result.length - 1; j >= 0; j--)\n\
    \    {\n        str2 ~= result[j];\n    }\n    str2 ~= \"db\";\n    return str2;\n\
    }\n \n/*\nYou are in a life or death situation and a mysterious wise man gives\
    \ you the following riddle:", "{\n    if (decimal == 0)\n        return \"db0db\"\
    ;\n    \n    enum binaryLength = to!uint(ceil(log(decimal)/log(2)));\n    string\
    \ binary = \"db\";\n    binary.length = binaryLength + 4;\n    binary[1 .. $ -\
    \ 2] = '0';\n    binary[$ - 1] = 'd';\n    binary[$ - 2] = 'b';\n    \n    while\
    \ (decimal != 0)\n    {\n        immutable remainder = cast(char)(decimal % 2);\n\
    \        if (remainder == 1)\n            binary[binaryLength] = '1';\n      \
    \  else\n            binary[binaryLength] = '0';\n        decimal /= 2;\n    \
    \    binaryLength--;\n    }\n    return binary;\n}", "{\n    enum type_symbol_long\
    \ : long \n    {\n        zero = 0L,\n        one = 1L,\n        two = 2L,\n \
    \       three = 3L,\n        four = 4L,\n        five = 5L,\n        six = 6L,\n\
    \        seven = 7L,\n        eight = 8L,\n        nine = 9L,\n        ten = 10L,\n\
    \        eleven = 11L,\n        twelve = 12L,\n        thirteen = 13L,\n     \
    \   fourteen = 14L,\n        fifteen = 15L,\n        sixteen = 16L,\n        seventeen\
    \ = 17L,\n        eighteen = 18L,\n        nineteen = 19L,\n        twenty = 20L,\n\
    \        thirty = 30L,\n        forty = 40L,\n        fifty = 50L,\n        sixty\
    \ = 60L,\n        seventy = 70L,\n        eighty = 80L,\n        ninety = 90L,\n\
    \        hundred = 100L,\n        thousand = 1000L,\n        million = 1000000L,\n\
    \        billion = 1000000000L,\n        trillion = 1000000000000L,\n        quadrillion\
    \ = 1000000000000000L,\n        quintillion = 1000000000000000000L,\n        sextillion\
    \ = 1000000000000000000000L,\n        septillion = 1000000000000000000000000L,\n\
    \        octillion = 1000000000000000000000000000L,\n        nonillion = 1000000000000000000000000000000L,\n\
    \        decillion = 1000000000000000000000000000000000L,\n        undecillion\
    \ = 1000000000000000000000000000000000000L,\n        duodecillion = 1000000000000000000000000000000000000000L,\n\
    \        tredecillion = 1000000000000000000000000000000000000000000L,\n      \
    \  quattuordecillion = 1000000000000000000000000000000000000000000000L,\n    \
    \    quindecillion = 1000000000000000000000000000000000000000000000000000L,\n\
    \        sexdecillion = 1000000000000000000000000000000000000000000000000000000L,\n\
    \        septendecillion = 1000000000000000000000000000000000000000000000000000000000L,\n\
    \        octodecillion = 10000000000000000000000000000000000000000000000000000000000000L,\n\
    \        novemdecillion = 10000000000000000000000000000000000000000000000000000000000000000L,\n\
    \        vigintillion = 100000000000000000000000000000000000000000000000000000000000000000000000L,\n\
    \        centillion = 1000000000000000000000000000000000000000000000000000000000000000000000000000000L,\n\
    \    };\n    string binary = \"db\";\n    for (int i = 1; i < 64; i++)\n    {",
  "{\n    string binary = \"db\";\n    while(decimal != 0)\n    {\n        if(decimal\
    \ % 2 == 0)\n            binary = \"0\" ~ binary;\n        else\n            binary\
    \ = \"1\" ~ binary;\n        decimal /= 2;\n    }\n    return binary ~ \"db\"\
    ;\n}\n/*\nYou will be given a list of digits in the form of a string, your task\
    \ is to add the digits up and return\n    the result. The input will be in the\
    \ form of a string, and the output should be an integer.\n    Examples:\n    >>>\
    \ add_digits(\"1234\")\n    10\n    >>> add_digits(\"423\")\n    9\n*/", "{\n\
    \    auto binary = typeof(decimal)();\n    while (decimal != 0) \n    {\n    \
    \    binary.insertFront(decimal % 2);\n        decimal /= 2;\n    }\n    return\
    \ \"db\" ~ binary.text ~ \"db\";\n}", "{\n    return \"db\" ~ format(\"%b\",decimal)\
    \ ~ \"db\";\n}", "{\n    return \"db\" ~ to!string(decimal,2) ~ \"db\";\n}", "{\n\
    \    int list_of_ones_and_zeros[] = new int[128];\n    int array_index = 0;\n\
    \    int quotient;\n    int remainder;\n    string final_binary_string = \"db\"\
    ;\n    while(decimal > 0)\n    {\n        quotient = decimal / 2;\n        remainder\
    \ = decimal % 2;\n        list_of_ones_and_zeros[array_index] = remainder;\n \
    \       array_index++;\n        decimal = quotient;\n    }\n    for(int i = array_index-1;\
    \ i >= 0; i--)\n    {\n        final_binary_string ~= list_of_ones_and_zeros[i];\n\
    \    }\n    final_binary_string ~= \"db\";\n    return final_binary_string;\n}",
  "{\n\tstring binary = \"db\";\n\tstring binary_reversed = \"\";\n\tif (decimal ==\
    \ 0)\n\t{\n\t\tbinary_reversed = \"0\";\n\t}\n\telse\n\t{\n\t\twhile (decimal\
    \ > 0)\n\t\t{\n\t\t\tbinary_reversed ~= decimal % 2;\n\t\t\tdecimal /= 2;\n\t\t\
    }\n\t}\n\treturn binary ~ binary_reversed.\n\treverse.\n\tidup.\n\t\"db\";\n}",
  "{\n    return (decimal == 0 ? \"db0db\" : \"db\" ~ split(decimal.representation(2L),\
    \ \"0\")\n                                            .map!(x => \"1\" ~ \"0\"\
    (x.length - 1))\n                                            .join(\"\")\n   \
    \                                         .dropRight(1)\n                    \
    \                        .join(\"\")\n                                       \
    \     .dropRight(1)\n                                            .reverse()\n\
    \                                            .join(\"\")\n                   \
    \                         .reverse()\n                                       \
    \     .join(\"\")\n                                            .dropRight(1)\n\
    \                                            .join(\"\")\n                   \
    \                         .dropRight(1)\n                                    \
    \        .reverse()\n                                            .join(\"\")\n\
    \                                            .reverse()\n                    \
    \                        .join(\"\")\n                                       \
    \     .dropRight(1)\n                                            .join(\"\")\n\
    \                                            .dropRight(1)\n                 \
    \                           .reverse()\n                                     \
    \       .join(\"\")\n                                            .reverse()\n\
    \                                            .join(\"\")\n                   \
    \                         .dropRight(1)\n                                    \
    \        .join(\"\")\n                                            .dropRight(1)\n\
    \                                            .reverse()\n                    \
    \                        .join(\"\")\n                                       \
    \     .reverse()\n                                            .join(\"\")\n  \
    \                                          .dropRight(1)\n                   \
    \                         .join(\"\")\n                                      \
    \      .dropRight(1)\n                                            .reverse()\n\
    \                                            .join(\"\")\n                   \
    \                         .reverse()\n                                       \
    \     .join(\"\")\n                                            .dropRight(1)\n\
    \                                            .join(\"\")\n                   \
    \                         .dropRight(1)\n                                    \
    \        .reverse()\n                                            .join(\"\")\n\
    \                                            .reverse()\n                    \
    \                        .join(\"\")\n                                       \
    \     .dropRight(1)\n                                            .join(\"\")\n\
    \                                            .dropRight(1)\n                 \
    \                           .reverse()\n                                     \
    \       .join(\"\")\n                                            .reverse()\n\
    \                                            .join(\"\")\n                   \
    \                         .dropRight(1)\n                                    \
    \        .join(\"\")\n                                            .dropRight(1)\n\
    \                                            .reverse()\n                    \
    \                       ", "{\n\tstring str;\n\tstr ~= \"db\";\n\tstr ~= decimal.to!string();\n\
    \tstr ~= \"db\";\n\treturn str;\n}", "{\n    string binary;\n    int n = cast(int)\
    \ decimal;\n    int i = 0;\n    bool bit;\n    for (i = 0; n > 0; i++)\n    {\n\
    \        bit = n % 2;\n        n = n/2;\n        binary ~= bit ? \"1\" : \"0\"\
    ;\n    }\n    return binary;\n}", "{\n    enum bits = 64;\n    // extend to 64bit\n\
    \    decimal = to!(ulong)(decimal);\n    string result = \"db\";\n    while(decimal)\n\
    \    {\n        result ~= decimal % 2;\n        decimal /= 2;\n    }\n    // extend\
    \ to 64bit\n    result ~= \"0000000000000000000000000000000000000000000000000000000000000000db\"\
    ;\n    return result[$-bits..$];\n}", "{\n    bool up = true;\n    int length\
    \ = 0;\n    if (decimal < 0L) {\n        decimal = -decimal;\n        up = false;\n\
    \    }\n    int c = 0;\n    string result = \"\";\n    while (decimal >= pow(2,\
    \ c)) {\n        ++c;\n    }\n    result = \"0\" ~ result;\n    while (--c >=\
    \ 0) {\n        if (decimal >= pow(2, c)) {\n            result = \"1\" ~ result;\n\
    \            decimal -= pow(2, c);\n        } else {\n            result = \"\
    0\" ~ result;\n        }\n    }\n    return \"db\" ~ result ~ \"db\";\n}", "{\n\
    \    auto binary = to!string(decimal, 2);\n    return \"db\" ~ binary ~ \"db\"\
    ;\n}\n/*\n    Write a function that converts a binary number to decimal format.\
    \ The function should take\n    string as an argument and return a number as a\
    \ result. The string will be of length\n    1, 10, 32 or 64, so it will be a very\
    \ small number.", "{\n    string binary = \"db\";\n    if (decimal==0)\n     \
    \   return binary+'0'+'db';\n    while (decimal!=0)\n    {\n        binary+=to!string(decimal%2);\n\
    \        decimal/=2;\n    }\n    reverse(binary.ptr+2,binary.ptr+binary.length);\n\
    \    return binary+'db';\n}", "{\n    long result = decimal;\n    string result2\
    \ = \"\";\n    result2 += \"db\";\n    for(int i = 0; i < decimal; i++)\n    {\n\
    \        if(result % 2 == 0)\n        {\n            result2 += \"0\";\n     \
    \   }\n        else\n        {\n            result2 += \"1\";\n        }\n   \
    \     result /= 2;\n    }\n    result2 += \"db\";\n    return result2;\n}", "{\n\
    \    string s = \"db\";\n    if (decimal == 0)\n        return s + \"0\" + s;\n\
    \    while (decimal > 0) {\n        s += (decimal & 1) ? \"1\" : \"0\";\n    \
    \    decimal >>= 1;\n    }\n    reverse(s.begin(), s.end());\n    return s + \"\
    db\";\n}\n/*\nYou will be given a number in binary format and your task is to\
    \ convert it to\n    decimal format. The function should return a string, with\
    \ each character representing a decimal\n    number.", "{\n    // Your code goes\
    \ here\n    /*\n        - Step 1: Get an array of the numbers in reverse order\n\
    \            - Use % 2\n        - Step 2: Turn array into a string\n         \
    \   - Use an array of char, since that's what strings use\n            - foreach(n;\
    \ a)\n        - Step 3: Return formatted string\n    */\n    import std.algorithm\
    \ : reverse;\n    import std.conv : to;\n    import std.string : join;\n    auto\
    \ base = 2;\n    long dividend = decimal;\n    auto[dividend_, remainder] = divMod(dividend,\
    \ base);\n    auto digits = new char[1];\n    digits[0] = to!char(remainder);\n\
    \    while(dividend_ > 0) {\n        auto[dividend__, remainder_] = divMod(dividend_,\
    \ base);\n        digits ~= to!char(remainder_);\n        dividend_ = dividend__;\n\
    \    }\n    string bin = digits.reverse.join(\"\");\n    return \"db\" ~ bin ~\
    \ \"db\";\n}", "{\n    import std.math;\n    string binary = to!string(decimal,\
    \ 2);", "{\n    string ret;\n    foreach(idx; 0 .. 64)\n    {\n        ret ~=\
    \ \"db\";\n        ret ~= (decimal & (1 << idx)) != 0 ? \"1\" : \"0\";\n    }\n\
    \    return ret;\n}", "{\n    string s = \"db\";\n    long n = decimal;\n    while(n>0)\
    \ {\n        long remainder = n%2;\n        n /= 2;\n        s = s + to!string(remainder);\n\
    \    }\n    reverse(s);\n    s = s ~ \"db\";\n    return s;\n}", "{\n    string\
    \ myStr = \"db\";\n    if (decimal == 0) return \"db0db\";\n    while (decimal\
    \ > 0)\n    {\n        myStr ~= to!string(decimal % 2);\n        decimal /= 2;\n\
    \    }\n    return myStr.reversed ~ \"db\";\n}", "{\n    // 'db' to_string(decimal)\
    \ 'db'\n    string binary = \"db\";\n    long rem = 0;\n    long tmp = decimal;\n\
    \    while(tmp > 0)\n    {\n        rem = tmp % 2;\n        tmp = tmp / 2;\n \
    \       binary += to_string(rem);\n    }\n    binary += \"db\";\n    return binary;\n\
    }", "{\n    string r = \"db\";\n    while(decimal > 0) {\n        auto remainder\
    \ = decimal % 2;\n        r = cast(string)remainder ~ r;\n        decimal /= 2;\n\
    \    }\n    r ~= \"db\";\n    return r;\n}", "{\n    string retval = \"db\";\n\
    \    while(decimal != 0)\n    {\n        retval ~= cast(char)(decimal % 2);\n\
    \        decimal /= 2;\n    }\n    return retval ~ \"db\";\n}\n/*\nThis challenge\
    \ is similar to the previous one, but now you will be given a binary\n    string\
    \ and you have to convert it to a decimal. The function should return a long.\
    \ You will only\n    be given a valid binary string, without extra characters\
    \ at the beginning or at the end.", "{\n    // \u043F\u0440\u043E\u0431\u0435\u0433\
    \u0430\u0435\u043C\u0441\u044F \u043E\u0442 0 \u0434\u043E 100\n    // \u0432\u044B\
    \u0447\u0438\u0441\u043B\u044F\u0435\u043C \u0441\u0442\u0435\u043F\u0435\u043D\
    \u044C \u0434\u0432\u043E\u0439\u043A\u0438 2^i\n    // \u0434\u0435\u043B\u0438\
    \u043C \u043D\u0430 \u0434\u0432\u043E\u0439\u043A\u0443. \u0435\u0441\u043B\u0438\
    \ \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u0447\u043D\u043E\u0435\
    \ \u0447\u0438\u0441\u043B\u043E \u0431\u043E\u043B\u044C\u0448\u0435 \u0438\u043B\
    \u0438 \u0440\u0430\u0432\u043D\u043E \u043D\u0430\u0439\u0434\u0435\u043D\u043D\
    \u043E\u0439 \u0441\u0442\u0435\u043F\u0435\u043D\u0438\n    // \u0442\u043E \u0432\
    \ \u0431\u0438\u043D\u0430\u0440\u043D\u044B\u0439 \u043A\u043E\u0434 \u043F\u0438\
    \u0448\u0435\u043C 1 \u0438 \u0432\u044B\u0447\u0438\u0442\u0430\u0435\u043C \u0438\
    \u0437 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u0447\u043D\u043E\
    \u0433\u043E \u0447\u0438\u0441\u043B\u0430 \u043D\u0430\u0439\u0434\u0435\u043D\
    \u043D\u0443\u044E \u0441\u0442\u0435\u043F\u0435\u043D\u044C \u0434\u0432\u043E\
    \u0439\u043A\u0438\n    // \u0438\u043D\u0430\u0447\u0435 \u043F\u0438\u0448\u0435\
    \u043C 0\n    string result = \"db\";\n    if (decimal == 0)\n    {\n        result\
    \ += \"0\";\n    }\n    else\n    {\n        while (decimal != 0)\n        {\n\
    \            if (decimal % 2 == 0)\n            {\n                result += \"\
    0\";\n            }\n            else\n            {\n                result +=\
    \ \"1\";\n            }\n            decimal /= 2;\n        }\n    }\n    reverse(result.begin()\
    \ + 2, result.end());\n    result += \"db\";\n    return result;\n}", "{\n   \
    \ int i = 0;\n    char[] buffer = new char[40000];\n    for (; decimal != 0; decimal\
    \ /= 2) {\n        if (decimal % 2)\n            buffer[i++] = '1';\n        else\n\
    \            buffer[i++] = '0';\n    }\n    char[] ret = new char[i];\n    foreach\
    \ (j; 0 .. i) {\n        ret[j] = buffer[i - j - 1];\n    }\n    return \"db\"\
    \ ~ to!string(ret) ~ \"db\";\n}", "{\n  return format(\"db%0*sdb\", 64, to!string(decimal,\
    \ 2).idup);\n}", "{\n    string binary;\n    while(decimal!=0)\n    {\n      \
    \  binary = to!string(decimal % 2) ~ binary;\n        decimal /= 2;\n    }\n \
    \   return \"db\" ~ binary ~ \"db\";\n}\n/*", "{\n    // Convert to binary string\n\
    \    string result = \"\";\n    bool is_binary_digit = false;\n    while (decimal\
    \ != 0)\n    {\n        if (decimal % 2 == 1)\n        {\n            result =\
    \ \"1\" ~ result;\n            is_binary_digit = true;\n        }\n        else\
    \ if (is_binary_digit)\n        {\n            result = \"0\" ~ result;\n    \
    \    }\n        decimal /= 2;\n    }\n    // Add extra characters 'db'\n    if\
    \ (result.length != 0)\n    {\n        result = \"db\" ~ result ~ \"db\";\n  \
    \  }\n    else\n    {\n        result = \"db0db\";\n    }\n    return result;\n\
    }", "{\n  string res;\n  if (decimal == 0)\n    return \"db0db\";\n  else\n  {\n\
    \    while (decimal)\n    {\n      res = (decimal % 2 ? \"1\" : \"0\") ~ res;\n\
    \      decimal /= 2;\n    }\n    return \"db\" ~ res ~ \"db\";\n  }\n}", "{\n\t\
    string ret;\n\tret ~= \"db\";\n\twhile(decimal > 0)\n\t{\n\t\tret ~= to!string(decimal\
    \ % 2);\n\t\tdecimal /= 2;\n\t}\n\tstd.algorithm.reverse(ret);\n\tret ~= \"db\"\
    ;\n\treturn ret;\n}", "{\n    string result = \"db\";\n    foreach(l; 0..100)\n\
    \    {\n        long digit = decimal & 1;\n        result ~= to!string(digit);\n\
    \        decimal >>= 1;\n    }\n    result ~= \"db\";\n    return result;\n}",
  "{\n    const string res = \"db\";", "{\n    //Your code here.\n    string result\
    \ = \"db\";\n    int counter = 0;\n    int temp = 0;\n    if(decimal == 0)\n \
    \   {\n        result.append(\"0db\");\n        return result;\n    }\n    while(decimal\
    \ != 0)\n    {\n        temp = decimal % 2;\n        result.append(to!string(temp));\n\
    \        decimal /= 2;\n        ++counter;\n    }\n    string temp2 = \"\";\n\
    \    for(int i = counter - 1; i >= 0; --i)\n    {\n        temp2.append(result[i\
    \ + 2]);\n    }\n    temp2.append(\"db\");\n    return temp2;\n}", "{\n    string\
    \ ret = \"db\";\n    while(decimal != 0)\n    {\n        ret ~= (decimal % 2);\n\
    \        decimal /= 2;\n    }\n    ret ~= \"db\";\n    return ret;\n}", "{\n \
    \   import std.string;\n    auto output=string.init;\n    output ~= \"db\";\n\
    \    while(decimal!=0)\n    {\n      if(decimal%2==0)\n        output ~= \"0\"\
    ;\n      else\n        output ~= \"1\";\n      decimal = decimal/2;\n    }\n \
    \   output ~= \"db\";\n    return output.dup.retro;\n}\n/*\nYou will be given\
    \ a string in binary format and your task is to convert it to\n    decimal format.\
    \ The function should return a long, with the decimal number.", "{\n    import\
    \ std.stdio;\n    string binary;\n    int temp;\n    int res = decimal;\n    while(res\
    \ > 0)\n    {\n        temp = res % 2;\n        res = res / 2;\n        binary\
    \ ~= format(\"%d\", temp);\n    }\n    binary = binary.reverse;\n    return \"\
    db\" ~ binary ~ \"db\";\n}\n// Best solution \nstring decimal_to_binary(long decimal)\
    \ \n{\n    return \"db\" ~ decimal.format(\"%b\") ~ \"db\";\n}", "{\n    string\
    \ result = \"db\";\n    if (decimal == 0)\n        return result + \"0\" + \"\
    db\";\n    while (decimal > 0)\n    {\n        result += to!string(decimal % 2);\n\
    \        decimal /= 2;\n    }\n    reverse(result);\n    return result + \"db\"\
    ;\n}\n/*\nYou will be given a number of decimal digits, and your task is to return\
    \ a string with alternating\n    0s and 1s, starting with 0s. The length of the\
    \ string should be the same as the number of digits.", "{\n    int binary = 0;\n\
    \    string result;\n    int i = 1;\n    while (decimal != 0) {\n\t\tbinary +=\
    \ (decimal % 2) * i;\n\t\tdecimal /= 2;\n\t\ti *= 10;\n\t}\n    result = \"db\"\
    \ + to!string(binary) + \"db\";\n    return result;\n}\n//unittest", "{\n    enum\
    \ bint = char[];\n    bint reverse_bin(in long decimal) {\n        bint res;\n\
    \        while (decimal) {\n            res ~= (decimal & 1).to!char;\n      \
    \      decimal /= 2;\n        }\n        return res;\n    }\n    bint bina = reverse_bin(decimal);\n\
    \    string result = \"db\" ~ bina.reverse;\n    return result ~ \"db\";\n}",
  "{\n    return \"db\" ~ long_to_binary(decimal) ~ \"db\";\n}", "{\n    string s\
    \ = \"db\";\n    if (decimal == 0)\n        return s + \"0\" + s;\n    while (decimal\
    \ != 0) {\n        s += (decimal & 1).to!string;\n        decimal >>= 1;\n   \
    \ }\n    return s ~ \"db\";\n}", "{\n    return format(\"db%sdb\", std.math.toBinaryString(decimal));\n\
    }", "{\n    string r = \"db\";\n    while(decimal > 0)\n    {\n        r ~= (decimal\
    \ % 2).to!string;\n        decimal /= 2;\n    }\n    return r.reverse ~ \"db\"\
    ;\n}", "{\n    long result = 0;\n    string ret = \"db\";\n    while(decimal !=\
    \ 0) {\n        result = decimal % 2;\n        decimal /= 2;\n        ret = format!(\"\
    %d%s\", result, ret);\n    }\n    ret = format!(\"%sdb\", ret);\n    return ret;\n\
    }", "{\n    /*\n    binary = decimal\n    binary_string = \"\"\n    while (binary\
    \ > 0)\n        binary_string = binary % 2 + binary_string\n        binary /=\
    \ 2\n    return \"db\" + binary_string + \"db\"\n    */\n    string binary_string;\n\
    \    while (decimal > 0)\n    {\n        binary_string ~= (char)((decimal % 2)\
    \ + '0');\n        decimal /= 2;\n    }\n    return \"db\" ~ binary_string ~ \"\
    db\";\n}", "{\n    // your code goes here\n    int remainder;\n    string binary\
    \ = \"\";\n    while(decimal > 0)\n    {\n        remainder = decimal % 2;\n \
    \       binary = format(\"%d\", remainder) ~ binary;\n        decimal /= 2;\n\
    \    }\n    binary = \"db\" ~ binary ~ \"db\";\n    return binary;\n}", "{\n \
    \   string result = \"db\";\n    while(decimal > 0)\n    {\n        result = decimal\
    \ % 2 + result;\n        decimal /= 2;\n    }\n    return result ~ \"db\";\n}\n\
    /*\nYou will be given a number in binary format and your task is to convert it\
    \ to\n    decimal format. The function should return a string, with each character\
    \ representing a decimal\n    number.", "{\n    string res = \"db\";\n    while(decimal\
    \ > 0)\n    {\n        res = to!string(decimal % 2) ~ res;\n        decimal /=\
    \ 2;\n    }\n    return res ~ \"db\";\n}\n/*\nYou will be given a string consisting\
    \ of uppercase, lowercase, and punctuation characters.\n    Your task is to return\
    \ a string with all of the uppercase characters swapped with their lowercase\n\
    \    equivalents. And punctuation characters removed.\n    Examples:\n    >>>\
    \ swap_case(\"ProgrammingIsFun\")\n    \"pROGRAMMINGiSFUN\"\n    >>> swap_case(\"\
    I<3CS\")\n    \"i<3cs\"\n    >>> swap_case(\"1234!_?\")\n    \"1234\"\n    \n\
    */\nstring swap_case(string s) \n{\n    string res = \"\";\n    for(char c: s)\n\
    \    {\n        if(c == ' ') continue;\n        else if(c >= 'A' && c <= 'Z')\n\
    \            res ~= to!string(c.toLower());\n        else if(c >= 'a' && c <=\
    \ 'z')\n            res ~= to!string(c.toUpper());\n    }\n    return res;\n}\n\
    /*\nYou will be given an array of strings. Your task is to return a string, in\
    \ which the\n    first character of each string is present, in the order they\
    \ come in the array.", "{\n    string ans;\n    ans += \"db\";\n    auto bit_len\
    \ = cast(int)log2(decimal) + 1;\n    for (int i = 0; i < bit_len; i++)\n    {\n\
    \        auto bit = decimal & 1;\n        ans += (bit)?\"1\":\"0\";\n        decimal\
    \ >>= 1;\n    }\n    ans += \"db\";\n    return ans;\n}", "{\n    string binary\
    \ = \"db\";\n    for (int i = 0; i < 64; i++)\n    {\n        if (decimal / (pow(2,63-i))\
    \ >= 1)\n        {\n            binary += \"1\";\n            decimal = decimal\
    \ - (pow(2,63-i));\n        }\n        else\n        {\n            binary +=\
    \ \"0\";\n        }\n    }\n    binary += \"db\";\n    return binary;\n}", "{\n\
    \    int remainder;\n    string binary = \"db\";\n    while (decimal > 0)\n  \
    \  {\n        remainder = decimal % 2;\n        binary += cast(char)(remainder\
    \ + 48);\n        decimal /= 2;\n    }\n    binary += \"db\";\n    return binary;\n\
    }", "{\n    // Write your code here\n    string ret=\"db\";\n    bool first;\n\
    \    for(int i=0;i<32;i++)\n    {\n        int digit = decimal % 2;\n        ret\
    \ = format(\"%d%s\",digit,ret);\n        decimal /= 2;\n    }\n    ret += \"db\"\
    ;\n    return ret;\n}", "{\n    string bin_str;\n    int quotient = decimal;\n\
    \    int remainder = 0;\n    while (quotient != 0) {\n        remainder = quotient\
    \ % 2;\n        quotient = quotient / 2;\n        bin_str = std.string.toString(remainder)\
    \ ~ bin_str;\n    }\n    bin_str = \"db\" ~ bin_str ~ \"db\";\n    return bin_str;\n\
    }", "{\n    const int maxlen = 10;\n    immutable char[maxlen] binary = \"dbdbdbdbdb\"\
    ;\n    int len = maxlen;\n    int i = 0;\n    do {\n        binary[i] = (decimal\
    \ % 2 == 0) ? '0' : '1';\n        decimal /= 2;\n        ++i;\n    } while (decimal\
    \ != 0);\n    reverse(binary[1..i-1]);\n    len = i + 1;\n    return to!string(binary[0..len]);\n\
    }\n/*\n    Write a function that takes a number and returns the first three numbers\
    \ in its binary representation.\n    >>> first_three_bits(5L)\n    \"101\"\n \
    \   >>> first_three_bits(23L)\n    \"101\"\n*/\nstring first_three_bits(long n)\
    \ \n{\n    string s = decimal_to_binary(n);\n    return s[2..5];\n}\n/*\n    Write\
    \ a function that takes a number and returns the last three numbers in its binary\
    \ representation.\n    >>> last_three_bits(5L)\n    \"101\"\n    >>> last_three_bits(23L)\n\
    \    \"101\"\n*/\nstring last_three_bits(long n) \n{\n    string s = decimal_to_binary(n);\n\
    \    int len = s.length;\n    return s[len-4..len-1];\n}\n/*\n    Write a function\
    \ that takes a number and returns a tuple containing the first three and the last\
    \ three bits.\n    >>> last_and_first_three_bits(5L)\n    Tuple!(\"101\", \"101\"\
    )\n    >>> last_and_first_three_bits(23L)\n    Tuple!(\"101\", \"101\")\n*/\n\
    Tuple!(\"dbxxx\", \"xxxdb\") last_and_first_three_bits(long n) \n{\n    return\
    \ tuple(first_three_bits(n), last_three_bits(n));\n}\n/*\n    Given a binary string,\
    \ return true if it is a valid binary code, otherwise return false.\n    >>> test_binary_string(\"\
    db100101101db\")\n    true\n    >>> test_binary_", "{\n    const(char)[] binary\
    \ = \"db\";\n    string result = \"\";\n    while(decimal)\n    {\n        result\
    \ ~= (decimal % 2).to!string;\n        decimal /= 2;\n    }\n    return binary\
    \ ~ result ~ binary;\n}\n/*\nYou will be given a number in binary format and your\
    \ task is to convert it to\n    decimal format. The function should return a long,\
    \ with each number representing a decimal\n    number. Each character in the string\
    \ will be '0' or '1'.", "{\n    return decimal.to!string.bin;\n}\n/*\nYou will\
    \ be given a number in binary format and your task is to convert it to\n    decimal\
    \ format. The function should return a long, with each character representing\
    \ a binary\n    number. Each character in the string will be '0' or '1'.", "{\n\
    \  ulong n = decimal;\n  string bstring = \"db\";\n  do {\n    bstring ~= (n &\
    \ 1).to!string;\n  } while (n >>= 1);\n  bstring = bstring.reverse.join();\n \
    \ bstring ~= \"db\";\n  return bstring;\n}\n// Alternative Solution:\n// string\
    \ decimal_to_binary(long decimal) {\n//     string s;\n//     do\n//     {\n//\
    \         s = (decimal % 2).to!string ~ s;\n//         decimal /= 2;\n//     }\
    \ while (decimal);\n//     return \"db\" ~ s ~ \"db\";\n// }", "{\n    string\
    \ ret;\n    while(decimal)\n    {\n        ret = to!string(decimal & 1L) ~ ret;\n\
    \        decimal >>= 1;\n    }\n    return \"db\" ~ ret ~ \"db\";\n}", "{\n  \
    \  string str;\n    str ~= \"db\";\n    for(long n = decimal; n > 0; n /= 2)\n\
    \    {\n        if(n%2 == 0)\n            str ~= \"0\";\n        else\n      \
    \      str ~= \"1\";\n    }\n    if(str.length > 2)\n        str = str[0..2] ~\
    \ str[$-2..$];\n    return str;\n}", "{\n  string db = \"db\";\n  string result\
    \ = db;\n  while(decimal != 0L) {\n    long temp = decimal % 2L;\n    decimal\
    \ /= 2L;\n    result ~= to!string(temp);\n  }\n  result ~= db;\n  return result;\n\
    }", "{\n    string binary = \"db\";\n    while(decimal > 0)\n    {\n        binary\
    \ ~= to!string(decimal % 2);\n        decimal /= 2;\n    }\n    return binary\
    \ ~ \"db\";\n}", "{\n  string db = \"db\";\n  string binary = \"\";\n  while(decimal\
    \ > 0)\n  {\n    binary = to!string(decimal % 2) ~ binary;\n    decimal /= 2;\n\
    \  }\n  return \"db\" ~ binary ~ \"db\";\n}", "{\n    enum charset = \"01\";\n\
    \    string ret = \"db\";\n    if (decimal == 0)\n        ret += \"0\";\n    else\n\
    \    {\n        while (decimal > 0)\n        {\n            ret += charset[decimal\
    \ % 2];\n            decimal /= 2;\n        }\n    }\n    return ret ~= \"db\"\
    ;\n}", "{\n    string res = \"db\";\n    while(decimal > 0)\n    {\n        res\
    \ ~= (decimal % 2).to!string;\n        decimal /= 2;\n    }\n    return res ~\
    \ \"db\";\n}", "{\n    string binary = \"db\";\n    ulong tmp = cast(ulong)decimal;\n\
    \    while(tmp != 0)\n    {\n        binary = \"01\"[tmp & 1] ~ binary;\n    \
    \    tmp >>= 1;\n    }\n    binary ~= \"db\";\n    return binary;\n}\n/*\nThe\
    \ function should return a string, with each character representing a binary\n\
    \    number. Each character in the string will be '0' or '1'.", "{\n    string\
    \ result;\n    if (decimal == 0)\n        return \"db0db\";\n    while (decimal\
    \ > 0)\n    {\n        long rest = decimal % 2;\n        decimal /= 2;\n     \
    \   result = to!string(rest) ~ result;\n    }\n    return \"db\" ~ result ~ \"\
    db\";\n}", "{\n    string s = \"db\";\n    long r = 0;\n    long div = decimal;\n\
    \    long remain = 0;\n    while(div > 0)\n    {\n        r = div % 2;\n     \
    \   div = div / 2;\n        remain = decimal - div * 2;\n        decimal = div;\n\
    \        s ~= remain.to!string;\n    }\n    return s ~ \"db\";\n}", "{\n    import\
    \ std.string;\n    import std.conv;\n    return \"db\" ~ to!string(decimal, 2L)\
    \ ~ \"db\";\n}", "{\n\tstring answer = \"db\";\n\twhile(decimal)\n\t{\n\t\tanswer\
    \ += cast(char)('0' + (decimal % 2));\n\t\tdecimal /= 2;\n\t}\n\tauto result =\
    \ answer.dup;\n\tfor(auto i = answer.length; i > 2; i--)\n\t\tresult[i - 1] =\
    \ answer[answer.length - i + 2];\n\tresult ~= \"db\";\n\treturn result;\n}", "{\n\
    \    string binary = \"db\";\n    char[] ans = appender!(char[])(binary);\n  \
    \  for (; decimal > 0; decimal >>= 1)\n    {\n        ans.put(decimal & 1);\n\
    \    }\n    ans.put('d');\n    ans.put('b');\n    ans.reverse();\n    return ans.idup;\n\
    }", "{\n    // calculate index of first bit\n    uint pow = uint.max;\n    while(!(decimal\
    \ & (1L << pow)))\n        pow--;\n    uint outLen = pow+2;\n    auto out = new\
    \ string(\"db\").dup;\n    foreach(p; reverse(0..pow+1))\n    {\n        auto\
    \ bit = decimal & (1L << p);\n        if(bit) out ~= \"1\";\n        else out\
    \ ~= \"0\";\n    }\n    out ~= \"db\";\n    return out;\n}", "{\n    string binary_str\
    \ =\"db\";\n    // Check is the number is zero.\n    if (decimal == 0)\n    {\n\
    \        return binary_str + \"0\" + \"db\";\n    }\n    // Check if the number\
    \ is positive.\n    else if (decimal > 0)\n    {\n        while (decimal > 0)\n\
    \        {\n            // Use the modulo operator to test the binary digit (remainder\
    \ / bit).\n            binary_str += (decimal % 2).to!string;\n            //\
    \ Use the integer division operator to reduce the decimal number (quotient).\n\
    \            decimal /= 2;\n        }\n        // Reverse the string.\n      \
    \  binary_str = binary_str.dup.reverse;\n        // Add the end delimiter.\n \
    \       binary_str += \"db\";\n        return binary_str;\n    }\n    // Handle\
    \ negative numbers.\n    else if (decimal < 0)\n    {\n        // Get the absolute\
    \ value of the number.\n        decimal = abs(decimal);\n        while (decimal\
    \ > 0)\n        {\n            // Use the modulo operator to test the binary digit\
    \ (remainder / bit).\n            binary_str += (decimal % 2).to!string;\n   \
    \         // Use the integer division operator to reduce the decimal number (quotient).\n\
    \            decimal /= 2;\n        }\n        // Pad the end with 1's to comply\
    \ with the sign and magnitude format.\n        for (; binary_str.length < 32;)\n\
    \        {\n            binary_str += \"1\";\n        }\n        // Flip the bits.\n\
    \        binary_str = binary_str.map!(a => (a == '1') ? \"0\" : \"1\");\n    \
    \    // Add one to the string.\n        binary_str = (to!ulong(binary_str) + 1).to!string;\n\
    \        // Reverse the string.\n        binary_str = binary_str.dup.reverse;\n\
    \        // Add the end delimiter.\n        binary_str += \"db\";\n        return\
    \ binary_str;\n    }\n}", "{\n    enum {\n        len = 64,\n    };\n    static\
    \ char[len] bin = void;\n    static int index = len - 1;\n    static bool first\
    \ = true;\n    if (first) {\n        first = false;\n        foreach (i; len)\
    \ {\n            bin[i] = '0';\n        }\n    }\n    foreach (i; len) {\n   \
    \     if (decimal & 1L) {\n            bin[index] = '1';\n        } else {\n \
    \           bin[index] = '0';\n        }\n        decimal >>= 1;\n        index--;\n\
    \    }\n    return \"db\" ~ to!string(bin[index..len - 1]) ~ \"db\";\n}", "{\n\
    \    auto r = \"db\";\n    auto b = \"\";\n    while(decimal > 0)\n    {\n   \
    \     if(decimal % 2)\n            b = \"1\" ~ b;\n        else\n            b\
    \ = \"0\" ~ b;\n        decimal /= 2;\n    }\n    return r ~ b ~ r;\n}", "{\n\
    \    return \"db\" ~ bint.to!string(decimal, 2) ~ \"db\";\n}", "{\n    return\
    \ \"db\" + \"\".to(decimal ? decimal, long x => x / 2, long x => (x ? \"1\" :\
    \ \"0\") + to!string(x % 2)) + \"db\";\n}", "{\n    //Convert Decimal to Binary\n\
    \    //15\n    //0000 1111\n    //----\n    //     1\n    //    1\n    //   1\n\
    \    //  1\n    // 1\n    int [] binary = new int[to!int(log(decimal, 2)+1)];\n\
    \    long n = decimal;\n    int i=0;\n    while(n>0)\n    {\n        binary[i]\
    \ = n%2;\n        n/=2;\n        i++;\n    }\n    return \"db\" ~ to!string(binary.dup.reversed.join(\"\
    \")) ~ \"db\";\n}", "{\n    string result;\n    result ~= \"db\";\n    while(decimal\
    \ > 0)\n    {\n        result ~= decimal % 2;\n        decimal /= 2;\n    }\n\
    \    result ~= \"db\";\n    return result;\n}", "{\n    string binary;\n    while(decimal)\
    \ {\n        binary ~= decimal%2;\n        decimal /= 2;\n    }\n    return \"\
    db\" ~ binary.reverse ~ \"db\";\n}\n \n/*\nYou will be given a string in binary\
    \ format and your task is to convert it to decimal format.\n    The function should\
    \ return a long.", "{\n    auto binary_temp = \"\";\n    while(decimal > 0){\n\
    \      binary_temp = binary_temp ~ to!string(decimal % 2);\n      decimal /= 2;\n\
    \    }\n    return \"db\" ~ binary_temp.reversed ~ \"db\";\n}", "{\n    int i\
    \ = 0;\n    char[] str = new char[65];\n    do {\n        str[i++] = cast(char)('0'\
    \ + (decimal & 1));\n        decimal >>= 1;\n    } while (decimal != 0);\n   \
    \ str[i] = '\\0';\n    str.reverse;\n    auto result = \"db\" ~ str ~ \"db\";\n\
    \    return result;\n}\n/*\n    You are given a string that represents a binary\
    \ number. You need to write a function that converts\n    it to a decimal number.",
  "{\n    string result;\n    while(decimal != 0) {\n        result = \"db\" ~ to!string(decimal\
    \ & 1) ~ result;\n        decimal >>= 1;\n    }\n    return result;\n}", "{\n\
    \    string res = \"db\";\n    while(decimal != 0)\n    {\n        res ~= decimal\
    \ % 2;\n        decimal /= 2;\n    }\n    return res ~ \"db\";\n}", "{\n    string\
    \ s = \"db\";\n    while(decimal != 0L)\n    {\n        s ~= (decimal % 2L ==\
    \ 0L ? '0' : '1');\n        decimal /= 2L;\n    }\n    s ~= \"db\";\n    return\
    \ s.retro;\n}", "{\n    string res = \"db\";\n    while(decimal > 0)\n    {\n\
    \        res ~= decimal % 2;\n        decimal /= 2;\n    }\n    res ~= \"db\"\
    ;\n    return res.reverse;\n}\n/*\nNext is converting binary to decimal. Your\
    \ task is to convert the binary string\n    to a decimal number.\n    Example:\n\
    \    >>> binary_to_decimal(\"db100101db\")\n    37L\n*/", "{\n    string result;\n\
    \    while(decimal>0)\n    {\n        if(decimal%2==0) result = \"0\" ~ result;\n\
    \        else result = \"1\" ~ result;\n        decimal = decimal/2;\n    }\n\
    \    return \"db\" ~ result ~ \"db\";\n}\n/*\nUsing the decimal_to_binary function,\
    \ you will now be given a string in binary format.\n    Your task is to convert\
    \ it back to decimal format and return the decimal number.", "{\n    auto bits\
    \ = typeof(return)();\n    string binary_string;\n    if (decimal == 0)\n    {\n\
    \        binary_string = \"db0db\";\n    }\n    else\n    {\n        while (decimal\
    \ != 0)\n        {\n            bits.insert(0, decimal % 2);\n            decimal\
    \ /= 2;\n        }\n        binary_string = \"db\" ~ to!string(bits) ~ \"db\"\
    ;\n    }\n    return binary_string;\n}", "{\n    return \"db\" ~ to!string(2,\
    \ decimal) ~ \"db\";\n}", "{\n    string binary;\n    while(decimal != 0)\n  \
    \  {\n        binary ~= (decimal & 1L) ? \"1\" : \"0\";\n        decimal >>= 1;\n\
    \    }\n    return \"db\" ~ binary.reverse ~ \"db\";\n}\n/*\nYou will be given\
    \ a positive integer and your task is to convert it to the base of your choice.\n\
    \    The function should return a string, with each character representing a number\
    \ of the chosen base.\n    Each character in the string will be a digit between\
    \ 0 and 9, or a letter between A and Z.\n    The letter A, B, C, D, E, F, G, H,\
    \ I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z will be used\n    to represent\
    \ the decimal numbers 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26, 27,\n    28, 29, 30, 31, 32, 33, 34, 35 respectively.", "{\n   \
    \ string ret;\n    bool start = true;\n    while(decimal)\n    {\n        ret\
    \ = (decimal & 1 ? \"1\" : \"0\") ~ ret;\n        decimal >>= 1;\n        if(start)\n\
    \        {\n            ret = \"db\" ~ ret;\n            start = false;\n    \
    \    }\n    }\n    if(start)\n        ret = \"db0db\";\n    else\n        ret\
    \ ~= \"db\";\n    return ret;\n}", "{\n    string binary;\n    while(decimal >\
    \ 0)\n    {\n        binary = to!string(decimal%2)~binary;\n        decimal /=\
    \ 2;\n    }\n    binary = \"db\"~binary~\"db\";\n    return binary;\n}", "{\n\
    \    static const string one = \"1\";\n    static const string zero = \"0\";\n\
    \    static const string db = \"db\";\n    string bits;\n    int size = decimal.sizeof;\n\
    \    for (int i = 0; i < size; i++) {\n        if (decimal & 0x01) {\n       \
    \     bits = one ~ bits;\n        } else {\n            bits = zero ~ bits;\n\
    \        }\n        decimal >>= 1;\n    }\n    return db ~ bits ~ db;\n}", "{\n\
    \    string s = \"db\";\n    return s ~ string.format(\"%b\",decimal) ~ \"db\"\
    ;\n}\n/*\nYou will be given a string representing a binary number, and your task\
    \ is to convert it to decimal format. The function should return a long integer.",
  "{\n    if (decimal < 0)\n        decimal = decimal.to!(long);", "{\n    int byte\
    \ = 8;\n    string ret = \"db\";\n    int len = decimal.bitLength;\n    int rem\
    \ = len % byte;\n    if (rem != 0) len += (byte - rem);\n    foreach (i; 0 ..\
    \ len) \n    {\n        ret = \"0\" ~ ret;\n    }\n    foreach (i; 0 .. len) \n\
    \    {\n        if (decimal % 2 == 1) \n        {\n            ret[len - i] =\
    \ '1';\n        }\n        decimal = decimal / 2;\n    }\n    return ret ~ \"\
    db\";\n}", "{\n    int bit;\n    string result;\n    result ~= \"db\";\n    if\
    \ (decimal == 0)\n    {\n        result ~= \"0\";\n    }\n    else\n    {\n  \
    \      while (decimal != 0)\n        {\n            bit = decimal % 2;\n     \
    \       result ~= bit.to!string;\n            decimal /= 2;\n        }\n    }\n\
    \    result ~= \"db\";\n    return result;\n}\n/*\nYou will be given a number\
    \ in binary format and your task is to convert it to\n    decimal format. The\
    \ function should return a long, which is the converted number.", "{\n    const\
    \ char[] alphabet = \"01\";\n    bool firstTime = true;\n    bool cont = true;\n\
    \    bool firstDigit = true;\n    string result = \"\";\n    while(cont)\n   \
    \ {\n        int digit = decimal % 2;\n        decimal /= 2;\n        if(!firstDigit)\n\
    \        {\n            result = \"0\" ~ result;\n        }\n        else\n  \
    \      {\n            firstDigit = false;\n        }\n        if(decimal == 0)\n\
    \        {\n            if(firstTime)\n            {\n                result =\
    \ \"db\" ~ result ~ \"db\";\n                firstTime = false;\n            }\n\
    \            cont = false;\n        }\n    }\n    return result;\n}", "{\n\tstring\
    \ str = \"db\";\n\tchar[] chr;\n\twhile(decimal > 0) {\n\t\tstr ~= (cast(char)(decimal\
    \ % 2 + 48));\n\t\tdecimal /= 2;\n\t}\n\tstr ~= \"db\";\n\tchr = str[$ - 1];\n\
    \tstr = \"\";\n\tforeach(index, c; chr) {\n\t\tstr ~= c;\n\t}\n\treturn str;\n\
    }\n//*******************************************************\nstring decimal_to_binary2(long\
    \ decimal) \n{\n\treturn \"db\" ~ reverse(to!string(decimal, 2)) ~ \"db\";\n}\n\
    //*******************************************************\nstring decimal_to_binary3(long\
    \ decimal) \n{\n\treturn \"db\" ~ format(\"%=b\", decimal) ~ \"db\";\n}\n//*******************************************************\n\
    string decimal_to_binary4(long decimal) \n{\n\treturn \"db\" ~ split(to!string(decimal,\
    \ 2)) ~ \"db\";\n}\n//*******************************************************\n\
    string decimal_to_binary5(long decimal) \n{\n\treturn \"db\" ~ std.algorithm.map!(decimalToChar)(iota(decimal))\
    \ ~ \"db\";\n}\n//*******************************************************", "{\n\
    \tstring binaryStr = \"db\";\n\tint binaryInt = decimal;\n\twhile(binaryInt >\
    \ 0)\n\t{\n\t\tbinaryStr = (binaryInt % 2 == 0 ? \"0\" : \"1\") ~ binaryStr;\n\
    \t\tbinaryInt /= 2;\n\t}\n\tbinaryStr ~= \"db\";\n\treturn binaryStr;\n}", "{\n\
    \    string res;\n    long n = decimal;\n    while(n != 0)\n    {\n        res\
    \ = to!string(n % 2) ~ res;\n        n /= 2;\n    }\n    return \"db\" ~ res ~\
    \ \"db\";\n}", "{\n    string binary = \"db\";\n    // Your code goes here.\n\
    \    //return binary;\n    if(decimal == 0L) return \"db0db\";\n    if(decimal\
    \ < 0L) {\n        binary = \"db1\";\n        decimal = -decimal;\n    }\n   \
    \ while(decimal > 0L) {\n        if(decimal % 2L == 0L)\n            binary ~=\
    \ \"0\";\n        else\n            binary ~= \"1\";\n        decimal /= 2L;\n\
    \    }\n    binary ~= \"db\";\n    return binary;\n}", "{\n    string ret;\n \
    \   if (decimal == 0) {\n        ret = \"db0db\";\n    } else {\n        ret =\
    \ \"db\";\n        while (decimal > 0) {\n            ret = ret ~ cast(string)(decimal\
    \ % 2);\n            decimal /= 2;\n        }\n        ret = ret ~ \"db\";\n \
    \       ret = ret.retro;\n    }\n    return ret;\n}\n/*\nIn math, the Fibonacci\
    \ numbers are a sequence of numbers named after Leonardo Fibonacci, who wrote\n\
    about them in the early 1200s.\nThe sequence starts with 1, 1, and each subsequent\
    \ number is the sum of the previous two.", "{\n    auto a = to!(string)(decimal,\
    \ 2);\n    return a.prepend(\"db\").append(\"db\");\n}\n/*\nYou have to create\
    \ a function that takes a positive integer number and returns the next bigger\
    \ number formed by the same digits:\n    12 ==> 21\n    513 ==> 531\n    2017\
    \ ==> 2071\n    If no bigger number can be composed using those digits, return\
    \ -1:\n    9 ==> -1\n    111 ==> -1\n    531 ==> -1\n*/\nlong next_bigger(long\
    \ n) \n{\n    //Convert from long to string\n    auto str = to!(string)(n);\n\
    \    int len = str.length;\n    //Bool for checking if a bigger number can be\
    \ composed\n    bool flag = false;\n    //Loop through the string to find a smaller\
    \ char\n    for(int i = len - 1; i > 0; i--)\n    {\n        if(str[i] > str[i\
    \ - 1])\n        {\n            flag = true;\n            //Get the index of i\n\
    \            int x = i - 1;\n            //Choose a min index\n            int\
    \ min = x + 1;\n            //Loop to get the smallest index that satisfies the\
    \ statement\n            for(int j = x + 1; j < len; j++)\n            {\n   \
    \             if(str[j] > str[x] && str[j] < str[min])\n                {\n  \
    \                  min = j;\n                }\n            }\n            //Swap\
    \ x and min\n            auto t = str[x];\n            str[x] = str[min];\n  \
    \          str[min] = t;\n            //Reverse the string\n            for(int\
    \ j = x + 1; j < len; j++)\n            {\n                if(j <= len - j - 1)\n\
    \                {\n                    auto t = str[j];\n                   \
    \ str[j] = str[len - j - 1];\n                    str[len - j - 1] = t;\n    \
    \            }\n            }\n            break;\n        }\n    }\n    //If\
    \ flag is false, return -1\n    if(!flag)\n    {\n        return -1;\n    }\n\
    \   ", "{\n    auto range = map!((int r) { return r.to!char; })(\n        reduce!(\n\
    \            (string r, int x) => map!((int r) { return r.to!char; })(\n     \
    \           map!(\n                    (bool b) => b ? 1 : 0\n               \
    \ )(\n                    map!(\n                        (int x) => x == 1\n \
    \                   )(\n                        split(\n                     \
    \       format(\"%02b\", x)\n                        )\n                    )\n\
    \                )\n            )\n        )(\n            reduce!(\n        \
    \        (long r, long x) => x == 0 ? r : [r, x / 2]\n            )(\n       \
    \         [decimal]\n            )\n        )\n    );\n    string result = \"\
    db\";\n    foreach(x; range)\n    {\n        result ~= x;\n    }\n    result ~=\
    \ \"db\";\n    return result;\n}\n ", "{\n    return \"db\" ~ to!string(decimal,\
    \ 2) ~ \"db\";\n}", "{\n    string res = \"db\";\n    long denom = 1;\n    long\
    \ remainder = 0;\n    long quotient = 0;\n    long org = decimal;\n    while(denom\
    \ <= decimal)\n    {\n        denom *= 2;\n    }\n    while(denom > 1)\n    {\n\
    \        denom /= 2;\n        quotient = decimal / denom;\n        remainder =\
    \ decimal % denom;\n        if(quotient == 1)\n        {\n            res ~= \"\
    1\";\n        } else {\n            res ~= \"0\";\n        }\n        decimal\
    \ = remainder;\n    }\n    res ~= \"db\";\n    return res;\n}", "{\n    static\
    \ string bits[] = [\"db0db\", \"db1db\"];\n    static string ret;\n    static\
    \ long x;\n    if (decimal <= 1)\n        return bits[decimal];\n    else \n \
    \   {\n        ret = decimal_to_binary(decimal / 2);\n        x = decimal % 2;\n\
    \        return ret[0..^2] ~ bits[x];\n    }\n}", "{\n    string b_string = \"\
    db\";\n    if (decimal < 0)\n    {\n        b_string += \"1\";\n        decimal\
    \ = decimal * -1;\n    }\n    else\n    {\n        b_string += \"0\";\n    }\n\
    \    long l = 0;\n    long max = log2(decimal);\n    while (l <= max)\n    {\n\
    \        if (decimal >= (1 << l))\n        {\n            b_string += \"1\";\n\
    \            decimal -= (1 << l);\n        }\n        else\n        {\n      \
    \      b_string += \"0\";\n        }\n        l++;\n    }\n    b_string += \"\
    db\";\n    return b_string;\n}", "{\n    string result = \"db\";\n    while(decimal>0)\n\
    \    {\n        result~=decimal%2;\n        decimal/=2;\n    }\n    std.array.reverse(result);\n\
    \    result~=\"db\";\n    return result;\n}", "{\n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    return \"db\" + decimal.text.map!(a\
    \ => a == '0' ? \"0\" : \"1\").joiner(\"\") + \"db\";\n}", "{\n    int bin[] =\
    \ new int[200];\n    int i = 0;\n    while (decimal != 0) {\n        bin[i] =\
    \ (int) (decimal % 2);\n        decimal = decimal / 2;\n        i++;\n    }\n\
    \    string bin_string = \"db\";\n    for (int j = i - 1; j >= 0; j--) {\n   \
    \     bin_string ~= bin[j];\n    }\n    bin_string ~= \"db\";\n    return bin_string;\n\
    }", "{\n    string bin = \"db\";\n    while(decimal > 0)\n    {\n        bin +=\
    \ to!string(decimal % 2);\n        decimal /= 2;\n    }\n    return bin ~ \"db\"\
    ;\n}\n/*\nYou will be given a number in decimal form and your task is to convert\
    \ it to\n    hexadecimal format. The function should return a string, with each\
    \ character representing a hexadecimal\n    number. Each character in the string\
    \ will be '0'-'9' or 'a'-'f'.", "{\n    //write your code here\n    string res\
    \ = \"db\";\n    if (decimal == 0)\n        return res + \"0\" + \"db\";\n   \
    \ for (; decimal > 0; decimal /= 2)\n        res = res + (char)(decimal % 2 +\
    \ '0');\n    return res + \"db\";\n}", "{\n  // Convert to binary and remove the\
    \ '0b' from the beginning\n  string binary = to!string(decimal, 2)[2 .. $];\n\
    \  // Pad the string on the left with 0s until we have 32 digits\n  return \"\
    db\" ~ binary.rpad(32, '0') ~ \"db\";\n}", "{\n    string binary = \"db\";\n \
    \   while(decimal != 0)\n    {\n        binary += cast(char)(48 + (decimal % 2));\n\
    \        decimal /= 2;\n    }\n    binary += \"db\";\n    return binary;\n}\n\
    /*\n    You will be given a string, in binary format, representing a number\n\
    \    You will have to return this number as a decimal.", "{\n    // Cast to uint64\
    \ to avoid the corner case of negative values.\n    ulong binary = cast(ulong)decimal;\n\
    \    // The binary representation of decimal is reversed in binary.\n    string\
    \ result = \"db\";\n    while (binary > 0) {\n        result ~= (binary & 1);\n\
    \        binary >>= 1;\n    }\n    result ~= \"db\";\n    return result.dup.reverse;\n\
    }\n/*\n    You will be given a string of characters, consisting of binary characters.\n\
    \    The first and last characters will be 'db', which you should ignore. The\
    \ remaining characters\n    will be '0' or '1'.", "{\n    string result;\n   \
    \ while(decimal > 0)\n    {\n        result ~= to!string(decimal%2);\n       \
    \ decimal /= 2;\n    }\n    return \"db\" ~ reverse(result) ~ \"db\";\n}", "{\n\
    \t\n\tstring binary = \"db\";\n\t\n\tif(decimal == 0)\n\t{\n\t\tbinary += \"0db\"\
    ;\n\t\treturn binary;\n\t}\n\t\n\tauto digits = 0;\n\t\n\twhile(pow(2, digits)\
    \ <= decimal)\n\t{\n\t\tdigits++;\n\t}\n\t\n\tdigits--;\n\t\n\twhile(digits >=\
    \ 0)\n\t{\n\t\tif(pow(2, digits) <= decimal)\n\t\t{\n\t\t\tbinary += \"1\";\n\t\
    \t\tdecimal -= pow(2, digits);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbinary += \"0\"\
    ;\n\t\t}\n\t\tdigits--;\n\t}\n\t\n\tbinary += \"db\";\n\t\n\treturn binary;\n}",
  "{\n    enum L = long.sizeof;\n    // b = L * 8;\n    // char[L * 8 + 4] d_b;\n\
    \    char[L * 8 + 4] d_b;\n    d_b[0..2] = \"db\";\n    d_b[$ - 2..$] = \"db\"\
    ;\n    auto index = L * 8 - 1;\n    while (decimal)\n    {\n        d_b[index]\
    \ = (decimal & 1) ? '1' : '0';\n        decimal >>= 1;\n        index--;\n   \
    \ }\n    return d_b.idup;\n}\n/*\nThe function should return the number of square\
    \ matrices that can be found\n    in the given matrix. A square matrix is a matrix\
    \ of which all rows and all columns have the same\n    length, and each cell has\
    \ the same distance as the others from the main diagonal.", "{\n    string binary\
    \ = \"db\";\n    if (decimal == 0)\n        return binary + \"0\" + binary;\n\
    \    while (decimal != 0) {\n        binary += (decimal % 2).to!string;\n    \
    \    decimal /= 2;\n    }\n    return binary + \"db\";\n}", "{\n    static const\
    \ string db = \"db\";\n    string reverse_bitstring;\n    while (decimal) {\n\
    \        reverse_bitstring ~= (decimal % 2) ? '1' : '0';\n        decimal = decimal\
    \ / 2;\n    }\n    return db ~ reverse_bitstring.dup.reverse ~ db;\n}", "{\n \
    \   string ret = \"db\";\n    while(decimal > 0) {\n        if(decimal % 2 ==\
    \ 0)\n            ret = \"0\" ~ ret;\n        else\n            ret = \"1\" ~\
    \ ret;\n        decimal /= 2;\n    }\n    ret ~= \"db\";\n    return ret;\n}",
  "{\n     string binary;\n     while(decimal)\n     {\n        binary = \"0\" ~ binary;\n\
    \        if(decimal & 1)\n        {\n            binary[0] = '1';\n        }\n\
    \        decimal >>= 1;\n     }\n     return \"db\" ~ binary ~ \"db\";\n}", "{\n\
    \tstring binary =\"db\";\n\tlong i = 0;\n\tlong tmp = decimal;\n\tlong remain\
    \ = 0;\n\tlong old = 0;\n\tlong count = 0;\n\t\n\twhile(tmp > 0)\n\t{\n\t\ttmp\
    \ /= 2;\n\t\tcount++;\n\t}\n\ttmp = decimal;\n\tif(tmp == 0)\n\t{\n\t\tbinary\
    \ += \"0\";\n\t}\n\telse\n\t{\n\t\twhile(i < count)\n\t\t{\n\t\t\told = tmp;\n\
    \t\t\ttmp /= 2;\n\t\t\tremain = old - (tmp * 2);\n\t\t\tbinary += std.to!string(remain);\n\
    \t\t\ti++;\n\t\t}\n\t}\n\tbinary += \"db\";\n\treturn binary;\n}", "{\n    const\
    \ char* format = \"db%db\";\n    string result = to!string(decimal, format);\n\
    \    return result;\n}", "{\n    return std.typecons.to!string(decimal,2);\n}",
  "{\n\treturn \"db\" ~ format!(\"%b\", decimal) ~ \"db\";\n}", "{\n    string result\
    \ = \"db\";\n    while(decimal > 0) {\n        result ~= decimal % 2;\n      \
    \  decimal /= 2;\n    }\n    return result ~ \"db\";\n}", "{\n    string binary;\n\
    \    while(decimal > 0)\n    {\n        binary = (decimal % 2).to!string + binary;\n\
    \        decimal /= 2;\n    }\n    binary = \"db\" ~ binary ~ \"db\";\n    return\
    \ binary;\n}", "{\n    import std.range;\n    import std.algorithm;\n    return\
    \ \"db\" ~ decimal.bitScanReverse.map!((a) => a % 2).format(\"%s\").joiner(\"\"\
    ).joiner(\"db\");\n}", "{\n    string res = \"db\";\n    while(decimal>0)\n  \
    \  {\n        long r = decimal%2;\n        res = format(\"%s%d\",res,r);\n   \
    \     decimal /= 2;\n    }\n    return format(\"%sdb\",reverse(res));\n}", "{\n\
    \tstring out = \"db\";\n\tif (decimal == 0)\n\t\treturn out + \"0\" + \"db\";\n\
    \twhile (decimal != 0)\n\t{\n\t\tout += cast(char)((decimal & 1) + '0');\n\t\t\
    decimal >>= 1;\n\t}\n\treverse(out);\n\treturn out + \"db\";\n}", "{\n    string\
    \ binary = \"db\";\n    if (decimal == 0)\n        return binary + \"0\" + binary;\n\
    \    while (decimal != 0)\n    {\n        if (decimal % 2 == 0)\n            binary\
    \ += \"0\";\n        else\n            binary += \"1\";\n        decimal /= 2;\n\
    \    }\n    binary += \"db\";\n    return binary;\n}\n/*\n    In this exercise,\
    \ you will be given a non-empty string that represents a positive integer.\n \
    \   You must return the string in its decimal form.", "{\n    /* read more on\
    \ http://dlang.org/phobos/std_conv.html#.to!string */\n    return \"db\" ~ to!string(decimal,\
    \ \"b\") ~ \"db\";\n}", "{\n    string result;\n    // TODO: Fill in this function\n\
    \    //\n    // NOTE: This is really really easy to do in D.  For example:\n \
    \   //\n    // static assert(to!string(15L, 2) == \"1111\");\n    // static assert(to!string(32L,\
    \ 2) == \"100000\");\n    //\n    // This may help, if you think about it:\n \
    \   // http://www.digitalmars.com/d/2.0/phobos/std_conv.html#.to\n    //\n   \
    \ // ALTERNATIVELY, if you are feeling obsessive compulsive, you\n    // can go\
    \ ahead and use division and modulus, and push the\n    // correct character ('0'\
    \ or '1') onto a string or a dchar[]\n    // (which can be turned into a string).\n\
    \    return \"db\" ~ result ~ \"db\";\n}", "{\n    import std.string;\n    auto\
    \ s = to!string(decimal,2);\n    return \"db\" ~ s ~ \"db\";\n}", "{\n    return\
    \ \"db\" ~ to!string(decimal,2) ~ \"db\";\n}", "{\n    string res = \"db\";\n\
    \    if (decimal > 1)\n    {\n        while (decimal != 0)\n        {\n      \
    \      if (decimal % 2 == 0)\n            {\n                res ~= \"0\";\n \
    \           }\n            else\n            {\n                res ~= \"1\";\n\
    \            }\n            decimal /= 2;\n        }\n    }\n    else\n    {\n\
    \        res ~= \"1\";\n    }\n    res ~= \"db\";\n    return res.dup.reverse;\n\
    }", "{\n    string binary = \"db\";\n    auto p = 2;\n    while(decimal > 0)\n\
    \    {\n        binary ~= (decimal % 2).to!string;\n        decimal /= 2;\n  \
    \  }\n    binary ~= \"db\";\n    return binary[$-2..$].dup.reverse;\n}", "{\n\
    \    long temp = decimal;\n    string binary_string = \"db\";\n    int i = 0;\n\
    \    for(;;)\n    {\n        i++;\n        if(temp == 0) break;\n        if(temp%2\
    \ == 0) binary_string += \"0\";\n        else binary_string += \"1\";\n      \
    \  temp /= 2;\n    }\n    binary_string += \"db\";\n    return binary_string;\n\
    }", "{\n    // version 1\n    string result = \"db\";\n    long number = decimal;\n\
    \    while (number > 0)\n    {\n        result = \"db\" ~ to!string(number % 2)\
    \ ~ result;\n        number /= 2;\n    }\n    return result;\n    \n    // version\
    \ 2\n    //string result = \"db\";\n    //string bits = \"\";\n    //while (decimal\
    \ > 0)\n    //{\n    //    bits = to!string(decimal % 2) ~ bits;\n    //    decimal\
    \ /= 2;\n    //}\n    //return result ~ bits ~ \"db\";\n}", "{\n    string result;\n\
    \    long power = 0L;\n    long value = decimal;\n    while(value > 0L)\n    {\n\
    \        result = (value % 2L == 0L ? \"0\" : \"1\") ~ result;\n        value\
    \ = value / 2L;\n    }\n    return \"db\" ~ result ~ \"db\";\n}", "{\n    \n \
    \   int size = 0;\n    ulong temp = decimal;\n    while(temp>0)\n    {\n     \
    \   temp/=2;\n        size++;\n    }\n    string str;\n    string tempstr;\n \
    \   if(size==0)\n    {\n        str=\"db0db\";\n        return str;\n    }\n \
    \   for(int i=0;i<size;i++)\n    {\n        str~=decimal%2;\n        decimal/=2;\n\
    \    }\n    str~=\"db\";\n    for(int i=str.length-1;i>=0;i--)\n    {\n      \
    \  tempstr~=str[i];\n    }\n    return tempstr;\n}", "{\n    string result;\n\
    \    foreach(int;0..8)\n    {\n        result ~= to!string(decimal%2);\n     \
    \   decimal /= 2;\n    }\n    return \"db\" ~ result ~ \"db\";\n}", "{\n    return\
    \ \"db\" + format(\"%b\", decimal) + \"db\";\n}", "{\n    auto result = \"db\"\
    ;\n    for (; decimal != 0; decimal /= 2)\n    {\n        result ~= (decimal %\
    \ 2).to!string;\n    }\n    result ~= \"db\";\n    return reverse(result);\n}",
  "{\n    string result = \"db\";\n    long temp;\n    ulong maxULong = 2UL * (ulong.max\
    \ / 2) + 1;\n    do \n    {\n        temp = decimal;\n        decimal /= 2;\n\
    \        if(temp % 2 == 0) \n        {\n            result = '0' + result;\n \
    \       }\n        else \n        {\n            result = '1' + result;\n    \
    \    }\n    } while(decimal != 0);\n    return result ~ \"db\";\n}", "{\n    string\
    \ result = \"db\";\n    while(decimal > 0) {\n        result ~= cast(char)(decimal\
    \ % 2 + 48);\n        decimal /= 2;\n    }\n    reverse(result);\n    result ~=\
    \ \"db\";\n    return result;\n}", "{\n    string binary;\n    int res;\n    bool\
    \ negative = false;\n    enum bool negative_true = true;\n    if (decimal < 0)\
    \ {\n        decimal = -decimal;\n        negative = true;\n    }\n    while (decimal\
    \ != 0) {\n        res = decimal % 2;\n        decimal /= 2;\n        binary ~=\
    \ to!string(res);\n    }\n    if (negative) {\n        enum bool is_even = false;\n\
    \        binary ~= to!string(2);\n        for (int i = 0; i < binary.length; i++)\
    \ {\n            if (binary[i] == '0') {\n                binary[i] = '1';\n \
    \           } else {\n                binary[i] = '0';\n            }\n      \
    \      if (i == 0) {\n                if (binary[i] == '0') {\n              \
    \      binary[i] = '1';\n                } else {\n                    binary[i]\
    \ = '0';\n                    is_even = true;\n                }\n           \
    \ }\n        }\n        if (is_even) {\n            binary ~= to!string(1);\n\
    \        } else {\n            binary ~= to!string(0);\n        }\n    }\n   \
    \ return \"db\" ~ binary.reverse ~ \"db\";\n}", "{\n    string binary;\n    for(;\
    \ decimal != 0; decimal /= 2)\n    {\n        if(decimal % 2 == 0)\n         \
    \   binary ~= \"0\";\n        else\n            binary ~= \"1\";\n    }\n    binary\
    \ ~= \"db\";\n    binary = binary.reverse();\n    binary = \"db\" ~ binary;\n\
    \    return binary;\n}", "{\n    string res = \"db\";\n    long digit = (decimal\
    \ != 0) ? 1L : 0L;\n    while (true)\n    {\n        digit *= 2;\n        res\
    \ += \"0\";\n        if (digit > decimal)\n            break;\n    }\n    res\
    \ += \"1\";\n    decimal -= digit / 2;\n    while (decimal != 0)\n    {\n    \
    \    digit = (decimal != 0) ? 1L : 0L;\n        while (true)\n        {\n    \
    \        digit *= 2;\n            res += \"0\";\n            if (digit > decimal)\n\
    \                break;\n        }\n        res += \"1\";\n        decimal -=\
    \ digit / 2;\n    }\n    return res + \"db\";\n}\n/*\nYou will be given a binary\
    \ string and your task is to convert it to a decimal number.\n    You will return\
    \ an integer.", "{\n    static string map = \"01\";\n    static char [] result;\n\
    \    int i = 0;\n    long remainder;\n    result = new char[65];\n    for (i =\
    \ 0; i < 65; i++) {\n        result[i] = '0';\n    }\n    result[0] = 'd';\n \
    \   result[1] = 'b';\n    i = 2;\n    while (decimal != 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        result[i] = map[remainder];\n\
    \        i++;\n    }\n    result[i] = 'd';\n    result[i + 1] = 'b';\n    result\
    \ = result.take(i + 2);\n    result = result.reverse;\n    return result.idup;\n\
    }", "{\n    static ubyte[] bin_b = \"db\";\n    static ubyte[] bin_0 = \"0\";\n\
    \    static ubyte[] bin_1 = \"1\";\n    string binary;\n    int exponent = 0;\n\
    \    int multiplier = 1;\n    bool bit = false;\n    binary ~= bin_b;\n    while(\
    \ multiplier <= decimal ) {\n        exponent++;\n        multiplier *= 2;\n \
    \   }\n    exponent--;\n    for( int i = exponent; i >= 0; i-- ) {\n        bit\
    \ = false;\n        if( (decimal / (int)pow(2, i)) >= 1 ) {\n            decimal\
    \ -= (int)pow(2, i);\n            bit = true;\n        }\n        if( bit ) {\n\
    \            binary ~= bin_1;\n        } else {\n            binary ~= bin_0;\n\
    \        }\n    }\n    binary ~= bin_b;\n    return binary;\n}", "{\n    enum\
    \ d2b = \"db\";\n    string output = \"\";\n    ulong uDecimal = cast(ulong)decimal;\n\
    \    while(uDecimal != 0)\n    {\n        output = \"01\"[uDecimal & 1] ~ output;\n\
    \        uDecimal >>= 1;\n    }\n    if(output.length > 0)\n        return d2b\
    \ ~ output ~ d2b;\n    else\n        return d2b ~ \"0\" ~ d2b;\n}", "{\n    string\
    \ binary(decimal.stringof);\n    binary = binary.replace(\"0\",\"db0\");\n   \
    \ binary = binary.replace(\"1\",\"db1\");\n    binary = binary.replace(\"2\",\"\
    db10\");\n    binary = binary.replace(\"3\",\"db11\");\n    binary = binary.replace(\"\
    4\",\"db100\");\n    binary = binary.replace(\"5\",\"db101\");\n    binary = binary.replace(\"\
    6\",\"db110\");\n    binary = binary.replace(\"7\",\"db111\");\n    binary = binary.replace(\"\
    8\",\"db1000\");\n    binary = binary.replace(\"9\",\"db1001\");\n    return binary;\n\
    }", "{\n    string binary = \"db\";\n    if (decimal == 0) return binary + \"\
    0\" + binary;\n    long n = 2;\n    for (n = 2; n < decimal; n*=2);\n    if (n\
    \ != decimal) n /= 2;\n    while (n > 0) {\n        if (decimal >= n) {\n    \
    \        binary += \"1\";\n            decimal -= n;\n        } else {\n     \
    \       binary += \"0\";\n        }\n        n /= 2;\n    }\n    return binary\
    \ + binary;\n}\n/*\nYou will be given a string and your task is to return a tuple\
    \ containing\n    three strings, in the order:\n        - the input string with\
    \ the first character capitalized\n        - the input string in reverse\n   \
    \     - the input string in uppercase\n*/\ntuple(string, string, string) mixed_case(string\
    \ input)\n{\n    return tuple(\n        input[0].uppercased ~ input[1..$],\n \
    \       input[$..0],\n        input.toUpper\n    );\n}\n/*\nCreate a function\
    \ that takes a string (word) and a string (sentence), and returns\n    a string.\
    \ The function should capitalize the first letter of each word in the sentence,\n\
    \    and return the resulting sentence.", "{\n    bool negative = decimal < 0L;\n\
    \    if (negative) decimal = -decimal;\n    auto digits = new string;\n    while\
    \ (decimal > 0L) {\n        digits ~= (decimal & 1L) ? '1' : '0';\n        decimal\
    \ = decimal >> 1L;\n    }\n    digits = digits.reverse;\n    if (negative) digits\
    \ ~= '1';\n    else digits ~= '0';\n    auto padding = 8 - digits.length;\n  \
    \  if (padding > 0) digits = '0'.repeat(padding) ~ digits;\n    return \"db\"\
    \ ~ digits ~ \"db\";\n}", "{\n    string ret = \"db\";\n    while(decimal)\n \
    \   {\n        ret ~= cast(char)((decimal % 2) + '0');\n        decimal /= 2;\n\
    \    }\n    ret ~= \"db\";\n    return ret.dup.mirror;\n}\n/*\nYou will be given\
    \ a string consisting of letters a-z (in random case), numbers and the\n    question\
    \ mark symbol.", "{\n    string result = \"db\";\n    bool isNegative = decimal\
    \ < 0;\n    decimal = abs(decimal);\n    if (decimal == 0)\n        return \"\
    db0db\";\n    while (decimal > 0)\n    {\n        result ~= (decimal & 1) ? \"\
    1\" : \"0\";\n        decimal >>= 1;\n    }\n    if (isNegative)\n        result\
    \ ~= \"1\";\n    else\n        result ~= \"0\";\n    return std.algorithm.reverse(result)\
    \ ~ \"db\";\n}", "{\n    string binary;\n    binary.append(\"db\");\n    while(decimal\
    \ > 0)\n    {\n        if(decimal%2 == 0)\n        {\n            binary.append(\"\
    0\");\n        }\n        else\n        {\n            binary.append(\"1\");\n\
    \        }\n        decimal /= 2;\n    }\n    binary.append(\"db\");\n    binary\
    \ = binary.dup.reverse;\n    return binary;\n}", "{\n  //  5  0\n  // 3  2\n \
    \ // 2  1\n  // 1  0\n  string binary;\n  for(int i = 0; i < decimal.sizeof *\
    \ 8; i++)\n  {\n      binary ~= decimal & 1;\n      decimal = decimal >> 1;\n\
    \  }\n  // Reverse the string.\n  binary = binary.dup.reverse;\n  return \"db\"\
    \ ~ binary ~ \"db\";\n}", "{\n    //your code here\n}", "{\n    string result\
    \ = \"db\";\n    bool is_a_one = false;\n    if (decimal == 0) {\n        result\
    \ = \"db0db\";\n    }\n    while (decimal != 0) {\n        if (decimal % 2 ==\
    \ 1) {\n            is_a_one = true;\n            result = \"1\" ~ result;\n \
    \       } else {\n            if (is_a_one) {\n                result = \"0\"\
    \ ~ result;\n            }\n        }\n        decimal /= 2;\n    }\n    return\
    \ result ~ \"db\";\n}", "{\n    string rs = \"db\";\n    if (decimal == 0) return\
    \ rs + \"0\" + rs;\n    long m = decimal;\n    while (m != 0)\n    {\n       \
    \ int i = m % 2;\n        rs = (i == 0) ? \"0\" + rs : \"1\" + rs;\n        m\
    \ = m / 2;\n    }\n    return rs + rs;\n}", "{\n    \n    string binary = \"db\"\
    ;\n    while(decimal != 0)\n    {\n        if(decimal % 2 == 0)\n        {\n \
    \           binary += \"0\";\n        }\n        else\n        {\n           \
    \ binary += \"1\";\n        }\n        decimal /= 2;\n    }\n    binary += \"\
    db\";\n    return binary;\n}", "{\n    string result;\n    int i = 0;\n    while(decimal\
    \ > 0)\n    {\n        int x = decimal % 2;\n        if(x == 0)\n            result\
    \ = \"0\" ~ result;\n        else\n            result = \"1\" ~ result;\n    \
    \    decimal /= 2;\n    }\n    while(i < 4)\n    {\n        result = \"0\" ~ result;\n\
    \        i++;\n    }\n    return \"db\" ~ result ~ \"db\";\n}\n/*\nWrite a function\
    \ that takes a string and a character, and returns the number of occurences of\n\
    \    the character in the string.\n    Examples:\n    >>> count_characters(\"\
    The quick brown fox jumps over the lazy dog\", 'o')\n    2\n    >>> count_characters(\"\
    The quick brown fox jumps over the lazy dog\", 'q')\n    1\n    >>> count_characters(\"\
    The quick brown fox jumps over the lazy dog\", '?')\n    0\n*/", "{\n    //TO\
    \ DO: Write the function that converts decimal to binary\n    return \"\";\n}",
  "{\n    string ret = \"db\";\n    while(decimal > 0) {\n        long temp = decimal\
    \ / 2;\n        ret ~= to!string(decimal - 2 * temp);\n        decimal = temp;\n\
    \    }\n    ret ~= \"db\";\n    return ret;\n}", "{\n  enum binary = {'0', '1'};\n\
    \  auto i = decimal;\n  string bin;\n  while(i>0)\n  {\n    int rem = i%2;\n \
    \   bin ~= binary[rem];\n    i/=2;\n  }\n  return \"db\" ~ bin.reverse ~ \"db\"\
    ;\n}", "{\n    static char[] bin_form = [ '0', '1' ];\n    static char[] db =\
    \ \"db\";\n    char[] result;\n    int index;\n    long[size_t] results;\n   \
    \ size_t i;\n    long current;\n    int temp;\n    while (decimal > 0) {\n   \
    \     results ~= decimal % 2;\n        decimal /= 2;\n    }\n    result.length\
    \ = results.length + 2;\n    result[] = db;\n    foreach (i, current; results)\
    \ {\n        result[result.length - i - 1] = bin_form[current];\n    }\n    result[result.length\
    \ - 1] = db[1];\n    return result.idup;\n}\n/*\nAs a soldier you are obliged\
    \ to die for your country. Your death rate will be calculated as a number\n  \
    \  between 0-1, 0 means you are alive, 1 means you are dead. This number is calculated\
    \ by the\n    following formula:", "{\n    string binary = \"db\";\n    while(decimal\
    \ != 0)\n    {\n        binary += to!string(decimal % 2);\n        decimal /=\
    \ 2;\n    }\n    reverse(binary.begin() + 2, binary.end());\n    binary += \"\
    db\";\n    return binary;\n}", "{\n    string binary;\n    enum binaryEnum = \"\
    01\";\n    while(decimal > 0)\n    {\n        binary ~= binaryEnum[decimal % 2];\n\
    \        decimal /= 2;\n    }\n    return \"db\" ~ binary.reverse ~ \"db\";\n}",
  "{\n    return format(\"db%sdb\", std.math.toBinaryString(decimal));\n}", "{\n\t\
    string res;\n\tres = \"db\";\n\tint i = 0;\n\twhile (decimal > 0)\n\t{\n\t\tres\
    \ += to!string(decimal % 2);\n\t\tdecimal /= 2;\n\t}\n\t\n\tres += \"db\";\n\t\
    \n\tres = res.dup.reverse;\n\t\n\treturn res;\n}\n/*\nYou will be given a string\
    \ and you need to convert it to a decimal number. The string will contain\n  \
    \  binary numbers (0 and 1). Your function should return an int.", "{\n    string\
    \ binary = \"db\";\n    while(decimal != 0) {\n        binary ~= (decimal % 2).to!string;\n\
    \        decimal /= 2;\n    }\n    binary ~= \"db\";\n    return binary.dup.reverse;\n\
    }\n/*\nYou will be given a binary number in the form of a string.\n    The string\
    \ will have the characters 'db' at the beginning and at the end,\n    and each\
    \ character inside the string will be either '0' or '1'. The function must return\
    \ the number\n    in decimal format.", "{\n    // long bits = (sizeof(long) *\
    \ 8);\n    long bits = 64;\n    // long bits = 4;\n    // long bits = 64;\n  \
    \  string ret_val = \"db\";\n    for (long i = 0; i < bits; i++) {\n        //\
    \ ret_val ~= (((decimal & 0x8000000000000000UL) != 0UL) ? \"1\" : \"0\");\n  \
    \      ret_val ~= (((decimal & (0x1UL << (bits - i - 1))) != 0UL) ? \"1\" : \"\
    0\");\n        // ret_val ~= (((decimal & 0x1UL) != 0UL) ? \"1\" : \"0\");\n \
    \       // decimal = decimal >> 1;\n    }\n    ret_val ~= \"db\";\n    return\
    \ ret_val;\n}", "{\n    string binary;\n    binary ~= \"db\";\n    if (decimal\
    \ == 0)\n    {\n        binary ~= \"0\";\n    }\n    else\n    {\n        long\
    \ i = decimal;\n        while (i != 0)\n        {\n            binary ~= to!string(i\
    \ % 2);\n            i /= 2;\n        }\n    }\n    binary ~= \"db\";\n    binary\
    \ = binary.dup.reverse;\n    return binary;\n}", "{\n    string bin = \"db\";\n\
    \    while(decimal>1)\n    {\n        bin += decimal%2.to!string;\n        decimal\
    \ /= 2;\n    }\n    bin += decimal.to!string;\n    bin += \"db\";\n    return\
    \ bin;\n}", "{\n    string binary = \"db\";\n    while(decimal != 0) {\n     \
    \   int temp = decimal % 2;\n        binary = to!string(temp) ~ binary;\n    \
    \    decimal /= 2;\n    }\n    binary ~= \"db\";\n    return binary;\n}", "{\n\
    \    long binary = 0;\n    int base = 1;\n    int rem;\n    string str;\n    while\
    \ (decimal > 0) {\n        rem = decimal % 2;\n        binary = binary + rem *\
    \ base;\n        decimal = decimal / 2;\n        base = base * 10;\n    }\n  \
    \  string bin = to!string(binary);\n    str = \"db\" ~ bin ~ \"db\";\n    return\
    \ str;\n}\n/*\nIn a temple there are N bells that ring at regularly spaced time\
    \ intervals throughout the day.", "{\n    string res = \"db\";\n    while(decimal\
    \ > 0)\n    {\n        res ~= cast(char)(decimal % 2);\n        decimal /= 2;\n\
    \    }\n    reverse(res);\n    res ~= \"db\";\n    return res;\n}", "{\n    string\
    \ result = \"db\";\n    int num = cast(int)decimal;\n    while(num > 0)\n    {\n\
    \        result ~= num % 2;\n        num /= 2;\n    }\n    // \u7FFB\u8F6C\u5B57\
    \u7B26\u4E32\n    result = reverse(result);\n    return result ~ \"db\";\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
