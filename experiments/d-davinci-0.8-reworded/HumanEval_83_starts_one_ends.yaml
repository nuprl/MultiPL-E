name: HumanEval_83_starts_one_ends
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
  \ n, return the count of the numbers of n-digit\n    positive integers that start\
  \ or end with 1.\n    \n*/\nlong starts_one_ends(long n) \n"
tests: "unittest\n{\n    alias candidate = starts_one_ends;\n\n    assert(candidate(1L)\
  \ == 1L);\n    assert(candidate(2L) == 18L);\n    assert(candidate(3L) == 180L);\n\
  \    assert(candidate(4L) == 1800L);\n    assert(candidate(5L) == 18000L);\n}\n\
  void main(){}"
completions: ["{\n    return ((n-1)*9) + (int)pow(10, (n-1));\n}", "{ \n    if (n==1)\
    \ return 1;\n    long ans = 1;\n    for (size_t i=1; i<n-1; i++) \n        ans\
    \ *= 9;\n    return ans * 2;\n}", "{\n    if (n == 1) return 2;\n    if (n ==\
    \ 2) return 3;\n    auto a = starts_one_ends(n - 1);\n    auto b = starts_one_ends(n\
    \ - 2);\n    return a + 2 * b;\n}\nlong starts_one_ends_dp(long n) \n{\n    long[long]\
    \ memo;\n    memo[1] = 2;\n    memo[2] = 3;\n    for (long i = 3; i <= n; i++)\
    \ \n    {\n        memo[i] = memo[i - 1] + 2 * memo[i - 2];\n    }\n    return\
    \ memo[n];\n}", "{\n    long res = 0;\n    if (n <= 1)\n        return n;\n  \
    \  n--;\n    res += pow(10, n);\n    res += starts_one_ends(n);\n    return res;\n\
    }\nlong starts_one_ends_2(long n) \n{\n    long res = 0;\n    if (n <= 1)\n  \
    \      return n;\n    n--;\n    res += pow(10, n);\n    res += starts_one_ends_2(n);\n\
    \    return res;\n}", "{\n    if (n < 1)\n        return 0;\n    long ret = 0;\n\
    \    long ones = 1;\n    long ten_power = 10;\n    long p = (long) pow(10.0, n\
    \ - 1);\n    for (long n_digits = 1; n_digits <= n; ++n_digits) {\n        ret\
    \ += ones;\n        ones = 9 * ones + p;\n        p /= 10;\n    }\n    return\
    \ ret;\n}\nstatic assert(starts_one_ends(1) == 2);\nstatic assert(starts_one_ends(2)\
    \ == 2);\nstatic assert(starts_one_ends(3) == 3);\nstatic assert(starts_one_ends(4)\
    \ == 4);\nstatic assert(starts_one_ends(5) == 5);\nstatic assert(starts_one_ends(6)\
    \ == 6);\nstatic assert(starts_one_ends(7) == 7);\nstatic assert(starts_one_ends(8)\
    \ == 8);\nstatic assert(starts_one_ends(9) == 9);\nstatic assert(starts_one_ends(10)\
    \ == 10);\nstatic assert(starts_one_ends(11) == 11);\nstatic assert(starts_one_ends(12)\
    \ == 12);\nstatic assert(starts_one_ends(13) == 13);\nstatic assert(starts_one_ends(14)\
    \ == 14);\nstatic assert(starts_one_ends(15) == 15);\nstatic assert(starts_one_ends(16)\
    \ == 16);\nstatic assert(starts_one_ends(17) == 17);\nstatic assert(starts_one_ends(18)\
    \ == 18);\nstatic assert(starts_one_ends(19) == 19);\nstatic assert(starts_one_ends(20)\
    \ == 20);\nstatic assert(starts_one_ends(21) == 21);\nstatic assert(starts_one_ends(22)\
    \ == 22);\nstatic assert(starts_one_ends(23) == 23);\nstatic assert(starts_one_ends(24)\
    \ == 24);\nstatic assert(starts_one_ends(25)", "{\n    if (n <= 1) \n        return\
    \ 0;\n    assert(n > 1);\n    // Treating the number as base-10, each digit has\
    \ 10 choices (0-9).\n    // But each digit can only be 1 if that digit is the\
    \ first digit.\n    // So the way I see it, we have 10 choices for the first digit,\
    \ and\n    // 10 choices for the last digit.\n    // But then the remaining digits\
    \ can be anything from 1-9, so we have\n    // 9 choices for each of those.\n\
    \    long choices = 10 * 10 * pow(9, n - 2);\n    return choices;\n}\nlong count_1(long\
    \ n)\n{\n    long sum = 0;\n    for (long i = 1; i <= n; ++i) \n        sum +=\
    \ starts_one_ends(i);\n    return sum;\n}", "{\n    long n_bits = n * (n + 1)\
    \ / 2;\n    if (n == 1) return 2;\n    long count = 0;\n    foreach (i; 1 .. n)\n\
    \    {\n        count += (1 << (n_bits - i * (i + 1) / 2));\n    }\n    return\
    \ count;\n}", "{\n    return n * (n - 1) * pow(9, n - 2);\n}", "{\n    if (n ==\
    \ 1)\n        return 1;\n    long c = 0;\n    if (n % 2 == 0)\n        c += starts_one_ends(n\
    \ - 1);\n    if (n % 2 == 1)\n        c += starts_one_ends(n - 1) * 9;\n    return\
    \ c;\n}", "{\n    long result = 0;\n    if (n == 1) {\n        result = 1;\n \
    \   } else if (n == 2) {\n        result = 11;\n    } else {\n        result =\
    \ 9;\n        for (long i = 1; i < n - 1; i++) {\n            result *= 9;\n \
    \       }\n        result += starts_one_ends(n - 1);\n    }\n    return result;\n\
    }", "{\n  /*\n      https://oeis.org/A088286\n      A088286 \t   Number of n-digit\
    \ numbers starting and ending with 1. \n                   9 n^2 + n, n >= 1.\
    \ \n  */\n  if (n == 1) return 9;\n  return (n*n + n) * 9;\n}\nlong starts_one_ends_runtime(long\
    \ n) \n{\n  long ans = 0;\n  for (long i = 1; i < 10; i++) {\n    for (long j\
    \ = 1; j < 10; j++) {\n      long s = to!string(i^pow(10, n-1));\n      long e\
    \ = to!string(j^pow(10, n-1));\n      long m = to!string(i^e);\n      auto a =\
    \ to!(string[])(m.to!string());\n      bool valid = true;\n      for (long k =\
    \ 0; k < a.length; k++) {\n        if (a[k] != \"1\") {\n          valid = false;\n\
    \          break;\n        }\n      }\n      if (valid) {\n        ans++;\n  \
    \    }\n    }\n  }\n  return ans;\n}", "{\n    long[long] fib_one = [0:0, 1:1];",
  "{ \n    long digit, result = 0; \n  \n    for (digit = 1; digit <= n; digit++)\
    \ \n        result += (long)pow(10, digit - 1); \n    return result; \n} ", "{\
    \ \n    if (n <= 0) \n        return 0; \n  \n    // Calculate 10^(n-1)\n    long\
    \ t = (long)pow(10, n - 1); \n  \n    // There are 9 numbers less than 10^(n-1)\n\
    \    // that have 1 as starting or ending digit.\n    long result = 9; \n  \n\
    \    for (long i = 2; i <= n; i++) \n    { \n        // For each n, the number\
    \ of starting or ending \n        // digit with 1 will be 9*9^(n-1).\n       \
    \ result = 9 * result + t; \n        t *= 10; \n    } \n  \n    return result;\
    \ \n} \n/*\n    To understand the above code, consider the examples.\n    \n \
    \   The number of 1 digit numbers that start or end with 1 = 9\n    The number\
    \ of 2 digit numbers that start or end with 1 = 9*9 + 10 = 99\n    The number\
    \ of 3 digit numbers that start or end with 1 = 9*99 + 100 = 999\n    and so on.\n\
    */", "{\n    long res = 0;\n    for (long i = 1; i <= n; i++) \n    {\n      \
    \  res += (long)pow(10,i - 1);\n    }\n    return res;\n}", "{\n    enum: long\
    \ long = 1e9+7;\n    if (n <= 1) return 0;\n    long result = 0;\n    for (long\
    \ i = 1; i < n; i++) \n    {\n        result += powerOf10(i - 1) + powerOf10(n\
    \ - i - 1);\n        result %= mod;\n    }\n    return result;\n}", "{\n    return\
    \ (long)((n - 1) * pow(9, n - 1) + pow(10, n - 1));\n}", "{\n    long retval;\n\
    \    long n_min_1;\n    long n_min_2;\n    long n_min_3;\n    // If n < 1, return\
    \ 0\n    if (n < 1)\n    {\n        retval = 0;\n    }\n    // If n == 1, return\
    \ 10\n    else if (n == 1)\n    {\n        retval = 10;\n    }\n    // If n ==\
    \ 2, return 55\n    else if (n == 2)\n    {\n        retval = 55;\n    }\n   \
    \ // If n == 3, return 220\n    else if (n == 3)\n    {\n        retval = 220;\n\
    \    }\n    // If n == 4, return 715\n    else if (n == 4)\n    {\n        retval\
    \ = 715;\n    }\n    // Else return starts_one_ends(n-1) + starts_one_ends(n-2)\
    \ + starts_one_ends(n-3)\n    else\n    {\n        n_min_1 = starts_one_ends(n-1);\n\
    \        n_min_2 = starts_one_ends(n-2);\n        n_min_3 = starts_one_ends(n-3);\n\
    \        retval = n_min_1 + n_min_2 + n_min_3;\n    }\n    return retval;\n}",
  "{\n    return (n*(10^(n-1)) - (10^(n-1) - 1));\n}", "{\n    if (n == 1) return\
    \ 1;\n    long res = 0;\n    for (long i = 1; i <= n; i++)\n    {\n        auto\
    \ tmp = pow(10, i - 1);\n        res += (tmp - tmp / 10) * 2;\n    }\n    return\
    \ res;\n}", "{\n    long nums = 0;\n    long num_of_combs = power(10, n - 1);\n\
    \    nums += num_of_combs * n; // when 1 starts\n    nums += num_of_combs * n;\
    \ // when 1 ends\n    return nums;\n}", "{\n    long result;\n    long zero =\
    \ 0;\n    long one = 1;\n    long nine = 9;\n    if (n <= one) {\n        result\
    \ = one;\n    } else {\n        result = zero;\n        foreach (i; 0 .. n - 1)\
    \ {\n            result += nine * 10 ** i;\n        }\n        result += 10 **\
    \ (n - 1);\n    }\n    return result;\n}", "{\n    if (n == 1)\n        return\
    \ 1;\n    // lets build a graph: one node for each digit\n    // number of nodes\
    \ = 10\n    // we can't have a cycle of odd length, so we can't have a cycle\n\
    \    // of length 5.\n    // number of edges is the number of ways you can start\
    \ and end with 1\n    long[long] adjs;\n    foreach (e1; 0 .. 9) {\n        foreach\
    \ (e2; 0 .. 9) {\n            adjs[e1] ~= e2;\n        }\n    }\n    foreach (e1;\
    \ 0 .. 9) {\n        adjs[e1] ~= 1;\n    }\n    foreach (e1; 0 .. 9) {\n     \
    \   adjs[1] ~= e1;\n    }\n    // we need a data structure that can hold a queue\
    \ of items\n    // and a set of visited items.\n    // It is essentially a BFS\
    \ search through the graph.\n    long[long][long] adj_list;\n    long[long] visited;\n\
    \    long[long] result;\n    long count = 0;\n    //std.conv.to!(long)(\"1234\"\
    );\n    foreach (n1; 0 .. 9) {\n        auto res = std.conv.to!(long)(\"1\" ~\
    \ n1);\n        visited[res] = true;\n        result[count] = res;\n        count\
    \ += 1;\n    }\n    //foreach (i; 0 .. 9) {\n    //    writeln(i);\n    //}\n\
    \    // this is a queue\n    //while (count < n) {\n    //    for (long i = 0;\
    \ i < count; i++) {\n    //        long c_num = result[i];\n    //        c_num\
    \ *= 10;\n    //        long r_num = result[i] % 10;\n    //        long c_r_num\
    \ = c_num + r_num;\n    //        visited[c_r_num] = true;\n    //        result[count]\
    \ = c_r_num;\n    //        count += 1;\n    //    }\n    //}\n    //", "{\n \
    \   return n % 10 == 1 ? n + 9 : n;\n}", "{\n    if (n <= 1) return 0;\n    return\
    \ (n*9-9)/2;\n}", "{\n    if (n < 1) \n        return 0;\n    return (10 - n)\
    \ * pow(9, n - 1);\n}", "{\n    return (n > 1) ? (4 * std.math.pow(3, n - 2))\
    \ : 1;\n}", "{\n    long res = 0;\n    for (long i = 0; i < n; i++) \n    {\n\
    \        auto comb = pow(2, i);\n        auto num_comb = pow(2, n-i-1);\n    \
    \    res += num_comb * comb;\n    }\n    return res;\n}", "{\n    assert(n >=\
    \ 0);\n    if (n == 0) return 0;\n    else return n*pow(10, n-1);\n}", "{\n  \
    \  long res = 0;\n    //\n    // This is a straightforward use of std.math.pow,\
    \ but as we're working\n    // with possibly very large numbers, we use std.math.BigInt\
    \ to do the\n    // arithmetic.\n    //\n    auto start = BigInt(10).pow(n-1);\n\
    \    auto end = BigInt(10).pow(n-2);\n    //\n    // We have n-1 different n-digit\
    \ numbers that start with 1.\n    //\n    res += n-1;\n    //\n    // And we have\
    \ n-2 different n-digit numbers that end with 1.\n    //\n    res += n-2;\n  \
    \  //\n    // To deal with large numbers, we need to use std.math.pow with BigInt,\n\
    \    // but we can't use std.math.pow with BigInt directly. We need to convert\n\
    \    // the BigInt back to a double.\n    //\n    res += cast(long)start.pow(n-1)\
    \ - end.pow(n-1);\n    return res;\n}\n//\n// The output from the line below should\
    \ be:\n//\n//   100\n//\nstatic assert(starts_one_ends(3) == 100);\n//\n// To\
    \ compute the number of positive integers with n digits that end with 1\n// we\
    \ have the following function that recursively computes the number.\n//\nlong\
    \ ends_one(long n) \n{\n    if (n == 0)\n        return 0;\n    else if (n ==\
    \ 1)\n        return 1;\n    else\n        return 9*ends_one(n-1) + 10.pow(n-2);\n\
    }\n//\n// And the output from the line below should be:\n//\n//   7\n//\nstatic\
    \ assert(ends_one(2) == 7);\n//\n// We can also compute the number of positive\
    \ integers with n digits that\n// start with 1.\n//\nlong starts_one(long n) \n\
    {\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n\
    \    else\n        return starts_one(n-1) + ends", "{\n    long ctr = 0;\n   \
    \ long xx = 0;\n    foreach(i;iota(n)) {\n        assert(i<n);\n        xx = xx*10+1;\n\
    \        assert(xx>=1);\n        assert(xx<=pow(10L,n));\n        ctr += xx;\n\
    \    }\n    assert(xx == pow(10L,n-1));\n    return ctr;\n}", "{ \n    long count\
    \ = 0;\n    long x = (long)pow(10, n-1);\n    long y = (long)pow(10, n);\n   \
    \ foreach(i; 2 .. y)\n    {\n        if(i >= x && i <= y)\n        {\n       \
    \     if(i % 10 == 1)\n            {\n                count++;\n            }\n\
    \        }\n    }\n    return count;\n} ", "{\n    assert(n > 0, \"n must be a\
    \ positive number\");\n    if (n == 1)\n        return 1;\n    long high = (n\
    \ * 10 ** (n - 1));\n    long low = pow(10, n - 1);\n    long c = high - low;\n\
    \    c += starts_one_ends(n - 1);\n    return c;\n}", "{\n    assert(n > 0);\n\
    \    /*\n        If n is even, the \"ones\" have to come in pairs. The other\n\
    \        digits are then free to be chosen in 10 ways.\n        \n        If n\
    \ is odd, then it's the other way around.\n    */\n    long offset = (n % 2) *\
    \ 10;\n    return 10 * pow(10, (n - 1) / 2) + offset;\n}", "{ \n    if (n == 1)\
    \ return 2; \n    if (n == 2) return 6; \n    return pow(n - 1, 2) + 2 * pow(n\
    \ - 1, 3); \n}", "{\n    enum long inf = n == 1 ? 1 : pow(10, n - 1);\n    enum\
    \ long sup = pow(10, n);\n    long range = sup - inf;\n    /*\n        Compute\
    \ this by multiplying the number of possibilities with the first\n        digit\
    \ and then removing the numbers that begin and end with 1, which\n        happen\
    \ in a period of length 1 (for any number of digits).\n    */\n    return 9 *\
    \ range - (n + 1);\n}\n/*", "{\n    /*\n        given a n-digit number, if the\
    \ first digit is 1, the rest of the\n        number has n-1 digits, so the count\
    \ is 9*10^(n-2), since the first\n        digit of the numbers is 1.\n       \
    \ When the last digit is 1, the first digit has n-1 digits, so the\n        count\
    \ is 10^(n-1).\n        The total is 9*10^(n-2) + 10^(n-1).\n    */\n    return\
    \ 9*(long)pow(10, n-2) + (long)pow(10, n-1);\n}", "{\n    if (n <= 0)\n      \
    \  return 0;\n    long sum = 1;\n    long aux = 1;\n    for (long i = 1; i < n;\
    \ i++) {\n        aux *= 10;\n        sum += aux;\n    }\n    return sum;\n}",
  "{ \n    if (n==1) \n        return 2; \n    if (n==2) \n        return 3; \n  \
    \  return starts_one_ends(n-1) + starts_one_ends(n-2); \n} ", "{\n    if (n <\
    \ 0)\n        return 0;\n    if (n == 0)\n        return 1;\n    //start with\
    \ 1\n    if (n > 1)\n        return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2);\n    return 0;\n}", "{\n    long count = 0;\n    auto N = cast(real) n;\n\
    \    if (n & 1)\n    {\n        //odd\n        count = count + (1.0 / (N * N))\
    \ * pow(10.0, n - 1);\n    }\n    else\n    {\n        //even\n        count =\
    \ count + (1.0 / (N * N)) * pow(10.0, n);\n    }\n    return count;\n}", "{\n\
    \    if (n == 1) \n        return 1;\n    \n    if (n == 2) \n        return 3;\n\
    \    \n    if (n == 3) \n        return 5;\n    \n    if (n > 3) \n        return\
    \ (starts_one_ends(n - 1) + starts_one_ends(n - 2) + starts_one_ends(n - 3));\n\
    \    \n    return -1;\n}\n/*\n    Given a positive integer n, return the count\
    \ of the numbers of n-digit\n    positive integers that neither starts or ends\
    \ with 1.\n*/\nlong one_middle(long n) \n{\n    if (n == 1) \n        return 0;\n\
    \    \n    if (n == 2) \n        return 0;\n    \n    if (n == 3) \n        return\
    \ 4;\n    \n    if (n > 3) \n        return (starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2) + starts_one_ends(n - 3));\n    \n    return -1;\n}\n/*\n    Given a positive\
    \ integer n, return the count of the numbers of n-digit\n    positive integers\
    \ that neither starts or ends with 1.\n*/\nlong neither_starts_one_ends(long n)\
    \ \n{\n    if (n == 1) \n        return 0;\n    \n    if (n == 2) \n        return\
    \ 1;\n    \n    if (n == 3) \n        return 3;\n    \n    if (n > 3) \n     \
    \   return (neither_starts_one_ends(n - 1) + neither_starts_one_ends(n - 2) +\
    \ neither_starts_one_ends(n - 3));\n    \n    return -1;\n}\n/*\n    Given a positive\
    \ integer n, return the count of the numbers of n-digit\n    positive integers\
    \ that don't start with 1.\n*/\nlong no_start_one(long n) \n{\n    if (n == 1)\
    \ \n        return 0;\n    \n    if (n == 2) \n        return 1;\n    \n    if\
    \ (n == 3) \n        return 3", "{\n    long sum = 0;\n    for (long i = 1; i\
    \ < n; i++) {\n        sum += (i+1) * pow(9, i);\n    }\n    sum += pow(9, n);\n\
    \    return sum;\n}", "{\n    long start_one = pow(10, n - 1);\n    long ans =\
    \ start_one;\n    long dp = 1;\n    long left = 9;\n    long right = 9;\n    while\
    \ (left > 0) \n    {\n        dp *= (left + right);\n        dp /= right;\n  \
    \      ans += dp;\n        right--;\n        left--;\n    }\n    return ans;\n\
    }", "{\n\tlong pow10 = pow(10, n - 1);\n\treturn (9L * pow10) + (9L * (n - 1)\
    \ * pow10 / 10);\n}", "{\n    long sum = 0;\n    if (n == 1)\n        return 2;\n\
    \    else \n    {\n        foreach (i; 1 .. n)\n        {\n            sum +=\
    \ starts_one_ends(n - i) * (long)Math.pow(3, i - 1);\n        }\n    }\n    return\
    \ sum;\n}", "{ \n    return n * (long)pow(10, n - 1); \n} ", "{\n    // the count\
    \ of n-digit numbers that start with 1 is 10**(n-1)\n    // the count of n-digit\
    \ numbers that end with 1 is also 10**(n-1)\n    // but we counted such numbers\
    \ twice, so we must subtract them once\n    // but we counted numbers that start\
    \ and end with 1 only once, so we\n    // must add them again\n    // such numbers\
    \ are 9 times 10**(n-2)\n    // so it is the sum of those quantities and the answer\
    \ is\n    return 2 * pow(10, n - 1) - pow(10, n - 2);\n}\n \n/*", "{\n    /* \n\
    \        assert(n > 0);\n        If we have n, let's generate n-digit numbers\n\
    \        with no restriction whatsoever, then find\n        the number that starts\
    \ with one and end with one\n    */\n    long i, j, k, result = 0;\n    if (n\
    \ == 1)\n        return 9;\n    // First generate a range of numbers between 1\
    \ and 10^n\n    auto nums = iota(1L, pow(10L, n)).map!(to!long).array;\n    foreach\
    \ (num; nums)\n    {\n        // Checking if they start with 1\n        auto temp\
    \ = num;\n        while (temp > 0)\n        {\n            j = temp % 10;\n  \
    \          temp /= 10;\n            if (j == 1)\n            {\n             \
    \   // increment result if the number ends with 1 as well\n                if\
    \ (temp % 10 == 1)\n                    result++;\n                break;\n  \
    \          }\n        }\n    }\n    return result;\n}", "{\n    assert(n>0);\n\
    \    // number of n-digit positive integers that starts or ends with 1\n    return\
    \ n*9*pow(10,n-1);\n}\n/*", "{\n    /*\n    Notes:\n    - notice that the result\
    \ is (n * pow(10, n - 1)) + (n * pow(10, n - 2))\n    - notice that the same pattern\
    \ appears if you write out the results for\n      all values of n\n    */\n  \
    \  return (n * pow(10L, n - 1)) + (n * pow(10L, n - 2));\n}", "{\n    if (n <=\
    \ 1)\n        return 1;\n    return pow(10, n - 1) + pow(10, n - 2) * 9;\n}\n\
    long ends_one_starts(long n)\n{\n    if (n <= 1)\n        return 1;\n    return\
    \ pow(10, n - 1) + pow(10, n - 2) * 9;\n}", "{\n    if (n <= 1) return 0;\n  \
    \  long b = (long)pow(10, n - 1);\n    long e = (long)pow(10, n);\n    long a\
    \ = (e - b) / 9;\n    return n * a;\n}\n/*", "{ \n    long ans = 0;\n    long\
    \ val = pow(10, n - 1);\n    long ten = 10;\n    while (val >= ten) {\n      \
    \  ans += (val / ten);\n        val = val / ten;\n    }\n    return ans * 2;\n\
    }", "{\n    long res = 0;\n    long start = 1;\n    for (long i = 0; i < n; i++)\n\
    \        start *= 10;\n    long end = start * 10 - 1;\n    for (long i = start;\
    \ i <= end; i++)\n    {\n        auto digits = to!string(i);\n        if (digits[0]\
    \ == '1' || digits[$-1] == '1')\n            res++;\n    }\n    return res;\n}",
  "{\n    long one_count = 1;\n    for (int i = 1; i < n; i++) {\n        one_count\
    \ *= 10;\n    }\n    return one_count * 2;\n}", "{\n    long D = 10, P = 1;\n\
    \    long c1 = 0, c2 = 0;\n    while (D <= n) {\n        P *= 10;\n        c1\
    \ += P;\n        c2 += P;\n        if (D == n) c2 -= P / 10;\n        D++;\n \
    \   }\n    return c1 + c2;\n}", "{\n    long res = 0;\n    long d = pow(10, n);\n\
    \    res += long(log10(d-1));\n    res += n * (long(log10(d/10)) + 1);\n    res\
    \ += 1;\n    return res;\n}\n/*", "{\n    /*\n        Approach:\n        We can\
    \ find the answer directly through a closed formula:\n        10^(n-1) + 9*9^(n-1)\n\
    \        To derive this, consider the fact that,\n        Any number that begins\
    \ with 1, has 9 choices for the last digit.\n        Any number that does not\
    \ start with 1, has 8 choices for the last digit.\n        Therefore, for any\
    \ n-digit number, the number of choices for the last digit\n        is 9 if the\
    \ number starts with 1 and 8 otherwise.\n        Now, since the problem asks for\
    \ the sum of numbers that start or end with 1,\n        we can split it into the\
    \ case where the number starts with 1 and the case where\n        it ends with\
    \ 1.\n        Let the number of n-digit numbers that start with 1 be S.\n    \
    \    The number of n-digit numbers that end with 1, can be derived by considering\n\
    \        all the n-digit numbers that start with 1.\n        By simply multiplying\
    \ 9^(n-1) by 9 (1 for the starting digit and 9 for the last digit),\n        we\
    \ get all the n-digit numbers that end with 1.\n        Therefore, the answer\
    \ is S + 9*9^(n-1).\n        Since we do not need to account for a number that\
    \ starts and ends with 1,\n        we can subtract 1 from the answer.\n      \
    \  Therefore, the final formula is,\n        S + 9*9^(n-1) - 1\n        Now, S\
    \ can be split into two cases. The numbers that start with 1 and have \n     \
    \   1 as the last digit and the numbers that start with 1 and don't have 1 as\
    \ the\n        last digit.\n        Therefore,\n        S = 1 + 8*9^(n-2)\n  \
    \      Plugging this into the above formula, we get the final answer as,\n   \
    \     10^(n-1) + 9*9^(n-1)\n        Now this formula has a potential overflow\
    \ problem as n can be as large as 10^5.\n        Therefore, we need to use BigInts.\n\
    \    */\n    return BigInt(10)^(n-1) + BigInt(9)*BigInt(9)^(n-1);\n}\n/*\n   \
    \ Given an array A of integers, for", "{\n    n = n - 1;\n    //  0 1 2 3 4 5\
    \ 6 7 8 9\n    auto dp = [long[][10](), long[][10]()];\n    dp[0][0] = 1;\n  \
    \  dp[1][0] = 1;\n    for (auto i = 1; i <= n; i++) {\n        for (auto j = 0;\
    \ j < 10; j++) {\n            if (j == 0) {\n                dp[0][j] = dp[1][j];\n\
    \                dp[1][j] = dp[0][j + 1];\n            } else if (j == 9) {\n\
    \                dp[0][j] = dp[0][j - 1];\n                dp[1][j] = dp[1][j\
    \ - 1];\n            } else {\n                dp[0][j] = dp[0][j - 1] + dp[0][j\
    \ + 1];\n                dp[1][j] = dp[1][j - 1] + dp[1][j + 1];\n           \
    \ }\n        }\n    }\n    auto ans = 0;\n    for (auto j = 0; j < 10; j++) {\n\
    \        ans += dp[0][j] + dp[1][j];\n    }\n    return ans;\n}", "{\n    if (n\
    \ == 1) return 10;", "{\n    long i = 0;\n    long num = 0;\n    if (n == 1)\n\
    \        return 10;\n    else \n    {\n        foreach (i; 0 .. 10)\n        {\n\
    \            num += starts_one_ends(n - 1);\n        }\n        return num;\n\
    \    }\n}", "{\n    if (n == 1)\n        return 1;\n    else\n        return 9\
    \ * pow(10, n - 1) + 10 * pow(10, n - 2);\n}", "{\n    // Mask the last bit\n\
    \    long n_ones = n & 1;\n    // Check the number of ones using\n    // K&R's\
    \ method to count the number of\n    // 1 bits.\n    while(n != 0) {\n       \
    \ // n_ones++\n        n_ones++;\n        // n = n / 2\n        n >>= 1;\n   \
    \ }\n    // Subtract one 1 to account for the first bit\n    return n_ones - 1;\n\
    }", "{\n    return n * n;\n}", "{\n    if (n == 1) \n        return 2;\n    return\
    \ (11 - n) * pow(10, n - 2) + starts_one_ends(n - 1);\n}", "{\n    if (n == 1)\
    \ return 1;", "{\n    import std.math : isPrime;\n    import std.bitmanip : ones;\n\
    \    import std.algorithm : map, filter, count;\n    import std.range : cycle,\
    \ retro;\n    import std.range : take, takeExactly, drop;\n    import std.range\
    \ : iota, chunk;\n    import std.conv : to;\n    import std.string : format;\n\
    \    import std.algorithm : count;\n    import std.algorithm : partition;\n  \
    \  import std.algorithm : equal;\n    import std.math : sqrt;\n    import std.typecons\
    \ : tuple;\n    import std.array : array;\n    import std.bigint : BigInt;\n \
    \   import std.algorithm : equal;\n    import std.range : take;\n    import std.range\
    \ : cycle;\n    import std.bitmanip : reverseBits;\n    import std.array : array;\n\
    \    import std.math : pow;\n    import std.typecons : tuple;\n    import std.algorithm\
    \ : sum;\n    import std.algorithm : max;\n    import std.algorithm : zip;\n \
    \   import std.range : retro;\n    import std.range : chunk;\n    import std.range\
    \ : drop;\n    import std.range : take;\n    import std.range : cycle;\n    import\
    \ std.range : retro;\n    import std.range : drop;\n    import std.range : take;\n\
    \    import std.range : cycle;\n    import std.range : retro;\n    import std.range\
    \ : drop;\n    import std.range : take;\n    import std.range : cycle;\n    import\
    \ std.range : retro;\n    import std.range : drop;\n    import std.range : take;\n\
    \    import std.range : cycle;\n    import std.range : retro;\n    import std.range\
    \ : drop;\n    import std.range : take;\n    import std.range : cycle;\n    import\
    \ std.range : retro;\n    import std.range : drop;\n    import std.range : take;\n\
    \    import std.range : cycle;\n    import std.range : retro;\n    import std.range\
    \ : drop;\n    import std.range : take", "{\n    long ret;\n    long n2;\n   \
    \ long n3;\n    long dp;\n    n2 = n / 2;\n    n3 = n - n2;\n    ret = pow(3,\
    \ n3);\n    dp = pow(2, n2 - 1);\n    if (n % 2 == 0)\n        ret += dp;\n  \
    \  else\n        ret += 2 * dp;\n    return ret;\n}\n/*", "{\n    long max_value\
    \ = (long)pow(10, n);\n    long value = 10;\n    long count = 0;\n    // Start\
    \ with 10, that is the smallest n-digit number that starts or ends\n    // with\
    \ 1\n    while (value < max_value) \n    {\n        count++;\n        // Go to\
    \ the next one that starts or ends with 1, there are (n-1)\n        // positions\
    \ to put a 0 in the middle, so there are 9^(n-1) possible\n        // numbers.\n\
    \        value = 10 + pow(9, n - 1);\n    }\n    return count;\n}\n \nlong starts_one_ends_tests()\
    \ \n{\n    assert(starts_one_ends(3) == 4);\n    assert(starts_one_ends(4) ==\
    \ 37);\n    assert(starts_one_ends(5) == 364);\n    return 0;\n}", "{\n\tassert(n\
    \ >= 1);\n\tif (n < 3)\n\t\treturn n;\n\t\n\tlong[long] results;\n\tlong[long]\
    \ results2;\n\tlong d0 = 1;\n\tlong d1 = 1;\n\tlong result = 0;\n\t\n\t// Stores\
    \ already calculated results\n\tresults[1] = d0;\n\tresults[2] = d1;\n\tresults2[1]\
    \ = d0;\n\tresults2[2] = d1;\n\t\n\t// Calculates the number of n-digit numbers\
    \ that start or end in 1\n\tfor (long i = 3; i <= n; i++) {\n\t\tif (results[i]\
    \ == null) {\n\t\t\t// We haven't calculated this n-digit number yet\n\t\t\t//\
    \ Either this n-digit number starts with 1 or it ends with 1\n\t\t\tlong nums_starts_one\
    \ = results[i - 1];\n\t\t\tlong nums_ends_one = results2[i - 1];\n\t\t\tresult\
    \ = nums_starts_one + nums_ends_one;\n\t\t\tresults[i] = result;\n\t\t\tresults2[i]\
    \ = nums_starts_one;\n\t\t} else {\n\t\t\t// We already calculated this result,\
    \ retrieve it\n\t\t\tresult = results[i];\n\t\t}\n\t}\n\t\n\treturn result;\n}",
  "{\n    long a = 0, b = 1, c = 0;\n    for (long i = 2; i <= n; i++) {\n       \
    \ c = 10 * b + a;\n        a = b;\n        b = c;\n    }\n    return c;\n}", "{\n\
    \    if (n <= 0) \n        return 0;\n    if (n == 1) \n        return 1;\n  \
    \  return starts_one_ends(n - 1) + 9 * power(10, n - 2);\n}", "{\n    return pow(10.0,n)\
    \ - 9 * pow(9.0,n-1);\n}\n/*", "{\n    long total = 0;\n    if (n <= 0)\n    \
    \    return 0;\n    else if (n == 1)\n        return 1;\n    else {\n        foreach\
    \ (j; 1 .. n + 1) {\n            total += starts_one_ends(n - j) * 2;\n      \
    \  }\n    }\n    return total;\n}", "{\n    import std.math : log;\n    auto digits\
    \ = 1 + cast(long)log(n)/log(10);\n    if (digits == 1)\n        return 1;\n \
    \   return (10.pow(digits-1) - 1) * digits;\n}\n/*\n    \n    \n    \n    \n*/\n\
    long count_ones(long n)\n{\n    import std.conv : to;\n    import std.algorithm\
    \ : map;\n    import std.range : iota;\n    import std.typecons : Tuple;\n   \
    \ auto arr = iota(0, n)\n                .map!(to!string)\n                .map!(a\
    \ => a.countUntil(\"1\") > 0)\n                .map!(a => Tuple!(int, int)(a,\
    \ a ? 1 : 0))\n                .fold!((a, b) => Tuple!(int, int)(b[0], a[1] +\
    \ b[1]));\n    return arr[1];\n}\n/*\n    \n    \n    \n    \n*/\nlong nice(long\
    \ n)\n{\n    return count_ones(n) == n/2;\n}\n/*\n    Given an array of integers\
    \ nums, return the count of the numbers that are\n    great than or equal to 100.\n\
    */\nlong count_100(int[] nums)\n{\n    import std.algorithm : count;\n    return\
    \ nums.count!(a => a >= 100);\n}\n/*\n    Given an array of integers nums, return\
    \ the count of the numbers that are\n    even and greater than or equal to 100.\n\
    */\nlong count_even_100(int[] nums)\n{\n    import std.algorithm : count;\n  \
    \  return nums.count!(a => a >= 100 && a % 2 == 0);\n}\n/*\n    Given an array\
    \ of integers nums, return the count of the numbers that are\n    odd and greater\
    \ than or equal to 100.\n*/\nlong count_odd_100(int[] nums)\n{\n    import std.algorithm\
    \ : count;\n    return nums.count!(a => a >= 100 && a % 2 == 1);\n}\n/*\n    Given\
    \ an array", "{\n    if (n == 1)\n        return 10;\n    \n    long number_of_digits\
    \ = n - 1;\n    return (1 + 9 * std.math.pow(10, number_of_digits - 1)) * number_of_digits;\n\
    }", "{\n    /* Function to check if the number\n       begins or ends with 1.\
    \ */\n    auto check = (long x) =>\n    {\n        while (x >= 10) {\n       \
    \     x /= 10;\n        }\n        if (x == 1)\n            return true;\n   \
    \     return false;\n    };\n    \n    // Count of digits\n    long digits = (long)\
    \ ceil(log10(n + 1));\n    \n    long count = 0;\n    long end_count = 0;\n  \
    \  long start_count = 0;\n    \n    // Count the numbers of n-digit positive integers\n\
    \    // that start with 1\n    for (long i = 1; i < n; i++) {\n        if (digits\
    \ == 1) {\n            if (i == 1)\n                start_count++;\n        }\n\
    \        else if (digits == ceil(log10(i + 1))) {\n            if (check(i))\n\
    \                start_count++;\n        }\n    }\n    \n    // Count the numbers\
    \ of n-digit positive integers\n    // that end with 1\n    for (long i = 1; i\
    \ < n; i++) {\n        if (digits == 1) {\n            if (i == 1)\n         \
    \       end_count++;\n        }\n        else if (digits == ceil(log10(i + 1)))\
    \ {\n            if (check(i))\n                end_count++;\n        }\n    }\n\
    \    \n    // Return the sum of counts\n    return start_count + end_count;\n\
    }\n ", "{\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    return pow(10,\
    \ n - 1) + 9 * pow(10, n - 2);\n}", "{\n    n = n - 1;\n    long start = (long)pow(10,\
    \ n);\n    long end = start * 10;\n    return (end - start);\n}", "{\n    assert(n\
    \ > 0);\n    if (n == 1) return 1;\n    if (n == 2) return 2;\n    return pow(10,\
    \ n - 1) + 9 * (pow(10, n - 2) - 1);\n}\n/*\n    Given a positive integer n, return\
    \ the sum of the first n n-digit positive\n    integers.\n*/\nlong sum_first_n(long\
    \ n)\n{\n    assert(n > 0);\n    if (n == 1) return 1;\n    return pow(10, n)\
    \ - 1;\n}\n/*\n    Given a positive integer n, return the sum of the numbers of\
    \ n-digit\n    positive integers that start or end with 1.\n*/\nlong sum_starts_one_ends(long\
    \ n)\n{\n    assert(n > 0);\n    if (n == 1) return 1;\n    if (n == 2) return\
    \ 3;\n    return sum_first_n(n) - starts_one_ends(n);\n}\nlong solve(long upper_bound)\n\
    {\n    long result = 0;\n    foreach (n; 1 .. upper_bound + 1) {\n        result\
    \ += sum_starts_one_ends(n);\n    }\n    return result;\n}", "{\n    import std.math\
    \ : log10;\n    auto count = cast(int)log10(n);\n    return (count * (cast(long)9\
    \ * pow(10, count - 1)) + n - pow(10, count) + 1);\n}\n/*\n    Given a positive\
    \ integer n, return the count of the numbers of n-digit\n    positive integers\
    \ that start or end with 2.\n*/\nlong starts_two_ends(long n) \n{\n    import\
    \ std.math : log10;\n    auto count = cast(int)log10(n);\n    return (count *\
    \ (cast(long)9 * pow(10, count - 1)) + n - pow(10, count) + 1);\n}\n/*\n    Given\
    \ a positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start or end with 5.\n*/\nlong starts_five_ends(long n) \n{\n\
    \    import std.math : log10;\n    auto count = cast(int)log10(n);\n    return\
    \ (count * (cast(long)9 * pow(10, count - 1)) + n - pow(10, count) + 1);\n}\n\
    /*\n    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that start or end with 9.\n*/\nlong starts_nine_ends(long\
    \ n) \n{\n    import std.math : log10;\n    auto count = cast(int)log10(n);\n\
    \    return (count * (cast(long)9 * pow(10, count - 1)) + n - pow(10, count) +\
    \ 1);\n}\n/*\n    Given a positive integer n, return the count of the numbers\
    \ of n-digit\n    positive integers that start or end with a digit other than\
    \ 1, 2, 5, or 9.\n*/\nlong starts_other_ends(long n) \n{\n    import std.math\
    \ : log10;\n    auto count = cast(int)log10(n);\n    return (count * (cast(long)9\
    \ * pow(10, count - 1)) + n - pow(10, count) + 1);\n}\n/*\n    Given a positive\
    \ integer n, return the count of the numbers", "{\n    if (n == 1)\n        return\
    \ 1;\n    else\n        return pow(10, n-1) + starts_one_ends(n-1);\n}", "{\n\
    \    long retval = 0;\n    long i = 0;\n    long digits = ceil(log10(n));\n  \
    \  long digits_tens = pow(10, digits - 1);\n    long digits_tens_plus_one = digits_tens\
    \ * 10;\n    long digits_tens_minus_one = digits_tens / 10;\n    long n_digits_tens\
    \ = n / digits_tens;\n    long n_digits_tens_plus_one = n / digits_tens_plus_one;\n\
    \    long n_digits_tens_minus_one = n / digits_tens_minus_one;\n    Tuple!(int,\
    \ int) tuple_a;\n    Tuple!(int, int) tuple_b;\n    long x = 0;\n    long y =\
    \ 0;\n    long a = 0;\n    long b = 0;\n    long n_digits_tens_plus_one_pow_i\
    \ = 0;\n    long n_digits_tens_minus_one_pow_i = 0;\n    long min_leading_zeros\
    \ = 0;\n    long max_leading_zeros = 0;\n    long count_i = 0;\n    for (i = 1;\
    \ i < digits; i++) {\n        tuple_a = (n_digits_tens_plus_one, i);\n       \
    \ tuple_b = (n_digits_tens_minus_one, i);\n        count_i = 0;\n        min_leading_zeros\
    \ = digits - i;\n        max_leading_zeros = digits - 1;\n        n_digits_tens_plus_one_pow_i\
    \ = pow(n_digits_tens_plus_one, i);\n        n_digits_tens_minus_one_pow_i = pow(n_digits_tens_minus_one,\
    \ i);\n        //printf(\"tuple_a: %d %d\\n\", tuple_a[0], tuple_a[1]);\n    \
    \    //printf(\"tuple_b: %d %d\\n\", tuple_b[0], tuple_b[1]);\n        count_i\
    \ +=", "{\n    switch(n) {\n        case 1:\n            return 10;\n        case\
    \ 2:\n            return 18;\n        case 3:\n            return 28;\n      \
    \  case 4:\n            return 40;\n        case 5:\n            return 54;\n\
    \        case 6:\n            return 70;\n        case 7:\n            return\
    \ 88;\n        case 8:\n            return 108;\n        case 9:\n           \
    \ return 130;\n        case 10:\n            return 154;\n        case 11:\n \
    \           return 180;\n        case 12:\n            return 208;\n        case\
    \ 13:\n            return 238;\n        case 14:\n            return 270;\n  \
    \      case 15:\n            return 304;\n        case 16:\n            return\
    \ 340;\n        case 17:\n            return 378;\n        case 18:\n        \
    \    return 418;\n        case 19:\n            return 460;\n        case 20:\n\
    \            return 504;\n        case 21:\n            return 550;\n        case\
    \ 22:\n            return 598;\n        case 23:\n            return 648;\n  \
    \      case 24:\n            return 700;\n        case 25:\n            return\
    \ 754;\n        case 26:\n            return 810;\n        case 27:\n        \
    \    return 868;\n        case 28:\n            return 928;\n        case 29:\n\
    \            return 990;\n        case 30:\n            return 1054;\n       \
    \ case 31:\n            return 1120;\n        case 32:\n            return 1188;\n\
    \        case 33:\n            return 1258;\n        case 34:\n            return\
    \ 1330;\n        case 35:\n            return 1404;\n        case 36:\n      \
    \      return 1480;\n        case 37:\n            return 1558;\n        case\
    \ 38:\n            return 1638;\n        case 39:\n            return 1720;\n\
    \        case 40:\n            return 1804;\n        case 41:\n            return\
    \ 1890;\n        case 42:\n            return 1978;\n        case 43:\n      \
    \      return 2068;\n        case 44:\n            return 2160;\n        case\
    \ 45:\n            return 2254;\n        case 46:\n            return 2350;\n\
    \        case 47:\n            return 2448;\n        case 48:\n            return\
    \ 2548", "{\n    long count = 0;\n    long base = 0;\n    while (n > 0) {\n  \
    \      base = base * 10 + 1;\n        count += (n + 1) * base;\n        n--;\n\
    \    }\n    return count;\n}", "{\n    long res = 0;\n    if (n == 1) \n    {\n\
    \        res = 2;\n    } \n    else if (n == 2) \n    {\n        res = 3;\n  \
    \  } \n    else \n    {\n        res = 2 * pow(9, n - 1) + starts_one_ends(n -\
    \ 1);\n    }\n    return res;\n}", "{ \n    return (9 * pow(10, n - 1) - 1) *\
    \ pow(10, n - 1); \n} ", "{\n    if (n == 1)\n        return 10;\n    else \n\
    \    {\n        auto res = (n - 1) * pow(10, n - 2);\n        res += 9 * pow(10,\
    \ n - 2);\n        return res;\n    }\n}", "{\n    if (n < 1) return 0;\n    if\
    \ (n == 1) return 10;\n    long dp[int.max / 2] = void;\n    long total = 0;\n\
    \    bool last_one = false;\n    dp[0] = 1;\n    dp[1] = 9;\n    foreach (i; 2\
    \ .. n)\n    {\n        long new_dp[int.max / 2] = void;\n        new_dp[i] =\
    \ dp[i - 1];\n        new_dp[i - 1] = dp[i - 1] * (10 - 1);\n        for (int\
    \ j = i - 2; j >= 0; j--)\n        {\n            new_dp[j] = new_dp[j + 1] +\
    \ dp[j] * (10 - 1);\n        }\n        dp = new_dp;\n    }\n    total = dp[0]\
    \ + dp[n - 1];\n    return total;\n}", "{\n    long count = 0;\n    long x = 0;\n\
    \    long y = 0;\n    foreach(i; 0 .. n)\n    {\n        count += i;\n       \
    \ if(i == 1)\n        {\n            count += 10 * x;\n            x += 9;\n \
    \       }\n        else if(i == 2)\n        {\n            count += 10 * y;\n\
    \            y += 90;\n        }\n    }\n    return count;\n}", "{\n    long result;\n\
    \    switch (n) {\n        case 1:\n            result = 2;\n            break;\n\
    \        case 2:\n            result = 5;\n            break;\n        default:\n\
    \            result = starts_one_ends(n - 1) +\n                     starts_one_ends(n\
    \ - 2) +\n                     starts_one_ends(n - 2);\n            break;\n \
    \   }\n    return result;\n}", "{\n    static struct S {\n        long n;\n  \
    \      long power;\n        long ends;\n        long ends2;\n        long starts;\n\
    \        this(long n_) \n        {\n            n = n_;\n            power = 1;\n\
    \            ends = ends2 = starts = 0;\n            foreach (i; 0 .. n) \n  \
    \          {\n                power *= 10;\n                ends = ends * 10 +\
    \ 1;\n                ends2 = ends2 * 10 + 9;\n                starts = starts\
    \ * 10 + 9;\n            }\n        }\n    } \n    s;\n    static immutable long\
    \ MAX_N = 20;\n    static immutable static_type_tuple!(S[]) s_arr = static_type_tuple!(S[])[\n\
    \        S(1), S(2), S(3), S(4), S(5), S(6), S(7), S(8), S(9), S(10), S(11), S(12),\
    \ S(13), S(14), S(15), S(16), S(17), S(18), S(19), S(20)\n    ];\n    static if\
    \ (n <= MAX_N) \n    {\n        return s_arr[n - 1].starts + s_arr[n - 1].ends\
    \ + s_arr[n - 1].ends2;\n    }\n    else \n    {\n        return s.starts + s.ends\
    \ + s.ends2;\n    }\n}", "{\n    long result = 0;\n    if (n == 1)\n        return\
    \ result + 1;\n    else\n    {\n        long zeros = power(10, n - 1);\n     \
    \   result += zeros;\n        result += starts_one_ends(n - 1);\n        return\
    \ result;\n    }\n}\n/*\n    return the number of ways to arrange n items with\
    \ no restrictions.\n    http://www.cplusplus.com/reference/numeric/iota/\n*/\n\
    long factorial(long n) \n{\n    Tuple!(long) items;\n    items = tuple(iota(n));\n\
    \    return product(items);\n}\n/*\n    return the number of ways to arrange n\
    \ items in r ways.\n*/\nlong permutation(long n, long r) \n{\n    assert(r <=\
    \ n);\n    long result = 0;\n    if (r == n)\n        return result + 1;\n   \
    \ else\n    {\n        long zeros = power(10, n - 1);\n        result += zeros;\n\
    \        result += permutation(n - 1, r);\n        return result;\n    }\n}\n\
    /*\n    return the number of ways to arrange n items in r ways.\n*/\nlong combination(long\
    \ n, long r) \n{\n    assert(r <= n);\n    if (r == n)\n        return result\
    \ + 1;\n    else\n    {\n        long zeros = power(10, n - 1);\n        result\
    \ += zeros;\n        result += combination(n - 1, r);\n        return result;\n\
    \    }\n}", "{\n    long [long] dp;\n    dp[0] = 0;\n    dp[1] = 1;\n    auto\
    \ n_digits = log10(n) + 1;\n    auto n_digits_minus_one = n_digits - 1;\n    foreach\
    \ (i; 2 .. n_digits_minus_one) {\n        // i-th level, dp[i] is the count of\
    \ the numbers of i-digit\n        // positive integers that start or end with\
    \ 1.\n        dp[i] = pow(9, i - 1) * i;\n    }\n    dp[n_digits] = pow(9, n_digits\
    \ - 1) * n_digits;\n    // tail: a slice of the first n_digits_minus_one integers\n\
    \    auto tail = iota(n_digits_minus_one).array();\n    tail.popFront();\n   \
    \ long count = 0;\n    for (long i = 1; i < n_digits_minus_one; i++) {\n     \
    \   foreach (j; 0 .. i) {\n            long number = tail[j];\n            if\
    \ (number < 10) continue;\n            auto digit = number % 10;\n           \
    \ if (digit != 1) continue;\n            auto upper = i - j - 1;\n           \
    \ auto lower = n_digits_minus_one - j - 1;\n            auto this_count = pow(9,\
    \ upper) * pow(10, lower);\n            count += this_count;\n        }\n    \
    \    tail.popFront();\n    }\n    return count + dp[n_digits];\n}\n \n/*\n   \
    \ Given a positive integer n, return the count of the numbers of n-digit\n   \
    \ positive integers that start with 1.\n*/\nlong starts_one(long n) \n{\n    long\
    \ [long] dp;\n    dp[0] = 0;\n    dp[1] = 1;\n    foreach (i; 2 .. n) {\n    \
    \    // i-th level, dp[i] is the count of the numbers of i-digit\n        // positive\
    \ integers that start with 1.\n        dp[i] = pow(9, i", "{\n    if (n == 1)\
    \ return 2;\n    long k = n / 2;\n    long part1 = (long)pow(9, k);\n    long\
    \ part2 = (n % 2 == 0) ? 0 : (long)pow(9, k);\n    return part1 + part2;\n}\n\
    /*", "{\n    long result = 0;\n    if (n <= 1) \n    {\n        return 10;\n \
    \   } \n    else \n    {\n        if (n == 2) \n        {\n            return\
    \ 81;\n        } \n        else \n        {\n            result = 100;\n     \
    \       for (long i = 1; i < n - 1; i++) \n            {\n                result\
    \ *= 10;\n            }\n            return (10 * result);\n        }\n    }\n\
    }", "{\n    if (n == 1) \n        return 1;\n    else if (n == 2) \n        return\
    \ 4;\n    else \n        return 3 * starts_one_ends(n - 1) - starts_one_ends(n\
    \ - 2);\n}", "{ \n    if (n == 1) \n    { \n        return 2; \n    } \n  \n \
    \   if (n == 2) \n    { \n        return 5; \n    } \n  \n    long dp[][] = new\
    \ long[n + 1][2]; \n  \n    dp[0][0] = 0; \n    dp[0][1] = 0; \n    dp[1][0] =\
    \ 1; \n    dp[1][1] = 1; \n  \n    for (long i = 2; i <= n; i++) \n    { \n  \
    \      dp[i][0] = 9 * dp[i - 1][0] + dp[i - 1][1]; \n        dp[i][1] = dp[i -\
    \ 1][0]; \n    } \n  \n    return dp[n][0] + dp[n][1]; \n}", "{\n    long num\
    \ = 1;\n    long res = 0;\n    while (n)\n    {\n        res += num;\n       \
    \ num *= 10;\n        n--;\n    }\n    return res;\n}\n ", "{\n    long ret =\
    \ 0;\n    int mod = pow(10, n-1);\n    long range = pow(10, n);\n    for (long\
    \ i = 1; i < range; i++)\n    {\n        if (i % mod == 1)\n            ret++;\n\
    \    }\n    return ret;\n}\n/*\n    Given a positive integer n, return the count\
    \ of the numbers of n-digit\n    positive integers that start or end with 1.\n\
    \    \n    This is a solution that deals with the count of numbers having a particular\n\
    \    number of 1's in them.\n    \n    The code is rather complex, but is the\
    \ fastest solution by far.\n*/\nlong starts_one_ends_solution(long n)\n{\n   \
    \ auto ret = 0;\n    if (n < 0)\n        return 0;\n    if (n == 0)\n        return\
    \ 1;\n    auto range = pow(10, n);\n    auto maxOnes = 2 * n - 2;\n    auto minOnes\
    \ = 2;\n    auto ones = minOnes;\n    auto increment = 2;\n    while (ones <=\
    \ maxOnes)\n    {\n        auto twoOf = getOnes(range, ones);\n        ret +=\
    \ twoOf;\n        ones += increment;\n        increment++;\n    }\n    return\
    \ ret;\n}\nlong getOnes(long range, long ones)\n{\n    auto ret = 0;\n    for\
    \ (auto i = 0; i < range; i++)\n    {\n        if (i == 0)\n            ret +=\
    \ solve(ones);\n        else\n        {\n            auto tmp = solve(ones-1);\n\
    \            ret += tmp;\n        }\n    }\n    return ret;\n}\nlong solve(long\
    \ n)\n{\n    if (n == 0)\n        return 1;\n    if (n == 1)\n        return 2;\n\
    \    auto ret = 0;\n    ret += solve(n-1);\n    ret += pow(2, n-1);\n    return\
    \ ret;\n}", "{\n    if (n == 1) \n        return 1;\n    \n    if (n == 2) \n\
    \        return 1;\n    \n    if (n == 3) \n        return 1;\n    \n    if (n\
    \ == 4) \n        return 1;\n    \n    if (n == 5) \n        return 1;\n    \n\
    \    if (n == 6) \n        return 1;\n    \n    if (n == 7) \n        return 1;\n\
    \    \n    if (n == 8) \n        return 1;\n    \n    if (n == 9) \n        return\
    \ 1;\n    \n    if (n == 10) \n        return 2;\n    \n    if (n == 11) \n  \
    \      return 2;\n    \n    if (n == 12) \n        return 2;\n    \n    if (n\
    \ == 13) \n        return 2;\n    \n    if (n == 14) \n        return 2;\n   \
    \ \n    if (n == 15) \n        return 2;\n    \n    if (n == 16) \n        return\
    \ 2;\n    \n    if (n == 17) \n        return 2;\n    \n    if (n == 18) \n  \
    \      return 2;\n    \n    if (n == 19) \n        return 2;\n    \n    if (n\
    \ == 20) \n        return 3;\n    \n    if (n == 21) \n        return 3;\n   \
    \ \n    if (n == 22) \n        return 3;\n    \n    if (n == 23) \n        return\
    \ 3;\n    \n    if (n == 24) \n        return 3;\n    \n    if (n == 25) \n  \
    \      return 3;\n    \n    if (n == 26) \n        return 3;\n    \n    if (n\
    \ == 27) \n        return 3;\n    \n    if (n == 28) \n        return 3;\n   \
    \ \n    if (n == 29) \n        return 3;\n    \n    if (n == 30) \n        return\
    \ 4;\n    \n    if (n == 31) \n        return 4;\n    \n    if (n == 32) \n  \
    \      return 4;", "{\n    long total = 0;\n    auto x = pow(10, n-1);\n    if\
    \ (n == 1) {\n        total += 1;\n    } else {\n        for (int i = 0; i < 10;\
    \ i++) {\n            auto m = starts_one_ends(n-1);\n            auto num = x\
    \ + m;\n            auto f = num/10;\n            auto l = num%10;\n         \
    \   if (f == 1 || l == 1) {\n                total += num;\n            }\n  \
    \      }\n    }\n    return total;\n}\n//@pbe (constraint (= (f 0) 1))\n//@pbe\
    \ (constraint (= (f 1) 10))\n//@pbe (constraint (= (f 2) 55))\n//@pbe (constraint\
    \ (= (f 3) 220))\n//@pbe (constraint (= (f 4) 715))\n//@pbe (constraint (= (f\
    \ 5) 2002))\n//@pbe (constraint (= (f 6) 5005))\n//@pbe (constraint (= (f 7) 11440))\n\
    //@pbe (constraint (= (f 8) 24310))\n//@pbe (constraint (= (f 9) 48620))\n//@pbe\
    \ (constraint (= (f 10) 92378))\n//@pbe (constraint (= (f 11) 167960))\n//@pbe\
    \ (constraint (= (f 12) 293930))\n//@pbe (constraint (= (f 13) 497420))\n//@pbe\
    \ (constraint (= (f 14) 817190))\n//@pbe (constraint (= (f 15) 1307504))\n//@pbe\
    \ (constraint (= (f 16) 2042975))\n//@pbe (constraint (= (f 17) 3124550))\n//@pbe\
    \ (constraint (= (f 18) 4686825))\n//@pbe (constraint (= (f 19) 6782230))\n//@pbe\
    \ (constraint (= (f 20) 10015005))\n//@pbe (constraint (= (", "{\n    static assert(n>=1);\n\
    \    if (n==1) \n        return 1;\n    long result = 0;\n    foreach (i; iota(n-1))\n\
    \        result += starts_one_ends(i+1) * starts_one_ends(n-1-i);\n    return\
    \ result;\n}\n/*\n    1*n + 10*(n-1) + 100*(n-2) + ... + 10^(n-1)*1\n    10^(n-1)\
    \ = 1 + 9*(1+10+100+...+10^(n-2))\n    10^(n-1) = 1 + 9*(1+starts_one_ends(n-1))\n\
    \    10^(n-1) - 9 = 10^(n-1) + starts_one_ends(n-1)\n    start(n) = 10^(n-1) +\
    \ starts_one_ends(n-1)\n*/\nlong starts_one(long n) \n{\n    static assert(n>=1);\n\
    \    if (n==1) \n        return 1;\n    return (long)pow(10, n-1) + starts_one_ends(n-1);\n\
    }\n/*\n    10^(n-1)*n + 1*n + 10*(n-1) + 100*(n-2) + ... + 10^(n-1)*1\n    10^n\
    \ - 10 = 10^(n-1)*n + start(n)\n    end(n) = 10^n - 10\n*/\nlong ends_one(long\
    \ n) \n{\n    static assert(n>=1);\n    if (n==1) \n        return 1;\n    return\
    \ (long)pow(10, n) - 10;\n}\nlong starts_one_count(long n) \n{\n    static assert(n>=1);\n\
    \    if (n==1) \n        return 1;\n    return starts_one(n) + starts_one_count(n-1);\n\
    }\n/*\n    Given a positive integer n, return the count of the numbers of n-digit\n\
    \    positive integers that start", "{\n    long res = 0;\n    for (long i = 1;\
    \ i <= n; i++) \n    {\n        res += pow(2, i - 1);\n    }\n    return res;\n\
    }", "{\n    if (n == 1) \n        return 0;\n    if (n == 2) \n        return\
    \ 9;\n    if (n == 3) \n        return 180;\n    long size = n + (n-1);\n    long[][]\
    \ dp = new long[n+1][size+1];\n    for (int i = 0; i <= n; i++) \n        dp[i][0]\
    \ = 0;\n    for (int i = 0; i <= size; i++) \n        dp[0][i] = 0;\n    for (int\
    \ i = 1; i <= n; i++) \n        dp[i][i-1] = 0;\n    dp[1][1] = 9;\n    for (int\
    \ i = 2; i <= n; i++) \n    {\n        for (int j = 1; j <= i+i-1; j++) \n   \
    \     {\n            if (j > n-1) \n                dp[i][j] = dp[i][j-1] + dp[i-1][j-1];\n\
    \            else \n                dp[i][j] = dp[i][j-1] + dp[i-1][j-1] - dp[i-1][j];\n\
    \        }\n    }\n    return dp[n][size];\n}", "{\n    if (n==1) return 1;\n\
    \    if (n==2) return 2;\n    if (n==3) return 4;\n    long result = 0;\n    for\
    \ (long i=1; i<n; i++) {\n        result += starts_one_ends(i);\n    }\n    return\
    \ result*9+pow(10,n-1);\n}", "{ \n    return (n * (pow(10,n-1))); \n} ", "{\n\
    \    static struct number_digit\n    {\n        long count;\n        long rest;\n\
    \    }\n    int[] digits = new int[10];\n    long i = 0;\n    long count = 0;\n\
    \    long base = 1;\n    long total = 0;\n    long digit = 0;\n    while (i <\
    \ n)\n    {\n        digits[i] = new number_digit;\n        ++i;\n    }\n    digits[0].count\
    \ = 9;\n    digits[0].rest = 0;\n    i = 1;\n    while (i < n)\n    {\n      \
    \  digits[i].count = 9 * base;\n        digits[i].rest = base;\n        base *=\
    \ 10;\n        ++i;\n    }\n    base = 1;\n    i = 0;\n    while (i < n)\n   \
    \ {\n        total += digits[i].count;\n        if (base == 1)\n        {\n  \
    \          count += digits[i].count;\n        }\n        else\n        {\n   \
    \         count += digits[i].rest;\n        }\n        base *= 10;\n        ++i;\n\
    \    }\n    return count;\n}", "{\n    /*\n        This function counts the number\
    \ of n-digit positive integers that\n        start or end with 1.", "{\n    return\
    \ 0;\n}", "{ \n    long num = (int)pow(10, n-1);\n    long num1 = (int)pow(10,\
    \ n) - 1;\n    long result = 0;\n    foreach(i;iota(num, num1+1)){\n        auto\
    \ chain = chain(i);\n        if(chain[0] == '1' || chain[$-1] == '1'){\n     \
    \       result++;\n        }\n    }\n    return result;\n}", "{\n    static struct\
    \ S \n    {\n        static long ctr;\n        static void inc() {++ctr;}\n  \
    \      static long get() {return ctr;}\n    } static s;\n    //\n    if (n ==\
    \ 1) return 1;\n    else if (n == 2) return 11;\n    else if (n == 3) return 111;\n\
    \    else if (n == 4) return 1111;\n    else if (n == 5) return 11111;\n    else\
    \ if (n == 6) return 111111;\n    else if (n == 7) return 1111111;\n    else if\
    \ (n == 8) return 11111111;\n    else if (n == 9) return 111111111;\n    else\
    \ if (n == 10) return 1111111111;\n    else if (n == 11) return 11111111111;\n\
    \    else if (n == 12) return 111111111111;\n    else if (n == 13) return 1111111111111;\n\
    \    else if (n == 14) return 11111111111111;\n    else if (n == 15) return 111111111111111;\n\
    \    else if (n == 16) return 1111111111111111;\n    else if (n == 17) return\
    \ 11111111111111111;\n    else if (n == 18) return 111111111111111111;\n    else\
    \ if (n == 19) return 1111111111111111111;\n    else if (n == 20) return 11111111111111111111;\n\
    \    else if (n == 21) return 111111111111111111111;\n    else if (n == 22) return\
    \ 1111111111111111111111;\n    else if (n == 23) return 11111111111111111111111;\n\
    \    else if (n == 24) return 111111111111111111111111;\n    else if (n == 25)\
    \ return 1111111111111111111111111;\n    else if (n == 26) return 11111111111111111111111111;\n\
    \    else if (n == 27) return 111111111111111111111111111;\n    else if (n ==\
    \ 28) return 1111111111111111111111111111;\n    else if (n == 29) return 11111111111111111111111111111;\n\
    \    else if (n == 30) return 111111111111111111111111111111;", "{\n    long result;\n\
    \    switch (n) {\n        case 1 :\n            result = 2;\n            break;\n\
    \        case 2 :\n            result = 4;\n            break;\n        default\
    \ :\n            result = starts_one_ends(n - 1) + starts_one_ends(n - 2);\n \
    \           break;\n    }\n    return result;\n}", "{\n    if (n <= 0) return\
    \ 0;\n    else return (10^(n-1)) - (10^(n-2));\n}", "{\n    auto a = 0;\n    auto\
    \ b = 1;\n    auto c = 0;\n    auto d = 1;\n    auto i = n;\n    while (i > 0)\
    \ {\n        a = ((10 * a) + b) % 1000000007;\n        b = (b + c) % 1000000007;\n\
    \        c = ((10 * c) + d) % 1000000007;\n        d = (d + a) % 1000000007;\n\
    \        i -= 1;\n    }\n    return ((n - 1) * ((a + b) % 1000000007)) % 1000000007;\n\
    }", "{\n    long long nn = n;\n    long long first_digit = nn / 10;\n    return\
    \ (n <= 1) ? n : first_digit + (10 - first_digit) * (n - 1);\n}\n/*\n    It's\
    \ obvious that when n <= 2, the answer is always n. \n    Let's assume that n\
    \ > 2. There are two ways to get a n-digit number start or \n    end with 1:",
  "{\n    if (n == 1) return 1;\n    return (9 * pow(10, n - 1)) + starts_one_ends(n\
    \ - 1);\n}", "{\n    ulong result = 0;\n    foreach(ulong i;0..n)\n    {\n   \
    \     ulong tmp = pow(10,i);\n        result += tmp;\n    }\n    return result;\n\
    }", "{\n    return int(pow(10,n)) - int(pow(9,n)) + int(pow(9,n-1));\n}", "{\n\
    \tlong end_count = 1;\n\tlong start_count = 1;\n\tlong mod = 100000;\n\tfor (long\
    \ i = 2; i < n; i++) {\n\t\tmod *= 10;\n\t\tend_count += cast(long) pow(10, i\
    \ - 1);\n\t\tstart_count += end_count;\n\t}\n\tlong total = end_count + start_count;\n\
    \tif (total > mod) {\n\t\ttotal %= mod;\n\t}\n\treturn total;\n}", "{ \n    long[long]\
    \ dp = new long[long[](n + 1, 0)];\n    dp[1] = 10;\n    long ret = 10;\n    foreach\
    \ (i; 2 .. n + 1) {\n        dp[i] = dp[i - 1] * 9 + pow(10, i - 1);\n       \
    \ ret += dp[i];\n    }\n    return ret;\n}", "{\n    long nx1 = n-1;\n    return\
    \ pow(10, nx1);\n}\n/*", "{\n    return n == 1 ? 2 : starts_one_ends(n - 1) +\
    \ (n - 1) * (long)pow(10, n - 2);\n}", "{\n    if (n < 1)\n        return 0;\n\
    \    else if (n == 1)\n        return 2;\n    else\n        return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2);\n}", "{\n    if (n==1) return 2;\n    long nums\
    \ = n;\n    long counts = 0;\n    for (; nums < math.pow(10, n); nums++) {\n \
    \       if (nums % 10 == 1 || nums / math.pow(10, n-1) == 1)\n            counts++;\n\
    \    }\n    return counts;\n}", "{\n    assert(n > 0);\n    return (long)pow(10,\
    \ n - 1);\n}\nlong count_num(long n) \n{\n    assert(n > 0);\n    return starts_one_ends(n)\
    \ * 9;\n}", "{\n    long ret = 0;\n    long lo = (long)pow(10, n - 1);\n    long\
    \ hi = (long)pow(10, n) - 1;\n    foreach (i; lo .. hi + 1)\n    {\n        if\
    \ (is_1(i))\n            ret++;\n    }\n    return ret;\n}", "{\n    if (n ==\
    \ 1)\n        return 10;\n    \n    return power(10L, n-1) + (n-1) * power(9L,\
    \ n-1);\n}", "{\n    long num = 1;\n    long den = 1;\n    long ans = 0;\n   \
    \ auto counts = tuple(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L);\n    num = 10 -\
    \ 1;\n    den = 9;\n    for (long i = 1; i < n; i++) {\n        num *= 10 - 1;\n\
    \        den *= 9;\n    }\n    ans = num / den;\n    return ans;\n}", "{\n   \
    \ long count = 0;\n    if (n == 1) \n    {\n        return 1;\n    }\n    for\
    \ (long i = 1; i < n; i++) \n    {\n        count += pow(10, i - 1);\n    }\n\
    \    return count * 2;\n}", "{\n    if (n == 1)\n        return 9;\n    return\
    \ (9 * (10 ** (n - 1))) + starts_one_ends(n - 1);\n}", "{\n    enum E = n*8/3;\n\
    \    auto bits_in_n = (n*8/3+1);\n    auto dp = uint[0..bits_in_n][0..1];\n  \
    \  dp[0][0] = 1;\n    foreach(i; 1..bits_in_n)\n    {\n        dp[i][0] = dp[i-1][0]\
    \ + dp[i-1][1];\n        dp[i][1] = dp[i-1][0];\n    }\n    return dp[bits_in_n-1][0]\
    \ + dp[bits_in_n-1][1];\n}", "{\n    return (n < 2) ? 1 : \n        pow(2, n -\
    \ 1) + \n        starts_one_ends(n - 1);\n}", "{\n    return (exp(cast(double)n)\
    \ - 1) / (exp(1) - 1);\n}\n/*\nlong ends_one_ends(long n) \n{\n    return (exp(cast(double)n)\
    \ - 1) / (exp(1) - 1);\n}\n*/", "{\n\tlong ret;\n\tstatic struct ONE end_one;\n\
    \t\n\tif (n == 1) return 1;\n\t\n\tstatic if (is(typeof(end_one) == struct)) {\n\
    \t\tif (end_one.n == n)\n\t\t\treturn end_one.ret;\n\t} else {\n\t\tend_one =\
    \ ONE(n, 0);\n\t}\n\t\n\tret = starts_one_ends(n - 1) + pow(10, n - 1);\n\tend_one.ret\
    \ = ret;\n\treturn ret;\n}", "{ \n    long left = 1, right = 0; \n    long count\
    \ = 0; \n    int len = n; \n    while (len) \n    { \n        count += left *\
    \ 9 * pow(10, len - 1); \n        right += left; \n        left = right; \n  \
    \      len--; \n    } \n    return count; \n} ", "{\n    long a = pow(10, n -\
    \ 1);\n    long b = 10 * a;\n    return b - a + 1;\n}", "{ \n    long result =\
    \ 0;\n    result = (long) pow(10, n - 1); \n    return result; \n} ", "{ \n  \
    \  long l = n - 1;\n    if (n < 2)\n        return l;\n    l *= 9;\n    l += start_one_ends(n\
    \ - 1);\n    return l;\n}", "{\n\tlong t = 1;\n\tlong res = 0;\n\tlong i = 1;\n\
    \tlong k = 1;\n\tlong d;\n\twhile (i <= n)\n\t{\n\t\td = n - i;\n\t\tk = 9;\n\t\
    \twhile (d > 0)\n\t\t{\n\t\t\tk *= 10;\n\t\t\td--;\n\t\t}\n\t\tres += k;\n\t\t\
    i++;\n\t}\n\treturn res;\n}", "{ \n    // In the case of 0 or 1 digit numbers,\
    \ the number of integers is the same\n    // as the number of digits\n    if (n\
    \ <= 1)\n        return n;\n    \n    // In the case of numbers that start or\
    \ end with 1, 10**(n-1) of the numbers\n    // are of the form 10**(n-1) * d,\
    \ and 9 of these always start with 1.\n    // The remaining 10**(n-1) - 9 start\
    \ with either 1 or 2, so are of the form\n    // 10**(n-1) * d + x where x >=\
    \ 1 and x <= 8\n    // However, since we have already counted the 10**(n-1) numbers\
    \ that start\n    // with 1, we only count those numbers where x >= 2\n    //\
    \ Furthermore, since we have already counted the 10**(n-1) numbers that\n    //\
    \ start with 1 or 2, we only count those numbers where x >= 3\n    // We can proceed\
    \ in this way until we count all numbers.\n    // This gives us the total number\
    \ of n-digit integers that start or end\n    // with 1.\n    // We subtract 1\
    \ to account for the fact that we have counted the number\n    // 1 twice.\n \
    \   long result = 1;\n    for (int i = 1; i < n; i++)\n        result += (9*10**(i-1))*(n-i);\n\
    \    return result - 1;\n}", "{\n    return (n - 1) * 10 + 1;\n}", "{ \n    //\
    \ dp[i][j] contains count of j digits numbers with i 1's and i 0's \n    // i\
    \ is up to 8. j is up to 9\n    long[9][10] dp;\n    dp[0][0] = 1;\n    // dp[i][0]\
    \ = 0 for i>0 because we cannot make number with 0 digits and at least 1 1\n \
    \   // dp[0][j] is 1 for all j because we can only make 1 with 0 1's.\n    //\
    \ dp[i][j] is sum of dp[i-1][j-1] and dp[i][j-1]\n    // dp[i-1][j-1] is count\
    \ of j-1 digit numbers with i-1 1's and i 0's\n    // dp[i][j-1] is count of j-1\
    \ digit numbers with i 1's and i 0's\n    // so, to make j digit number with i\
    \ 1's and i 0's, we can add a 1 at the end of all j-1 digit numbers with i-1 1's\
    \ and i 0's.\n    // or we can add a 0 at the end of all j-1 digit numbers with\
    \ i 1's and i 0's.\n    foreach(i; 1..8) {\n        foreach(j; 1..9) {\n     \
    \       dp[i][j] = dp[i-1][j-1] + dp[i][j-1];\n        }\n    }\n    // Now we\
    \ have counts of 1's and 0's in numbers of all lengths.\n    // Count of numbers\
    \ of length n with 1's and 0's is sum of counts for 1's and 0's in numbers of\
    \ length n.\n    // After that, the count is dp[1][n] + dp[2][n] + .. dp[8][n]\n\
    \    long sum = 0;\n    foreach(i; 1..8) {\n        sum += dp[i][n];\n    }\n\
    \    return sum;\n} \n \n// Driver code ", "{ \n    if (n <= 1) return 0;\n  \
    \  long k = (n - 1) / 2;\n    long res = pow(10, k);\n    long ones = n - 2 *\
    \ k;\n    if (ones > 0) {\n        if (k > 0) {\n            res = res + 9 * pow(10,\
    \ k - 1);\n        } else {\n            res = res + ones;\n        }\n    }\n\
    \    return res;\n}\nstatic assert(starts_one_ends(5) == 49);\nstatic assert(starts_one_ends(4)\
    \ == 30);\nstatic assert(starts_one_ends(3) == 10);\nstatic assert(starts_one_ends(2)\
    \ == 0);\nstatic assert(starts_one_ends(1) == 0);\n/*\n    Given an integer n,\
    \ return all possible sequences that sum to n.\n    Each sequence may or may not\
    \ contain all numbers from 1 to n.", "{\n    enum e = 2*n -1;\n    long count\
    \ = 0;\n    long d = n;\n    foreach(int; i; 0..d+1)\n    {\n        long r =\
    \ 10^e + 1 - 10^(e-i);\n        count += r;\n    }\n    return count;\n}", "{\n\
    \    //\n    // We're going to use the \"stars and bars\" combinatorial technique\
    \ here.\n    //\n    // For example, say we want the number of 4-digit positive\
    \ integers that\n    // start with 1.\n    //\n    // The number of ways to choose\
    \ the 1 is clearly 1.\n    // The number of ways to choose the next 3 digits is\
    \ 10^3.\n    // Therefore, the total number of integers is 10^3.\n    //\n   \
    \ // But, we're not just looking for integers that start with 1, we're also\n\
    \    // looking for integers that end with 1.\n    //\n    // In order to count\
    \ those, we can simply imagine taking our example above\n    // and flipping it\
    \ on its head. That is, we now want 4-digit integers that\n    // end with 1.\n\
    \    //\n    // The number of ways to choose the last digit is clearly 1.\n  \
    \  // The number of ways to choose the first 3 digits is 10^3.\n    // Therefore,\
    \ the total number of integers is 10^3.\n    //\n    // Thus, the total number\
    \ of integers that start or end with 1 is\n    //\n    //     10^3 + 10^3 = 10^3\
    \ * 2\n    //\n    //\n    // For example, say we want the number of 7-digit positive\
    \ integers that\n    // start with 1.\n    //\n    // The number of ways to choose\
    \ the 1 is clearly 1.\n    // The number of ways to choose the next 6 digits is\
    \ 10^6.\n    // Therefore, the total number of integers is 10^6.\n    //\n   \
    \ // But, we're not just looking for integers that start with 1, we're also\n\
    \    // looking for integers that end with 1.\n    //\n    // In order to count\
    \ those, we can simply imagine taking our example above\n    // and flipping it\
    \ on its head. That is, we now want 7-digit integers that\n    // end with 1.\n\
    \    //\n    // The number of ways to choose the last digit is clearly 1.\n  \
    \  // The number of ways to choose the first 6 digits is 10^6.\n    // Therefore,\
    \ the total number of integers is 10^6.\n    //\n    // Thus, the total number\
    \ of integers that start or end with", "{\n    /*\n        X = 10^n\n        then:\n\
    \        result = X / 2 +\n                 X / 4 +\n                 X / 8 +\n\
    \                 ... +\n                 X / (2^(n-1))\n    */\n    long X =\
    \ ipow(10L, n);\n    long result = 0;\n    long multiplier = 1;\n    while (multiplier\
    \ <= n)\n    {\n        result += X / (2L * multiplier);\n        multiplier *=\
    \ 2;\n    }\n    return result;\n}", "{\n    auto digits = [](long n) pure nothrow\
    \ @nogc => n < 10 ? 1 : digits(n / 10) + 1;\n    if (n == 1) \n        return\
    \ 2;\n    else \n        return 0.5 * (power(10.0L, n - 1) - power(9.0L, n - 1))\
    \ + 0.5 * (power(10.0L, n - 2) - power(9.0L, n - 2));\n}", "{\n    if (n <= 0)\n\
    \        return 0;\n    else if (n == 1)\n        return 1;\n    else \n    {\n\
    \        long power = (long) pow(10, n - 1);\n        return starts_one_ends(n\
    \ - 1) + (power - 1) * power / 9;\n    }\n}\n ", "{\n    long[] counts;\n    long\
    \ total = 0;\n    long limit = 10 ^ n;\n    long count = 1;\n    long i = 0;\n\
    \    long j = 0;\n    long sum = 0;\n    long current = 1;\n    long sum_total\
    \ = 0;\n    long val = 0;\n    long k = 0;\n    long m = 0;\n    long f = 0;\n\
    \    long s = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long\
    \ d = 0;\n    long e = 0;\n    long h = 0;\n    long l = 0;\n    long g = 0;\n\
    \    long v = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long\
    \ u = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n\
    \    counts = new long[n + 1];\n    for (i = 1; i <= n; i++) {\n        val =\
    \ 10 ^ i;\n        if (i == 1) {\n            counts[i] = 2;\n        } else {\n\
    \            counts[i] = 9 * (i - 1) * 10 ^ (i - 2);\n        }\n        writeln(counts[i]);\n\
    \    }\n    return 1;\n}", "{ \n    long dp[][] = new long[2][n + 1]; \n    dp[0][1]\
    \ = 0; \n    dp[1][1] = 1; \n    for (int i = 2; i <= n; i++) { \n        dp[0][i]\
    \ = dp[0][i - 1] + dp[1][i - 1]; \n        dp[1][i] = dp[0][i - 1]; \n    } \n\
    \    return dp[0][n] + dp[1][n]; \n} ", "{\n    long digits = 1;\n    long res\
    \ = 0;\n    long start = 2;\n    long end = 0;\n    long count = 10;\n    long\
    \ index = 1;\n    while (digits < n)\n    {\n        end = count;\n        count\
    \ *= 10;\n        res += end - start;\n        start = end;\n        digits++;\n\
    \    }\n    res += count / 10;\n    return res;\n}", "{\n    return n ? \n   \
    \     pow(5, n-1) + 4 * pow(5, n-2) :\n        0;\n}", "{\n    long max_limit\
    \ = long(pow(10, n));\n    long min_limit = long(pow(10, n - 1));\n    return\
    \ (max_limit - min_limit) * 9 + min_limit;\n}", "{\n    static struct Helper\n\
    \    {\n        int[int] cache;\n        auto operator()() -> long\n        {\n\
    \            return 0;\n        }\n        auto operator()(int n) -> long\n  \
    \      {\n            if (cache.count(n))\n                return cache[n];\n\
    \            else\n            {\n                auto r = (*this)(n - 1) + 9\
    \ * pow(10, n - 1);\n                cache[n] = r;\n                return r;\n\
    \            }\n        }\n    } helper;\n    if (n < 0)\n        return 0;\n\
    \    return helper(n);\n}", "{\n    long[4] fact_arr = factorials!long(4);\n \
    \   switch(n) {\n        case 1:\n            return 2;\n        case 2:\n   \
    \         return 10;\n        default:\n            long result = fact_arr[n]/fact_arr[n-2];\n\
    \            return (result*9/10);\n    }\n}", "{ \n    long s = 0;\n    if (n\
    \ == 1) \n        return 2; \n    if (n == 2) \n        return 4; \n    s = starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2); \n    return s; \n} \n  \nlong ways_to_start_one(long\
    \ n) \n{ \n    long n1, n2, n3; \n    n1 = n2 = n3 = 0; \n    if (n == 1) \n \
    \       return 2; \n    if (n == 2) \n        return 4; \n    if (n == 3) \n \
    \       return 6; \n    n1 = ways_to_start_one(n - 1); \n    n2 = ways_to_start_one(n\
    \ - 2); \n    n3 = ways_to_start_one(n - 3); \n    return (n1 + n2 + n3); \n} ",
  "{\n    static long[const] digits = [0L,1L,2L,3L,4L,5L,6L,7L,8L,9L];\n    static\
    \ long[string] memo = [\"0\":1,\"1\":2];\n    static long count(long n) \n   \
    \ {\n        if (n == 0) return 1;\n        if (n == 1) return 2;\n        //\
    \ if not a multiple of 2, then there is no way to start and end with a 1\n   \
    \     if (n % 2 == 1) return count(n-1);\n        auto key = n.stringof;\n   \
    \     if (key in memo) return memo[key];\n        long result = 0;\n        foreach\
    \ (d; digits) \n        {\n            if (d == 0) continue;\n            result\
    \ += count(n-1);\n        }\n        memo[key] = result;\n        return result;\n\
    \    }\n    return count(n);\n}\n// ----\nlong starts_one_ends2(long n) \n{\n\
    \    static long[const] digits = [0L,1L,2L,3L,4L,5L,6L,7L,8L,9L];\n    static\
    \ long count(long n) \n    {\n        if (n == 0) return 1;\n        if (n ==\
    \ 1) return 2;\n        // if not a multiple of 2, then there is no way to start\
    \ and end with a 1\n        if (n % 2 == 1) return count(n-1);\n        long result\
    \ = 0;\n        foreach (d; digits) \n        {\n            if (d == 0) continue;\n\
    \            result += count(n-1);\n        }\n        return result;\n    }\n\
    \    return count(n);\n}\n// ----\nlong starts_one_ends3(long n) \n{\n    static\
    \ long[const] digits = [0L,1L,2L,3L,4L,5L,6L,7L,8L,9L];\n    if (n == 0) return\
    \ 1;\n    if (n == 1) return 2;\n    // if not a multiple of 2, then there is\
    \ no", "{\n    auto f = [=](long d) \n    {\n        return d <= 1 ? 1 : (long)pow(10.0,\
    \ d - 1);\n    };\n    return f(n) + (n - 1) * 9 * f(n - 1);\n}\n/*", "{\n   \
    \ long num(long n, bool starts_one)\n    {\n        if (n == 1) return 1;\n  \
    \      long result = 0;\n        if (starts_one) {\n            if (n == 2) return\
    \ 9;\n            long m = 1;\n            for (long i = 1; i < n; i++) m *= 10;\n\
    \            result = 9 * m;\n            for (long i = 2; i < n; i++) {\n   \
    \             result += num(i, false) * 9 * m;\n            }\n        } else\
    \ {\n            for (long i = 1; i < n; i++) result += num(i, true);\n      \
    \  }\n        return result;\n    }\n    if (n < 1) return 0;\n    if (n == 1)\
    \ return 1;\n    return num(n, true) + num(n, false);\n}", "{\n    long res =\
    \ 0;\n    if (n < 2)\n        return res;\n    long end_one = (long)pow(10, n\
    \ - 1);\n    res += end_one;\n    if (n > 2)\n        res += (n - 2) * (end_one\
    \ / 10);\n    return res;\n}\n/*\n    Given a positive integer n, return the count\
    \ of the numbers of n-digit\n    positive integers that start or end with 1, or\
    \ 2.\n*/\nlong starts_one_two_ends(long n) \n{\n    return starts_one_ends(n)\
    \ + starts_one_ends(n - 1);\n}\n/*\n    Given a positive integer n, return the\
    \ count of the numbers of n-digit\n    positive integers that start or end with\
    \ 1, or 2, or 3.\n*/\nlong starts_one_two_three_ends(long n) \n{\n    return starts_one_ends(n)\
    \ + starts_one_ends(n - 1) + starts_one_ends(n - 2);\n}\n/*\n    Given a positive\
    \ integer n, return the count of the numbers of n-digit\n    positive integers\
    \ that start or end with 1, or 2, or 3, or 4.\n*/\nlong starts_one_two_three_four_ends(long\
    \ n) \n{\n    return starts_one_ends(n) + starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2) + starts_one_ends(n - 3);\n}\n/*\n    Given a positive integer n, return\
    \ the count of the numbers of n-digit\n    positive integers that start or end\
    \ with 1, or 2, or 3, or 4, or 5.\n*/\nlong starts_one_two_three_four_five_ends(long\
    \ n) \n{\n    return starts_one_ends(n) + starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2) + starts_one_ends(n - 3) + starts_one_ends(n - 4);\n}\n/*\n    Given a\
    \ positive integer n, return the count of the numbers of n-digit\n    positive\
    \ integers that start or end with 1,", "{\n    long result = 0;\n    long val\
    \ = 0;\n    int i;\n    if (n == 1)\n        return 10;\n    \n    if (n == 2)\n\
    \        return 91;\n    \n    val = 9;\n    for (i = 2; i <= n - 1; i++)\n  \
    \      val *= 10;\n    result += val;\n    \n    // The next number if the digits\
    \ are all ones is 1,000,000\n    // This means that there are one million - 1,000\
    \ numbers\n    // with a one in the front digit.\n    if (n == 7)\n        result\
    \ += 999999;\n    else\n        result += pow(10, n) - pow(10, n - 1);\n    \n\
    \    return result;\n}", "{\n    assert(n > 0);\n    return (n == 1) ? 10 : starts_one_ends(n\
    \ - 1) + 10.pow(n - 1);\n}", "{\n    return n > 1 ? (4 * pow(5.0, n - 2) + starts_one_ends(n\
    \ - 1)) : 0;\n}\n/*", "{\n    assert(n > 0);\n    // Returns the count of starting\
    \ or ending with one.\n    return pow(5L, n - 1L);\n}", "{\n    if (n == 1)\n\
    \        return 1;\n    // all integers that start with 1 are 1xx...x\n    //\
    \ The first digit is always 1\n    // The other n-1 digits can be anything from\
    \ 0 to 9\n    // We have n-1 places where each one can be 0 or 1\n    // The total\
    \ number of digits is 2^(n-1)\n    long result = (cast(long)pow(2, n-1));\n  \
    \  return result;\n}", "{\n    long c1 = n-1;\n    long c2 = n==1 ? 1 : n;\n \
    \   long c3 = n;\n    long c4 = c2;\n    long c5 = n;\n    long sum = c1 + c2\
    \ + c3 + c4 + c5;\n    return sum;\n}", "{\n    return \n        n == 1 ? 2 :\
    \ // 1xx, x1x\n        n == 2 ? 4 : // 11x, 1x1, x11, xx1\n        n == 3 ? 6\
    \ : // 111, 1x1, x11, xx1, 11x, x1x\n        n == 4 ? 8 : // 1111, 1x11, x111,\
    \ xx11, 11x1, x1x1, 1xx1, xxx1\n        n == 5 ? 10 : // 1111, 1x11, x111, xx11,\
    \ 11x1, x1x1, 1xx1, xxx1, 11xx, xx1x\n        n == 6 ? 12 : // 11111, 1x111, x1111,\
    \ xx111, 11x11, x1x11, 1xx11, xxx11, 11xx1, xx1x1, 1xxx1, xxxx1\n        n ==\
    \ 7 ? 14 : // 11111, 1x111, x1111, xx111, 11x11, x1x11, 1xx11, xxx11, 11xx1, xx1x1,\
    \ 1xxx1, xxxx1, 11xxx, xx1xx, xxx1x\n        n == 8 ? 16 : // 111111, 1x1111,\
    \ x11111, xx1111, 11x111, x1x111, 1xx111, xxx111, 11xx11, xx1x11, 1xxx11, xxxx11,\
    \ 11xx1x, xx1x1x, 1xxx1x, xxxx1x\n        n == 9 ? 18 : // 111111, 1x1111, x11111,\
    \ xx1111, 11x111, x1x111, 1xx111, xxx111, 11xx11, xx1x11, 1xxx11, xxxx11, 11xx1x,\
    \ xx1x1x, 1xxx1x, xxxx1x, 11xxxx, xx1xxx, xxx1xx, xxxx1x\n        n == 10 ? 20\
    \ : // 111111, 1x1111, x11111, xx1111, 11x111, x1x111, 1xx111, xxx111, 11xx11,\
    \ xx1x11, 1xxx11, xxxx11, 11xx1x, xx1x1x", "{\n    return cast(long) std.math.pow(9,\
    \ n) + cast(long) std.math.pow(9, n-1);\n}", "{ \n    if (n == 1) \n        return\
    \ 10; \n  \n    long count = 10; \n    long prev = 10; \n    long cur = 9; \n\
    \    long digit = 9; \n  \n    for (long i = 1; i < n; i++) \n    { \n       \
    \ digit--; \n        prev = cur; \n        cur = cur * digit; \n        count\
    \ += prev; \n    } \n  \n    return count; \n} ", "{\n    switch(n) {\n      \
    \  case 1: return 1;\n        case 2: return 10;\n        case 3: return 100;\n\
    \        case 4: return 190;\n        case 5: return 373;\n        case 6: return\
    \ 709;\n        case 7: return 1383;\n        case 8: return 2699;\n        case\
    \ 9: return 5204;\n        case 10: return 9999;\n        default: assert(0);\n\
    \    }\n}", "{ \n    if (n == 1) \n    { \n        return 1; \n    } \n    if\
    \ (n == 2) \n    { \n        return 1; \n    } \n    if (n == 3) \n    { \n  \
    \      return 2; \n    } \n    if (n == 4) \n    { \n        return 3; \n    }\
    \ \n    if (n == 5) \n    { \n        return 4; \n    } \n    if (n == 6) \n \
    \   { \n        return 5; \n    } \n    if (n == 7) \n    { \n        return 6;\
    \ \n    } \n    if (n == 8) \n    { \n        return 7; \n    } \n    if (n ==\
    \ 9) \n    { \n        return 8; \n    } \n    return starts_one_ends(n - 1) \n\
    \        + starts_one_ends(n - 2) \n        + starts_one_ends(n - 3) \n      \
    \  + starts_one_ends(n - 4) \n        + starts_one_ends(n - 5) \n        + starts_one_ends(n\
    \ - 6) \n        + starts_one_ends(n - 7) \n        + starts_one_ends(n - 8) \n\
    \        + starts_one_ends(n - 9); \n} \n  ", "{\n    assert(n > 0);\n    return\
    \ 10_L^(n-1) - 9_L^(n-1);\n}", "{\n    // The count that begins and ends with\
    \ a 1\n    // E.g. 11, 1101, 11001, 1111, 11011...\n    // This is the sum of\
    \ the powers of 2 from 2^1 to 2^(n-1)\n    long ends_one_starts = pow(2, n - 1);\n\
    \    \n    // The count that starts with 1 is the sum of all numbers that do not\n\
    \    // start and end with 1\n    // E.g. 1, 101, 1001, 1011, 10001, 10011, 10101...\n\
    \    // This is the sum of the powers of 2 from 2^(n-1) to 2^n\n    long starts_one\
    \ = pow(2, n) - ends_one_starts;\n    \n    // The count that ends with 1 is the\
    \ same as the count that starts with 1\n    long ends_one = starts_one;\n    \n\
    \    // So the count that starts and ends with 1 is the sum of the two\n    return\
    \ starts_one + ends_one;\n}", "{\n    if (n == 1)\n        return 10;\n    \n\
    \    // S(n) = S(n-1) + S(n-2) + S(n-3) + S(n-4) + ... + S(1) - 10\n    // S(n)\
    \ = 10(2^(n-1)-1) + S(n-1)\n    if (n <= 0)\n        return 0;\n    long S_1 =\
    \ 10;\n    long S_2 = 90;\n    long S_n = 0;\n    for (int i = 3; i <= n; i++)\
    \ {\n        S_n = 10 * ((int)(pow(2, i-1)) - 1) + S_1;\n        S_1 = S_2;\n\
    \        S_2 = S_n;\n    }\n    return S_n;\n}", "{\n    long count;\n    long\
    \ j;\n    if (n == 1) \n    {\n        return 1;\n    }\n    else \n    {\n  \
    \      count = starts_one_ends(n - 1);\n        if (n == 2) \n        {\n    \
    \        count *= 9;\n        }\n        else \n        {\n            count *=\
    \ 10;\n        }\n        return count;\n    }\n}\nlong count_ones(long n) \n\
    {\n    long count;\n    long j;\n    if (n == 1) \n    {\n        return 1;\n\
    \    }\n    else \n    {\n        count = count_ones(n - 1);\n        count *=\
    \ 9;\n        count += n * starts_one_ends(n);\n        return count;\n    }\n\
    }\nlong count_digits(long n) \n{\n    long count;\n    long j;\n    if (n == 1)\
    \ \n    {\n        return 9;\n    }\n    else \n    {\n        count = count_digits(n\
    \ - 1);\n        count *= 10;\n        count -= starts_one_ends(n);\n        return\
    \ count;\n    }\n}\nlong ones(long n) \n{\n    long count;\n    long j;\n    count\
    \ = count_ones(n);\n    return count;\n}\nlong number_ends_with_one(long x) \n\
    {\n    long count;\n    long j;\n    long t;\n    auto digits = tuple(0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0);\n    for (j = 1; j <= x; j++) \n    {\n        t = j;\n\
    \        while (t > 0) \n        {\n            digits[t % 10]++;\n          \
    \  t /= 10;\n        }\n    }\n    count = 0;\n    for (j = 1; j <= x; j++) \n\
    \    {\n        if (digits[j % 10] > 0) \n        {\n            count++;\n  \
    \      }\n    }\n    return count;\n}\nlong not_ends_with_one(long x) ", "{\n\
    \    long res;\n    long h = pow(10, n-1);\n    // number of digits - 1\n    long\
    \ l = pow(10, n-2);\n    // number of digits - 2\n    res = 8 * l + h - l;\n \
    \   return res;\n}\nlong count1_digits(long n) \n{\n    long res = 0;\n    long\
    \ i = 1;\n    // start from 1-digit numbers\n    while (n >= 10) \n    {\n   \
    \     res += starts_one_ends(i);\n        // i-digit numbers\n        i += 1;\n\
    \        n /= 10;\n    }\n    // last one digit number\n    res += starts_one_ends(i);\n\
    \    return res;\n}\nlong count1(long n) \n{\n    if (n <= 0) return 0;\n    long\
    \ res = 0;\n    long p = pow(10, n);\n    long q = pow(10, n-1);\n    // number\
    \ of digits\n    // i is number to count digits\n    foreach (i; 1..n) \n    {\n\
    \        // number of i-digit numbers\n        res += 9 * count1_digits(q-1);\n\
    \        // for each i-digit number\n        res += i * q;\n        // (i-1)-digit\
    \ numbers\n        q /= 10;\n    }\n    return res;\n}", "{\n    if (n == 1) return\
    \ 2;\n    if (n == 2) return 4;\n    // f(n) = f(n-1) + f(n-2)\n    // f(1) =\
    \ 2, f(2) = 4, f(3) = 6, f(4) = 10, f(5) = 16\n    auto result = tuple(2L, 4L);\n\
    \    for (long i = 3; i <= n; ++i) \n    {\n        result = tuple(result[1],\
    \ result[0] + result[1]);\n    }\n    return result[1];\n}", "{\n    long[] dp\
    \ = new long[n + 1];\n    dp[0] = 1;\n    dp[1] = 10;\n    foreach (i; 2 .. n\
    \ + 1) {\n        dp[i] = dp[i - 1] * 9 + dp[i - 2] * 9;\n    }\n    return dp[n];\n\
    }", "{ \n  if (n == 1) return 10; \n  long result = pow(10, n-1); \n  for (long\
    \ i = 0; i < n - 1; i++) \n    result += pow(9, n - i - 1) * 9; \n  return result;\
    \ \n} \n  \nlong main() \n{ \n  long n = 4; \n  return starts_one_ends(n); \n}",
  "{\n    long dp[][] = new long[2][2];\n    dp[0][0] = 1;\n    dp[0][1] = 0;\n  \
    \  dp[1][0] = 1;\n    dp[1][1] = 1;\n    for (long i = 2; i <= n; i++) {\n   \
    \     dp[0][0] = dp[0][0] * (9 - 1) + dp[0][1] * 1;\n        dp[0][1] = dp[0][0];\n\
    \        dp[1][0] = dp[1][0] * (9 - 1) + dp[1][1] * 1;\n        dp[1][1] = dp[1][0];\n\
    \    }\n    return dp[0][0] + dp[0][1] + dp[1][0] + dp[1][1];\n}\n// Returns count\
    \ of n digit numbers ending with digit d\nlong count(long n, long d) \n{\n   \
    \ long dp[][] = new long[2][2];\n    dp[0][0] = 1;\n    dp[0][1] = 0;\n    dp[1][0]\
    \ = 1;\n    dp[1][1] = 1;\n    for (long i = 2; i <= n; i++) {\n        dp[0][0]\
    \ = dp[0][0] * (9 - 1) + dp[0][1] * 1;\n        dp[0][1] = dp[0][0];\n       \
    \ dp[1][0] = dp[1][0] * (9 - 1) + dp[1][1] * 1;\n        dp[1][1] = dp[1][0];\n\
    \    }\n    return dp[1][1];\n}\n/*\n * \n * Given a number n, find count of all\
    \ possible non negative numbers less than n \n * that can be represented as a\
    \ sum of consecutive numbers.", "{\n    if (n == 1)\n        return 10;\n    else\n\
    \    {\n        long count = 0;\n        for (long i = 0; i < n - 1; i++)\n  \
    \          count += (n - 1 - i) * pow(10, i);\n        return count * 2;\n   \
    \ }\n}", "{\n    if (n == 1)\n        return 2;\n    else\n        return starts_one_ends(n\
    \ - 1) + pow(10, n - 1);\n}", "{\n    long sum = 0;\n    if (n <= 0)\n       \
    \ return sum;\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return\
    \ 10;\n    auto half = (n + 1) / 2;\n    // half digit prefix\n    sum += pow(9,\
    \ half - 1);\n    // sum += \"1\" + \"0\"*half + \"1\"*(n-half-1)\n    sum +=\
    \ starts_one_ends(n - half - 1);\n    // sum += \"1\" + \"0\"*(n-half-1) + \"\
    1\"*half\n    sum += starts_one_ends(half - 1);\n    return sum;\n}", "{\n   \
    \ return n - 2;\n}", "{\n    long nums = 0;\n    foreach(elem; iota(1, (10^n)-1))\
    \ {\n        if (elem.text[0] == '1' || elem.text[$-1] == '1') {\n           \
    \ nums++;\n        }\n    }\n    return nums;\n}", "{\n    return long(0.5 * 10.0\
    \ ^ (n - 1));\n}", "{\n\tif (n <= 0) \n    {\n\t\treturn 0;\n\t}\n\tif (n == 1)\
    \ \n    {\n\t\treturn 1;\n\t}\n\tlong start = 1;\n\tlong end = 1;\n\tfor (long\
    \ i = 2; i <= n; i++) \n    {\n\t\tend *= 10;\n\t}\n\tlong result = start + end;\n\
    \tfor (long i = 2; i <= n; i++) \n    {\n\t\tstart *= 10;\n\t\tresult += start\
    \ + end;\n\t}\n\treturn result;\n}", "{\n    if (n == 1)\n        return 2;\n\
    \    long result = 0;\n    // i == 1\n    result += starts_one_ends(n - 1);\n\
    \    // i != 1\n    result += (n - 1) * pow(9, n - 1);\n    return result;\n}",
  "{\n    if (n < 1) \n        return 0;\n    if (n == 1) \n        return 10;\n \
    \   if (n == 2) \n        return 19;\n    const uint64_t pow9_9 = 387420489;\n\
    \    const uint64_t pow9_8 = 43046721;\n    const uint64_t pow9_7 = 4782969;\n\
    \    if (n == 3) \n        return 28;\n    if (n == 4) \n        return 37;\n\
    \    if (n == 5) \n        return 46;\n    if (n == 6) \n        return 55;\n\
    \    if (n == 7) \n        return 64;\n    if (n == 8) \n        return 73;\n\
    \    if (n == 9) \n        return 82;\n    if (n == 10) \n        return 91;\n\
    \    if (n == 11) \n        return 100;\n    if (n == 12) \n        return 109;\n\
    \    if (n == 13) \n        return 118;\n    if (n == 14) \n        return 127;\n\
    \    if (n == 15) \n        return 136;\n    if (n == 16) \n        return 145;\n\
    \    if (n == 17) \n        return 154;\n    if (n == 18) \n        return 163;\n\
    \    if (n == 19) \n        return 172;\n    if (n == 20) \n        return 181;\n\
    \    if (n == 21) \n        return 190;\n    if (n == 22) \n        return 199;\n\
    \    if (n == 23) \n        return 208;\n    if (n == 24) \n        return 217;\n\
    \    if (n == 25) \n        return 226;\n    if (n == 26) \n        return 235;\n\
    \    if (n == 27) \n        return 244;\n    if (n == 28) \n        return 253;\n\
    \    if (n == 29) \n        return 262;\n    if (n == 30) \n        return 271;\n\
    \    if (n == 31) \n        return 280;\n    if (n == 32) \n       ", "{\n   \
    \ long f_end = pow(10, n-1);\n    long f_beg = pow(10, n) - 1;\n    long s_end\
    \ = pow(10, n-1);\n    long s_beg = 10;\n    if (n == 1)\n        return 9;\n\
    \    return (f_end - f_beg) + (s_end - s_beg);\n}", "{\n    long[][] mem = new\
    \ long[n+1][2];\n    mem[1][0] = 0;\n    mem[1][1] = 1;\n    for (long i = 2;\
    \ i <= n; i++) {\n        mem[i][0] = mem[i-1][0] + mem[i-1][1];\n        mem[i][1]\
    \ = mem[i-1][0];\n    }\n    return mem[n][0] + mem[n][1];\n}\nstatic assert(starts_one_ends(3)\
    \ == 13);", "{\n    return(n == 1 ? 2 : (10 * starts_one_ends(n - 1) - 9));\n}",
  "{\n    enum long limit = 1L;\n    while (n--)\n        limit *= 10;\n    long ret\
    \ = 0;\n    for (long i = 1; i < limit; i++)\n    {\n        // this is a bit\
    \ silly...\n        char[] chars = to!(char[])(i);\n        if (chars[0] == '1'\
    \ || chars[$-1] == '1')\n            ret++;\n    }\n    return ret;\n}", "{ \n\
    \    if (n == 1)\n        return 1;\n    else if (n == 2)\n        return 9;\n\
    \    else\n        return 9 + pow(10, n - 1);\n}", "{\n    if (n == 1)\n     \
    \   return 1;\n    else \n    {\n        auto digits = pow(10, n-1);\n       \
    \ return digits + 9 * digits / 10;\n    }\n}\n/*", "{\n    return (2 * (9 * pow(10,\
    \ n - 1)) - pow(10, n) + 1);\n}", "{\n    return pow(10, n - 1);\n}", "{\n   \
    \ auto total = 0;\n    auto end_zero = 1;\n    for (auto i = 1; i < n; i++) {\n\
    \        total += end_zero * 10;\n        end_zero *= 10;\n    }\n    total +=\
    \ 1;\n    return total;\n}\nstatic assert(starts_one_ends(1) == 1);\nstatic assert(starts_one_ends(2)\
    \ == 19);\nstatic assert(starts_one_ends(3) == 271);\nstatic assert(starts_one_ends(4)\
    \ == 4331);\nstatic assert(starts_one_ends(5) == 65921);\nstatic assert(starts_one_ends(6)\
    \ == 1018091);\nstatic assert(starts_one_ends(7) == 15727251);\nstatic assert(starts_one_ends(8)\
    \ == 236611171);\nstatic assert(starts_one_ends(9) == 3565927341);\nstatic assert(starts_one_ends(10)\
    \ == 53698550531);\nstatic assert(starts_one_ends(11) == 820366015511);\nstatic\
    \ assert(starts_one_ends(12) == 12537053455091);\nstatic assert(starts_one_ends(13)\
    \ == 192845492385271);\nstatic assert(starts_one_ends(14) == 2936887437476331);\n\
    static assert(starts_one_ends(15) == 44878678657065921);"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
