name: HumanEval_83_starts_one_ends
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
  \ n, return the count of the numbers of n-digit\n    positive integers that start\
  \ or end with 1.\n    \n*/\nlong starts_one_ends(long n) \n"
tests: "unittest\n{\n    alias candidate = starts_one_ends;\n\n    assert(candidate(1L)\
  \ == 1L);\n    assert(candidate(2L) == 18L);\n    assert(candidate(3L) == 180L);\n\
  \    assert(candidate(4L) == 1800L);\n    assert(candidate(5L) == 18000L);\n}\n\
  void main(){}"
completions: ["{\n    return ((n-1)*9) + (int)pow(10, (n-1));\n}", "{ \n    if (n==1)\
    \ return 1;\n    long ans = 1;\n    for (size_t i=1; i<n-1; i++) \n        ans\
    \ *= 9;\n    return ans * 2;\n}", "{\n    if (n == 1) return 2;\n    if (n ==\
    \ 2) return 3;\n    auto a = starts_one_ends(n - 1);\n    auto b = starts_one_ends(n\
    \ - 2);\n    return a + 2 * b;\n}\nlong starts_one_ends_dp(long n) \n{\n    long[long]\
    \ memo;\n    memo[1] = 2;\n    memo[2] = 3;\n    for (long i = 3; i <= n; i++)\
    \ \n    {\n        memo[i] = memo[i - 1] + 2 * memo[i - 2];\n    }\n    return\
    \ memo[n];\n}", "{\n    long res = 0;\n    if (n <= 1)\n        return n;\n  \
    \  n--;\n    res += pow(10, n);\n    res += starts_one_ends(n);\n    return res;\n\
    }\nlong starts_one_ends_2(long n) \n{\n    long res = 0;\n    if (n <= 1)\n  \
    \      return n;\n    n--;\n    res += pow(10, n);\n    res += starts_one_ends_2(n);\n\
    \    return res;\n}", "{\n    if (n < 1)\n        return 0;\n    long ret = 0;\n\
    \    long ones = 1;\n    long ten_power = 10;\n    long p = (long) pow(10.0, n\
    \ - 1);\n    for (long n_digits = 1; n_digits <= n; ++n_digits) {\n        ret\
    \ += ones;\n        ones = 9 * ones + p;\n        p /= 10;\n    }\n    return\
    \ ret;\n}\nstatic assert(starts_one_ends(1) == 2);\nstatic assert(starts_one_ends(2)\
    \ == 2);\nstatic assert(starts_one_ends(3) == 3);\nstatic assert(starts_one_ends(4)\
    \ == 4);\nstatic assert(starts_one_ends(5) == 5);\nstatic assert(starts_one_ends(6)\
    \ == 6);\nstatic assert(starts_one_ends(7) == 7);\nstatic assert(starts_one_ends(8)\
    \ == 8);\nstatic assert(starts_one_ends(9) == 9);\nstatic assert(starts_one_ends(10)\
    \ == 10);\nstatic assert(starts_one_ends(11) == 11);\nstatic assert(starts_one_ends(12)\
    \ == 12);\nstatic assert(starts_one_ends(13) == 13);\nstatic assert(starts_one_ends(14)\
    \ == 14);\nstatic assert(starts_one_ends(15) == 15);\nstatic assert(starts_one_ends(16)\
    \ == 16);\nstatic assert(starts_one_ends(17) == 17);\nstatic assert(starts_one_ends(18)\
    \ == 18);\nstatic assert(starts_one_ends(19) == 19);\nstatic assert(starts_one_ends(20)\
    \ == 20);\nstatic assert(starts_one_ends(21) == 21);\nstatic assert(starts_one_ends(22)\
    \ == 22);\nstatic assert(starts_one_ends(23) == 23);\nstatic assert(starts_one_ends(24)\
    \ == 24);\nstatic assert(starts_one_ends(25)", "{\n    if (n <= 1) \n        return\
    \ 0;\n    assert(n > 1);\n    // Treating the number as base-10, each digit has\
    \ 10 choices (0-9).\n    // But each digit can only be 1 if that digit is the\
    \ first digit.\n    // So the way I see it, we have 10 choices for the first digit,\
    \ and\n    // 10 choices for the last digit.\n    // But then the remaining digits\
    \ can be anything from 1-9, so we have\n    // 9 choices for each of those.\n\
    \    long choices = 10 * 10 * pow(9, n - 2);\n    return choices;\n}\nlong count_1(long\
    \ n)\n{\n    long sum = 0;\n    for (long i = 1; i <= n; ++i) \n        sum +=\
    \ starts_one_ends(i);\n    return sum;\n}", "{\n    long n_bits = n * (n + 1)\
    \ / 2;\n    if (n == 1) return 2;\n    long count = 0;\n    foreach (i; 1 .. n)\n\
    \    {\n        count += (1 << (n_bits - i * (i + 1) / 2));\n    }\n    return\
    \ count;\n}", "{\n    return n * (n - 1) * pow(9, n - 2);\n}", "{\n    if (n ==\
    \ 1)\n        return 1;\n    long c = 0;\n    if (n % 2 == 0)\n        c += starts_one_ends(n\
    \ - 1);\n    if (n % 2 == 1)\n        c += starts_one_ends(n - 1) * 9;\n    return\
    \ c;\n}", "{\n    long result = 0;\n    if (n == 1) {\n        result = 1;\n \
    \   } else if (n == 2) {\n        result = 11;\n    } else {\n        result =\
    \ 9;\n        for (long i = 1; i < n - 1; i++) {\n            result *= 9;\n \
    \       }\n        result += starts_one_ends(n - 1);\n    }\n    return result;\n\
    }", "{\n  /*\n      https://oeis.org/A088286\n      A088286 \t   Number of n-digit\
    \ numbers starting and ending with 1. \n                   9 n^2 + n, n >= 1.\
    \ \n  */\n  if (n == 1) return 9;\n  return (n*n + n) * 9;\n}\nlong starts_one_ends_runtime(long\
    \ n) \n{\n  long ans = 0;\n  for (long i = 1; i < 10; i++) {\n    for (long j\
    \ = 1; j < 10; j++) {\n      long s = to!string(i^pow(10, n-1));\n      long e\
    \ = to!string(j^pow(10, n-1));\n      long m = to!string(i^e);\n      auto a =\
    \ to!(string[])(m.to!string());\n      bool valid = true;\n      for (long k =\
    \ 0; k < a.length; k++) {\n        if (a[k] != \"1\") {\n          valid = false;\n\
    \          break;\n        }\n      }\n      if (valid) {\n        ans++;\n  \
    \    }\n    }\n  }\n  return ans;\n}", "{\n    long[long] fib_one = [0:0, 1:1];",
  "{ \n    long digit, result = 0; \n  \n    for (digit = 1; digit <= n; digit++)\
    \ \n        result += (long)pow(10, digit - 1); \n    return result; \n} ", "{\
    \ \n    if (n <= 0) \n        return 0; \n  \n    // Calculate 10^(n-1)\n    long\
    \ t = (long)pow(10, n - 1); \n  \n    // There are 9 numbers less than 10^(n-1)\n\
    \    // that have 1 as starting or ending digit.\n    long result = 9; \n  \n\
    \    for (long i = 2; i <= n; i++) \n    { \n        // For each n, the number\
    \ of starting or ending \n        // digit with 1 will be 9*9^(n-1).\n       \
    \ result = 9 * result + t; \n        t *= 10; \n    } \n  \n    return result;\
    \ \n} \n/*\n    To understand the above code, consider the examples.\n    \n \
    \   The number of 1 digit numbers that start or end with 1 = 9\n    The number\
    \ of 2 digit numbers that start or end with 1 = 9*9 + 10 = 99\n    The number\
    \ of 3 digit numbers that start or end with 1 = 9*99 + 100 = 999\n    and so on.\n\
    */", "{\n    long res = 0;\n    for (long i = 1; i <= n; i++) \n    {\n      \
    \  res += (long)pow(10,i - 1);\n    }\n    return res;\n}", "{\n    enum: long\
    \ long = 1e9+7;\n    if (n <= 1) return 0;\n    long result = 0;\n    for (long\
    \ i = 1; i < n; i++) \n    {\n        result += powerOf10(i - 1) + powerOf10(n\
    \ - i - 1);\n        result %= mod;\n    }\n    return result;\n}", "{\n    return\
    \ (long)((n - 1) * pow(9, n - 1) + pow(10, n - 1));\n}", "{\n    long retval;\n\
    \    long n_min_1;\n    long n_min_2;\n    long n_min_3;\n    // If n < 1, return\
    \ 0\n    if (n < 1)\n    {\n        retval = 0;\n    }\n    // If n == 1, return\
    \ 10\n    else if (n == 1)\n    {\n        retval = 10;\n    }\n    // If n ==\
    \ 2, return 55\n    else if (n == 2)\n    {\n        retval = 55;\n    }\n   \
    \ // If n == 3, return 220\n    else if (n == 3)\n    {\n        retval = 220;\n\
    \    }\n    // If n == 4, return 715\n    else if (n == 4)\n    {\n        retval\
    \ = 715;\n    }\n    // Else return starts_one_ends(n-1) + starts_one_ends(n-2)\
    \ + starts_one_ends(n-3)\n    else\n    {\n        n_min_1 = starts_one_ends(n-1);\n\
    \        n_min_2 = starts_one_ends(n-2);\n        n_min_3 = starts_one_ends(n-3);\n\
    \        retval = n_min_1 + n_min_2 + n_min_3;\n    }\n    return retval;\n}",
  "{\n    return (n*(10^(n-1)) - (10^(n-1) - 1));\n}", "{\n    if (n == 1) return\
    \ 1;\n    long res = 0;\n    for (long i = 1; i <= n; i++)\n    {\n        auto\
    \ tmp = pow(10, i - 1);\n        res += (tmp - tmp / 10) * 2;\n    }\n    return\
    \ res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
