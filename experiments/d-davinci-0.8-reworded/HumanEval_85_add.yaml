name: HumanEval_85_add
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nGiven a non-empty array of integers\
  \ lst. add the even elements that are at odd indices..\n\n\n    Examples:\n    >>>\
  \ add([4L, 2L, 6L, 7L])\n    2L\n    \n*/\nlong add(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = add;\n\n    assert(candidate([4L, 88L])\
  \ == 88L);\n    assert(candidate([4L, 5L, 6L, 7L, 2L, 122L]) == 122L);\n    assert(candidate([4L,\
  \ 0L, 6L, 7L]) == 0L);\n    assert(candidate([4L, 4L, 6L, 8L]) == 12L);\n}\nvoid\
  \ main(){}"
completions: ["{\n    long sum = 0;\n    foreach(i,e; lst)\n    {\n        if(i %\
    \ 2 == 1 && e % 2 == 0)\n        {\n            sum += e;\n        }\n    }\n\
    \    return sum;\n}", "{\n    int a = 0;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (i % 2 == 1 && lst[i] % 2 == 0)\n        {\n       \
    \     a += lst[i];\n        }\n    }\n    return a;\n}", "{\n    long x=0;\n \
    \   foreach(a;0..lst.length)\n    {\n        if(a%2==1)\n        {\n         \
    \   if(lst[a]%2==0)\n            {\n                x+=lst[a];\n            }\n\
    \        }\n    }\n    return x;\n}", '{', "{\n  long result = 0L;\n  foreach(immutable\
    \ i, immutable l; lst) \n  {\n    static if (i % 2 == 1) \n    {\n      static\
    \ if (l % 2 == 0) \n      {\n        result += l;\n      }\n    }\n  }\n  return\
    \ result;\n}", "{\n    /*\n    long r = 0;\n    for (auto i = 0; i < lst.length;\
    \ i += 2)\n        r += lst[i];\n    return r;\n    */\n    // isEven() is an\
    \ expression\n    return lst.filter!(i => i % 2 == 0).sum;\n}", "{\n    auto f\
    \ = (long x) => x % 2 == 0 ? x : 0;\n    return map!f(lst).sum;\n}", "{\n    return\
    \ 0;\n}", "{\n    long tot;\n    int i,n;\n    foreach(i,n;lst)\n    {\n     \
    \   if(n%2==0)\n        {\n            tot+=n;\n        }\n    }\n    return tot;\n\
    }\n    ", "{\n    // return sum(i % 2 == 1 ? lst[i] : 0L for i in 0..lst.length);\n\
    \    long sum = 0L;\n    foreach( idx, num; lst )\n    {\n        if( idx % 2\
    \ == 1 )\n        {\n            sum += num;\n        }\n    }\n    return sum;\n\
    }\n/*\nGiven a non-empty array of integers lst. add the even elements that are\
    \ at odd indices..", "{\n    long result = 0L;\n    foreach(n; lst)\n    {\n \
    \     enum even = n % 2 == 0;\n      enum odd = n % 2 != 0;\n      if(even) \n\
    \      {\n        result += n;\n      }\n    }\n    return result;\n}", "{\n \
    \   alias IndicesAndValues = Tuple!(size_t, \"index\", long, \"value\");\n   \
    \ return lst.enumerate\n        .filter!(a => a.index & 1 == 1 && a.value & 1\
    \ == 0)\n        .map!(a => a.value)\n        .sum;\n}", "{\n    int result =\
    \ 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if (i % 2 == 1\
    \ && lst[i] % 2 == 0)\n        {\n            result += lst[i];\n        }\n \
    \   }\n    return result;\n}", "{\n    long res=0;\n    int len = lst.length;\n\
    \    for(int i=0;i<len;i++){\n        if(i%2==1){\n            res+=lst[i];\n\
    \        }\n    }\n    return res;\n}", "{\n    return lst.filter!(x => isEven(x))\n\
    \              .filter!(x => lst.indexOf(x) % 2 == 1)\n              .sum;\n}",
  "{\n  long sum = 0;\n  foreach(lst, (val, index) => \n  {\n    if (index % 2 !=\
    \ 0 && val % 2 == 0)\n      sum += val;\n  });\n  return sum;\n}\n/*\nModule contains\
    \ a function that calculates the sum of all even numbers in an array.", "{\n \
    \   import std.algorithm;\n    return lst\n    .filter!(a => a%2 == 0)\n    .filter!((a,i)\
    \ => i%2==1)\n    .sum;\n}", "{\n    return lst.zip(0L..lst.length)\n        .filter!(t\
    \ => (t[1] % 2L) == 0L)\n        .map!(t => t[0])\n        .sum;\n}\n/*\nReturn\
    \ the number of consecutive integers with the same value as in a given array lst.",
  "{\n    long ans = 0L;\n    foreach(i,v; lst)\n    {\n        if(i % 2 == 1 && v\
    \ % 2 == 0)\n        {\n            ans += v;\n        }\n    }\n    return ans;\n\
    }", "{\n    long sum = 0;\n    foreach(i, e; lst) \n    {\n        if(i % 2 ==\
    \ 1 && e % 2 == 0)\n            sum += e;\n    }\n    return sum;\n}\n/*\nGiven\
    \ a tree, return the level in the tree that has the greatest sum.", "{\n    long[]\
    \ temp = new long[(long) ceil(lst.length / 2.0)];\n    int count = 0;\n    foreach(i,\
    \ val; lst)\n    {\n        if(i % 2 == 1 && val % 2 == 0)\n        {\n      \
    \      temp[count] = val;\n            count++;\n        }\n    }\n    return\
    \ reduce!\"a + b\"(temp);\n}", "{\n    auto f = (a,b) => a+b;\n    long[] even\
    \ = lst.filter!((a) => a % 2 == 0);\n    return even.enumerate.filter!((a) =>\
    \ a.index % 2 == 1).map!(a => a.value).reduce!f(0L);\n}", "{\n    // change code\
    \ here\n    long sum = 0;\n    auto i = lst.size;\n    for(size_t m = 0; m < i;\
    \ m++)\n    {\n      if(m % 2 == 1 && lst[m] % 2 == 0)\n      {\n        sum +=\
    \ lst[m];\n      }\n    }\n    return sum;\n}", "{\n    long res = 0L;\n    for\
    \ (int i = 0; i < lst.length; i += 2)\n    {\n        long item = lst[i];\n  \
    \      if ((item % 2L) == 0L)\n        {\n            res += item;\n        }\n\
    \    }\n    return res;\n}\n/*\nA palindrome is a word, phrase, number, or other\
    \ sequence of characters which reads the same backward or forward. Allowances\
    \ may be made for adjustments to capital letters, punctuation, and word dividers.",
  "{\n    long result = 0L;\n    long index = 0L;\n    foreach (value; lst) \n   \
    \ {\n        if (index % 2L == 1L && isEven(value)) \n        {\n            result\
    \ += value;\n        }\n        index++;\n    }\n    return result;\n}\n/*\nDefine\
    \ the function isEven that takes an integer x as a parameter and returns true\
    \ if x is even and false otherwise.\n*/", "{\n    long sum = 0;\n    foreach(immutable\
    \ idx, immutable val; lst)\n    {\n        if (idx % 2 == 1 && val % 2 == 0)\n\
    \        {\n            sum += val;\n        }\n    }\n    return sum;\n}", "{\n\
    \    long sum = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if(i\
    \ % 2 == 1 && lst[i] % 2 == 0)\n        {\n            sum += lst[i];\n      \
    \  }\n    }\n    return sum;\n}\n/*\nGiven a list of integers lst and a single\
    \ integer n, return the nth largest integer in lst.\n(If lst has the same largest\
    \ number more than once, return the largest integer in lst.)", "{\n    int a =\
    \ 0;\n    for (int i = 0; i < lst.length; i += 2)\n    {\n        a += lst[i];\n\
    \    }\n    return a;\n}\n/*\nYou are given an array of integers, where each element\
    \ represents the maximum number of steps that can be jumped going forward from\
    \ that element. Write a function to return the minimum number of jumps you must\
    \ take in order to get from the start to the end of the array.", "{\nlong res\
    \ = 0L;\n//int i = 0;\n//int len = lst.length;\n//while(i < len) {\n    //if((lst[i]\
    \ % 2L) == 0L && (i % 2) == 1) {\n        //res += lst[i];\n    //}\n    //i++;\n\
    //}\n//return res;\nauto odds = filter!(a => (a % 2L) == 0L)(lst);\nauto evens\
    \ = filter!(a => (a % 2L) == 1L)(lst);\nreturn odds.sum() + evens.sum();\n}",
  "{\n  long res = 0L;\n  long j = 0L;\n  foreach (long i, long el; lst) \n  {\n \
    \   if (j % 2L == 0L && el % 2L == 0L) \n    {\n      res += el;\n    }\n    j++;\n\
    \  }\n  return res;\n}\n/*\nGiven an array of integers, return the array with\
    \ all duplicate elements removed.", "{\n    int i = 0;\n    long sum = 0;\n  \
    \  foreach(ele; lst)\n    {\n        if(i%2 != 0 && ele%2 == 0)\n        {\n \
    \           sum += ele;\n        }\n        i++;\n    }\n    return sum;\n}",
  "{\n    return lst.filter!(a => a % 2 == 0).filter!(a => lst.indexOf(a) % 2 == 1).sum;\n\
    }", "{\n    long sum = 0;\n    foreach(index, element; lst) \n    {\n        if(index\
    \ % 2 != 0 && element % 2 == 0)\n        {\n            sum += element;\n    \
    \    }\n    }\n    return sum;\n}", "{\n    long sum=0;\n    int i=0;\n    while(i<lst.length)\n\
    \    {\n        if((i%2!=0)&&(lst[i]%2==0))\n            sum+=lst[i];\n      \
    \  i++;\n    }\n    return sum;\n}\n/*\nGiven a tuple of integers tpl, return\
    \ the tuple of integers where each element is multiplied by 2, as long as the\
    \ elements are less than 100. Otherwise, keep the element as it is.", "{\n   \
    \ long sum = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i]\
    \ % 2 == 0 && i % 2 != 0)\n        {\n            sum += lst[i];\n        }\n\
    \    }\n    return sum;\n}\n/*\nGiven the array numbers in the form:", "{\n  \
    \  long result = 0L;\n    int  i = 0;\n    foreach(elem; lst)\n    {\n       \
    \ if (i % 2 == 1 && elem % 2 == 0)\n        {\n            result += elem;\n \
    \       }\n        i++;\n    }\n    return result;\n}\n/*\nGiven an array of integers,\
    \ find the pair of adjacent elements that has the largest product and return that\
    \ product.", "{\n  int i = 0;\n  long sum = 0;\n  while (i < lst.length)\n  {\n\
    \    if (i % 2 == 1)\n    {\n      sum += lst[i];\n    }\n    i++;\n  }\n  return\
    \ sum;\n}\n/*\nGiven a non-empty array of integers lst. add the even elements\
    \ that are at odd indices..", "{\n    return reduce!((a, b) => a + b)(filter!(a\
    \ => (a % 2 == 0))(enumerate(lst))).sum;\n}\n// This is a clunky way to get the\
    \ sum of an array of 2 element tuples.\n// It is not the fastest way.\nTuple!(long,\
    \ long) sum(Tuple!(long, long)[] array)\n{\n    auto result = tuple(0L, 0L);\n\
    \    foreach(item; array)\n    {\n        result[0] += item[0];\n        result[1]\
    \ += item[1];\n    }\n    return result;\n}\nlong add_fast(long[] lst) \n{\n \
    \   return sum(map!(a => tuple(a[1], 0L))(filter!(a => (a[1] % 2 == 0))(enumerate(lst)))).sum;\n\
    }", "{\n   long res = 0L;\n   size_t len = lst.length;\n   for (size_t i = 0;\
    \ i < len; i++)\n    {\n       if (i % 2 == 1)\n        {\n           if (lst[i]\
    \ % 2 == 0)\n            {\n               res += lst[i];\n            }\n   \
    \     }\n    }\n   return res;\n}\n/*", "{\n    return lst.filter!(a => a % 2\
    \ == 0 && lst.indexOf(a) % 2 != 0).sum;\n}", "{\n    return reduce!((a,b) => a\
    \ + b)(lst).filter!(x => x % 2 == 0 && lst.indexOf(x) % 2 != 0).sum;\n}", "{\n\
    \    return zip(lst,iota(0L,lst.length)).filter!(a => a[1] % 2L == 1L).map!(a\
    \ => a[0]).filter!(a => a % 2L == 0L).reduce!q{a,b => a + b}();\n}", "{\n    int\
    \ len = lst.length;\n    long sum = 0;\n    for (int i = 0; i < len; i++)\n  \
    \  {\n        if (i % 2 == 1 && lst[i] % 2 == 0)\n        {\n            sum +=\
    \ lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(immutable\
    \ i, immutable e; lst)\n    {\n        if(i%2 != 0 && e%2 == 0)\n        {\n \
    \           sum += e;\n        }\n    }\n    return sum;\n}", "{\n    /*", "{\n\
    \  long sum = 0;\n  foreach(immutable i, long e; lst)\n  {\n    if (i % 2 == 1\
    \ && e % 2 == 0)\n      sum += e;\n  }\n  return sum;\n}", "{\n    long res =\
    \ 0L;\n    foreach(c, i; lst)\n    {\n        if(c%2==0 && i%2==1)\n        {\n\
    \            res += c;\n        }\n    }\n    return res;\n}", "{\n    long Sum;\n\
    \    Sum = 0;\n    long i;\n    i = 0;\n    while (i < lst.length)\n    {\n  \
    \      if (lst[i] % 2 == 0 && i % 2 != 0)\n        {\n            Sum = Sum +\
    \ lst[i];\n        }\n        i = i + 1;\n    }\n    return Sum;\n}\n/*", "{\n\
    \  long sum=0;\n  foreach(i, e; lst)\n  {\n    if(i%2==1 && e%2==0)\n    {\n \
    \     sum+=e;\n    }\n  }\n  return sum;\n}", "{\n    long res = 0L;\n    for\
    \ (int i = 0; i < lst.length; i += 2)\n    {\n        if (lst[i] % 2 == 0)\n \
    \       {\n            res += lst[i];\n        }\n    }\n    return res;\n}\n\
    long add2(long[] lst) \n{\n    long res = 0L;\n    foreach (var el; lst)\n   \
    \ {\n        if (el % 2 == 0)\n        {\n            res += el;\n        }\n\
    \    }\n    return res;\n}\nlong add3(long[] lst) \n{\n    long res = 0L;\n  \
    \  foreach (var el; lst)\n    {\n        if (el % 2 == 0)\n        {\n       \
    \     res += el;\n        }\n    }\n    return res;\n}\n// -----\nauto add4(long[]\
    \ lst)\n{\n    long res = 0L;\n    foreach (var el; lst)\n    {\n        if (el\
    \ % 2 == 0)\n        {\n            res += el;\n        }\n    }\n    return res;\n\
    }\n// -----\n// -----\n// -----\n// -----\n// -----\n// -----\n// -----\n// -----\n\
    // -----\n// -----\n// -----\n// -----\n// -----\n// -----\n// -----\n// -----\n\
    // -----\n// -----\n// -----", "{\n    bool b=true;\n    auto sum = 0L;\n    auto\
    \ i = 0L;\n    while(i < lst.length)\n    {\n        sum+=b ? lst[i] : 0L;\n \
    \       b = !b;\n        i++;\n    }\n    return sum;\n}\n/*\nReturn the sum of\
    \ numbers in lst.\n    \n    Examples:\n    >>> sum([1, 2, 3, 4])\n    10\n  \
    \  \n*/\nlong sum(long[] lst) \n{\n    auto x = 0L;\n    foreach(long y; lst)\n\
    \    {\n        x+=y;\n    }\n    return x;\n}\n/*\nGiven a list of integer lst.\
    \ do the following.\n- move the positive elements to the end.\n- move the negative\
    \ elements to the front.\n- keep the order of the elements unchanged.", "{\n \
    \   long res = 0L;\n    return lst.filter!(i => i % 2 == 0 && lst.indexOf(i) %\
    \ 2 != 0).reduce!((l, r) => l + r)(0L);\n}\n// Example Test Run\nunittest\n{\n\
    \    auto res = add([4L, 2L, 6L, 7L]);\n    assert(res == 2L);\n}\n \n \n /*\n\
    \        Task", "{\n    long sum = 0;\n    foreach(idx, element; lst)\n    {\n\
    \        if (idx % 2 != 0 && element % 2 == 0)\n        {\n            sum +=\
    \ element;\n        }\n    }\n    return sum;\n}", "{\n    long oddSum = 0;\n\
    \    foreach(int i, long l; lst)\n    {\n        if (i % 2 == 1 && l % 2 == 0)\
    \ \n        {\n            oddSum += l;\n        }\n    }\n    return oddSum;\n\
    }\n/*\nWrite a function to check if a given string is a palindrome.", "{\n   \
    \ auto tup = std.typecons.tuple(lst.length);\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        tup[i] = lst[i];\n    }\n    long sum = 0;\n    int j =\
    \ 0;\n    for (int i = 0; i < tup.length; i++)\n    {\n        if (i % 2 == 0)\n\
    \        {\n            sum += tup[i];\n        }\n    }\n    return sum;\n}",
  "{\n    long result = 0L;\n    foreach(index, element; lst) \n    {\n        if(index\
    \ % 2 == 1 && element % 2 == 0) \n        {\n            result += element;\n\
    \        }\n    }\n    return result;\n}", "{\n    long res = 0L;\n    foreach(i,\
    \ e; lst) if (i % 2 == 1 && e % 2 == 0) res += e;\n    return res;\n}", "{\n \
    \ long sum = 0;\n  for (int i = 0; i < lst.length; i+=2)\n    sum += lst[i];\n\
    \  return sum;\n}", "{\n  long res = 0L;\n  foreach(i, e; lst) \n  {\n    if (i\
    \ % 2)\n      res += e;\n  }\n  return res;\n}\n/*\nGiven a non-empty array of\
    \ integers lst. add the even elements that are at odd indices..", "{\n    long[]\
    \ lst1 = lst.retro;\n    long res = 0;\n    for (int i = 0; i < lst1.length; i\
    \ += 2)\n    {\n        res += lst1[i];\n    }\n    return res;\n}", "{\n    long\
    \ sum = 0;\n    size_t n = lst.length;\n    for (size_t i = 0; i < n; i++) \n\
    \    {\n        if (i % 2 != 0 && lst[i] % 2 == 0) \n        {\n            sum\
    \ += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    return lst.sum &\
    \ 0x1;\n}", "{\n    long sum=0;\n    for(int i=0;i<lst.length;i+=2)\n        if(lst[i]%2==0)\n\
    \        sum+=lst[i];\n    return sum;\n}", "{\n    return lst[(int)iota(lst.length).filter!(x\
    \ => x & 1 == 1).filter!(x => lst[x] & 1 == 0).reduce!q{a, b => a + b}];\n}",
  "    => lst.\n        enumerate().\n        filter!(i => i.index % 2 && i.value\
    \ % 2 == 0).\n        map!(i => i.value).\n        reduce!((a, b) => a + b)(0L);\n\
    /*\nGiven a tree a, b and c. Find the shortest way to get from a to c.", "{\n\
    \    long sum = 0;\n    foreach(i, element; lst) \n    {\n        if((i & 1L)\
    \ && element & 1L == 0L)\n        {\n            sum += element;\n        }\n\
    \    }\n    return sum;\n}", "{\n    long result = 0L;\n    return result;\n}\n\
    \"#;", "{\n    int count = 0;\n    long sum = 0;\n    foreach(item; lst)\n   \
    \ {\n        if(count%2==0)\n        {\n            sum += item;\n        }\n\
    \        count++;\n    }\n    return sum;\n}", "{\n    long result = 0L;\n   \
    \ foreach(index, value; lst) \n    {\n        if(index % 2 == 1 && value % 2 ==\
    \ 0) \n        {\n            result += value;\n        }\n    }\n    return result;\n\
    }", "{\n    long sum = 0;\n    foreach(index,element; lst)\n    {\n        if(index\
    \ % 2 == 1 && element % 2 == 0)\n        {\n            sum += element;\n    \
    \    }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(i, e; lst)\n\
    \    {\n        if(i % 2 == 1 && e % 2 == 0)\n        {\n            sum += e;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long total = 0;\n    bool odd\
    \ = true;\n    foreach(i;lst)\n    {\n        if (odd)\n        {\n          \
    \  if (i%2 == 0)\n            {\n                total += i;\n            }\n\
    \        }\n        odd = !odd;\n    }\n    return total;\n}", "{\n    if (lst.length\
    \ == 0L)\n    {\n        return 0L;\n    }\n    return map!\"a % 2 == 0 ? a :\
    \ 0\"(iota(lst.length)).sum() + (lst.sum - map!\"a % 2 == 0 ? a : 0\"(lst).sum);\n\
    }", "{\n    return lst[1..$]\n        .filter!(x => x % 2 == 0)\n        .sum;\n\
    }", "{\n  long sum = 0;\n  foreach(i, j; lst) \n  {\n      if (j & 1 == 1)\n \
    \     {\n          continue;\n      }\n      sum += i;\n  }\n  return sum;\n}",
  "{\n  return lst.retro.indices.zip(lst.retro).filter!(a => a[0] & 1 && a[1] & 1).map!(a\
    \ => a[1]).sum;\n}\n/*\n    Examples:\n    >>> add1([4L, 2L, 6L, 7L])\n    2L\n\
    \    \n*/\nlong add1(long[] lst) \n{\n  return lst.retro.indices.zip(lst.retro).filter!(a\
    \ => a[0] & 1 && a[1] & 1).map!(a => a[1]).sum;\n}\n/*\nGiven a list of lowercase\
    \ words and a string S, add spaces in s to construct a sentence where each word\
    \ is a valid dictionary word. Return all such possible sentences.", "{\n    long\
    \ sum = 0;\n    for (size_t i = 0; i < lst.length; i += 2) \n    {\n        sum\
    \ += lst[i];\n    }\n    return sum;\n}\nlong add([long] lst) \n{\n    long sum\
    \ = 0;\n    for (size_t i = 0; i < lst.length; i += 2) \n    {\n        sum +=\
    \ lst[i];\n    }\n    return sum;\n}\nlong add(in long[] lst) \n{\n    long sum\
    \ = 0;\n    for (size_t i = 0; i < lst.length; i += 2) \n    {\n        sum +=\
    \ lst[i];\n    }\n    return sum;\n}\nlong add(ref long[] lst) \n{\n    long sum\
    \ = 0;\n    for (size_t i = 0; i < lst.length; i += 2) \n    {\n        sum +=\
    \ lst[i];\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    for (int i =\
    \ 0; i < lst.length; i++)\n    {\n        if (i % 2 == 1 && lst[i] % 2 == 0)\n\
    \        {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\
    \"\n# Use std.math, std.typecons\n# Given a non-empty array of integers lst. add\
    \ the even elements that are at odd indices.\n# Examples:\n# add([4L, 2L, 6L,\
    \ 7L]) == 2L", "{\n   long value = 0;\n   foreach(i, element; lst)\n   {\n   \
    \     if(i%2 != 0 && element%2 == 0)\n        {\n            value += element;\n\
    \        }\n   }\n   return value;\n}", "{\n    long oddSum = 0;\n    foreach(i,\
    \ elem; lst)\n    {\n        if (i % 2 == 1 && (elem % 2 == 0))\n        {\n \
    \           oddSum += elem;\n        }\n    }\n    return oddSum;\n}", "{\nlong\
    \ c=0;", "{\n    long sum = 0;\n    foreach(i, e; lst)\n    {\n        if (i %\
    \ 2 == 1 && e % 2 == 0)\n        {\n            sum += e;\n        }\n    }\n\
    \    return sum;\n}", "{\n    long x=0;\n    foreach(int i, inout long e; lst)\n\
    \    {\n        if (i % 2 == 1 && e % 2 == 0)\n        {\n            x+=e;\n\
    \        }\n    }\n    return x;\n}\n/*\nGiven a non-empty array of integers lst.\
    \ remove the odd elements that are at even indices..", "{\n    long result = 0L;\n\
    \    for (int i = 0; i < lst.length; i++) {\n        if (i % 2 == 1 && lst[i]\
    \ % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    return result;\n\
    }\n/*\nGiven a string s, return true if it is comprised of unique characters,\
    \ otherwise return false.", "{\n    return lst.addEvenOddIndex();\n}", "{\n  \
    \  long sum = 0;\n    foreach(int i, long elem; lst)\n    {\n        if (i % 2\
    \ == 1 && elem % 2 == 0)\n        {\n            sum += elem;\n        }\n   \
    \ }\n    return sum;\n}", "{\n    long result = 0L;\n    int j = 0;\n    foreach(int\
    \ i; lst)\n    {\n        if (i % 2 == 0 && j % 2 != 0)\n        {\n         \
    \   result += i;\n        }\n        j++;\n    }\n    return result;\n}\n/*\n\
    Given a list of integers lst, find all the odd numbers that are not divisible\
    \ by 3.", "{\n    auto odds = lst.filter!(x => lst.indexOf(x) & 1)();\n    return\
    \ odds.sum();\n}", "{\n    // auto lst = [4L, 2L, 6L, 7L];\n    long sum = 0;\n\
    \    foreach( index, element; lst)\n    {\n        if(index % 2 == 1 && element\
    \ % 2 == 0)\n        {\n            sum += element;\n        }\n    }\n    return\
    \ sum;\n    /*\n    auto lst = [4L, 2L, 6L, 7L];\n    long sum = 0;\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(i % 2 == 1 && lst[i] % 2 == 0)\n\
    \        {\n            sum += lst[i];\n        }\n    }\n    return sum;\n  \
    \  */\n}", "{\n    import std.algorithm;\n    return chain(lst)\n        .filter!(a\
    \ => isOdd(a[1]))\n        .filter!(a => isEven(a[0]))\n        .sum!((a) => a[0]);\n\
    }", "{\n  int i = 0;\n  long sum = 0;\n  while (i < lst.length)\n  {\n    if (i\
    \ % 2 == 1)\n    {\n      sum += lst[i];\n    }\n    i += 1;\n  }\n  return sum;\n\
    }\n/*\nGiven two positive integers start and end, return a list of all the unique\
    \ \nprimes between start and end, inclusive.", "{\n    long total = 0;\n    foreach(index,\
    \ value; lst)\n    {\n      if(index % 2 != 0 && value % 2 == 0)\n      {\n  \
    \      total += value;\n      }\n    }\n    return total;\n}", "{\n    long sum\
    \ = 0;\n    foreach(long elt; lst) \n    {\n        if(elt % 2 == 0 && cast(int)elt\
    \ % 2 != 0)\n        {\n            sum += elt;\n        }\n    }\n    return\
    \ sum;\n}\n/*\n    func f1(func func f, long a) {\n        return f(a);\n    }\n\
    \    long g1(long a) {\n        return a * a;\n    }\n    long f2(long a) {\n\
    \        return a * a * a;\n    }\n    Examples:\n    >>> f1(g1, 5L)\n    25L\n\
    \    >>> f1(f2, 5L)\n    125L\n    \n*/\nlong f1(long delegate(long) f, long a)\
    \ \n{\n    return f(a);\n}\n/*\n    Examples:\n    >>> g1(2L)\n    4L\n    \n\
    */\nlong g1(long a) \n{\n    return a * a;\n}\n/*\n    Examples:\n    >>> f2(2L)\n\
    \    8L\n    \n*/\nlong f2(long a) \n{\n    return a * a * a;\n}\n/*\nGiven two\
    \ lists lst1 and lst2, create a new list. For each element of lst1, find the value\
    \ in lst2 that is closest to it.\nIf there are two values in lst2 that are equal\
    \ distance from the element of lst1, pick the smallest one.", "{\n    return lst.fold!((a,\
    \ b) => a + (isOdd(b) ? 0 : b))(0L);\n}", "{\n    long result = 0L;\n    foreach(i,\
    \ e; lst) \n    {\n        if((i % 2 == 1) && (e % 2 == 0)) \n        {\n    \
    \        result += e;\n        }\n    }\n    return result;\n}", "{\n    long\
    \ l = 0;\n    for (long i = 0; i < lst.length; i++)\n    {\n        if (i%2==1\
    \ && lst[i]%2==0)\n        {\n            l += lst[i];\n        }\n    }\n   \
    \ return l;\n}", "{\n    int sum = 0;\n    for (int i = 0; i < lst.length; i++)\n\
    \    {\n        if ( i % 2 == 1 && lst[i] % 2 == 0)\n        {\n            sum\
    \ += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long result = 0L;\n\
    \    foreach( i, a; lst )\n    {\n        if( a % 2 == 0 && i % 2 != 0 )\n   \
    \     {\n            result += a;\n        }\n    }\n    return result;\n}\n/*\n\
    \    >>> add([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L])\n    6L\n    \n*/", "{\n\
    \    long sum=0;\n    foreach(int i; 0..lst.length)\n    {\n      if(i%2==1 &&\
    \ lst[i]%2==0)\n      {\n        sum+=lst[i];\n      }\n    }\n    return sum;\n\
    }", "{\n    long sum=0;\n    for(int i=0;i<lst.length;i++)\n    {\n        if(i%2!=0\
    \ && lst[i]%2==0)\n        {\n            sum+=lst[i];\n        }\n    }\n   \
    \ return sum;\n}", "{\n    long result = 0L;\n    foreach(index, elem; lst)\n\
    \    {\n        if(elem % 2 == 0 && index % 2 != 0)\n        {\n            result\
    \ += elem;\n        }\n    }\n    return result;\n}", "{\n    int i;\n    long\
    \ result = 0;\n    for (i = 0; i < lst.length; i++)\n    {\n        if ((lst[i]\
    \ % 2 == 0) && (i % 2 != 0))\n        {\n            result += lst[i];\n     \
    \   }\n    }\n    return result;\n}", "{\n    long sum = 0;\n    foreach(index,\
    \ value; lst)\n    {\n        if(index % 2 == 1 && value % 2 == 0)\n        {\n\
    \            sum += value;\n        }\n    }\n    return sum;\n}", "{\n  return\
    \ lst[1L..$].filter!(i => i % 2 == 0).reduce!((a, b) => a + b)(0L);\n}", "{\n\
    \    return lst.enumerate.filter!(a => a.index % 2 == 1 && a.value % 2 == 0).map!(a\
    \ => a.value).sum;\n}", "    {\n    long evens = 0;\n    foreach(ind, val; lst)\
    \ \n        {\n        if(ind % 2 == 1 && val % 2 == 0)\n            {\n     \
    \       evens += val;\n            }\n        }\n    return evens;\n    }\n/*\n\
    Given a list of integers lst and a single integer k, add all the elements in lst\
    \ that are greater than k.", "{\n    return lst.enumerate.filter!(a => a.index\
    \ % 2 == 1 && a.value % 2 == 0).sum!(b => b.value)();\n}", "{\n    long result\
    \ = 0L;\n    foreach( i, v; lst)\n    {\n        if ( i % 2 != 0)\n        {\n\
    \            if ( v % 2 == 0)\n            {\n                result += v;\n \
    \           }\n        }\n    }\n    return result;\n}\n/*\nGiven a positive integer\
    \ n, and a positive integer start, return the sum of the numbers from start to\
    \ (start+n) using a while loop.", "{\n    long res = 0L;\n    foreach(idx, val;\
    \ lst) \n    {\n        if(idx % 2 == 1 && val % 2 == 0) \n        {\n       \
    \     res += val;\n        }\n    }\n    return res;\n}\n/*\nDelete each element\
    \ at a given index from a list lst.", "{\n    long sum = 0;\n    foreach(i, e;\
    \ lst) \n    {\n        if(i % 2 == 1 && e % 2 == 0) \n        {\n           \
    \ sum += e;\n        }\n    }\n    return sum;\n}\n/*\nSorting a tuple\nGiven\
    \ a tuple of integers tpl, sort it by the sum of its elements in ascending order.",
  "{\n    return lst.filter!(x => (x % 2 == 0)).sum();\n}\n/*\nThis time no story,\
    \ no theory. The examples below show you how to write function accum:", "{\n \
    \   long add = 0L;\n    long i = 0L;\n    while (i < lst.length) \n    {\n   \
    \     if (i % 2 == 1L)\n        {\n            add += lst[i];\n        }\n   \
    \     i++;\n    }\n    return add;\n}\n/*\nGiven a non-empty array of integers\
    \ lst, add all the values that are multiples of 5. ", "{\n    long  x = 0;\n \
    \   foreach(i,e; lst)\n    {\n        if(i%2==1 && e%2==0)\n            x+=e;\n\
    \    }\n    return x;\n}", "{\n    return lst.filter!(a => a % 2 == 0 && lst.indexOf(a)\
    \ % 2 != 0).sum;\n}\n/*\ncreate a function which will take a string as an argument\
    \ and return a list containing all the words in the string.\ntest(\"test\").map!(a\
    \ => a.toString()).\n    reduce!((a, b) => a + b).length.assertEqual(10);\ntest(\"\
    test\").map!(a => a.toString()).\n    reduce!((a, b) => a + b).assertEqual(\"\
    test\");\ntest(\"test\").map!(a => a.toString()).reduce!((a, b) => a + b).\n \
    \   assertEqual(\"test\");\n*/\nstring[] create(string s)\n{\n    auto r = new\
    \ string[](s.split(\" \").length);\n    foreach(a; s.split(\" \"))\n    {\n  \
    \      r[s.split(\" \").indexOf(a)] = a;\n    }\n    return r;\n}\n/*\ngiven a\
    \ string s and a number n\ncreate a function which returns a string with n copies\
    \ of the last n characters of the string\ntest(\"Hello\", 2).assertEqual(\"lololo\"\
    );\ntest(\"Hello\", 3).assertEqual(\"lllllllll\");\ntest(\"Hello\", 1).assertEqual(\"\
    o\");\ntest(\"Hello\", 0).assertEqual(\"\");\ntest(\"ayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayayay",
  "{\n    long s=0;\n    foreach(long i; lst)\n    {\n        if (i%2==0)\n      \
    \  {\n            s=s+i;\n        }\n    }\n    return s;\n}", "{\n    long result\
    \ = 0L;\n    foreach(i, element; lst) \n    {\n        if(i % 2L != 0L && element\
    \ % 2L == 0L) \n        {\n            result += element;\n        }\n    }\n\
    \    return result;\n}", "{\n    long sum = 0;\n    foreach(index, value; lst)\n\
    \    {\n        if(index % 2 == 1 && value % 2 == 0)\n        {\n            sum\
    \ += value;\n        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n  \
    \  foreach(i,e; lst)\n    {\n        if(i%2 == 1 && e%2 == 0)\n        {\n   \
    \         sum += e;\n        }\n    }\n    return sum;\n}\n/*\nGiven a non-empty\
    \ array of integers lst, return the sum of all its elements.", "{\n  int n = lst.length;\n\
    \  return lst[i] for i in 0..n-1 if (i%2==0) if (lst[i]%2==0);\n}\n/*\nGiven a\
    \ non-empty array of integers lst, reverse only the even numbers from the array.",
  "{\n    assert(lst.length > 0L);\n    long rv = 0L;\n    foreach (idx, num; lst)\
    \ \n    {\n        if (idx & 1L == 1L && num & 1L == 0L)\n        {\n        \
    \    rv += num;\n        }\n    }\n    return rv;\n}\n/*\nGiven an array of ints,\
    \ set all the odd elements to 1 and all the even ones to 0.", "{\n    /*\n   \
    \ int sum = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (i % 2\
    \ == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n \
    \   return sum;\n    */\n    int sum = 0;\n    auto a = lst.filter!(x => x % 2\
    \ == 0);\n    for (int i = 0; i < a.length; i++) {\n        if (i % 2 == 1) {\n\
    \            sum += a[i];\n        }\n    }\n    return sum;\n}\n/*", "{\n   \
    \ long result = 0L;\n    foreach(idx, element; lst) \n    {\n        if(element\
    \ % 2 == 0 && idx % 2 != 0) \n        {\n            result += element;\n    \
    \    }\n    }\n    return result;\n}", "{\n    long sum = 0;\n    foreach(i, e;\
    \ lst) {\n        if (e % 2 == 0 && i % 2 != 0) {\n            sum += e;\n   \
    \     }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    for (long i =\
    \ 0; i < lst.length; i++)\n    {\n        if (i % 2 == 1 && lst[i] % 2 == 0)\n\
    \        {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
  "{\n    long sum = 0;\n    foreach(int i, long l; lst) \n    {\n        if (i %\
    \ 2 == 1 && l % 2 == 0) \n        {\n            sum += l;\n        }\n    }\n\
    \    return sum;\n}", "{\n    long x = 0;\n    bool even = false;\n    foreach(l;\
    \ lst)\n    {\n        if(l % 2 == 0 && even)\n        {\n            x = x +\
    \ l;\n        }\n        even = !even;\n    }\n    return x;\n}", "{\n  long sum\
    \ = 0;\n  foreach(idx, l; lst)\n  {\n    if(idx%2 == 1 && l%2 == 0)\n    {\n \
    \     sum += l;\n    }\n  }\n  return sum;\n}", "{\n  long sum = 0;\n  foreach(i,\
    \ e; lst)\n    if(i % 2 == 1 && e % 2 == 0)\n      sum += e;\n  return sum;\n}",
  "  return lst.zip!((x, i) => ((x.isEven) && (i.isOdd)) ? x : 0L)\n  .reduce!((a,\
    \ b) => a + b)();\n}", "{\n\tlong ret = 0;\n\tfor (long idx = 0; idx < lst.length;\
    \ idx++) \n\t{\n\t\tif (lst[idx] % 2 == 0 && idx % 2 == 1)\n\t\t{\n\t\t\tret +=\
    \ lst[idx];\n\t\t}\n\t}\n\treturn ret;\n}", "{\n    long sum = 0;\n    foreach(int\
    \ i, long e; lst)\n    {\n        if (i%2 != 0 && e%2 == 0)\n        {\n     \
    \       sum += e;\n        }\n    }\n    return sum;\n}\n ", "{\n    long sum\
    \ = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (isEven(i) && isEven(lst[i]))\
    \ {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}", "{\n \
    \ return lst.retro.filter!(a => a % 2 == 0).sum;\n}", "{\n    long accumulator\
    \ = 0L;\n    for (size_t i = 0; i < lst.length; i+=2)\n    {\n        accumulator\
    \ += lst[i];\n    }\n    return accumulator;\n}\n/*\nCreate a generic function,\
    \ fun, that takes an argument and returns the absolute value of that argument.\n\
    \    Example:\n    >>> fun(-5)\n    5\n*/\nT fun(T)(T x)\n{\n    return abs(x);\n\
    }\n/*\nCreate a function that takes a string, str, and returns the string repeated\
    \ num times.\n    Example:\n    >>> repeat(\"foo\", 3)\n    \"foofoofoo\"\n*/\n\
    string repeat(string str, int num)\n{\n    return str.dup.joiner(num).array.joiner.toString;\n\
    }\n/*\nCreate a function that takes a string, str, and returns the number of occurrences\
    \ of each letter in the string.\n    Example:\n    >>> freq_counter(\"aaaaabbbbbbbccccc\"\
    )\n    [\"a\": 5, \"b\": 7, \"c\": 5]\n*/\nimmutable int[] freq_counter(string\
    \ str)\n{\n    immutable int[] result = [];\n    foreach(c; str)\n    {\n    \
    \    immutable size_t index = c.toString.indexOf(c);\n        if (result.length\
    \ == 0)\n        {\n            result = [1];\n        }\n        else if (index\
    \ == 0)\n        {\n            result = [result[0] + 1];\n        }\n       \
    \ else\n        {\n            result ~= 1;\n        }\n    }\n    return result;\n\
    }\n/*\nCreate a function that takes two strings, str1 and str2, and returns the\
    \ number of occurrences of str2 in str1.\n    Example:\n    >>> check_occurrences(\"\
    aaa\", \"aa\")\n    2\n*/\nimmutable int check_occurrences(string str1, string\
    \ str2)\n{\n    immutable int[] result = [];\n    foreach(c; str1)\n    {\n  \
    \      immutable size_t index = c.toString.indexOf(c);\n        if (result.length\
    \ == 0)", "{\n    return 0;\n}", "{\n    long sum = 0;\n    foreach(i, e; lst)\
    \ {\n        if(e % 2 == 0 && i % 2 != 0) {\n            sum += e;\n        }\n\
    \    }\n    return sum;\n}\n/*\nGiven a list of the form [[1, a], [2, b], [3,\
    \ c], [4, d], ...]\nconvert it to the form [[1, 2, 3, 4, ...], [a, b, c, d, ...]]\n\
    */\nlong[][] invert(long[][] lst) \n{\n    long[][] res = new long[2][];\n   \
    \ foreach(e; lst) {\n        res[0] ~= e[0];\n        res[1] ~= e[1];\n    }\n\
    \    return res;\n}\n/*\nGiven a positive integer n and a list of the form [[1,\
    \ a], [2, b], [3, c], [4, d], ...]\nfind the nth fibonacci number.\n*/\nlong findFib(long\
    \ n, long[][] lst) \n{\n    long[][] res = invert(lst);\n    for(long i = res[0].length;\
    \ i < n; i++) {\n        res[0] ~= i + 1;\n        res[1] ~= res[1][$ - 1] + res[1][$\
    \ - 2];\n    }\n    return res[1][$ - 1];\n}\n/*\nGiven an array of integers,\
    \ return True if the array contains a 3 next to a 3 somewhere.", "{\n    return\
    \ 0;\n}", "{\n    alias index_value = Tuple!(int, long);\n    auto pair = zip(iota(lst.length),\
    \ lst);\n    auto odd_even = pair.filter!((a) => a[0] % 2 == 1 && a[1] % 2 ==\
    \ 0)();\n    return odd_even.map!(v => v[1]).reduce!((a,b) => a + b)();\n}", "{\n\
    \    return 0;\n}", "{\n    long sum=0;\n    for(long i=0;i<lst.length;i++)\n\
    \    {\n        if(lst[i]%2==0 && i%2!=0)\n        {\n            sum+=lst[i];\n\
    \        }\n    }\n    return sum;\n}", "{\n    long ret = 0L;\n    foreach(i,\
    \ e; lst) \n    {\n        ret += (i % 2 == 0 && e % 2 == 0) ? e : 0L;\n    }\n\
    \    return ret;\n}", "{\n    long sum = 0;\n    foreach(int i, elem; lst)\n \
    \   {\n        if(i % 2 == 1 && elem % 2 == 0)\n        {\n            sum +=\
    \ elem;\n        }\n    }\n    return sum;\n}", "{\n    \n    long r = 0L;\n \
    \   foreach(i,e;enumerate(lst)){\n        if(i % 2 == 1 && e % 2 == 0){\n    \
    \        r += e;\n        }\n    }\n    return r;\n}\n/*\n    Given a non-empty\
    \ array of integers lst. add the even elements that are at odd indices.", "{\n\
    \    auto result = reduce!(a=>a[0]+a[1])(zip(filter!((e, i) => e & 1 == 0 && i\
    \ & 1 == 1)(lst), iota(0, lst.length)));\n    return result[0];\n}\n/*\nGiven\
    \ a list lst, multiply each element by 4.", "{\n    long result=0;\n    for(int\
    \ i=0;i<lst.length;i++)\n    {\n        if(lst[i]%2==0 && i%2!=0)\n        {\n\
    \            result+=lst[i];\n        }\n    }\n    return result;\n}\n/*\nGiven\
    \ a linked list, remove all consecutive nodes that sum to zero. Print out the\
    \ remaining nodes.", "{\n    long total = 0;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (i % 2 == 1 && lst[i] % 2 == 0)\n        {\n       \
    \     total += lst[i];\n        }\n    }\n    return total;\n}\n/*\n# User-friendly\
    \ version", "{\n    return lst[1..].filter!(a => a % 2 == 0).sum;\n}", "{\n  \
    \  long sum = 0;\n    for (int i = 0; i < lst.length; i += 2) \n    {\n      \
    \  if (i % 2 == 0) \n        {\n            sum += lst[i];\n        }\n    }\n\
    \    return sum;\n}", '    => lst.filter!(x => x % 2 == 0).fold!((x, y) => x +
    y);', "    {\n    long sum=0;\n    for(int i=0;i<lst.length;i++)\n        {\n\
    \        if(i%2!=0)\n            {\n            if(lst[i]%2==0)\n            \
    \    {\n                sum+=lst[i];\n            }\n        }\n    }\n    return\
    \ sum;\n}\n/*\na=[[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7]]", "{\n    auto accum\
    \ = 0L;\n    auto st = 0L;\n    auto en = lst.length;\n    auto mult = 1L;\n \
    \   for(auto i = st; i < en; i += 2) \n    {\n        if(lst[i] % 2 == 0) \n \
    \       {\n            accum += lst[i];\n        }\n    }\n    return accum;\n\
    }", "{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "{\n    long result\
    \ = 0L;\n    foreach(ix, val; lst) \n    {\n        if (ix % 2 == 1 && val % 2\
    \ == 0)\n        {\n            result += val;\n        }\n    }\n    return result;\n\
    }", "{\n    return map!(a => a * (a & 1))(lst).sum;\n}", "{\n    long result =\
    \ 0L;\n    foreach(i,e; lst) \n    {\n        if(i % 2 == 1 && e % 2 == 0)\n \
    \       {\n            result += e;\n        }\n    }\n    return result;\n}",
  "{\n    import std.range;\n    static if (is(typeof(lst[0]) == long))\n    {\n \
    \       return lst.zip(0L..lst.length).filter!(a => a[1] % 2 == 1).map!(a => a[0]).filter!(a\
    \ => a % 2 == 0).sum;\n    }\n    else static if (is(typeof(lst[0]) == double))\n\
    \    {\n        return lst.zip(0L..lst.length).filter!(a => a[1] % 2 == 1).map!(a\
    \ => a[0]).filter!(a => a % 2 == 0).sum;\n    }\n    else\n    {\n        return\
    \ 0;\n    }\n}", "{\n    return lst.retro .filter!((a,i) => a % 2 == 0 && i %\
    \ 2 == 1) .sum;\n}", "{\n    long ret=0;\n    if (lst.length == 0) \n        return\
    \ ret;\n    if (lst.length == 1) \n        return lst[0];\n    foreach (idx, elem;\
    \ lst) \n    {\n        if (elem % 2 == 0 && idx % 2 != 0) \n            ret +=\
    \ elem;\n    }\n    return ret;\n}", "{\n    return 0;\n}\n/*\nGiven a non-empty\
    \ array of integers lst. add the odd elements that are at even indices..", "{\n\
    \    int index = 0;\n    long evenSum = 0;\n    foreach(num; lst)\n    {\n   \
    \     if(index % 2 == 1 && num % 2 == 0)\n        {\n            evenSum += num;\n\
    \        }\n        index++;\n    }\n    return evenSum;\n}", "{\n  long odd_sum\
    \ = 0;\n  foreach(i, x; lst) \n  {\n    if (x % 2 == 0 && i % 2 != 0) \n    {\n\
    \      odd_sum += x;\n    }\n  }\n  return odd_sum;\n}", "{\n\tlong sum = 0;\n\
    \tint pos = 0;\n\tforeach(num; lst)\n\t{\n\t\tif(pos % 2 == 1 && num % 2 == 0)\n\
    \t\t{\n\t\t\tsum += num;\n\t\t}\n\t\tpos++;\n\t}\n\treturn sum;\n}", "{\n  long\
    \ res = 0L;\n  for (int i = 0; i < lst.length; i++)\n  {\n    if (i % 2 == 1 &&\
    \ lst[i] % 2 == 0)\n    {\n      res += lst[i];\n    }\n  }\n  return res;\n}\n\
    }", "{\n    long sum = 0;\n    foreach(index, elem; lst)\n    {\n        if(elem\
    \ % 2 == 0 && index % 2 != 0)\n        {\n            sum += elem;\n        }\n\
    \    }\n    return sum;\n}", "{\n  return lst.retro.filter!(a => a % 2 == 0)().fold!((acc,\
    \ cur) => acc + cur)();\n}", "{\n    return lst.filter!(a => a % 2 == 0)().sum();\n\
    }", "{\n    long n = 0L;\n    foreach(i, e; lst) \n    {\n        if (i % 2 ==\
    \ 1) \n        {\n            n += e;\n        }\n    }\n    return n;\n}", "{\n\
    \    long sum = 0;\n    foreach(idx, e; lst) {\n        if (idx % 2 == 1 && e\
    \ % 2 == 0) {\n            sum += e;\n        }\n    }\n    return sum;\n}", "{\n\
    \    return lst.filter!(x => x % 2 == 0).sum!((x, y) => x + y)();\n}\n```", "{\n\
    \  return lst.length == 0 ? 0 : lst[0] % 2 == 0 ? lst[0] + add(lst[1 .. $]) :\
    \ add(lst[1 .. $]);\n}", "{\n    long sum = 0;\n    for (int i = 0; i < lst.length;\
    \ i += 2)\n    {\n        sum += i % 2 == 0 ? lst[i] : 0;\n    }\n    return sum;\n\
    }\n/*\nCheck if a string is a palindrome. Palindromes are strings that read the\
    \ same from the left or right, for example madam or 0110.", "{\n    long sum =\
    \ 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if (i % 2 == 1\
    \ && lst[i] % 2 == 0)\n        {\n            sum += lst[i];\n        }\n    }\n\
    \    return sum;\n}\n/*\nGiven a non-empty array of integers lst. add the even\
    \ elements that are at odd indices..", "{\n    if (lst.length <= 0)\n    {\n \
    \       return 0;\n    }\n    long sum = 0;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (i % 2 == 1 && lst[i] % 2 == 0)\n        {\n       \
    \     sum += lst[i];\n        }\n    }\n    return sum;\n}", "    {\n        long\
    \ odd_sum = 0;\n        foreach(i, elem; lst)\n        {\n            if(i % 2\
    \ == 1 && isEven(elem))\n            {\n                odd_sum += elem;\n   \
    \         }\n        }\n        return odd_sum;\n    }", "{\n    return lst.retro.filter!((a,\
    \ i) => a % 2 == 0 && i % 2 == 1).sum;\n}", "{\n    auto a = lst.dup;\n    a.remove(2..$);\n\
    \    a.remove(0..1);\n    return a.sum;\n}", "{\n    long res = 0L;\n    foreach(i,\
    \ ind; lst) \n    {\n        if(i % 2 == 0)\n            res += ind;\n    }\n\
    \    return res;\n}", "{\n    long c=0;\n    foreach(long i, long j; iota(lst.length).zip(lst))\n\
    \    {\n        if(i%2!=0 && j%2==0)\n        {\n            c+=j;\n        }\n\
    \    }\n    return c;\n}", "{\n  return reduce!q{a + b}(map!q{a}(filter!q{a %\
    \ 2 == 0}(filter!q{(index % 2) == 1}(zip(lst, iota(lst.length))))));\n}", "{\n\
    \    long sum = 0;\n    foreach(i, elem; lst)\n    {\n        if(i%2==1)\n   \
    \     {\n            if(elem%2==0)\n            {\n                sum += elem;\n\
    \            }\n        }\n    }\n    return sum;\n}", "{\n    int s = 0;\n  \
    \  for (int i = 0; i < lst.length; i++) {\n        if (i % 2 == 1 && lst[i] %\
    \ 2 == 0) {\n            s += lst[i];\n        }\n    }\n    return s;\n}\n/*\n\
    In this kata you have to correctly return who is the \"survivor\", ie: the last\
    \ element of a Josephus permutation.", "{\n  long i = 0;\n  long sum = 0;\n  while\
    \ (i < lst.length) \n  {\n    if (i % 2 == 1) \n    {\n      sum += lst[i];\n\
    \    }\n    i++;\n  }\n  return sum;\n}", "{\n    long ret = 0L;\n    for (int\
    \ i = 0; i < lst.length; i++)\n    {\n        if (i % 2 == 1 && lst[i] % 2 ==\
    \ 0)\n        {\n            ret += lst[i];\n        }\n    }\n    return ret;\n\
    }", "{\n    long ret = 0L;\n    for (long index = 0L; index < lst.length; index\
    \ += 1L) {\n        if ((((index % 2L) == 0L) && ((lst[index] % 2L) == 0L))) {\n\
    \            ret += lst[index];\n        }\n    }\n    return ret;\n}", "{\n \
    \   if (lst.empty)\n    {\n        return 0;\n    }\n    auto evenOdd = zip(iota(lst.length),\
    \ lst);\n    return evenOdd.map!(a => a[0] % 2 == 0 ? a[1] : 0).reduce!((a, b)\
    \ => a + b)();\n}", "{\n    long sum = 0;\n    for (int i = 0; i < lst.length;\
    \ i += 2)\n    {\n        if (lst[i] % 2 == 0)\n        {\n            sum +=\
    \ lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long result = 0L;\n\
    \    int odd = 1;\n    foreach(int elem; lst)\n    {\n        if(odd % 2 == 1\
    \ && elem % 2 == 0)\n        {\n            result += elem;\n        }\n     \
    \   odd++;\n    }\n    return result;\n}", "{\n    long result = 0L;\n    foreach(i,\
    \ n; lst)\n    {\n        if(i % 2 == 1 && n % 2 == 0)\n        {\n          \
    \  result += n;\n        }\n    }\n    return result;\n}", "{\n   if (lst.length\
    \ == 0) \n   {\n      return 0;\n   }\n   else \n   {\n      return (lst[0] %\
    \ 2 == 0 ? lst[0] : 0) + add(lst[1 .. $]);\n   }\n}", '{', "{\n    \n    long\
    \ sum = 0;\n    for (long i = 0; i < lst.length; i++) {\n        if (i%2 != 0\
    \ && lst[i]%2 == 0)\n            sum += lst[i];\n    }\n    return sum;\n}\n/*\n\
    Return a new array where each element is the mirror image of the original.", "{\n\
    \  long sum=0;\n  int n = lst.length;\n  for(int i=0;i<n;i++)\n  {\n    if(i%2==1\
    \ && lst[i]%2==0)\n    {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
  "{\n    long cnt = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n       \
    \ if (lst[i] % 2 == 0 && i % 2 != 0)\n        {\n            cnt += lst[i];\n\
    \        }\n    }\n    return cnt;\n}\n/*\nGiven a non-empty array of integers\
    \ lst. add the odd elements that are at even indices..", "{\nlong ret = 0L;\n\
    foreach (k, v; lst)\n{\n    if (k % 2)\n    {\n        ret += v;\n    }\n}\nreturn\
    \ ret;\n}", "{\n    long result = 0L;\n    foreach(idx, val; lst) {\n        if((idx\
    \ % 2 == 1) && (val % 2 == 0)) result += val;\n    }\n    return result;\n}",
  "{\n    return lst.filter((a,i) => (a%2) == 0 && i%2 != 0).reduce!((a,b) => a+b)();\n\
    }", "{\n    // Write your code here.\n    int sum = 0;\n    foreach(i, v; lst)\n\
    \    {\n        if (v % 2 == 0 && i % 2 != 0)\n        {\n            sum += v;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long result = 0L;\n    foreach(ind,\
    \ val; lst)\n    {\n        if (ind % 2 != 0)\n        {\n            if (val\
    \ % 2 == 0)\n            {\n                result += val;\n            }\n  \
    \      }\n    }\n    return result;\n}", "{\n    long s = 0;\n    int i = 0;\n\
    \    foreach(n; lst)\n    {\n        if(i % 2 == 1 && n % 2 == 0)\n        {\n\
    \            s += n;\n        }\n        i++;\n    }\n    return s;\n}\n \n/*\n\
    Given a non-empty array of integers lst. add the even elements that are at odd\
    \ indices..", "{\n  long i;\n  long r = 0L;\n  long sz = lst.length;\n  foreach\
    \ (i; 0L..sz) \n  {\n    if ((i % 2L) != 0L) \n    {\n      r += lst[i];\n   \
    \ }\n  }\n  return r;\n}\n/*\n    Examples:\n    >>> add([4L, 2L, 6L, 7L])\n \
    \   2L\n*/\nlong add(long[] lst) \n{\n  long i;\n  long r = 0L;\n  long sz = lst.length;\n\
    \  foreach (i; 0L..sz) \n  {\n    if ((i % 2L) != 0L) \n    {\n      r += lst[i];\n\
    \    }\n  }\n  return r;\n}\n/*\n    Examples:\n    >>> add([4L, 2L, 6L, 7L])\n\
    \    2L\n*/\nlong add(long[] lst) \n{\n  long i;\n  long r = 0L;\n  long sz =\
    \ lst.length;\n  foreach (i; 0L..sz) \n  {\n    if ((i % 2L) != 0L) \n    {\n\
    \      r += lst[i];\n    }\n  }\n  return r;\n}\n/*\n    Examples:\n    >>> add([4L,\
    \ 2L, 6L, 7L])\n    2L\n*/\nlong add(long[] lst) \n{\n  long i;\n  long r = 0L;\n\
    \  long sz = lst.length;\n  foreach (i; 0L..sz) \n  {\n    if ((i % 2L) != 0L)\
    \ \n    {\n      r += lst[i];\n    }\n  }\n  return r;\n}\n/*\n    Examples:\n\
    \    >>> add([4L, 2L, 6L, 7L])\n    2L\n*/\nlong add(long[] lst) \n{\n  long i;\n\
    \  long r = 0L;\n  long sz = lst.length;\n "]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
