name: HumanEval_62_derivative
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n xs represent coefficients of\
  \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative\
  \ of this polynomial in the same form.\n    >>> derivative([3L, 1L, 2L, 4L, 5L])\n\
  \    [1L, 4L, 12L, 20L]\n    >>> derivative([1L, 2L, 3L])\n    [2L, 6L]\n    \n\
  */\nlong[] derivative(long[] xs) \n"
tests: "unittest\n{\n    alias candidate = derivative;\n\n    assert(candidate([3L,\
  \ 1L, 2L, 4L, 5L]) == [1L, 4L, 12L, 20L]);\n    assert(candidate([1L, 2L, 3L]) ==\
  \ [2L, 6L]);\n    assert(candidate([3L, 2L, 1L]) == [2L, 2L]);\n    assert(candidate([3L,\
  \ 2L, 1L, 0L, 4L]) == [2L, 2L, 0L, 16L]);\n    assert(candidate([1L]) == []);\n\
  }\nvoid main(){}"
completions: ["{\n    long[] ys = new long[xs.length - 1];\n    for (int i = 0; i\
    \ < ys.length; i++) \n    {\n        ys[i] = xs[i + 1] * (i + 1);\n    }\n   \
    \ return ys;\n}", "{\n    int len = xs.length;\n    if (len < 2)\n    {\n    \
    \    return (len == 1) ? new long[]{0L} : new long[0];\n    }\n    long[] dxs\
    \ = new long[len - 1];\n    for (int i = 0; i < len - 1; i++)\n    {\n       \
    \ dxs[i] = xs[i + 1] * (i + 1);\n    }\n    return dxs;\n}\n \n/*\n  xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return integral of this polynomial in the same form.\n    >>> integral([3L,\
    \ 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 2L, 4L, 5L]\n    >>> integral([1L, 2L,\
    \ 3L])\n    [0L, 1L, 1L, 3L]\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L,\
    \ 3L, 0.5L, 2L, 4L, 5L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 3L]\n\
    */\nlong[] integral(long[] xs) \n{\n    int len = xs.length;\n    long[] ixs =\
    \ new long[len + 1];\n    for (int i = 0; i < len; i++)\n    {\n        ixs[i\
    \ + 1] = xs[i] / (i + 1);\n    }\n    return ixs;\n}\n \n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return the\
    \ value of this polynomial at x.\n    >>> evaluate(3L, [3L, 1L, 2L, 4L, 5L])\n\
    \    761L\n    >>> evaluate(2L, [1L, 2L, 3L])\n    17", "{\n    return xs[1..$];\n\
    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Return integral of this polynomial in the same form.\n  \
    \  >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 0.6666666666666666L,\
    \ 1.25L, 1.2L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 1L]\n    \n*/\n\
    long[] integral(long[] xs) \n{\n    immutable N = xs.length;\n    auto result\
    \ = new long[N + 1];\n    foreach (immutable i, immutable x; xs)\n    {\n    \
    \    result[i + 1] = x / (i + 1);\n    }\n    return result;\n}\n/*\n Calculate\
    \ the value of a polynomial defined by the coefficients in\n    coeffs at a given\
    \ point.\n    >>> evaluate([3L, 1L, 2L, 4L, 5L], 2L)\n    49L\n    >>> evaluate([1L,\
    \ 2L, 3L], 2L)\n    17L\n    \n*/\nlong evaluate(long[] coeffs, long point) \n\
    {\n    return coeffs.length == 0 ? 0 : coeffs[0] + point * evaluate(coeffs[1..$],\
    \ point);\n}\n/*\n Return the result of a multiplication of polynomials defined\
    \ by their\n    coefficients.\n    >>> poly_multiply([1L, 1L], [1L, 1L])\n   \
    \ [1L, 2L, 1L]\n    >>> poly_multiply([1L, 1L, 1L], [1L, 1L])\n    [1L, 2L, 2L,\
    \ 1L]\n    >>> poly_multiply([1L, 2L, 3L], [0L, 1L, 2L, 3L])\n    [0L, 1L, 4L,\
    \ 10L, 12L, 9L]\n    \n*/", "{\n    int degree = xs.length - 1;\n    if (degree\
    \ == 0) \n    {\n        return [0L];\n    }\n    long[] ys = [0L];\n    ys.length\
    \ = degree;\n    long[] zs = new long[degree];\n    foreach (i, x; xs) \n    {\n\
    \        if (i > 0) \n        {\n            zs[i - 1] = i * x;\n        }\n \
    \   }\n    return zs;\n}\n//     Calculate n factorial.\nlong factorial(int n)\
    \ \n{\n    long[] ys = [1L];\n    foreach (x; [1 .. n]) \n    {\n        ys[0]\
    \ *= x;\n    }\n    return ys[0];\n}\n/*\n Calculate polyomial of a multi variable:\n\
    \    f(x, y) = 1 + 2*x + 3*x^2 + 4*y + 5*y^2 + 6*x*y\n    \n*/\nlong poly_multi(long[]\
    \ coeffs, long[] xs) \n{\n    long ret = 0L;\n    int len = coeffs.length;\n \
    \   int lenx = xs.length;\n    foreach (i, x; xs) \n    {\n        foreach (j,\
    \ y; xs) \n        {\n            int idx = ((i + 1) * (lenx + 1) - (lenx - j))\
    \ - 1;\n            ret += coeffs[idx] * x * y;\n        }\n    }\n    return\
    \ ret;\n}\n//     The following two functions are copied from\n//    http://rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation#D\n\
    long poly_eval(long[] xs, long x) \n{\n    long result = 0L;\n    foreach (coeff;\
    \ xs) \n    {\n        result = result * x + coeff;\n    }\n    return result;\n\
    }\nlong poly_eval(long[] xs, float x) \n{\n    float result = 0", "{\n    immutable\
    \ len = xs.length;\n    if (len < 2) return [0L];\n    long[] ys = new long[len\
    \ - 1];\n    foreach (immutable int i, immutable long x; xs) \n    {\n       \
    \ if (i == 0) continue;\n        ys[i - 1] = i * x;\n    }\n    return ys;\n}\n\
    /*\n     xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Return indefinite integral of this polynomial in the same\
    \ form.\n    The constant of integration is taken to be 0, so the first element\n\
    \    of the result is always 0.\n    >>> indefinite_integral([3L, 1L, 2L, 4L,\
    \ 5L])\n    [0L, 3L, 0.5L, 2L, 2.0L, 5L]\n    >>> indefinite_integral([1L, 2L,\
    \ 3L])\n    [0L, 1L, 1.0L, 3L]\n    \n*/\nlong[] indefinite_integral(long[] xs)\
    \ \n{\n    immutable len = xs.length;\n    long[] ys = new long[len + 1];\n  \
    \  ys[0] = 0L;\n    foreach (immutable int i, immutable long x; xs) \n    {\n\
    \        ys[i + 1] = x / cast(long)(i + 1);\n    }\n    return ys;\n}\n/*\n  \
    \   Return definite integral of polynomial with coefficients given in xs\n   \
    \ from lower_limit to upper_limit.\n    >>> definite_integral([3L, 1L, 2L, 4L,\
    \ 5L], 0, 1)\n    8L\n    >>> definite_integral([1L, 2L, 3L], -1, 1)\n    4L\n\
    \    \n*/\nlong definite_integral(long[] xs, real lower_limit, real upper_limit)\
    \ \n{\n    long[] ys = indefinite_integral(xs);\n    real v1 = real_eval_polynomial(ys,\
    \ lower_limit", "{\n    int []s = new int[xs.length];\n    int[] r = new int[xs.length\
    \ - 1];\n    foreach (int i, long j; zip(i, j, xs))\n    {\n        s[i] = i *\
    \ j;\n    }\n    foreach (int i, int j; zip(i, j, s))\n    {\n        r[i] = j;\n\
    \    }\n    return r;\n}", "{\n    long[] $result;\n    bool[] a = false;\n  \
    \  bool[] b = true;\n    bool[] c = false;\n    bool[] d = false;\n    bool[]\
    \ e = false;\n    bool[] f = false;\n    bool[] g = false;\n    bool[] h = false;\n\
    \    bool[] i = false;\n    bool[] j = false;\n    bool[] k = false;\n    bool[]\
    \ l = false;\n    bool[] m = false;\n    bool[] n = false;\n    bool[] o = false;\n\
    \    bool[] p = false;\n    bool[] q = false;\n    bool[] r = false;\n    bool[]\
    \ s = false;\n    bool[] t = false;\n    bool[] u = false;\n    bool[] v = false;\n\
    \    bool[] w = false;\n    bool[] x = false;\n    bool[] y = false;\n    bool[]\
    \ z = false;\n    long[] $result1;\n    long[] $result2;\n    long[] $result3;\n\
    \    long[] $result4;\n    long[] $result5;\n    long[] $result6;\n    long[]\
    \ $result7;\n    long[] $result8;\n    long[] $result9;\n    long[] $result10;\n\
    \    long[] $result11;\n    long[] $result12;\n    long[] $result13;\n    long[]\
    \ $result14;\n    long[] $result15;\n    long[] $result16;\n    long[] $result17;\n\
    \    long[] $result18;\n    long[] $result19;\n    long[] $result20;\n    long[]\
    \ $result21;\n    long[] $result22;\n    long[] $result23;\n    long[] $result24;\n\
    \    long[] $result25;\n    long[] $result26;\n    long[] $result27;\n    long[]\
    \ $result28;\n    long[] $result29;\n    long[] $result30;\n    long[] $result31;\n\
    \    long[] $result32;\n    long[] $result33;\n    long[] $result34;\n    long[]\
    \ $result35;\n    long[] $result36;\n    long[] $result37", "{\n    return xs[0..$-1].map!(i\
    \ => i * cast(long)(i + 1));\n}", "{\n   alias tup = tuple!(long, long);\n   auto\
    \ ts = map!(tup)(iota(0L, cast(size_t)xs.length), xs);\n   return map!((a, b)\
    \ => a * b)(ts[0L .. $ - 1L])[];\n}", "{\n    if(xs.length < 2) \n    {\n    \
    \    return new long[0];\n    }\n    return xs[1..$];\n}\n/*\n  xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral\
    \ of this polynomial in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n\
    \    [0L, 3L, 0.5L, 0.6666666666666666L, 1.25L, 0.2L]\n    >>> integral([1L, 2L,\
    \ 3L])\n    [0L, 1L, 1L, 1L]\n    \n*/\ndouble[] integral(long[] xs) \n{\n   \
    \ alias N = long;\n    alias I = double;\n    auto n = xs.length;\n    auto ys\
    \ = new I[n + 1];\n    if(n > 0) \n    {\n        ys[0] = 0.0;\n        foreach(i,\
    \ ref x; xs) \n        {\n            ys[i + 1] = I(x) / I(i + 1);\n        }\n\
    \    }\n    return ys;\n}\n/*\n  xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral from left to\
    \ right of this polynomial in the same form.\n    >>> integral_left([3L, 1L, 2L,\
    \ 4L, 5L], 1, 2)\n    [0.3333333333333333L, 2.75L, 3.75L]\n    >>> integral_left([1L,\
    \ 2L, 3L], 1, 2)\n    [0.5L, 2.0L, 3.0L]\n    \n*/\ndouble[] integral_left(long[]\
    \ xs, long x0, long x1) \n{\n    alias N = long;\n    alias I = double;\n    auto\
    \ n = xs.length;\n    auto ys = new I[n];\n    if", "{\n   if (xs.length <= 1)\
    \ \n      return new long[0];\n    long[] ys = new long[xs.length - 1];\n    long[]\
    \ ys_ = new long[xs.length - 1];\n    auto b = xs.length;\n    foreach(i, x; xs)\
    \ \n    {\n        if (i != 0) \n            ys_[i - 1] = i * x;\n    }\n    return\
    \ ys_;\n}", "{\n    long[] res = new long[xs.length - 1];\n    for (long i = 0L;\
    \ i < res.length; i++)\n    {\n        res[i] = xs[i + 1] * (i + 1L);\n    }\n\
    \    return res;\n}", "{\n    int n = xs.length;\n    long[] ys = new long[n -\
    \ 1];\n    for (int i = 1; i < n; i++)\n    {\n        ys[i - 1] = i * xs[i];\n\
    \    }\n    return ys;\n}", "{\n    size_t i = 0;\n    long[] res = new long[xs.length-1];\n\
    \    for (i = 0; i < xs.length - 1; i++)\n    {\n        res[i] = xs[i+1] * (i+1);\n\
    \    }\n    return res;\n}", "{\n  long[] ys = xs[1..$];\n  ys.length = xs.length\
    \ - 1;\n  long[] zs = zip!(\"a * b\", ys, iota(1, xs.length - 1))();\n  return\
    \ zs;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] *\
    \ x + xs[2] * x^2 + ....\n     Return the integral of this polynomial in the same\
    \ form.\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 1L]\n    >>> integral([1L,\
    \ 2L, 3L, 4L])\n    [0L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] integral(long[] xs)\
    \ {\n  long[] ys = new long[xs.length + 1];\n  ys[0] = 0;\n  ys[1..$] = xs;\n\
    \  long[] zs = zip!(\"a / b\", ys, iota(1, xs.length + 1))();\n  return zs;\n\
    }\n/*\n Return coefficients of the polynomial such that\n    p(x) = 0.5*x^2 +\
    \ 1 is the integral of q(x).\n    >>> p = [0.5L, 0L, 1L]\n    >>> q = integral(p)\n\
    \    >>> compose(p, q)\n    [1L, 0L, 0L, 0L]\n    >>> compose(q, p)\n    [1L,\
    \ 0L, 0L, 0L]\n    >>> p = [3L, 2L, 1L]\n    >>> q = [1L, 0L, 0L, 0L]\n    >>>\
    \ compose(p, q)\n    [3L, 2L, 1L, 0L]\n    >>> compose(q, p)\n    [3L, 2L, 1L,\
    \ 0L]\n    >>> p = [3L, 2L, 1L]\n    >>> q = integral(p)\n    >>> compose(p, q)\n\
    \    [3L, 2L,", "{\n    long[] newpoly=new long[xs.length-1];\n    for (uint k=0;k<newpoly.length;k++)\n\
    \    {\n        newpoly[k]=xs[k+1]*(k+1);\n    }\n    return newpoly;\n}\n/*\n\
    \ Efficiently evaluate the polynomial at x using Horner's scheme.\n    xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \    >>> polyval([3L, 1L, 2L, 4L, 5L], -2L)\n    -3L\n    >>> polyval([3L, 1L,\
    \ 2L, 4L, 5L], 0L)\n    3L\n    >>> polyval([3L, 1L, 2L, 4L, 5L], 3L)\n    94L\n\
    \    >>> polyval([3L, 1L, 2L, 4L, 5L], 4L)\n    155L\n*/\nlong polyval(long[]\
    \ xs, long x) \n{\n    long result=0;\n    for (uint k=0;k<xs.length;k++)\n  \
    \  {\n        result=xs[k]+result*x;\n    }\n    return result;\n}\n/*\n Find\
    \ a real root of the given polynomial, using Newton's method.\n    xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \    >>> find_real_root([3L, 1L, 2L, 4L, 5L])\n    -1.3040138071629562\n    >>>\
    \ find_real_root([1L, 2L, 3L])\n    -0.3333333333333333\n    >>> find_real_root([1L,\
    \ 0L, 0L, 0L, -1L])\n    1.0\n    >>> find_real_root([1L, 0L, 0L, 0L, 1L])\n \
    \   Traceback (most recent call last):\n        ...\n    ValueError: No real root.\n\
    */\ndouble find_real", "{\n    long[] ys = new long[xs.length - 1];\n    for (int\
    \ i = 0; i < ys.length; i++)\n        ys[i] = xs[i + 1] * (i + 1);\n    return\
    \ ys;\n}\n/*\n Return the sequence of coefficients for the polynomial of\n   \
    \ log |f|.\n    >>> log_coeffs([3L, 1L, 2L, 4L, 5L])\n    [0L, log(3), log(2),\
    \ log(2), log(5)]\n    \n*/\nTuple!(T,T) log_coeffs(T)(T[] xs) \n{\n    if (xs.length\
    \ == 0)\n        return tuple(0, 0);\n    T[] ys = new T[xs.length];\n    for\
    \ (int i = 0; i < ys.length; i++)\n        ys[i] = log(xs[i]);\n    return tuple(ys[0],\
    \ ys[1] - ys[0]);\n}\n/*\n Represent F as g * 2^e, where g is odd.  Then x^2 =\
    \ n is solvable\n    in integers if and only if e is even and g = 1.\n    >>>\
    \ is_square(1L)\n    True\n    >>> is_square(2L)\n    False\n    >>> is_square(3L)\n\
    \    True\n    >>> is_square(4L)\n    True\n    >>> is_square(5L)\n    False\n\
    \    >>> is_square(6L)\n    False\n    >>> is_square(7L)\n    False\n    >>> is_square(8L)\n\
    \    True\n    >>> is_square(9L)\n    True\n    >>> is_square(10L)\n    False\n\
    \    >>> is_square(121L)\n    True\n    >>> is_square(123L)\n    False\n    \n\
    */", "{\n    int n = xs.length;\n    if (n == 0)\n    {\n        return new long[0];\n\
    \    }\n    long[] dxs = new long[n - 1];\n    for (int i = 0; i < n - 1; i++)\n\
    \    {\n        dxs[i] = (i + 1) * xs[i + 1];\n    }\n    return dxs;\n}\n/*\n\
    \    Evaluate the polynomial of xs at x = value.\n    xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    \n    >>>\
    \ eval_poly([3L, 1L, 2L, 4L, 5L], 2L)\n    83L\n    >>> eval_poly([1L, 2L, 3L],\
    \ -1L)\n    6L\n    \n*/\nlong eval_poly(long[] xs, long value) \n{\n    int n\
    \ = xs.length;\n    if (n == 0)\n    {\n        return 0;\n    }\n    long result\
    \ = xs[n - 1];\n    for (int i = n - 2; i >= 0; i--)\n    {\n        result =\
    \ result * value + xs[i];\n    }\n    return result;\n}\n/*\n    xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return the polynomial in the same form with the leading coefficient and\
    \ degree\n    reduced.\n    >>> normalize([3L, 0L, 1L, 4L, 5L])\n    [1L, 4L,\
    \ 5L]\n    >>> normalize([1L, 2L, 3L])\n    [1L, 2L, 3L]\n    >>> normalize([0L,\
    \ 0L, 0L])\n    [0L]\n    \n*/\nlong[] normalize(long[] xs) \n{\n    int n = xs.length;\n\
    \    if (n == 0)\n    {\n        return new long[0];\n    }\n", "{\n\tint n =\
    \ xs.length;\n\tif (n == 0) \n\t{\n\t\treturn xs;\n\t}\n\tif (n == 1) \n\t{\n\t\
    \treturn new long[] {0L};\n\t}\n\tlong[] v = new long[n - 1];\n\tfor (int i =\
    \ 0; i < n - 1; i++) \n\t{\n\t\tv[i] = xs[i + 1] * (i + 1);\n\t}\n\treturn v;\n\
    }", "{\n  return std.take(xs, xs.length - 1L).map!((x,i) => \n  {\n    return\
    \ x * (xs.length - i - 1L);\n  })();\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral of this polynomial\
    \ in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L,\
    \ 2L, 4L, 5L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\n\
    long[] integral(long[] xs) \n{\n  return tuple(0L).cat(xs.map!((x,i) => \n  {\n\
    \    return x / (xs.length - i);\n  })());\n}\n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral\
    \ of this polynomial in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n\
    \    [0L, 3L, 0.5L, 2L, 4L, 5L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L,\
    \ 1L, 3L]\n    \n*/\nTuple!(long[]) integral(Tuple!(long[]) xs) \n{\n  return\
    \ tuple(0L).cat(xs.tupleof.map!((x,i) => \n  {\n    return x / (xs.tupleof.length\
    \ - i);\n  })());\n}\n/*\n Return coefficients of product of two polynomials.\n\
    \    >>> poly1 = [1L, 2L, 3L]\n    >>> poly2 = [2L, 3L, 4L]\n    >>> product(poly1,\
    \ poly2)\n    [2L, 7L, 16L, 12L", "{\n    long[] result = xs[1L..$];\n    auto\
    \ n = size_t(xs.length);\n    foreach (i; 1..n)\n    {\n        result[i - 1L]\
    \ *= i;\n    }\n    return result;\n}", "{\n    import std.stdio;\n    import\
    \ std.conv;\n    writeln(\"xs[0] \", xs[0], \" xs[1] \", xs[1], \" xs[2] \", xs[2],\
    \ \" xs[3] \", xs[3], \" xs[4] \", xs[4]);\n    long[] ys;\n    if (xs.length\
    \ == 1)\n    {\n        ys ~= 0;\n    }\n    else\n    {\n        foreach (i,\
    \ x; xs)\n        {\n            if (i == 0)\n            {\n                continue;\n\
    \            }\n            ys ~= x * i;\n        }\n    }\n    return ys;\n}\n\
    /*\n Compute the real roots of a polynomial.\n    xs represent coefficients of\
    \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return a list\
    \ of roots sorted from low to high.\n    >>> roots([1L, -4L, 4L])\n    [2.0, 2.0]\n\
    \    >>> roots([1L, -6L, 11L, -6L])\n    [1.0, 2.0, 3.0]\n    >>> roots([1L, -2L,\
    \ 0L, 2L])\n    [-1.0, 0.0, 1.0]\n    >>> roots([1L, -1L, 1L, -1L, 1L])\n    [-1.0,\
    \ -0.5, 0.0, 0.5, 1.0]\n    >>> roots([1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L", "{\n    import std.math;\n\
    \    import std.typecons;\n    /*\n     xs represent coefficients of a polynomial.\n\
    \        xs[0] + xs[1] * x + xs[2] * x^2 + ....\n         Return derivative of\
    \ this polynomial in the same form.\n        >>> derivative([3L, 1L, 2L, 4L, 5L])\n\
    \        [1L, 4L, 12L, 20L]\n        >>> derivative([1L, 2L, 3L])\n        [2L,\
    \ 6L]\n        \n    */\n    long[] derivative(long[] xs) \n    {\n        assert(xs.length\
    \ > 0);\n        long[] result = new long[];\n        foreach (c; xs[1..$])\n\
    \        {\n            immutable n = result.length;\n            result ~= c\
    \ * n;\n        }\n        return result;\n    }\n    assert(xs.length > 0);\n\
    \    long[] result = new long[];\n    foreach (c; xs[1..$])\n    {\n        immutable\
    \ n = result.length;\n        result ~= c * n;\n    }\n    return result;\n}\n\
    /*\n    Given a polynomial and a point, return the value of the polynomial at\
    \ that point.\n    >>> evaluate([1L, 2L, 3L], 2L)\n    17L\n    >>> evaluate([1L,\
    \ 1L, 1L], 3L)\n    13L\n*/\nlong evaluate(long[] xs, long x) \n{\n    /*\n  \
    \      Given a polynomial and a point, return the value of the polynomial at that\
    \ point.\n        >>> evaluate([1L, 2L, 3L], 2L)\n        17L\n        >>> evaluate([1L,\
    \ 1L, 1L], 3L)\n        13L\n    */\n    long evaluate(long[] xs, long x) \n \
    \   {\n        long result = 0L;\n        foreach (c; xs)\n        {\n       \
    \     result *= x;\n            result += c;\n        }\n        return result;\n\
    \    }\n    long result = 0L;\n    foreach (", "{\n    int n = xs.length - 1;\n\
    \    if (n < 1) return typeof(xs).init;\n    long[] ys = new long[n];\n    for\
    \ (int i = 0; i < n; i++) ys[i] = (i + 1) * xs[i + 1];\n    return ys;\n}", "{\n\
    \        final long[] ys = new long[$ - 1L];\n        for (long i = 0L; (i < ys.length);\
    \ i++)\n        {\n            ys[i] = (xs[(i + 1L)] * (i + 1L));\n        }\n\
    \        return ys;\n}\n/*\n \n xs represent coefficients of a polynomial.\n \
    \   xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral of this polynomial\
    \ in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L,\
    \ 2L, 4L, 5L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\n\
    long[] integral(long[] xs) \n{\n        final long[] ys = new long[$ + 1L];\n\
    \        for (long i = 0L; (i < xs.length); i++)\n        {\n            ys[(i\
    \ + 1L)] = (xs[i] / (i + 1L));\n        }\n        return ys;\n}\n/*\n xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     ys represent coefficients of another polynomial.\n    ys[0] + ys[1] * x\
    \ + ys[2] * x^2 + ....\n     Return sum of these two polynomials in the same form.\n\
    \    >>> add([3L, 1L, 2L, 4L, 5L], [2L, 4L, 5L])\n    [5L, 5L, 7L, 4L, 5L]\n \
    \   >>> add([1L, 2L, 3L], [3L, 4L, 5L])\n    [4L, 6L, 8L]\n    \n*/\nlong[] add(long[]\
    \ xs, long[] ys) \n{\n        final long[] nxs = new long[(max(xs.", "  return\
    \ xs[1 .. $].map!(x => x * cast(long)(xs.length - 1)).array;\n/*\n Generate a\
    \ sequence of polynomials representing the successive derivatives of f.\n    >>>\
    \ derivatives([2L, 3L, 4L])\n    [[2L, 3L, 4L], [3L, 8L], [8L]]\n    >>> derivatives([5L,\
    \ 2L, 1L, 4L])\n    [[5L, 2L, 1L, 4L], [2L, 2L, 12L], [2L, 24L], [24L]]\n    \n\
    */\nlong[][] derivatives(long[] f) \n  if(f.length == 1) return [f];\n  return\
    \ [f] ~ derivatives(derivative(f));\n/*\n xs represent a polynomial.\n    xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ....\n     Return the value of this polynomial when\
    \ x=x0.\n    >>> polynomial([2L, 3L, 4L], 1L)\n    9L\n    >>> polynomial([3L,\
    \ 2L, 1L], 2L)\n    17L\n    \n*/\nlong polynomial(long[] xs, long x0) \n  return\
    \ xs.zip(xs.length.iota).map!(x => x[0] * pow(x0, x[1])).sum;\n/*\n Generate a\
    \ sequence of the values of f when x=0,1,2,...\n    >>> polynomials([3L, 2L, 1L])\n\
    \    [3L, 6L, 11L, 18L, 27L, 38L, 51L, 66L, 83L, 102L]\n    \n*/\nlong[] polynomials(long[]\
    \ f) \n  return f.length.iota.map!(i => polynomial(f, i)).array;\n/*\n */", "{\n\
    \    long[] xs_ = new long[$length(xs) - 1];\n    foreach (i, x; xs)\n    {\n\
    \        xs_[i] = x * cast(long)i;\n    }\n    return xs_;\n}\n/*\n    xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \    Return derivative of this polynomial, removing leading zeros.\n    >>> derivative([3L,\
    \ 1L, 2L, 4L, 5L])\n    [1L, 4L, 12L, 20L]\n    >>> derivative([1L, 2L, 3L])\n\
    \    [2L, 6L]\n    >>> derivative([0L, 0L, 0L, 2L, 3L])\n    [0L, 0L, 6L]\n*/\n\
    long[] derivativeStrip(long[] xs) \n{\n    long[] xs_ = new long[$length(xs) -\
    \ 1];\n    foreach (i, x; xs)\n    {\n        xs_[i] = x * cast(long)i;\n    }\n\
    \    return strip(xs_);\n}", "{\n    long[] dxs = new long[xs.length-1];\n   \
    \ foreach (i, x; xs) {\n        if (i < dxs.length) {\n            dxs[i] = x\
    \ * i;\n        }\n    }\n    return dxs;\n}\n/*\n -*- coding: utf-8 -*-\n \n\
    \ Given coefficients of a univariate polynomial, this computes the value of the\
    \ polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    \n*/\nlong evalPoly(long[]\
    \ xs, long x) \n{\n    long y = 0;\n    long xp = 1;\n    foreach (i, xi; xs)\
    \ {\n        y += xi * xp;\n        xp *= x;\n    }\n    return y;\n}\n/*\n xs\
    \ represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2\
    \ + ....\n     Return the polynomial in the same form.\n    >>> scalePoly([1L,\
    \ 2L, 3L], 10L)\n    [10L, 20L, 30L]\n    >>> scalePoly([1L, 2L, 3L], 0L)\n  \
    \  [0L, 0L, 0L]\n    \n*/\nlong[] scalePoly(long[] xs, long s) \n{\n    return\
    \ xs.map!(x => x * s);\n}\n/*\n -*- coding: utf-8 -*-\n \n Multiply two univariate\
    \ polynomials.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    ys[0] + ys[1]\
    \ * x + ys[2] * x^2 + ....\n    \n*/\nlong[] multiplyPoly(long[] xs, long[] ys)\
    \ \n{\n    assert(xs.length > 0 && ys.length > 0);\n    size_t n = xs.length;\n\
    \    size_t m = ys.length;\n    assert(n <=", "{\n    long[] result = new long[xs.length\
    \ - 1];\n    for (int i = 0; i < result.length; i++)\n    {\n        result[i]\
    \ = xs[i + 1] * (i + 1);\n    }\n    return result;\n}\nlong[] integrate(long[]\
    \ xs) \n{\n    long[] result = new long[xs.length + 1];\n    for (int i = 0; i\
    \ < xs.length; i++)\n    {\n        result[i + 1] = xs[i] / (i + 1);\n    }\n\
    \    return result;\n}\nlong[] differentiate(long[] xs) \n{\n    long[] result\
    \ = new long[xs.length - 1];\n    for (int i = 0; i < result.length; i++)\n  \
    \  {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n    return result;\n}\n\
    long[] integrate(long[] xs) \n{\n    long[] result = new long[xs.length + 1];\n\
    \    for (int i = 0; i < xs.length; i++)\n    {\n        result[i + 1] = xs[i]\
    \ / (i + 1);\n    }\n    return result;\n}\nlong[] differentiate(long[] xs) \n\
    {\n    long[] result = new long[xs.length - 1];\n    for (int i = 0; i < result.length;\
    \ i++)\n    {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n    return result;\n\
    }\nlong[] integrate(long[] xs) \n{\n    long[] result = new long[xs.length + 1];\n\
    \    for (int i = 0; i < xs.length; i++)\n    {\n        result[i + 1] = xs[i]\
    \ / (i + 1);\n    }\n    return result;\n}\nlong[] differentiate(long[] xs) \n\
    {\n    long[] result = new long[xs.length - 1];\n    for (int i = 0; i < result.length;\
    \ i++)\n    {\n        result[", "    in (xs.length > 0)\n    out (result.length\
    \ == xs.length - 1)\n    body \n{\n\tuint[] result = new uint[];\n\tuint i = 1;\n\
    \tforeach (x; xs[1 .. $])\n\t{\n\t\tresult ~= x * i;\n\t\ti++;\n\t}\n\treturn\
    \ result;\n}", "{\n    assert (xs.length > 0);\n    static struct Poly {\n   \
    \     long[] xs;\n        Poly opSlice(size_t start, size_t end) {\n         \
    \   return Poly(xs[start .. end]);\n        }\n        Poly opSlice(size_t start)\
    \ {\n            return Poly(xs[start .. $]);\n        }\n        Poly opSlice()\
    \ {\n            return Poly(xs[1 .. $]);\n        }\n        Poly opSlice(size_t\
    \ start, size_t end, int step) {\n            return Poly(xs[start .. end : step]);\n\
    \        }\n        long opIndex(size_t i) {\n            return xs[i];\n    \
    \    }\n        long opIndexAssign(size_t i, long newX) {\n            return\
    \ xs[i] = newX;\n        }\n        long opIndex(size_t i, long v) {\n       \
    \     return xs[i] = v;\n        }\n        size_t opDollar() {\n            return\
    \ xs.length;\n        }\n        Poly opSliceAssign(int start, int end, int step,\
    \ in Poly r) {\n            xs[start .. end : step] = r.xs;\n        }\n     \
    \   Poly opSliceAssign(int start, int end, in Poly r) {\n            xs[start\
    \ .. end] = r.xs;\n        }\n        Poly opSliceAssign(int start, in Poly r)\
    \ {\n            xs[start .. $] = r.xs;\n        }\n        Poly opSliceAssign(in\
    \ Poly r) {\n            xs[1 .. $] = r.xs;\n        }\n        Poly opSliceAssign(int\
    \ start, int end, int step, in long[] r) {\n            xs[start .. end : step]\
    \ = r;\n        }\n        Poly opSliceAssign(int start, int end, in long[] r)\
    \ {\n            xs[start .. end] = r;\n        }\n        Poly opSliceAssign(int\
    \ start, in long[] r) {\n            xs[start .. $] = r;\n        }\n        Poly\
    \ opSliceAssign(", "{\n    long[] ys = new long[xs.length - 1];\n    for (int\
    \ i = 0; i < ys.length; i++)\n        ys[i] = xs[i + 1] * (i + 1);\n    return\
    \ ys;\n}\n/*\n    Given three points on a curve, p1, p2, p3, find a polynomial\
    \ of degree <= 2\n    that goes through all three points.  If there is no such\
    \ polynomial, return\n    an empty list.\n    >>> find_quadratic([1L, 2L], [2L,\
    \ 4L], [3L, 8L])\n    [1L, 1L, 1L]\n    >>> find_quadratic([1L, 0L], [2L, 1L],\
    \ [3L, 2L])\n    []\n    >>> find_quadratic([1L, 0L], [2L, 2L], [3L, 3L])\n  \
    \  [0L, 1L, 0L]\n*/\nlong[] find_quadratic(long[] p1, long[] p2, long[] p3) \n\
    {\n    // let p(x) = a*x^2 + b*x + c\n    // Solve for the coefficients a, b,\
    \ c:\n    // p1: a*x1^2 + b*x1 + c = y1\n    // p2: a*x2^2 + b*x2 + c = y2\n \
    \   // p3: a*x3^2 + b*x3 + c = y3\n    //\n    // This gives a system of three\
    \ equations in three unknowns:\n    // x1^2   x1   1    a    y1\n    // x2^2 \
    \  x2   1    b    y2\n    // x3^2   x3   1    c    y3\n    //\n    // Construct\
    \ the augmented matrix, which contains the coefficients of\n    // the equations:\n\
    \    // x1^2   x1   1    a    y1\n    // x2^2   x2   1    b    y2\n    // x3^2\
    \   x3   1    c    y3\n    //\n    // Use", "    return xs[1 .. $] . iota.map!(a\
    \ => a * xs[a]);\n/*\nx represents coefficients of a polynomial.\n   x[0] + x[1]\
    \ * x + x[2] * x^2 + ....\n    Return derivative of this polynomial in the same\
    \ form.\n   >>> derivative([3, 1, 2, 4, 5])\n   [1, 4, 12, 20]\n   >>> derivative([1,\
    \ 2, 3])\n   [2, 6]\n   \n*/\nreal[] derivative(real[] xs) \n    return xs[1 ..\
    \ $] . iota.map!(a => a * xs[a]);\n/*\nx represents coefficients of a polynomial.\n\
    \   x[0] + x[1] * x + x[2] * x^2 + ....\n    Return derivative of this polynomial\
    \ in the same form.\n   >>> derivative([3, 1, 2, 4, 5])\n   [1, 4, 12, 20]\n \
    \  >>> derivative([1, 2, 3])\n   [2, 6]\n   \n*/\ndouble[] derivative(double[]\
    \ xs) \n    return xs[1 .. $] . iota.map!(a => a * xs[a]);\n/*\nsolve([a, b, c],\
    \ r)\n    Solve a quadratic equation a * x^2 + b * x + c = 0\n     and return\
    \ a pair of real numbers for roots\n    in sorted order.\n    If there is only\
    \ one real root, the same number will be repeated twice.\n    >>> solve([1, 0,\
    \ 0], 1)\n    [-0.0, -0.0]\n    >>> solve([1, -3, 2], 1)\n    [2.0, 1.0]\n   \
    \ >>> solve([1, -6, 9], 1)\n    [3.0, 3.0]\n    >>> solve([1, -2, 1], 1)\n   \
    \ [1.0, 1.0]\n    \n*/\nTuple!(real, real) solve(real[] xs, real r) \n    assert(r\
    \ >= 0);\n    real a = xs[0];\n    real", "{\n    \n    immutable n = xs.length\
    \ - 1;\n    return n <= 0 ? new long[0] : (xs[1..$] * iota(n)).array;\n}", "{\n\
    \    auto n = xs.length;\n    if (n < 2)\n    {\n        return new long[0];\n\
    \    }\n    return xs[1 .. $].map!(a => a * cast(long)(n - 1)).array;\n}\n// long[]\
    \ derivative(long[] xs) { return xs[1 .. $].map!(a => a * cast(long)(xs.length\
    \ - 1)).array; }\n/*\n    Return roots of this polynomial.\n     Return empty\
    \ list if no solution exists.\n     Return NaN if root is non-real.\n    \n  \
    \  >>> roots([1L, 1L, -6L, 11L, -6L])\n    [3, -1, -1]\n    >>> roots([4L, -5L,\
    \ 1L])\n    [-0.25]\n    \n*/\ndouble[] roots(long[] xs) \n{\n    auto n = xs.length;\n\
    \    if (n == 0)\n    {\n        return new double[](0);\n    }\n    if (n ==\
    \ 1)\n    {\n        return new double[](0);\n    }\n    if (n == 2)\n    {\n\
    \        return new double[](-xs[0] / xs[1]);\n    }\n    auto ab = n.min(4).iota.map!(i\
    \ => xs[i] / xs[n - 1] / 1.0);\n    auto x = (-ab[0] + sqrt(ab[0] * ab[0] - 4\
    \ * ab[1])) / 2;\n    auto y = (-ab[0] - sqrt(ab[0] * ab[0] - 4 * ab[1])) / 2;\n\
    \    if (ab[2] == 0)\n    {\n        return new double[](x, y);\n    }\n    auto\
    \ xx = solveQuadratic(1, ab[0], -ab[1] - ab[2] / x);\n    auto yy = solveQuadratic(1,\
    \ ab[0], -ab[1] - ab[2] / y);\n    return xx ~ yy;\n}\n// double[] roots(long[]\
    \ xs)", "{\n    long[] res;\n    auto n = xs.length;\n    if (n==0) \n    {\n\
    \        res= long[0];\n    }\n    else\n    {\n        res = new long[n-1];\n\
    \        foreach (i, x; xs[1..n]) \n        {\n            res[i-1] = x * i;\n\
    \        }\n    }\n    return res;\n}\n/*\n    Compute x^n.\n    >>> power(2L,\
    \ 3L)\n    8L\n    >>> power(10L, 0L)\n    1L\n    >>> power(10L, 1L)\n    10L\n\
    */\nlong power(long x, long n) \n{\n    auto res = 1L;\n    auto p = x;\n    while\
    \ (n > 0) \n    {\n        if (n % 2) \n        {\n            res *= p;\n   \
    \     }\n        p *= p;\n        n /= 2;\n    }\n    return res;\n}\n/*\n   \
    \ Evaluate polynomial in xs at x.\n    >>> evaluate([2L, 4L, 5L], 3L)\n    48L\n\
    \    >>> evaluate([1L, 0L, 0L], 10L)\n    1L\n    >>> evaluate([1L, 2L, 3L], 0L)\n\
    \    3L\n*/\nlong evaluate(long[] xs, long x) \n{\n    auto res = 0L;\n    auto\
    \ p = 1L;\n    foreach (i, x; xs) \n    {\n        res += x * p;\n        p *=\
    \ x;\n    }\n    return res;\n}\n/*\n    Compute coefficient of x^n in polynomial\
    \ in xs.\n    >>> coefficient([2L, 4L, 5L], 2L)\n    5L\n    >>> coefficient([2L,\
    \ 4L, 5L], 0L)\n    2L\n    >>> coefficient([1L, 0L, 0L], 10L)\n    0L\n*/\nlong\
    \ coefficient(long[] xs, long n) \n{\n    if (n >= xs.length) \n   ", "    if\
    \ (isEmpty(xs))\n    {\n        return xs;\n    }\n    auto result = [];\n   \
    \ foreach (i, x; xs[1..$])\n    {\n        result ~= x * i;\n    }\n    return\
    \ result;\n}", "{\n    if (xs.length == 0)\n    {\n        return xs;\n    }\n\
    \    auto n = xs.length;\n    long[] result = new long[n - 1];\n    for (size_t\
    \ i = 0; i < n - 1; i++)\n    {\n        result[i] = (i + 1) * xs[i + 1];\n  \
    \  }\n    return result;\n}\n/*\n   xs[0] + xs[1] * x + xs[2] * x^2 + ....\n \
    \  Return the value of this polynomial at x.\n    >>> evaluate([1L, 2L, 3L], 2L)\n\
    \    17L\n*/\nlong evaluate(long[] xs, long x) \n{\n    if (xs.length == 0)\n\
    \    {\n        return 0;\n    }\n    long result = 0;\n    for (size_t i = 0;\
    \ i < xs.length; i++)\n    {\n        result += xs[i] * pow(x, i);\n    }\n  \
    \  return result;\n}\n/*\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return\
    \ n-th derivative of this polynomial in the same form.\n    >>> nthDerivative([3L,\
    \ 1L, 2L, 4L, 5L], 2)\n    [12L, 60L]\n*/\nlong[] nthDerivative(long[] xs, size_t\
    \ n) \n{\n    if (n >= xs.length)\n    {\n        return new long[0];\n    }\n\
    \    else\n    {\n        return derivative(nthDerivative(xs, n + 1));\n    }\n\
    }\n/*\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x +\
    \ xs[2] * x^2 + ....\n    Return integral of this polynomial in the same form.\n\
    \    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 0.6666666666666666L,\
    \ 1.25", "{\n    assert(xs.length > 0);\n    return xs[1 .. xs.length].map!(a\
    \ => a * cast(long)(xs.length - 1));\n}", "{\n  long[] result;\n  int i = 1;\n\
    \  while(i < xs.length) \n  {\n    xs[i - 1] = i * xs[i];\n    i += 1;\n  }\n\
    \  xs.length -= 1;\n  return xs;\n}", "{\n    long[] result = new long[xs.length\
    \ - 1];\n    int n = xs.length;\n    for (int i = 0; i < n - 1; i++)\n    {\n\
    \        result[i] = xs[i] * (n - i - 1);\n    }\n    return result;\n}\n/*\n\
    \    >>> convert([3L, 1L, 2L, 4L, 5L], 2)\n    (1L, 2L, 4L, 5L)\n    >>> convert([3L,\
    \ 1L, 2L, 4L, 5L], 7)\n    (1L, 1L, 3L, 3L, 5L, 2L, 6L)\n    >>> convert([3L,\
    \ 1L, 2L, 4L, 5L], 1)\n    (1L, 0L, 0L, 0L, 0L)\n    >>> convert([3L, 1L, 2L,\
    \ 4L, 5L], 10)\n    (1L, 0L, 1L, 2L, 1L, 1L, 4L, 1L, 5L, 1L)\n*/\nTuple!(long[],\
    \ long[]) convert(long[] xs, long p)\n{\n    long[] result = new long[p];\n  \
    \  int n = xs.length;\n    long[] tmp = new long[n];\n    for (int i = 0; i <\
    \ n; i++)\n    {\n        tmp[i] = xs[i];\n    }\n    for (int i = 0; i < p; i++)\n\
    \    {\n        result[i] = tmp[0];\n        long tmp2 = 0;\n        for (int\
    \ j = 0; j < n - 1; j++)\n        {\n            tmp2 = tmp[j + 1] + i * tmp[j];\n\
    \            tmp[j] = tmp2 % p;\n        }\n    }\n    return tuple(result, tmp);\n\
    }\n// def _horner(xs, p):\n//     s = xs[0]\n//     for x in xs[1:]:\n//     \
    \    s = s * p + x\n//     return s\nlong horner(long[] xs, long p)", "{\n   \
    \ long[] ys = new long[xs.length - 1];\n    for (int i = 0; i < ys.length; i++)\n\
    \    {\n        ys[i] = xs[i + 1] * (i + 1);\n    }\n    return ys;\n}", "{\n\
    \    static long[] derivative(T)(T xs) \n        if (is(T == long[]))\n    {\n\
    \        if (xs.length <= 1)\n        {\n            return new long[0];\n   \
    \     }\n        return xs[1 .. $]\n        .map!(a => a * cast(long)(xs.length\
    \ - 1 - xs[1 .. $].indexOf(a)))\n        .array;\n    }\n    else\n    {\n   \
    \     return derivative(new long[] {cast(long)xs});\n    }\n}\n/*\n  #### Problem:\n\
    \  https://projecteuler.net/problem=66\n    \n  Diophantine equation\n    \n \
    \   Consider quadratic Diophantine equations of the form:\n    x^2 \u2013 Dy^2\
    \ = 1\n    For example, when D=13, the minimal solution in x is 649^2 \u2013 13\xD7\
    180^2 = 1.\n    It can be assumed that there are no solutions in positive integers\
    \ when D is square.\n    By finding minimal solutions in x for D = {2, 3, 5, 6,\
    \ 7}, we obtain the following:\n    3^2 \u2013 2\xD72^2 = 1\n    2^2 \u2013 3\xD7\
    1^2 = 1\n    9^2 \u2013 5\xD74^2 = 1\n    5^2 \u2013 6\xD72^2 = 1\n    8^2 \u2013\
    \ 7\xD73^2 = 1\n    Hence, by considering minimal solutions in x for D \u2264\
    \ 7, the largest x is obtained when D=5.\n    Find the value of D \u2264 1000\
    \ in minimal solutions of x for which the largest value of x is obtained.\n  \
    \  Answer: 661\n*/", "    if (xs.length == 0L) \n        return new long[0L];\n\
    \    else\n        return xs[1L..];\n/*\n  xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return the value of this polynomial\
    \ evaluated at x.\n    >>> evaluate([3L, 1L, 2L, 4L, 5L], 2L)\n    79L\n    \n\
    */\nlong evaluate(long[] xs, long x) \n    if (xs.length == 0L) \n        return\
    \ 0L;\n    else\n        return evaluate(xs[1L..], x) * x + xs[0L];\n/*\n  xs\
    \ represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2\
    \ + ....\n     Return the value of this polynomial evaluated at x.\n    >>> evaluate([3L,\
    \ 1L, 2L, 4L, 5L], 2L)\n    79L\n    \n*/\nlong evaluate(long[] xs, long x) \n\
    \    long n = xs.length;\n    if (n == 0L) \n        return 0L;\n    else\n  \
    \      return evaluate(xs[1L..], x) * x + xs[0L];", "{\n    long[] ret = new long[xs.length\
    \ - 1];\n    for (int i = 0; i < ret.length; i++)\n        ret[i] = xs[i] * (i\
    \ + 1);\n    return ret;\n}", "{\n    return xs[1..$].array;\n}\n/*\n    xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \    Return number of real roots of this polynomial.\n    >>> countRealRoots([1L,\
    \ 2L, 1L])\n    1\n    >>> countRealRoots([2L, 0L, 1L])\n    2\n    >>> countRealRoots([1L,\
    \ -1L, 1L])\n    2\n    >>> countRealRoots([2L, 1L, -4L, 1L])\n    2\n    >>>\
    \ countRealRoots([1L, -4L, 1L])\n    1\n    >>> countRealRoots([1L, 1L, 1L])\n\
    \    0\n    >>> countRealRoots([1L, 1L, 1L, -1L])\n    0\n    >>> countRealRoots([1L,\
    \ 1L, 1L, -1L, 1L])\n    1\n    >>> countRealRoots([1L, 1L, 1L, -1L, 1L, -1L])\n\
    \    2\n    >>> countRealRoots([1L, 1L, 1L, -1L, 1L, -1L, 1L])\n    3\n    >>>\
    \ countRealRoots([1L, 1L, 1L, -1L, 1L, -1L, 1L, -1L])\n    4\n    >>> countRealRoots([1L,\
    \ 1L, 1L, -1L, 1L, -1L, 1L, -1L, 1L])\n    5\n    >>> countRealRoots([1L, 1L,\
    \ 1L, -1L, 1L, -1L, 1L, -1L, 1L, -1L])\n    6\n    >>> countRealRoots([1L, 1L,\
    \ 1L, -1L, 1L, -1L, 1L, -1L, 1L, -1L, 1L])\n    7\n    >>> countRealRoots([1L,\
    \ 1L, 1L, -1L, 1L, -1L,", " {\n    int len(xs.length);\n    long[] ys = new long[len-1];\n\
    \    for (int i = 0; i < len-1; i++) \n    {\n        ys[i] = xs[i+1] * (i+1);\n\
    \    }\n    return ys;\n}", "{\n  if (xs.length == 0) return xs;\n  long[] ys\
    \ = new long[xs.length - 1];\n  long[] ys2 = new long[xs.length - 1];\n  for (int\
    \ i = 0; i < ys.length; i++) {\n    ys[i] = xs[i + 1] * (i + 1);\n  }\n  return\
    \ ys;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] *\
    \ x + xs[2] * x^2 + ....\n     Return integral of this polynomial in the same\
    \ form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 2L, 4L, 5L]\n\
    \    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\nlong[] integral(long[]\
    \ xs) \n{\n  long[] ys = new long[xs.length + 1];\n  for (int i = 0; i < xs.length;\
    \ i++) {\n    ys[i + 1] = xs[i] / (i + 1);\n  }\n  return ys;\n}\n/*\n xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return integral of this polynomial in the same form.\n    >>> integral([3L,\
    \ 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 2L, 4L, 5L]\n    >>> integral([1L, 2L,\
    \ 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\nlong[] integral(long[] xs, long c) \n\
    {\n  long[] ys = new long[xs.length + 1];\n  ys[0] = c;\n  for (int i = 0; i <\
    \ xs.length; i++) {\n    ys[i + 1] = x", "{\n    if (xs.length < 2)\n    {\n \
    \       return new long[0];\n    }\n    return xs[1..$].zip(1L..$).map!((a,b)\
    \ => a * b).array;\n}\n/*\n    >>> evaluate([2L, 3L, 0L, 1L], 10L)\n    926L\n\
    \    >>> evaluate([1L, 2L, 3L], 100L)\n    123000L\n    >>> evaluate([1L, 1L,\
    \ 0L, 1L], 2L)\n    10L\n    >>> evaluate([], 3L)\n    0L\n*/\nlong evaluate(long[]\
    \ xs, long x) \n{\n    return xs.zip(0L..xs.length).map!((a,b) => a * x.pow(b)).sum;\n\
    }\n/*\n    >>> coefficients({1L: 1L, 3L: 2L, 2L: 3L})\n    [1L, 2L, 3L, 0L]\n\
    \    >>> coefficients({})\n    [0L]\n*/\nlong[] coefficients(Map!(long, long)\
    \ xs) \n{\n    long maxK = xs.keys.max;\n    long[] keys = xs.keys.array;\n  \
    \  long[] values = xs.values.array;\n    return iota(maxK + 1).map!(index => keys.indexOf(index).ifElse(values[index],\
    \ 0L)).array;\n}\n/*\n    >>> to_dict([2L, 1L, 1L, 0L])\n    {1L: 1L, 2L: 1L,\
    \ 3L: 2L}\n    >>> to_dict([0L, 0L, 0L])\n    {}\n*/\nMap!(long, long) to_dict(long[]\
    \ xs) \n{\n    return xs.zip(0L..xs.length).filter!(a => a[0] != 0L).map!(a =>\
    \ tuple(a[1], a[0])).toMap;\n}\n/*\n    >>> zeros([1L, 2L, 3L, 4L, 5L])\n    [0L,\
    \ 0L, 0L", "{\n    long[] dxs = new long[xs.length - 1];\n    for (int i = 0;\
    \ i < dxs.length; i++) {\n        dxs[i] = xs[i + 1] * (i + 1);\n    }\n    return\
    \ dxs;\n}", "{\n    auto length = xs.length;\n    if (length == 0) return new\
    \ long[];\n    auto result = new long[length - 1];\n    foreach (i, x; xs) \n\
    \    {\n        if (i == 0) continue;\n        result[i - 1] = x * i;\n    }\n\
    \    return result;\n}\n/*\n Return a string representation of a polynomial.\n\
    \    >>> poly_str([1L, 2L, 3L])\n    'x^2 + 2x + 3'\n    >>> poly_str([0L, 1L,\
    \ 0L, -1L])\n    '-x^3 + x'\n    >>> poly_str([1L, 0L, -1L])\n    '-x^2 + 1'\n\
    \    >>> poly_str([0L, 0L, 0L, 0L, 1L])\n    'x^4'\n    >>> poly_str([1L, 1L,\
    \ 1L])\n    'x^2 + x + 1'\n    >>> poly_str([1L, -1L, 1L])\n    'x^2 - x + 1'\n\
    \    >>> poly_str([1L, -1L, -1L])\n    '-x^2 - x + 1'\n    >>> poly_str([1L, 1L,\
    \ -1L])\n    'x^2 + x - 1'\n    >>> poly_str([1L, -1L, -1L])\n    '-x^2 - x +\
    \ 1'\n    >>> poly_str([0L, 1L, 2L, -1L])\n    '-x^3 + 2x^2 + x'\n    >>> poly_str([0L,\
    \ 0L, 1L, -1L])\n    '-x^3 + x^2'\n    >>> poly_str([0L, 0L, 0L, 1L])\n    'x^3'\n\
    \    >>> poly_str([0L, 1L, -1L])\n    '-x^2 + x'\n    >>> poly_str([1L, -1L])\n\
    \    '-x + 1'\n    >>> poly_str([0L, 1L])\n", "{\n    if ( len(xs) == 0 )\n  \
    \  {\n        return []();\n    }\n    else \n    {\n        return zipWith!((n,\
    \ x) => (n + 1) * x)(xs[1L .. $]);\n    }\n}\n/*\n     Find the position of a\
    \ value in an ordered array.\n    \n     >>> binarySearch([1, 2, 3, 4, 5], 2)\n\
    \     1\n     >>> binarySearch([1, 2, 3, 4, 5], 0)\n     Traceback (most recent\
    \ call last):\n      ...\n     AssertionError\n     >>> binarySearch([1, 2, 3,\
    \ 4, 5], 5)\n     4\n     >>> binarySearch([1, 2, 3, 4, 5], 4.5)\n     3\n   \
    \  >>> binarySearch([1, 2, 3, 4, 5], 6)\n     5\n    \n*/\nlong binarySearch(T)(T[]\
    \ sortedArray, T value) \n    if (isFloatingPoint!T)\n{\n    long pos = lowerBound(sortedArray,\
    \ value);\n    if (pos >= 0 && pos < len(sortedArray) && sortedArray[pos] == value)\n\
    \    {\n        return pos;\n    }\n    else \n    {\n        assert(0);\n   \
    \ }\n}\n/*\n     Find the position of a value in an ordered array.\n    \n   \
    \  >>> binarySearch([1, 2, 3, 4, 5], 2)\n     1\n     >>> binarySearch([1, 2,\
    \ 3, 4, 5], 0)\n     Traceback (most recent call last):\n      ...\n     AssertionError\n\
    \     >>> binarySearch([1, 2, 3, 4, 5], 5)\n     4\n     >>> binarySearch([1,\
    \ 2, 3, 4, 5], 4.5)\n     3\n     >>> binarySearch([1, 2, 3, 4, 5], 6)\n     5\n\
    \    \n*/\nlong binarySearch(T)(T[] sortedArray, T value) \n    if (isIntegral!T)\n\
    {\n    long pos = lowerBound(sortedArray, value);\n    if (pos >= 0 && pos < len(sortedArray)\
    \ && sortedArray[pos]", "{\n    final int n = xs.length - 1;\n    if (n == 0)\
    \ return new long[0];\n    long[] ys = new long[n];\n    for (int i = 0; i < n;\
    \ i++) ys[i] = (i + 1) * xs[i + 1];\n    return ys;\n}", "{\n    immutable n =\
    \ xs.length;\n    immutable x = 1;\n    foreach (immutable i; 1 .. n) \n    {\n\
    \        x *= i;\n        xs[i] *= x;\n    }\n    return xs[1 .. $ - 1];\n}",
  "    if (xs.length == 0) \n        return new long[0];\n    else \n        return\
    \ xs[1L..$].array;", "{\n    return xs[1..$];\n}\n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return coefficients\
    \ of integral of this polynomial in the same form.\n    >>> integral([3L, 1L,\
    \ 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 0.6666666666666666L, 1.25L, 1.6666666666666667L]\n\
    \    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1.0L, 1.5L]\n*/\ndouble[] integral(long[]\
    \ xs) \n{\n    double[] result = new double[$ + 1];\n    foreach (i, x; xs)\n\
    \    {\n        result[i + 1] = (double)x / (i + 1);\n    }\n    return result;\n\
    }\n/*\n Sum of coefficients is value of the function at zero.\n    >>> f([1L,\
    \ 2L, 3L])\n    6L\n*/\nlong f(long[] xs) \n{\n    return reduce!(\"a + b\")(xs);\n\
    }", "    if (xs.length > 0) \n        long[] dxs = new long[xs.length - 1];\n\
    \        foreach (immutable long i, immutable long x; xs) \n            if (i\
    \ > 0) \n                dxs[i - 1] = i * x;\n        return dxs;\n    else \n\
    \        return new long[0];", "{\n    if (xs.length < 2) \n    {\n        return\
    \ [0L];\n    }\n    else \n    {\n        long[] newXs = new long[xs.length -\
    \ 1];\n        foreach (i, x; newXs) \n        {\n            newXs[i] = (i +\
    \ 1) * xs[i + 1];\n        }\n        return newXs;\n    }\n}\n//  Given two polynomials\
    \ f, g in x, return a polynomial g(f(x)).\n//\n//    >>> compose([1L, 2L, 3L],\
    \ [2L, 3L, 4L])\n//    [2L, 9L, 26L, 43L, 24L]\n//\nlong[] compose(long[] f, long[]\
    \ g) \n{\n    long[] fg = [0L];\n    foreach (i, gi; g) \n    {\n        fg ~=\
    \ iterate!(times)(gi, f);\n    }\n    return reduce!(plus)(fg);\n}\n//  Return\
    \ f(x) mod g(x)\n//\n//    >>> reduce([2L, 3L, 4L], [1L, 2L, 1L])\n//    [1L,\
    \ 1L]\n//\nlong[] reduce(long[] f, long[] g) \n{\n    assert(g.length > 0);\n\
    \    long[] r = f[];\n    long[] q = [0L];\n    foreach (i, fi; f) \n    {\n \
    \       auto rk = r.length;\n        q ~= [fi];\n        long[] sk = times(q,\
    \ g);\n        long[] nr = reduce!(minus)(r, sk);\n        if (nr.length == rk)\
    \ \n        {\n            q.pop();\n        }\n        else \n        {\n   \
    \         r = nr;\n        }\n    }\n    return r;\n}\n//  Return the square-free\
    \ part of f(x).\n//\n//    >>> squareFree([1L, 1L, -1L, 1L, -1L, -1L, 1L, -1L,",
  "    if (xs.length == 0)\n    {\n        return [];\n    }\n    else\n    {\n  \
    \      size_t n = xs.length;\n        size_t m = n - 1;\n        size_t i = 0;\n\
    \        long[] ys = new long[m];\n        for (i; i < m; i++)\n        {\n  \
    \          ys[i] = (i + 1) * xs[i + 1];\n        }\n        return ys;\n    }\n\
    \    \n    \n}", "{\n    if (xs.length == 0)\n        return xs;\n    if (xs.length\
    \ == 1)\n        return [];\n    xs.remove(0);\n    long[] ys = [ xs.length, ];\n\
    \    for (size_t i = 0; i < xs.length; i++)\n        ys[i] = (i + 1) * xs[i];\n\
    \    return ys;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ....\n     Return the value of this polynomial at\
    \ x.\n    >>> polynomial([3L, 1L, 2L, 4L, 5L], 5L)\n    849L\n    >>> polynomial([1L,\
    \ 2L, 3L], 5L)\n    76L\n*/\nlong polynomial(long[] xs, long x) \n{\n    long\
    \ y = 0;\n    for (size_t i = 0; i < xs.length; i++)\n        y += xs[i] * pow(x,\
    \ i);\n    return y;\n}\n/*\n Find all the roots of the polynomial in the range\
    \ [xmin, xmax] using\n    the bisection method.\n    xs represent coefficients\
    \ of a polynomial.\n    Return a tuple (List of roots, count of iterations).\n\
    \    Note that this function has a check for if a root is close to the\n    interval\
    \ of the guess.  It does this by checking if the sign of the\n    value of the\
    \ polynomial is the same.\n    >>> roots([1L, 2L, 3L], 1L, 3L)\n    ([2.0], 3)\n\
    \    >>> roots([1L, 2L, 3L], -3L, -1L)\n    ([-2.0], 3)\n    >>> roots([3L, 1L,\
    \ 2L, 4L, 5L], 0L, 4L)\n    ([1.0, 3.0], 3)\n    >>> roots([3L, 1L, 2L, 4L, 5L],\
    \ 0L, 5L)\n    ([1.0", "{\n    if (xs.length == 0) {\n        return new long[0];\n\
    \    }\n    long[] ys = new long[xs.length - 1];\n    for (int i = 0; i < ys.length;\
    \ i++) {\n        ys[i] = xs[i + 1] * (i + 1);\n    }\n    return ys;\n}\n// @exclude",
  "{\n    return zipWith(lmul, range(1L, to!long(xs.length)), xs[1L .. $]);\n}", "{\n\
    \    import std.stdio;\n    xs = xs[1 .. $];\n    return xs.map!((a,i) => a *\
    \ i).array;\n}", "{\n    return xs[1 .. $] . map!((x, i) => (i + 1) * x)();\n\
    }\n \n/*\n  Represent a polynomial using nested sublists.\n  Example: [1, [2,\
    \ 0, 1], [1, 1, 1]]\n    Represents: 1 + 2 * x + (1 + x + x^2)\n*/", "{\n    long[]\
    \ ys = new long[xs.length - 1];\n    for (long i = 0L; i < ys.length; i++)\n \
    \   {\n        ys[i] = xs[i + 1] * (i + 1L);\n    }\n    return ys;\n}\n/*\n xs\
    \ represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2\
    \ + ....\n     Return a function that computes value of this polynomial at x.\n\
    \    >>> polynomial([1L, 2L, 3L])(10L)\n    123L\n    \n*/\nFunction1<long, long>\
    \ polynomial(long[] xs) \n{\n    if (xs.length == 0L)\n    {\n        return (long\
    \ x) => \n        {\n            return 0L;\n        };\n    }\n    else\n   \
    \ {\n        return (long x) => \n        {\n            long sum = 0L;\n    \
    \        long x_i = 1L;\n            for (long i = 0L; i < xs.length; i++)\n \
    \           {\n                sum += xs[i] * x_i;\n                x_i *= x;\n\
    \            }\n            return sum;\n        };\n    }\n}\n/*\n Given two\
    \ lists of coefficients representing polynomials, return\n    a function that\
    \ computes product of these polynomials.\n    >>> poly = product([1L, 2L, 3L],\
    \ [4L, 5L, 6L])\n    >>> poly(1L)\n    32L\n    >>> poly(2L)\n    256L\n    \n\
    */\nFunction1<long, long> product(long[] xs, long[] ys) \n{\n    long[] zs = new\
    \ long[xs.length + ys.length - 1L];\n    for (long i = 0L; i < xs.length; i++)\n\
    \    {\n        for (long j = 0L; j < ys.length; j++)\n        {\n           \
    \ zs[i + j] += xs[i] * ys[j];\n        }\n   ", "{\n    if (xs.length < 2)\n \
    \   {\n        return new long[0];\n    }\n    else\n    {\n        long[] result\
    \ = new long[xs.length - 1];\n        ulong n = 0;\n        foreach (x; xs[1 ..\
    \ $])\n        {\n            result[n] = x * n;\n            n++;\n        }\n\
    \        return result;\n    }\n}\n/*\nReturn coefficients of the quotient polynomial\
    \ when a polynomial is divided by x - c.\n    >>> quotient([1L, 2L, 3L], 1L)\n\
    \    [2L, 3L]\n    >>> quotient([1L, 2L, 3L], -1L)\n    [-2L, 3L]\n    >>> quotient([1L,\
    \ 2L, 3L], 0L)\n    [1L, 2L, 3L]\n    >>> quotient([1L, 2L, 3L], 2L)\n    [1L,\
    \ -1L]\n    >>> quotient([1L, 2L, 3L], 3L)\n    [1L, -5L]\n    >>> quotient([1L,\
    \ 2L, 3L], 4L)\n    [1L, -9L]\n*/\nlong[] quotient(long[] xs, long c) \n{\n  \
    \  if (xs.length < 2)\n    {\n        return new long[0];\n    }\n    else\n \
    \   {\n        long[] result = new long[xs.length - 1];\n        long prev = xs[0];\n\
    \        ulong n = 0;\n        foreach (x; xs[1 .. $])\n        {\n          \
    \  result[n] = x + c * prev;\n            prev = result[n];\n            n++;\n\
    \        }\n        return result;\n    }\n}\n/*\nReturn list of roots of a polynomial.\n\
    \    >>> roots([2L, 1L, 3L])\n    []\n    >>> roots([1L, -1L, 1L])\n    [1L, 1L]\n\
    \    >>> roots([1L, -5L, 6L])\n    [2L, 3L]\n    >>> roots", "{\n   int[] a =\
    \ new int[xs.length - 1];\n   for (int i = 0; i < a.length; i++)\n   {\n     \
    \  a[i] = i + 1;\n   }\n   return zip(xs, a).map!(x => x[0] * x[1]);\n}", "{\n\
    \    long[] ys;\n    size_t ys_len = xs.length - 1;\n    ys = new long[ys_len];\n\
    \    foreach (i, elt; xs)\n    {\n        if (i != 0)\n        {\n           \
    \ ys[i - 1] = elt * cast(long)i;\n        }\n    }\n    return ys;\n}\n/*\n  \
    \ xs represent coefficients of a polynomial.\n   xs[0] + xs[1] * x + xs[2] * x^2\
    \ + ....\n   Return n-th derivative of this polynomial in the same form.\n   \
    \ >>> derivative([3L, 1L, 2L, 4L, 5L], 2)\n    [12L, 24L, 20L]\n    >>> derivative([1L,\
    \ 2L, 3L], 10)\n    []\n    >>> derivative([1L, 2L, 3L], 0)\n    [1L, 2L, 3L]\n\
    \    >>> derivative([1L, 2L, 3L], 1)\n    [2L, 6L]\n*/\nlong[] nthDerivative(long[]\
    \ xs, size_t n) \n{\n    long[] ys;\n    size_t ys_len = xs.length - n;\n    ys\
    \ = new long[ys_len];\n    foreach (i, elt; xs)\n    {\n        if (i >= n)\n\
    \        {\n            ys[i - n] = elt * StirlingNumberFirst(n, i);\n       \
    \ }\n    }\n    return ys;\n}\n/*\n   xs represent coefficients of a polynomial.\n\
    \   xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return the integral of this polynomial\
    \ in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L,\
    \ 0.6666666666666666L, 1.25L, 1.25L]\n*/\nlong[] integral(long[] xs) \n{\n   \
    \ long[] ys", "{\n    long n = xs.length;\n    return n < 2 ? new long[]{} : xs[1..n].map!((x,i)\
    \ => x * (i + 1L));\n}\n/*\n  Return the roots of the polynomial in xs.\n*/\n\
    real[] roots(long[] xs) \n{\n    auto dxs = derivative(xs);\n    int n = dxs.length;\n\
    \    while (n) \n    {\n        real realPart = 0;\n        real imagPart = 0;\n\
    \        real[] zs = complexRoots(dxs);\n        for (real z : zs) \n        {\n\
    \            if (abs(imagPart) <= 1e-6) \n            {\n                realPart\
    \ = z;\n                break;\n            }\n        }\n        xs = polydiv(xs,\
    \ realPart);\n        dxs = derivative(xs);\n        n = dxs.length;\n    }\n\
    \    return xs[0..1].map!((x) => -x / xs[1]);\n}\n/*\n  Return coefficients of\
    \ divisor of poly1 / poly2.\n    >>> polydiv([1L,1L,1L], [-1L,1L])\n    [1L, 0L,\
    \ 1L]\n*/\nlong[] polydiv(long[] poly1, long poly2) \n{\n    return poly1.map!((x)\
    \ => x / poly2).array;\n}\n/*\n  Return coefficients of quotient and remainder\
    \ of poly1 / poly2.\n    >>> polydiv([1L,1L,1L], [1L, -1L])\n    ([1L, 0L], [1L])\n\
    */\ntuple!(long[], long[]) polydiv(long[] poly1, long[] poly2) \n{\n    auto n\
    \ = poly1.length;\n    auto m = poly2.length;\n    long[] quotient = new long[];\n\
    \    for (int i = 0; i < n - m + 1; i++) \n    {\n        if (quotient.length)\
    \ \n        {\n            long v = quotient[i] * poly2[0];\n           ", "{\n\
    \    xs = xs.dup;\n    foreach (i, ref x; xs) \n    {\n        xs[i] *= i;\n \
    \   }\n    xs.popFront;\n    return xs;\n}", "{\n    xs = xs.dup;\n    int count\
    \ = 0;\n    long[] result = new long[xs.length - 1];\n    foreach (index, x; xs)\
    \ \n    {\n        if (count != 0)\n        {\n            result[count - 1] =\
    \ x * count;\n        }\n        count++;\n    }\n    return result;\n}\n/*\n\
    \    Newton's Method to find root of f(x) = 0.\n    >>> newton(lambda x: x **\
    \ 2 - 2, lambda x: 2 * x, 1.5)\n    1.414213562373095\n    >>> newton(lambda x:\
    \ x ** 2 - 2, lambda x: 2 * x, -1.5)\n    -1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x, -1.0)\n    -1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x, -1.1)\n    -1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x, -2.0)\n    -1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x, 10.0)\n    1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x, 2.0)\n    1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x, 3.0)\n    1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x, 4.0)\n    1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x, -4.0)\n    -1.414213562373095\n    >>> newton(lambda\
    \ x: x ** 2 - 2, lambda x: 2 * x,", "{\n    if (xs.length == 0L)\n    {\n    \
    \    return new long[0L];\n    }", "{\n    return xs[1 .. xs.length].zip(0 ..\
    \ (xs.length - 1)).map!(a => a[0] * a[1]).array;\n}\nlong[] solve_polynomial(long[]\
    \ xs) \n{\n    auto ret = new long[][];\n    while (xs.length > 1)\n    {\n  \
    \      xs = xs.copy;\n        auto p = xs.length - 1;\n        if (xs[p] == 0)\n\
    \        {\n            xs.length--;\n            continue;\n        }\n     \
    \   ret ~= [xs[p], -xs[p - 1]];\n        xs = (xs[0 .. p - 1] + derivative(xs)).array;\n\
    \    }\n    return ret.array;\n}\nauto quotient(long[] xs, long[] ys) \n{\n  \
    \  long[] result;\n    while (xs.length >= ys.length)\n    {\n        xs = xs.copy;\n\
    \        auto p = xs.length - ys.length;\n        result ~= xs[$ - 1] / ys[$ -\
    \ 1];\n        xs[$ - 1 .. $] = 0;\n        xs[$ - ys.length .. $ - 1] += result[$\
    \ - 1] * ys;\n    }\n    return result.array;\n}\nlong[] compose(long[] xs, long[]\
    \ ys) \n{\n    long[] result;\n    foreach (i, x; xs)\n    {\n        auto tmp\
    \ = ys.map!(a => a ^ i);\n        result ~= x * tmp.product;\n    }\n    return\
    \ result.array;\n}\nlong[] decompose(long[] xs) \n{\n    long[] xs1, xs2;\n  \
    \  if (xs.length == 1)\n    {\n        return [xs[0]];\n    }\n    if (xs.length\
    \ == 2)\n    {\n        return [xs[0], xs[1]];\n    }\n    else\n    {\n     \
    \   auto p = xs.length / 2;\n        xs1 = xs[0", "{\n    int n = xs.length;\n\
    \    if (n == 0) \n    {\n        return new long[0];\n    }\n    long[] result\
    \ = new long[n - 1];\n    for (int i = 0; i < n - 1; i++) \n    {\n        result[i]\
    \ = (i + 1) * xs[i + 1];\n    }\n    return result;\n}\n/*\n Approximate the integral\
    \ of f, using n_slices slices.\n    This is the Riemann sum.\n    f needs to take\
    \ one argument, which is a number.\n    >>> round(integrate(lambda x: x**2, 0,\
    \ 1, n_slices=100), 2)\n    0.33\n    >>> round(integrate(lambda x: x**2, 0, 1,\
    \ n_slices=1000), 2)\n    0.33\n    >>> round(integrate(lambda x: x**2, 0, 1,\
    \ n_slices=10000), 2)\n    0.33\n    >>> round(integrate(lambda x: x**2, 0, 1,\
    \ n_slices=100000), 2)\n    0.33\n    >>> round(integrate(lambda x: x**2, 0, 1,\
    \ n_slices=1000000), 2)\n    0.33\n    >>> round(integrate(lambda x: x**2, 0,\
    \ 1, n_slices=10000000), 2)\n    0.33\n    >>> round(integrate(lambda x: x**2,\
    \ 0, 1, n_slices=100000000), 2)\n    0.33\n    >>> round(integrate(lambda x: x**2,\
    \ 0, 1, n_slices=1000000000), 2)\n    0.33\n    >>> round(integrate(lambda x:\
    \ x**2, 0, 1, n_slices=10000000000), 2)\n    0.33\n    >>> round(integrate(lambda\
    \ x: x**2, 0, 1, n_slices=100000000000), 2)\n    0.33\n    >>> round(integrate(lambda\
    \ x: x**2, 0, 1, n", "{\n    auto n = xs.length;\n    if (n < 2)\n    {\n    \
    \    return new long[0];\n    }\n    auto new_xs = new long[n - 1];\n    for (auto\
    \ i = 0; i < n - 1; i++)\n    {\n        new_xs[i] = (i + 1) * xs[i + 1];\n  \
    \  }\n    return new_xs;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return value of this polynomial\
    \ at x.\n    >>> value([1L, 1L, 2L, 3L], 2L)\n    17L\n    \n*/\nlong value(long[]\
    \ xs, long x) \n{\n    auto n = xs.length;\n    if (n == 0)\n    {\n        return\
    \ 0L;\n    }\n    long a = xs[n - 1];\n    for (auto i = n - 2; i >= 0; i--)\n\
    \    {\n        a = a * x + xs[i];\n    }\n    return a;\n}\n/*\n xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return integral of this polynomial in the same form.\n    >>> integral([1L,\
    \ 1L, 2L, 3L])\n    [0L, 1L, 1L, 2L, 1L]\n    \n*/\nlong[] integral(long[] xs)\
    \ \n{\n    auto n = xs.length;\n    auto new_xs = new long[n + 1];\n    for (auto\
    \ i = 0; i < n; i++)\n    {\n        new_xs[i + 1] = xs[i] / (i + 1);\n    }\n\
    \    return new_xs;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ....\n     Return value of the integral", "{\n \
    \   return xs[1 .. $].array;\n}\n/*\n    >>> is_zero_polynomial([0L, 0L, 0L, 0L])\n\
    \    True\n    >>> is_zero_polynomial([0L, 0L, 0L, 1L])\n    False\n    >>> is_zero_polynomial([0L,\
    \ 0L, 0L, 0L, 1L])\n    False\n*/", "{\n    return xs[1..$].map!(a => a * cast(ulong)($\
    \ - 1)).array;\n}\n/*\n  Return sum of squares of coefficients of a polynomial.\n\
    \     >>> sum_squares([1L, 3L, 0L, 2L])\n    19L\n    \n*/\nulong sum_squares(long[]\
    \ xs) \n{\n    return xs.map!(a => cast(ulong)(a * a)).sum;\n}\n/*\n  Return reciprocal\
    \ of a polynomial.\n    TODO: Add precondition to make sure that polynomial is\
    \ invertible.\n    >>> reciprocal([1L, 2L, 3L])\n    [1L, -2L, 1L, 0L, -3L]\n\
    \    \n*/\nlong[] reciprocal(long[] xs) \n{\n    long[] result = new long[xs.length\
    \ + 1];\n    result[0] = 1;\n    foreach (immutable i; 0..xs.length) \n    {\n\
    \        foreach (immutable j; 0..i) \n        {\n            result[i - j + 1]\
    \ -= xs[i] * result[j];\n        }\n    }\n    return result;\n}\n/*\n  Return\
    \ polynomial as a string in a pretty format.\n    >>> p = [1L, 2L, 3L]\n    >>>\
    \ print (to_pretty_string(p))\n    1 + 2*x + 3*x^2\n    \n*/\nstring to_pretty_string(long[]\
    \ xs) \n{\n    return xs.map!(a => new string[] { a.to!string, \"\" })\n     \
    \        .map!(a => a.join(\"\")).joiner(\" + \");\n}\n/*\n  Return polynomial\
    \ represented by xs as a string in a pretty format.\n    >>> xs = [1L, 2L, 3L]\n\
    \    >>> print (from_string(to_string(xs)))\n    [1L, 2L, 3L]\n    \n*/\nlong[]\
    \ from_string(string xs) \n{\n    long[] ys = xs.split(\",\").map", "{\n    if\
    \ (len(xs) < 2) \n    {\n        return new long[](1);\n    }", "{\n    return\
    \ xs[0 .. $ - 1].map!(i => (i + 1) * xs[i + 1]);\n}\n/*\n    Return the polynomial\
    \ value at a given point x.\n    >>> evaluate(3, [3L, 1L, 2L, 4L, 5L])\n    144L\n\
    \    >>> evaluate(2, [1L, 2L, 3L])\n    17L\n    >>> evaluate(10, [1L, 2L, 3L])\n\
    \    1331L\n*/\nlong evaluate(long x, long[] xs) \n{\n    return xs.map!(i =>\
    \ i * pow(x, i)).sum;\n}\n/*\n    Return the sum of these two polynomials.\n \
    \   >>> sum_of_polynomials([1L, 2L, 3L], [3L, 1L, 2L, 4L, 5L])\n    [4L, 3L, 5L,\
    \ 4L, 5L]\n*/\nlong[] sum_of_polynomials(long[] lhs, long[] rhs) \n{\n    auto\
    \ r = zip(lhs, rhs).map!(a => a[0] + a[1]);\n    return r.array;\n}\n/*\n    Return\
    \ the product of these two polynomials.\n    >>> product_of_polynomials([1L, 2L,\
    \ 3L], [3L, 1L, 2L, 4L, 5L])\n    [3L, 7L, 16L, 25L, 26L, 17L, 15L]\n*/\nlong[]\
    \ product_of_polynomials(long[] lhs, long[] rhs) \n{\n    auto r = zip(lhs, rhs).map!(a\
    \ => a[0] * a[1]);\n    return r.array;\n}\nlong[] polynomial(long[] xs) {\n \
    \   long[] l = new long[][](xs.length);\n    l[0] = 1;\n    foreach (i; 1 .. xs.length)\n\
    \    {\n        l[i] = l[i - 1] * xs[i - 1];\n    }\n    return l;\n", "{\n  int\
    \ n = xs.length;\n  long[] ys = new long[n-1];\n  for (int i = 1; i < n; i++)\
    \ \n  {\n    ys[i-1] = i * xs[i];\n  }\n  return ys;\n}\n/*\n    Find the roots\
    \ of a polynomial.\n    xs represent coefficients of a polynomial.\n    xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ....\n    Return a set of all real roots (including\
    \ any double roots).\n    >>> roots([2L, 0L, -2L])\n    [-1.0, 1.0]\n    >>> roots([1L,\
    \ 2L, 1L])\n    [-1.0]\n    >>> roots([1L, 0L, -1L])\n    [-1.0, 1.0]\n*/\ndouble[]\
    \ roots(long[] xs) \n{\n  long[] deriv = derivative(xs);\n  double[] roots = roots(deriv);\n\
    \  Set!(double) rs = roots.toSet();\n  foreach (root; rs) \n  {\n    Tuple!(double,\
    \ int) rr = new Tuple!(double, int)(root, 0);\n    while (eval(xs, root) == 0)\
    \ \n    {\n      rr[1]++;\n      root = root + 0.001;\n    }\n    for (int i =\
    \ 0; i < rr[1]; i++) \n    {\n      roots ~= rr[0];\n    }\n  }\n  return roots;\n\
    }", "{\n    int N = xs.length;\n    int deg = N - 1;\n    long[] rs = new long[deg];\n\
    \    foreach (i, x; xs)\n    {\n        if (i != 0)\n        {\n            rs[i\
    \ - 1] = x * i;\n        }\n    }\n    return rs;\n}", "{\n    long[] ys = new\
    \ long[xs.length - 1];\n    for (size_t i = 0; i < ys.length; i += 1) \n    {\n\
    \        ys[i] = (i + 1) * xs[i + 1];\n    }\n    return ys;\n}\n/*\n Return degree\
    \ of a polynomial.\n    Raise exception if polynomial doesn't have any non-zero\
    \ coefficient.\n    >>> degree([3L, 1L, 2L, 4L, 5L])\n    4\n    >>> degree([])\n\
    \    Traceback (most recent call last):\n        ...\n    std.exception.RuntimeError:\
    \ degree of a polynomial cannot be zero\n*/\nsize_t degree(long[] xs) {\n    return\
    \ xs.length - 1;\n}\n/*\n Return value of a polynomial at given x\n    >>> eval_polynomial([3L,\
    \ 1L, 2L, 4L, 5L], 0L)\n    3L\n    >>> eval_polynomial([3L, 1L, 2L, 4L, 5L],\
    \ 1L)\n    15L\n    >>> eval_polynomial([3L, 1L, 2L, 4L, 5L], 2L)\n    50L\n*/\n\
    long eval_polynomial(long[] xs, long x) {\n    long y = 0L;\n    for (size_t i\
    \ = 0; i < xs.length; i += 1) \n    {\n        y += xs[i] * pow(x, i);\n    }\n\
    \    return y;\n}\n/*\n Return integral of a polynomial in the same form.\n  \
    \  >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 1L, 1.25L, 1.25L]\n\
    */\nlong[] integral(long[] xs) {\n    long[] ys = new long[xs.length + 1];\n \
    \   for (size_t i = 0; i < xs.length; i += 1) \n    {\n        ys[i + 1] = xs[i]\
    \ / (i +", "{\n    import std.range : iota;\n    return iota(1, xs.length).map!(x\
    \ => xs[x] * x).array;\n}\n// \n// \nlong gcd(long[] xs) \n{\n    if (xs.length\
    \ == 0)\n    {\n        return 0;\n    }\n    return xs.reduce!((a, b) => gcd(a,\
    \ b));\n}\n/*\n xs represents a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2\
    \ + ....\n     Returns the coefficient of x^n.\n    >>> coeff(x**3 + 2*x**2 +\
    \ x, 2)\n    2\n    >>> coeff(x**3 + 2*x**2 + x, 0)\n    1\n    \n*/\nlong coeff(long[]\
    \ xs, long n) \n{\n    if (n < xs.length)\n    {\n        return xs[n];\n    }\n\
    \    return 0;\n}\n/*\n xs represents a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Evaluate at n and return the result.\n    >>> eval_poly([1L,\
    \ 2L, 3L], 1L)\n    6L\n    >>> eval_poly([1L, 2L, 3L], 0L)\n    1L\n    \n*/\n\
    long eval_poly(long[] xs, long n) \n{\n    return xs.map!(x => x * n.pow(xs.indexOf(x))).sum;\n\
    }\n/*\n xs represents a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return the representation of this polynomial in the monomial form.\n   \
    \ >>> monomial_form([3L, 1L, 2L, 4L, 5L])\n    [(1L, 4L), (2L, 3L), (4L, 1L),\
    \ (5L, 0L)]\n    \n*/\nalias Pair", "{\n    long[] result;\n    size_t n = xs.length;\n\
    \    if (n == 0)\n    {\n        result = xs;\n    }\n    else\n    {\n      \
    \  result = new long[n - 1];\n        size_t k = 1;\n        foreach (i; 0 ..\
    \ n - 1)\n        {\n            result[i] = k * xs[i + 1];\n            k++;\n\
    \        }\n    }\n    return result;\n}\n/*\n xs represent coefficients of a\
    \ polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Multiply polynomial\
    \ by x^k.\n    >>> mul_xk([3L, 1L, 2L, 4L, 5L], 2L)\n    [0L, 0L, 3L, 1L, 2L,\
    \ 4L, 5L]\n    >>> mul_xk([3L, 1L, 2L, 4L, 5L], 0L)\n    [3L, 1L, 2L, 4L, 5L]\n\
    \    >>> mul_xk([3L, 1L, 2L, 4L, 5L], 1L)\n    [0L, 3L, 1L, 2L, 4L, 5L]\n    \n\
    */\nlong[] mul_xk(long[] xs, size_t k) \n{\n    size_t n = xs.length;\n    long[]\
    \ result = new long[n + k];\n    foreach (i; 0 .. n)\n    {\n        result[i\
    \ + k] = xs[i];\n    }\n    return result;\n}\n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return this\
    \ polynomial in the form of:\n    (xs[0], xs[1], ...)\n    \n*/\nlong[] poly(long[]\
    \ xs) \n{\n    long[] result = new long[xs.length];\n    foreach (i; 0 .. xs.length)\n\
    \    {\n", "{\n    int n = xs.length;\n    auto ys = new long[](max(0, n - 1));\n\
    \    foreach (i, ref x; xs) \n    {\n        ys[i] = (i + 1) * x;\n    }\n   \
    \ return ys;\n}\n/*\n Return n-th derivation of a polynomial.\n    >>> nderivative([1L,\
    \ 2L, 3L], 0)\n    [1L, 2L, 3L]\n    >>> nderivative([1L, 2L, 3L], 1)\n    [2L,\
    \ 6L]\n    >>> nderivative([1L, 2L, 3L], 2)\n    [6L]\n    >>> nderivative([1L,\
    \ 2L, 3L], 3)\n    []\n    >>> nderivative([1L, 2L, 3L], 4)\n    []\n*/\nlong[]\
    \ nderivative(long[] xs, int n) \n{\n    while (n-- > 0) \n    {\n        xs =\
    \ derivative(xs);\n    }\n    return xs;\n}\n/*\n Returns a valid range for input\
    \ argument.\n    >>> normalize_poly([3L, 1L, 2L, 4L, 5L])\n    (1, 4)\n    >>>\
    \ normalize_poly([3L, 1L, 2L, 4L, 5L, 0L, 0L, 0L])\n    (1, 4)\n    >>> normalize_poly([0L,\
    \ 0L, 0L, 3L, 1L, 2L, 4L, 5L])\n    (3, 7)\n*/", "{\n    //auto xs = xs.dup;\n\
    \    long[] xs = new long[xs.length];\n    System.arraycopy(xs, 0, xs, 0, xs.length);\n\
    \    int n = xs.length;\n    if (n == 0)\n    {\n        return new long[0];\n\
    \    }\n    int p = n - 1;\n    long[] ys = new long[p];\n    for (int i = 0;\
    \ i < p; i++)\n    {\n        ys[i] = xs[i + 1] * (i + 1);\n    }\n    return\
    \ ys;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] *\
    \ x + xs[2] * x^2 + ....\n     Return antiderivative of this polynomial in the\
    \ same form.\n    >>> antiderivative([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 1L, 2L,\
    \ 4L, 5L]\n    >>> antiderivative([1L, 2L, 3L])\n    [0L, 1L, 2L, 3L]\n    \n\
    */\nlong[] antiderivative(long[] xs) \n{\n    //auto xs = xs.dup;\n    long[]\
    \ xs = new long[xs.length];\n    System.arraycopy(xs, 0, xs, 0, xs.length);\n\
    \    int n = xs.length;\n    long[] ys = new long[n + 1];\n    for (int i = 0;\
    \ i < n; i++)\n    {\n        ys[i + 1] = xs[i] / (i + 1);\n    }\n    return\
    \ ys;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] *\
    \ x + xs[2] * x^2 + ....\n     Return integral of this polynomial in the same\
    \ form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 1", "{\n\tauto result\
    \ = new long[];\n\tif (xs.length < 2) \n\t{\n\t\treturn new long[](0L);\n\t}\n\
    \t\n\t\n\tforeach (i, item; xs) \n\t{\n\t\tif (i < 1) continue;\n\t\tresult ~=\
    \ item * i;\n\t}\n\treturn result;\n}\n/*\n Return the polynomial in the form\
    \ of a list of coefficients, \n    given a lambda that represents a polynomial.\n\
    \    >>> p = (lambda x: 4L + 3L * x + 2L * x ** 2 + x ** 3)\n    >>> poly(p)\n\
    \    [4L, 3L, 2L, 1L]\n    >>> p = (lambda x: 5L)\n    >>> poly(p)\n    [5L]\n\
    \    >>> p = (lambda x: 0L)\n    >>> poly(p)\n    [0L]\n    \n*/\nlong[] poly(alias\
    \ f)() \n{\n\tauto result = new long[];\n\t\n\t\n\tforeach (i; 0 .. ) \n\t{\n\t\
    \tauto value = f(i);\n\t\tif (value == 0L) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\
    result ~= value;\n\t}\n\treturn result;\n}\n/*\n Return list of complex roots\
    \ for a polynomial with real coefficients.\n    xs represent coefficients of a\
    \ polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    There can be no\
    \ roots, a single root, two roots (complex conjugates),\n    or any number of\
    \ roots.\n    >>> roots([1L, 0L, -1L])\n    [-0.7071067811865475-0.7071067811865475i,\
    \ 0.7071067811865475+0.7071067811865475i]\n    >>> roots([1L, -3L, 2L])\n    [1.0+0.0i,\
    \ 2.0+0.0i]\n    >>> roots([1L, 0L, 1L])\n    [-1.0+0.0", "{\n    int start =\
    \ 0;\n    for (int i = 0; i < xs.length; i++)\n    {\n        if (xs[i] != 0)\n\
    \        {\n            start = i;\n            break;\n        }\n    }\n   \
    \ auto dy = xs[start .. $];\n    int deg = dy.length - 1;\n    if (deg == 0)\n\
    \    {\n        return [0L];\n    }\n    for (int i = 0; i < deg; i++)\n    {\n\
    \        dy[i] = dy[i + 1] * (i + 1);\n    }\n    dy[deg] = 0;\n    return dy;\n\
    }\n/*\n    Find all complex roots of a univariate polynomial.\n    xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \    n is degree of polynomial.\n     If a root r is exact, it is returned as\
    \ a Real.\n    Otherwise, it is returned as a Complex.\n    >>> roots([1, 2, 3])\n\
    \    [(-0.5+1.0i), (-0.5-1.0i)]\n    \n*/\nauto roots(long[] xs) \n{\n    int\
    \ n = xs.length - 1;\n    auto cs = croots(xs);\n    auto rs = new double[cs.length];\n\
    \    int nr = 0;\n    for (int i = 0; i < cs.length; i++)\n    {\n        auto\
    \ z = cs[i];\n        if (abs(z.re) < 1e-9 && abs(z.im) < 1e-9)\n        {\n \
    \           rs[nr] = z.re;\n            nr++;\n        }\n    }\n    return rs[0\
    \ .. nr];\n}\n/*\n   Return value at x of the polynomial with coefficients xs.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    \n*/\nlong polyval(long[] xs,\
    \ long x) \n{\n    long x0 = 1;\n", "{\n    long[] result = new long[xs.length\
    \ - 1];\n    for (int i = 0; i < result.length; i++)\n        result[i] = xs[i\
    \ + 1] * (i + 1);\n    return result;\n}\n/*\n xs represent coefficients of a\
    \ polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Evaluate this\
    \ polynomial at x=x0.\n    >>> evaluate([1L, 2L, 3L], 2L)\n    17L\n    >>> evaluate([1L,\
    \ 0L, 0L, 1L], 3L)\n    28L\n    \n*/\nlong evaluate(long[] xs, long x0) \n{\n\
    \    long result = 0;\n    long x = 1;\n    for (int i = 0; i < xs.length; i++)\n\
    \    {\n        result += xs[i] * x;\n        x *= x0;\n    }\n    return result;\n\
    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Evaluate this polynomial at x=x0.\n    >>> evaluate([1L,\
    \ 2L, 3L], 2L)\n    17L\n    >>> evaluate([1L, 0L, 0L, 1L], 3L)\n    28L\n   \
    \ \n*/\nlong evaluate(long[] xs, long x0, long mod) \n{\n    long result = 0;\n\
    \    long x = 1;\n    for (int i = 0; i < xs.length; i++)\n    {\n        result\
    \ += xs[i] * x;\n        x *= x0;\n        result %= mod;\n        x %= mod;\n\
    \    }\n    return result;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return a list of roots of this\
    \ polynomial.\n    >>> roots([1L, 2L, 1L", "{\n    size_t i, len;\n    len = xs.length;\n\
    \    long[] rs = new long[];\n    for (i = 1; i < len; i++) \n    {\n        rs\
    \ ~= i * xs[i];\n    }\n    return rs;\n}", "{\n    import std.math;\n    import\
    \ std.typecons;\n    return zip(iota(1L, xs.length), xs).map!((a) => a[0] * a[1]).array;\n\
    }\n/*\n  xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Return antiderivative of this polynomial in the same form.\n\
    \    >>> antiderivative([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 1L, 2L, 4L,\
    \ 5L]\n    >>> antiderivative([2L, 5L, 3L])\n    [0L, 2L, 2.5L, 1L, 3L]\n    \n\
    */\nlong[] antiderivative(long[] xs) \n{\n    import std.math;\n    import std.typecons;\n\
    \    return zip(iota(0L, xs.length + 1L), [0L] ~ xs).map!((a) => a[1] / a[0]).array;\n\
    }\n/*\n Return the x^n where n is the index of the element in xs.\n    >>> powers([1L,\
    \ 2L, 3L, 4L])\n    [1L, 2L, 9L, 64L]\n    \n*/\nlong[] powers(long[] xs) \n{\n\
    \    import std.math;\n    import std.typecons;\n    return xs.map!((a) => pow(a,\
    \ iota(0L, xs.length).array[a])).array;\n}\n/*\n Return an array of the cumulative\
    \ sums of xs.\n    >>> cum_sum([1L, 2L, 3L, 4L])\n    [1L, 3L, 6L, 10L]\n    \n\
    */\nlong[] cum_sum(long[] xs) \n{\n    import std.math;\n    import std.typecons;\n\
    \    return scanl!((a, b) => a + b)(0L, xs).array;\n}\n/*\n Return", "{\n    return\
    \ std.zip(xs, iota(1L, xs.length)).map!(a => a[0] * a[1]).take(xs.length - 1).array;\n\
    }", "{\n    long[] r = new long[xs.length - 1L];\n    for (long i = 0L; i < xs.length\
    \ - 1L; i++)\n    {\n        r[i] = xs[i + 1L] * (i + 1L);\n    }\n    return\
    \ r;\n}\n/*\nReturn the coefficients of the roots of the given polynomial,\n \
    \   as a list of complex numbers.\n    >>> roots([1L, -5L, 9L, -5L, 1L])\n   \
    \ [1L + 0i, 1L + 0i, 1L + 0i, 1L + 0i]\n    >>> roots([1L, 0L, -1L])\n    [-1L\
    \ + 0i, 1L + 0i]\n    \n*/\ncomplex[] roots(long[] xs) \n{\n    long[] newxs =\
    \ new long[xs.length - 1L];\n    for (long i = 0L; i < xs.length - 1L; i++)\n\
    \    {\n        newxs[i] = xs[i + 1L] * (i + 1L);\n    }\n    complex[] r = roots(newxs);\n\
    \    r = r[0L..1L];\n    return r;\n}\n/*\nReturn the coefficients of the roots\
    \ of the given polynomial,\n    as a list of complex numbers.\n    >>> roots([1L,\
    \ -5L, 9L, -5L, 1L])\n    [1L + 0i, 1L + 0i, 1L + 0i, 1L + 0i]\n    >>> roots([1L,\
    \ 0L, -1L])\n    [-1L + 0i, 1L + 0i]\n    \n*/\ncomplex[] roots(long[] xs) \n\
    {\n    if (xs.length == 1L)\n    {\n        return new complex[0L];\n    }\n \
    \   else if (xs.length == 2L)\n    {\n        return new complex[1L];\n    }\n\
    \    else\n    {\n        complex[] rs = roots(xs[0L..1L]);\n        complex[]\
    \ r = new complex[rs.length];\n        for (long i = 0L", "{\n    long[] result\
    \ = new long[xs.length - 1];\n    long[] coeff = new long[xs.length];\n    for\
    \ (int i = 1; i < xs.length; i++)\n        coeff[i] = i * xs[i];\n    for (int\
    \ i = 0; i < result.length; i++)\n        result[i] = coeff[i + 1];\n    return\
    \ result;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1]\
    \ * x + xs[2] * x^2 + ....\n     Return integral of this polynomial in the same\
    \ form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 0.6666666666666666L,\
    \ 0.8L, 1.0L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1.0L, 1.0L]\n    \n\
    */\nTuple!(long[], long) integral(long[] xs) \n{\n    long[] result = new long[xs.length\
    \ + 1];\n    for (int i = 1; i < result.length; i++)\n        result[i] = xs[i\
    \ - 1] / i;\n    return tuple(result, 0);\n}\n/*\n A zero-indexed sequence of\
    \ real numbers.\n    >>> array([3L, 1L, 2L, 4L, 5L])\n    [3L, 1L, 2L, 4L, 5L]\n\
    \    >>> array([])\n    []\n    \n*/\nlong[] array(long[] xs) \n{\n    return\
    \ xs;\n}\n/*\n Find integer root of a polynomial, if it exists.\n    In other\
    \ words, find such x that f(x) = 0.\n    >>> root([1L, 0L, 1L])\n    []\n    >>>\
    \ root([1L, 0L, -1L])\n    [-1L, 1L]\n    >>> root([1L, 2L, 3L])\n    []\n   \
    \ \n*/\nlong[] root(long[] xs", "{\n  long[] result = new long[xs.length - 1];\n\
    \  for (size_t i = 0; i < result.length; i++)\n    result[i] = xs[i + 1] * (i\
    \ + 1);\n  return result;\n}", "{\n  assert(xs.length >= 1U);\n  return xs[1..$].map!((a,\
    \ i) => (i + 1U) * a)();\n}\n/*\nReturn the definite integral of polynomial p.\n\
    \  That is, return q such that d/dx q(x) = p(x).\n  >>> integral([1L, 1L, 1L])\n\
    \  [0L, 1L, 1L, 1L]\n  >>> integral([1L, 1L, 1L, 1L])\n  [0L, 0L, 1L, 1L, 1L,\
    \ 1L]\n  >>> integral([0L, 1L, 2L, 3L])\n  [0L, 0L, 0L, 1L, 2L, 3L]\n  >>> integral([2L,\
    \ 3L, 4L])\n  [0L, 0L, 2L, 3L, 4L]\n*/\nlong[] integral(long[] xs) \n{\n  assert(xs.length\
    \ >= 1U);\n  return xs.map!((a, i) => a / cast(long)(i + 1U))([0L]);\n}\n/*\n\
    Compute the composition of two polynomials.\n  The composition p o q is defined\
    \ as p(q(x)).\n  >>> composition([1L, 1L, 1L], [2L, 3L, 4L])\n  [1L, 4L, 11L,\
    \ 26L, 60L]\n  >>> composition([3L, 2L, 1L], [1L, 1L, 1L])\n  [3L, 7L, 12L, 17L]\n\
    \  >>> composition([1L, 2L, 3L], [2L, 3L, 4L])\n  [2L, 9L, 28L, 75L, 168L]\n \
    \ >>> composition([2L, 1L, 0L], [1L, 1L, 1L])\n  [2L, 3L, 3L]\n*/\nlong[] composition(long[]\
    \ a, long[] b) \n{\n  assert(a.length >= 1U);\n  assert(b.length >= 1U);\n  auto\
    \ result = new long[a.length +", "{\n    long[] ys = new long[xs.length - 1];\n\
    \    foreach (long i, long x; xs.length)\n    {\n        if (i == 0) \n      \
    \  {\n            continue;\n        }\n        ys[i - 1] = i * x;\n    }\n  \
    \  return ys;\n}\n/*\n Given a sequence of rationals (a, b) return all rationals\
    \ that can be formed\n    by dividing a by b and b by a (i.e. by transposing the\
    \ pair).\n    >>> list(transpose_pairs([(3, 4), (5, 6)]))\n    [(3, 4), (4, 3),\
    \ (5, 6), (6, 5)]\n    \n*/\nlong[][] transpose_pairs(long[][] xs) \n{\n    return\
    \ std.algorithm.flatMap!((ref long[] x) => \n    {\n        return [x, [x[1],\
    \ x[0]]];\n    })(xs);\n}\n/*\n Given a sequence of rationals and a precision,\
    \ group the rationals into\n    numerator and denominator pairs such that the\
    \ numerator and denominator\n    are as close as possible to the given precision.\n\
    \    >>> [(x, y) for x, y in group_pairs([(0.25, 1.5), (2.0, 3.0), (10.0, 15.0)],\
    \ 0.1)]\n    [(0.25, 1.5), (2.0, 3.0)]\n    >>> [(x, y) for x, y in group_pairs([(0.25,\
    \ 1.5), (2.0, 3.0), (10.0, 15.0)], 0.5)]\n    [(0.25, 1.5), (2.0, 3.0), (10.0,\
    \ 15.0)]\n    \n*/\nlong[][] group_pairs(long[][] xs, long precision) \n{\n  \
    \  long[][] ys = std.algorithm.map!((ref long[] x) => \n    {\n        return\
    \ [x[0] * precision, x[1] * precision];\n    })(xs", "{\n    return xs[1 .. $].map!((x)\
    \ => x * (xs.length - i - 1))();\n}", "{\n\tint n = xs.length - 1;\n\tlong[] dx\
    \ = new long[n];\n\tfor (int i = 1; i <= n; i++) \n\t{\n\t\tdx[i - 1] = xs[i]\
    \ * i;\n\t}\n\treturn dx;\n}", "{\n    import std.range;\n    return xs[1..].enumerate().map!((i,\
    \ x) => (i + 1) * x).array();\n}", "{\n    size_t N = xs.length;\n    if (N ==\
    \ 0)\n        return new long[0];\n    else\n        return xs[1..$].map!(i =>\
    \ (N - i) * xs[i]);\n}", "{\n\tlong[] result = new long[xs.length - 1];\n\tfor\
    \ (int i = 0; i < result.length; i++)\n\t{\n\t\tresult[i] = (i + 1) * xs[i + 1];\n\
    \t}\n\treturn result;\n}", "{\n    size_t n = len(xs);\n    size_t m = n - 1;\n\
    \    if (m == 0)\n    {\n        return typeof(return)();\n    }\n    long[] ys\
    \ = new long[m];\n    foreach (i, x; zip(iota(m), xs[1 .. $]))\n    {\n      \
    \  ys[i] = (i + 1) * x;\n    }\n    return ys;\n}", "{\n    return xs[1 .. $].array;\n\
    }\n/*\nx0 is the left endpoint of the interval,\n    x1 is the right endpoint\
    \ of the interval.\n    xs represent coefficients of a polynomial.\n    xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ....\n    Return the integral of this polynomial\
    \ in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L], 0L, 2L)\n    [0L,\
    \ 0L, 1L, 4L, 6L, 5L]\n    >>> integral([3L, 1L, 2L, 4L, 5L], -1L, 2L)\n    [0L,\
    \ -1L, 1L, 4L, 6L, 5L]\n    >>> integral([1L, 2L, 3L], 2L, 3L)\n    [16L, 10L,\
    \ 3L]\n    \n*/\nreal[] integral(real[] xs, real x0, real x1) \n{\n    const n\
    \ = xs.length;\n    real[] xs2 = new real[xs.length + 1];\n    for (int i = 0;\
    \ i < n; i++)\n    {\n        xs2[i + 1] = xs[i] / (i + 1);\n    }\n    return\
    \ xs2;\n}\n/*\n    x0 is the left endpoint of the interval,\n    x1 is the right\
    \ endpoint of the interval.\n    xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Assume x0 <= x1.\n    Return\
    \ the area of the surface of this polynomial in the interval [x0, x1].\n    See\
    \ picture below.\n    >>> surface_area([3L, 1L, 2L, 4L, 5L], 0L, 2L)\n    53.78539816339745\n\
    \    >>> surface_area([3L, 1L, 2L, 4L, 5L], -1L, 2L)\n    83.78539816339745\n\
    \    >>> surface", "{\n    xs[$-1L] = 0L;\n    return xs[1L..$];\n}", "{\n   \
    \ assert(!array(xs).empty);\n    return array(xs).dropOne.zip(array(xs).dropOne.map!(a\
    \ => a * a.iota)).map!(a => a[0] * a[1]).array;\n}", "{\n    return xs[0..$-1].zip(iota(1L,xs.length))\n\
    \        .map!((a,b) => a * b)\n        .array;\n}\n/*\n    Return polynomial\
    \ that is the integral of xs with given constant term.\n    xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    integral([1L,\
    \ 2L, 3L], 1L)\n    [1L, 1L, 1L, 1L]\n    \n*/\nlong[] integral(long[] xs, long\
    \ constant) \n{\n    return xs.zip(iota(0L,xs.length))\n        .map!((a,b) =>\
    \ a / b)\n        .array;\n}\n/*\n    Return polynomial that is the integral of\
    \ xs.\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x +\
    \ xs[2] * x^2 + ....\n    integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 1L]\n    \n\
    */\nlong[] integral(long[] xs) \n{\n    return integral(xs, 0L);\n}\n/*\n    Return\
    \ polynomial that is the modulus of xs by another polynomial ys.\n    xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \    ys represent coefficients of another polynomial.\n    ys[0] + ys[1] * x +\
    \ ys[2] * x^2 + ....\n    >>> modulus([1L, 2L, 3L], [1L, 1L])\n    [0L, 1L]\n\
    \    >>> modulus([1L, 2L, 3L, 4L], [1L, 1L])\n    [0L, 1L, 3L]\n    >>> modulus([1L,\
    \ 2L, 3L, 4L, 5L], [1L, 1L])\n    [0", "{\n  auto len_xs = xs.length;\n  if (len_xs\
    \ == 0) \n  {\n    return [];\n  }\n  else \n  {\n    auto new_xs = [0L];\n  \
    \  foreach (i, x; xs[1 .. $]) \n    {\n      new_xs ~= (i + 1) * x;\n    }\n \
    \   return new_xs;\n  }\n}", "{\n    if (xs.length > 1)\n    {\n     //   return\
    \ [xs[i] * i for i in range(1, len(xs))];\n    }\n    return new long[0];\n}\n\
    }", "\t=> xs[1..$].enumerate.map!((a, b) => (a + 1) * b).array;", "    in(xs)\n\
    \    {\n    return xs[0 ..$-1] . map!((x, i) => x * (i + 1L));\n    }\nlong longPolynomialEvaluation(long[]\
    \ xs, long x) \n    in(xs)\n    {\n    return xs . enumerate . map!((a, i) =>\
    \ a.value * pow(x, i)) . reduce!((a, b) => a + b)(0L);\n    }\nlong[] longPolynomialDivision(long[]\
    \ xs, long[] ys) \n    in(xs)\n    in(ys)\n    {\n    if (xs.length < ys.length)\
    \ \n        {\n        return [];\n        }\n    auto quotient = new long[xs.length\
    \ - ys.length + 1];\n    auto remainder = xs.dup;\n    foreach (i; 0 .. quotient.length)\
    \ \n        {\n        quotient[i] = remainder[i] / ys[0];\n        remainder\
    \ = remainder[0 ..$-1] . zip(ys . map!((x) => x * quotient[i])) . map!((a) =>\
    \ a[0] - a[1]);\n        }\n    return quotient;\n    }\nauto longPolynomialMultiplication(long[]\
    \ xs, long[] ys) \n    in(xs)\n    in(ys)\n    {\n    auto a = xs.dup;\n    auto\
    \ b = ys.dup;\n    if (a.length < b.length) \n        {\n        return longPolynomialMultiplication(b,\
    \ a);\n        }\n    return a.enumerate . map!((val, i) => val.value * b) . reduce!((a,\
    \ b) => a . zip(b) . map!((a) => a[0] + a[1]))(b . dup . map!((x) => 0L));\n \
    \   }\n/*\n     xs represent coefficients of a polynomial.\n    xs[0] + xs[1]\
    \ * x + xs[2] * x^2 + ....\n     Return xs evaluated", "{\n    import std.array;\n\
    \    enum int sz = xs.length;\n    long[] res = new long[sz - 1];\n    for (int\
    \ i = 0; i < sz - 1; i++) {\n        res[i] = (i + 1) * xs[i + 1];\n    }\n  \
    \  return res;\n}\n \n \n/*\n    long[][] to represent a matrix of long\n    float[][]\
    \ to represent a matrix of float\n    long[][][] to represent a 3-dimensional\
    \ array of long\n    float[][][][] to represent a 4-dimensional array of float\n\
    \    You can also initialize a multidimensional array at declaration time:\n \
    \   long[][] a = [[1L, 2L], [3L, 4L], [5L, 6L]];\n    float[][] b = [[1.0f, 2.0f],\
    \ [3.0f, 4.0f], [5.0f, 6.0f]];\n    long[][][] c = [[[1L, 2L], [3L, 4L]], [[5L,\
    \ 6L], [7L, 8L]]];\n    float[][][][] d = [[[[1.0f, 2.0f], [3.0f, 4.0f]], [[5.0f,\
    \ 6.0f], [7.0f, 8.0f]]], [[[9.0f, 10.0f], [11.0f, 12.0f]], [[13.0f, 14.0f], [15.0f,\
    \ 16.0f]]]];\n*/\nlong[][] multiplyByNumber(long[][] m, long n) \n{\n    import\
    \ std.array;\n    int sz = m.length;\n    long[][] res = new long[sz][];\n   \
    \ for (int i = 0; i < sz; i++) {\n        long[] tmp = new long[m[i].length];\n\
    \        for (int j = 0; j < m[i].length; j++) {\n            tmp[j] = m[i][j]\
    \ * n;\n        }\n        res[i] =", "{\n    long[][] tmpl = tuple(xs[0..$-1])[0..$-1];\n\
    \    long[] res = new long[tmpl.length];\n    for (int i = 0; i < tmpl.length;\
    \ i++)\n    {\n        res[i] = (i + 1) * tmpl[i][0];\n    }\n    return res;\n\
    }", "{\n    return map!\"a-1\"(xs[1..$]);\n}\n/*\n    xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return value\
    \ of this polynomial at x.\n    >>> evaluate([3L, 1L, 2L, 4L, 5L], 2L)\n    89L\n\
    \    >>> evaluate([3L, 1L, 2L, 4L, 5L], -1L)\n    -4L\n    >>> evaluate([1L, 2L,\
    \ 3L], 5L)\n    28L\n    >>> evaluate([1L, 0L, 0L], 5L)\n    1L\n*/\nlong evaluate(long[]\
    \ xs, long x) \n{\n    //writefln(\"xs:%s x:%s\", xs, x);\n    long[] tmp = xs.dup;\n\
    \    //writefln(\"tmp:%s\", tmp);\n    //writefln(\"map:%s\", map!\"a*b\"(tmp,\
    \ x));\n    //writefln(\"reduce:%s\", reduce!\"a+b\"(map!\"a*b\"(tmp, x)));\n\
    \    return reduce!\"a+b\"(map!\"a*b\"(tmp, x));\n}\n/*\n    xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return the\
    \ value of this polynomial at x by Horner's method.\n    >>> horner([3L, 1L, 2L,\
    \ 4L, 5L], 2L)\n    89L\n    >>> horner([3L, 1L, 2L, 4L, 5L], -1L)\n    -4L\n\
    \    >>> horner([1L, 2L, 3L], 5L)\n    28L\n    >>> horner([1L, 0L, 0L], 5L)\n\
    \    1L\n*/\nlong horner(long[] xs, long x) \n{\n    long[] tmp = xs.dup;\n  \
    \  long tmpx = x;\n    long res = 0", "{\n    long[] res = new long[xs.length\
    \ - 1];\n    foreach (i, x; xs) \n    {\n        if (i > 0) \n        {\n    \
    \        res[i - 1] = i * x;\n        }\n    }\n    return res;\n}\nlong[] add(long[]\
    \ xs, long[] ys) \n{\n    long[] res = new long[max(xs.length, ys.length)];\n\
    \    foreach (i, x; xs) \n    {\n        res[i] += x;\n    }\n    foreach (i,\
    \ y; ys) \n    {\n        res[i] += y;\n    }\n    return res;\n}\nlong[] multiply(long[]\
    \ xs, long[] ys) \n{\n    if (xs.length == 0 || ys.length == 0) \n    {\n    \
    \    return [];\n    }\n    long[] res = new long[xs.length + ys.length - 1];\n\
    \    foreach (i, x; xs) \n    {\n        foreach (j, y; ys) \n        {\n    \
    \        res[i + j] += x * y;\n        }\n    }\n    return res;\n}\nlong[] multiply(long[]\
    \ xs, long y) \n{\n    if (xs.length == 0) \n    {\n        return [];\n    }\n\
    \    long[] res = new long[xs.length];\n    foreach (i, x; xs) \n    {\n     \
    \   res[i] = x * y;\n    }\n    return res;\n}\n// Shifters.\n/*\n    >>> shift([1L,\
    \ 2L, 3L], 2)\n    [1L, 2L, 3L, 0L, 0L]\n    >>> shift([1L, 2L, 3L], -2)\n   \
    \ [0L, 0L, 1L, 2L, 3L]\n*/\nlong[] shift(long[] xs, long d) \n{\n    long[] res\
    \ = new long[xs.length + abs(d)];\n    foreach (i, x; xs) \n   ", "{\n    return\
    \ xs[1 .. $].map!((x) => x * cast(ulong)(xs.length - 1)).array;\n}\n/*\n    Find\
    \ the degree of a polynomial.\n    @param xs coefficients of a polynomial.\n \
    \   \n*/\nulong degree(long[] xs) \n{\n    return xs.length - 1;\n}\n/*\n    Evaluate\
    \ polynomial.\n    @param xs coefficients of a polynomial.\n    @param x   value\
    \ of x at which polynomial is evaluated.\n    \n*/\nlong evaluate(long[] xs, long\
    \ x) \n{\n    long res = 0;\n    foreach (i, coeff; xs) \n    {\n        res +=\
    \ coeff * cast(ulong)(x ^ i);\n    }\n    return res;\n}\n/*\n    Find degree-r\
    \ monic multiple.\n    @param xs coefficients of a polynomial.\n    @param r \
    \  degree of monic multiple.\n    \n*/\nlong[] monicMultiple(long[] xs, ulong\
    \ r) \n{\n    ulong degree = xs.length - 1;\n    if (degree == r) \n    {\n  \
    \      return xs.dup;\n    }\n    if (degree < r) \n    {\n        return repeat(0L,\
    \ r + 1).dup;\n    }\n    long[] res = repeat(0L, r + 1);\n    res[0] = 1;\n \
    \   long mult = -xs[0];\n    res[1] = mult;\n    foreach (i; 2 .. r + 1) \n  \
    \  {\n        res[i] = mult * xs[i - 1];\n    }\n    return res;\n}\n/*\n    Multiply\
    \ two polynomials.\n    >>> multiply([1L, 2L, 3L], [1L, 3L, 5L])\n    [1L, 5L,\
    \ 13L, 15L, 9L]\n    \n*/\nlong[] multiply(long[] xs, long[] ys) \n{\n    ulong\
    \ degree = xs.length + ys.length - 2;\n    long[] res", "{\n    auto ys = new\
    \ long[xs.length - 1];\n    for (size_t i = 0; i < ys.length; i++)\n        ys[i]\
    \ = xs[i + 1] * (i + 1);\n    return ys;\n}\n/*\n xs represent coefficients of\
    \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return the integral\
    \ of this polynomial in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n\
    \    [0L, 3L, 0.5L, 2L, 4L, 5L]\n    >>> integral([2L, 3L, 4L])\n    [0L, 2L,\
    \ 1.5L, 4L]\n    \n*/\nlong[] integral(long[] xs) \n{\n    auto ys = new long[xs.length\
    \ + 1];\n    for (size_t i = 0; i < xs.length; i++)\n        ys[i + 1] = xs[i]\
    \ / cast(double)(i + 1);\n    return ys;\n}\n/*\n xs represent coefficients of\
    \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return the polynomial\
    \ itself evaluated at x.\n    >>> eval_poly([3L, 1L, 2L, 4L, 5L], 2L)\n    54L\n\
    \    >>> eval_poly([1L, 2L, 3L], 4L)\n    57L\n    \n*/\nlong eval_poly(long[]\
    \ xs, long x) \n{\n    long y = 0;\n    for (size_t i = 0; i < xs.length; i++)\n\
    \        y += xs[i] * ipow(x, i);\n    return y;\n}\n/*\n * Generate a random\
    \ polynomial of degree `n`.\n *\n * The polynomial is returned as a list of coefficients,\
    \ with the\n * 0th coefficient being the coefficient of x**0.  (In other words,\n\
    \ * the list", "{\n    long[] ret;\n    long[] ys = new long[xs.length];\n   \
    \ ys[0] = xs[0];\n    ret = new long[xs.length - 1];\n    for (int i = 1; i <\
    \ xs.length; i++)\n    {\n        ys[i] = xs[i] * i;\n        ret[i - 1] = ys[i];\n\
    \    }\n    return ret;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral of this polynomial\
    \ in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L,\
    \ 1L, 4L, 5L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\n\
    long[] integral(long[] xs) \n{\n    long[] ret;\n    long[] ys = new long[xs.length\
    \ + 1];\n    ys[0] = 0;\n    ret = new long[xs.length + 1];\n    for (int i =\
    \ 0; i < xs.length; i++)\n    {\n        ys[i + 1] = xs[i] / (i + 1);\n      \
    \  ret[i + 1] = ys[i + 1];\n    }\n    return ret;\n}\n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral\
    \ of this polynomial in the same form,\n    but with all coefficients multiplied\
    \ by the value at x.\n    >>> integrate([3L, 1L, 2L, 4L, 5L], 2L)\n    [3L, 1L,\
    \ 4L, 8L, 20L, 25L]\n    >>> integrate([1L, 2L, 3L], 2L)\n    [1L, 2L, 6L, 12L]\n\
    \    >>> integrate", "{\n   if (xs.length == 0)\n   {\n      return new long[0];\n\
    \   }\n   return new long[](xs.length - 1)\n   .map!(a => (a+1)*xs[a+1])();\n\
    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Return value of this polynomial evaluated at n.\n    >>>\
    \ polynomial([1L, 1L, 1L, 1L], 2L)\n    9L\n    >>> polynomial([1L, 1L, 1L, 1L],\
    \ 3L)\n    16L\n    \n*/\nlong polynomial(long[] xs, long n) \n{\n    if (xs.length\
    \ == 0)\n    {\n        return 0;\n    }\n    return new long[](xs.length)\n \
    \      .map!(a => xs[a] * pow(n, a))\n       .reduce!((a, b) => a + b)();\n}\n\
    /*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Return terms of this polynomial in the form of `(coefficient,\
    \ exponent)`\n    >>> terms([1L, 2L, 3L, 4L])\n    [(1L, 0L), (2L, 1L), (3L, 2L),\
    \ (4L, 3L)]\n    \n*/\nTuple!(long, long)[] terms(long[] xs) \n{\n    if (xs.length\
    \ == 0)\n    {\n        return new Tuple!(long, long)[](0);\n    }\n    return\
    \ new Tuple!(long, long)[](xs.length)\n       .map!(a => tuple(xs[a], a))();\n\
    }\n/*\n Calculate sum of polynomials.\n    >>> sum_poly([1L, 2L, 3L], [2L, 3L,\
    \ 4L])\n    [3L, 5L, 7L]\n    >>> sum", "{\n    long[] res = new long[$ - 1];\n\
    \    foreach (i, x; xs[1 .. $])\n    {\n        res[i - 1] = i * x;\n    }\n \
    \   return res;\n}", "{\n    int n = xs.length;\n    return xs[n - 1..0].map!((a,i)\
    \ => n - i * a)();\n}\n/*\n  Create strings from a list of values.\n    >>> sel([3L,\
    \ 1L, 2L, 4L, 5L])\n    \"[3, 1, 2, 4, 5]\"\n    \n*/\nstring sel(long[] xs) \n\
    {\n    string s = \"[\";\n    int i = 0;\n    foreach (x; xs) \n    {\n      \
    \  if (i > 0)\n            s ~= \", \";\n        s ~= to!string(x);\n        i\
    \ += 1;\n    }\n    s ~= \"]\";\n    return s;\n}\n/*\n   Given a polynomial,\
    \ find all real roots by finding all intersections\n    with the x-axis. \n  \
    \  >>> roots( [3L, 1L, 2L, 4L, 5L])\n    [-4.44, -0.52, 1.64]\n    \n*/\ndouble[]\
    \ roots(long[] xs) \n{\n    int n = xs.length;\n    auto xss = xs[n - 1..0].map!((a,i)\
    \ => n - i * a)();\n    auto xxs = [ xs ];\n    auto dxs = [ xss ];\n    foreach\
    \ (x; xss) \n    {\n        xxs ~= derivative(xxs[$ - 1]);\n        dxs ~= derivative(dxs[$\
    \ - 1]);\n    }\n    xxs = xxs[1..$];\n    dxs = dxs[1..$];\n    auto xr = [];\n\
    \    auto dr = [];\n    foreach (tup; zip(xxs, dxs)) \n    {\n        auto [xx,\
    \ dx] = tup;\n        xr ~= roots(xx);\n        dr ~= roots(dx);\n    }\n    auto\
    \ roots = [];\n    foreach (tup; zip(xr, dr)) \n    {\n        auto [x, d] = tup;\n\
    \        foreach (xi; x) \n        {", "{\n    return [xs[i] * long(i) for (i\
    \ in 1 .. xs.length - 1)];\n}\n \n}", "{\n    \n    long[] res = new long[$ -\
    \ 1];\n    for (size_t i = 1; i < $; i++) \n    {\n        res[i - 1] = xs[i]\
    \ * i;\n    }\n    return res;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return value of this polynomial\
    \ at x\n    >>> value([3L, 1L, 2L, 4L, 5L], 1L)\n    15L\n    >>> value([1L, 2L,\
    \ 3L], 3L)\n    40L\n    >>> value([1L, 2L, 3L], 4L)\n    61L\n    \n*/\nlong\
    \ value(long[] xs, long x) \n{\n    \n    long res = 0L;\n    for (size_t i =\
    \ 0; i < $; i++) \n    {\n        res += xs[i] * pow(x, i);\n    }\n    return\
    \ res;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1]\
    \ * x + xs[2] * x^2 + ....\n     Return integral of this polynomial in the same\
    \ form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 2L, 4L, 5L]\n\
    \    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\ndouble[] integral(long[]\
    \ xs) \n{\n    \n    double[] res = new double[$ + 1];\n    for (size_t i = 0;\
    \ i < $; i++) \n    {\n        res[i + 1] = xs[i] / (i + 1);\n    }\n    return\
    \ res;\n}\n/*\n Return the result of multiplying two polynomials represented by\
    \ their\n    coefficients.\n    >>> multiply([3L, 1L, 2L, 4L, 5L], [1", "{\n \
    \   immutable len = xs.length;\n    long[] res = new long[len-1];\n    for (immutable\
    \ i = 0L; i < len-1; i++)\n        res[i] = (i+1) * xs[i+1];\n    return res;\n\
    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Returns value of this polynomial at given point x.\n    >>>\
    \ polyval([3L, 1L, 2L, 4L, 5L], 10L)\n    32423L\n    >>> polyval([1L, 2L, 3L],\
    \ 100L)\n    1000000601L\n    \n*/\nlong polyval(long[] xs, long x) \n{\n    immutable\
    \ len = xs.length;\n    long res = 0L;\n    for (immutable i = 0L; i < len; i++)\n\
    \        res += xs[i] * pow(x, i);\n    return res;\n}\n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Find number\
    \ of roots in range [a, b] for any polynomial\n    >>> countRoots([3L, 2L, 1L],\
    \ -10L, 10L)\n    1L\n    >>> countRoots([3L, 2L, 1L], -1L, 1L)\n    0L\n    >>>\
    \ countRoots([2L, 1L, 0L], -1L, 1L)\n    2L\n    >>> countRoots([0L, 0L, 1L],\
    \ -1L, 1L)\n    2L\n    >>> countRoots([2L, 1L, 0L], 1L, 1L)\n    0L\n    >>>\
    \ countRoots([2L, 1L, 0L], 0L, 0L)\n    1L\n    >>> countRoots([2L, 1L, 0L], -2L,\
    \ -2L)\n    1L\n    >>> countRoots([2L,", "    {\n    long[] result;\n    result.length\
    \ = xs.length-1;\n    foreach (i,x;xs) \n        if (i>0) \n            result[i-1]\
    \ = x * long(i);\n    return result;\n    }\n/*\n xs represent coefficients of\
    \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative\
    \ of this polynomial in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n\
    \    [0L, 3L, 0.5L, 2L, 4L, 5L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L,\
    \ 1L, 3L]\n*/\nlong[] integral(long[] xs) \n    {\n    long[] result;\n    result.length\
    \ = xs.length+1;\n    foreach (i,x;xs) \n        result[i+1] = x / long(i+1);\n\
    \    return result;\n    }\n/*\n    Sum two polynomials.\n    >>> sum([3L, 1L,\
    \ 2L, 4L, 5L], [1L, 2L, 3L])\n    [4L, 3L, 5L, 4L, 5L]\n*/\nlong[] sum(long[]\
    \ xs, long[] ys) \n    {\n    long[] result;\n    result.length = max(xs.length,\
    \ ys.length);\n    foreach (i,x;xs) \n        result[i] += x;\n    foreach (i,y;ys)\
    \ \n        result[i] += y;\n    return result;\n    }\n/*\n    Multiply two polynomials.\n\
    \    >>> multiply([3L, 1L, 2L, 4L, 5L], [1L, 2L, 3L])\n    [3L, 7L, 17L, 23L,\
    \ 37L, 41L, 25L]\n*/\nlong[] multiply(long[] xs, long[] ys) \n    {\n    long[]\
    \ result;\n", "{\n  if(xs.length == 0)\n  {\n    return xs;\n  }\n  long[] result\
    \ = new long[xs.length - 1];\n  for(int i = 0; i < result.length; i++)\n  {\n\
    \    result[i] = xs[i + 1] * (i + 1);\n  }\n  return result;\n}", "{\n    long[]\
    \ ys = new long[xs.length-1];\n    for (int i = 0; i < ys.length; i++)\n     \
    \   ys[i] = xs[i+1] * (i+1);\n    return ys;\n}\n/*\n  xs represent coefficients\
    \ of a polynomial.\n     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral\
    \ of this polynomial in the same form.\n    \n    >>> integral([3L, 1L, 2L, 4L,\
    \ 5L])\n    [0L, 3L, 0.5L, 0.6666666666666666L, 1.25L, 1.2L]\n    >>> integral([3L,\
    \ 1L, 2L])\n    [0L, 3L, 0.5L, 0.6666666666666666L]\n    \n*/\ndouble[] integral(long[]\
    \ xs) \n{\n    double[] ys = new double[xs.length+1];\n    for (int i = 0; i <\
    \ xs.length; i++)\n        ys[i+1] = xs[i] / (i+1);\n    return ys;\n}\n/*\n xs\
    \ represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2\
    \ + ....\n     Return value of this polynomial for x.\n    >>> evaluate([3L, 1L,\
    \ 2L, 4L, 5L], 0L)\n    3L\n    >>> evaluate([3L, 1L, 2L, 4L, 5L], 1L)\n    15L\n\
    \    >>> evaluate([3L, 1L, 2L, 4L, 5L], 2L)\n    61L\n    >>> evaluate([3L, 1L,\
    \ 2L, 4L, 5L], -1L)\n    -3L\n    \n*/\nlong evaluate(long[] xs, long x) \n{\n\
    \    long y = 0;\n    long pow = 1;\n    for (int i = 0; i < xs.length; i++)\n\
    \    {\n        y += xs[i] *", "{\n    if(empty(xs)) {\n        return [];\n \
    \   }\n    xs = xs[1..$];\n    foreach(i, x; xs) {\n        xs[i] *= i + 1;\n\
    \    }\n    return xs;\n}", "    in \n    {\n        assert(xs.length >= 1);\n\
    \    }\n    body \n    {\n        return xs[1 .. $].zipWith!((a, b) => a * b)(\n\
    \            iota(1L, cast(long)xs.length - 1)\n        );\n    }", "{\n    int\
    \ n = xs.length;\n    if (n == 0) \n    {\n        return xs;\n    }\n    else\
    \ \n    {\n        long[] ys = new long[n - 1];\n        for (int i = 0; i < n\
    \ - 1; i++) \n        {\n            ys[i] = (i + 1) * xs[i + 1];\n        }\n\
    \        return ys;\n    }\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return value of this polynomial\
    \ at x.\n    >>> eval_poly([3L, 1L, 2L, 4L, 5L], 5L)\n    774L\n    >>> eval_poly([1L,\
    \ 2L, 3L], 5L)\n    106L\n    \n*/\nlong eval_poly(long[] xs, long x) \n{\n  \
    \  long y = 0L;\n    long p = 1L;\n    for (int i = 0; i < xs.length; i++) \n\
    \    {\n        y += xs[i] * p;\n        p *= x;\n    }\n    return y;\n}\n/*\n\
    \ xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] *\
    \ x^2 + ....\n     Return value of this polynomial derivative at x.\n    >>> eval_poly_derivative([3L,\
    \ 1L, 2L, 4L, 5L], 5L)\n    278L\n    >>> eval_poly_derivative([1L, 2L, 3L], 5L)\n\
    \    26L\n    \n*/\nlong eval_poly_derivative(long[] xs, long x) \n{\n    long\
    \ y = 0L;\n    long p = 1L;\n    for (int i = 1; i < xs.length; i++) \n    {\n\
    \        y += i * xs[i] * p;\n        p *= x;\n    }\n    return y;\n}\n/*", "{\n\
    \    long[] ys = new long[$ - 1];\n    for (int i = 0; i < $ - 1; i++) \n    {\n\
    \        ys[i] = (i + 1) * xs[i + 1];\n    }\n    return ys;\n}\n/*\n    m[i][j]\
    \ = coefficient of x**i * y**j in (x + y)**n.\n    \n*/\nlong[][] binom_coeff(int\
    \ n) \n{\n    long[][] a = new long[n + 1][n + 1];\n    a[0][0] = 1;\n    for\
    \ (int i = 1; i <= n; i++) \n    {\n        a[i][0] = 1;\n        for (int j =\
    \ 1; j <= i; j++) \n        {\n            a[i][j] = a[i - 1][j - 1] + a[i - 1][j];\n\
    \        }\n    }\n    return a;\n}\n/*\n    Return polynomial:\n    \n    (1\
    \ + x + x**2 + ... + x**n) * (1 + y + y**2 + ... + y**n)\n    \n    >>> poly1([1L,\
    \ 2L, 3L])\n    [1L, 3L, 6L, 7L, 6L, 3L]\n    \n*/\nlong[] poly1(long[] xs) \n\
    {\n    int n = xs.length - 1;\n    long[][] m = binom_coeff(n);\n    long[] ys\
    \ = new long[n * 2 + 1];\n    for (int i = 0; i <= n; i++) \n    {\n        for\
    \ (int j = 0; j <= n; j++) \n        {\n            ys[i + j] += m[i][j] * xs[i]\
    \ * xs[j];\n        }\n    }\n    return ys;\n}\n/*\n    Return polynomial:\n\
    \    \n    (1 + x + x**2 + ... + x**n) * (1 + y + y**2 + ... + y**n)\n    \n \
    \   >>>", "{\n    return xs[1 .. $] * iota(xs.length - 1L);\n}\n/*\n e = x^2 -\
    \ 2\n  f = x^3 - 5\n  >>> factor(e, f)\n  ((x - 1), (x - 1, x - 2))\n  \n*/\n\
    tuple(std.list.List!(std.list.List!(long)), std.list.List!(std.list.List!(long)))\
    \ factor(long[] e, long[] f) \n{\n    long p = e[0L];\n    std.list.List!(std.list.List!(long))\
    \ s = new std.list.List!(std.list.List!(long));\n    std.list.List!(std.list.List!(long))\
    \ t = new std.list.List!(std.list.List!(long));\n    if (e.length == 1L) \n  \
    \  {\n        return (s, t);\n    }\n    while ((p % f[0L]) == 0L) {\n       \
    \ p /= f[0L];\n        t ~= new std.list.List!(long)().dup(1L, f[0L]);\n    }\n\
    \    s ~= new std.list.List!(long)().dup(1L, p);\n    return (s, t);\n}\n/*\n\
    \ e = x^2 - 2\n  f = x^3 - 5\n  >>> gcd(e, f)\n  (1L, x - 1)\n  \n*/\ntuple(long,\
    \ long[]) gcd(long[] e, long[] f) \n{\n    bool w = e.length < f.length;\n   \
    \ long[] p = w ? e : f;\n    long[] q = w ? f : e;\n    long[] r = derivative(p);\n\
    \    long[] s = derivative(q);\n    long[] t = new long[1L + max(r.length, s.length)];\n\
    \    long g = 1L;\n    while ((p[0L] != 0L) && (q[0L] != 0L)) \n    {\n      \
    \  while ((p[0L", "{\n    return xs[1..xs.length].tupleof;\n}\n/*\n xs represents\
    \ coefficients of a polynomial\n     Return the integral of this polynomial in\
    \ the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 0.6666666666666666L,\
    \ 1.25L, 1.25L]\n    \n*/\ndouble[] integral(long[] xs) \n{\n    double[] ret\
    \ = new double[xs.length + 1];\n    double acc = 0.0;\n    foreach (i, l ; xs)\
    \ \n    {\n        acc += (double)l / (i + 1);\n        ret[i + 1] = acc;\n  \
    \  }\n    return ret;\n}\n/*\n xxs represents coefficients of polynomials.\n \
    \    Return coefficients of the quotient and remainder of these polynomials.\n\
    \    >>> divmod([3L, 1L, 2L, 4L, 5L], [1L, 2L, 3L])\n    ([2L, 2L, 5L], [10L])\n\
    \    \n*/\nTuple!(long[], long[]) divmod(long[] xxs, long[] yys) \n{\n    long[]\
    \ xs = xxs.dup;\n    long[] ys = yys.dup;\n    long[] zs = new long[max(xs.length,\
    \ ys.length)];\n    while (xs.length >= ys.length) \n    {\n        long[] z =\
    \ new long[xs.length - ys.length + 1];\n        z[z.length - 1] = xs[xs.length\
    \ - 1] / ys[ys.length - 1];\n        zs[zs.length - z.length] = z[z.length - 1];\n\
    \        long[] w = new long[xs.length];\n        foreach (i, y ; ys) \n     \
    \   {\n            w[i + z.length - 1] = y * z[z.length - 1];\n        }\n   \
    \     xs = (xs - w)[0..xs.length - z.length];\n   ", "{\n    long[] ys = new long[xs.length-1];\n\
    \    size_t i = 0L;\n    while (i < xs.length - 1L) \n    {\n        ys[i] = xs[i\
    \ + 1L] * (i + 1L);\n        i += 1L;\n    }\n    return ys;\n}", "{\n    return\
    \ xs[0..$-1].map!(a => a * long(xs.length - 1));\n}\n/*\n f, g represent polynomials.\n\
    \    Return the quotient and remainder of these polynomials after \n    dividing\
    \ f by g.\n    >>> poly_divmod([3L, 1L, 2L, 4L, 5L], [1L, 2L, 3L])\n    ([5L,\
    \ 5L], [])\n    >>> poly_divmod([1L, 2L, 3L], [1L, 2L, 3L])\n    ([1L], [])\n\
    \    >>> poly_divmod([2L, 3L], [1L, 2L, 3L])\n    ([], [2L, 3L])\n    \n*/\nTuple!(long[],\
    \ long[]) poly_divmod(long[] f, long[] g) \n{\n    if (g.length > f.length)\n\
    \    {\n        return tuple(long[](), f);\n    }\n    long[] xs;\n    int m =\
    \ f.length - g.length;\n    long[] q = f[m..$].map!(a => 0L);\n    long[] r =\
    \ f[0..m].map!(a => a);\n    while (r.length >= g.length)\n    {\n        long\
    \ a = r[$-1] / g[$-1];\n        long[] r_ = r.map!(b => b - a * g[b.length - 1]);\n\
    \        q[$-1] = a;\n        xs = q;\n        q = q[0..$-1].map!(b => b);\n \
    \       r = r_[0..m].map!(b => b);\n        m = r.length - 1;\n    }\n    return\
    \ tuple(xs, r);\n}\n/*\n f, g represent polynomials.\n    Return the quotient\
    \ and remainder of these polynomials after \n    dividing f by g.\n    >>> poly_div([3L,\
    \ 1L, 2L, 4L, 5L], [1L, 2L, 3L])\n    [5L, 5L", "{\n    int n = xs.length;\n \
    \   if (n == 0)\n    {\n        return null;\n    }\n    if (n == 1)\n    {\n\
    \        return new long[]{0L};\n    }\n    return slice(xs, 1, null).map!(int\
    \ x => cast(long)x * (n - 1));\n}", "{\n  long[] ys = new long[xs.length-1];\n\
    \  foreach (int i, long x; xs) \n  {\n    if (i != 0) \n    {\n      ys[i-1] =\
    \ x * cast(long)i;\n    }\n  }\n  return ys;\n}\n \n \n \n/*\n Implements the\
    \ fractional part function.\n*/\nlong frac(long val) \n{\n  return val & 0x0fffffffffffffff;\n\
    }\n \n \n/*\n Implements the integer part function.\n*/\nlong intg(long val) \n\
    {\n  return val >> 60;\n}\n \n \n/*\n \n*/\nlong[] integer_part(long[] xs) \n\
    {\n  long[] ys = new long[xs.length];\n  foreach (int i, long x; xs) \n  {\n \
    \   ys[i] = intg(x);\n  }\n  return ys;\n}\n \n \n/*\n \n*/\nlong[] make_poly(long[]\
    \ ds) \n{\n  long[] ys = new long[ds.length];\n  foreach (int i, long d; ds) \n\
    \  {\n    ys[i] = frac(d * 0x1000000000000000L);\n  }\n  return ys;\n}\n \n \n\
    /*\n \n*/\nlong[] make_poly_normalized(long[] ds) \n{\n  if (ds.length == 0)\n\
    \  {\n    return [0L];\n  }\n  if (ds.length == 1)\n  {\n    return ds;\n  }\n\
    \  long[] ys = new long[ds.length];\n  foreach (int i, long d; ds) \n  {\n   \
    \ ys[i] = frac(d * 0x1000000000000000L);\n  }\n  while (ys[ys.length-1] == 0)\
    \ \n  {\n    ys = ys[0..$-1];\n  }\n  return ys;\n}\n \n \n/*\n ", "{\n    long[]\
    \ ys = new long[xs.length - 1];\n    long i = 1;\n    foreach (long x; xs) {\n\
    \        ys[i - 1] = i * x;\n        i += 1;\n    }\n    return ys;\n}\n/*\n xs\
    \ represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2\
    \ + ....\n     Return the value of this polynomial at x=value.\n    >>> value_of([1L,\
    \ 2L, 3L], 10L)\n    123L\n    >>> value_of([1L, 2L, 3L], 1000L)\n    1002003L\n\
    \    >>> value_of([1L, 2L, 3L], 1000000000000L)\n    12000000000003L\n    \n*/\n\
    long value_of(long[] xs, long value) \n{\n    long[] ys = new long[xs.length];\n\
    \    ys[0] = xs[0];\n    foreach (i, long x; xs) {\n        if (i != 0) {\n  \
    \          ys[i] = ys[i - 1] * value + x;\n        }\n    }\n    return ys[xs.length\
    \ - 1];\n}\n/*\n   Yield all positive integers up to but not including n.\n  \
    \  \n*/", "{\n  long[] res = new long[xs.length - 1L];\n  for (long i = 0L; i\
    \ < res.length; i++) \n  {\n    res[i] = (xs[i + 1L] * (i + 1L));\n  }\n  return\
    \ res;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1]\
    \ * x + xs[2] * x^2 + ....\n     Evaluate this polynomial with specified x.\n\
    \    >>> evaluate([1L, 2L, 3L], 5L)\n    76L\n    \n*/\nlong evaluate(long[] xs,\
    \ long x) \n{\n  long res = 0L;\n  long xp = 1L;\n  for (long xi : xs) \n  {\n\
    \    res += xi * xp;\n    xp *= x;\n  }\n  return res;\n}\n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return a\
    \ new polynomial which is the product of this polynomial\n    and the given polynomial.\n\
    \    >>> multiply([1L, 2L, 3L], [4L, 5L, 6L])\n    [4L, 13L, 28L, 27L, 18L]\n\
    \    \n*/\nlong[] multiply(long[] xs, long[] ys) \n{\n  long[] res = new long[xs.length\
    \ + ys.length - 1L];\n  for (long i = 0L; i < xs.length; i++) \n  {\n    for (long\
    \ j = 0L; j < ys.length; j++) \n    {\n      res[i + j] += xs[i] * ys[j];\n  \
    \  }\n  }\n  return res;\n}\n/*\n Return a new polynomial which is the quotient\
    \ of this polynomial\n    and the given polynomial.\n    >>> divmod([1L, 2L, 3L],\
    \ [2L, 1L])\n    ([1L, 0L], [1", "{\n  auto res = xs[1 .. $].array();\n  foreach\
    \ (i, item; xs[1 .. $])\n  {\n    res[i] *= i + 1;\n  }\n  return res;\n}\n/*\n\
    \    Given n, return a n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n matrix.\n\
    \    >>> A_30 = hypermatrix(30)\n    >>> sum(A_30[0])\n    1L\n    >>> sum(A_30[1])\n\
    \    1L\n    >>> sum(A_30[30 - 1])\n    1L\n    >>> sum(map(sum, A_30))\n    30L\n\
    \    >>> A_30[0][0]\n    0L\n    >>> A_30[1][1]\n    0L\n    >>> A_30[2][2]\n\
    \    0L\n    >>> A_30[30 - 1][30 - 1]\n    0L\n    >>> all(A_30[i][i] == 0 for\
    \ i in xrange(1, 30))\n    True\n    >>> all(A_30[i][j] == 1 for i in xrange(30)\
    \ for j in xrange(30) if i != j)\n    True\n*/\nauto hypermatrix(int n) \n{\n\
    \  return [i => [j => (i == j ? 0 : 1) for j in iota(n)] for i in iota(n)];\n\
    }\n/*\n     The greatest common divisor of a and b.\n    >>> gcd(36, 63)\n   \
    \ 9\n*/\nlong gcd(long a, long b) \n{\n  if (a == 0)\n  {\n    return b;\n  }\n\
    \  if (b == 0)\n  {\n    return a;\n  }\n  while (true)\n  {\n    auto a1 = a\
    \ % b;\n    if (a1 == 0)\n    {\n      return b;\n   ", "{\n    long[] result\
    \ = new long[xs.length - 1];\n    for (int i = 0; i < result.length; i++)\n  \
    \  {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n    return result;\n}",
  "{\n    long[long[]] res = [];\n    int n = size(xs);\n    int i = 0;\n    while\
    \ (i < n - 1) \n    {\n        res.push_back(i * xs[i]);\n        i += 1;\n  \
    \  }\n    return res;\n}\n/*\n xs represent coefficients of a polynomial.\n  \
    \  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return degree of this polynomial.\n\
    \    >>> degree([0L, 1L, 2L, 4L, 5L])\n    4\n    >>> degree([1L, 2L, 3L])\n \
    \   2\n    \n*/\nlong degree(long[] xs) \n{\n    return size(xs) - 1;\n}\n/*\n\
    \ xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] *\
    \ x^2 + ....\n     Return polynomial evaluated at x = a.\n    >>> eval_poly([0L,\
    \ 1L, 2L, 4L, 5L], 3L)\n    98L\n    >>> eval_poly([1L, 2L, 3L], 0L)\n    1L\n\
    \    \n*/\nlong eval_poly(long[] xs, long a) \n{\n    long res = 0L;\n    long\
    \ a_i = 1L;\n    foreach (x; xs) \n    {\n        res += x * a_i;\n        a_i\
    \ *= a;\n    }\n    return res;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return leading coefficient of\
    \ this polynomial.\n    >>> leading_coeff([0L, 1L, 2L, 4L, 5L])\n    5L\n    >>>\
    \ leading_coeff([1L, 2L, 3L])\n    3L\n    \n*/\nlong leading_coeff(long[] xs)\
    \ \n{\n    return xs[$ - 1];\n}\n/*\n xs", "{\n    assert(xs.length != 0);\n \
    \   long[] result = new long[xs.length - 1];\n    for (int i = 0; i < result.length;\
    \ i++)\n    {\n        result[i] = (i + 1) * xs[i + 1];\n    }\n    return result;\n\
    }", "{\n    if(xs.length == 0) return null;\n    long[] ys = new long[xs.length\
    \ - 1];\n    for(uint i = 0; i < ys.length; i++)\n    {\n        ys[i] = xs[i\
    \ + 1] * (i + 1);\n    }\n    return ys;\n}\n/*\n  xs represent coefficients of\
    \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative\
    \ of this polynomial in the same form.\n    >>> derivative([3L, 1L, 2L, 4L, 5L])\n\
    \    [1L, 4L, 12L, 20L]\n    >>> derivative([1L, 2L, 3L])\n    [2L, 6L]\n    \n\
    */\nlong[] derivative(long[] xs) \n{\n    if(xs.length == 0) return null;\n  \
    \  long[] ys = new long[xs.length - 1];\n    for(uint i = 0; i < ys.length; i++)\n\
    \    {\n        ys[i] = xs[i + 1] * (i + 1);\n    }\n    return ys;\n}\n/*\n \
    \ xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] *\
    \ x^2 + ....\n     Return derivative of this polynomial in the same form.\n  \
    \  >>> derivative([3L, 1L, 2L, 4L, 5L])\n    [1L, 4L, 12L, 20L]\n    >>> derivative([1L,\
    \ 2L, 3L])\n    [2L, 6L]\n    \n*/\nlong[] derivative(long[] xs) \n{\n    if(xs.length\
    \ == 0) return null;\n    long[] ys = new long[xs.length - 1];\n    for(uint i\
    \ = 0; i < ys.length; i++)\n    {\n        ys[i] = xs[i + 1] * (i + 1);\n    }\n\
    \    return ys;\n}\n/*\n Return", "{\n    return xs[1 .. $] * iota(xs.length -\
    \ 1);\n}\n//", "{\n    long[] ys = new long[xs.length - 1];\n    long n = 0;\n\
    \    foreach (i, x; xs) \n    {\n        ys[i] = n * x;\n        n += 1;\n   \
    \ }\n    return ys;\n}", "{\n    long[] result = new long[xs.length - 1];\n  \
    \  foreach (i, x; xs)\n    {\n        if (i == 0)\n            continue;\n   \
    \     result[i - 1] = i * x;\n    }\n    return result;\n}\n/*\n xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return integral of this polynomial in the same form.\n    >>> integral([1L,\
    \ 2L, 3L])\n    [0L, 1L, 1L, 1L]\n    >>> integral([1L, 2L, 3L, 4L])\n    [0L,\
    \ 1L, 1L, 1L, 1L]\n    \n*/\nlong[] integral(long[] xs) \n{\n    long[] result\
    \ = new long[xs.length + 1];\n    foreach (i, x; xs)\n    {\n        result[i\
    \ + 1] = x / (i + 1);\n    }\n    return result;\n}\n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return list\
    \ of coefficients of resultant of this polynomial and given polynomial.\n    >>>\
    \ resultant([1L, 2L, 3L], [2L, 1L, 1L])\n    [1L, 1L, 5L, 1L]\n    >>> resultant([1L,\
    \ 2L, 3L, 4L], [2L, 1L, 1L])\n    [1L, 1L, 5L, 1L, 4L]\n    \n*/\nlong[] resultant(long[]\
    \ xs, long[] ys) \n{\n    long[] result = new long[max(xs.length, ys.length)];\n\
    \    foreach (i, x; xs)\n    {\n        result[i] += x;\n    }\n    foreach (i,\
    \ y; ys)\n    {\n        result[i] -= y;\n    }\n    return result;\n}\n/*\n xs\
    \ represent coefficients", "    {\n    immutable n = xs.length;\n    immutable\
    \ result = n == 0 ? () : new long[n - 1];\n    foreach (i, x; xs) \n        result[i]\
    \ = (i + 1) * x;\n    return result;\n    }\n/*\n xs represent coefficients of\
    \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Find roots of\
    \ this polynomial in the complex domain.\n    >>> roots([0, 1])\n    [0]\n   \
    \ >>> roots([0, 0, 0, 1])\n    [0, 0, 0]\n    >>> roots([0, 1, 0, 0, -2])\n  \
    \  [0, 0, 1, -2]\n    >>> roots([0, 0, 1])\n    [0, -1]\n    \n*/\nstd.array.Array!(complex)\
    \ roots(long[] xs) \n    {\n    immutable n = xs.length;\n    static if (n <=\
    \ 1)\n        return n == 0 ? () : tuple(0);\n    else\n        return solve(derivative(xs))~concat(solve(xs));\n\
    \    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n     Find roots of this polynomial in the real domain.\n\
    \    >>> realRoots([0, 1])\n    [0]\n    >>> realRoots([0, 0, 0, 1])\n    [0,\
    \ 0, 0]\n    >>> realRoots([0, 1, 0, 0, -2])\n    [0, 1, -2]\n    >>> realRoots([0,\
    \ 0, 1])\n    [0, -1]\n    \n*/\nlong[] realRoots(long[] xs) \n    {\n    immutable\
    \ n = xs.length;\n    static if (n <= 1)\n        return n == 0 ? () : tuple(0);\n\
    \    else\n        return roots(xs).filter!(isReal);\n    }\n/*\n xs represent\
    \ coefficients of a polyn", "{\n    if (xs.length == 0)\n        return new long[0];\n\
    \    else\n        return [i * xs[i] for (i = 1 .. xs.length)];\n}\nlong[] derivative2(long[]\
    \ xs) \n{\n    if (xs.length == 0)\n        return new long[0];\n    else\n  \
    \      return [reduce!(\"a + b\", xs[1 .. $])];\n}", "{\n    int N = xs.length-1;\n\
    \    return  array(N, (i) => (N-i) * xs[i]);\n}\n/*\n Find a real root using Newton's\
    \ method.\n   \n*/\ndouble findroot(long[] xs, double x0) \n{\n    double x =\
    \ x0;\n    double[] dxs = (map!(a => cast(double)a))(derivative(xs));\n    while(true)\
    \ \n    {\n        double fx = dotProduct(xs, map!(a => pow(x, a))(iota(xs.length)));\n\
    \        double fx_prime = dotProduct(dxs, map!(a => pow(x, a))(iota(dxs.length)));\n\
    \        double x2 = x - fx / fx_prime;\n        if(abs(x2 - x) < 1e-10) \n  \
    \      {\n            return x2;\n        }\n        x = x2;\n    }\n}\n/*\n Find\
    \ a real root using Newton's method, starting from 1.0.\n   \n*/\ndouble findroot2(long[]\
    \ xs) \n{\n    return findroot(xs, 1.0);\n}\nlong[] powers(int N) \n{\n    return\
    \  map!(a => a*a)(iota(N));\n}\nlong[] powers2(int N) \n{\n    return  map!(a\
    \ => a*a*a)(iota(N));\n}\nlong[] powers4(int N) \n{\n    return  map!(a => a*a*a*a)(iota(N));\n\
    }\nlong[] powers5(int N) \n{\n    return  map!(a => a*a*a*a*a)(iota(N));\n}\n\
    long[] powers6(int N) \n{\n    return  map!(a => a*a*a*a*a*a)(iota(N));\n}\nlong[]\
    \ powers10(int N) \n{\n    return  map!(a => a*a*a*a*a*a*a*a*a*a)(iota", "{\n\
    \    return take(xs.length - 1, iota(xs.length - 1).map!(a => xs[a + 1] * (a +\
    \ 1)));\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1]\
    \ * x + xs[2] * x^2 + ....\n     Return integral of this polynomial in the same\
    \ form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 0.6666666666666666L,\
    \ 1.25L, 1.2L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 1L]\n    \n*/\n\
    long[] integral(long[] xs) \n{\n    return [0L].cat(iota(xs.length + 1).map!(a\
    \ => xs[a] / (a + 1)));\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral of this polynomial\
    \ in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L,\
    \ 0.6666666666666666L, 1.25L, 1.2L]\n    >>> integral([1L, 2L, 3L])\n    [0L,\
    \ 1L, 1L, 1L]\n    \n*/\nlong[] integral(long[] xs) \n{\n    return [0L].cat(iota(xs.length\
    \ + 1).map!(a => xs[a] / (a + 1)));\n}\n/*\n Segmented naive factorial.\n    \
    \ >>> factorialsNaive(10, 2)\n    [0L, 1L, 2L, 6L, 24L, 120L, 720L, 5040L, 40320L,\
    \ 362880L, 3628800L]\n     >>> factorialsNaive(10, 3)\n    [0L, 1L, 2L, 6L, 24L",
  "{\n    if(xs.length == 0) return new long[0];\n    long[] res = new long[xs.length\
    \ - 1];\n    for(int i = 0; i < res.length; i++)\n    {\n        res[i] = (i +\
    \ 1) * xs[i + 1];\n    }\n    return res;\n}\n/*\n xs represent coefficients of\
    \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative\
    \ of this polynomial in the same form.\n    >>> derivative([3.0, 1.0, 2.0, 4.0,\
    \ 5.0])\n    [1.0, 4.0, 12.0, 20.0]\n    >>> derivative([1.0, 2.0, 3.0])\n   \
    \ [2.0, 6.0]\n*/\ndouble[] derivative(double[] xs) \n{\n    if(xs.length == 0)\
    \ return new double[0];\n    double[] res = new double[xs.length - 1];\n    for(int\
    \ i = 0; i < res.length; i++)\n    {\n        res[i] = (i + 1) * xs[i + 1];\n\
    \    }\n    return res;\n}\n/*\nBase converter.\nConvert number represented as\
    \ a string in given base to number represented as a string in base `base` (2 <=\
    \ base <= 36). \n    >>> baseConvert(\"E\", 16, 8)\n    '16'\n    >>> baseConvert(\"\
    1010\", 2, 10)\n    '10'\n    >>> baseConvert(\"77\", 8, 16)\n    '4F'\n    >>>\
    \ baseConvert(\"1000000111100101101111\", 2, 16)\n    '87BF3F'\n    >>> baseConvert(\"\
    KQ9L8\", 20, 8)\n    '203723'\n    >>> baseConvert(\"1AeF\", 16, 35)\n    '20F'\n\
    \    >>> baseConvert(\"YmjQNrM7m7mO\", 36, 2)\n    '11011110110101010011011110100110111",
  "{\n    auto result = new long[];\n    foreach (i, x; iota(1, xs.length)) \n   \
    \ {\n        result ~= x * i;\n    }\n    return result;\n}\n/*\n >>> polynomial(2,\
    \ 3, 4)\n    [2L, 3L, 4L]\n    \n*/\nlong[] polynomial(long[] xs...) \n{\n   \
    \ return xs;\n}\n/*\n >>> evalPolynomial(polynomial(2, 3, 4), 1)\n    9L\n   \
    \ >>> evalPolynomial(polynomial(2, 3, 4), 2)\n    20L\n    \n*/\nlong evalPolynomial(long[]\
    \ xs, long x) \n{\n    long sum = 0;\n    foreach (i, x; xs) \n    {\n       \
    \ sum += x * long(pow(float(x), float(i)));\n    }\n    return sum;\n}\n/*\n >>>\
    \ evalHorner(polynomial(2, 3, 4), 1)\n    9L\n    >>> evalHorner(polynomial(2,\
    \ 3, 4), 2)\n    20L\n    \n*/\nlong evalHorner(long[] xs, long x) \n{\n    long\
    \ result = 0;\n    foreach (x; xs) \n    {\n        result = result * x + x;\n\
    \    }\n    return result;\n}\n/*\n Return coefficients of a polynomial that is\
    \ the product of the\n     two given polynomials.\n    >>> multiply(polynomial(1,\
    \ 1), polynomial(1, 1))\n    [1L, 2L, 1L]\n    >>> multiply(polynomial(1, 1),\
    \ polynomial(1, 2, 1))\n    [1L, 3L, 3L, 1L]\n    \n*/\nlong[] multiply(long[]\
    \ xs, long[] ys) \n{\n    long[] result = new long[xs.length + ys.length - 1];\n\
    \    foreach (i, x; xs) \n    {\n        foreach (j, y; ys) \n        {\n    \
    \        result", "{\n    return xs[0..$-1].zip(xs[1..$]).map!(a => a[0] * a[1]).array;\n\
    }", '    xs[0..$-1].zip(1..$).map!(a =&gt; a[0] * a[1]).array;', "{\n    long[]\
    \ ys = new long[xs.length-1];\n    foreach (i, long x; xs)\n        ys[i] = (i+1)\
    \ * x;\n    return ys;\n}\n/*\n     Return the primitive of this polynomial in\
    \ the same form,\n    where the constant of integration is set to 0.\n    >>>\
    \ primitive([1L, 2L, 3L])\n    [0L, 1L, 1L, 1L]\n    >>> primitive([1L, 2L, 3L,\
    \ 4L])\n    [0L, 1L, 1L, 1L, 1L]\n*/\nlong[] primitive(long[] xs) \n{\n    long[]\
    \ ys = new long[xs.length+1];\n    foreach (i, long x; xs)\n        ys[i+1] =\
    \ x / (i+1);\n    return ys;\n}\n//  Return polynomial composed of polynomials\
    \ a and b.\n// >>> compose([1L, 0L, 2L], [1L, 2L, 3L])\n// [1L, 2L, 7L, 12L, 6L]\n\
    long[] compose(long[] a, long[] b) \n{\n    long[] c = new long[a.length + b.length\
    \ - 1];\n    // Iterate over all possible exponents of c.\n    foreach (i; 0 ..\
    \ c.length) \n    {\n        // Iterate over all possible terms in a.\n      \
    \  foreach (j; 0 .. a.length) \n        {\n            // Check that the exponents\
    \ are valid.\n            if (i >= j) \n            {\n                // Now\
    \ we can add in a[j] * b[i-j].\n                c[i] += a[j] * b[i-j];\n     \
    \       }\n        }\n    }\n    return c;\n}\n/*\n     Return the nth term in\
    \ the Taylor expansion of a polynomial.\n    >>> taylor([1L, 2L, 3L], 0L, 0L)\n\
    \    [1L]\n    >>> taylor([1L, 2L, 3L], 1L, 0L", "{\n    return xs[1..$].array;\n\
    }\n/*\n    Given x and m, return the minimal sum for:\n    x^2 + (x+1)^2 + ...\
    \ + (x+m-1)^2\n    >>> get_minimal_sum(1L, 1L)\n    1L\n    >>> get_minimal_sum(2L,\
    \ 3L)\n    19L\n    >>> get_minimal_sum(3L, 1L)\n    10L\n    >>> get_minimal_sum(3L,\
    \ 2L)\n    25L\n    >>> get_minimal_sum(3L, 3L)\n    43L\n    >>> get_minimal_sum(3L,\
    \ 4L)\n    65L\n    >>> get_minimal_sum(3L, 5L)\n    91L\n    >>> get_minimal_sum(3L,\
    \ 6L)\n    121L\n    >>> get_minimal_sum(3L, 7L)\n    155L\n    >>> get_minimal_sum(3L,\
    \ 8L)\n    193L\n    >>> get_minimal_sum(3L, 9L)\n    235L\n    >>> get_minimal_sum(3L,\
    \ 10L)\n    281L\n    >>> get_minimal_sum(4L, 10L)\n    1286L\n    >>> get_minimal_sum(5L,\
    \ 10L)\n    7905L\n    >>> get_minimal_sum(100L, 100L)\n    97231207984003761L\n\
    \    >>> get_minimal_sum(1234567890123456789L, 1234567890123456789L)\n    827171511123835189896195350905L\n\
    */\nlong get_minimal_sum(long x, long m) \n{\n    long[] f = {1L, -2L * x, x *\
    \ x};\n    long[] g = {1L, -(x + m), m * (x + m)};\n    long[] fg = polymul(f,\
    \ g);\n    long[] p = polyadd(fg, {-m * (m +", "{\n    long[] ys = new long[xs.length\
    \ - 1];\n    long acc = 0L;\n    long i = 0L;\n    while ((i < xs.length))\n \
    \   {\n        ys[cast(size_t)i] = acc;\n        acc += xs[cast(size_t)i] * (i\
    \ + 1L);\n        i += 1L;\n    }\n    return ys;\n}", "{\n    int n = xs.length;\n\
    \    long[] dxs = new long[n - 1];\n    for (int i = 1; i < n; i++) \n    {\n\
    \        dxs[i - 1] = xs[i] * cast(long)i;\n    }\n    return dxs;\n}\n/*\n Find\
    \ roots of a polynomial, by Newton's method.\n    >>> roots([3L, 1L, 2L, 4L, 5L])\n\
    \    {0.07333333333333335L, 0.06666666666666667L, 0.06666666666666667L, 0.06000000000000000L}\n\
    \    \n*/\nreal[] roots(long[] xs) \n{\n    int n = xs.length;\n    real tol =\
    \ 0.000001L;\n    real[] rts = new real[n - 1];\n    for (int i = 0; i < n - 1;\
    \ i++) \n    {\n        real rt = 0.0L;\n        while(true) \n        {\n   \
    \         real y = evaluate(xs, rt);\n            real dy = evaluate(derivative(xs),\
    \ rt);\n            real delta = y / dy;\n            if (abs(delta) < tol) \n\
    \            {\n                break;\n            }\n            rt -= delta;\n\
    \        }\n        rts[i] = rt;\n        // No need to compute rts[j] with j\
    \ < i.\n        long[] xs2 = new long[n - i - 1];\n        for (int j = 0; j <\
    \ n - i - 1; j++) \n        {\n            xs2[j] = (xs[j] + xs[j + 1] * rt) /\
    \ (1.0L - rt * rt);\n        }\n        xs = xs2;\n    }\n    return rts;\n}\n\
    /*\n Return the value of a polynomial evaluated at x.\n    >>> evaluate([2L, 3L,\
    \ 1L], 5L)\n    62L\n    \n*/\nlong evaluate(long[] xs, long x) \n{\n    long\
    \ xx = 1L;\n   ", "{\n    return xs[1 .. xs.length].map!((x, i) => (i + 1) * x)();\n\
    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Return antiderivative of this polynomial in the same form.\n\
    \    >>> antiderivative([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 2L, 4L, 5L]\n\
    \    >>> antiderivative([1L, 2L, 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\nlong[]\
    \ antiderivative(long[] xs) \n{\n    return [0L].opSliceRight(xs.map!((x, i) =>\
    \ x / (i + 1)));\n}\n/*\n Return the next term in the sequence.\n    >>> nextTerm(1,\
    \ [3L, 1L, 2L, 4L, 5L])\n    (19, [6L, 4L, 8L, 20L])\n    \n*/\nTuple!(ulong,\
    \ long[]) nextTerm(ulong n, long[] xs) \n{\n    auto ys = xs.map!((x, i) => x\
    \ * n);\n    return tuple(ys[0], ys[1 .. ys.length]);\n}\n/*\n Compute the nth\
    \ term of the Taylor series for the given function.\n    >>> taylorTerm(1, (ulong\
    \ n) => 1)\n    1\n    >>> taylorTerm(2, (ulong n) => 1)\n    0\n    >>> taylorTerm(3,\
    \ (ulong n) => 1)\n    0\n    >>> taylorTerm(4, (ulong n) => 1)\n    0\n    >>>\
    \ taylorTerm(5, (ulong n) => 1)\n    0\n    >>> taylorTerm(2, (ulong n) => cast(long)n)\n\
    \    1\n    >>> taylorTerm(3, (ulong n) => cast(long)n)\n    1", "{\n    assert\
    \ xs.length > 0L;\n    long[] res = new long[xs.length - 1L];\n    foreach (i,\
    \ x; xs) \n    {\n        if (i > 0L)\n        {\n            res[i - 1L] = x\
    \ * i;\n        }\n    }\n    return res;\n}", "{\n  long[] res = new long[xs.length-1];\n\
    \  for (size_t i = 0; i < res.length; i++)\n  {\n    res[i] = (i+1) * xs[i+1];\n\
    \  }\n  return res;\n}\n/*\n   Derivative of the polynomial represented by xs\
    \ / the polynomial represented by ys.\n    >>> derivative_quotient([1L, 1L, 1L],\
    \ [1L, 1L])\n    [0L, 1L]\n    \n*/\nlong[] derivative_quotient(long[] xs, long[]\
    \ ys) \n{\n  long[] qs = derivative(xs);\n  long[] rs = derivative(ys);\n  return\
    \ divide(qs, rs);\n}", "{\n    if (xs.length < 2)\n    {\n        return [0L];\n\
    \    }\n    else\n    {\n        long[] result = new long[xs.length - 1];\n  \
    \      foreach (i, x; xs[1 .. $])\n        {\n            result[i] = (i + 1)\
    \ * x;\n        }\n        return result;\n    }\n}", "{\n    auto ret = new long[]((xs.length\
    \ - 1UL));\n    long multiplier = 1UL;\n    long i = 0UL;\n    for (; i < (xs.length\
    \ - 1UL); i++)\n    {\n        ret[i] = multiplier * xs[(i + 1UL)];\n        multiplier\
    \ += 1UL;\n    }\n    return ret;\n}", "{\n    return xs[1 .. $].map!(a => a *\
    \ cast(int)(xs.length - 1));\n}", "{\n\tsize_t n = xs.length;\n\tsize_t m = n\
    \ - 1;\n\tlong[] ys = new long[m];\n\tforeach (size_t i; 0 .. m)\n\t{\n\t\tys[i]\
    \ = xs[i + 1] * (i + 1);\n\t}\n\treturn ys;\n}\n/*\n Return i-th derivative of\
    \ the polynomial represented by xs.\n    \n    >>> xs = [3L, 1L, 2L, 4L, 5L]\n\
    \    >>> [derivative(xs, i) for i in range(len(xs))]\n    [[3L, 1L, 2L, 4L, 5L],\
    \ [1L, 4L, 12L, 20L], [4L, 24L, 60L], [24L, 120L], [120L]]\n    >>> xs = [1L,\
    \ 2L, 3L]\n    >>> [derivative(xs, i) for i in range(len(xs))]\n    [[1L, 2L,\
    \ 3L], [2L, 6L], [6L]]\n    >>> derivative([0], 0)\n    [0]\n    >>> derivative([1],\
    \ 0)\n    [1]\n    >>> derivative([-1], 0)\n    [-1]\n    >>> derivative([1, 1],\
    \ 0)\n    [1, 1]\n    >>> derivative([-1, 1], 0)\n    [-1, 1]\n    \n*/\nlong[]\
    \ derivative(long[] xs, size_t i) \n{\n\tlong[] ys = xs;\n\tforeach (size_t j;\
    \ 0 .. i)\n\t{\n\t\tys = derivative(ys);\n\t}\n\treturn ys;\n}\n/*\n Return xs[0]\
    \ + xs[1] * x + ...\n    \n    >>> poly([3L, 2L, 5L, 1L, 0L])\n    3L + 2L * x\
    \ + 5L * x^2 + x^3\n    >>> poly([1L, 2L, 0L, 0L, 0L])\n    1L + 2L * x\n    >>>\
    \ poly([1L, 0L", "{\n    long[] ys = new long[xs.length - 1];\n    for (long i\
    \ = 0; i < ys.length; i++)\n        ys[i] = (i + 1) * xs[i + 1];\n    return ys;\n\
    }\n/*\n Given a polynomial in coefficients form, find roots of it.\n    >>> roots([1L,\
    \ 1L, 1L])\n    [-1.0+1.0j, -1.0-1.0j]\n    >>> roots([1L, -2L, 1L])\n    [1.0]\n\
    \    >>> roots([1L, 0L, 0L, 1L])\n    [-1.0j, 1.0j]\n    >>> roots([1L, -7L, 15L,\
    \ -16L, 8L])\n    [-3.2606825553462623, -0.6048997193336551, 1.211532350204819,\
    \ 2.034912595051562]\n    \n*/\nreal[] roots(long[] xs) \n{\n    long[] ys = derivative(xs);\n\
    \    auto zs = roots(ys);\n    real[] rs = new real[xs.length - 1];\n    long\
    \ i = 0;\n    for (real r : zs) \n    {\n        rs[i] = -r;\n        i++;\n \
    \   }\n    i = 0;\n    foreach (ref real r; rs) \n    {\n        real f = evaluate(xs,\
    \ r);\n        // Newtons method\n        long d = 1;\n        while (d != 0 &&\
    \ f != 0) \n        {\n            d = (evaluate(xs, r) / evaluate(ys, r)).to!long;\n\
    \            r -= d;\n            f = evaluate(xs, r);\n        }\n        i++;\n\
    \    }\n    return rs;\n}\n/*\n Given a polynomial in coefficients form, find\
    \ roots of it.\n    >>> roots([1L, 1L, 1L])\n    [-1.0+1.0j, -1.0-1.0j]\n    >>>\
    \ roots([1L, -2L, 1L])\n", "    if (xs.length == 0)\n    {\n        return xs;\n\
    \    }\n    else\n    {\n        long[] result = new long[xs.length - 1];\n  \
    \      int ix = 0;\n        foreach (i, x; xs)\n        {\n            if (i !=\
    \ 0)\n            {\n                result[ix] = x * i;\n                ix +=\
    \ 1;\n            }\n        }\n        return result;\n    }\n}", "{\n    long[]\
    \ res = new long[xs.length-1];\n    for (int i = 1; i < xs.length; i++) \n   \
    \ {\n        res[i-1] = xs[i] * i;\n    }\n    return res;\n}", "{\n    long[]\
    \ tmp = new long[0 .. length(xs) - 1];\n    for (uint i = 0; i < length(xs) -\
    \ 1; i++)\n    {\n        tmp[i] = xs[i + 1] * (i + 1);\n    }\n    return tmp;\n\
    }", "{\n    auto n = xs.length;\n    auto dxs = n > 0 ? new long[n - 1] : new\
    \ long[0];\n    for (long i = 0; i < n - 1; i++) \n    {\n        dxs[i] = xs[i\
    \ + 1] * (i + 1);\n    }\n    return dxs;\n}\n/*\n xs represent coefficients of\
    \ a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral\
    \ of this polynomial in the same form.\n    >>> integral([1L, 2L, 3L])\n    [0L,\
    \ 1L, 1L, 1L]\n    >>> integral([1L, 2L, 3L], 4L)\n    [0L, 1L, 1L, 1L, 4L]\n\
    \    >>> integral([1L, 2L, 3L], 4L, 5L)\n    [0L, 1L, 1L, 1L, 4L, 5L]\n    \n\
    */\nlong[] integral(long[] xs, long? c = null, long? n = null) \n{\n    auto len\
    \ = xs.length;\n    if (n is null) \n    {\n        n = len + 1;\n    }\n    auto\
    \ intx = new long[n];\n    for (long i = 0; i < len; i++) \n    {\n        intx[i]\
    \ = xs[i] / (i + 1);\n    }\n    if (c is null) \n    {\n        intx[len] = 0;\n\
    \    }\n    else \n    {\n        intx[len] = c;\n    }\n    return intx;\n}\n\
    /*\n >>> roots([1L, -2L, 3L])\n [1.0L, 3.0L]\n >>> roots([1L, -4L, 0L, 6L])\n\
    \ [1.7320508075688772L, -1.7320508075688772L, 0.0L]\n    \n*/\ndouble[] roots(long[]\
    \ xs) \n{\n    auto dxs =", "{\n    if (xs.length == 0) \n    {\n        return\
    \ xs;\n    }\n    else\n    {\n        long[] dxs = new long[xs.length - 1];\n\
    \        for (int i = 0; i < dxs.length; i++) \n        {\n            dxs[i]\
    \ = (i + 1) * xs[i + 1];\n        }\n        return dxs;\n    }\n}\n/*\n if xs\
    \ is 0, return 0\n otherwise return 1 / xs\n*/\nlong[] inv(long[] xs) \n{\n  \
    \  if (xs.length == 0) \n    {\n        return xs;\n    }\n    else\n    {\n \
    \       long[] invxs = new long[xs.length];\n        for (int i = 1; i < invxs.length;\
    \ i++) \n        {\n            invxs[i] = - xs[i] / xs[0];\n        }\n     \
    \   invxs[0] = 1 / xs[0];\n        return invxs;\n    }\n}\n/*\n the degree of\
    \ 0 is -1\n*/", "{\n    xs = xs.dup;\n    auto len = xs.length;\n    long[] ys\
    \ = new long[len-1];\n    for (int i = 0; i < len-1; i++)\n    {\n        ys[i]\
    \ = xs[i+1] * (i+1);\n    }\n    return ys;\n}\n/*\n    >>> count_roots([1L, 2L,\
    \ 1L])\n    2\n    >>> count_roots([3L, 0L, 1L])\n    1\n    >>> count_roots([3L,\
    \ -5L, 1L])\n    2\n    >>> count_roots([1L, 0L, -6L, 11L, -6L])\n    3\n    >>>\
    \ count_roots([1L, 0L, 1L, 0L, 1L])\n    0\n    >>> count_roots([4L, 0L, 0L, 0L,\
    \ 0L])\n    0\n    >>> count_roots([1L, 0L, -1L, 0L, 1L])\n    4\n    >>> count_roots([-3L,\
    \ 0L, 0L, 0L, 0L])\n    1\n*/\n// Helper function.\nlong count_sign_changes(long[]\
    \ xs) \n{\n    if (xs.length < 2)\n    {\n        return 0;\n    }\n    long cnt\
    \ = 0;\n    long sign = xs[0] >= 0 ? 1 : -1;\n    foreach (x; xs)\n    {\n   \
    \     if (x * sign < 0)\n        {\n            cnt += 1;\n            sign =\
    \ -sign;\n        }\n    }\n    return cnt;\n}\nlong count_roots(long[] xs) \n\
    {\n    xs = xs.dup;\n    long sign = xs[0] >= 0 ? 1 : -1;\n    xs = xs.map!(x\
    \ => x * sign);\n    long[] ys = new long[xs.length-1];\n    foreach (x; xs)\n\
    \    {\n        xs = xs[1..$];\n        ys = ys[", "{\n    long[] ans = new long[xs.length\
    \ - 1L];\n    long p = 1L;\n    for (long i = 0L; i < xs.length - 1L; i++) {\n\
    \        ans[i] = p * xs[i + 1L];\n        p = p + 1L;\n    }\n    return ans;\n\
    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ....\n     Return integral of this polynomial in the same form.\n  \
    \  >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 2L, 2.0L, 5L]\n    >>>\
    \ integral([1L, 2L, 3L])\n    [0L, 1L, 1.0L, 3L]\n    \n*/\nTuple!(long[], long)\
    \ integral(long[] xs) \n{\n    long[] ans = new long[xs.length + 1L];\n    long\
    \ p = 0L;\n    long c = 0L;\n    foreach (i, x; xs) {\n        ans[i + 1L] = x\
    \ / cast(long)(p + 1L);\n        c = c + x % cast(long)(p + 1L);\n        p =\
    \ p + 1L;\n    }\n    return tuple(ans, c);\n}\n/*\n Return the greatest common\
    \ divisor of integers a and b.\n    >>> gcd(24L, 60L)\n    12L\n    >>> gcd(24L,\
    \ 52L)\n    4L\n    >>> gcd(24L, 24L)\n    24L\n    \n*/\nlong gcd(long a, long\
    \ b) \n{\n    while (b != 0L) {\n        a %= b;\n        long tmp = a;\n    \
    \    a = b;\n        b = tmp;\n    }\n    return a;\n}\n/*\n Return the least\
    \ common multiple of integers a and b.\n    >>> lcm(24L, 60L)\n    120L\n    >>>\
    \ lcm(24L,", "{\n    return xs[0 .. $ - 1] . map!(index => (index + 1) * xs[index\
    \ + 1]);\n}", "{\n    return take(xs.length - 1, tupleof(iota(xs.length - 1)).map!(x\
    \ => xs[x + 1] * (x + 1)));\n}", "{\n    \n    \n     if (xs == null) {\n    \
    \    return xs;\n    }\n    long[] ys = new long[xs.length - 1];\n    for (int\
    \ i = 0; i < ys.length; i++) {\n        ys[i] = (i + 1) * xs[i + 1];\n    }\n\
    \    return ys;\n}", "{\n    return take(xs.length - 1L, map!(\"a * idx\")(iota(xs.length),\
    \ xs));\n}\n/*\n    Return the polynomial sum of xs and ys,\n    in the same form\
    \ as xs and ys.\n    This is not necessarily the canonical form of the polynomial\
    \ sum.\n    >>> polynomial_sum([1L, 2L, 3L], [2L, 3L, 4L])\n    [3L, 5L, 7L]\n\
    \    >>> polynomial_sum([1L, 2L, 3L], [2L, 0L, 0L])\n    [3L, 2L, 3L]\n    >>>\
    \ polynomial_sum([0L, 0L, 0L], [2L, 3L, 4L])\n    [2L, 3L, 4L]\n*/\nlong[] polynomial_sum(long[]\
    \ xs, long[] ys) \n{\n    if (empty(xs)) return ys;\n    if (empty(ys)) return\
    \ xs;\n    if (xs.length < ys.length) return polynomial_sum(ys, xs);\n    size_t\
    \ min_len = min(xs.length, ys.length);\n    return zip!(\"a + b\")(take(min_len,\
    \ xs), take(min_len, ys)) ~ take(xs.length - min_len, xs);\n}\n/*\n    Return\
    \ the polynomial product of xs and ys,\n    in the same form as xs and ys.\n \
    \   This is not necessarily the canonical form of the polynomial product.\n  \
    \  >>> polynomial_product([1L, 2L, 3L], [2L, 3L, 4L])\n    [2L, 7L, 17L, 20L,\
    \ 12L]\n    >>> polynomial_product([1L, 2L, 3L], [2L, 0L, 0L])\n    [2L, 0L, 0L,\
    \ 0L]\n    >>> polynomial_product([0L, 0L, 0L], [2L, 3L, 4L])\n    [0L, 0L, 0",
  "{\n    typeof(xs[0])[] cs = new typeof(xs[0])[$ - 1];\n    foreach (i, x; xs[1..$])\n\
    \    {\n        cs[i] = x * i;\n    }\n    return cs;\n}\n/*\n  Return the sum\
    \ of two polynomials:\n    >>> add([1L, 3L, 5L], [2L, 4L, 6L])\n    [3L, 7L, 11L]\n\
    */\nlong[] add(long[] xs, long[] ys) \n{\n    long[] cs = new long[max(xs.length,\
    \ ys.length)];\n    cs[0] = xs[0] + ys[0];\n    foreach (i; 1..cs.length)\n  \
    \  {\n        cs[i] = ((i - 1) < xs.length ? xs[i] : 0) + ((i - 1) < ys.length\
    \ ? ys[i] : 0);\n    }\n    return cs;\n}\n/*\n Return product of two polynomials:\n\
    \    >>> mult([1L, 3L, 5L], [2L, 4L, 6L])\n    [2L, 10L, 28L, 34L, 30L]\n*/\n\
    long[] mult(long[] xs, long[] ys) \n{\n    long[] cs = new long[xs.length + ys.length\
    \ - 1];\n    foreach (i, x; xs)\n    {\n        foreach (j, y; ys)\n        {\n\
    \            cs[i + j] += x * y;\n        }\n    }\n    return cs;\n}\n/*\n Return\
    \ the composition of two polynomials:\n    >>> compose([1L, 2L, 3L], [4L, 5L])\n\
    \    [4L, 19L, 45L, 73L, 54L]\n*/\nlong[] compose(long[] xs, long[] ys) \n{\n\
    \    long[] cs = new long[xs.length * ys.length];\n    for (long i = 0; i < cs.length;\
    \ i++)\n    {\n        cs[", "{\n    long[] res = new long[xs.length - 1];\n \
    \   for (int i = 0; i < res.length; i++)\n    {\n        res[i] = xs[i + 1] *\
    \ (i + 1);\n    }\n    return res;\n}\nlong[][] nderivative(long[] xs, long n)\
    \ \n{\n    long[][] res = new long[n][];\n    res[0] = xs;\n    for (int i = 1;\
    \ i < n; i++)\n    {\n        res[i] = derivative(res[i - 1]);\n    }\n    return\
    \ res;\n}\nlong[] integral(long[] xs) \n{\n    long[] res = new long[xs.length\
    \ + 1];\n    for (int i = 0; i < xs.length; i++)\n    {\n        res[i + 1] =\
    \ xs[i] / (i + 1);\n    }\n    return res;\n}\nlong[][] nintegral(long[] xs, long\
    \ n) \n{\n    long[][] res = new long[n][];\n    res[0] = xs;\n    for (int i\
    \ = 1; i < n; i++)\n    {\n        res[i] = integral(res[i - 1]);\n    }\n   \
    \ return res;\n}\nlong evaluate(long[] xs, long x) \n{\n    long s = 0;\n    for\
    \ (int i = 0; i < xs.length; i++)\n    {\n        s = s * x + xs[i];\n    }\n\
    \    return s;\n}\nlong[] compose(long[] xs, long[] ys) \n{\n    long[] res =\
    \ new long[xs.length];\n    if (xs.length == 0)\n    {\n        return res;\n\
    \    }\n    res[0] = xs[0];\n    for (int i = 1; i < xs.length; i++)\n    {\n\
    \        long[] tmp = new long[i];\n        for (int j = 0; j < i; j++)\n    \
    \    {\n            tmp[j] = res[j];", "{\n    return xs[1..$].map!(a => a * cast(long)($\
    \ - 1)).array;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ....\n     Return the degree of the polynomial.\n\
    \    >>> degree([3L, 1L, 2L, 4L, 5L])\n    4\n    >>> degree([3L, 1L, 2L, 4L,\
    \ 0L])\n    3\n    >>> degree([0L, 0L, 0L, 0L, 0L])\n    0\n    >>> degree([1L])\n\
    \    0\n    >>> degree([1L, 1L])\n    1\n*/\nlong degree(long[] xs) \n{\n    return\
    \ xs.length - 1 - xs[1..$].takeWhile!(a => a == 0).length;\n}\n/*\n xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return a polynomial that is the integral of this polynomial.\n    >>> integral([3L,\
    \ 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 0.6666666666666666L, 1.0L, 1.25L]\n   \
    \ >>> integral([3L, 1L, 2L, 4L, 0L])\n    [0L, 3L, 0.5L, 0.6666666666666666L,\
    \ 1.0L, 0L]\n    >>> integral([0L, 0L, 0L, 0L, 0L])\n    [0L, 0L, 0L, 0L, 0L,\
    \ 0L]\n    >>> integral([1L])\n    [0L, 1L]\n    >>> integral([1L, 1L])\n    [0L,\
    \ 1L, 0.5L]\n    >>> integral([1L, 0L, 0L, 0L, 0L])\n    [0L, 1L, 0L, 0L, 0L,\
    \ 0L]\n*/\ndouble[] integral(long[] xs)", "    { \n    int n = size(xs);\n   \
    \ if (n == 0)\n        return xs;\n    return [xs[1] * i + 1 : i in 0 .. n - 2];\n\
    \    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n     Return integral of this polynomial in the same form.\n\
    \    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 2L, 4L, 5L]\n    >>>\
    \ integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\nlong[] integral(long[]\
    \ xs) \n    { \n    auto n = size(xs);\n    if (n == 0)\n        return xs;\n\
    \    return [0] ~ [xs[i] / (i + 1) : i in 0 .. n - 1];\n    }\n/*\n xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return the value of this polynomial at x.\n    >>> poly([1L, 2L, 3L], 2L)\n\
    \    17L\n    >>> poly([0L, 1L, 2L, 3L], 2L)\n    23L\n    \n*/\nlong poly(long[]\
    \ xs, long x) \n    { \n    int n = size(xs);\n    if (n == 0)\n        return\
    \ 0;\n    auto val = 0;\n    auto xpow = 1;\n    for (int i = 0; i < n; ++i)\n\
    \        {\n        val += xs[i] * xpow;\n        xpow *= x;\n        }\n    return\
    \ val;\n    }\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1]\
    \ * x + xs[2] * x^2 + ....\n     Return the value of this polynomial at x.\n \
    \   >>>", "{\n    int n = xs.length;\n    if (n <= 1) return new long[0];\n  \
    \  long[] dxs = new long[n - 1];\n    for (int i = 1; i < n; i++)\n    {\n   \
    \     dxs[i - 1] = i * xs[i];\n    }\n    return dxs;\n}\n/*\n xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return antiderivative\
    \ of this polynomial in the same form.\n    >>> antiderivative([1L, 2L, 3L])\n\
    \    [0L, 1L, 1L, 1L]\n    >>> antiderivative([2L, 3L, 4L, 5L])\n    [0L, 2L,\
    \ 1L, 1L, 1L]\n    >>> antiderivative([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0L,\
    \ 1L, 1L, 1L]\n    \n*/\nlong[] antiderivative(long[] xs) \n{\n    int n = xs.length;\n\
    \    long[] a = new long[n + 1];\n    a[0] = 0;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        a[i + 1] = xs[i] / (i + 1);\n    }\n    return a;\n}\n/*\n xs\
    \ represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2\
    \ + ....\n     Return integral of this polynomial in the same form.\n    >>> integral([2L,\
    \ 3L, 4L, 5L])\n    [1L, 2L, 1L, 1L, 1L]\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n\
    \    [1L, 3L, 0L, 1L, 1L, 1L]\n    \n*/\nlong[] integral(long[] xs) \n{\n    int\
    \ n = xs.", '{', "{\n  int n = size(xs);\n  if (n == 0) return [];\n  long[] ys\
    \ = new long[n - 1];\n  int ysIdx = 0;\n  for (int i = 1; i < n; i++) {\n    ys[ysIdx]\
    \ = i * xs[i];\n    ysIdx++;\n  }\n  return ys;\n}\n/*\n Find x value for given\
    \ y using Newton's method.\n     P is polynomial in the form of a list of coefficients.\n\
    \    x0 is a guess.  If f(x0) == y, x0 is returned.\n    \n*/\nlong newton(long[]\
    \ P, long y, long x0) \n{\n  long[] f = P;\n  int n = 10;\n  while (n-- != 0)\
    \ {\n    long x1 = x0 - (eval(f, x0) - y) / eval(derivative(f), x0);\n    if (abs(x1\
    \ - x0) < 1) break;\n    x0 = x1;\n  }\n  return x0;\n}\n/*\n Evaluate polynomial\
    \ with coefficients from xs\n    at x=x0.\n    \n*/\nlong eval(long[] xs, long\
    \ x0) \n{\n  long y = 0;\n  for (long x : xs) {\n    y = y * x0 + x;\n  }\n  return\
    \ y;\n}\n/*\n xs represent coefficients of a polynomial.\n    xs[0] + xs[1] *\
    \ x + xs[2] * x^2 + ....\n     Return coefficient of the largest term.\n    >>>\
    \ maxPoly([3L, 1L, 2L, 4L, 5L])\n    5L\n    >>> maxPoly([1L, 2L, 3L])\n    3L\n\
    \    \n*/\nlong maxPoly(long[] xs) \n{\n  long x = 0;\n  for (long y : xs) {\n\
    \    x = max(x, y);\n  }\n  return x;\n}\nlong N;\nlong[] P;\nlong maxP;\nlong[]\
    \ bits;", "{\n    long[] dx = new long[xs.length-1];\n    for (int i = 0; i <\
    \ dx.length; i++) {\n        dx[i] = (i+1) * xs[i+1];\n    }\n    return dx;\n\
    }", "{\n    \n    int len = len(xs);\n    if (len == 0) \n    {\n        return\
    \ [];\n    }\n    auto res = new long[len - 1];\n    for (size_t i = 0; i < len\
    \ - 1; i++) \n    {\n        res[i] = xs[i + 1] * (i + 1);\n    }\n    return\
    \ res;\n}\n/*\n Calculate the composition of two polynomials.\n   return (p1 o\
    \ p2)(x)\n     >>> compose([2L, 3L, 4L], [1L, 2L, 3L])\n    [2L, 10L, 32L, 73L]\n\
    \    \n*/\nlong[] compose(long[] p1, long[] p2) \n{\n    auto n = len(p1);\n \
    \   long[] p1pow = [];\n    long[] res = [0L];\n    long[] p2pow = [1L];\n   \
    \ while (n != 0) \n    {\n        n = n - 1;\n        p1pow = multiply(p1pow,\
    \ p1);\n        p2pow = multiply(p2pow, p2);\n        auto  mul = multiply(p1pow,\
    \ p2pow);\n        auto temp = multiply(mul, [p1[n]]);\n        res = add(res,\
    \ temp);\n    }\n    return res;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    return the value of polynomial\
    \ at x.\n    >>> horner([1L, 2L, 3L], 5L)\n    76L\n    \n*/\nlong horner(long[]\
    \ xs, long x) \n{\n    int len = len(xs);\n    long result = 0L;\n    while (len\
    \ != 0) \n    {\n        len = len - 1;\n        result = xs[len] + result * x;\n\
    \    }\n    return result;\n}\n/*\n Add two polynomials xs and ys.\n   return\
    \ (p1", "{\n  long[] result;\n  foreach (i, ref x; zip(xrange(xs.length), xs))\n\
    \  {\n    result ~= x[0] * x[1];\n  }\n  return result[1 .. $];\n}\n/*\n xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \     Return definite integral of this polynomial in the same form.\n    >>> integral([3L,\
    \ 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L, 2L, 4L, 5L]\n    >>> integral([1L, 2L,\
    \ 3L])\n    [0L, 1L, 1L, 3L]\n    \n*/\nlong[] integral(long[] xs) \n{\n  long[]\
    \ result;\n  foreach (i, ref x; zip(xrange(xs.length), xs))\n  {\n    result ~=\
    \ x[1] / (i + 1);\n  }\n  return result[0 .. $];\n}\n/*\n This class represents\
    \ an atom in the context of a state.\n    An atom of a state is a list of positions.\n\
    \    For example, in the state\n    \n      0 | 0 0 1  1  0\n      1 | 0 1 0 \
    \ 0  1\n      2 | 1 0 0  0  0\n    \n    there are 3 atoms: [0], [1, 2], [3, 4].\n\
    \    \n    Each atom can be in two positions: left or right.\n    Each atom can\
    \ be in a superposition of multiple positions.\n    For example, the atom [0]\
    \ can be in a superposition of\n    positions: left|right, left, right.\n    \n\
    \    This class provides a unified way to represent all these\n    possibilities.\n\
    \    \n    It also provides a way to represent position of an atom\n    independent\
    \ of the state.\n    For example, the position of the atom [0] in the state\n\
    \    \n      0 | 0 0 1  1  0\n      1 | 0 1 0  0  1\n      2 | 1 0 0  0  0\n \
    \   \n   ", "{\n    size_t n = xs.length;\n    if (n < 2)\n    {\n        return\
    \ [1L];\n    }\n    else\n    {\n        long[] d = to!(long[])(inout xs[1 ..\
    \ $]);\n        foreach (i, ref e; d)\n        {\n            e *= i + 1;\n  \
    \      }\n        return d;\n    }\n}", "{\n    bool is(T)(T[] xs)\n    {\n  \
    \      foreach (i, x; xs)\n        {\n            if (x != 0) return true;\n \
    \       }\n        return false;\n    }\n    if (is(xs))\n    {\n        long[]\
    \ result = new long[$ - 1];\n        foreach (i, x; xs)\n        {\n         \
    \   if (i != 0)\n            {\n                result[i - 1] = i * x;\n     \
    \       }\n        }\n        return result;\n    }\n    else\n    {\n       \
    \ return [0L];\n    }\n}", "{\n    long[] ys = new long[xs.length - 1L];\n   \
    \ long n = 0L;\n    foreach (long x; xs)\n    {\n        ys[n] = x * n;\n    \
    \    n += 1L;\n    }\n    return ys;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral of this polynomial\
    \ in the same form.\n    >>> integral([3L, 1L, 2L, 4L, 5L])\n    [0L, 3L, 0.5L,\
    \ 1L, 4L / 3L, 5L / 4L]\n    >>> integral([1L, 2L, 3L])\n    [0L, 1L, 1L, 1L]\n\
    \    >>> integral([1L, 2L, 3L, 4L])\n    [0L, 1L, 1L, 1L, 1L]\n    >>> integral([1L,\
    \ 2L, 3L, 4L, 5L])\n    [0L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\ndouble[] integral(long[]\
    \ xs) \n{\n    long n = 0L;\n    double[] ys = new double[xs.length + 1L];\n \
    \   foreach (long x; xs)\n    {\n        ys[n + 1L] = x / (n + 1L);\n        n\
    \ += 1L;\n    }\n    return ys;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return the value of this polynomial\
    \ at t.\n    >>> polyval([3L, 1L, 2L, 4L, 5L], 2L)\n    155L\n    >>> polyval([1L,\
    \ 2L, 3L], 2L)\n    17L\n    \n*/\nlong polyval(long[] xs, long t) \n{\n    long\
    \ x = 0L;\n    long n = 0L;\n", "{\n    immutable uint n = xs.length;\n    long[]\
    \ ys = new long[n-1];\n    foreach (immutable uint i, ref long x; xs)\n    {\n\
    \        ys[i] = x * cast(long)(i+1);\n    }\n    return ys;\n}", "    in \n \
    \   {\n        assert(xs.length > 0);\n    }\n    body \n    {\n        long[]\
    \ ys = new long[xs.length - 1];\n        for (size_t i = 0; i < ys.length; i++)\
    \ \n        {\n            ys[i] = xs[i + 1] * (i + 1);\n        }\n        return\
    \ ys;\n    }\n/*\n Compute coefficients of the polynomial that are the n-th powers\
    \ of x.\n    >>> powers(2L, 0L)\n    [1L]\n    >>> powers(2L, 1L)\n    [1L, 2L]\n\
    \    >>> powers(2L, 2L)\n    [1L, 4L, 4L]\n    >>> powers(2L, 3L)\n    [1L, 8L,\
    \ 16L, 8L]\n    >>> powers(2L, 4L)\n    [1L, 16L, 64L, 128L, 64L]\n    \n*/\n\
    long[] powers(long x, size_t n) \n    in \n    {\n        assert(n >= 0);\n  \
    \  }\n    body \n    {\n        long[] ys = new long[n + 1];\n        ys[0] =\
    \ 1;\n        long xk = 1;\n        for (size_t k = 1; k <= n; k++) \n       \
    \ {\n            xk *= x;\n            ys[k] = xk;\n        }\n        return\
    \ ys;\n    }\n/*\n Compute coefficients of the polynomial that are the n-th powers\
    \ of x\n      multiplied by the binomial coefficients of degree n.\n    >>> binomial_powers(2L,\
    \ 0L)\n    [1L]\n    >>> binomial_powers(2L, 1L)\n    [1L, 2L]\n    >>> binomial_powers(2L,\
    \ 2L)\n    [1L, 3L, 3L]\n    >>> binomial_powers(2L, 3L)\n    [1L, 4L, 6L, 4L]\n\
    \    >>> binomial_powers(2L, 4L)\n    [1L", "{\n    if (xs.length == 0)\n    {\n\
    \        return xs;\n    }\n    long[] res = new long[xs.length - 1];\n    foreach\
    \ (i, x; xs)\n    {\n        if (i > 0)\n        {\n            res[i - 1] = x\
    \ * i;\n        }\n    }\n    return res;\n}\n/*\n Return the roots of a polynomial.\n\
    \    xs represent coefficients of a polynomial in the form\n    xs[0] + xs[1]\
    \ * x + xs[2] * x^2 + ....\n    Return roots of this polynomial.\n    >>> realRoots([1L,\
    \ 1L, -4L, -4L, 4L])\n    [-1.41421, -1.0, 1.0, 1.41421]\n    >>> realRoots([1L,\
    \ 1L, -4L, -4L, 1L])\n    [-1.33352, -0.666748, 0.666748, 1.33352]\n    >>> realRoots([1L,\
    \ 2L, 3L])\n    [-1.0, -0.0]\n    \n*/\ndouble[] realRoots(long[] xs) \n{\n  \
    \  if (xs.length <= 1)\n    {\n        return new double[0];\n    }\n    else\n\
    \    {\n        long[] ys = xs;\n        double[] div = realRoots(derivative(ys));\n\
    \        return div.filter!(a => all!(b => !opEquals(a, b))(div) && abs(poly(ys,\
    \ a)) < epsilon)().array;\n    }\n}\n/*\n Multiply two polynomials.\n    xs and\
    \ ys represent coefficients of polynomials in the form\n    xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n    Return coefficients of polynomial xs * ys.\n    >>>\
    \ multiply([1L, 2L, 3L], [1L, 1L, 1L])\n    [1L, 3L, 6L, 5L]\n", "{\n  long[]\
    \ result = new long[xs.length - 1];\n  foreach (i, x; iota(xs.length).zip(xs))\
    \ \n  {\n    if (i == 0) \n    {\n      continue;\n    }\n    result[i - 1] =\
    \ i * x;\n  }\n  return result;\n}\n/*\n >>> find_roots([3L, 0L, 0L, 4L])\n  \
    \  [-1L, -2L]\n     >>> find_roots([1L, 2L, 1L])\n    [-1L]\n*/\nlong[] find_roots(long[]\
    \ xs) \n{\n  long[] result = new long[];\n  long[] dx = derivative(xs);\n  long[]\
    \ d2x = derivative(dx);\n  long[] d3x = derivative(d2x);\n  long[] zeros = find_roots(dx);\n\
    \  foreach (zero; zeros) \n  {\n    long f1 = eval(xs, zero);\n    long f2 = eval(dx,\
    \ zero);\n    long f3 = eval(d2x, zero);\n    long f4 = eval(d3x, zero);\n   \
    \ if (abs(f1) < 1e-9 && abs(f2) < 1e-9 && abs(f3) < 1e-9 && abs(f4) < 1e-9) \n\
    \    {\n      result ~= zero;\n    }\n  }\n  return result;\n}\n/*\n eval(3L,\
    \ 0L, 0L, 4L, 5L, 0L, 3L), -2)\n    -3.0\n     eval(1L, 2L, 1L), -1)\n    0.0\n\
    \    \n*/\ndouble eval(long[] xs, double x) \n{\n  double y = 0.0;\n  foreach\
    \ (i, a; iota(xs.length).zip(xs)) \n  {\n    y += a * pow(x, i);\n  }\n  return\
    \ y;\n}\nlong[] iota(long n) \n{\n  long[] result = new long[n];\n  foreach (i;\
    \ 0 .. n", "{\n\treturn xs[0..$-1].map!((l,l1) => (l1+1) * l);\n}\n/*\n    Return\
    \ the definite integral of a polynomial.\n    >>> integral([1L, 2L, 3L], [2L,\
    \ 3L])\n    [1L, 2L, 1L, 1L]\n    >>> integral([3L, 4L, 5L, 6L], [1L, 2L, 3L])\n\
    \    [1L, 4L, 4L, 5L, 2L]\n    */\nlong[] integral(long[] xs, long[] a) \n{\n\t\
    return a.map!((l,i) => a[i] * xs[i] / (i+1)).array;\n}\n/*\n    Return the definite\
    \ integral of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    >>>\
    \ integral([3L, 1L, 2L, 4L, 5L], [1L, 1L])\n    [1L, 4L, 1L, 2L, 1L, 1L]\n   \
    \ >>> integral([1L, 2L, 3L])\n    [1L, 1L, 1L, 1L]\n*/\nlong[] integral(long[]\
    \ xs) \n{\n\treturn xs.map!((l,i) => xs[i] / (i+1)).array;\n}", "{\n    return\
    \ zip(xs, iota(xs.length - 1)).map!(a => a[0] * a[1]).array;\n}\n/*\n n :: Integer\n\
    \    The number of roots to find.\n    Function f must have n roots in the given\
    \ interval.\n    a, b :: Double\n    The interval in which to search for roots.\n\
    \    It is assumed that f(a) and f(b) have opposite signs,\n    i.e. f(a) < 0\
    \ < f(b).\n    f :: Function\n    The function to be root-solved. Must be continuous\
    \ and\n    differentiable in the given interval.\n    tolerance :: Double\n  \
    \  Stop if root is found with precision epsilon where\n    epsilon = tolerance\
    \ * max(|b|, |a|).\n    maxiter :: Integer\n    Stop after at most maxiter steps.\n\
    \    \n*/\ndouble[] rootFinding(long n, double a, double b, Func!(double) f, double\
    \ tolerance = 1e-7, long maxiter = 100) \n{\n    import std.math;\n    double\
    \ epsilon = tolerance * max(abs(a), abs(b));\n    assert(epsilon > 0);\n    double[]\
    \ roots = new double[];\n    while (n > 0) {\n        assert(maxiter > 0);\n \
    \       double c = 0.5 * (a + b);\n        double fc = f(c);\n        double fb\
    \ = f(b);\n        if (abs(fc) < epsilon) {\n            roots ~= c;\n       \
    \     b = c;\n            n--;\n        } else if (fb * fc < 0) {\n          \
    \  a = c;\n        } else {\n            b = c;\n        }\n        maxiter--;\n\
    \    }\n    return roots;\n}\n/*\n    xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return roots of this polynomial.\n\
    \    >>> polyroots([1L, 1L, -64L, 236L, -240L])\n    [5.0, 3.0, 2.0,", "{\n  \
    \  long[] dxs;\n    dxs = new long[xs.length - 1];\n    for (int i = 0; i < dxs.length;\
    \ i ++)\n        dxs[i] = xs[i + 1] * (i + 1);\n    return dxs;\n}", "{\n    import\
    \ std.math : abs;\n    int zeros = 0;\n    foreach (i, x; xs)\n    {\n       \
    \ if (abs(x) < 1e-15)\n        {\n            zeros++;\n        }\n        else\n\
    \        {\n            break;\n        }\n    }\n    if (zeros == xs.length)\n\
    \    {\n        return [0L];\n    }\n    return xs[zeros..$].zip([1L..$-zeros]).map!(a\
    \ => a[0] * a[1]).array;\n}\n/*\n xs represent coefficients of a polynomial.\n\
    \    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral of this polynomial\
    \ in the same form.\n    >>> integrate([1L, 2L, 3L])\n    [0L, 1L, 1L, 1L]\n \
    \   >>> integrate([3L, 1L, 2L, 4L, 5L])\n    [0L, 0.75L, 0.5L, 0.3333333333333333L,\
    \ 0.25L, 1.25L]\n*/\nlong[] integrate(long[] xs) \n{\n    import std.math : abs;\n\
    \    int zeros = 0;\n    foreach (i, x; xs)\n    {\n        if (abs(x) < 1e-15)\n\
    \        {\n            zeros++;\n        }\n        else\n        {\n       \
    \     break;\n        }\n    }\n    if (zeros == xs.length)\n    {\n        return\
    \ [0L];\n    }\n    long[] ys = [0L].opSlice(xs[zeros..$]).zip([0L..$-zeros]).map!(a\
    \ => a[0] / (a[1] + 1)).array;\n    return ys[0..$ - 1];\n}\n/*\n    xs represent\
    \ coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \    Returns the primitive function, i.e. the result of integration,", "    if\
    \ (xs.length == 0)\n    {\n        return new long[0.init];\n    }\n    else\n\
    \    {\n        return xs[1..$].zip(enumerate(xs[1..$])).map!(x => (x[0] * x[1])).array;\n\
    \    }\n}\n/*\n  xs represent coefficients of a polynomial.\n    xs[0] + xs[1]\
    \ * x + xs[2] * x^2 + ....\n     Return polynomial in a value.\n    >>> evaluate([3L,\
    \ 1L, 2L, 4L, 5L], 2L)\n    95L\n    >>> evaluate([1L, 2L, 3L], 2L)\n    17L\n\
    \    \n*/\nlong evaluate(long[] xs, long x)\n{\n    long y = 0L;\n    long base\
    \ = 1L;\n    foreach (int i; 0..xs.length)\n    {\n        y += xs[i] * base;\n\
    \        base *= x;\n    }\n    return y;\n}\n/*\n  xs represent coefficients\
    \ of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return the\
    \ maximum value of this polynomial in a range\n    >>> maximum([1L, 2L, 3L], [1L,\
    \ 2L])\n    5L\n    >>> maximum([1L, 2L, 3L], [1L, 3L])\n    8L\n    >>> maximum([1L,\
    \ 2L, 3L], [3L, 2L])\n    Traceback (most recent call last):\n        ...\n  \
    \  AssertionError\n    \n*/\nlong maximum(long[] xs, long[] range)\n{\n    assert(range[0]\
    \ <= range[1]);\n    long diff = (range[1] - range[0]) / 10L;\n    assert(diff\
    \ > 0L);\n    long current = evaluate(xs, range[0]);\n    long pos = range[0];\n\
    \    foreach (i; 0..10)\n    {\n        long new_pos = range[0] + diff *"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
