name: HumanEval_121_solution
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nGiven a non-empty array of integers,\
  \ return the sum of all of the odd elements that are in even positions.\n    \n\n\
  \    Examples\n    >>> solution([5L, 8L, 7L, 1L])\n    12L\n    >>> solution([3L,\
  \ 3L, 3L, 3L, 3L])\n    9L\n    >>> solution([30L, 13L, 24L, 321L])\n    0L\n  \
  \  \n*/\nlong solution(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = solution;\n\n    assert(candidate([5L,\
  \ 8L, 7L, 1L]) == 12L);\n    assert(candidate([3L, 3L, 3L, 3L, 3L]) == 9L);\n  \
  \  assert(candidate([30L, 13L, 24L, 321L]) == 0L);\n    assert(candidate([5L, 9L])\
  \ == 5L);\n    assert(candidate([2L, 4L, 8L]) == 0L);\n    assert(candidate([30L,\
  \ 13L, 23L, 32L]) == 23L);\n    assert(candidate([3L, 13L, 2L, 9L]) == 3L);\n}\n\
  void main(){}"
completions: ["{\n    long total = 0;\n    for(int i = 0; i < lst.length; i += 2)\n\
    \    {\n        if(lst[i] % 2 == 1)\n        {\n            total += lst[i];\n\
    \        }\n    }\n    return total;\n}", "{\n    long sum = 0;\n    long temp;\n\
    \    long i;\n    foreach( i; 0..lst.length)\n    {\n        temp = lst[i];\n\
    \        if(i % 2 == 0)\n        {\n            if(temp % 2 != 0)\n          \
    \  {\n                sum += temp;\n            }\n        }\n    }\n    return\
    \ sum;\n}", "{\n  //  Your code here.\n   long sum = 0;\n   for(int i = 0; i <\
    \ lst.length; i++) {\n       if(i % 2 == 0 && lst[i] % 2 != 0) {\n           sum\
    \ += lst[i];\n       }\n   }\n   return sum;\n}", "{\n    long sum=0;\n    for(int\
    \ i=0;i<lst.length;i++)\n    {\n      if(i%2==0 && lst[i]%2!=0)\n      {\n   \
    \     sum+=lst[i];\n      }\n    }\n    return sum;\n}", "{\n    size_t len =\
    \ lst.length;\n    size_t i = 0;\n    size_t j = 0;\n    long[] lst2 = new long[len];\n\
    \    for(i; i < len; i+=2)\n    {\n        lst2[j] = lst[i];\n        j++;\n \
    \   }\n    len = j;\n    j = 0;\n    i = 0;\n    long[] lst3 = new long[len];\n\
    \    for(i; i < len; i++)\n    {\n        if(lst2[i]%2 == 1)\n        {\n    \
    \        lst3[j] = lst2[i];\n            j++;\n        }\n    }\n    len = j;\n\
    \    i = 0;\n    long sum = 0;\n    for(i; i < len; i++)\n    {\n        sum +=\
    \ lst3[i];\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    if(lst.empty)\
    \ return sum;\n    for(int i = 0; i < lst.length; i += 2)\n    {\n        if(lst[i]\
    \ % 2 != 0)\n        {\n            sum += lst[i];\n        }\n    }\n    return\
    \ sum;\n}", "{\n    long result = 0;\n    foreach(i, l; lst)\n    {\n        if\
    \ (i % 2 != 0 && i != lst.length - 1)\n        {\n            result += l;\n \
    \       }\n    }\n    return result;\n}", "{\n    long[uint] oddEven;\n    foreach(i,\
    \ v; lst)\n    {\n        if(v % 2 == 0)\n        {\n            if(i % 2 == 0)\n\
    \            {\n                oddEven ~= v;\n            }\n        }\n    }\n\
    \    return reduce!\"a + b\"(oddEven);\n}", "{\n    int cnt = 0;\n    long res\
    \ = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if (i % 2 ==\
    \ 0 && lst[i] % 2 != 0)\n        {\n            res += lst[i];\n        }\n  \
    \  }\n    return res;\n}", "{\n    return lst.filter!((x, i) => i % 2 == 0 &&\
    \ x % 2 == 1).sum;\n}", "{\n    long sum = 0;\n    foreach(a; lst)\n    {\n  \
    \      if (a%2 == 1 && lst.indexOf(a)%2 == 0)\n        {\n            sum += a;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long res = 0;\n    for(int i =\
    \ 0; i < lst.length; i+=2)\n    {\n        if (lst[i] % 2 != 0)\n        {\n \
    \           res += lst[i];\n        }\n    }\n    return res;\n}", "{\n    \n\
    \    long sum = 0;\n    foreach(i, v; lst)\n    {\n        if(i % 2 != 0 && v\
    \ % 2 == 0)\n        {\n            sum += v;\n        }\n    }\n    return sum;\n\
    }", "{\n    \n    long sum = 0;\n    for(auto i = 0; i < lst.length; i++)\n  \
    \  {\n        if(i % 2 == 0 && lst[i] % 2 != 0)\n        {\n            sum +=\
    \ lst[i];\n        }\n    }\n    return sum;\n}", "{\n    return lst.indexedMap!(a\
    \ => a[0] * a[1] % 2 == 0 ? a[0] : 0).sum;\n}", "{\n  int count = 0;\n  long sum\
    \ = 0;\n  foreach(int n; lst)\n  {\n    if(n%2 != 0 && count%2 == 0)\n    {\n\
    \      sum += n;\n    }\n    count++;\n  }\n  return sum;\n}", "{\n    long n\
    \ = 2;\n    long solution = 0;\n    foreach(i; lst)\n    {\n        if (n % 2\
    \ == 0)\n        {\n            if (i % 2 != 0)\n            {\n             \
    \   solution += i;\n            }\n        }\n        n++;\n    }\n    return\
    \ solution;\n}", "{\n    auto sum = 0L;\n    auto index = 0L;\n    auto odd =\
    \ false;\n    foreach(i; lst)\n    {\n        odd = (i % 2) != 0;\n        if(index\
    \ % 2 == 0 && odd)\n        {\n            sum += i;\n        }\n        index++;\n\
    \    }\n    return sum;\n}", "{\n    long result = 0;\n    foreach(i, v; lst)\n\
    \    {\n        if(i % 2 == 0 && v % 2 != 0)\n        {\n            result +=\
    \ v;\n        }\n    }\n    return result;\n}", "{\n    long sum = 0;\n    foreach(int\
    \ i, long e; lst)\n    {\n        if(i % 2 == 0 && e % 2 != 0)\n        {\n  \
    \          sum += e;\n        }\n    }\n    return sum;\n}", "{\n    // Initialize\
    \ the sum\n    long sum = 0L;\n    // Loop through the list\n    foreach(i, v;\
    \ lst)\n    {\n        // Check if the index of the element is even\n        if(i\
    \ % 2 == 0)\n        {\n            // Check if the element is odd\n         \
    \   if(v % 2 != 0)\n            {\n                // Add the element to the sum\n\
    \                sum += v;\n            }\n        }\n    }\n    // Return the\
    \ sum\n    return sum;\n}", "{\n    long sum = 0;\n    for (int i = 0; i < lst.length;\
    \ i += 2) \n    {\n        if (lst[i] % 2 == 1) \n        {\n            sum +=\
    \ lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long ret=0;\n    for(size_t\
    \ i=0;i<lst.length;i+=2)\n    {\n        ret+=lst[i]%2==1?lst[i]:0;\n    }\n \
    \   return ret;\n}", "{\n    long solution = 0;\n    foreach(i, e; lst)\n    {\n\
    \        if(i % 2 == 0 && e % 2 != 0)\n        {\n            solution += e;\n\
    \        }\n    }\n    return solution;\n}", "{\n    return lst.length > 0 ? lst.elementAt!((lst.length\
    \ >> 1) - 1) : 0;\n}", "{\n    long ret = 0;\n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        ret += (lst[i] % 2 == 0) ? 0 : lst[i] * (i % 2 == 0 ? 1\
    \ : -1);\n    }\n    return ret;\n}", "{\n    long accumulator = 0;\n    ulong\
    \ i = 0;\n    foreach(elem; lst)\n    {\n        if(i % 2 == 0 && elem % 2 ==\
    \ 1)\n        {\n            accumulator += elem;\n        }\n        i++;\n \
    \   }\n    return accumulator;\n}", "{\n    long sum = 0;\n    for (long i = 0;\
    \ i < lst.length; i += 2)\n    {\n        if (lst[i] % 2 != 0)\n        {\n  \
    \          sum += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long\
    \ tot=0;\n    foreach(i,e;enumerate(lst))\n    {\n        if(i%2==0 && e%2==1)\n\
    \            tot+=e;\n    }\n    return tot;\n}", "{\n    \n    \n    \n    \n\
    \    \n    return lst.enumerate\n                .filter!(a => a.index % 2 ==\
    \ 0 && a.value % 2 == 1)\n                .reduce!((a, b) => a + b.value)\n  \
    \              .getOrElse(0L);\n}", "{\n    long sum = 0;\n    foreach(i, e; lst)\n\
    \    {\n        if (isOdd(i) && isEven(e))\n        {\n            sum += e;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    for (int i\
    \ = 0; i < lst.length; i++)\n    {\n        if (i % 2 == 0 && lst[i] % 2 != 0)\n\
    \        {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
  "{\n    long sum = 0;\n    foreach(i, v; lst)\n    {\n        if(i % 2 == 0 && v\
    \ % 2 != 0)\n        {\n            sum += v;\n        }\n    }\n    return sum;\n\
    }", "{\n    long temp = 0;\n    int num = 0;\n    foreach(i;0..lst.length)\n \
    \   {\n        if(i%2==0)\n        {\n            if(lst[i]%2!=0)\n          \
    \  {\n                temp+=lst[i];\n            }\n        }\n    }\n    return\
    \ temp;\n}", "{\n    /*\n        if(lst.length == 0)\n            return 0;\n\
    \        if(lst.length == 1)\n            return lst[0];\n        \n        long\
    \ total = 0;\n        for(int i = 0; i < lst.length; i++)\n        {\n       \
    \     if(i % 2 == 0)\n            {\n                total += lst[i];\n      \
    \      }\n        }\n        return total;\n    */\n    \n    //return lst.zipWithIndex.filter!(a\
    \ => a[1] % 2 == 0).sum!(a => a[0]);\n    //return lst.sum!(a => ((a.to!ulong)\
    \ & ((a.to!ulong)<<1)) != 0 && (a.to!ulong) & 1 != 0);\n    //return lst.sum!(a\
    \ => ((a.to!ulong) & 1) == 1 && ((a.to!ulong) & 1 << 1) == 0);\n    //return lst.sum!(a\
    \ => (a.to!ulong) & 0b101 == 1);\n    //return lst.sum!(a => (a.to!ulong) & (1\
    \ << 1 | 1) == 1);\n    //return lst.sum!(a => (a.to!ulong) & 3 == 1);\n    //return\
    \ lst.sum!(a => (a.to!ulong) & 3 == 1);\n    //return lst.sum!(a => (a.to!ulong)\
    \ & 3 == 1);\n    //return lst.sum!(a => (a.to!ulong) & 3 == 1);\n    //return\
    \ lst.sum!(a => (a.to!ulong) & 3 == 1);\n    //return lst.sum!(a => (a.to!ulong)\
    \ & 3 == 1);\n    //return lst.sum!(a => (a.to!ulong) & 3 == 1);\n    //return\
    \ lst.sum!(a => (a.to!ulong) & 3 == 1);\n    //return lst.sum!(a => (a.to!ulong)\
    \ & 3", "{\n    return reduce!q{a+b}(map!(a=>a[0])(filter!(a=>a[1]%2==0)(zip(lst,iota(lst.length)))));\n\
    }", "{\n    long sum = 0;\n    foreach(idx, elem; lst)\n    {\n        if(elem\
    \ % 2 == 1 && idx % 2 == 0)\n        {\n            sum += elem;\n        }\n\
    \    }\n    return sum;\n}", "{ \n  //TODO:\n  long result = 0;\n  for(int i =\
    \ 1; i < lst.length; i+=2)\n  {\n    if(i % 2 == 0)\n    {\n      result += lst[i];\n\
    \    }\n  }\n  return result;\n}", "{\n    return lst.filter!(x => x & 1 == 1\
    \ && x.indexOf & 1 == 0).sum;\n}", "{\n    int sum = 0;\n    int index = 0;\n\
    \    foreach(element; lst)\n    {\n        if(index % 2 == 0 && element % 2 !=\
    \ 0)\n        {\n            sum += element;\n        }\n        index++;\n  \
    \  }\n    return sum;\n}", "{\n\tlong sum = 0;\n\tint n = lst.length;\n\tfor (int\
    \ i = 0; i < n; i++)\n\t{\n\t\tif (lst[i] % 2 == 1 && i % 2 == 0)\n\t\t{\n\t\t\
    \tsum += lst[i];\n\t\t}\n\t}\n\treturn sum;\n}", "{\n    long result = 0;\n  \
    \  foreach(int i, long l; lst) \n    {\n        if(i % 2 == 0 && l % 2 != 0) \n\
    \        {\n            result += l;\n        }\n    }\n    return result;\n}",
  "{\n    long sum = 0;\n    for (long i = 0; i < lst.length; i++)\n    {\n      \
    \  if (i % 2 == 0 && lst[(int)i] % 2 != 0)\n        {\n            sum += lst[(int)i];\n\
    \        }\n    }\n    return sum;\n}", "{\n    long res = 0;\n    foreach(idx,\
    \ el; lst) \n    {\n        if((idx & 1) == 0 && (el & 1) == 1) \n        {\n\
    \            res += el;\n        }\n    }\n    return res;\n}", "{ \n  long sum\
    \ = 0;\n  foreach(idx, a; lst)\n  {\n    if(idx % 2 == 0 && a % 2 != 0)\n    {\n\
    \      sum += a;\n    }\n  }\n  return sum;\n}", "{\n    size_t idx = 0;\n   \
    \ long acc = 0;\n    foreach(var elm; lst)\n    {\n        if(idx % 2 == 0 &&\
    \ elm % 2 == 1)\n        {\n            acc += elm;\n        }\n        idx++;\n\
    \    }\n    return acc;\n}", "{\n    long sum = 0;\n    int lst_size = lst.length;\n\
    \    int i;\n    for (i = 0; i < lst_size; i += 2) {\n        if (lst[i] % 2 ==\
    \ 1)\n            sum += lst[i];\n    }\n    return sum;\n}", "{\n    return lst.enumerate\n\
    \      .filter!(x => x.index % 2 == 0)\n      .filter!(x => x.value % 2 == 1)\n\
    \      .sum!(x => x.value)();\n}", "{\n    long result = 0;\n    for (int i =\
    \ 0; i < lst.length; i++)\n    {\n        if (i % 2 == 0 && lst[i] % 2 != 0)\n\
    \        {\n            result += lst[i];\n        }\n    }\n    return result;\n\
    }", "{\n    long sum = 0;\n    size_t len = lst.length;\n    for (int i = 0; i\
    \ < len; i++)\n    {\n        if (i%2 == 0 && lst[i]%2 != 0)\n        {\n    \
    \        sum += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long sum\
    \ = 0;\n    foreach(i, e; lst)\n    {\n        if(i % 2 == 0 && e % 2 != 0)\n\
    \        {\n            sum += e;\n        }\n    }\n    return sum;\n}", "{ \n\
    \    long[] b = new long[lst.length];\n    long ans = 0;\n    bool add = false;\n\
    \    foreach(idx, num; lst)\n    {\n        if(add)\n        {\n            if(num\
    \ % 2 != 0)\n            {\n                ans += num;\n            }\n     \
    \   }\n        add = !add;\n    }\n    return ans;\n}", "{\n    long sum = 0;\n\
    \    bool even = false;\n    foreach(i; 0..lst.length)\n    {\n        if(i%2==0)\n\
    \        {\n            even = !even;\n        }\n        if(even)\n        {\n\
    \            if(lst[i]%2==1)\n            {\n                sum += lst[i];\n\
    \            }\n        }\n    }\n    return sum;\n}", "{\n     return zip(lst,\
    \ cycle([true, false])).filter!(a => a[1]).map!(a => a[0]).filter!(a => a % 2).sum;\n\
    }", "{\n    long sum = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n \
    \       if(i % 2 == 0 && lst[i] % 2 != 0)\n        {\n            sum += lst[i];\n\
    \        }\n    }\n    return sum;\n}", "{\n    return lst.indices\n        .where(i\
    \ => i % 2 == 0)\n        .where(i => lst[i] % 2 == 1)\n        .sum!(i => lst[i]);\n\
    }", "{\n    long result = 0;\n    for (int i = 0; i < lst.length; i++) \n    {\n\
    \        if ((i % 2 == 0) && (lst[i] % 2 != 0)) \n        {\n            result\
    \ += lst[i];\n        }\n    }\n    return result;\n}", "{\n    enum Even = true;\n\
    \    enum Odd = false;\n    auto zipped = zip(lst, cycle(Even, Odd));\n    return\
    \ sum(map!(c => c[0], filter!(x => x[1] == Odd)(zipped)));\n}", "{\n    long sum\
    \ = 0;\n    for (long i = 0; i < lst.length; i += 2)\n    {\n        if (i % 2\
    \ == 0)\n        {\n            if (lst[i] % 2 != 0)\n            {\n        \
    \        sum += lst[i];\n            }\n        }\n    }\n    return sum;\n}",
  "{\n    int i = 0;\n    long sum = 0;\n    foreach(l; lst) {\n        if(i%2 ==\
    \ 0 && l%2 != 0) {\n            sum += l;\n        }\n        i++;\n    }\n  \
    \  return sum;\n}", "{\n  long output = 0;\n  long i = 0;\n  foreach(l; lst)\n\
    \  {\n    if(i % 2 == 0 && l % 2 != 0)\n    {\n      output += l;\n    }\n   \
    \ i++;\n  }\n  return output;\n}", "{\n    long sum = 0;\n    long[int] dict =\
    \ new long[int](lst.length);\n    int index = 0;\n    foreach(element; lst)\n\
    \    {\n        if(index % 2 == 0)\n        {\n            dict[index] = element;\n\
    \        }\n        index++;\n    }\n    foreach(element; dict)\n    {\n     \
    \   if(element % 2 != 0)\n        {\n            sum += element;\n        }\n\
    \    }\n    return sum;\n}", "{\n    return reduce!(\"a + b\")(map!(x => x % 2\
    \ == 0 ? lst[x] : 0L)(iota(lst.length)));\n}", "{\n    // Type your solution here\n\
    \    long sum = 0;\n    foreach(index, element; lst)\n    {\n        if(index\
    \ % 2 == 0 && element % 2 != 0)\n        {\n            sum += element;\n    \
    \    }\n    }\n    return sum;\n}", "{\n    return lst.enumerate.filter!((i, el)\
    \ => (i & 1) == 0 && (el & 1) == 1).sum;\n}", "{\n    int oddsum = 0;\n    for\
    \ (int i = 0; i < lst.length; i++)\n    {\n        if (i % 2 == 0 && lst[i] %\
    \ 2 != 0)\n        {\n            oddsum += lst[i];\n        }\n    }\n    return\
    \ oddsum;\n}", "{\n    long sum = 0;\n    foreach(idx, val; lst)\n    {\n    \
    \    if(modulo(idx, 2) == 0)\n        {\n            if(modulo(val, 2) == 1)\n\
    \            {\n                sum += val;\n            }\n        }\n    }\n\
    \    return sum;\n}", "{\n    return lst.\n    enumerate.\n    filter!((l) =>\
    \ l.index % 2 == 0).\n    filter!((l) => l.value % 2 == 1).\n    map!((l) => l.value).\n\
    \    reduce!((acc, l) => acc + l).\n    getOrElse(0L);\n}", "{\n    long res =\
    \ 0;\n    int len = lst.length;\n    for(int i = 0; i < len; i += 2)\n    {\n\
    \        if(lst[i] % 2 != 0)\n        {\n            res += lst[i];\n        }\n\
    \    }\n    return res;\n}", "{\n    long sum = 0;\n    for (long i = 0; i < lst.length;\
    \ i += 2) \n    {\n        if (i % 2 == 0)\n        {\n            sum += lst[cast(size_t)i];\n\
    \        }\n    }\n    return sum;\n}", "{\n    long result = 0;\n    foreach(i,\
    \ item; lst) \n    {\n        if((i % 2) != 0 && (item % 2) == 0)\n        {\n\
    \            result += item;\n        }\n    }\n    return result;\n}", "{\n \
    \   long sum = 0;\n    auto i = 0;\n    foreach(e; lst)\n    {\n        if (i%2\
    \ == 0)\n        {\n            if (e%2 != 0)\n            {\n               \
    \ sum += e;\n            }\n        }\n        i++;\n    }\n    return sum;\n}",
  "{\n    long result = 0;\n    for (size_t i = 0; i < lst.length; i += 2)\n    {\n\
    \        if (lst[i] % 2 != 0)\n        {\n            result += lst[i];\n    \
    \    }\n    }\n    return result;\n}", "{\n    long suma = 0;\n    foreach(i,\
    \ e; lst) \n    {\n        if (i % 2 != 0 && e % 2 == 0) \n        {\n       \
    \     suma += e;\n        }\n    }\n    return suma;\n}", "{\n    if (lst.length\
    \ == 0) return 0;\n    return lst.filter !isOdd()[2L..$].sum;\n}", "{\n    long\
    \ result = 0;\n    for (int i = 0; i < lst.length; i += 2)\n    {\n        if\
    \ (lst[i] % 2 == 1)\n        {\n            result += lst[i];\n        }\n   \
    \ }\n    return result;\n}", "{\n    long sum = 0;\n    size_t k = lst.length;\n\
    \    for (size_t i = 0; i < k; i++)\n    {\n        if (i % 2 == 0 && lst[i] %\
    \ 2 != 0)\n        {\n            sum += lst[i];\n        }\n    }\n    return\
    \ sum;\n}", "{\n  return lst.filter!((x, idx) => x % 2 == 1 && idx % 2 == 0).sum;\n\
    }", "{\n    return lst.retro.span!(i => i % 2 == 0)[0].sum();\n}", "{\n    return\
    \ zip(lst, iota(0L, lst.length))\n            .filter!((a) => a[1] % 2 == 0)\n\
    \            .filter!((a) => a[0] % 2 == 1)\n            .reduce!((a, b) => a[0]\
    \ + b[0])[0];\n}", "{\n    long sum = 0;\n    foreach(i, element; lst)\n    {\n\
    \        if(i % 2 == 0 && element % 2 != 0)\n        {\n            sum += element;\n\
    \        }\n    }\n    return sum;\n}", "{\n    return lst.filter!(a => a % 2L\
    \ == 1L && a % 2L == 0L).sum;\n}", "{\n    alias Res = Tuple!(long,long,long);\n\
    \    return lst.retro.chunks(3).map!(c=>c.tupleof).map!(a=>a[0]+a[2]).reduce!((a,b)=>a+b).retro;\n\
    }", "{\n    return iota(lst.length).filter!((i) => ((lst[i] & 1) == 1) && (i &\
    \ 1) == 0).map!((i) => lst[i]).sum;\n}", "{\n    long sum = 0;\n    foreach(i,elem;\
    \ enumerate(lst))\n    {\n        //sum += to!long(elem & 1) * (1L << i);\n  \
    \      if (to!long(elem & 1) && i % 2 == 0)\n            sum += elem;\n    }\n\
    \    return sum;\n}", "{\n    // Type your solution here\n    long result = 0;\n\
    \    int [] odd = lst.filter!( (n) => n % 2 != 0 && lst.indexOf(n) % 2 == 0).sort();\n\
    \    for(int i = 0; i < odd.length; i ++)\n    {\n        result += odd[i];\n\
    \    }\n    return result;\n}", "{\n    long tmp = 0;\n    foreach(i, value; lst)\n\
    \    {\n        if(i % 2 == 0 && value % 2 != 0)\n        {\n            tmp +=\
    \ value;\n        }\n    }\n    return tmp;\n}", "{\n    long sum = 0;\n    foreach(i,\
    \ element; lst)\n    {\n        if (isOdd(i) && isEven(element))\n        {\n\
    \            sum += element;\n        }\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    for (int i = 0; i < lst.length; i+=2)\n    {\n        if(lst[i]\
    \ % 2 != 0)\n        {\n            sum += lst[i];\n        }\n    }\n    return\
    \ sum;\n}", "{\n  return lst.indices\n            .where!(i => i % 2 == 0)\n \
    \           .map!(i => lst[i])\n            .sum!(x => x % 2 == 1 ? x : 0)\n \
    \           .to!long;\n}", "{\n    return lst.getBuffer()\n        .filter!((a)\
    \ => a % 2 != 0)\n        .sum;\n}", "{\n    return lst.indices\n    .filter!((int\
    \ i) => i % 2 == 0)\n    .filter!((int i) => lst[i] % 2 == 1)\n    .sum!((int\
    \ i) => lst[i]);\n}", "{\n    auto odd = true;\n    long acc = 0;\n    for(auto\
    \ e : lst)\n    {\n        if(e % 2 == 0)\n            odd = !odd;\n        else\
    \ if(odd)\n            acc += e;\n    }\n    return acc;\n}", "{\n    return lst.enumerate\n\
    \            .filter!(a => (a.index & 1) == 0)\n            .filter!(a => (a.value\
    \ & 1) == 1)\n            .map!(a => a.value)\n            .reduce!((a, b) =>\
    \ a + b)(0L);\n}", "{\n    return zip(iota(lst.length), lst)\n            .filter!(t\
    \ => t[0] % 2 == 0 && t[1] % 2 == 1)\n            .map!(t => t[1])\n         \
    \   .sum;\n}", "{ \n    long result = 0;\n    foreach(idx, item; lst)\n    {\n\
    \        if(item % 2 == 1 && idx % 2 == 0)\n        {\n            result += item;\n\
    \        }\n    }\n    return result;\n}", "{\n    const long even = 2L;\n   \
    \ long elem = 0L;\n    long sum = 0L;\n    foreach(elem; lst)\n    {\n       \
    \ if(isOdd(elem) && (elem % even == 0))\n        {\n            sum += elem;\n\
    \        }\n    }\n    return sum;\n}", "{ \n    auto lst2 = lst.dup;\n    lst2.map!(a\
    \ => a / 2).dedup;\n    auto lst3 = lst.dup;\n    lst3.map!(a => a * 2).dedup;\n\
    \    auto tpl = tuple(lst2, lst3);\n    return tpl.zip.filter!(t => t[0] + t[1]\
    \ == 1).map!(t => t[0] == 1 ? t[1] : t[0]).map!(a => a * 2).sum;\n}", "{\n   \
    \ long res = 0;\n    for(int i = 0; i < lst.length; i += 2)\n    {\n        if(lst[i]\
    \ % 2 == 1)\n        {\n            res += lst[i];\n        }\n    }\n    return\
    \ res;\n}", "{\n    //return the result\n    long sum = 0;\n    foreach(i,l; lst)\n\
    \    {\n        if(i % 2 != 0 && l % 2 == 0)\n        {\n            sum += l;\n\
    \        }\n    }\n    return sum;\n}", "{\n\tlong result = 0;\n\tfor (in i =\
    \ 0; i < lst.length; i += 2)\n\t{\n\t\tif (lst[i] % 2 != 0)\n\t\t{\n\t\t\tresult\
    \ += lst[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n    return lst.filter!(x =>\
    \ x%2 == 1).filter!(x => lst.indexOf(x)%2 == 0).sum;\n}", "{ \n    long sum =\
    \ 0;\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(i % 2 == 0 &&\
    \ lst[i] % 2 != 0)\n        {\n            sum += lst[i];\n        }\n    }\n\
    \    return sum;\n}", "{\n    long r=0;\n    foreach(i,e; zip(iota(lst.length),lst))\n\
    \    {\n        if(i%2==0)\n        {\n            if(e%2==1)\n            {\n\
    \                r+=e;\n            }\n        }\n    }\n    return r;\n}", "{\
    \ \n    long result = 0;\n    for(uint i = 0; i < lst.length; i++)\n    {\n  \
    \      if(i % 2 == 0 && lst[i] % 2 != 0)\n        {\n            result += lst[i];\n\
    \        }\n    }\n    return result;\n}", "{\n    return lst.filter!(i => i %\
    \ 2 == 1).sum;\n}", "{\n    \n    \n    \n    \n    return sum!((n) => n.isOdd()\
    \ && (n.index & 1) == 0)(lst);\n}", "{\n    struct Number{\n        long value;\n\
    \        int pos;\n        Number(long value, int pos){\n            this.value\
    \ = value;\n            this.pos = pos;\n        }\n    }\n    auto even_odd_elements\
    \ = lst.map!(x => new Number(x, lst.indexOf(x)));\n    auto odd_even_elements\
    \ = even_odd_elements.filter!(x => x.value % 2 == 1 && x.pos % 2 == 0);\n    auto\
    \ result = odd_even_elements.reduce!((a, b) => new Number(a.value + b.value, a.pos)).value;\n\
    \    return result;\n}", "{\n    long sum = 0;\n    auto p = zip(iota(0, lst.length),\
    \ lst);\n    foreach(p; i => j)\n    {\n        if (i % 2 == 0 && j % 2 != 0)\n\
    \        {\n            sum += j;\n        }\n    }\n    return sum;\n}", "{\n\
    \    if (lst.length < 2)\n    {\n        return 0;\n    }\n    long sum = 0;\n\
    \    for (size_t i = 0; i < lst.length; i+=2)\n    {\n        if (isOdd(lst[i]))\n\
    \        {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
  "{\n    long res = 0;\n    bool isOdd = false;\n    foreach(x; lst)\n    {\n   \
    \     if(isOdd)\n        {\n            if(x % 2 == 1)\n            {\n      \
    \          res += x;\n            }\n        }\n        isOdd = !isOdd;\n    }\n\
    \    return res;\n}", "{\n    long sum = 0;\n    foreach(idx, item; lst)\n   \
    \ {\n        if(item % 2 != 0 && idx % 2 == 0)\n        {\n            sum +=\
    \ item;\n        }\n    }\n    return sum;\n}", "{\n    long res = 0;\n    foreach(idx,\
    \ i; lst)\n    {\n        if (idx % 2 == 0 && i % 2 != 0)\n            res +=\
    \ i;\n    }\n    return res;\n}", "{\n    return lst.enumerate.filter!((a,b) =>\
    \ a % 2 == 0 && b % 2 == 1).map!(a => a[1]).sum;\n}", "{\n    return sum(lst.filter!((x)\
    \ => lst.indexOf(x) % 2 == 0)().filter!((x) => x % 2 == 1)());\n}", "{\n  long\
    \ odd = 0;\n  long even = 0;\n  for(int i = 0; i < lst.length; i++)\n  {\n   \
    \ if(i % 2 == 0)\n    {\n      if(lst[i] % 2 != 0)\n      {\n        odd += lst[i];\n\
    \      }\n    }\n  }\n  return odd;\n}", "{\n    size_t sz = lst.length;\n   \
    \ if (sz < 2)\n        return 0;\n    else\n    {\n        size_t mid = sz/2;\n\
    \        size_t upp = min(mid, sz-1);\n        long sum = 0;\n        foreach\
    \ (i; 2..upp)\n        {\n            long num = lst[i];\n            if (num\
    \ % 2 == 1)\n                sum += num;\n        }\n        return sum;\n   \
    \ }\n}", "{\n\t//Given a non-empty array of integers, return the sum of all of\
    \ the odd elements that are in even positions.\n\t//Find the position of all odd\
    \ numbers, add those numbers that are in even positions.\n\treturn zip(iota(lst.length),\
    \ lst).filter!(a => a[0] % 2 == 0).filter!(a => a[1] % 2 != 0).map!(a => a[1]).reduce!(a\
    \ => a + a).sum;\n}", "{\n    //take only even position values\n    lst=lst.filter!(x=>lst.indexOf(x)%2==0);\n\
    \    //take only odd values\n    lst=lst.filter!(x=>x%2!=0);\n    //sum the values\n\
    \    return lst.sum;\n}", "{\n    import std.algorithm.iteration : filter, count,\
    \ max, iota;\n    import std.array : map;\n    import std.conv : to;\n    import\
    \ std.algorithm.comparison : equal;\n    auto even = lst\n                .map!(x\
    \ => x % 2)\n                .filter!(x => x == 0)\n                .equal([0,\
    \ 0]);\n    auto odd = lst\n                .map!(x => x % 2)\n              \
    \  .filter!(x => x == 1)\n                .equal([1, 1]);\n    return equal(even,\
    \ odd) ? -1 : \n               lst\n               .map!(x => (x % 2) == 0)\n\
    \               .iota\n               .filter!(x => x[0] ^ x[1])\n           \
    \    .map!(x => lst[x[0]])\n               .sum;\n}", "{\n  return lst.indexed\n\
    \    .filter!(e => (e.index % 2 == 0 && e.value % 2 == 1))\n    .map!(e => e.value)\n\
    \    .reduce!((a, b) => a + b)(0L);\n}", "{\n    return lst.enumerate.filter!(a\
    \ => a.index % 2 == 0).filter!(a => a.value % 2 == 1).map!(a => a.value).sum;\n\
    }", "{\n    long odd_answer = 0;\n    int i = 0;\n    foreach(x; lst)\n    {\n\
    \        if(i % 2 == 0 && x % 2 != 0)\n        {\n            odd_answer += x;\n\
    \        }\n        i++;\n    }\n    return odd_answer;\n}", "{\n    long result\
    \ = 0;\n    foreach(i, e; lst)\n    {\n        if(isOdd(i) && isEven(e))\n   \
    \     {\n            result += e;\n        }\n    }\n    return result;\n}", "{\n\
    \    int i = 0;\n    long res = 0;\n    foreach(long n; lst)\n    {\n        if\
    \ (i % 2 == 0 && n % 2 != 0)\n            res += n;\n        i++;\n    }\n   \
    \ return res;\n}", "{\n  long[] lstDup = lst.dup;\n  long[] lstEven = lstDup.filter!(i\
    \ => i % 2 == 0)();\n  long[] lstOdd = lstDup.filter!(i => i % 2 != 0)();\n  long[]\
    \ lstEvenOdd = lstEven.zip(lstOdd).map!(t => t[0] + t[1])();\n  long[] lstOddEven\
    \ = lstOdd.zip(lstEven).map!(t => t[0] + t[1])();\n  long[] lstOddEvenSorted =\
    \ lstOddEven.sort!((a, b) => a < b)();\n  long[] lstEvenOddSorted = lstEvenOdd.sort!((a,\
    \ b) => a < b)();\n  return lstOddEvenSorted[0] + lstEvenOddSorted[0];\n}", "{\n\
    \    return lst.length % 2 == 0 ? lst[1..$-1].sum!(x => x % 2 == 1) : lst[1..$].sum!(x\
    \ => x % 2 == 1);\n}", "{\n    int p = 0;\n    long acc = 0;\n    foreach(i; lst)\n\
    \    {\n        if(p % 2 == 0 && i % 2 == 1)\n        {\n            acc += i;\n\
    \        }\n        p++;\n    }\n    return acc;\n}", "{\n    long sum = 0;\n\
    \    for (long i = 0; i < lst.length; i++) \n    {\n        if (i % 2 == 0 &&\
    \ lst[i] % 2 != 0) \n        {\n            sum += lst[i];\n        }\n    }\n\
    \    return sum;\n}", "{\n    // init\n    long sum = 0;\n    int idx = 0;\n \
    \   // check if odd\n    foreach(idx, lst)\n    {\n        if (isOdd(idx) && isEven(lst[idx]))\n\
    \        {\n            sum += lst[idx];\n        }\n    }\n    return sum;\n\
    }\nlong isOdd(long i)\n{\n    return i % 2;\n}\nlong isEven(long i)\n{\n    return\
    \ 1 - isOdd(i);\n}", "{\n  long sum = 0;\n  foreach(i, item; lst)\n  {\n    if(i\
    \ % 2 == 0 && item % 2 != 0)\n    {\n      sum += item;\n    }\n  }\n  return\
    \ sum;\n}", "{ \n    return lst.enumerate.filter!((i, v) => i % 2 == 0 && v %\
    \ 2 == 1).sum;\n}", "{\n    long res = 0;\n    int i = 0;\n    foreach(var c;\
    \ lst)\n    {\n        if (c%2==1 && i%2==0)\n            res += c;\n        i++;\n\
    \    }\n    return res;\n}", "{\n    int[] indexes = iota(lst.length)\n      \
    \              .filter!(x => x % 2 == 0)\n                    .array;\n    return\
    \ lst\n           .filter!(x => x % 2 == 1)\n           .array\n           .sum(indexes);\n\
    }", "{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "{\n    long ans\
    \ = 0;\n    foreach(elem; zip(lst, iota(0L, lst.length)))\n    {\n        if(elem[1]\
    \ % 2 == 0 && elem[0] % 2 == 1)\n        {\n            ans += elem[0];\n    \
    \    }\n    }\n    return ans;\n}", "{\n  long res = 0;\n  for(int i = 0; i <\
    \ lst.length; i++)\n  {\n    if(i % 2 == 0 && lst[i] % 2 != 0)\n    {\n      res\
    \ += lst[i];\n    }\n  }\n  return res;\n}", "{\n    long sum = 0;\n    foreach(idx,\
    \ val; lst)\n    {\n        if(isOdd(idx) && isEven(val)) sum += val;\n    }\n\
    \    return sum;\n}", "{\n    long sum = 0;\n    int i = 0;\n    foreach(elem;\
    \ lst)\n    {\n        if(i%2 == 0 && elem%2 == 1)\n        {\n            sum\
    \ += elem;\n        }\n        i++;\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    foreach(int i, elem; lst)\n    {\n        if (i % 2 == 0 && elem\
    \ % 2 != 0)\n        {\n            sum += elem;\n        }\n    }\n    return\
    \ sum;\n}", "{\n    long sum=0;\n    foreach(int i, ref lst)\n    {\n        if(i%2!=0\
    \ && i%2==0)\n        {\n            sum+=i;\n        }\n    }\n    return sum;\n\
    }", "{\n    int result = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n\
    \        if(i % 2 == 0 && lst[i] % 2 != 0)\n        {\n            result += lst[i];\n\
    \        }\n    }\n    return result;\n}", "{\n    long sum = 0;\n    auto i =\
    \ 0L;\n    auto numbers = lst.zip(lst.save.map!(a => a % 2 == 0L).save.cycle);\n\
    \    foreach(number; numbers) \n    {\n        if(number[0] % 2 != 0L && number[1])\n\
    \        {\n            sum += number[0];\n        }\n    }\n    return sum;\n\
    }", "{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return\
    \ (long) lst.filter!(x => x % 2 == 1 && x % 2 == 0).sum;\n}\n```", "{\n  long[]\
    \ odd = lst.filter!(i => i % 2 == 1)().filter!(j => j % 2 == 0)();\n  long result\
    \ = odd.sum;\n  return result;\n}", "{\n  long result = 0;\n  foreach(i,item;\
    \ lst)\n  {\n    // print(\"i = \",i,\" item = \",item,\"\\n\");\n    if((i %\
    \ 2) == 0 && (item % 2) != 0)\n    {\n      result += item;\n    }\n  }\n  return\
    \ result;\n}", "{\n    long sum = 0;\n    int pos = 0;\n    foreach(long num;\
    \ lst)\n    {\n        if(pos % 2 == 0 && num % 2 != 0)\n        {\n         \
    \   sum += num;\n        }\n        pos++;\n    }\n    return sum;\n}", "{\n \
    \   // We need to return a long.\n    long ret = 0L;\n    // lst.length will tell\
    \ us how many elements are in the array.\n    // Since the array is non-empty,\
    \ we know there will be at least 1 element.\n    // length will tell us how many\
    \ elements there are.\n    // length - 1 will give us the largest index in the\
    \ array.\n    // This will help us only loop through even indexes.\n    foreach(idx;\
    \ 0..(lst.length - 1))\n    {\n        // modulus tells us the remainder. \n \
    \       // idx % 2 will return the remainder of (idx / 2).\n        // If idx\
    \ is even, the remainder will be 0.\n        // If idx is odd, the remainder will\
    \ be 1.\n        // We only want to do our computations for even idx's.\n    \
    \    if(idx % 2 == 0)\n        {\n            // The element is at the even index.\n\
    \            // We will only add it to our sum if it is odd.\n            // lst[idx]\
    \ % 2 will return the remainder of (lst[idx] / 2).\n            // If lst[idx]\
    \ is even, the remainder will be 0.\n            // If lst[idx] is odd, the remainder\
    \ will be 1.\n            // We only want to add the number to our sum if it is\
    \ odd.\n            if(lst[idx] % 2 == 1)\n            {\n                // Even\
    \ index and odd element.\n                // Add the element to our return value.\n\
    \                ret += lst[idx];\n            }\n        }\n    }\n    // All\
    \ done.\n    return ret;\n}\n// TEST_CODE", "{\n  long count = 0;\n  for(int i\
    \ = 0; i < lst.length; i++)\n  {\n    if((i + 1) % 2 == 0 && lst[i] % 2 != 0)\n\
    \    {\n      count += lst[i];\n    }\n  }\n  return count;\n}", "{\n    ulong\
    \ sz = lst.length;\n    long sum = 0;\n    for (ulong i = 0; i < sz; i += 2)\n\
    \    {\n        if (lst[i] % 2 != 0)\n        {\n            sum += lst[i];\n\
    \        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(idx,\
    \ item; lst)\n    {\n        if(idx % 2 == 0 && item % 2 != 0) sum += item;\n\
    \    }\n    return sum;\n}", "{\n    long res = 0;\n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        //std.conv.to!string(lst[i]).length > 2\n        if(lst[i]\
    \ % 2 != 0 && i % 2 == 0)\n        {\n            res += lst[i];\n        }\n\
    \    }\n    return res;\n}", "{\n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    long sum = 0;\n    long[] temp = new long[lst.length];\n\
    \    long[] temp2 = new long[lst.length];\n    foreach(el;lst)\n    {\n      \
    \  if(el%2 == 0)\n        {\n            temp.insertBack(el);\n        }\n   \
    \ }\n    for(int i = 1; i<=temp.length;i+=2)\n    {\n        temp2.insertBack(temp[i]);\n\
    \    }\n    foreach(el;temp2)\n    {\n        sum+=el;\n    }\n    return sum;\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n}", "{\n    long oddSum = 0;\n\
    \    foreach(idx, x; enumerate(lst)) {\n        if (idx % 2 == 0 && x % 2 == 1)\
    \ {\n            oddSum += x;\n        }\n    }\n    return oddSum;\n}", "{\n\
    \  alias tuple!(long,long) tup;\n  auto reduce = reduce!((a,b) => a+b);\n  auto\
    \ pairs = map!(tup(index,x) => (index,x))(iota(0L,lst.length));\n  auto filtered\
    \ = filter!((i,l) => i%2 == 0 && l%2 != 0)(pairs);\n  auto mapped = map!((i,l)\
    \ => l)(filtered);\n  return reduce(mapped);\n}", "{\n  long sum = 0;\n  foreach(var\
    \ i, int j; zip(lst, iota(lst.length)))\n  {\n    if(i % 2 == 0 && j % 2 == 1)\n\
    \      sum += j;\n  }\n  return sum;\n}", "{\n  long result = 0;\n  foreach(idx,\
    \ element; lst)\n  {\n    if(idx % 2 == 0 && element % 2 != 0)\n    {\n      result\
    \ += element;\n    }\n  }\n  return result;\n}", "{\n    int sum = 0;\n    foreach(idx,\
    \ e; lst)\n    {\n        if(idx % 2 == 0 && e % 2 != 0)\n        {\n        \
    \    sum += e;\n        }\n    }\n    return sum;\n}", "{\n    // Your code goes\
    \ here\n    long n = lst.length;\n    long sum = 0;\n    for(long i = 0; i < n;\
    \ i++)\n    {\n        if((i % 2 == 0) && (lst[i] % 2 != 0))\n        {\n    \
    \        sum += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    return\
    \ zip(lst, iota(lst.length)).filter!(x => x[1] % 2 == 0).filter!(x => x[0] % 2\
    \ == 1).map!(x => x[0]).sum;\n}", "{\n    return lst.enumerate.filter!(x => x.index\
    \ % 2 == 0).filter!(x => x.value % 2 == 1).map!(x => x.value).sum;\n}", "{\n \
    \   long sum = 0;\n    int index = 0;\n    foreach(a; lst)\n    {\n        if\
    \ (a % 2 == 1 && index % 2 == 0)\n        {\n            sum += a;\n        }\n\
    \        index++;\n    }\n    return sum;\n}", "{\n    long res = 0;\n    foreach(i,\
    \ el; lst)\n    {\n        if(el % 2 != 0 && i % 2 == 0)\n        {\n        \
    \    res += el;\n        }\n    }\n    return res;\n}", "{\n    int length = lst.length;\n\
    \    long total = 0;\n    for (int i = 0; i < length; i += 2)\n    {\n       \
    \ if (lst[i] & 1)\n        {\n            total += lst[i];\n        }\n    }\n\
    \    return total;\n}", "{\n    return lst.length > 0 ? lst.filter!(x => x % 2\
    \ != 0).sum : 0;\n}", "{\n    static assert(lst.length > 0);\n    static assert(lst.length\
    \ <= 100_000);\n    static assert(all!(element => element >= 0 && element <= 100_000));\n\
    \    long result = 0;\n    foreach(idx, item; zip(iota(0, lst.length), lst))\n\
    \    {\n        if(idx % 2 == 0 && item % 2 == 1)\n        {\n            result\
    \ += item;\n        }\n    }\n    return result;\n}", "{\n  Tuple!(long, long)\
    \ oddPositions = iota(0L, lst.length)\n      .filter!(i => i % 2 == 0)\n     \
    \ .filter!(i => lst[i] % 2 == 1)\n      .reduce!(\n        (a, b) => a + lst[b],\n\
    \        0L\n      );\n  return oddPositions[0];\n}", "{\n    return lst.length\
    \ % 2 == 0 ? 0 : (lst[0] + lst[lst.length - 1]);\n}", "{\n    long res = 0;\n\
    \    for(long i = 0; i < lst.length; i++)\n    {\n        if(i % 2 == 0 && lst[i]\
    \ % 2 != 0)\n        {\n            res += lst[i];\n        }\n    }\n    return\
    \ res;\n}", "{\n    long odd = 0;\n    for(int i = 0; i < lst.length; i++)\n \
    \   {\n        if(isOdd(lst[i]) && isEven(i))\n        {\n            odd += lst[i];\n\
    \        }\n    }\n    return odd;\n}", "{\n    long sum = 0;\n    if(lst.length\
    \ < 2) return sum;\n    foreach(i, v; lst)\n    {\n        if(i % 2 == 0 && v\
    \ % 2 != 0)\n        {\n            sum += v;\n        }\n    }\n    return sum;\n\
    }", "{ \n\tint i=0;\n\tlong sum = 0;\n\tforeach(e; lst) {\n\t\tif (i%2==0 && e%2==1)\
    \ {\n\t\t\tsum+=e;\n\t\t}\n\t\ti++;\n\t}\n    return sum;\n}", "{\n    //# your\
    \ code here\n    long sum = 0;\n    foreach(i, e; lst) {\n        if(isOdd(i)\
    \ && isEven(e)) {\n            sum += e;\n        }\n    }\n    return sum;\n}",
  "{\n    long result = 0;\n    foreach(el;iota(lst.length))\n    {\n        if(el\
    \ % 2 == 0 && lst[el] % 2 != 0)\n        {\n            result += lst[el];\n \
    \       }\n    }\n    return result;\n}", "{\n    long sum = 0;\n    for (int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(i % 2 == 0 && lst[i] % 2 != 0)\n\
    \        {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
  "{\n    long total = 0;\n    int pos = 0;\n    foreach(elem; lst)\n    {\n     \
    \   if(pos % 2 == 0 && elem % 2 != 0)\n        {\n            total += elem;\n\
    \        }\n        pos++;\n    }\n    return total;\n}", "{\n    return lst.length.iota.filter!(x\
    \ => x % 2 == 0).map!(x => lst[x]).filter!(x => x % 2 == 1).sum;\n}", "{\n   \
    \ long ret = 0;\n    for(long i = 0; i < lst.length; i++)\n    {\n        if(i\
    \ % 2 == 0 && lst[i] % 2 != 0)\n        {\n            ret += lst[i];\n      \
    \  }\n    }\n    return ret;\n}", "{\n    long sum = 0;\n    for (int i = 0; i\
    \ < lst.length; i += 2)\n    {\n        if (lst[i] % 2 != 0)\n        {\n    \
    \        sum += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long sum\
    \ = 0;\n    for (int i = 0; i < lst.length; i += 2)\n    {\n        if (lst[i]\
    \ % 2 == 1)\n        {\n            sum += lst[i];\n        }\n    }\n    return\
    \ sum;\n}", "{\n    long res = 0;\n    foreach(i, e; lst)\n    {\n        if(i\
    \ % 2 != 0 && e % 2 == 0)\n        {\n            res += e;\n        }\n    }\n\
    \    return res;\n}", "{\n    long result = 0;\n    foreach(e; iota(lst.length))\n\
    \    {\n        if(isOdd(e) && isEven(lst[e]))\n        {\n            result\
    \ += lst[e];\n        }\n    }\n    return result;\n}", "{\n    long result =\
    \ 0;\n    for (long i = 0; i < lst.length; i++)\n    {\n        if (i % 2 == 0\
    \ && lst[i] % 2 != 0)\n        {\n            result += lst[i];\n        }\n \
    \   }\n    return result;\n}", "{\n    long sum = 0;\n    foreach(i, el; lst)\n\
    \    {\n        if(i % 2 == 0 && el % 2 != 0)\n        {\n            sum += el;\n\
    \        }\n    }\n    return sum;\n}", "{\n    long sol = 0;\n    foreach(i,e;enumerate(lst))\n\
    \    {\n        if(i%2==0 && e%2!=0)\n        {\n            sol+=e;\n       \
    \ }\n    }\n    return sol;\n}", "{\n    long res = 0;\n    for(int i = 0; i <\
    \ lst.length; i++)\n    {\n        if(lst[i] % 2 == 1 && i % 2 == 0)\n       \
    \ {\n            res += lst[i];\n        }\n    }\n    return res;\n}", "{\n \
    \ return zip(lst, cycle(0l, 1l))\n    .filter!(t => isOdd(t[1]))\n    .map!(t\
    \ => t[0])\n    .sum;\n}", "{\n    return lst.enumerate()\n        .filter!(t\
    \ => t[0] & 1)\n        .map!(t => t[1])\n        .filter!(n => n & 1)\n     \
    \   .reduce!(a, b => a + b)(0L);\n}", "{\n    long r = 0;\n    foreach(int i,\
    \ long n; lst)\n    {\n        if(i % 2 == 0 && n % 2 == 1)\n            r +=\
    \ n;\n    }\n    return r;\n}", "{\n    return lst.indices.filter!(x => x % 2\
    \ == 0).sum(x => lst[x]);\n}", "{\n    if (lst.length == 0)\n        return 0;\n\
    \    else if (lst.length == 1)\n        return lst[0];\n    else\n    {\n    \
    \    long res = 0;\n        foreach (i, num; lst)\n        {\n            if (i\
    \ % 2 == 0 && num % 2 != 0)\n                res += num;\n        }\n        return\
    \ res;\n    }\n}", "{\n    long sum = 0;\n    for (int i = 0; i < lst.length;\
    \ i+=2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n      \
    \  }\n    }\n    return sum;\n}", "{\n  return sum(enumerate(lst).filter!(t =>\
    \ t[0] % 2 == 0 && t[1] % 2 == 1));\n}", "{\n    long answer = 0;\n    for(int\
    \ i = 1; i < lst.length; i += 2)\n    {\n        if(lst[i] % 2 == 0)\n       \
    \ {\n            answer += lst[i];\n        }\n    }\n    return answer;\n}",
  "{\n    long result = 0;\n    for (long i = 0; i < lst.length; i++)\n    {\n   \
    \     if (lst[i] % 2 == 1 && i % 2 == 0)\n        {\n            result += lst[i];\n\
    \        }\n    }\n    return result;\n}", "{\n    \n    \n    long odd = 0;\n\
    \    if(lst.length == 1)\n    {\n        return lst[0];\n    }\n    else if(lst.length\
    \ % 2 == 0)\n    {\n        for(size_t i = 0; i < lst.length; i++)\n        {\n\
    \            if(i % 2 == 0)\n            {\n                odd += lst[i];\n \
    \           }\n        }\n    }\n    else if(lst.length % 2 != 0)\n    {\n   \
    \     for(size_t i = 0; i < lst.length; i++)\n        {\n            if(i % 2\
    \ != 0)\n            {\n                odd += lst[i];\n            }\n      \
    \  }\n    }\n    return odd;\n}\n/*\nGiven a string, determine whether it is a\
    \ palindrome (reads the same both ways).\n    ", "{\n    //long result = 0;\n\
    \    /*\n    long [] odd = lst.filter!((long x) => x % 2L == 1L);\n    long []\
    \ even = lst.filter!((long x) => x % 2L == 0L);\n    long [] oddEven = odd.filter!((long\
    \ x) => lst.indexOf(x) % 2L == 0L);\n    oddEven.reduce!((a, b) => a + b);\n \
    \   */\n    //for(int i = 0; i < lst.length; i += 2)\n        //if(lst[i] % 2L\
    \ == 1L)\n            //result += lst[i];\n    return lst.filter!((long x) =>\
    \ x % 2L == 1L)\n        .filter!((long x) => lst.indexOf(x) % 2L == 0L)\n   \
    \     .reduce!((a, b) => a + b);\n}", "{\n    return lst.enumerate()\n       \
    \ .filter!(t => t[0] % 2 == 0 && t[1] % 2 == 1)\n        .map!(t => t[1])\n  \
    \      .sum;\n}", "{\n    long result = 0;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] % 2 != 0 && i % 2 == 0)\n        {\n       \
    \     result += lst[i];\n        }\n    }\n    return result;\n}", "{\n    long\
    \ sum = 0;\n    int counter = 0;\n    foreach(x; lst)\n    {\n        if (counter\
    \ % 2 == 0 && x % 2 != 0)\n        {\n            sum += x;\n        }\n     \
    \   counter++;\n    }\n    return sum;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
