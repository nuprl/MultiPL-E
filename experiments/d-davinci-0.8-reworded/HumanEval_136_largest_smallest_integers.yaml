name: HumanEval_136_largest_smallest_integers
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
  \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and\
  \ 'b' is the smallest\n    of positive integers in an array.\n    If there is no\
  \ negative or positive integers, return them as null.\n\n    Examples:\n    >>>\
  \ largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n   \
  \ >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
  \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n     \
  \   auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
  \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get ==\
  \ 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
  \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
  \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
  \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n\
  \        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto\
  \ result = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
  }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
  \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
  \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
  \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
  \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get ==\
  \ 1L);\n}\n\n}\nvoid main(){}"
completions: ["{\n    if(lst.length == 0)\n        return tuple(null, null);\n   \
    \ else\n    {\n        long max_neg = -2147483648L;\n        long min_pos = 2147483647L;\n\
    \        foreach(x; lst)\n        {\n            if(x<0)\n                max_neg\
    \ = max(max_neg, x);\n            else if(x>0)\n                min_pos = min(min_pos,\
    \ x);\n        }\n        return tuple(max_neg == -2147483648L ? null : max_neg,\
    \ min_pos == 2147483647L ? null : min_pos);\n    }\n}", "{\n    Nullable!(long)\
    \ a = Nullable!(long).init;\n    Nullable!(long) b = Nullable!(long).init;\n \
    \   foreach(x; lst)\n    {\n        if(x < 0L)\n        {\n            if(!a.isNull\
    \ || a < x)\n            {\n                a = x;\n            }\n        }\n\
    \        else if(x > 0L)\n        {\n            if(!b.isNull || b > x)\n    \
    \        {\n                b = x;\n            }\n        }\n    }\n    return\
    \ tuple(a, b);\n}", "{\n    Nullable!(long) max_neg;\n    Nullable!(long) min_pos;\n\
    \    foreach(idx, item; lst) \n    {\n        if (item < 0) \n        {\n    \
    \        if (!max_neg.isNull) \n            {\n                if (max_neg.get\
    \ < item) \n                {\n                    max_neg = item;\n         \
    \       }\n            }\n            else \n            {\n                max_neg\
    \ = item;\n            }\n        }\n        else if (item > 0) \n        {\n\
    \            if (!min_pos.isNull) \n            {\n                if (min_pos.get\
    \ > item) \n                {\n                    min_pos = item;\n         \
    \       }\n            }\n            else \n            {\n                min_pos\
    \ = item;\n            }\n        }\n    }\n    return tuple(max_neg, min_pos);\n\
    }", "{\n    Nullable!(long) small = Nullable!(long)();\n    Nullable!(long) large\
    \ = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i < 0)\n      \
    \  {\n            if(i < small.getOrDefault)\n            {\n                small\
    \ = Nullable!(long)(i);\n            }\n        }\n        else if(i > 0)\n  \
    \      {\n            if(i > large.getOrDefault)\n            {\n            \
    \    large = Nullable!(long)(i);\n            }\n        }\n    }\n    return\
    \ tuple(large, small);\n}", "{\n\tNullable!(long) maxNeg = null;\n\tNullable!(long)\
    \ minPos = null;\n\tforeach(num; lst)\n\t{\n\t\tif(num > 0)\n\t\t{\n\t\t\tif(minPos\
    \ is null || num < minPos)\n\t\t\t\tminPos = num;\n\t\t}\n\t\telse if(num < 0)\n\
    \t\t{\n\t\t\tif(maxNeg is null || num > maxNeg)\n\t\t\t\tmaxNeg = num;\n\t\t}\n\
    \t}\n\treturn tuple(maxNeg, minPos);\n}", "{\n    Nullable!(long) neg = null;\n\
    \    Nullable!(long) pos = null;\n    foreach(n; lst)\n    {\n        if(n < 0)\n\
    \        {\n            if(neg is null || neg < n)\n                neg = n;\n\
    \        }\n        else if(n > 0)\n        {\n            if(pos is null || pos\
    \ > n)\n                pos = n;\n        }\n    }\n    return tuple(neg, pos);\n\
    }", "{\n    Nullable!(long) largest_neg;\n    Nullable!(long) smallest_pos;\n\
    \    foreach(x; lst) \n    {\n        if(x < 0)\n        {\n            if(!largest_neg.isNull)\n\
    \            {\n                if(largest_neg.get < x)\n                {\n \
    \                   largest_neg = x;\n                }\n            }\n     \
    \       else\n            {\n                largest_neg = x;\n            }\n\
    \        }\n        else if(x > 0)\n        {\n            if(!smallest_pos.isNull)\n\
    \            {\n                if(smallest_pos.get > x)\n                {\n\
    \                    smallest_pos = x;\n                }\n            }\n   \
    \         else\n            {\n                smallest_pos = x;\n           \
    \ }\n        }\n    }\n    return tuple(largest_neg, smallest_pos);\n}", "{\n\
    \    auto biggest = lst.filter!(x => x < 0).sort.front;\n    auto smallest = lst.filter!(x\
    \ => x > 0).sort.front;\n    return tuple(biggest, smallest);\n}\n \n/*", "{\n\
    \    return tuple(null, null);\n}", "{\n    Nullable!(long) a = null;\n    Nullable!(long)\
    \ b = null;\n    foreach(item; lst) \n    {\n        if(item > 0)\n        {\n\
    \            if(b is null)\n            {\n                b = item;\n       \
    \     }\n            else\n            {\n                b = min(b, item);\n\
    \            }\n        }\n        else if(item < 0)\n        {\n            if(a\
    \ is null)\n            {\n                a = item;\n            }\n        \
    \    else\n            {\n                a = max(a, item);\n            }\n \
    \       }\n    }\n    return tuple(a, b);\n}\nassert(largest_smallest_integers([2L,\
    \ 4L, 1L, 3L, 5L, 7L]) == tuple(null, 1L));\nassert(largest_smallest_integers([])\
    \ == tuple(null, null));\nassert(largest_smallest_integers([0L]) == tuple(null,\
    \ null));", "{\n    Nullable!(long) largeNegative = null;\n    Nullable!(long)\
    \ smallPositive = null;\n    foreach(element; lst) \n    {\n        if(element\
    \ > 0) \n        {\n            if(smallPositive is null) \n            {\n  \
    \              smallPositive = element;\n            }\n            else if(element\
    \ < smallPositive) \n            {\n                smallPositive = element;\n\
    \            }\n        }\n        else if(element < 0) \n        {\n        \
    \    if(largeNegative is null) \n            {\n                largeNegative\
    \ = element;\n            }\n            else if(element > largeNegative) \n \
    \           {\n                largeNegative = element;\n            }\n     \
    \   }\n    }\n    return tuple(largeNegative, smallPositive);\n}", "{\n    import\
    \ std.typecons;\n    Nullable!(long) largestNegative = null;\n    Nullable!(long)\
    \ smallestPositive = null;\n    foreach(x; lst) \n    {\n        if(x < 0) \n\
    \        {\n            if(largestNegative.isNull || x > largestNegative.get)\n\
    \                largestNegative = x;\n        }\n        else if(x > 0) \n  \
    \      {\n            if(smallestPositive.isNull || x < smallestPositive.get)\n\
    \                smallestPositive = x;\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}", "{\n    auto a = null;\n    auto b = null;\n    foreach(l;\
    \ lst)\n    {\n        if(l > 0)\n        {\n            if(b is null)\n     \
    \       {\n                b = l;\n            }\n            else\n         \
    \   {\n                b = min(b, l);\n            }\n        }\n        else\
    \ if(l < 0)\n        {\n            if(a is null)\n            {\n           \
    \     a = l;\n            }\n            else\n            {\n               \
    \ a = max(a, l);\n            }\n        }\n    }\n    return tuple(a, b);\n}",
  "{\n    auto maxNeg = lst.filter!((e) => e < 0L).max();\n    auto minPos = lst.filter!((e)\
    \ => e > 0L).min();\n    return tuple(maxNeg, minPos);\n}", "{\n    return tuple(null,\
    \ 1L);\n}\n ", "{\n    Nullable!(long) largestNegative = Nullable!(long)();\n\
    \    Nullable!(long) smallestPositive = Nullable!(long)();\n    foreach(index,\
    \ i; lst)\n    {\n        if(i < 0)\n        {\n            if(largestNegative.isNull\
    \ || largestNegative.get > i)\n            {\n                largestNegative\
    \ = Nullable!(long)(i);\n            }\n        }\n        else if(i > 0)\n  \
    \      {\n            if(smallestPositive.isNull || smallestPositive.get > i)\n\
    \            {\n                smallestPositive = Nullable!(long)(i);\n     \
    \       }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }", "{\n    Nullable!(long) largest_negative;\n    Nullable!(long) smallest_positive;\n\
    \    foreach(long n; lst)\n    {\n        if(n < 0)\n        {\n            if(largest_negative.isNull)\n\
    \            {\n                largest_negative = n;\n            }\n       \
    \     else\n            {\n                largest_negative = max(largest_negative,\
    \ n);\n            }\n        }\n        else if(n > 0)\n        {\n         \
    \   if(smallest_positive.isNull)\n            {\n                smallest_positive\
    \ = n;\n            }\n            else\n            {\n                smallest_positive\
    \ = min(smallest_positive, n);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\n/*", "{\n    Nullable!(long) largest = Nullable!(long)();\n\
    \    Nullable!(long) smallest = Nullable!(long)();\n    foreach(l; lst)\n    {\n\
    \        if(l < 0L)\n        {\n            if(!largest || l > largest.get)\n\
    \            {\n                largest = Nullable!(long)(l);\n            }\n\
    \        }\n        else if(l > 0L)\n        {\n            if(!smallest || l\
    \ < smallest.get)\n            {\n                smallest = Nullable!(long)(l);\n\
    \            }\n        }\n    }\n    return tuple(largest, smallest);\n}", "{\n\
    \    long maxNum = long.min;\n    long minNum = long.max;\n    foreach(num; lst)\
    \ \n    {\n        if(num > 0L) \n        {\n            minNum = min(minNum,\
    \ num);\n        }\n        else \n        {\n            maxNum = max(maxNum,\
    \ num);\n        }\n    }\n    Nullable!(long) a = Nullable!(long)(maxNum);\n\
    \    Nullable!(long) b = Nullable!(long)(minNum);\n    if(maxNum == long.min)\
    \ a = null;\n    if(minNum == long.max) b = null;\n    return tuple(a, b);\n}\n\
    \ ", "{\n    Nullable!(long) maxNeg = Nullable!(long)();\n    Nullable!(long)\
    \ minPos = Nullable!(long)();\n    foreach(e; lst) \n    {\n        if(e < 0L)\
    \ \n        {\n            if(maxNeg.isNull)\n                maxNeg = Nullable!(long)(e);\n\
    \            else\n                maxNeg = max(maxNeg.get, e);\n        }\n \
    \       else if(e > 0L) \n        {\n            if(minPos.isNull)\n         \
    \       minPos = Nullable!(long)(e);\n            else\n                minPos\
    \ = min(minPos.get, e);\n        }\n    }\n    return tuple(maxNeg, minPos);\n\
    }\n/*\n    Create a function that returns an array of prime numbers that are not\
    \ greater than the \n    given number. The array should be sorted in increasing\
    \ order, and the number of prime \n    numbers should be equal to the given number.\n\
    \    Examples:\n    >>> prime_numbers(3)\n    [2L, 3L]\n    >>> prime_numbers(7)\n\
    \    [2L, 3L, 5L, 7L]\n    >>> prime_numbers(1)\n    [2L]\n    >>> prime_numbers(4)\n\
    \    [2L, 3L, 5L]\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
