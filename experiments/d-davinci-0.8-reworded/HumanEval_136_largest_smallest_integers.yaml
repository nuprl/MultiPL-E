name: HumanEval_136_largest_smallest_integers
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
  \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and\
  \ 'b' is the smallest\n    of positive integers in an array.\n    If there is no\
  \ negative or positive integers, return them as null.\n\n    Examples:\n    >>>\
  \ largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n   \
  \ >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
  \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n     \
  \   auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
  \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get ==\
  \ 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
  \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
  \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
  \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n\
  \        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto\
  \ result = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
  }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
  \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
  \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
  \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
  \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get ==\
  \ 1L);\n}\n\n}\nvoid main(){}"
completions: ["{\n    if(lst.length == 0)\n        return tuple(null, null);\n   \
    \ else\n    {\n        long max_neg = -2147483648L;\n        long min_pos = 2147483647L;\n\
    \        foreach(x; lst)\n        {\n            if(x<0)\n                max_neg\
    \ = max(max_neg, x);\n            else if(x>0)\n                min_pos = min(min_pos,\
    \ x);\n        }\n        return tuple(max_neg == -2147483648L ? null : max_neg,\
    \ min_pos == 2147483647L ? null : min_pos);\n    }\n}", "{\n    Nullable!(long)\
    \ a = Nullable!(long).init;\n    Nullable!(long) b = Nullable!(long).init;\n \
    \   foreach(x; lst)\n    {\n        if(x < 0L)\n        {\n            if(!a.isNull\
    \ || a < x)\n            {\n                a = x;\n            }\n        }\n\
    \        else if(x > 0L)\n        {\n            if(!b.isNull || b > x)\n    \
    \        {\n                b = x;\n            }\n        }\n    }\n    return\
    \ tuple(a, b);\n}", "{\n    Nullable!(long) max_neg;\n    Nullable!(long) min_pos;\n\
    \    foreach(idx, item; lst) \n    {\n        if (item < 0) \n        {\n    \
    \        if (!max_neg.isNull) \n            {\n                if (max_neg.get\
    \ < item) \n                {\n                    max_neg = item;\n         \
    \       }\n            }\n            else \n            {\n                max_neg\
    \ = item;\n            }\n        }\n        else if (item > 0) \n        {\n\
    \            if (!min_pos.isNull) \n            {\n                if (min_pos.get\
    \ > item) \n                {\n                    min_pos = item;\n         \
    \       }\n            }\n            else \n            {\n                min_pos\
    \ = item;\n            }\n        }\n    }\n    return tuple(max_neg, min_pos);\n\
    }", "{\n    Nullable!(long) small = Nullable!(long)();\n    Nullable!(long) large\
    \ = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i < 0)\n      \
    \  {\n            if(i < small.getOrDefault)\n            {\n                small\
    \ = Nullable!(long)(i);\n            }\n        }\n        else if(i > 0)\n  \
    \      {\n            if(i > large.getOrDefault)\n            {\n            \
    \    large = Nullable!(long)(i);\n            }\n        }\n    }\n    return\
    \ tuple(large, small);\n}", "{\n\tNullable!(long) maxNeg = null;\n\tNullable!(long)\
    \ minPos = null;\n\tforeach(num; lst)\n\t{\n\t\tif(num > 0)\n\t\t{\n\t\t\tif(minPos\
    \ is null || num < minPos)\n\t\t\t\tminPos = num;\n\t\t}\n\t\telse if(num < 0)\n\
    \t\t{\n\t\t\tif(maxNeg is null || num > maxNeg)\n\t\t\t\tmaxNeg = num;\n\t\t}\n\
    \t}\n\treturn tuple(maxNeg, minPos);\n}", "{\n    Nullable!(long) neg = null;\n\
    \    Nullable!(long) pos = null;\n    foreach(n; lst)\n    {\n        if(n < 0)\n\
    \        {\n            if(neg is null || neg < n)\n                neg = n;\n\
    \        }\n        else if(n > 0)\n        {\n            if(pos is null || pos\
    \ > n)\n                pos = n;\n        }\n    }\n    return tuple(neg, pos);\n\
    }", "{\n    Nullable!(long) largest_neg;\n    Nullable!(long) smallest_pos;\n\
    \    foreach(x; lst) \n    {\n        if(x < 0)\n        {\n            if(!largest_neg.isNull)\n\
    \            {\n                if(largest_neg.get < x)\n                {\n \
    \                   largest_neg = x;\n                }\n            }\n     \
    \       else\n            {\n                largest_neg = x;\n            }\n\
    \        }\n        else if(x > 0)\n        {\n            if(!smallest_pos.isNull)\n\
    \            {\n                if(smallest_pos.get > x)\n                {\n\
    \                    smallest_pos = x;\n                }\n            }\n   \
    \         else\n            {\n                smallest_pos = x;\n           \
    \ }\n        }\n    }\n    return tuple(largest_neg, smallest_pos);\n}", "{\n\
    \    auto biggest = lst.filter!(x => x < 0).sort.front;\n    auto smallest = lst.filter!(x\
    \ => x > 0).sort.front;\n    return tuple(biggest, smallest);\n}\n \n/*", "{\n\
    \    return tuple(null, null);\n}", "{\n    Nullable!(long) a = null;\n    Nullable!(long)\
    \ b = null;\n    foreach(item; lst) \n    {\n        if(item > 0)\n        {\n\
    \            if(b is null)\n            {\n                b = item;\n       \
    \     }\n            else\n            {\n                b = min(b, item);\n\
    \            }\n        }\n        else if(item < 0)\n        {\n            if(a\
    \ is null)\n            {\n                a = item;\n            }\n        \
    \    else\n            {\n                a = max(a, item);\n            }\n \
    \       }\n    }\n    return tuple(a, b);\n}\nassert(largest_smallest_integers([2L,\
    \ 4L, 1L, 3L, 5L, 7L]) == tuple(null, 1L));\nassert(largest_smallest_integers([])\
    \ == tuple(null, null));\nassert(largest_smallest_integers([0L]) == tuple(null,\
    \ null));", "{\n    Nullable!(long) largeNegative = null;\n    Nullable!(long)\
    \ smallPositive = null;\n    foreach(element; lst) \n    {\n        if(element\
    \ > 0) \n        {\n            if(smallPositive is null) \n            {\n  \
    \              smallPositive = element;\n            }\n            else if(element\
    \ < smallPositive) \n            {\n                smallPositive = element;\n\
    \            }\n        }\n        else if(element < 0) \n        {\n        \
    \    if(largeNegative is null) \n            {\n                largeNegative\
    \ = element;\n            }\n            else if(element > largeNegative) \n \
    \           {\n                largeNegative = element;\n            }\n     \
    \   }\n    }\n    return tuple(largeNegative, smallPositive);\n}", "{\n    import\
    \ std.typecons;\n    Nullable!(long) largestNegative = null;\n    Nullable!(long)\
    \ smallestPositive = null;\n    foreach(x; lst) \n    {\n        if(x < 0) \n\
    \        {\n            if(largestNegative.isNull || x > largestNegative.get)\n\
    \                largestNegative = x;\n        }\n        else if(x > 0) \n  \
    \      {\n            if(smallestPositive.isNull || x < smallestPositive.get)\n\
    \                smallestPositive = x;\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}", "{\n    auto a = null;\n    auto b = null;\n    foreach(l;\
    \ lst)\n    {\n        if(l > 0)\n        {\n            if(b is null)\n     \
    \       {\n                b = l;\n            }\n            else\n         \
    \   {\n                b = min(b, l);\n            }\n        }\n        else\
    \ if(l < 0)\n        {\n            if(a is null)\n            {\n           \
    \     a = l;\n            }\n            else\n            {\n               \
    \ a = max(a, l);\n            }\n        }\n    }\n    return tuple(a, b);\n}",
  "{\n    auto maxNeg = lst.filter!((e) => e < 0L).max();\n    auto minPos = lst.filter!((e)\
    \ => e > 0L).min();\n    return tuple(maxNeg, minPos);\n}", "{\n    return tuple(null,\
    \ 1L);\n}\n ", "{\n    Nullable!(long) largestNegative = Nullable!(long)();\n\
    \    Nullable!(long) smallestPositive = Nullable!(long)();\n    foreach(index,\
    \ i; lst)\n    {\n        if(i < 0)\n        {\n            if(largestNegative.isNull\
    \ || largestNegative.get > i)\n            {\n                largestNegative\
    \ = Nullable!(long)(i);\n            }\n        }\n        else if(i > 0)\n  \
    \      {\n            if(smallestPositive.isNull || smallestPositive.get > i)\n\
    \            {\n                smallestPositive = Nullable!(long)(i);\n     \
    \       }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }", "{\n    Nullable!(long) largest_negative;\n    Nullable!(long) smallest_positive;\n\
    \    foreach(long n; lst)\n    {\n        if(n < 0)\n        {\n            if(largest_negative.isNull)\n\
    \            {\n                largest_negative = n;\n            }\n       \
    \     else\n            {\n                largest_negative = max(largest_negative,\
    \ n);\n            }\n        }\n        else if(n > 0)\n        {\n         \
    \   if(smallest_positive.isNull)\n            {\n                smallest_positive\
    \ = n;\n            }\n            else\n            {\n                smallest_positive\
    \ = min(smallest_positive, n);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\n/*", "{\n    Nullable!(long) largest = Nullable!(long)();\n\
    \    Nullable!(long) smallest = Nullable!(long)();\n    foreach(l; lst)\n    {\n\
    \        if(l < 0L)\n        {\n            if(!largest || l > largest.get)\n\
    \            {\n                largest = Nullable!(long)(l);\n            }\n\
    \        }\n        else if(l > 0L)\n        {\n            if(!smallest || l\
    \ < smallest.get)\n            {\n                smallest = Nullable!(long)(l);\n\
    \            }\n        }\n    }\n    return tuple(largest, smallest);\n}", "{\n\
    \    long maxNum = long.min;\n    long minNum = long.max;\n    foreach(num; lst)\
    \ \n    {\n        if(num > 0L) \n        {\n            minNum = min(minNum,\
    \ num);\n        }\n        else \n        {\n            maxNum = max(maxNum,\
    \ num);\n        }\n    }\n    Nullable!(long) a = Nullable!(long)(maxNum);\n\
    \    Nullable!(long) b = Nullable!(long)(minNum);\n    if(maxNum == long.min)\
    \ a = null;\n    if(minNum == long.max) b = null;\n    return tuple(a, b);\n}\n\
    \ ", "{\n    Nullable!(long) maxNeg = Nullable!(long)();\n    Nullable!(long)\
    \ minPos = Nullable!(long)();\n    foreach(e; lst) \n    {\n        if(e < 0L)\
    \ \n        {\n            if(maxNeg.isNull)\n                maxNeg = Nullable!(long)(e);\n\
    \            else\n                maxNeg = max(maxNeg.get, e);\n        }\n \
    \       else if(e > 0L) \n        {\n            if(minPos.isNull)\n         \
    \       minPos = Nullable!(long)(e);\n            else\n                minPos\
    \ = min(minPos.get, e);\n        }\n    }\n    return tuple(maxNeg, minPos);\n\
    }\n/*\n    Create a function that returns an array of prime numbers that are not\
    \ greater than the \n    given number. The array should be sorted in increasing\
    \ order, and the number of prime \n    numbers should be equal to the given number.\n\
    \    Examples:\n    >>> prime_numbers(3)\n    [2L, 3L]\n    >>> prime_numbers(7)\n\
    \    [2L, 3L, 5L, 7L]\n    >>> prime_numbers(1)\n    [2L]\n    >>> prime_numbers(4)\n\
    \    [2L, 3L, 5L]\n*/", "{\n    Nullable!(long) largest_negative_integer;\n  \
    \  Nullable!(long) smallest_positive_integer;\n    foreach(l; lst) \n    {\n \
    \       if(l < 0L) \n        {\n            if(!largest_negative_integer.isNull\
    \ || largest_negative_integer < l) \n            {\n                largest_negative_integer\
    \ = l;\n            }\n        }\n        else if(l > 0L) \n        {\n      \
    \      if(smallest_positive_integer.isNull || smallest_positive_integer > l) \n\
    \            {\n                smallest_positive_integer = l;\n            }\n\
    \        }\n    }\n    return tuple(largest_negative_integer, smallest_positive_integer);\n\
    }", "{\n    if (lst.length == 0) return tuple(Nullable!(long)(), Nullable!(long)());\n\
    \    else\n    {\n        const int MAX_INT = 2147483647;\n        long largest\
    \ = -MAX_INT;\n        long smallest = MAX_INT;\n        foreach (long l; lst)\n\
    \        {\n            if (l > 0 && l < smallest) smallest = l;\n           \
    \ if (l < 0 && l > largest) largest = l;\n        }\n        return tuple(largest\
    \ == -MAX_INT ? Nullable!(long)() : Nullable!(long)(largest),\n              \
    \        smallest == MAX_INT ? Nullable!(long)() : Nullable!(long)(smallest));\n\
    \    }\n}\n// Create a function that checks if a given matrix is a\n// symmetric\
    \ matrix. If it is, return true, else return false.", "{\n    auto tmp = lst.filter!(a\
    \ => a < 0L).max();\n    long a = tmp.isNull ? long.min : tmp.get;\n    tmp =\
    \ lst.filter!(a => a > 0L).min();\n    long b = tmp.isNull ? long.max : tmp.get;\n\
    \    return tuple(nullable!long(a), nullable!long(b));\n}", "{\n    Nullable!(long)\
    \ mn;\n    Nullable!(long) mx;\n    if (lst.length > 0)\n    {\n        // scope(exit)\
    \ { writeln(\"scope exit\"); };\n        // scope(failure) { writeln(\"scope failure\"\
    ); };\n        // scope(success) { writeln(\"scope success\"); };\n        for\
    \ (int i = 0; i < lst.length; i++)\n        {\n            if (lst[i] > 0)\n \
    \           {\n                if (mx.isNull)\n                {\n           \
    \         mx = lst[i];\n                }\n                else\n            \
    \    {\n                    mx = min(mx, lst[i]);\n                }\n       \
    \     }\n            else if (lst[i] < 0)\n            {\n                if (mn.isNull)\n\
    \                {\n                    mn = lst[i];\n                }\n    \
    \            else\n                {\n                    mn = max(mn, lst[i]);\n\
    \                }\n            }\n        }\n    }\n    return tuple(mn, mx);\n\
    }", "{\n    Nullable!(long) largest_neg = null;\n    Nullable!(long) smallest_pos\
    \ = null;\n    foreach(val; lst) \n    {\n        if(val < 0L) \n        {\n \
    \           if(largest_neg is null || largest_neg < val) \n            {\n   \
    \             largest_neg = val;\n            }\n        }\n        else if(val\
    \ > 0L) \n        {\n            if(smallest_pos is null || smallest_pos > val)\
    \ \n            {\n                smallest_pos = val;\n            }\n      \
    \  }\n    }\n    return tuple(largest_neg, smallest_pos);\n}", "{\n    import\
    \ std.algorithm;\n    import std.range;\n    if(lst.empty) return tuple(null,\
    \ null);\n    auto pos_range = lst.filter!(x => x > 0);\n    auto neg_range =\
    \ lst.filter!(x => x < 0);\n    if(pos_range.empty) return tuple(neg_range.max,\
    \ null);\n    if(neg_range.empty) return tuple(null, pos_range.min);\n    return\
    \ tuple(neg_range.max, pos_range.min);\n}", "{\n    Nullable!(long) lrg = null;\n\
    \    Nullable!(long) sml = null;\n    foreach(el; lst)\n    {\n        if(el >\
    \ 0)\n        {\n            if(sml is null)\n            {\n                sml\
    \ = el;\n            }\n            else\n            {\n                sml =\
    \ min(sml, el);\n            }\n        }\n        else if(el < 0)\n        {\n\
    \            if(lrg is null)\n            {\n                lrg = el;\n     \
    \       }\n            else\n            {\n                lrg = max(lrg, el);\n\
    \            }\n        }\n    }\n    return tuple(lrg, sml);\n}", "{\n    Nullable!(long)\
    \ max = Nullable!(long)(-min!(long));\n    Nullable!(long) min = Nullable!(long)(max!(long));\n\
    \    foreach(i; lst) \n    {\n        if(i < 0) \n        {\n            if(i\
    \ > max) \n            {\n                max = Nullable!(long)(i);\n        \
    \    }\n        }\n        else if(i > 0) \n        {\n            if(i < min)\
    \ \n            {\n                min = Nullable!(long)(i);\n            }\n\
    \        }\n    }\n    return tuple(max, min);\n}", "{\n    Nullable!(long) neg\
    \ = null;\n    Nullable!(long) pos = null;\n    for (i in lst) \n    {\n     \
    \   if (i < 0) \n        {\n            if (neg is null) \n            {\n   \
    \             neg = i;\n            }\n            else \n            {\n    \
    \            neg = max(neg, i);\n            }\n        }\n        else if (i\
    \ > 0) \n        {\n            if (pos is null) \n            {\n           \
    \     pos = i;\n            }\n            else \n            {\n            \
    \    pos = min(pos, i);\n            }\n        }\n    }\n    return tuple(neg,\
    \ pos);\n}", "{\n    auto it = filter!((a) => a < 0)(lst);\n    if (it.empty)\
    \ \n    {\n        auto it2 = filter!((a) => a > 0)(lst);\n        if (it2.empty)\n\
    \            return tuple(null, null);\n        return tuple(null, reduce!((a,\
    \ b) => a > b ? b : a)(it2));\n    }\n    return tuple(reduce!((a, b) => a > b\
    \ ? a : b)(it), null);\n}", "{\n    Nullable!(long) negNum = Nullable!(long)(long.min);\n\
    \    Nullable!(long) posNum = Nullable!(long)(long.max);\n    foreach(num; lst)\n\
    \    {\n        if(num < 0)\n        {\n            if(negNum.isNone || num >\
    \ negNum.get)\n            {\n                negNum = Nullable!(long)(num);\n\
    \            }\n        }\n        else if(num > 0)\n        {\n            if(posNum.isNone\
    \ || num < posNum.get)\n            {\n                posNum = Nullable!(long)(num);\n\
    \            }\n        }\n    }\n    return tuple(negNum, posNum);\n}", "{\n\
    \    long smallestPos = long.max;\n    long largestNeg = long.min;\n    bool hasNeg\
    \ = false;\n    bool hasPos = false;\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            hasNeg = true;\n            largestNeg = max(largestNeg,\
    \ i);\n        }\n        else if(i > 0)\n        {\n            hasPos = true;\n\
    \            smallestPos = min(smallestPos, i);\n        }\n    }\n    Nullable!(long)\
    \ smallest = hasPos ? to!(Nullable!(long))(smallestPos) : to!(Nullable!(long))(null);\n\
    \    Nullable!(long) largest = hasNeg ? to!(Nullable!(long))(largestNeg) : to!(Nullable!(long))(null);\n\
    \    return tuple(largest, smallest);\n}", "{\n    Nullable!(long) largest = Nullable!(long)(null);\n\
    \    Nullable!(long) smallest = Nullable!(long)(null);\n    foreach(int i, l;\
    \ lst)\n    {\n        auto current = lst[i];\n        if(current > 0)\n     \
    \   {\n            if(!smallest.isInitialized)\n            {\n              \
    \  smallest = Nullable!(long)(current);\n            }\n            else if(current\
    \ < smallest.get)\n            {\n                smallest = Nullable!(long)(current);\n\
    \            }\n        }\n        else if(current < 0)\n        {\n         \
    \   if(!largest.isInitialized)\n            {\n                largest = Nullable!(long)(current);\n\
    \            }\n            else if(current > largest.get)\n            {\n  \
    \              largest = Nullable!(long)(current);\n            }\n        }\n\
    \    }\n    return tuple(largest, smallest);\n}", "{\n    return tuple(null, null);\n\
    }", "{\n    Nullable!(long) largest_negative = Nullable!(long)(null);\n    Nullable!(long)\
    \ smallest_positive = Nullable!(long)(null);\n    foreach(item; lst) \n    {\n\
    \        if(item < 0) \n        {\n            if(largest_negative.isNull || item\
    \ > largest_negative.get) \n            {\n                largest_negative =\
    \ Nullable!(long)(item);\n            }\n        } \n        else if(item > 0)\
    \ \n        {\n            if(smallest_positive.isNull || item < smallest_positive.get)\
    \ \n            {\n                smallest_positive = Nullable!(long)(item);\n\
    \            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }", "{\n    long largest_negative = 0L;\n    long smallest_positive = 0L;\n  \
    \  foreach(x; lst) \n    {\n        if (x < 0) \n        {\n            if (x\
    \ > largest_negative)\n                largest_negative = x;\n        }\n    \
    \    else if (x > 0) \n        {\n            if (smallest_positive == 0L)\n \
    \               smallest_positive = x;\n            else if (x < smallest_positive)\n\
    \                smallest_positive = x;\n        }\n    }\n    return tuple(largest_negative\
    \ == 0L ? null : largest_negative, smallest_positive == 0L ? null : smallest_positive);\n\
    }", "{\n    auto neg = min(lst.filter!(e => e < 0));\n    auto pos = max(lst.filter!(e\
    \ => e > 0));\n    return tuple(neg, pos);\n}", "{\n    auto first = Nullable!(long)();\n\
    \    auto second = Nullable!(long)();\n    foreach(e; lst)\n    {\n        if(e\
    \ > 0 && (second.isNull || e < second.get)) second = e;\n        if(e < 0 && (first.isNull\
    \ || e > first.get)) first = e;\n    }\n    return tuple(first, second);\n}",
  "{\n    if (lst.length < 1) return tuple(null, null);\n    int pmin = lst[0], pmax\
    \ = lst[0];\n    int nmin = lst[0], nmax = lst[0];\n    int minp = lst[0], maxp\
    \ = lst[0];\n    int minn = lst[0], maxn = lst[0];\n    int pn = 0, nn = 0;\n\
    \    for (int i = 0; i < lst.length; i++) \n    {\n        if (lst[i] > 0) \n\
    \        {\n            if (lst[i] < pmin) pmin = lst[i];\n            if (lst[i]\
    \ > pmax) pmax = lst[i];\n            pn++;\n        } \n        else if (lst[i]\
    \ < 0) \n        {\n            if (lst[i] < nmin) nmin = lst[i];\n          \
    \  if (lst[i] > nmax) nmax = lst[i];\n            nn++;\n        }\n    }\n  \
    \  int nmin1 = nmin, nmax1 = nmax;\n    if (pn > 0)\n    {\n        if (nn > 0)\n\
    \        {\n            if (nmin1 <= pmin)\n            {\n                nmin1\
    \ = pmin;\n            }\n            if (nmax1 >= pmax)\n            {\n    \
    \            nmax1 = pmax;\n            }\n        }\n        else\n        {\n\
    \            nmin1 = pmin;\n            nmax1 = pmax;\n        }\n    }\n    else\n\
    \    {\n        if (nn > 0)\n        {\n            nmin1 = nmin;\n          \
    \  nmax1 = nmax;\n        }\n        else\n        {\n            nmin1 = 0;\n\
    \            nmax1 = 0;\n        }\n    }\n    return tuple(nmin1, nmax1);\n}",
  "{\n    Nullable!(long) min_positive;\n    Nullable!(long) max_negative;\n    foreach(value;\
    \ lst) \n    {\n        if (value < 0L) \n        {\n            if (!max_negative.isNull\
    \ || abs(value) > abs(max_negative.get!()) ) \n            {\n               \
    \ max_negative = value;\n            }\n        }\n        else if (value > 0L)\
    \ \n        {\n            if (!min_positive.isNull || value < min_positive.get!())\
    \ \n            {\n                min_positive = value;\n            }\n    \
    \    }\n    }\n    return tuple(max_negative, min_positive);\n}", "{\n    auto\
    \ a = to!Nullable(0L);\n    auto b = to!Nullable(0L);\n    foreach(item; lst)\n\
    \    {\n        if(item < 0)\n        {\n            if(!a.isNull)\n         \
    \   {\n                if(a.get > item)\n                {\n                 \
    \   a = to!Nullable(item);\n                }\n            }\n            else\n\
    \            {\n                a = to!Nullable(item);\n            }\n      \
    \  }\n        else if(item > 0)\n        {\n            if(!b.isNull)\n      \
    \      {\n                if(b.get < item)\n                {\n              \
    \      b = to!Nullable(item);\n                }\n            }\n            else\n\
    \            {\n                b = to!Nullable(item);\n            }\n      \
    \  }\n    }\n    return tuple(a, b);\n}", "{\n    Nullable!(long) larg = Nullable!(long).init;\n\
    \    Nullable!(long) small = Nullable!(long).init;\n    bool have_positive = false;\n\
    \    bool have_negative = false;\n    foreach(i; lst) \n    {\n        if (i >\
    \ 0L) \n        {\n            if (!have_positive) \n            {\n         \
    \       small = i;\n                have_positive = true;\n            }\n   \
    \         if (i < small) \n            {\n                small = i;\n       \
    \     }\n        }\n        else if (i < 0L) \n        {\n            if (!have_negative)\
    \ \n            {\n                larg = i;\n                have_negative =\
    \ true;\n            }\n            if (i > larg) \n            {\n          \
    \      larg = i;\n            }\n        }\n    }\n    if (!have_positive)\n \
    \       small = Nullable!(long).init;\n    if (!have_negative)\n        larg =\
    \ Nullable!(long).init;\n    return tuple(larg, small);\n}\n/*", "{\n    Nullable!(long)\
    \ largest_negative = null;\n    Nullable!(long) smallest_positive = null;\n  \
    \  foreach(var number; lst) \n    {\n        if (number > 0)\n        {\n    \
    \        if (smallest_positive is null || number < smallest_positive)\n      \
    \      {\n                smallest_positive = number;\n            }\n       \
    \ }\n        else if (number < 0)\n        {\n            if (largest_negative\
    \ is null || number > largest_negative)\n            {\n                largest_negative\
    \ = number;\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long)) tuple;\n\
    \    Nullable!(long) neg;\n    Nullable!(long) pos;\n    foreach(l; lst)\n   \
    \ {\n        if(l < 0L)\n        {\n            if(neg is null)\n            {\n\
    \                neg = l;\n            }\n            else if(l > neg)\n     \
    \       {\n                neg = l;\n            }\n        }\n        else if(l\
    \ > 0L)\n        {\n            if(pos is null)\n            {\n             \
    \   pos = l;\n            }\n            else if(l < pos)\n            {\n   \
    \             pos = l;\n            }\n        }\n    }\n    return tuple(neg,\
    \ pos);\n}\n ", "{\n    long maxNeg = long.min;\n    long minPos = long.max;\n\
    \    bool flag = false;\n    foreach(e; lst)\n    {\n        if(e > 0L)\n    \
    \    {\n            minPos = min(minPos, e);\n            flag = true;\n     \
    \   }\n        else if(e < 0L)\n        {\n            maxNeg = max(maxNeg, e);\n\
    \            flag = true;\n        }\n    }\n    if(flag)\n    {\n        return\
    \ tuple(maxNeg, minPos);\n    }\n    else\n    {\n        return tuple(null, null);\n\
    \    }\n}", "{\n    enum neg_idx = find_if_idx!(i => lst[i] < 0, lst);\n    enum\
    \ pos_idx = find_if_idx!(i => lst[i] > 0, lst);\n    auto neg_num = lst[neg_idx];\n\
    \    auto pos_num = lst[pos_idx];\n    enum neg_max = neg_idx > -1 ? neg_num :\
    \ null;\n    enum pos_min = pos_idx > -1 ? pos_num : null;\n    auto tuple = tuple(neg_max,\
    \ pos_min);\n    return tuple;\n}\nstatic assert(largest_smallest_integers([-3L,\
    \ -2L, -1L]) == tuple(-1L, null));\nstatic assert(largest_smallest_integers([1L,\
    \ 2L, 3L]) == tuple(null, 1L));\nstatic assert(largest_smallest_integers([-10L,\
    \ 10L]) == tuple(-10L, 10L));\nstatic assert(largest_smallest_integers([2L, 4L,\
    \ 1L, 3L, 5L, 7L]) == tuple(null, 1L));\nstatic assert(largest_smallest_integers([])\
    \ == tuple(null, null));\nstatic assert(largest_smallest_integers([0L]) == tuple(null,\
    \ null));\n ", "{\n    size_t sz = lst.length;\n    size_t i;\n    long largest,\
    \ smallest;\n    Nullable!(long) nlargest, nsmallest;\n    if (sz == 0) \n   \
    \ {\n        nlargest = null;\n        nsmallest = null;\n    } \n    else \n\
    \    {\n        if (lst[0] >= 0) \n        {\n            nsmallest = lst[0];\n\
    \            smallest = lst[0];\n        } \n        else \n        {\n      \
    \      nsmallest = null;\n            smallest = lst[0];\n        }\n        if\
    \ (lst[0] <= 0) \n        {\n            nlargest = lst[0];\n            largest\
    \ = lst[0];\n        } \n        else \n        {\n            nlargest = null;\n\
    \            largest = lst[0];\n        }\n        for (i = 1; i < sz; i++) \n\
    \        {\n            if (lst[i] > 0) \n            {\n                if (smallest\
    \ == 0) \n                {\n                    nsmallest = lst[i];\n       \
    \             smallest = lst[i];\n                } \n                else if\
    \ (lst[i] < smallest) \n                {\n                    nsmallest = lst[i];\n\
    \                    smallest = lst[i];\n                }\n            } \n \
    \           else if (lst[i] < 0) \n            {\n                if (largest\
    \ == 0) \n                {\n                    nlargest = lst[i];\n        \
    \            largest = lst[i];\n                } \n                else if (lst[i]\
    \ > largest) \n                {\n                    nlargest = lst[i];\n   \
    \                 largest = lst[i];\n                }\n            }\n      \
    \  }\n    }\n    return tuple(nlargest, nsmallest);\n}", "{\n    Nullable!(long)\
    \ largest_neg;\n    Nullable!(long) smallest_pos;\n    foreach(elem; lst) \n \
    \   {\n        if(elem < 0L) \n        {\n            if(largest_neg.isNull ||\
    \ elem > largest_neg.get) \n            {\n                largest_neg = elem;\n\
    \            }\n        } \n        else if(elem > 0L) \n        {\n         \
    \   if(smallest_pos.isNull || elem < smallest_pos.get) \n            {\n     \
    \           smallest_pos = elem;\n            }\n        }\n    }\n    return\
    \ tuple(largest_neg, smallest_pos);\n}", "{\n    Nullable!(long) largest_negative;\n\
    \    Nullable!(long) smallest_positive;\n    foreach(long number; lst)\n    {\n\
    \        if(number < 0L)\n        {\n            if(largest_negative.isNull)\n\
    \            {\n                largest_negative = number;\n            }\n  \
    \          else\n            {\n                largest_negative = max(largest_negative,\
    \ number);\n            }\n        }\n        else if(number > 0L)\n        {\n\
    \            if(smallest_positive.isNull)\n            {\n                smallest_positive\
    \ = number;\n            }\n            else\n            {\n                smallest_positive\
    \ = min(smallest_positive, number);\n            }\n        }\n    }\n    return\
    \ tuple(largest_negative, smallest_positive);\n}", "{\n    Nullable!(long) largest_neg\
    \ = null;\n    Nullable!(long) smallest_pos = null;\n    for (long i = 0; i <\
    \ lst.length; i++)\n    {\n        if (lst[i] < 0 && largest_neg is null)\n  \
    \      {\n            largest_neg = lst[i];\n        }\n        else if (lst[i]\
    \ < 0 && largest_neg !is null)\n        {\n            largest_neg = max(largest_neg,\
    \ lst[i]);\n        }\n        else if (lst[i] > 0 && smallest_pos is null)\n\
    \        {\n            smallest_pos = lst[i];\n        }\n        else if (lst[i]\
    \ > 0 && smallest_pos !is null)\n        {\n            smallest_pos = min(smallest_pos,\
    \ lst[i]);\n        }\n    }\n    return tuple(largest_neg, smallest_pos);\n}\n\
    assert(largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L]) == tuple(null, 1L));\n\
    assert(largest_smallest_integers([]) == tuple(null, null));\nassert(largest_smallest_integers([0L])\
    \ == tuple(null, null));", "{\n    if(lst.length == 0)\n        return tuple(null,\
    \ null);\n    else\n    {\n        long[] positive = lst.filter!(x => x > 0);\n\
    \        long[] negative = lst.filter!(x => x < 0);\n        return tuple(negative.length\
    \ == 0 ? null : negative.max, positive.length == 0 ? null : positive.min);\n \
    \   }\n}", "{\n    auto largest = lst.filter!(a => a < 0L).max;\n    auto smallest\
    \ = lst.filter!(a => a > 0L).min;\n    return tuple(largest, smallest);\n}\n/*",
  "{\n    auto larger = Nullable!(long)();\n    auto smaller = Nullable!(long)();\n\
    \    foreach(n; lst)\n    {\n        if(n < 0L)\n        {\n            if(larger\
    \ is null)\n            {\n                larger = n;\n            }\n      \
    \      else\n            {\n                larger = max(larger, n);\n       \
    \     }\n        }\n        else if(n > 0L)\n        {\n            if(smaller\
    \ is null)\n            {\n                smaller = n;\n            }\n     \
    \       else\n            {\n                smaller = min(smaller, n);\n    \
    \        }\n        }\n    }\n    return tuple(larger, smaller);\n}", "{\n   \
    \ Nullable!(long) largestNegative = Nullable!(long)().init;\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)().init;\n    foreach(ref long i; lst)\n \
    \   {\n        if(i < 0L)\n        {\n            if(!largestNegative.isNull)\n\
    \            {\n                if(i > largestNegative.get)\n                {\n\
    \                    largestNegative.get = i;\n                }\n           \
    \ }\n            else\n            {\n                largestNegative.get = i;\n\
    \            }\n        }\n        else if(i > 0L)\n        {\n            if(!smallestPositive.isNull)\n\
    \            {\n                if(i < smallestPositive.get)\n               \
    \ {\n                    smallestPositive.get = i;\n                }\n      \
    \      }\n            else\n            {\n                smallestPositive.get\
    \ = i;\n            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\n/*", "{\n    if (lst.length == 0) \n    {\n        return tuple(to!Nullable(null),\
    \ to!Nullable(null));\n    }", "{\n    auto is_positive = (long x) => x > 0;\n\
    \    auto is_negative = (long x) => x < 0;\n    auto largest_neg = lst.filter!is_negative.max;\n\
    \    auto smallest_pos = lst.filter!is_positive.min;\n    return tuple(largest_neg,\
    \ smallest_pos);\n}", "{\n    bool hasPositive = false;\n    bool hasNegative\
    \ = false;\n    long temp;\n    Nullable!(long) largestNegative;\n    Nullable!(long)\
    \ smallestPositive;\n    foreach(element; lst) \n    {\n        temp = cast(long)element;\n\
    \        if(temp > 0) \n        {\n            hasPositive = true;\n         \
    \   if(smallestPositive.isNull)\n                smallestPositive = temp;\n  \
    \          else if(temp < smallestPositive)\n                smallestPositive\
    \ = temp;\n        } \n        else if(temp < 0) \n        {\n            hasNegative\
    \ = true;\n            if(largestNegative.isNull)\n                largestNegative\
    \ = temp;\n            else if(temp > largestNegative)\n                largestNegative\
    \ = temp;\n        }\n    }\n    return hasNegative || hasPositive\n        ?\
    \ tuple(largestNegative, smallestPositive)\n        : tuple(Nullable!(long).init,\
    \ Nullable!(long).init);\n}", "{\n    Nullable!(long) a;\n    Nullable!(long)\
    \ b;\n    for (int i = 0; i < lst.length; i++) \n    {\n        if(lst[i] < 0)\n\
    \        {\n            if(!a.isNull)\n            {\n                if(lst[i]\
    \ > a.get!)\n                {\n                    a = lst[i];\n            \
    \    }\n            }\n            else\n            {\n                a = lst[i];\n\
    \            }\n        }\n        else if(lst[i] > 0)\n        {\n          \
    \  if(!b.isNull)\n            {\n                if(lst[i] < b.get!)\n       \
    \         {\n                    b = lst[i];\n                }\n            }\n\
    \            else\n            {\n                b = lst[i];\n            }\n\
    \        }\n    }\n    return tuple(a, b);\n}", "{\n    Nullable!(long) smallest\
    \ = None;\n    Nullable!(long) largest = None;\n    for (long l; lst) {\n    \
    \    l = lst.front;\n        if (l < 0) {\n            if (largest is null ||\
    \ l > largest) {\n                largest = l;\n            }\n        } else\
    \ if (l > 0) {\n            if (smallest is null || l < smallest) {\n        \
    \        smallest = l;\n            }\n        }\n    }\n    return tuple(largest,\
    \ smallest);\n}\n/*", "{\n    Nullable!(long) smallest = null;\n    Nullable!(long)\
    \ largest = null;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if\
    \ (lst[i] < 0)\n        {\n            if (largest is null)\n            {\n \
    \               largest = lst[i];\n            }\n            else\n         \
    \   {\n                largest = max(largest, lst[i]);\n            }\n      \
    \  }\n        else if (lst[i] > 0)\n        {\n            if (smallest is null)\n\
    \            {\n                smallest = lst[i];\n            }\n          \
    \  else\n            {\n                smallest = min(smallest, lst[i]);\n  \
    \          }\n        }\n    }\n    return tuple(largest, smallest);\n}", "  \
    \  in\n{\n    if(lst.length == 0) \n    {\n        return tuple(null, null);\n\
    \    }\n}\n    out(lst)\n{\n    assert(lst.length == 0 ? true : !lst.count(0L));\n\
    }\n    body\n{\n    import std.algorithm;\n    import std.range;\n    import std.conv;\n\
    \    import std.typecons;\n    import std.array;\n    import std.math;\n    import\
    \ std.range;\n    import std.typecons;\n    import std.algorithm;\n    import\
    \ std.range;\n    import std.array;\n    import std.conv;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.algorithm;\n    import std.conv;\n    import std.array;\n    import\
    \ std.range;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.math;\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.math;\n    import std.array;\n\
    \    import std.algorithm;\n    import std.conv;\n    import std.range;\n    import\
    \ std.math;\n    import std.typecons;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.array;\n    import std.math;\n    import std.conv;\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.array;\n    import std.math;\n\
    \    import std.conv;\n    import std.algorithm;\n    import std.array;\n    import\
    \ std.range;\n    import std.math;\n    import std.algorithm;\n    import std.conv;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.array;\n   \
    \ import std.math;\n    import std.conv;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std", "{\n    auto largest\
    \ = Nullable!(long)();\n    auto smallest = Nullable!(long)();\n    foreach(val;\
    \ lst)\n    {\n        if(val < 0)\n        {\n            if(largest.isNull)\n\
    \            {\n                largest = val;\n            }\n            else\n\
    \            {\n                largest = val > largest.get ? val : largest.get;\n\
    \            }\n        }\n        else if(val > 0)\n        {\n            if(smallest.isNull)\n\
    \            {\n                smallest = val;\n            }\n            else\n\
    \            {\n                smallest = val < smallest.get ? val : smallest.get;\n\
    \            }\n        }\n    }\n    return tuple(largest, smallest);\n}", "{\n\
    \    Nullable!(long) largest_negative;\n    Nullable!(long) smallest_positive;\n\
    \    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n            if(largest_negative.isNull)\n\
    \            {\n                largest_negative = l;\n            }\n       \
    \     else\n            {\n                largest_negative = max(largest_negative,\
    \ l);\n            }\n        }\n        else if(l > 0)\n        {\n         \
    \   if(smallest_positive.isNull)\n            {\n                smallest_positive\
    \ = l;\n            }\n            else\n            {\n                smallest_positive\
    \ = min(smallest_positive, l);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}", "{\n\tNullable!(long) largestNegative, smallestPositive;\n\
    \tforeach(elem; lst) \n\t{\n\t\tif(elem > 0L) \n\t\t{\n\t\t\tif(!smallestPositive.isValid()\
    \ || elem < smallestPositive) \n\t\t\t{\n\t\t\t\tsmallestPositive = elem;\n\t\t\
    \t}\n\t\t}\n\t\telse if(elem < 0L) \n\t\t{\n\t\t\tif(!largestNegative.isValid()\
    \ || elem > largestNegative) \n\t\t\t{\n\t\t\t\tlargestNegative = elem;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn tuple(largestNegative, smallestPositive);\n}", "{\n  \
    \  // write your code here\n    long minPos = long.max;\n    long maxNeg = long.min;\n\
    \    foreach(i; lst)\n    {\n        if(i > 0 && i < minPos)\n            minPos\
    \ = i;\n        if(i < 0 && i > maxNeg)\n            maxNeg = i;\n    }\n    return\
    \ tuple(minPos == long.max ? null : maxNeg, maxNeg == long.min ? null : minPos);\n\
    }", "{\n    auto t = tuple(Nullable!(long)(), Nullable!(long)());\n    if (lst.length\
    \ == 0) \n    {\n        return t;\n    }\n    if (lst.length == 1) \n    {\n\
    \        if (lst[0] >= 0)\n        {\n            return tuple(Nullable!(long)(),\
    \ lst[0]);\n        }\n        return tuple(lst[0], Nullable!(long)());\n    }\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (value; lst) \n \
    \   {\n        if (value < 0) \n        {\n            if (value > max) \n   \
    \         {\n                max = value;\n            }\n        } \n       \
    \ else if (value > 0) \n        {\n            if (value < min) \n           \
    \ {\n                min = value;\n            }\n        }\n    }\n    if (min\
    \ < 0) \n    {\n        t[0] = max;\n    }\n    if (max > 0) \n    {\n       \
    \ t[1] = min;\n    }\n    return t;\n}", "{\n    import std.math;\n    import\
    \ std.typecons;\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i<0)\n        {\n          \
    \  if(largest is null || abs(i)>abs(largest))\n            {\n               \
    \ largest = i;\n            }\n        }\n        else if(i>0)\n        {\n  \
    \          if(smallest is null || i<smallest)\n            {\n               \
    \ smallest = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }", "{\n    long a = 0;\n    long b = 0;\n    bool in_range = false;\n    foreach(num;\
    \ lst) \n    {\n        if(num < 0) \n        {\n            if(!in_range) \n\
    \            {\n                a = num;\n                in_range = true;\n \
    \           } \n            else if(num > a) \n            {\n               \
    \ a = num;\n            }\n        } \n        else if(num > 0) \n        {\n\
    \            if(!in_range) \n            {\n                b = num;\n       \
    \         in_range = true;\n            } \n            else if(num < b) \n  \
    \          {\n                b = num;\n            }\n        }\n    }\n    return\
    \ tuple(a != 0 ? a : null, b != 0 ? b : null);\n}\nstatic assert(tuple(null, 1L)\
    \ == largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L]));\nstatic assert(tuple(null,\
    \ null) == largest_smallest_integers([]));\nstatic assert(tuple(null, null) ==\
    \ largest_smallest_integers([0L]));\n//\n/*\n    Check if a word is a palindrome,\
    \ case-insensitive", "{\n    bool has_positive = false;\n    long smallest_positive\
    \ = long.max;\n    bool has_negative = false;\n    long largest_negative = long.min;\n\
    \    foreach(l; lst) \n    {\n        if (l > 0) \n        {\n            has_positive\
    \ = true;\n            smallest_positive = min(smallest_positive, l);\n      \
    \  } \n        else if (l < 0) \n        {\n            has_negative = true;\n\
    \            largest_negative = max(largest_negative, l);\n        }\n    }\n\
    \    return tuple(has_negative ? largest_negative : null, has_positive ? smallest_positive\
    \ : null);\n}", "{\n    // Init a tuple to store the results\n    auto result\
    \ = tuple(null, null);\n    // Create a range with index and store in a dynamic\
    \ array\n    auto tmpLst = iota(0L, lst.length).map!((long i) => lst[i]).array;\n\
    \    // Sort array by ascending order\n    sort(tmpLst);\n    // Get the last\
    \ negative and first positive integers, store in a tuple\n    // and return it\n\
    \    return tuple(tmpLst.filter!(n => n < 0).back, tmpLst.filter!(n => n > 0).front);\n\
    }", "{\n    return tuple(max(filter!((a) => a < 0)(lst)), min(filter!((a) => a\
    \ > 0)(lst)));\n}\n// ----\nassert(largest_smallest_integers([2L, 4L, 1L, 3L,\
    \ 5L, 7L]) == tuple(null, 1L));\nassert(largest_smallest_integers([]) == tuple(null,\
    \ null));\nassert(largest_smallest_integers([0L]) == tuple(null, null));\n \n\
    \ \n// -------------------------------------------------------------------------------------------------\n\
    \ \n/*", "{\n    auto t = tuple(null, null);\n    bool hasPositive = false;\n\
    \    bool hasNegative = false;\n    foreach(num; lst) \n    {\n        if(num\
    \ > 0) \n        {\n            hasPositive = true;\n            if(t[1] is null\
    \ || num < t[1]) \n            {\n                t[1] = num;\n            }\n\
    \        }\n        else if(num < 0) \n        {\n            hasNegative = true;\n\
    \            if(t[0] is null || num > t[0]) \n            {\n                t[0]\
    \ = num;\n            }\n        }\n    }\n    if(!hasPositive) \n    {\n    \
    \    t[1] = null;\n    }\n    if(!hasNegative) \n    {\n        t[0] = null;\n\
    \    }\n    return t;\n}", "{\n    return \n        lst.filter!(a => a < 0).length\
    \ == 0 &&\n        lst.filter!(a => a > 0).length == 0 ?\n        tuple(null,\
    \ null) :\n        tuple(\n            lst.filter!(a => a < 0).max,\n        \
    \    lst.filter!(a => a > 0).min\n        );\n}", "{\n    enum pos = lst.countUntil!(i\
    \ => i > 0);\n    enum neg = lst.countUntil!(i => i < 0);\n    return tuple(lst.back.abs.retro(min)\
    \ if (neg > 0) else null,\n                 lst.front.abs.retro(min) if (pos >\
    \ 0) else null);\n}", "    pure nothrow @safe\n{\n    Nullable!(long) a = null;\n\
    \    Nullable!(long) b = null;\n    foreach(long i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(a.isNull || a.get!long > i)\n            {\n\
    \                a = i;\n            }\n        }\n        else if(i > 0)\n  \
    \      {\n            if(b.isNull || b.get!long < i)\n            {\n        \
    \        b = i;\n            }\n        }\n    }\n    return tuple(a, b);\n}",
  "{\n    Tuple!(Nullable!(long), Nullable!(long)) res = tuple(null, null);\n    long\
    \ maxNeg = long.min;\n    long minPos = long.max;\n    foreach(i; lst)\n    {\n\
    \        if(i > 0)\n        {\n            minPos = min(minPos, i);\n        }\n\
    \        else if(i < 0)\n        {\n            maxNeg = max(maxNeg, i);\n   \
    \     }\n    }\n    res[0] = (maxNeg == long.min) ? null : cast(Nullable!(long))maxNeg;\n\
    \    res[1] = (minPos == long.max) ? null : cast(Nullable!(long))minPos;\n   \
    \ return res;\n}", "{\n    Nullable!(long) largest = Nullable!(long)();\n    Nullable!(long)\
    \ smallest = Nullable!(long)();\n    foreach(num; lst) \n    {\n        if(num\
    \ < 0) \n        {\n            if(largest.isNone) \n            {\n         \
    \       largest = Nullable!(long)(num);\n            }\n            else if(largest.get\
    \ > num) \n            {\n                largest = Nullable!(long)(num);\n  \
    \          }\n        }\n        else if(num > 0) \n        {\n            if(smallest.isNone)\
    \ \n            {\n                smallest = Nullable!(long)(num);\n        \
    \    }\n            else if(smallest.get < num) \n            {\n            \
    \    smallest = Nullable!(long)(num);\n            }\n        }\n    }\n    return\
    \ tuple(largest, smallest);\n}", "{\n    Nullable!(long) max = null;\n    Nullable!(long)\
    \ min = null;\n    foreach(e; lst) \n    {\n        if(min is null && e > 0) \n\
    \        {\n            min = e;\n        }\n        else if(e > 0 && e < min)\
    \ \n        {\n            min = e;\n        }\n        if(max is null && e <\
    \ 0) \n        {\n            max = e;\n        }\n        else if(e < 0 && e\
    \ > max) \n        {\n            max = e;\n        }\n    }\n    return tuple(max,\
    \ min);\n}", "{\n    Nullable!(long) max_long = Nullable!(long)(0L),\n       \
    \              min_long = Nullable!(long)(0L);\n    foreach(x; lst)\n    {\n \
    \       if(x < 0L)\n        {\n            if(max_long.isNull)\n             \
    \   max_long = Nullable!(long)(x);\n            else\n                max_long\
    \ = max(max_long.get, x);\n        }\n        else if(x > 0L)\n        {\n   \
    \         if(min_long.isNull)\n                min_long = Nullable!(long)(x);\n\
    \            else\n                min_long = min(min_long.get, x);\n        }\n\
    \    }\n    return tuple(max_long, min_long);\n}", "{\n    /*\n    Return a tuple\
    \ (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest\
    \ of positive integers.\n    */\n    Nullable!(long) largestNegative = Nullable!(long)(-1);\n\
    \    Nullable!(long) smallestPositive = Nullable!(long)(1);\n    for (long elem;\
    \ lst)\n    {\n        elem = lst.front;\n        if (elem < 0)\n        {\n \
    \           if (largestNegative.isNull || elem > largestNegative.get)\n      \
    \      {\n                largestNegative = Nullable!(long)(elem);\n         \
    \   }\n        }\n        else if (elem > 0)\n        {\n            if (smallestPositive.isNull\
    \ || elem < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(elem);\n            }\n        }\n        lst.popFront();\n\
    \    }\n    return tuple(largestNegative, smallestPositive);\n}\n ", "{\n    Nullable!(long)\
    \ maxNegative = null;\n    Nullable!(long) minPositive = null;\n    foreach(x;\
    \ lst)\n    {\n        if(x > 0) \n        {\n            if(minPositive.isNull\
    \ || x < minPositive.get) \n            {\n                minPositive = x;\n\
    \            }\n        }\n        else if(x < 0) \n        {\n            if(maxNegative.isNull\
    \ || x > maxNegative.get) \n            {\n                maxNegative = x;\n\
    \            }\n        }\n    }\n    return tuple(maxNegative, minPositive);\n\
    }", "{\n    \n    auto biggestNegative = Nullable!(long)(null);\n    auto smallestPositive\
    \ = Nullable!(long)(null);\n    \n    foreach(i; lst)\n    {\n        if(i > 0)\n\
    \        {\n            if(smallestPositive.isNull || i < smallestPositive.get!)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n        else if(i < 0)\n        {\n            if(biggestNegative.isNull\
    \ || i > biggestNegative.get!)\n            {\n                biggestNegative\
    \ = i;\n            }\n        }\n    }\n    \n    return tuple(biggestNegative,\
    \ smallestPositive);\n}", "{\n    long max_neg, min_pos;\n    if (lst.length ==\
    \ 0) \n    {\n        return tuple(null, null);\n    }", "{\n\tNullable!(long)\
    \ a = null;\n\tNullable!(long) b = null;\n\tforeach(i; lst) \n\t{\n\t\tif(i >\
    \ 0) \n\t\t{\n\t\t\tif(b is null)\n\t\t\t\tb = i;\n\t\t\telse\n\t\t\t\tb = min(b,\
    \ i);\n\t\t}\n\t\telse if(i < 0) \n\t\t{\n\t\t\tif(a is null)\n\t\t\t\ta = i;\n\
    \t\t\telse\n\t\t\t\ta = max(a, i);\n\t\t}\n\t}\n\treturn tuple(a, b);\n}\n/*\n\
    \    Create a function that accepts a 2D array, and returns the same 2D array\n\
    \    with the value of '0' for every cell that is not on the edge of the array.\n\
    \    Ignore the edges for this exercise, as they will always be '1'.", "{\n  \
    \  auto max_neg = Nullable!(long)();\n    auto min_pos = Nullable!(long)();\n\
    \    foreach(l; lst) \n    {\n        if (l > 0) \n        {\n            if (min_pos.isNull()\
    \ || l < min_pos.get)\n                min_pos = l;\n        } \n        else\
    \ if (l < 0) \n        {\n            if (max_neg.isNull() || l > max_neg.get)\n\
    \                max_neg = l;\n        }\n    }\n    return tuple(max_neg, min_pos);\n\
    }\nstatic assert(largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L]) == tuple(null,\
    \ 1L));\nstatic assert(largest_smallest_integers([]) == tuple(null, null));\n\
    static assert(largest_smallest_integers([0L]) == tuple(null, null));", "{\n  \
    \  Nullable!(long) a = null;\n    Nullable!(long) b = null;\n    foreach(i; lst)\n\
    \    {\n        if(i < 0)\n        {\n            if(a is null)\n            {\n\
    \                a = i;\n            }\n            else\n            {\n    \
    \            a = max(a, i);\n            }\n        }\n        else if(i > 0)\n\
    \        {\n            if(b is null)\n            {\n                b = i;\n\
    \            }\n            else\n            {\n                b = min(b, i);\n\
    \            }\n        }\n    }\n    return tuple(a, b);\n}\n ", "{\n    auto\
    \ largest = long.min;\n    auto smallest = long.max;\n    foreach(x; lst) \n \
    \   {\n        if (x < 0) \n        {\n            largest = max(largest, x);\n\
    \        } \n        else if (x > 0) \n        {\n            smallest = min(smallest,\
    \ x);\n        }\n    }\n    auto first = Nullable!(long)(largest == long.min\
    \ ? null : largest);\n    auto second = Nullable!(long)(smallest == long.max ?\
    \ null : smallest);\n    return tuple(first, second);\n}", "{\n    Nullable!(long)\
    \ small_pos(Nullable!(long) a, long b)\n    {\n        if(b > 0)\n        {\n\
    \            return a is null || b < a ? b : a;\n        }\n        return a;\n\
    \    }\n    Nullable!(long) big_neg(Nullable!(long) a, long b)\n    {\n      \
    \  if(b < 0)\n        {\n            return a is null || b > a ? b : a;\n    \
    \    }\n        return a;\n    }\n    return tuple(reduce!(big_neg)(lst), reduce!(small_pos)(lst));\n\
    }", "{\n    size_t size = lst.length;\n    Nullable!(long) smallest = null;\n\
    \    Nullable!(long) largest = null;\n    for (size_t i = 0; i < size; i++) \n\
    \    {\n        if (lst[i] >= 0) \n        {\n            if (smallest.isNull\
    \ || lst[i] < smallest.get!(long))\n                smallest = lst[i];\n     \
    \   }\n        else \n        {\n            if (largest.isNull || lst[i] > largest.get!(long))\n\
    \                largest = lst[i];\n        }\n    }\n    return tuple(largest,\
    \ smallest);\n}\n/*\n    Generate a list of length 'n' of random integers in the\
    \ range [-m, m]\n    and return it.\n*/\nlong[] randomIntegers(long n, long m)\
    \ \n{\n    long[] result = new long[n];\n    foreach (i; 0 .. n) \n    {\n   \
    \     result[i] = cast(long)(uniform(-m, m));\n    }\n    return result;\n}\n\
    /*\n    Generate 'n' random lists of length 'l' of random integers in the range\n\
    \    [-m, m] and return them.\n*/\nlong[][] randomIntegersList(long n, long l,\
    \ long m) \n{\n    long[][] lists = new long[n][l];\n    foreach (i; 0 .. n) \n\
    \    {\n        lists[i] = randomIntegers(l, m);\n    }\n    return lists;\n}\n\
    /*\n    Tests a function that implements largest_smallest_integers, for a\n  \
    \  list of lists of integers.\n*/", "{\n\tbool haspos = false;\n\tbool hasneg\
    \ = false;\n\t\n\tlong maxneg = long.min;\n\tlong minpos = long.max;\n\t\n\tforeach(var\
    \ item; lst)\n\t{\n\t\tif(item > 0)\n\t\t{\n\t\t\thaspos = true;\n\t\t\tminpos\
    \ = min(minpos, item);\n\t\t}\n\t\telse if(item < 0)\n\t\t{\n\t\t\thasneg = true;\n\
    \t\t\tmaxneg = max(maxneg, item);\n\t\t}\n\t}\n\t\n\tNullable!(long) maxneg2 =\
    \ hasneg ? maxneg : cast(Nullable!(long)) null;\n\tNullable!(long) minpos2 = haspos\
    \ ? minpos : cast(Nullable!(long)) null;\n\t\n\treturn tuple(maxneg2, minpos2);\n\
    }", "{\n    Nullable!(long) largest_of_negative = null;\n    Nullable!(long) smallest_of_positive\
    \ = null;\n    foreach(var i; lst) \n    {\n        if(i < 0) \n        {\n  \
    \          if(largest_of_negative.isNull || i > largest_of_negative.get) \n  \
    \          {\n                largest_of_negative = i;\n            }\n      \
    \  }\n        else if(i > 0) \n        {\n            if(smallest_of_positive.isNull\
    \ || i < smallest_of_positive.get) \n            {\n                smallest_of_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_of_negative,\
    \ smallest_of_positive);\n}", "{\n    auto r = tuple(null, null);\n    foreach(x;\
    \ lst) \n    {\n        if (x > 0) \n        {\n            if (r[1] is null ||\
    \ x < r[1])\n                r[1] = x;\n        }\n        else \n        {\n\
    \            if (r[0] is null || x > r[0])\n                r[0] = x;\n      \
    \  }\n    }\n    return r;\n}", "{\n    /*\n    Algorithm:\n    Step 1: Sort the\
    \ list.\n    Step 2: Set default largest_negative to null.\n    Step 3: Set default\
    \ smallest_positive to null.\n    Step 4: Set largest_negative to head of negative\
    \ elements.\n    Step 5: Set smallest_positive to tail of positive elements.\n\
    \    Step 6: Return (largest_negative, smallest_positive).\n    */\n    // Step\
    \ 1\n    lst.sort();\n    // Step 2\n    Nullable!(long) largest_negative = null;\n\
    \    // Step 3\n    Nullable!(long) smallest_positive = null;\n    // Step 4\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < 0)\n  \
    \      {\n            largest_negative = lst[i];\n        }\n        else\n  \
    \      {\n            break;\n        }\n    }\n    // Step 5\n    for (int i\
    \ = lst.length - 1; i >= 0; i--)\n    {\n        if (lst[i] > 0)\n        {\n\
    \            smallest_positive = lst[i];\n        }\n        else\n        {\n\
    \            break;\n        }\n    }\n    // Step 6\n    return tuple(largest_negative,\
    \ smallest_positive);\n}", "{\n    auto it = lst.filter!(a => a > 0).min();\n\
    \    auto jt = lst.filter!(a => a < 0).max();\n    if (it)\n        return tuple(jt,\
    \ it);\n    else if (jt)\n        return tuple(jt, null);\n    else\n        return\
    \ tuple(null, null);\n}", "{\n    long largest = null;\n    long smallest = null;\n\
    \    for (long i = 0; i < lst.length; i++) \n    {\n        long item = lst[i];\n\
    \        if (item < 0)\n        {\n            if (largest is null || largest\
    \ < item)\n            {\n                largest = item;\n            }\n   \
    \     }\n        else if (item > 0)\n        {\n            if (smallest is null\
    \ || smallest > item)\n            {\n                smallest = item;\n     \
    \       }\n        }\n    }\n    return tuple(largest, smallest);\n}", "{\n  \
    \  long min = 0L;\n    long max = 0L;\n    bool isFirst = true;\n    bool hasPositive\
    \ = false;\n    bool hasNegative = false;\n    foreach(long item; lst) \n    {\n\
    \        if(isFirst)\n        {\n            min = item;\n            max = item;\n\
    \            isFirst = false;\n        }\n        if(item < 0)\n        {\n  \
    \          hasNegative = true;\n            if(item > max) max = item;\n     \
    \   }\n        else if(item > 0)\n        {\n            hasPositive = true;\n\
    \            if(item < min) min = item;\n        }\n    }\n    Nullable!(long)\
    \ largest = Nullable!(long)();\n    Nullable!(long) smallest = Nullable!(long)();\n\
    \    if(hasNegative) largest = Nullable!(long)(max);\n    if(hasPositive) smallest\
    \ = Nullable!(long)(min);\n    return tuple(largest, smallest);\n}", "{\n    if\
    \ (lst.length == 0)\n        return tuple(null, null);\n    auto positiveNums\
    \ = lst.filter!(a => a > 0);\n    auto negativeNums = lst.filter!(a => a < 0);\n\
    \    Nullable!(long) smallestPositive = null;\n    Nullable!(long) largestNegative\
    \ = null;\n    if (positiveNums.length > 0)\n        smallestPositive = positiveNums.min;\n\
    \    if (negativeNums.length > 0)\n        largestNegative = negativeNums.max;\n\
    \    return tuple(largestNegative, smallestPositive);\n}", "{\n    Nullable!(long)\
    \ largest_negative = null;\n    Nullable!(long) smallest_positive = null;\n  \
    \  foreach(item; lst)\n    {\n        if(item > 0)\n        {\n            if(smallest_positive.isNull()\
    \ || smallest_positive > item)\n            {\n                smallest_positive\
    \ = item;\n            }\n        }\n        else if(item < 0)\n        {\n  \
    \          if(largest_negative.isNull() || largest_negative < item)\n        \
    \    {\n                largest_negative = item;\n            }\n        }\n \
    \   }\n    return tuple(largest_negative, smallest_positive);\n}", "{\n    return\
    \ lst.filter!((n) => n < 0).max.toNullable(Nullable!(long)) ~ lst.filter!((n)\
    \ => n > 0).min.toNullable(Nullable!(long));\n}", "{\n    Nullable!(long) l =\
    \ Nullable!(long)();\n    Nullable!(long) s = Nullable!(long)();\n    foreach(lst;\
    \ (i, e) => \n    {\n        if (l.isNull && e < 0) \n        {\n            l\
    \ = Nullable!(long)(e);\n        }\n        else if (!l.isNull && l.get < e &&\
    \ e < 0) \n        {\n            l = Nullable!(long)(e);\n        }\n       \
    \ if (s.isNull && e > 0) \n        {\n            s = Nullable!(long)(e);\n  \
    \      }\n        else if (!s.isNull && s.get > e && e > 0) \n        {\n    \
    \        s = Nullable!(long)(e);\n        }\n    });\n    return tuple(l, s);\n\
    }", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result = tuple(null, null);\n\
    \    size_t i;\n    long n;\n    if (lst.length == 0)\n        return result;\n\
    \    for (i = 0; i < lst.length; i++)\n    {\n        n = lst[i];\n        if\
    \ (n < 0)\n        {\n            if (result[0] == null || n > result[0])\n  \
    \              result[0] = n;\n        }\n        else if (n > 0)\n        {\n\
    \            if (result[1] == null || n < result[1])\n                result[1]\
    \ = n;\n        }\n    }\n    return result;\n}", "{\n    return tuple(lst.filter!(n\
    \ => n < 0).empty ? null : lst.filter!(n => n < 0).max, \n                 lst.filter!(n\
    \ => n > 0).empty ? null : lst.filter!(n => n > 0).min);\n}\n \n \n/*\n    Create\
    \ a function that takes a string and returns a tuple of:\n    - A string with\
    \ all of the vowels removed.\n    - A string with all of the consonants removed.\n\
    \    - A string with all of the spaces removed.\n    Assume that there won't be\
    \ any punctuation in the string.", "{\n    long max_neg, min_pos;\n    bool found_neg\
    \ = false, found_pos = false;\n    foreach(i; lst) \n    {\n        if(i < 0)\
    \ \n        {\n            if(!found_neg) \n            {\n                max_neg\
    \ = i;\n                found_neg = true;\n            }\n            else\n \
    \               max_neg = max(max_neg, i);\n        }\n        else if(i > 0)\
    \ \n        {\n            if(!found_pos) \n            {\n                min_pos\
    \ = i;\n                found_pos = true;\n            }\n            else\n \
    \               min_pos = min(min_pos, i);\n        }\n    }\n    return tuple(found_neg\
    \ ? max_neg : null, found_pos ? min_pos : null);\n}", "{\n    Nullable!(long)\
    \ a = null;\n    Nullable!(long) b = null;\n    long min = cast(long)std.math.numeric_limits.max;\n\
    \    long max = cast(long)std.math.numeric_limits.min;\n    foreach(e; lst)\n\
    \    {\n        if(e < 0)\n        {\n            if(e > max)\n            {\n\
    \                max = e;\n            }\n        }\n        else if(e > 0)\n\
    \        {\n            if(e < min)\n            {\n                min = e;\n\
    \            }\n        }\n    }\n    if(max != cast(long)std.math.numeric_limits.min)\n\
    \    {\n        a = max;\n    }\n    if(min != cast(long)std.math.numeric_limits.max)\n\
    \    {\n        b = min;\n    }\n    return tuple(a, b);\n}", "{\n    Nullable!(long)[]\
    \ posNeg;\n    posNeg = [];\n    foreach(v; lst) \n    {\n        if(v < 0) \n\
    \        {\n            posNeg ~= v;\n        }\n        else if(v > 0) \n   \
    \     {\n            posNeg ~= v;\n        }\n    }\n    if(posNeg.length == 0)\
    \ \n    {\n        return tuple(null, null);\n    }\n    else \n    {\n      \
    \  long[] p;\n        long[] n;\n        p = [];\n        n = [];\n        foreach(e;\
    \ posNeg) \n        {\n            if(e.isNull) \n            {\n            \
    \    continue;\n            }\n            if(e < 0) \n            {\n       \
    \         n ~= e;\n            }\n            else \n            {\n         \
    \       p ~= e;\n            }\n        }\n        if(p.length == 0) \n      \
    \  {\n            return tuple(max(n), null);\n        }\n        else if(n.length\
    \ == 0) \n        {\n            return tuple(null, min(p));\n        }\n    \
    \    else \n        {\n            return tuple(max(n), min(p));\n        }\n\
    \    }\n}", "{\n    // Make the return tuple\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ ret(Nullable!(long).init, Nullable!(long).init);\n    long largestNeg = long.min;\n\
    \    long smallestPos = long.max;\n    // Loop over the array\n    foreach(num;\
    \ lst)\n    {\n        // Find largest negative\n        if(num < 0 && num > largestNeg)\n\
    \        {\n            largestNeg = num;\n        }\n        // Find smallest\
    \ positive\n        if(num > 0 && num < smallestPos)\n        {\n            smallestPos\
    \ = num;\n        }\n    }\n    // If a number was found\n    if(largestNeg !=\
    \ long.min)\n    {\n        ret[0] = Nullable!(long)(largestNeg);\n    }\n   \
    \ if(smallestPos != long.max)\n    {\n        ret[1] = Nullable!(long)(smallestPos);\n\
    \    }\n    return ret;\n}", "{\n    Nullable!(long) smallest = null;\n    Nullable!(long)\
    \ largest = null;\n    foreach(l; lst) \n    {\n        if(!largest.isNull &&\
    \ !smallest.isNull) \n        {\n            if(l < 0 && l > largest)\n      \
    \          largest = l;\n            else if(l > 0 && l < smallest)\n        \
    \        smallest = l;\n        }\n        else if(largest.isNull && l < 0)\n\
    \            largest = l;\n        else if(smallest.isNull && l > 0)\n       \
    \     smallest = l;\n    }\n    return tuple(largest, smallest);\n}", "{\n   \
    \ Nullable!(long) min = Nullable!(long)();\n    Nullable!(long) max = Nullable!(long)();\n\
    \    if (lst.length > 0)\n    {\n        max = lst[0];\n        min = lst[0];\n\
    \        foreach (i; 1..lst.length)\n        {\n            if (lst[i] > max)\n\
    \            {\n                max = lst[i];\n            }\n            if (lst[i]\
    \ < min)\n            {\n                min = lst[i];\n            }\n      \
    \  }\n    }\n    return tuple(max, min);\n}", "{\n    long min = long.max;\n \
    \   long max = long.min;\n    bool has_neg = false;\n    bool has_pos = false;\n\
    \    foreach(it; lst) \n    {\n        if(it < 0) \n        {\n            max\
    \ = max(max, it);\n            has_neg = true;\n        }\n        else if(it\
    \ > 0) \n        {\n            min = min(min, it);\n            has_pos = true;\n\
    \        }\n    }\n    return tuple(has_neg ? to!long(max) : null, has_pos ? to!long(min)\
    \ : null);\n}", "{\n    long min = long.max;\n    long max = long.min;\n    foreach(item;\
    \ lst)\n    {\n        if(item >= 0)\n        {\n            if(item < min)\n\
    \            {\n                min = item;\n            }\n        }\n      \
    \  else\n        {\n            if(item > max)\n            {\n              \
    \  max = item;\n            }\n        }\n    }\n    return tuple( max != long.min\
    \ ? max : null, min != long.max ? min : null);\n}", "{\n    Nullable!(long) largestNeg\
    \ = Nullable!(long)();\n    Nullable!(long) smallestPos = Nullable!(long)();\n\
    \    foreach(elem; lst) \n    {\n        if(elem < 0L) \n        {\n         \
    \   if(!largestNeg.isNull) \n            {\n                if(largestNeg.get\
    \ < elem)\n                    largestNeg.set(elem);\n            }\n        \
    \    else\n                largestNeg.set(elem);\n        }\n        else if(elem\
    \ > 0L) \n        {\n            if(!smallestPos.isNull) \n            {\n   \
    \             if(smallestPos.get > elem)\n                    smallestPos.set(elem);\n\
    \            }\n            else\n                smallestPos.set(elem);\n   \
    \     }\n    }\n    return tuple(largestNeg, smallestPos);\n}", "{\n    long maxNeg\
    \ = -999999999L;\n    long minPos = 999999999L;\n    bool seenPos = false;\n \
    \   bool seenNeg = false;\n    foreach(l; lst)\n    {\n        if(l < 0)\n   \
    \     {\n            if(!seenNeg)\n            {\n                seenNeg = true;\n\
    \                maxNeg = l;\n            }\n            else if(l > maxNeg)\n\
    \            {\n                maxNeg = l;\n            }\n        }\n      \
    \  else if(l > 0)\n        {\n            if(!seenPos)\n            {\n      \
    \          seenPos = true;\n                minPos = l;\n            }\n     \
    \       else if(l < minPos)\n            {\n                minPos = l;\n    \
    \        }\n        }\n    }\n    return tuple(maxNeg == -999999999L ? null :\
    \ maxNeg, minPos == 999999999L ? null : minPos);\n}", "{\n    Nullable!(long)\
    \ min, max;\n    min = max = Nullable!(long).init;\n    foreach(i; lst)\n    {\n\
    \        if(i < 0)\n        {\n            if(max.isNull || i > max.get!)\n  \
    \              max = i;\n        }\n        else if(i > 0)\n        {\n      \
    \      if(min.isNull || i < min.get!)\n                min = i;\n        }\n \
    \   }\n    return tuple(max, min);\n}", "{\n    long smallest=0, largest=0;",
  "{\n    assert(lst.length >= 0);\n    Nullable!(long) min = null;\n    Nullable!(long)\
    \ max = null;\n    foreach(n; lst) \n    {\n        if (n < 0) \n        {\n \
    \           if (max is null || n > max) \n            {\n                max =\
    \ n;\n            }\n        } \n        else if (n > 0) \n        {\n       \
    \     if (min is null || n < min) \n            {\n                min = n;\n\
    \            }\n        }\n    }\n    return tuple(max, min);\n}", "{\n    Nullable!(long)\
    \ largestNeg = Nullable!(long)();\n    Nullable!(long) smallestPos = Nullable!(long)();\n\
    \    foreach(elem; lst)\n    {\n        if(elem < 0)\n        {\n            if(largestNeg.isNull\
    \ || largestNeg.get > elem)\n            {\n                largestNeg = Nullable!(long)(elem);\n\
    \            }\n        }\n        else if(elem > 0)\n        {\n            if(smallestPos.isNull\
    \ || smallestPos.get > elem)\n            {\n                smallestPos = Nullable!(long)(elem);\n\
    \            }\n        }\n    }\n    return tuple(largestNeg, smallestPos);\n\
    }", "{\n    Nullable!(long) largestNegative(Nullable!(long)[] negatives) {\n \
    \       if (negatives.length > 0) {\n            long largest = negatives[0];\n\
    \            foreach (n; negatives) {\n                if (n > largest) {\n  \
    \                  largest = n;\n                }\n            }\n          \
    \  return largest;\n        }\n        return Nullable!(long)();\n    }\n    Nullable!(long)\
    \ smallestPositive(Nullable!(long)[] positives) {\n        if (positives.length\
    \ > 0) {\n            long smallest = positives[0];\n            foreach (p; positives)\
    \ {\n                if (p < smallest) {\n                    smallest = p;\n\
    \                }\n            }\n            return smallest;\n        }\n \
    \       return Nullable!(long)();\n    }\n    return tuple(largestNegative(filter!(x\
    \ => x < 0)(lst)),\n                 smallestPositive(filter!(x => x > 0)(lst)));\n\
    }", "{\n    alias N = Nullable!(long);\n    N[] neg = lst.filter!(a => a < 0L).sort;\n\
    \    N[] pos = lst.filter!(a => a > 0L).sort;\n    if (neg.length > 0)\n    {\n\
    \        return tuple(neg.back, pos.front);\n    }\n    else\n    {\n        return\
    \ tuple(null, pos.front);\n    }\n}", "{\n    auto largest_negative = (long) max(elem[0L]\
    \ for elem in lst if elem < 0L);\n    auto smallest_positive = (long) min(elem[0L]\
    \ for elem in lst if elem > 0L);\n    return tuple(largest_negative.nullable,\
    \ smallest_positive.nullable);\n}", "{\n    Nullable!(long) max = Nullable!(long)().init;\n\
    \    Nullable!(long) min = Nullable!(long)().init;\n    foreach(n; lst)\n    {\n\
    \        if(n > 0)\n        {\n            if(min.isNull)\n            {\n   \
    \             min = n;\n            }\n            else\n            {\n     \
    \           min = min.get < n ? min.get : n;\n            }\n        }\n     \
    \   else if(n < 0)\n        {\n            if(max.isNull)\n            {\n   \
    \             max = n;\n            }\n            else\n            {\n     \
    \           max = max.get > n ? max.get : n;\n            }\n        }\n    }\n\
    \    return tuple(max, min);\n}", "{\n    long a = 0;\n    long b = 0;\n    auto\
    \ n = lst.length;\n    if (n == 0)\n    {\n        return tuple(to!Nullable(a),\
    \ to!Nullable(b));\n    }\n    auto i = 0;\n    long max = 0;\n    long min =\
    \ 0;\n    for (i = 0; i < n; i++)\n    {\n        if (lst[i] > 0)\n        {\n\
    \            min = min > lst[i] ? lst[i] : min;\n        }\n        else if (lst[i]\
    \ < 0)\n        {\n            max = max < lst[i] ? lst[i] : max;\n        }\n\
    \    }\n    if (min == 0 && max == 0)\n    {\n        return tuple(to!Nullable(a),\
    \ to!Nullable(b));\n    }\n    else if (min == 0)\n    {\n        return tuple(to!Nullable(max),\
    \ to!Nullable(b));\n    }\n    else if (max == 0)\n    {\n        return tuple(to!Nullable(a),\
    \ to!Nullable(min));\n    }\n    else\n    {\n        return tuple(to!Nullable(max),\
    \ to!Nullable(min));\n    }\n}", "    nothrow pure safe\n{\n    auto iter = lst.filter!(e\
    \ => e != 0).sorted.partition!(e => e > 0);\n    return tuple(\n        iter.first.length\
    \ == 0 ? null : iter.first.front,\n        iter.second.length == 0 ? null : iter.second.back\n\
    \    );\n}", "{\n\tNullable!(long) max_neg_int;\n\tNullable!(long) min_pos_int;\n\
    \tforeach(number; lst)\n\t{\n\t\tif(number < 0)\n\t\t{\n\t\t\tif(!max_neg_int.isNull)\n\
    \t\t\t{\n\t\t\t\tif(number > max_neg_int)\n\t\t\t\t{\n\t\t\t\t\tmax_neg_int =\
    \ number;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax_neg_int = number;\n\
    \t\t\t}\n\t\t}\n\t\telse if(number > 0)\n\t\t{\n\t\t\tif(!min_pos_int.isNull)\n\
    \t\t\t{\n\t\t\t\tif(number < min_pos_int)\n\t\t\t\t{\n\t\t\t\t\tmin_pos_int =\
    \ number;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmin_pos_int = number;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn tuple(max_neg_int, min_pos_int);\n}\nassert(largest_smallest_integers([2L,\
    \ 4L, 1L, 3L, 5L, 7L]) == tuple(None, 1L));\nassert(largest_smallest_integers([])\
    \ == tuple(None, None));\nassert(largest_smallest_integers([0L]) == tuple(None,\
    \ None));", "{\n\tlong largestNegative;\n\tlong smallestPositive;\n\t\n\tforeach(immutable\
    \ value; lst)\n\t{\n\t\tif(value > 0)\n\t\t{\n\t\t\tsmallestPositive = value;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\t\n\tforeach(immutable value; lst)\n\t{\n\t\tif(value\
    \ < 0)\n\t\t{\n\t\t\tlargestNegative = value;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t\
    foreach(immutable value; lst)\n\t{\n\t\tif(value > 0 && value < smallestPositive)\n\
    \t\t{\n\t\t\tsmallestPositive = value;\n\t\t}\n\t\t\n\t\tif(value < 0 && value\
    \ > largestNegative)\n\t\t{\n\t\t\tlargestNegative = value;\n\t\t}\n\t}\n\t\n\t\
    if(smallestPositive == null)\n\t{\n\t\tsmallestPositive = to!long(Nullable!long.init);\n\
    \t}\n\t\n\tif(largestNegative == null)\n\t{\n\t\tlargestNegative = to!long(Nullable!long.init);\n\
    \t}\n\t\n\treturn tuple(to!long(largestNegative), to!long(smallestPositive));\n\
    }", "    if (lst.length != 0) {\n        long largestNegative = lst[0];\n    \
    \    long smallestPositive = lst[0];\n        foreach (index, value; lst) {\n\
    \            if (value < 0 && largestNegative < value) {\n                largestNegative\
    \ = value;\n            } else if (value > 0 && smallestPositive > value) {\n\
    \                smallestPositive = value;\n            }\n        }\n       \
    \ if (largestNegative == smallestPositive) {\n            return tuple(null, null);\n\
    \        } else {\n            return tuple(largestNegative, smallestPositive);\n\
    \        }\n    } else {\n        return tuple(null, null);\n    }", "{\n    Nullable!(long)\
    \ l = null;\n    Nullable!(long) s = null;\n    foreach(x; lst)\n    {\n     \
    \   if(x < 0)\n        {\n            if(l.isNull || x > l.get)\n            {\n\
    \                l = x;\n            }\n        }\n        else if(x > 0)\n  \
    \      {\n            if(s.isNull || x < s.get)\n            {\n             \
    \   s = x;\n            }\n        }\n    }\n    return tuple(l, s);\n}", "{\n\
    \    long? min = long.max;\n    long? max = long.min;\n    foreach(el; lst) \n\
    \    {\n        if(el < 0)\n        {\n            if(el > max)\n            {\n\
    \                max = el;\n            }\n        }\n        else if(el > 0)\n\
    \        {\n            if(el < min)\n            {\n                min = el;\n\
    \            }\n        }\n    }\n    Nullable!(long) nmax;\n    if(max < 0)\n\
    \    {\n        nmax = max;\n    }\n    else\n    {\n        nmax = null;\n  \
    \  }\n    Nullable!(long) nmin;\n    if(min > 0)\n    {\n        nmin = min;\n\
    \    }\n    else\n    {\n        nmin = null;\n    }\n    return tuple(nmax, nmin);\n\
    }\nstatic assert(largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L]) == tuple(null,\
    \ 1L));\nstatic assert(largest_smallest_integers([]) == tuple(null, null));\n\
    static assert(largest_smallest_integers([0L]) == tuple(null, null));", "{\n  \
    \  auto neg = lst.front;\n    auto pos = lst.front;\n    foreach(e; lst)\n   \
    \ {\n        if(e < 0)\n        {\n            if(!neg.isNull || e > neg.get)\n\
    \                neg = e;\n        }\n        else if(e > 0)\n        {\n    \
    \        if(!pos.isNull || e < pos.get)\n                pos = e;\n        }\n\
    \    }\n    return tuple(neg, pos);\n}", "{\n    bool is_neg = true;\n    bool\
    \ is_pos = true;\n    long largest_neg = 0L;\n    long smallest_pos = 0L;\n  \
    \  foreach(l; lst)\n    {\n        if(l < 0L)\n        {\n            is_neg =\
    \ false;\n            if(largest_neg < l)\n            {\n                largest_neg\
    \ = l;\n            }\n        }\n        else if(l > 0L)\n        {\n       \
    \     is_pos = false;\n            if(smallest_pos > l)\n            {\n     \
    \           smallest_pos = l;\n            }\n        }\n    }\n    return tuple(\n\
    \        is_neg ? Nullable!(long)(largest_neg) : Nullable!(long)(null),\n    \
    \    is_pos ? Nullable!(long)(smallest_pos) : Nullable!(long)(null)\n    );\n\
    }\n/*", "{\n\tif (lst.length == 0)\n\t\treturn tuple(null, null);\n\telse\n\t\
    {\n\t\tlong maxNegative = lst[0];\n\t\tlong minPositive = lst[0];\n\t\tforeach\
    \ (int n; lst)\n\t\t{\n\t\t\tif (n > 0)\n\t\t\t{\n\t\t\t\tif (n < minPositive)\n\
    \t\t\t\t\tminPositive = n;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (n > maxNegative)\n\
    \t\t\t\t\tmaxNegative = n;\n\t\t\t}\n\t\t}\n\t\treturn tuple(maxNegative > 0 ?\
    \ null : maxNegative, minPositive < 0 ? null : minPositive);\n\t}\n}", "in {\n\
    \    assert(lst.length >= 0);\n}\nout (result) {\n    assert(result.length ==\
    \ 2);\n    if (result[0] is Nullable!(long)) {\n        assert(result[0].isNull);\n\
    \    } else {\n        assert(result[0] == min(lst.filter!(x => x < 0)));\n  \
    \  }\n    if (result[1] is Nullable!(long)) {\n        assert(result[1].isNull);\n\
    \    } else {\n        assert(result[1] == max(lst.filter!(x => x > 0)));\n  \
    \  }\n}\ndo {\n    // Write your implementation here\n    Nullable!(long) largest\
    \ = Nullable!(long).init;\n    Nullable!(long) smallest = Nullable!(long).init;\n\
    \    for (l in lst) {\n        if (l < 0) {\n            if (largest.isNull) {\n\
    \                largest = l;\n            } else {\n                largest =\
    \ min(largest, l);\n            }\n        } else if (l > 0) {\n            if\
    \ (smallest.isNull) {\n                smallest = l;\n            } else {\n \
    \               smallest = max(smallest, l);\n            }\n        }\n    }\n\
    \    return tuple(largest, smallest);\n}", "    if (lst.length > 0) {\n      \
    \  long min = lst[0];\n        long max = lst[0];\n        foreach (l; lst) {\n\
    \            if (l < 0 && l > max) {\n                max = l;\n            }\
    \ else if (l > 0 && l < min) {\n                min = l;\n            }\n    \
    \    }\n        if (min > 0) {\n            return tuple(null, min);\n       \
    \ } else if (max < 0) {\n            return tuple(max, null);\n        } else\
    \ {\n            return tuple(null, null);\n        }\n    }\n    else {\n   \
    \     return tuple(null, null);\n    }", "{\n    Nullable!(long) a;\n    Nullable!(long)\
    \ b;\n    foreach(i; lst) \n    {\n        if(i < 0) \n        {\n           \
    \ if(a.isNull || abs(i) > abs(a.get)) \n            {\n                a = i;\n\
    \            }\n        } \n        else if(i > 0) \n        {\n            if(b.isNull\
    \ || i < b.get) \n            {\n                b = i;\n            }\n     \
    \   }\n    }\n    return tuple(a, b);\n}", "{\n    long[] positives = lst.filter!(x\
    \ => x > 0L);\n    long[] negatives = lst.filter!(x => x < 0L);\n    Nullable!(long)\
    \ largest_negative = positives.empty ? Nullable!(long).init : positives.max;\n\
    \    Nullable!(long) smallest_positive = negatives.empty ? Nullable!(long).init\
    \ : negatives.min;\n    return tuple(largest_negative, smallest_positive);\n}",
  "{\n    auto largest = find!((e) => e < 0)(lst);\n    auto smallest = find!((e)\
    \ => e > 0)(lst);\n    return tuple(largest, smallest);\n}", "{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.range;\n    import std.typecons;\n    Nullable!(long)\
    \ maxNeg = max(lst.filter!(x => x < 0).map!(to!long));\n    Nullable!(long) minPos\
    \ = min(lst.filter!(x => x > 0).map!(to!long));\n    return tuple(maxNeg, minPos);\n\
    }", "{\n    Nullable!(long) maxn = null;\n    Nullable!(long) minp = null;\n \
    \   for (long l; lst)\n    {\n        l = lst.front;\n        if (l < 0)\n   \
    \     {\n            if (isNull(maxn) || maxn < l)\n                maxn = l;\n\
    \        }\n        else if (l > 0)\n        {\n            if (isNull(minp) ||\
    \ minp > l)\n                minp = l;\n        }\n        lst = lst.popFront;\n\
    \    }\n    return tuple(maxn, minp);\n}\n \n \n /*\n    Create a function that\
    \ returns array with duplicates removed,\n    and sorted.\n    \n    Examples:\n\
    \    >>> remove_duplicates_and_sort([2L, 4L, 1L, 3L, 5L, 7L])\n    [1L, 2L, 3L,\
    \ 4L, 5L, 7L]\n    >>> remove_duplicates_and_sort([1L, 1L, 1L, 1L, 2L, 2L, 3L,\
    \ 1L, 2L, 1L])\n    [1L, 2L, 3L]\n    >>> remove_duplicates_and_sort([])\n   \
    \ []\n */\nlong[] remove_duplicates_and_sort(long[] lst) \n{\n    long[] result\
    \ = [];\n    for (long l; lst)\n    {\n        l = lst.front;\n        if (!lst.front.in(result))\n\
    \            result ~= l;\n        lst = lst.popFront;\n    }\n    return result.sort;\n\
    }\n \n \n \n /*\n    Create a function that returns all unique characters that\
    \ appear in an array of strings.\n    The function will return an array with strings,\
    \ so sort them as well.\n    The function will ignore the case of the string.\n\
    \    The function should ignore any punctuation characters.\n    \n    Example:\n\
    \    >>> get_unique_characters([\"Hello\", \"World\", \"!\"])\n    [\" \", \"\
    !\", \"H\", \"W\", \"d\", \"e\", \"l", "{\n    static struct Result \n    {\n\
    \        Nullable!(long) largest;\n        Nullable!(long) smallest;\n    }\n\
    \    static auto opBinary(string op : \"==\")(Result a, Result b) { return a.largest\
    \ == b.largest && a.smallest == b.smallest; }\n    static auto opBinary(string\
    \ op : \"!=\")(Result a, Result b) { return a.largest != b.largest || a.smallest\
    \ != b.smallest; }\n    static struct Tester \n    {\n        Nullable!(long)\
    \ largest;\n        Nullable!(long) smallest;\n        static immutable Result[]\
    \ testCases = [\n            Result(Nullable!(long)(), Nullable!(long)()),\n \
    \           Result(Nullable!(long)(2L), Nullable!(long)(1L)),\n            Result(Nullable!(long)(-10L),\
    \ Nullable!(long)(0L)),\n            Result(Nullable!(long)(-1L), Nullable!(long)(-2L)),\n\
    \            Result(Nullable!(long)(-1L), Nullable!(long)(1L)),\n            Result(Nullable!(long)(1L),\
    \ Nullable!(long)(-1L)),\n            Result(Nullable!(long)(null), Nullable!(long)(1L)),\n\
    \            Result(Nullable!(long)(-1L), Nullable!(long)(null)),\n          \
    \  Result(Nullable!(long)(null), Nullable!(long)(null)),\n        ];\n       \
    \ static assert(testCases.length == 9);\n        @property bool get isExerciseVersion()\
    \ { return testCases[0] != testCases[this.largest.isNull ? this.smallest.isNull\
    \ ? 3 : this.smallest < 0 ? 4 : 5 : this.largest < 0 ? 1 : 2]; }\n        static\
    \ void run() { foreach (testCase; testCases) assert(largest_smallest_integers(testCase.largest.isNull\
    \ ? [1L] : [-1L]) == testCase); }\n    }\n    Tester.run();\n    return Tester.isExerciseVersion\
    \ ? tuple(Nullable!(long", "{\n    long[] pos = lst.filter!(a => a > 0).array;\n\
    \    long[] neg = lst.filter!(a => a < 0).array;\n    Nullable!(long) lp, ls;\n\
    \    if (pos.length > 0) \n    {\n        ls = pos.min;\n    }\n    else \n  \
    \  {\n        ls = null;\n    }\n    if (neg.length > 0) \n    {\n        lp =\
    \ neg.max;\n    }\n    else \n    {\n        lp = null;\n    }\n    return tuple(lp,\
    \ ls);\n}", "{\n    Nullable!(long) a = null;\n    Nullable!(long) b = null;\n\
    \    foreach(n; lst)\n    {\n        if(n < 0)\n        {\n            if(a is\
    \ null || a < n)\n                a = n;\n        }\n        else if(n > 0)\n\
    \        {\n            if(b is null || b > n)\n                b = n;\n     \
    \   }\n    }\n    return tuple(a, b);\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ ret;\n    ret[0] = null;\n    ret[1] = null;\n    if (lst.length == 0) \n  \
    \  {\n        return ret;\n    }\n    long min, max;\n    min = max = lst[0];\n\
    \    foreach (i; lst) \n    {\n        if (i < 0) \n        {\n            if\
    \ (min > i) \n            {\n                min = i;\n            }\n       \
    \ }\n        else if (i > 0) \n        {\n            if (max < i) \n        \
    \    {\n                max = i;\n            }\n        }\n    }\n    if (min\
    \ != lst[0]) \n    {\n        ret[0] = min;\n    }\n    if (max != lst[0]) \n\
    \    {\n        ret[1] = max;\n    }\n    return ret;\n}\n/*", "{\n    if (lst.length\
    \ == 0) return tuple(null, null);\n    alias f = tuple(long largest, long smallest);\n\
    \    f find = tuple(long.min, long.max);\n    foreach (i; lst)\n    {\n      \
    \  if (i > 0)\n        {\n            if (i < find.smallest)\n               \
    \ find.smallest = i;\n        }\n        else if (i < 0)\n        {\n        \
    \    if (i > find.largest)\n                find.largest = i;\n        }\n   \
    \ }\n    return tuple(find.largest == long.min ? null : find.largest,\n      \
    \           find.smallest == long.max ? null : find.smallest);\n}", "{\n    import\
    \ std.algorithm;\n    import std.conv;\n    import std.meta;\n    auto pos = lst.filter!(x\
    \ => x > 0).min;\n    auto neg = lst.filter!(x => x < 0).max;\n    if (pos ==\
    \ null) pos = typeof(pos).init;\n    if (neg == null) neg = typeof(neg).init;\n\
    \    return tuple(neg, pos);\n}", "{\n    if (lst.length == 0)\n        return\
    \ tuple(null, null);\n    else\n    {\n        auto largest = Nullable!(long)();\n\
    \        auto smallest = Nullable!(long)();\n        foreach (i; lst)\n      \
    \  {\n            if (i < 0)\n            {\n                if (largest.isNull\
    \ || i > largest.get)\n                    largest = i;\n            }\n     \
    \       else if (i > 0)\n            {\n                if (smallest.isNull ||\
    \ i < smallest.get)\n                    smallest = i;\n            }\n      \
    \  }\n        return tuple(largest, smallest);\n    }\n}", "{\n    return tuple(\n\
    \        maxElement(lst.filter!(x => x < 0), x => x),\n        minElement(lst.filter!(x\
    \ => x > 0), x => x)\n    );\n}", "{\n    Nullable!(long) largestNeg = Nullable!(long)();\n\
    \    Nullable!(long) smallestPos = Nullable!(long)();\n    foreach(long l; lst)\
    \ \n    {\n        if(l > 0L) \n        {\n            if(!smallestPos.isNull)\
    \ \n            {\n                if(l < smallestPos.value) \n              \
    \  {\n                    smallestPos.value = l;\n                }\n        \
    \    } \n            else \n            {\n                smallestPos.value =\
    \ l;\n            }\n        } \n        else if(l < 0L) \n        {\n       \
    \     if(!largestNeg.isNull) \n            {\n                if(l > largestNeg.value)\
    \ \n                {\n                    largestNeg.value = l;\n           \
    \     }\n            } \n            else \n            {\n                largestNeg.value\
    \ = l;\n            }\n        }\n    }\n    return tuple(largestNeg, smallestPos);\n\
    }\nstatic assert(largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L]) == tuple(null,\
    \ 1L));\nstatic assert(largest_smallest_integers([]) == tuple(null, null));\n\
    static assert(largest_smallest_integers([0L]) == tuple(null, null));", "{\n  \
    \  import std.algorithm.sorting : sort;\n    import std.range : filter;\n    import\
    \ std.range : take;\n    import std.range : takeExactly;\n    import std.range\
    \ : takeWhile;\n    import std.range : zip;\n    import std.range : zipShortest;\n\
    \    alias pair = Tuple!(Nullable!(long), Nullable!(long));\n    alias nullableLong\
    \ = Nullable!(long);\n    lst = lst.sort.filter!(a => a != 0).take!(3);\n    return\
    \ lst.zipShortest!(nullableLong.fromNull).map!(a => a[0] - a[1]).takeExactly(2).array.zip(lst).map!(a\
    \ => tuple(a[0][0] < 0 ? a[1] : null, a[0][1] > 0 ? a[1] : null)).map!(a => tuple(a[0]\
    \ == null ? null : nullableLong.fromNull, a[1] == null ? null : nullableLong.fromNull)).takeExactly(2).array[0];\n\
    }", "    @safe pure nothrow {\n    // Testing...\n    static assert(is(typeof(largest_smallest_integers([2L,\
    \ 4L, 1L, 3L, 5L, 7L])) == Tuple!(Nullable!(long), Nullable!(long))));\n    static\
    \ assert(is(typeof(largest_smallest_integers([])) == Tuple!(Nullable!(long), Nullable!(long))));\n\
    \    static assert(is(typeof(largest_smallest_integers([0L])) == Tuple!(Nullable!(long),\
    \ Nullable!(long))));\n    static assert(largest_smallest_integers([2L, 4L, 1L,\
    \ 3L, 5L, 7L]) == tuple(null, 1L));\n    static assert(largest_smallest_integers([])\
    \ == tuple(null, null));\n    static assert(largest_smallest_integers([0L]) ==\
    \ tuple(null, null));\n    enum min = min(lst);\n    enum max = max(lst);\n  \
    \  auto res = tuple(max < 0 ? max : null, min > 0 ? min : null);\n    return res;\n\
    }\n/*", "{\n    import std.algorithm;\n    import std.array;\n    return lst.map!(to!long).retro.filter!(inRange!long(-LONG_MAX,\
    \ 0)).takeExactly(1)\n    .tupleof ~ lst.map!(to!long).filter!(inRange!long(0,\
    \ LONG_MAX)).takeExactly(1).tupleof;\n}", "{\n    int min = 0;\n    int max =\
    \ 0;\n    long min_value = 0;\n    long max_value = 0;\n    foreach(i,e; lst)\n\
    \    {\n        if(e < 0 && e > max_value)\n        {\n            max = i;\n\
    \            max_value = e;\n        }\n        if(e > 0 && (e < min_value ||\
    \ min_value == 0))\n        {\n            min = i;\n            min_value = e;\n\
    \        }\n    }\n    if(max == 0 && min == 0)\n    {\n        return tuple(Nullable!(long)(),\
    \ Nullable!(long)());\n    }\n    else if(max == 0)\n    {\n        return tuple(Nullable!(long)(),\
    \ min_value);\n    }\n    else if(min == 0)\n    {\n        return tuple(max_value,\
    \ Nullable!(long)());\n    }\n    else\n    {\n        return tuple(max_value,\
    \ min_value);\n    }\n}", "{\n    long[] pos_lst;\n    long[] neg_lst;\n    foreach(i;\
    \ lst)\n    {\n        if(i>0)\n        {\n            pos_lst ~= i;\n       \
    \ }\n        else if(i<0)\n        {\n            neg_lst ~= i;\n        }\n \
    \   }\n    return tuple(min(neg_lst), max(pos_lst));\n}\n/*", "{\n    Nullable!(long)\
    \ a = null;\n    Nullable!(long) b = null;\n    foreach(x; lst)\n    {\n     \
    \   if(x < 0L)\n        {\n            if(a is null || x > a) a = x;\n       \
    \ }\n        else if(x > 0L)\n        {\n            if(b is null || x < b) b\
    \ = x;\n        }\n    }\n    return tuple(a, b);\n}", "    if (lst.length &gt;=\
    \ 0) {\n        return tuple(\n            reduce!(max_int_nullable, lst.filter!(a\
    \ =&gt; a &lt; 0L).map!(a =&gt; Nullable!(long)(a))),\n            reduce!(min_int_nullable,\
    \ lst.filter!(a =&gt; a &gt; 0L).map!(a =&gt; Nullable!(long)(a)))\n        );\n\
    \    }\n}", "{\n    long min = 0;\n    long max = 0;\n    bool has_negative =\
    \ false;\n    bool has_positive = false;\n    foreach(item; lst) \n    {\n   \
    \     if(item < 0) \n        {\n            has_negative = true;\n           \
    \ max = max(max, item);\n        } \n        else if(item > 0) \n        {\n \
    \           has_positive = true;\n            min = min(min, item);\n        }\n\
    \    }\n    if(has_negative && has_positive) \n    {\n        return tuple(max,\
    \ min);\n    } \n    else if(has_negative) \n    {\n        return tuple(max,\
    \ null);\n    } \n    else if(has_positive) \n    {\n        return tuple(null,\
    \ min);\n    } \n    else \n    {\n        return tuple(null, null);\n    }\n}",
  "{\n    long maxNeg = long.min;\n    long minPos = long.max;\n    long temp;\n \
    \   foreach(i; lst)\n    {\n        temp = i;\n        if(i < 0)\n        {\n\
    \            if(temp > maxNeg)\n            {\n                maxNeg = temp;\n\
    \            }\n        }\n        else if(i > 0)\n        {\n            if(temp\
    \ < minPos)\n            {\n                minPos = temp;\n            }\n  \
    \      }\n    }\n    return tuple(maxNeg == long.min ? null : maxNeg, minPos ==\
    \ long.max ? null : minPos);\n}", "{\n    Nullable!(long) smallestPositive;\n\
    \    Nullable!(long) largestNegative;\n    foreach(elem; lst)\n    {\n       \
    \ if(elem < 0)\n        {\n            if(largestNegative is null || largestNegative.isEmpty\
    \ || elem > largestNegative.get!)\n            {\n                largestNegative\
    \ = to!Nullable(elem);\n            }\n        }\n        else if(elem > 0)\n\
    \        {\n            if(smallestPositive is null || smallestPositive.isEmpty\
    \ || elem < smallestPositive.get!)\n            {\n                smallestPositive\
    \ = to!Nullable(elem);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}", "{\n    static immutable nullable_max = Nullable!(long)(null);\n\
    \    static immutable nullable_min = Nullable!(long)(null);\n    static assert(isForwardRange!(lst));\n\
    \    foreach(i; lst)\n    {\n        nullable_max.opAssign(max(nullable_max.get,\
    \ i));\n        nullable_min.opAssign(min(nullable_min.get, i));\n    }\n    return\
    \ tuple(nullable_max, nullable_min);\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result = tuple(null, null);\n    auto r = reduce!q{a.positive ? a.value : b};\n\
    \    if (r is null) {\n        result[1] = null;\n    } else {\n        result[1]\
    \ = r;\n    }\n    auto l = reduce!q{a.negative ? a.value : b};\n    if (l is\
    \ null) {\n        result[0] = null;\n    } else {\n        result[0] = l;\n \
    \   }\n    return result;\n}", "{\n    Nullable!(long) largestNegative = Nullable!(long)();\n\
    \    Nullable!(long) smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n\
    \    {\n        if(i < 0)\n        {\n            if(i > largestNegative.get())\n\
    \            {\n                largestNegative = Nullable!(long)(i);\n      \
    \      }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull())\n\
    \            {\n                smallestPositive = Nullable!(long)(i);\n     \
    \       }\n            else if(i < smallestPositive.get())\n            {\n  \
    \              smallestPositive = Nullable!(long)(i);\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}", "in {\n\
    \    assert(lst.length == 0 || !std.algorithm.any!(x => x > 0L)(lst));\n} out\
    \ (result) {\n    if (result[0].isNull) {\n        assert(result[1].isNull);\n\
    \    } else {\n        assert(result[1].isSome);\n    }\n} body {\n    return\
    \ tuple( lst.filter!(x => x < 0L).max,\n                  lst.filter!(x => x >\
    \ 0L).min);\n}", "{\n    long min = long.max;\n    long max = long.min;\n    foreach(val;\
    \ lst)\n    {\n        if(val > 0 && val < min)\n            min = val;\n    \
    \    if(val < 0 && val > max)\n            max = val;\n    }\n    return tuple(max\
    \ == long.min ? null : max, min == long.max ? null : min);\n}", "{\n    Nullable!(long)\
    \ largestNeg = Nullable!(long)(0L);\n    Nullable!(long) smallestPos = Nullable!(long)(0L);\n\
    \    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n            if(!largestNeg\
    \ || largestNeg < l)\n            {\n                largestNeg = l;\n       \
    \     }\n        }\n        else if(l > 0)\n        {\n            if(!smallestPos\
    \ || smallestPos > l)\n            {\n                smallestPos = l;\n     \
    \       }\n        }\n    }\n    return tuple(largestNeg, smallestPos);\n}", "{\n\
    \    auto maxNeg = lst.map!(x => x < 0 ? x : long.min).max;\n    auto minPos =\
    \ lst.map!(x => x > 0 ? x : long.max).min;\n    return tuple(maxNeg != long.min\
    \ ? maxNeg : null, minPos != long.max ? minPos : null);\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) ret;\n    ret.field1 = null;\n    ret.field2 = null;\n    for\
    \ (int i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if\
    \ (ret.field2 is null) {\n                ret.field2 = lst[i];\n            }\
    \ else {\n                ret.field2 = min(ret.field2, lst[i]);\n            }\n\
    \        } else if (lst[i] < 0) {\n            if (ret.field1 is null) {\n   \
    \             ret.field1 = lst[i];\n            } else {\n                ret.field1\
    \ = max(ret.field1, lst[i]);\n            }\n        }\n    }\n    return ret;\n\
    }", "{\n    Nullable!(long) largestNegativeInteger = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositiveInteger = Nullable!(long)();\n    foreach(n; lst)\n    {\n \
    \       if(n < 0)\n        {\n            if(!largestNegativeInteger.isInitialized\
    \ || n > largestNegativeInteger.get())\n            {\n                largestNegativeInteger\
    \ = Nullable!(long)(n);\n            }\n        }\n        else if(n > 0)\n  \
    \      {\n            if(!smallestPositiveInteger.isInitialized || n < smallestPositiveInteger.get())\n\
    \            {\n                smallestPositiveInteger = Nullable!(long)(n);\n\
    \            }\n        }\n    }\n    return tuple(largestNegativeInteger, smallestPositiveInteger);\n\
    }", "{\n    return tuple(null, null);\n}\n/*\n    Solve a binomial equation of\
    \ the form 'ax + b = 0'.", "{\n    Nullable!(long) smallestPositive;\n    Nullable!(long)\
    \ largestNegative;\n    foreach(long n; lst)\n    {\n        if(n > 0)\n     \
    \   {\n            if(smallestPositive.isNull || n < smallestPositive.value)\n\
    \            {\n                smallestPositive = n;\n            }\n       \
    \ }\n        else if(n < 0)\n        {\n            if(largestNegative.isNull\
    \ || n > largestNegative.value)\n            {\n                largestNegative\
    \ = n;\n            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }", "{\n    Nullable!(long) min = null;\n    Nullable!(long) max = null;\n   \
    \ lst = lst.filter!(e => e > 0).sort!((a, b) => a < b);\n    if (lst.length >\
    \ 0)\n        min = lst[0];\n    lst = lst.filter!(e => e < 0).sort!((a, b) =>\
    \ a > b);\n    if (lst.length > 0)\n        max = lst[0];\n    return tuple(max,\
    \ min);\n}", "{\n    Nullable!(long) maxNeg, minPos;\n    foreach(e; lst) \n \
    \   {\n        if (e < 0) \n        {\n            if (!maxNeg.isValid) \n   \
    \         {\n                maxNeg = e;\n            } \n            else \n\
    \            {\n                maxNeg = max(maxNeg, e);\n            }\n    \
    \    } \n        else if (e > 0) \n        {\n            if (!minPos.isValid)\
    \ \n            {\n                minPos = e;\n            } \n            else\
    \ \n            {\n                minPos = min(minPos, e);\n            }\n \
    \       }\n    }\n    return tuple(maxNeg, minPos);\n}", "{\n    return tuple(max(lst.filter!(isNegative)),\
    \ min(lst.filter!(isPositive)));\n}", "in {\n    assert(lst.length >= 0);\n} \n\
    out (result) \nbody {\n    Nullable!(long) a = Nullable!(long).init;\n    Nullable!(long)\
    \ b = Nullable!(long).init;\n    for (auto it = lst.begin(); it < lst.end(); it++)\
    \ \n    {\n        if (*it > 0) \n        {\n            if (b.is_null)\n    \
    \            b = *it;\n            else\n                b = min(b, *it);\n  \
    \      }\n        else if (*it < 0) \n        {\n            if (a.is_null)\n\
    \                a = *it;\n            else\n                a = max(a, *it);\n\
    \        }\n    }\n    result = tuple(a, b);\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    if(lst.length == 0) \n    {\n        result =\
    \ tuple(null, null);\n    }\n    else \n    {\n        long min_pos = 0L;\n  \
    \      long max_neg = 0L;\n        bool have_min_pos = false;\n        bool have_max_neg\
    \ = false;\n        foreach(l; lst) \n        {\n            if(l > 0) \n    \
    \        {\n                if(!have_min_pos) \n                {\n          \
    \          min_pos = l;\n                    have_min_pos = true;\n          \
    \      }\n                else \n                {\n                    min_pos\
    \ = min(min_pos, l);\n                }\n            }\n            else if(l\
    \ < 0) \n            {\n                if(!have_max_neg) \n                {\n\
    \                    max_neg = l;\n                    have_max_neg = true;\n\
    \                }\n                else \n                {\n               \
    \     max_neg = max(max_neg, l);\n                }\n            }\n        }\n\
    \        result = tuple(\n            have_max_neg ? Nullable!(long)(max_neg)\
    \ : null,\n            have_min_pos ? Nullable!(long)(min_pos) : null\n      \
    \  );\n    }\n    return result;\n}\n//short version\nTuple!(Nullable!(long),\
    \ Nullable!(long)) largest_smallest_integers2(long[] lst) \n{\n    if(lst.length\
    \ == 0) \n    {\n        return tuple(null, null);\n    }\n    else \n    {\n\
    \        long min_pos = 0L;\n        long max_neg = 0L;\n        bool have_min_pos\
    \ = false;\n        bool have_max_neg = false;\n        foreach(l; lst) \n   \
    \     {\n            if(l > 0) \n            {\n                if(!have_min_pos)\
    \ \n                {\n                    min_pos = l;\n                    have_min_pos\
    \ = true;\n                }\n                else \n                {\n     \
    \              ", "{\n    long min = long.max;\n    long max = long.min;\n   \
    \ foreach(item; lst) \n    {\n        if (item < 0) \n        {\n            max\
    \ = max(max, item);\n        } \n        else if (item > 0) \n        {\n    \
    \        min = min(min, item);\n        }\n    }\n    return tuple(toNullable(max),\
    \ toNullable(min));\n}\n// Return the largest of the negative integers\n// and\
    \ the smallest of the positive integers", "{\n    long? maxNeg = null;\n    long?\
    \ minPos = null;\n    foreach(l; lst) \n    {\n        if(l > 0) \n        {\n\
    \            if(minPos is null || l < minPos) \n            {\n              \
    \  minPos = l;\n            }\n        }\n        else if(l < 0) \n        {\n\
    \            if(maxNeg is null || l > maxNeg) \n            {\n              \
    \  maxNeg = l;\n            }\n        }\n    }\n    return tuple(maxNeg, minPos);\n\
    }", "{\n    \n    auto min = minElement(lst);\n    auto max = maxElement(lst);\n\
    \    if (min == Nullable!(long).init || max == Nullable!(long).init)\n    {\n\
    \        return tuple(Nullable!(long).init, Nullable!(long).init);\n    }\n  \
    \  if (min > 0)\n    {\n        return tuple(Nullable!(long).init, min);\n   \
    \ }\n    if (max < 0)\n    {\n        return tuple(max, Nullable!(long).init);\n\
    \    }\n    return tuple(max, min);\n}\n/*", "{\n    if(lst.length == 0)\n   \
    \     return tuple(null, null);\n    Nullable!(long) max_neg = null;\n    Nullable!(long)\
    \ min_pos = null;\n    foreach(elem; lst)\n    {\n        if(elem < 0 && (max_neg\
    \ is null || elem > max_neg))\n            max_neg = elem;\n        if(elem >\
    \ 0 && (min_pos is null || elem < min_pos))\n            min_pos = elem;\n   \
    \ }\n    return tuple(max_neg, min_pos);\n}", "{\n    Nullable!(long) maxNegative\
    \ = null;\n    Nullable!(long) minPositive = null;\n    foreach(v; lst)\n    {\n\
    \        if(v < 0)\n        {\n            if(maxNegative.isNull || v > maxNegative.get!)\n\
    \            {\n                maxNegative = to!Nullable(v);\n            }\n\
    \        }\n        else if(v > 0)\n        {\n            if(minPositive.isNull\
    \ || v < minPositive.get!)\n            {\n                minPositive = to!Nullable(v);\n\
    \            }\n        }\n    }\n    return tuple(maxNegative, minPositive);\n\
    }", "{\n    if (lst.length == 0)\n        return tuple(null, null);\n    long?\
    \ resNeg = lst[0];\n    long? resPos = lst[0];\n    foreach (elem; lst) \n   \
    \ {\n        if (elem < 0) \n        {\n            if (resNeg < elem)\n     \
    \           resNeg = elem;\n        } \n        else if (elem > 0) \n        {\n\
    \            if (resPos > elem)\n                resPos = elem;\n        }\n \
    \   }\n    return tuple(resNeg, resPos);\n}", "{\n    Nullable!(long) neg = null;\n\
    \    Nullable!(long) pos = null;\n    foreach(i; lst) \n    {\n        if(i >\
    \ 0) \n        {\n            if(pos is null) \n            {\n              \
    \  pos = i;\n            }\n            else \n            {\n               \
    \ pos = min(pos, i);\n            }\n        }\n        else if(i < 0) \n    \
    \    {\n            if(neg is null) \n            {\n                neg = i;\n\
    \            }\n            else \n            {\n                neg = max(neg,\
    \ i);\n            }\n        }\n    }\n    return tuple(neg, pos);\n}", "{\n\
    \    long smallestPositive = null;\n    long largestNegative = null;\n    foreach(index,\
    \ element; lst)\n    {\n        if(element > 0)\n        {\n            if(smallestPositive\
    \ is null)\n            {\n                smallestPositive = element;\n     \
    \       }\n            else\n            {\n                smallestPositive =\
    \ min(smallestPositive, element);\n            }\n        }\n        else if(element\
    \ < 0)\n        {\n            if(largestNegative is null)\n            {\n  \
    \              largestNegative = element;\n            }\n            else\n \
    \           {\n                largestNegative = max(largestNegative, element);\n\
    \            }\n        }\n    }\n    return tuple(to!(Nullable!(long))(largestNegative),\
    \ to!(Nullable!(long))(smallestPositive));\n}", "{\n    Nullable!(long) neg =\
    \ null;\n    Nullable!(long) pos = null;\n    foreach(n; lst)\n    {\n       \
    \ if(n < 0)\n        {\n            if(neg is null || n > neg)\n             \
    \   neg = n;\n        }\n        else if(n > 0)\n        {\n            if(pos\
    \ is null || n < pos)\n                pos = n;\n        }\n    }\n    return\
    \ tuple(neg, pos);\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result\
    \ = tuple(Nullable!(long)(), Nullable!(long)());\n    auto sz = lst.length;\n\
    \    long minimum = max_long;\n    long maximum = min_long;\n    for (long i =\
    \ 0; i < sz; i++)\n    {\n        if (lst[i] < 0)\n        {\n            if (lst[i]\
    \ > maximum)\n            {\n                maximum = lst[i];\n            }\n\
    \        }\n        else if (lst[i] > 0)\n        {\n            if (lst[i] <\
    \ minimum)\n            {\n                minimum = lst[i];\n            }\n\
    \        }\n    }\n    if (maximum == min_long)\n    {\n        result[0] = Nullable!(long)();\n\
    \    }\n    else\n    {\n        result[0] = Nullable!(long)(maximum);\n    }\n\
    \    if (minimum == max_long)\n    {\n        result[1] = Nullable!(long)();\n\
    \    }\n    else\n    {\n        result[1] = Nullable!(long)(minimum);\n    }\n\
    \    return result;\n}", "{\n    bool found_negative = false;\n    bool found_positive\
    \ = false;\n    long largest_negative = 0L;\n    long smallest_positive = 0L;\n\
    \    foreach(long i; lst) \n    {\n        if (i > 0L) \n        {\n         \
    \   if (!found_positive) \n            {\n                found_positive = true;\n\
    \                smallest_positive = i;\n            } \n            else if (i\
    \ < smallest_positive) \n            {\n                smallest_positive = i;\n\
    \            }\n        } \n        else if (i < 0L) \n        {\n           \
    \ if (!found_negative) \n            {\n                found_negative = true;\n\
    \                largest_negative = i;\n            } \n            else if (i\
    \ > largest_negative) \n            {\n                largest_negative = i;\n\
    \            }\n        }\n    }\n    return tuple(Nullable!(long)(found_negative\
    \ ? largest_negative : null), Nullable!(long)(found_positive ? smallest_positive\
    \ : null));\n}\n/*", "{\n    if (lst.length == 0)\n        return tuple(null,\
    \ null);\n    else\n    {\n        bool no_neg = true;\n        bool no_pos =\
    \ true;\n        long largest = 0;\n        long smallest = 0;\n        foreach\
    \ (i; lst)\n        {\n            if (i < 0)\n            {\n               \
    \ if (no_neg)\n                {\n                    largest = i;\n         \
    \           no_neg = false;\n                }\n                else\n       \
    \             largest = max(largest, i);\n            }\n            else if (i\
    \ > 0)\n            {\n                if (no_pos)\n                {\n      \
    \              smallest = i;\n                    no_pos = false;\n          \
    \      }\n                else\n                    smallest = min(smallest, i);\n\
    \            }\n        }\n        return tuple(no_neg ? null : largest, no_pos\
    \ ? null : smallest);\n    }\n}", "{\n    Nullable!(long) negMax = null;\n   \
    \ Nullable!(long) posMin = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n\
    \        {\n            if(negMax.isNull)\n            {\n                negMax\
    \ = l;\n            }\n            else\n            {\n                negMax\
    \ = max(negMax, l);\n            }\n        }\n        else if(l > 0)\n      \
    \  {\n            if(posMin.isNull)\n            {\n                posMin = l;\n\
    \            }\n            else\n            {\n                posMin = min(posMin,\
    \ l);\n            }\n        }\n    }\n    return tuple(negMax, posMin);\n}\n\
    \ ", "{\n    \n    \n}", "{\n    Nullable!(long) largestNegativeNumber = null;\n\
    \    Nullable!(long) smallestPositiveNumber = null;\n    long min = min(lst);\n\
    \    long max = max(lst);\n    if (min < 0)\n    {\n        largestNegativeNumber\
    \ = min;\n    }\n    if (max > 0)\n    {\n        smallestPositiveNumber = max;\n\
    \    }\n    return tuple(largestNegativeNumber, smallestPositiveNumber);\n}",
  "{\n    Nullable!(long) large, small;\n    for (int i = 0; i < lst.length; i++)\
    \ \n    {\n        if (lst[i] < 0) \n        {\n            if (large is null\
    \ || lst[i] > large)\n                large = lst[i];\n        }\n        else\
    \ \n        {\n            if (small is null || lst[i] < small)\n            \
    \    small = lst[i];\n        }\n    }\n    return tuple(large, small);\n}", "{\n\
    \    Nullable!(long) largest_negative;\n    Nullable!(long) smallest_positive;\n\
    \    foreach(i; lst)\n    {\n        if(largest_negative.isNull() && smallest_positive.isNull())\n\
    \        {\n            largest_negative = Nullable!(long)(i);\n            smallest_positive\
    \ = Nullable!(long)(i);\n        }\n        else if(i > 0)\n        {\n      \
    \      if(i < smallest_positive.get!())\n            {\n                smallest_positive\
    \ = Nullable!(long)(i);\n            }\n        }\n        else if(i < 0)\n  \
    \      {\n            if(i > largest_negative.get!())\n            {\n       \
    \         largest_negative = Nullable!(long)(i);\n            }\n        }\n \
    \   }\n    if(largest_negative.isNull())\n    {\n        largest_negative = Nullable!(long)(null);\n\
    \    }\n    if(smallest_positive.isNull())\n    {\n        smallest_positive =\
    \ Nullable!(long)(null);\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }", "in\n{\n    assert(lst.all!(e => e == lst[0] || e < lst[0]));\n}\nout\n(\n\
    \    auto ret\n)\n{\n    auto pos = std.algorithm.find_if(lst, e => e > 0);\n\
    \    auto pos_last = std.algorithm.find_if(lst, e => e > 0, false);\n    auto\
    \ neg = std.algorithm.find_if(lst, e => e < 0);\n    auto neg_last = std.algorithm.find_if(lst,\
    \ e => e < 0, false);\n    import std.conv : to;\n    ret = tuple(neg_last ? to!Nullable(neg_last)\
    \ : null,\n                pos_last ? to!Nullable(pos_last) : null);\n    assert(ret[0]\
    \ == null || ret[0] == (neg_last ? neg_last : null));\n    assert(ret[1] == null\
    \ || ret[1] == (pos_last ? pos_last : null));\n}\nbody\n{\n    return tuple(lst.min!((a,\
    \ b) => b < a).to!Nullable(),\n                 lst.max!((a, b) => b > a).to!Nullable());\n\
    }", "{\n    Nullable!(long) maxNeg = typeof(return).init.init;\n    Nullable!(long)\
    \ minPos = typeof(return).init.init;\n    foreach(l; lst)\n    {\n        if(l\
    \ < 0)\n        {\n            if(maxNeg is null || l > maxNeg)\n            \
    \    maxNeg = l;\n        }\n        else if(l > 0)\n        {\n            if(minPos\
    \ is null || l < minPos)\n                minPos = l;\n        }\n    }\n    return\
    \ typeof(return)(maxNeg, minPos);\n}", "{\n    Nullable!(long) maxNeg = null;\n\
    \    Nullable!(long) minPos = null;\n    foreach(e; lst)\n    {\n        if(e\
    \ == 0)\n            continue;\n        if(e < 0)\n        {\n            if(maxNeg\
    \ is null || e > maxNeg)\n                maxNeg = e;\n        }\n        else\n\
    \        {\n            if(minPos is null || e < minPos)\n                minPos\
    \ = e;\n        }\n    }\n    return tuple(maxNeg, minPos);\n}", "{\n    long\
    \ max = long.min;\n    long min = long.max;\n    foreach(el; lst) \n    {\n  \
    \      if (el > 0 && el < min)\n            min = el;\n        if (el < 0 && el\
    \ > max)\n            max = el;\n    }\n    return tuple(Nullable!(long)(min ==\
    \ long.max ? null : max), Nullable!(long)(min == long.max ? null : min));\n}",
  "{\n    auto positive = filter!((n) => n > 0L)(lst);\n    auto negative = filter!((n)\
    \ => n < 0L)(lst);\n    return tuple(negative.empty ? null : max(negative), positive.empty\
    \ ? null : min(positive));\n}", "{\n    Nullable!(long) maxNeg = null;\n    Nullable!(long)\
    \ minPos = null;\n    foreach(num; lst)\n    {\n        if(num < 0 && (maxNeg\
    \ is null || num > maxNeg))\n            maxNeg = num;\n        else if(num >\
    \ 0 && (minPos is null || num < minPos))\n            minPos = num;\n    }\n \
    \   return tuple(maxNeg, minPos);\n}\n/*", "{\n    long min = Nullable!(long).init;\n\
    \    long max = Nullable!(long).init;\n    bool first_positive = true;\n    bool\
    \ first_negative = true;\n    foreach(l; lst)\n    {\n        if(l > 0)\n    \
    \    {\n            if(first_positive)\n            {\n                min = l;\n\
    \                first_positive = false;\n            }\n            else\n  \
    \          {\n                min = min < l ? min : l;\n            }\n      \
    \  }\n        else if(l < 0)\n        {\n            if(first_negative)\n    \
    \        {\n                max = l;\n                first_negative = false;\n\
    \            }\n            else\n            {\n                max = max > l\
    \ ? max : l;\n            }\n        }\n    }\n    return tuple(max, min);\n}",
  "    // implement this function\n    /*\n        (long[])\n        filter!(\n  \
    \          (long x) => x < 0L\n        )(lst)\n        .\n        map!(\n    \
    \        (long x) => Math.abs(x)\n        )\n        .\n        reduce!(\n   \
    \         Math.max\n        )\n    */\n{\n    return tuple(null, null);\n}", "{\n\
    \    long minp = long.max;\n    long maxn = long.min;\n    foreach(v; lst) \n\
    \    {\n        if (v > 0) \n        {\n            minp = min(minp, v);\n   \
    \     } \n        else if (v < 0) \n        {\n            maxn = max(maxn, v);\n\
    \        }\n    }\n    if (minp == long.max) \n    {\n        minp = typeof(minp).init;\n\
    \    }\n    if (maxn == long.min) \n    {\n        maxn = typeof(maxn).init;\n\
    \    }\n    return tuple(maxn, minp);\n}\nstatic assert(largest_smallest_integers([2L,\
    \ 4L, 1L, 3L, 5L, 7L]) == tuple(None, 1L));\nstatic assert(largest_smallest_integers([])\
    \ == tuple(None, None));\nstatic assert(largest_smallest_integers([0L]) == tuple(None,\
    \ None));\nstatic assert(largest_smallest_integers([1L, 2L, -1L, -2L]) == tuple(-2L,\
    \ 1L));", "{\n    if (lst.length == 0) return tuple(null, null);\n    return tuple(lst.filter!(x\
    \ => x < 0).max, lst.filter!(x => x > 0).min);\n}\n \n/*", "    if (lst.length\
    \ > 0)\n{\n    long min = long.max;\n    long max = long.min;\n    foreach (item;\
    \ lst) \n    {\n        if (item < 0) \n        {\n            max = max(max,\
    \ item);\n        }\n        else if (item > 0) \n        {\n            min =\
    \ min(min, item);\n        }\n    }\n    return tuple(max > long.min ? max : null,\
    \ min < long.max ? min : null);\n}\n```"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
