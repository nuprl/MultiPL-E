name: HumanEval_88_sort_array
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // your code\
    \ here\n    import std.conv;\n    long[] result = array;\n    int sum = 0;\n \
    \   foreach(x; result)\n    {\n        sum += x;\n    }\n    if(sum % 2 == 0)\n\
    \    {\n        result.sort!((a, b) => a > b);\n    }\n    else\n    {\n     \
    \   result.sort!((a, b) => a < b);\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpur3ym5og.d(35): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpur3ym5og.d(39): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpur3ym5og.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int i = 0;\n\
    \    while(i < array.length)\n    {\n        if((array[0] + array[array.length\
    \ - 1]) % 2 == 0)\n        {\n            long a = array[i];\n            long\
    \ b = array[array.length - 1 - i];\n            array[i] = b;\n            array[array.length\
    \ - 1 - i] = a;\n        }\n        i++;\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz9g83j7f.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286c5]\\n??:? void tmpz9g83j7f.__unittest_L39_C1()\
    \ [0x4280ca]\\n??:? void tmpz9g83j7f.__modtest() [0x428448]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c723]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430749]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bf8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b58d]\\n??:? runModuleUnitTests [0x42c4f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b88]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b0f]\\n??:? _d_run_main [0x428a7a]\\n??:? main [0x42845b]\\\
    n??:? __libc_start_main [0xdf4ff554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // TODO: Your\
    \ code here.\n    auto result = array.dup;\n    auto len = result.length;\n  \
    \  bool descending = result[0] + result[len - 1] % 2 == 0;\n    if (descending)\
    \ \n    {\n        result.sort!((x, y) => y - x);\n    }\n    else \n    {\n \
    \       result.sort!((x, y) => x - y);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj1psrvx6.d(31): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpj1psrvx6.d(35): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj1psrvx6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result\
    \ = new long[array.length];\n    if(array.length == 0)\n        return result;\n\
    \    long total = 0;\n    for(long i = 0; i < array.length; i++)\n    {\n    \
    \    total += array[i];\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    if((first + last) % 2 == 0)\n    {\n        std.algorithm.sort(array);\n\
    \        array.reverse();\n    }\n    else\n    {\n        std.algorithm.sort(array);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6fji8_0m.d(37): Error: undefined identifier `algorithm` in package\
    \ `std`\\n/tmp/tmp6fji8_0m.d(38): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmp6fji8_0m.d(42):\
    \ Error: undefined identifier `algorithm` in package `std`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6fji8_0m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int[] index\
    \ = std.range(0, array.length);\n    int[long] comparator = array.zip(index).sort;\n\
    \    if (comparator.values[0] + comparator.values[$ - 1] % 2 == 0) \n    {\n \
    \       comparator.values = comparator.values.reversed;\n    }\n    return index.map!((int\
    \ i) => comparator[i]);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr8r06tls.d(25): Deprecation: package `std.range` is not accessible\
    \ here\\n/tmp/tmpr8r06tls.d(25): Error: function expected before `()`, not `package\
    \ range` of type `void`\\n/tmp/tmpr8r06tls.d(26): Error: no property `zip` for\
    \ type `long[]`\\n/tmp/tmpr8r06tls.d(29): Error: no property `reversed` for type\
    \ `int[]`\\n/tmp/tmpr8r06tls.d(31): Error: no property `map` for type `int[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr8r06tls.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1) \n        return array;\n    \n    if (array[0] +\
    \ array[array.length - 1] % 2 == 0) \n        return array.sort(reverseCompare);\n\
    \    \n    return array.sort(Compare);\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpopl29ibi.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpopl29ibi.d(31): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpopl29ibi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    //  Sort the\
    \ given array in ascending order if the sum( first index value, last index value)\
    \ is odd,\n    //  or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n    bool descending = cast(int)(array[0] + array[$-1])\
    \ % 2 == 0;\n    return array.sort( (a, b) => descending ? a < b : a > b);\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphh8shbou.d(28): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphh8shbou.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    enum ordering\
    \ {\n        greater,\n        lesser\n    }\n    auto getFirstNLastSum = (long[]\
    \ arr) => {\n        import std.array;\n        return arr[0] + arr.back;\n  \
    \  };\n    static bool isOdd(long n) {\n        return n % 2 == 1;\n    }\n  \
    \  static bool isEven(long n) {\n        return n % 2 == 0;\n    }\n    auto sortItems\
    \ = (long[] arr, ordering o) => {\n        return o == ordering.greater ? arr.sort(std.math.comparison!(\"\
    a > b\")) : arr.sort(std.math.comparison!(\"a < b\"));\n    };\n    static bool\
    \ isEmpty(long[] arr) {\n        return arr.length == 0;\n    }\n    static bool\
    \ isSingleElement(long[] arr) {\n        return arr.length == 1;\n    }\n    static\
    \ bool isMoreThanTwo(long[] arr) {\n        return arr.length > 2;\n    }\n  \
    \  switch(true) {\n        case isEmpty(array):\n            return array;\n \
    \       case isSingleElement(array):\n            return array;\n        case\
    \ isMoreThanTwo(array):\n            if(isOdd(getFirstNLastSum(array)))\n    \
    \            return sortItems(array, ordering.lesser);\n            else if(isEven(getFirstNLastSum(array)))\n\
    \                return sortItems(array, ordering.greater);\n    }\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwi0vz72y.d(40): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpwi0vz72y.d(40): Error: no property `sort` for type `long[]`\\n/tmp/tmpwi0vz72y.d(52):\
    \ Error: variable `array` cannot be read at compile time\\n/tmp/tmpwi0vz72y.d(52):\
    \        called from here: `isEmpty(array)`\\n/tmp/tmpwi0vz72y.d(54): Error: variable\
    \ `array` cannot be read at compile time\\n/tmp/tmpwi0vz72y.d(54):        called\
    \ from here: `isSingleElement(array)`\\n/tmp/tmpwi0vz72y.d(56): Error: variable\
    \ `array` cannot be read at compile time\\n/tmp/tmpwi0vz72y.d(56):        called\
    \ from here: `isMoreThanTwo(array)`\\n/tmp/tmpwi0vz72y.d(57): Error: function\
    \ `tmpwi0vz72y.sort_array.isOdd(long n)` is not callable using argument types\
    \ `(long delegate() pure nothrow @nogc @safe)`\\n/tmp/tmpwi0vz72y.d(57):     \
    \   cannot pass argument `(*getFirstNLastSum)(array)` of type `long delegate()\
    \ pure nothrow @nogc @safe` to parameter `long n`\\n/tmp/tmpwi0vz72y.d(59): Error:\
    \ function `tmpwi0vz72y.sort_array.isEven(long n)` is not callable using argument\
    \ types `(long delegate() pure nothrow @nogc @safe)`\\n/tmp/tmpwi0vz72y.d(59):\
    \        cannot pass argument `(*getFirstNLastSum)(array)` of type `long delegate()\
    \ pure nothrow @nogc @safe` to parameter `long n`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwi0vz72y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    long sum = array[0] + array[array.length -\
    \ 1];\n    long[] ret = array.sort(x => x);\n    return (sum & 1) == 0 ? ret.reverse()\
    \ : ret;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxncl1i7r.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpxncl1i7r.d(29): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpxncl1i7r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    size_t n = array.length;\n\
    \    if (n == 0) return array;\n    size_t m = n >> 1;\n    long* lhs = sort_array(array[0..m]);\n\
    \    long* rhs = sort_array(array[m..$]);\n    if ((lhs[0] + rhs[$-1]) & 1) \n\
    \    {\n        return lhs.sort().array() ~ rhs.sort().array();\n    }\n    else\
    \ \n    {\n        return lhs.sort!q{a > b}.array() ~ rhs.sort!q{a > b}.array();\n\
    \    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpytq0z114.d(28): Error: cannot implicitly convert expression `sort_array(array[0..m])`\
    \ of type `long[]` to `long*`\\n/tmp/tmpytq0z114.d(29): Error: cannot implicitly\
    \ convert expression `sort_array(array[m..__dollar])` of type `long[]` to `long*`\\\
    n/tmp/tmpytq0z114.d(30): Error: undefined identifier `__dollar`\\n/tmp/tmpytq0z114.d(32):\
    \ Error: no property `sort` for type `long*`\\n/tmp/tmpytq0z114.d(32): Error:\
    \ no property `sort` for type `long*`\\n/tmp/tmpytq0z114.d(36): Error: no property\
    \ `sort` for type `long*`\\n/tmp/tmpytq0z114.d(36): Error: no property `sort`\
    \ for type `long*`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpytq0z114.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return sort_array_internal(array,\
    \ 0, array.length, 0);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkd3impab.d(25): Error: undefined identifier `sort_array_internal`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkd3impab.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long first_value\
    \ = array[0];\n    long last_value = array[array.length - 1];\n    if((first_value\
    \ + last_value) % 2 == 0)\n    {\n        std.sort(array);\n        return array;\n\
    \    }\n    else\n    {\n        std.sort(array);\n        array.reverse();\n\
    \        return array;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5jq1qua5.d(29): Error: undefined identifier `sort` in package\
    \ `std`\\n/tmp/tmp5jq1qua5.d(34): Error: undefined identifier `sort` in package\
    \ `std`\\n/tmp/tmp5jq1qua5.d(35): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp5jq1qua5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int size = array.length;\n\
    \    long[] answer = array.dup;\n    bool isOdd = (array[0] + array[size - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        sort(answer);\n    }\n    else\n \
    \   {\n        sort(answer, (a, b) => b - a);\n    }\n    return answer;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc8rapsul.d(25): Error: cannot implicitly convert expression `array.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpc8rapsul.d(30): Error: undefined identifier\
    \ `sort`, did you mean function `sqrt`?\\n/tmp/tmpc8rapsul.d(34): Error: undefined\
    \ identifier `sort`, did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpc8rapsul.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long first =\
    \ array[0];\n    long last = array[array.length - 1];\n    bool isOdd = (first\
    \ + last) % 2 == 1;\n    //std.algorithm.sort(array);\n    if (isOdd)\n    {\n\
    \        std.algorithm.sort(array);\n    }\n    else\n    {\n        array = array.sorted;\n\
    \        array = array.reversed;\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfu92llr2.d(31): Error: undefined identifier `algorithm` in package\
    \ `std`\\n/tmp/tmpfu92llr2.d(35): Error: no property `sorted` for type `long[]`\\\
    n/tmp/tmpfu92llr2.d(36): Error: no property `reversed` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfu92llr2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    return sortArray(array);\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa1rcpsii.d(26): Error: undefined identifier `sortArray`, did\
    \ you mean function `sort_array`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpa1rcpsii.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int n = array.length;\n\
    \    if (n == 0) return array;\n    bool odd = (array[0] + array[n - 1]) % 2 ==\
    \ 1;\n    long[] copy = array.dup;\n    sort!((a, b) => a < b, copy);\n    return\
    \ odd ? copy : copy.reverse;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpknjahjsz.d(25): Error: cannot implicitly convert expression `array.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpknjahjsz.d(29): Error: template instance\
    \ `sort!((a, b) => a < b, copy)` template `sort` is not defined, did you mean\
    \ sqrt?\\n/tmp/tmpknjahjsz.d(30): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpknjahjsz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  return array.length\
    \ == 0 || array.length == 1 ? array : sum(array[0], array[$ - 1]) % 2 == 0\n \
    \   ? array.sort().reverse() : array.sort();\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5cnlk3m9.d(25): Error: undefined identifier `sum`\\n/tmp/tmp5cnlk3m9.d(26):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmp5cnlk3m9.d(26): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5cnlk3m9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    sort_by_oddness(array);\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8kbur7id.d(27): Error: undefined identifier `sort_by_oddness`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8kbur7id.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    auto start = array[0];\n    auto end = array[$\
    \ - 1];\n    enum direction = (start + end) % 2 == 0 ? sortDirection.descending\
    \ : sortDirection.ascending;\n    return array.sort!(direction == sortDirection.ascending\
    \ ? (x, y) => x < y : (x, y) => x > y);\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb67_t8es.d(29): Error: undefined identifier `sortDirection`\\\
    n/tmp/tmpb67_t8es.d(29): Error: undefined identifier `sortDirection`\\n/tmp/tmpb67_t8es.d(30):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpb67_t8es.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    \n    auto arraySum = array[0] + array[$-1];\n\
    \    if (arraySum % 2 == 0)\n        return array.sort!\"a > b\";\n    \n    return\
    \ array.sort!\"a < b\";\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjqcay_si.d(30): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpjqcay_si.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjqcay_si.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
