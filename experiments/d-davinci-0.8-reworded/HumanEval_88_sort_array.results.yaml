language: d
name: HumanEval_88_sort_array
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // your code\
    \ here\n    import std.conv;\n    long[] result = array;\n    int sum = 0;\n \
    \   foreach(x; result)\n    {\n        sum += x;\n    }\n    if(sum % 2 == 0)\n\
    \    {\n        result.sort!((a, b) => a > b);\n    }\n    else\n    {\n     \
    \   result.sort!((a, b) => a < b);\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpic0wr3uz.d(35): Error: no property `sort` for type `long[]`

    /tmp/tmpic0wr3uz.d(39): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpic0wr3uz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int i = 0;\n\
    \    while(i < array.length)\n    {\n        if((array[0] + array[array.length\
    \ - 1]) % 2 == 0)\n        {\n            long a = array[i];\n            long\
    \ b = array[array.length - 1 - i];\n            array[i] = b;\n            array[array.length\
    \ - 1 - i] = a;\n        }\n        i++;\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpc6dtck6a.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286c5]

    ??:? void tmpc6dtck6a.__unittest_L39_C1() [0x4280ca]

    ??:? void tmpc6dtck6a.__modtest() [0x428448]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c723]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430749]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430bf8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c4f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b88]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // TODO: Your\
    \ code here.\n    auto result = array.dup;\n    auto len = result.length;\n  \
    \  bool descending = result[0] + result[len - 1] % 2 == 0;\n    if (descending)\
    \ \n    {\n        result.sort!((x, y) => y - x);\n    }\n    else \n    {\n \
    \       result.sort!((x, y) => x - y);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8r3krgeu.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmp8r3krgeu.d(35): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8r3krgeu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result\
    \ = new long[array.length];\n    if(array.length == 0)\n        return result;\n\
    \    long total = 0;\n    for(long i = 0; i < array.length; i++)\n    {\n    \
    \    total += array[i];\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    if((first + last) % 2 == 0)\n    {\n        std.algorithm.sort(array);\n\
    \        array.reverse();\n    }\n    else\n    {\n        std.algorithm.sort(array);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptyxmyb7s.d(37): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmptyxmyb7s.d(38): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmptyxmyb7s.d(42): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptyxmyb7s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int[] index\
    \ = std.range(0, array.length);\n    int[long] comparator = array.zip(index).sort;\n\
    \    if (comparator.values[0] + comparator.values[$ - 1] % 2 == 0) \n    {\n \
    \       comparator.values = comparator.values.reversed;\n    }\n    return index.map!((int\
    \ i) => comparator[i]);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1oqg1g5j.d(25): Deprecation: package `std.range` is not accessible
    here

    /tmp/tmp1oqg1g5j.d(25): Error: function expected before `()`, not `package range`
    of type `void`

    /tmp/tmp1oqg1g5j.d(26): Error: no property `zip` for type `long[]`

    /tmp/tmp1oqg1g5j.d(29): Error: no property `reversed` for type `int[]`

    /tmp/tmp1oqg1g5j.d(31): Error: no property `map` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1oqg1g5j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1) \n        return array;\n    \n    if (array[0] +\
    \ array[array.length - 1] % 2 == 0) \n        return array.sort(reverseCompare);\n\
    \    \n    return array.sort(Compare);\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwk9889p6.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpwk9889p6.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwk9889p6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    //  Sort the\
    \ given array in ascending order if the sum( first index value, last index value)\
    \ is odd,\n    //  or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n    bool descending = cast(int)(array[0] + array[$-1])\
    \ % 2 == 0;\n    return array.sort( (a, b) => descending ? a < b : a > b);\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptt5aaq9w.d(28): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptt5aaq9w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    enum ordering\
    \ {\n        greater,\n        lesser\n    }\n    auto getFirstNLastSum = (long[]\
    \ arr) => {\n        import std.array;\n        return arr[0] + arr.back;\n  \
    \  };\n    static bool isOdd(long n) {\n        return n % 2 == 1;\n    }\n  \
    \  static bool isEven(long n) {\n        return n % 2 == 0;\n    }\n    auto sortItems\
    \ = (long[] arr, ordering o) => {\n        return o == ordering.greater ? arr.sort(std.math.comparison!(\"\
    a > b\")) : arr.sort(std.math.comparison!(\"a < b\"));\n    };\n    static bool\
    \ isEmpty(long[] arr) {\n        return arr.length == 0;\n    }\n    static bool\
    \ isSingleElement(long[] arr) {\n        return arr.length == 1;\n    }\n    static\
    \ bool isMoreThanTwo(long[] arr) {\n        return arr.length > 2;\n    }\n  \
    \  switch(true) {\n        case isEmpty(array):\n            return array;\n \
    \       case isSingleElement(array):\n            return array;\n        case\
    \ isMoreThanTwo(array):\n            if(isOdd(getFirstNLastSum(array)))\n    \
    \            return sortItems(array, ordering.lesser);\n            else if(isEven(getFirstNLastSum(array)))\n\
    \                return sortItems(array, ordering.greater);\n    }\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkjl9iovg.d(40): Error: no property `sort` for type `long[]`

    /tmp/tmpkjl9iovg.d(40): Error: no property `sort` for type `long[]`

    /tmp/tmpkjl9iovg.d(52): Error: variable `array` cannot be read at compile time

    /tmp/tmpkjl9iovg.d(52):        called from here: `isEmpty(array)`

    /tmp/tmpkjl9iovg.d(54): Error: variable `array` cannot be read at compile time

    /tmp/tmpkjl9iovg.d(54):        called from here: `isSingleElement(array)`

    /tmp/tmpkjl9iovg.d(56): Error: variable `array` cannot be read at compile time

    /tmp/tmpkjl9iovg.d(56):        called from here: `isMoreThanTwo(array)`

    /tmp/tmpkjl9iovg.d(57): Error: function `tmpkjl9iovg.sort_array.isOdd(long n)`
    is not callable using argument types `(long delegate() pure nothrow @nogc @safe)`

    /tmp/tmpkjl9iovg.d(57):        cannot pass argument `(*getFirstNLastSum)(array)`
    of type `long delegate() pure nothrow @nogc @safe` to parameter `long n`

    /tmp/tmpkjl9iovg.d(59): Error: function `tmpkjl9iovg.sort_array.isEven(long n)`
    is not callable using argument types `(long '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    long sum = array[0] + array[array.length -\
    \ 1];\n    long[] ret = array.sort(x => x);\n    return (sum & 1) == 0 ? ret.reverse()\
    \ : ret;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgw_is9om.d(28): Error: no property `sort` for type `long[]`

    /tmp/tmpgw_is9om.d(29): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgw_is9om.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    size_t n = array.length;\n\
    \    if (n == 0) return array;\n    size_t m = n >> 1;\n    long* lhs = sort_array(array[0..m]);\n\
    \    long* rhs = sort_array(array[m..$]);\n    if ((lhs[0] + rhs[$-1]) & 1) \n\
    \    {\n        return lhs.sort().array() ~ rhs.sort().array();\n    }\n    else\
    \ \n    {\n        return lhs.sort!q{a > b}.array() ~ rhs.sort!q{a > b}.array();\n\
    \    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3md17inb.d(28): Error: cannot implicitly convert expression `sort_array(array[0..m])`
    of type `long[]` to `long*`

    /tmp/tmp3md17inb.d(29): Error: cannot implicitly convert expression `sort_array(array[m..__dollar])`
    of type `long[]` to `long*`

    /tmp/tmp3md17inb.d(30): Error: undefined identifier `__dollar`

    /tmp/tmp3md17inb.d(32): Error: no property `sort` for type `long*`

    /tmp/tmp3md17inb.d(32): Error: no property `sort` for type `long*`

    /tmp/tmp3md17inb.d(36): Error: no property `sort` for type `long*`

    /tmp/tmp3md17inb.d(36): Error: no property `sort` for type `long*`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3md17inb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return sort_array_internal(array,\
    \ 0, array.length, 0);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdcudikqn.d(25): Error: undefined identifier `sort_array_internal`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdcudikqn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long first_value\
    \ = array[0];\n    long last_value = array[array.length - 1];\n    if((first_value\
    \ + last_value) % 2 == 0)\n    {\n        std.sort(array);\n        return array;\n\
    \    }\n    else\n    {\n        std.sort(array);\n        array.reverse();\n\
    \        return array;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9avki2w3.d(29): Error: undefined identifier `sort` in package `std`

    /tmp/tmp9avki2w3.d(34): Error: undefined identifier `sort` in package `std`

    /tmp/tmp9avki2w3.d(35): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9avki2w3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int size = array.length;\n\
    \    long[] answer = array.dup;\n    bool isOdd = (array[0] + array[size - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        sort(answer);\n    }\n    else\n \
    \   {\n        sort(answer, (a, b) => b - a);\n    }\n    return answer;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprlipi663.d(25): Error: cannot implicitly convert expression `array.length`
    of type `ulong` to `int`

    /tmp/tmprlipi663.d(30): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmprlipi663.d(34): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprlipi663.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long first =\
    \ array[0];\n    long last = array[array.length - 1];\n    bool isOdd = (first\
    \ + last) % 2 == 1;\n    //std.algorithm.sort(array);\n    if (isOdd)\n    {\n\
    \        std.algorithm.sort(array);\n    }\n    else\n    {\n        array = array.sorted;\n\
    \        array = array.reversed;\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkkm2wkh_.d(31): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpkkm2wkh_.d(35): Error: no property `sorted` for type `long[]`

    /tmp/tmpkkm2wkh_.d(36): Error: no property `reversed` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkkm2wkh_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    return sortArray(array);\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6s9x3p9k.d(26): Error: undefined identifier `sortArray`, did you
    mean function `sort_array`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6s9x3p9k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int n = array.length;\n\
    \    if (n == 0) return array;\n    bool odd = (array[0] + array[n - 1]) % 2 ==\
    \ 1;\n    long[] copy = array.dup;\n    sort!((a, b) => a < b, copy);\n    return\
    \ odd ? copy : copy.reverse;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5iq5lwo9.d(25): Error: cannot implicitly convert expression `array.length`
    of type `ulong` to `int`

    /tmp/tmp5iq5lwo9.d(29): Error: template instance `sort!((a, b) => a < b, copy)`
    template `sort` is not defined, did you mean sqrt?

    /tmp/tmp5iq5lwo9.d(30): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5iq5lwo9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  return array.length\
    \ == 0 || array.length == 1 ? array : sum(array[0], array[$ - 1]) % 2 == 0\n \
    \   ? array.sort().reverse() : array.sort();\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0enacdjt.d(25): Error: undefined identifier `sum`

    /tmp/tmp0enacdjt.d(26): Error: no property `sort` for type `long[]`

    /tmp/tmp0enacdjt.d(26): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0enacdjt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    sort_by_oddness(array);\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwb60p8ep.d(27): Error: undefined identifier `sort_by_oddness`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwb60p8ep.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    auto start = array[0];\n    auto end = array[$\
    \ - 1];\n    enum direction = (start + end) % 2 == 0 ? sortDirection.descending\
    \ : sortDirection.ascending;\n    return array.sort!(direction == sortDirection.ascending\
    \ ? (x, y) => x < y : (x, y) => x > y);\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_quqgko4.d(29): Error: undefined identifier `sortDirection`

    /tmp/tmp_quqgko4.d(29): Error: undefined identifier `sortDirection`

    /tmp/tmp_quqgko4.d(30): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_quqgko4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    \n    auto arraySum = array[0] + array[$-1];\n\
    \    if (arraySum % 2 == 0)\n        return array.sort!\"a > b\";\n    \n    return\
    \ array.sort!\"a < b\";\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprcpror4c.d(30): Error: no property `sort` for type `long[]`

    /tmp/tmprcpror4c.d(32): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcpror4c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  int len = array.length;\n\
    \  if (len <= 1) return array;\n  if ((array[0] + array[len - 1]) % 2 == 0)\n\
    \  {\n    return sort(array).idup;\n  }\n  else\n  {\n    return sort(array).dup;\n\
    \  }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp503foeaw.d(25): Error: cannot implicitly convert expression `array.length`
    of type `ulong` to `int`

    /tmp/tmp503foeaw.d(29): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmp503foeaw.d(33): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp503foeaw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto ar = array.dup;\n\
    \    if (ar.length > 0) \n    {\n        auto len = ar.length;\n        if ((ar[0]\
    \ + ar[len - 1]) % 2 == 0) \n        {\n            ar.sort!((a, b) => a < b);\n\
    \        } \n        else \n        {\n            ar.sort!((a, b) => a > b);\n\
    \        }\n    }\n    return ar;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2xzfr1tu.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmp2xzfr1tu.d(35): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2xzfr1tu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] temp\
    \ = array.dup;\n    if(sum(temp[0], temp[$-1]) % 2 == 0) {\n        temp.sort!q{b\
    \ - a};\n    } else {\n        temp.sort!q{a - b};\n    }\n    return temp;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6zfk_7jf.d(26): Error: undefined identifier `sum`

    /tmp/tmp6zfk_7jf.d(27): Error: no property `sort` for type `long[]`

    /tmp/tmp6zfk_7jf.d(29): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zfk_7jf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if ( array.length\
    \ == 0 )\n        return array;\n    else if ( array.length == 1 )\n        return\
    \ array;\n    else if ( array.length == 2 )\n    {\n        if ( array[0] > array[1]\
    \ )\n        {\n            long temp = array[0];\n            array[0] = array[1];\n\
    \            array[1] = temp;\n        }\n        return array;\n    }\n    else\n\
    \    {\n        long sum = array[0] + array[array.length - 1];\n        if ( sum\
    \ % 2 == 0 )\n        {\n            sort(array);\n            return array.reverse();\n\
    \        }\n        else\n        {\n            sort(array);\n            return\
    \ array;\n        }\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwh7gynsf.d(44): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpwh7gynsf.d(45): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpwh7gynsf.d(49): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwh7gynsf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return sort_array(array,\
    \ 0, array.length);\n}\nlong[] sort_array(long[] array, long start, long len)\
    \ \n{\n    long[] result = new long[len];\n    if (len == 0) return result;\n\
    \    if (len == 1) {\n        result[0] = array[start];\n        return result;\n\
    \    }\n    if (len == 2) {\n        if (array[start] > array[start + 1]) {\n\
    \            result[0] = array[start + 1];\n            result[1] = array[start];\n\
    \        } else {\n            result[0] = array[start];\n            result[1]\
    \ = array[start + 1];\n        }\n        return result;\n    }\n    long half_len\
    \ = len / 2;\n    long[] array1 = sort_array(array, start, half_len);\n    long[]\
    \ array2 = sort_array(array, start + half_len, len - half_len);\n    long i =\
    \ 0;\n    long j = 0;\n    if ((array1[0] + array1[array1.length - 1]) % 2 ==\
    \ 0) {\n        while (i < array1.length && j < array2.length) {\n           \
    \ if (array1[i] > array2[j]) {\n                result[i + j] = array1[i];\n \
    \               i++;\n            } else {\n                result[i + j] = array2[j];\n\
    \                j++;\n            }\n        }\n        while (i < array1.length)\
    \ {\n            result[i + j] = array1[i];\n            i++;\n        }\n   \
    \     while (j < array2.length) {\n            result[i + j] = array2[j];\n  \
    \          j++;\n        }\n    } else {\n        while (i < array1.length &&\
    \ j < array2.length) {\n            if (array1[i] < array2[j]) {\n           \
    \     result[i + j] = array1[i];\n                i++;\n            } else {\n\
    \                result[i + j] = array2[j];\n                j++;\n          \
    \  }\n        }\n        while (\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyw3x8f52.d(79): Error: expression expected, not `unittest`

    /tmp/tmpyw3x8f52.d(80): Error: found `{` when expecting `)`

    /tmp/tmpyw3x8f52.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyw3x8f52.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ < 2)\n        return array;\n    \n    long a = array[0];\n    long b = array[array.length\
    \ - 1];\n    bool c = false;\n    if ((a + b) % 2 == 0)\n        c = true;\n \
    \   \n    auto t = tuple(a, b, c);\n    return array.sort!( (l, r) => (t[0] +\
    \ t[1]) % 2 == 0 ? l > r : l < r );\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc4c589rz.d(35): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc4c589rz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    if (array.length == 1)\n        return array;\n\
    \    long first = array[0];\n    long last = array[array.length - 1];\n    bool\
    \ ascending = (first + last) % 2 == 1;\n    if (ascending)\n        array.sort(int.compare);\n\
    \    else\n        array.sort(int.compare).reverse();\n    return array;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpds9wqboi.d(33): Error: no property `sort` for type `long[]`

    /tmp/tmpds9wqboi.d(35): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpds9wqboi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    size_t length\
    \ = array.length;\n    if (length == 0L)\n        return array;\n    const bool\
    \ odd_count = (array[0L] + array[length - 1L]) % 2L == 1L;\n    if (odd_count)\n\
    \        std.algorithm.sort(array, (n, m) => n < m);\n    else\n        std.algorithm.sort(array,\
    \ (n, m) => n > m);\n    return array;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6j53p2p2.d(30): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmp6j53p2p2.d(32): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6j53p2p2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    int isReverse = (array[0] + array[array.length - 1])\
    \ % 2;\n    return array.sort.opCall() * (isReverse * -1 + 1);\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcuwcthjo.d(27): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcuwcthjo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return array.sort();\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp10229ftv.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp10229ftv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto copy_array\
    \ = copy(array);\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ozbfe87.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ozbfe87.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    /*\n    int\
    \ len = array.length;\n    if (len == 0)\n        return array;\n    long temp\
    \ = 0;\n    bool swapped = false;\n    if (len > 1)\n    {\n        for (int i\
    \ = 0; i < len - 1; i++)\n        {\n            swapped = false;\n          \
    \  for (int j = 0; j < len - i - 1; j++)\n            {\n                if (array[j]\
    \ > array[j + 1])\n                {\n                    temp = array[j];\n \
    \                   array[j] = array[j + 1];\n                    array[j + 1]\
    \ = temp;\n                    swapped = true;\n                }\n          \
    \  }\n            if (!swapped)\n                break;\n        }\n    }\n  \
    \  return array;\n    */\n    auto len = array.length;\n    auto sum = array[0]\
    \ + array[len - 1];\n    auto cmp = (sum % 2 == 0) ? (int a, int b) { return a\
    \ > b; } : (int a, int b) { return a < b; };\n    array = array.sort(cmp);\n \
    \   return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpak_osrpa.d(55): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpak_osrpa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] s = array.dup;\n\
    \    if (s.length <= 1) return s;\n    long sum = s[0] + s[$ - 1];\n    bool asc\
    \ = (sum % 2L) == 1L;\n    sort(asc ? s : s.dup.reverse);\n    return s;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ed4a4yo.d(29): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ed4a4yo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long temp, sum;\n\
    \    auto index = array.length;\n    auto findex = 0;\n    auto maxindex = 0;\n\
    \    auto minindex = 0;\n    auto max = 0;\n    auto min = 0;\n    sum = array[0]\
    \ + array[index - 1];\n    //Sorting in descending order if sum is even\n    if\
    \ (sum % 2 == 0)\n    {\n        for (int i = 0; i < index; i++)\n        {\n\
    \            for (int j = i + 1; j < index; j++)\n            {\n            \
    \    if (array[i] < array[j])\n                {\n                    temp = array[i];\n\
    \                    array[i] = array[j];\n                    array[j] = temp;\n\
    \                }\n            }\n        }\n    }\n    //Sorting in ascending\
    \ order if sum is odd\n    else\n    {\n        for (int i = 0; i < index; i++)\n\
    \        {\n            for (int j = i + 1; j < index; j++)\n            {\n \
    \               if (array[i] > array[j])\n                {\n                \
    \    temp = array[i];\n                    array[i] = array[j];\n            \
    \        array[j] = temp;\n                }\n            }\n        }\n    }\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvwuehowo.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42891e]

    ??:? long[] tmpvwuehowo.sort_array(long[]) [0x427e29]

    ??:? void tmpvwuehowo.__unittest_L67_C1() [0x4280e9]

    ??:? void tmpvwuehowo.__modtest() [0x4285f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c8cb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b75e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430da0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43087d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]

    ??:? runModuleUnitTests [0x42c6a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(c'
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  long s = 0L;\n\
    \  if(array.length)\n  {\n    s = array[0] + array[array.length - 1];\n  }\n \
    \ if(s % 2)\n  {\n    return array.sort();\n  }\n  else\n  {\n    return array.sort((a,\
    \ b) => b - a);\n  }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq7frcq5f.d(32): Error: no property `sort` for type `long[]`

    /tmp/tmpq7frcq5f.d(36): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7frcq5f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long idx = array.length;\n\
    \    if (idx < 2)\n        return array;\n    long f = array[0];\n    long l =\
    \ array[idx - 1];\n    auto s = tuple(sum,f,l);\n    std.algorithm.sort(array,\
    \ (a, b) => a < b);\n    if (s % 2 == 0)\n        return array.reversed.array;\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0jpaw0p2.d(30): Error: undefined identifier `sum`

    /tmp/tmp0jpaw0p2.d(31): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmp0jpaw0p2.d(33): Error: no property `reversed` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0jpaw0p2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted\
    \ = array.dup;\n    qsort(sorted);\n    long sum = sorted[0] + sorted[$-1];\n\
    \    return sum % 2 == 0 ? sorted : sorted.reversed;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm61rpqux.d(26): Error: undefined identifier `qsort`

    /tmp/tmpm61rpqux.d(28): Error: no property `reversed` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm61rpqux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ > 0)\n    {\n        long first = array[0];\n        long last = array[array.length\
    \ - 1];\n        if ((first + last) % 2 != 0)\n        {\n            std.sort(array);\n\
    \        }\n        else\n        {\n            array = std.sort(array);\n  \
    \          array = array.reverse();\n        }\n    }\n    return array;\n}\n\
    // END\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpneafsbri.d(31): Error: undefined identifier `sort` in package `std`

    /tmp/tmpneafsbri.d(35): Error: undefined identifier `sort` in package `std`

    /tmp/tmpneafsbri.d(36): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpneafsbri.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    static struct\
    \ Tuple1(T) {T[] array; long sum;}\n    static int pred(Tuple1!(long) lhs, Tuple1!(long)\
    \ rhs) {\n        return lhs.sum < rhs.sum;\n    }\n    auto tmp = Tuple1!(long)(array[0L..$].dup);\n\
    \    tmp.sum = array[0L] + array[$-1L];\n    const a = [tmp];\n    while (true)\n\
    \    {\n        const index = a.lowerBound!pred(tmp).array.length;\n        a.insert(index,\
    \ tmp);\n        if (tmp.array.length == array.length)\n            break;\n \
    \       tmp.array.insert(0L, array[tmp.array.length]);\n        tmp.sum += array[tmp.array.length];\n\
    \    }\n    return a.map!(x => x.array).array.joiner.join;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbm2v5os8.d(34): Error: no property `lowerBound` for type `const(Tuple1!long[])`

    /tmp/tmpbm2v5os8.d(35): Error: no property `insert` for type `const(Tuple1!long[])`

    /tmp/tmpbm2v5os8.d(38): Error: no property `insert` for type `long[]`

    /tmp/tmpbm2v5os8.d(41): Error: no property `map` for type `const(Tuple1!long[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbm2v5os8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    enum flag { ASC, DESC }\n    alias ascflag = flag.ASC;\n\
    \    alias descflag = flag.DESC;\n    const(flag) order = (array[0] + array[$-1])\
    \ % 2 == 0 ? descflag : ascflag;\n    auto rng = array[];\n    // ok, we use insertion\
    \ sort here, as it is so easy to implement.\n    if (order == ascflag)\n    {\n\
    \        foreach (i, a; rng)\n        {\n            foreach (j, b; rng[i+1..$])\n\
    \            {\n                if (a > b)\n                {\n              \
    \      long t = a;\n                    a = b;\n                    b = t;\n \
    \               }\n            }\n        }\n    }\n    else\n    {\n        foreach\
    \ (i, a; rng)\n        {\n            foreach (j, b; rng[i+1..$])\n          \
    \  {\n                if (a < b)\n                {\n                    long\
    \ t = a;\n                    a = b;\n                    b = t;\n           \
    \     }\n            }\n        }\n    }\n    return rng;\n}\nunittest\n{\n  \
    \  alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfmplav1e.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpfmplav1e.__unittest_L64_C1() [0x428272]

    ??:? void tmpfmplav1e.__modtest() [0x4285f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d83b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f9a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a7f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a880]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a77d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f71]

    ??:? runModuleUnitTests [0x42d611]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    size_t len =\
    \ array.length;\n    if (len <= 1)\n        return array;\n    auto sum = array[0]\
    \ + array[len - 1];\n    auto predicate = sum % 2 ? (a, b) { return a > b; }\n\
    \                             : (a, b) { return a < b; };\n    quickSort(array[],\
    \ predicate);\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: "/tmp/tmp6mk92lua.d(29): Error: variable `tmp6mk92lua.sort_array.predicate`\
    \ type `void` is inferred from initializer `sum % cast(long)2 ? (a, b)\n{\nreturn\
    \ a > b;\n}\n : (a, b)\n{\nreturn a < b;\n}\n`, and variables cannot be of type\
    \ `void`\n/tmp/tmp6mk92lua.d(29): Error: expression `sum % cast(long)2 ? (a, b)\n\
    {\nreturn a > b;\n}\n : (a, b)\n{\nreturn a < b;\n}\n` is `void` and has no value\n\
    /tmp/tmp6mk92lua.d(31): Error: undefined identifier `quickSort`\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6mk92lua.d\", \"-I/tmp\"]\n"
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ <= 1)\n        return array;\n    \n    alias Result = Tuple!(long, bool);\n\
    \    bool isEven = (array[0] + array[$ - 1]) % 2 == 0;\n    auto comparator =\
    \ isEven ? (a, b) => b - a : (a, b) => a - b;\n    auto result = array.map!(n\
    \ => Result(n, n % 2 == 0)).sort!((a, b) => comparator(a[0], b[0]));\n    return\
    \ result.map!(r => r[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2txys_fq.d(30): Error: variable `tmp2txys_fq.sort_array.comparator`
    type `void` is inferred from initializer `isEven ? (a, b) => b - a : (a, b) =>
    a - b`, and variables cannot be of type `void`

    /tmp/tmp2txys_fq.d(30): Error: expression `isEven ? (a, b) => b - a : (a, b) =>
    a - b` is `void` and has no value

    /tmp/tmp2txys_fq.d(31): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2txys_fq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    return array.indexSum % 2 == 0 ? array.sort() : array.sort((a,\
    \ b) => b - a);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoggu3nl4.d(26): Error: no property `indexSum` for type `long[]`

    /tmp/tmpoggu3nl4.d(26): Error: no property `sort` for type `long[]`

    /tmp/tmpoggu3nl4.d(26): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoggu3nl4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    else if (array.length == 1)\n        return\
    \ array;\n    else\n    {\n        if ((array[0] + array[$ - 1]) % 2 == 0)\n \
    \           std.algorithm.sort(array, CompareType.byValueDescending);\n      \
    \  else\n            std.algorithm.sort(array, CompareType.byValue);\n    }\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpledofb19.d(32): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpledofb19.d(34): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpledofb19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    \n    if (sum(array[0], array[$ - 1]) % 2\
    \ != 0)\n        return array.sort();\n    else\n        return sort(array, (lhs,\
    \ rhs) => rhs - lhs);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp2k44khp.d(28): Error: undefined identifier `sum`

    /tmp/tmpp2k44khp.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpp2k44khp.d(31): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp2k44khp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    alias NumPair\
    \ = Tuple!(long, long);\n    long sum = array[0] + array[$ - 1];\n    NumPair[]\
    \ sortedArray = array.map!( (x) => NumPair(x, x) );\n    sum.odd\n        ? sortedArray.sort!(\
    \ (a, b) => a[0] < b[0] )\n        : sortedArray.sort!( (a, b) => a[0] > b[0]\
    \ );\n    return sortedArray.map!( (x) => x[0] ).array;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz_f3qkel.d(27): Error: no property `map` for type `long[]`

    /tmp/tmpz_f3qkel.d(28): Error: no property `odd` for type `long`

    /tmp/tmpz_f3qkel.d(29): Error: no property `sort` for type `Tuple!(long, long)[]`

    /tmp/tmpz_f3qkel.d(30): Error: no property `sort` for type `Tuple!(long, long)[]`

    /tmp/tmpz_f3qkel.d(31): Error: no property `map` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_f3qkel.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array\
    \ = new long[array.length];\n    for (int i = 0; i < array.length; i++)\n    {\n\
    \        sorted_array[i] = array[i];\n    }\n    if ((sorted_array[0] + sorted_array[sorted_array.length\
    \ - 1]) % 2 == 0)\n    {\n        sort(sorted_array.sorted, (a, b) => a > b);\n\
    \    }\n    else\n    {\n        sort(sorted_array.sorted, (a, b) => a < b);\n\
    \    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhby7c2e.d(32): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpxhby7c2e.d(36): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhby7c2e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Your code\
    \ here\n    // Before sorting, make a copy of the given array.\n    auto copy\
    \ = array.dup;\n    // If the sum of the first and last value of the given array\
    \ is even, sort the copy in descending order.\n    if ((array[0] + array[$-1])\
    \ % 2 == 0)\n    {\n        sort(copy, (long a, long b) => b < a);\n    }\n  \
    \  // If the sum of the first and last value of the given array is odd, sort the\
    \ copy in ascending order.\n    else\n    {\n        sort(copy);\n    }\n    return\
    \ copy;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl5y80a92.d(31): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpl5y80a92.d(36): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl5y80a92.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    long[][] index_value = new long[array.length][2];\n\
    \    foreach (int i, long v; array)\n    {\n        index_value[i][0] = i;\n \
    \       index_value[i][1] = v;\n    }\n    sort(index_value);\n    long[] array_copy\
    \ = array[];\n    foreach (i, int v; index_value)\n    {\n        array_copy[v[0]]\
    \ = v[1];\n    }\n    return array_copy;\n}\n/*\n    s = \"Python is Good programming\
    \ language\"\n    >>> str = \"Python is Good programming language\"\n    >>> fn(str)\n\
    \    'g'\n    >>> s = \"Hello World\"\n    >>> fn(s)\n    'w'\n    >>> s = \"\
    Python is Fun\"\n    >>> fn(s)\n    'f'\n    >>> s = \"dfdsfsd\"\n    >>> fn(s)\n\
    \    'd'\n    >>> s = \"zlekzbl\"\n    >>> fn(s)\n    'l'\n    >>> s = \"How are\
    \ you\"\n    >>> fn(s)\n    'w'\n    >>> s = \"How are you\"\n    >>> fn(s)\n\
    \    'w'\n*/\nchar fn(string s)\n{\n    string s_l = toLower(s);\n    string s_u\
    \ = toUpper(s);\n    char[][] char_arr = new char[][](\n        s_l,\n       \
    \ s_u\n    );\n    int[][] char_count = new int[2][256];\n    foreach (i, char[]\
    \ s; char_arr)\n    {\n        foreach (j, char c; s)\n        {\n           \
    \ char_count[i][c]++;\n        }\n    }\n    int[] counts = new int[2];\n    foreach\
    \ (i, char[] s; char_arr)\n    {\n        foreach (j, char c; s)\n        {\n\
    \            if (char_count[i][c] == 1)\n            {\n                counts[i\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt9aazuab.d(88): Error: found `unittest` when expecting `,`

    /tmp/tmpt9aazuab.d(100): Error: found `void` when expecting `,`

    /tmp/tmpt9aazuab.d(100): Error: found `{` when expecting `,`

    /tmp/tmpt9aazuab.d(100): Error: expression expected, not `}`

    /tmp/tmpt9aazuab.d(100): Error: found `End of File` when expecting `,`

    /tmp/tmpt9aazuab.d(100): Error: found `End of File` when expecting `]`

    /tmp/tmpt9aazuab.d(100): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpt9aazuab.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpt9aazuab.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpt9aazuab.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpt9aazuab.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt9aazuab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ < 2) return array;\n    auto compare = (array[0L] + array[$ - 1L]) % 2L == 0\
    \ ? std.math.comparator!\"a > b\" : std.math.comparator!\"a < b\";\n    return\
    \ array.sort!(compare);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcm9ezhnj.d(26): Error: undefined identifier `comparator` in module
    `std.math`

    /tmp/tmpcm9ezhnj.d(26): Error: undefined identifier `comparator` in module `std.math`

    /tmp/tmpcm9ezhnj.d(27): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcm9ezhnj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    if (array.length == 1) return array;\n    long sum\
    \ = array[0] + array[array.length - 1];\n    if (sum % 2 == 0) \n    {\n     \
    \   return array.sort!((a, b) => b - a);\n    }\n    else \n    {\n        return\
    \ array.sort!((a, b) => a - b);\n    }\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5xih9hf5.d(30): Error: no property `sort` for type `long[]`

    /tmp/tmp5xih9hf5.d(34): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xih9hf5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return new long[0];\n    \n    bool is_even = (array[0] + array[$\
    \ - 1]) % 2 == 0;\n    auto cmp = is_even ? std.functional.greater : std.functional.less;\n\
    \    return std.algorithm.sort(array, cmp);\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph0aixrul.d(29): Deprecation: module `std.functional` is not accessible
    here, perhaps add `static import std.functional;`

    /tmp/tmph0aixrul.d(29): Error: undefined identifier `greater` in module `std.functional`

    /tmp/tmph0aixrul.d(29): Deprecation: module `std.functional` is not accessible
    here, perhaps add `static import std.functional;`

    /tmp/tmph0aixrul.d(29): Error: undefined identifier `less` in module `std.functional`

    /tmp/tmph0aixrul.d(30): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph0aixrul.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    long first_index = array[0];\n    long last_index =\
    \ array[array.length - 1];\n    if ((first_index + last_index) % 2 != 0) {\n \
    \       array.sort;\n    } else {\n        array.sort.retro;\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi4s42sxc.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpi4s42sxc.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi4s42sxc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{ \n    int first_idx\
    \ = 0;\n    int last_idx = array.length - 1;\n    int first_value = array[first_idx];\n\
    \    int last_value = array[last_idx];\n    int sum = first_value + last_value;\n\
    \    bool odd = sum % 2 != 0;\n    auto tup = odd ? tuple(first_idx, last_idx)\
    \ : tuple(last_idx, first_idx);\n    auto tup_result = odd ? tuple(first_value,\
    \ last_value) : tuple(last_value, first_value);\n    auto results = to!(long[])([]);\n\
    \    int fst_idx = tup[0];\n    int sec_idx = tup[1];\n    long fst_val = tup_result[0];\n\
    \    long sec_val = tup_result[1];\n    results ~= fst_val;\n    results ~= sec_val;\n\
    \    for (int i = 0; i < array.length; i++)\n    {\n        int value = array[i];\n\
    \        if (value == fst_val || value == sec_val)\n        {\n            continue;\n\
    \        }\n        results ~= value;\n    }\n    sort(results);\n    return results;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeqt8wedq.d(26): Error: cannot implicitly convert expression `array.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpeqt8wedq.d(27): Error: cannot implicitly convert expression `array[cast(ulong)first_idx]`
    of type `long` to `int`

    /tmp/tmpeqt8wedq.d(28): Error: cannot implicitly convert expression `array[cast(ulong)last_idx]`
    of type `long` to `int`

    /tmp/tmpeqt8wedq.d(33): Error: template instance `to!(long[])` template `to` is
    not defined, did you mean No?

    /tmp/tmpeqt8wedq.d(42): Error: cannot implicitly convert expression `array[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmpeqt8wedq.d(49): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeqt8wedq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    bool odd = (array.front\
    \ + array.back) % 2 == 1;\n    auto tuple = zip(array, iota(array.length));\n\
    \    auto tup = tuple.filter!((a, i) => a % 2 == odd);\n    auto tup_sorted =\
    \ tup.sort!((a, b) => a[0] > b[0]);\n    auto tuple_sorted = tuple.sort!((a, b)\
    \ => a[0] > b[0]);\n    long[] result = tuple_sorted\n        .map!((a, i) =>\
    \ a[0])\n        .map!((a, i) => \n        {\n            if (i < tup_sorted.length)\n\
    \            {\n                return tup_sorted[i][0];\n            }\n    \
    \        else\n            {\n                return a;\n            }\n     \
    \   }\n        );\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3j7f7dl.d(25): Error: no property `front` for type `long[]`

    /tmp/tmpk3j7f7dl.d(25): Error: no property `back` for type `long[]`

    /tmp/tmpk3j7f7dl.d(26): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3j7f7dl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] the_array\
    \ = new long[array.length];\n    int the_end = array.length - 1;\n    int the_begin\
    \ = 0;\n    while (the_begin < the_end)\n    {\n        the_array[the_begin] =\
    \ array[the_begin];\n        the_array[the_end] = array[the_end];\n        the_begin++;\n\
    \        the_end--;\n    }\n    if (the_begin == the_end)\n    {\n        the_array[the_begin]\
    \ = array[the_begin];\n    }\n    if ((the_array[0] + the_array[the_array.length\
    \ - 1]) % 2 == 0)\n    {\n        return the_array.sort().array();\n    }\n  \
    \  else\n    {\n        return the_array.sort(std.typecons.greater).array();\n\
    \    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6rm9fber.d(26): Error: cannot implicitly convert expression `array.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp6rm9fber.d(41): Error: no property `sort` for type `long[]`

    /tmp/tmp6rm9fber.d(45): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6rm9fber.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = array[0]\
    \ + array[array.length - 1];\n    return sum % 2 == 0 ? \n      sort!((a, b) =>\
    \ a > b)(array) :\n      sort!((a, b) => a < b)(array);\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp8kx7o3n.d(27): Error: template instance `sort!((a, b) => a > b)`
    template `sort` is not defined, did you mean sqrt?

    /tmp/tmpp8kx7o3n.d(28): Error: template instance `sort!((a, b) => a < b)` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp8kx7o3n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    enum OP = typeof(sort_array).OP;\n\
    \    return sort_arrayImpl!(OP.asc)(array);\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpete0ls8s.d(25): Error: no property `OP` for type `long[](long[]
    array)`

    /tmp/tmpete0ls8s.d(26): Error: template instance `sort_arrayImpl!(OP.asc)` template
    `sort_arrayImpl` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpete0ls8s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    int start = 0;\n    int end = array.length - 1;\n \
    \   if ((array[start] + array[end]) % 2 == 0) // check if the sum of ( first index\
    \ value, last index value) is even.\n    {\n        sort!((x, y) => -(x > y))(array);\
    \ // sort in descending order \n    }\n    else\n    {\n        sort!((x, y) =>\
    \ x > y)(array); // sort in ascending order \n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd9o4hoxf.d(27): Error: cannot implicitly convert expression `array.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpd9o4hoxf.d(30): Error: template instance `sort!((x, y) => -(x > y))` template
    `sort` is not defined, did you mean sqrt?

    /tmp/tmpd9o4hoxf.d(34): Error: template instance `sort!((x, y) => x > y)` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd9o4hoxf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  long[] r = array;\n\
    \  if(array.length == 0)\n    return array;\n  else if(array.length == 1)\n  \
    \  return array;\n  else\n  {\n    bool asc = ((array[0] + array[array.length\
    \ - 1]) % 2) == 0;\n    if(asc)\n      r.sort;\n    else\n      r.sort(std.typecons.scalar(long,\
    \ -a));\n  }\n  return r;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4eqiiei6.d(36): Error: found `,` when expecting `.` following long

    /tmp/tmp4eqiiei6.d(36): Error: found `-` when expecting identifier following `long`.

    /tmp/tmp4eqiiei6.d(36): Error: found `a` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4eqiiei6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n\tif (array.length\
    \ == 0)\n\t\treturn new long[0];\n\tlong first = array[0];\n\tlong last = array[array.length\
    \ - 1];\n\tlong[] res = array.dup;\n\tif ((first + last) % 2 == 0)\n\t\treturn\
    \ res.sort(std.typecons.greater);\n\telse\n\t\treturn res.sort(std.typecons.less);\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wo7uyx0.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmp8wo7uyx0.d(33): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wo7uyx0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return array.dup.sort;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnb278k2x.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnb278k2x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1)\n        return array;\n    else\n    {\n       \
    \ long first_value = array[0];\n        long last_value = array[array.length -\
    \ 1];\n        long sum = first_value + last_value;\n        if (sum % 2 == 0)\n\
    \            array.sort(std.typecons.unaryFun!((ref long x, ref long y) => x >\
    \ y));\n        else\n            array.sort(std.typecons.unaryFun!((ref long\
    \ x, ref long y) => x < y));\n        return array;\n    }\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwak2nwm4.d(33): Error: no property `sort` for type `long[]`

    /tmp/tmpwak2nwm4.d(35): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwak2nwm4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    if (array.length == 1)\n        return array;\n\
    \    return iota(0L, array.length)\n        .map!(i => tuple(i, array[i]))\n \
    \       .sort!((a, b) => a[1] < b[1])\n        .map!(a => a[1])\n        .array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8229ze27.d(29): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8229ze27.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Get the sum\
    \ of the first and last elements\n    auto sum = array[0] + array[$-1];\n    //\
    \ Get a copy of the array\n    auto c = array.dup;\n    // Sort the array in descending\
    \ order if sum is even\n    if (sum % 2 == 0)\n    {\n        c.sort!q{ b > a\
    \ }();\n    }\n    // Sort the array in ascending order if sum is odd\n    else\n\
    \    {\n        c.sort!q{ a < b }();\n    }\n    // Return the sorted array\n\
    \    return c;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3n909g2p.d(32): Error: no property `sort` for type `long[]`

    /tmp/tmp3n909g2p.d(37): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3n909g2p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto result\
    \ = array;\n    if (result.length > 0)\n    {\n        // code goes here\n   \
    \     if (result[0] + result[$-1] % 2 == 0)\n        {\n            sort!((a,\
    \ b) => a > b)(result);\n        }\n        else\n        {\n            sort!((a,\
    \ b) => a < b)(result);\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpencnb900.d(31): Error: template instance `sort!((a, b) => a > b)`
    template `sort` is not defined, did you mean sqrt?

    /tmp/tmpencnb900.d(35): Error: template instance `sort!((a, b) => a < b)` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpencnb900.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    immutable long\
    \ sum = array[0] + array[$-1];\n    immutable long n = array.length;\n    immutable\
    \ bool is_even = sum % 2 == 0;\n    immutable long end = n - 1;\n    bool done\
    \ = false;\n    for (; !done;) \n    {\n        done = true;\n        for (immutable\
    \ long i = 0; i < end; ++i) \n        {\n            if (is_even ? array[i] <\
    \ array[i + 1] : array[i] > array[i + 1]) \n            {\n                long\
    \ tmp = array[i];\n                array[i] = array[i + 1];\n                array[i\
    \ + 1] = tmp;\n                done = false;\n            }\n        }\n     \
    \   --end;\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeqm_ocrm.d(33): Error: cannot modify `immutable` expression `0L`

    /tmp/tmpeqm_ocrm.d(43): Error: cannot modify `immutable` expression `end`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeqm_ocrm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \nin {\n    assert( array.length\
    \ == 0 || array.length > 0 && array.length < 10000);\n    assert( forall(int i;\
    \ 0 <= i && i < array.length; 0 <= array[i] && array[i] <= 9));\n}\nout {\n  \
    \  assert( result.length == array.length);\n    assert( forall(int i; 0 <= i &&\
    \ i < result.length - 1; result[i] <= result[i + 1]));\n    if( array.length ==\
    \ 0) {\n        assert( result.length == 0);\n    } else {\n        if((array[0]\
    \ + array[array.length - 1]) % 2 == 0) {\n            assert( forall(int i; 0\
    \ <= i && i < result.length - 1; result[i] >= result[i + 1]));\n        } else\
    \ {\n            assert( forall(int i; 0 <= i && i < result.length - 1; result[i]\
    \ <= result[i + 1]));\n        }\n    }\n}\n{\n    typeof(array) result;\n   \
    \ if( array.length == 0) {\n        result = array;\n    } else {\n        long[]\
    \ result1 = sort(array);\n        if((array[0] + array[array.length - 1]) % 2\
    \ == 0) {\n            result = reverse(result1);\n        } else {\n        \
    \    result = result1;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp39529zvx.d(26): Error: found `i` when expecting `.` following int

    /tmp/tmp39529zvx.d(26): Error: found `;` when expecting identifier following `int`.

    /tmp/tmp39529zvx.d(26): Error: found `0` when expecting `,`

    /tmp/tmp39529zvx.d(26): Error: expression expected, not `<=`

    /tmp/tmp39529zvx.d(26): Error: found `i` when expecting `,`

    /tmp/tmp39529zvx.d(26): Error: expression expected, not `&&`

    /tmp/tmp39529zvx.d(26): Error: found `i` when expecting `,`

    /tmp/tmp39529zvx.d(26): Error: expression expected, not `<`

    /tmp/tmp39529zvx.d(26): Error: found `array` when expecting `,`

    /tmp/tmp39529zvx.d(26): Error: found `;` when expecting `,`

    /tmp/tmp39529zvx.d(30): Error: found `i` when expecting `.` following int

    /tmp/tmp39529zvx.d(30): Error: found `;` when expecting identifier following `int`.

    /tmp/tmp39529zvx.d(30): Error: found `0` when expecting `,`

    /tmp/tmp39529zvx.d(30): Error: expression expected, not `<=`

    /tmp/tmp39529zvx.d(30): Error: found `i` when expecting `,`

    /tmp/tmp39529zvx.d(30): Error: expression'
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    auto comp = array[0] + array[$-1] == 1 ? std.functional.greater\
    \ : std.functional.less;\n    return array.sort!(comp);\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw_xuzsi2.d(26): Deprecation: module `std.functional` is not accessible
    here, perhaps add `static import std.functional;`

    /tmp/tmpw_xuzsi2.d(26): Error: undefined identifier `greater` in module `std.functional`

    /tmp/tmpw_xuzsi2.d(26): Deprecation: module `std.functional` is not accessible
    here, perhaps add `static import std.functional;`

    /tmp/tmpw_xuzsi2.d(26): Error: undefined identifier `less` in module `std.functional`

    /tmp/tmpw_xuzsi2.d(27): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_xuzsi2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[long[]]\
    \ new_array = [array[$ - 1L .. 0L]];\n    ulong len = array.length;\n    int i\
    \ = 0;\n    int j = 0;\n    if(len == 0)\n    {\n        return [0L];\n    }\n\
    \    if(len == 1)\n    {\n        return [array[0L]];\n    }\n    if(array[0L]\
    \ + array[$ - 1L] % 2 == 0)\n    {\n        foreach(index, value; array)\n   \
    \     {\n            new_array[j][i] = value;\n            i++;\n        }\n \
    \       sort(new_array[j]);\n        return new_array[j];\n    }\n    else\n \
    \   {\n        foreach(index, value; array)\n        {\n            new_array[j][i]\
    \ = value;\n            i++;\n        }\n        sort(new_array[j], std.algorithm.sorting.greater);\n\
    \        return new_array[j];\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8439n09k.d(25): Error: not an associative array initializer

    /tmp/tmp8439n09k.d(41): Error: cannot implicitly convert expression `j` of type
    `int` to `const(long)[]`

    /tmp/tmp8439n09k.d(44): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmp8439n09k.d(45): Error: cannot implicitly convert expression `j` of type
    `int` to `const(long)[]`

    /tmp/tmp8439n09k.d(51): Error: cannot implicitly convert expression `j` of type
    `int` to `const(long)[]`

    /tmp/tmp8439n09k.d(54): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmp8439n09k.d(55): Error: cannot implicitly convert expression `j` of type
    `int` to `const(long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8439n09k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) \n        return array;\n    \n    bool is_ascending = (array[0] + array[array.length\
    \ - 1]) % 2 == 0;\n    long[] result = array.dup;\n    result.sort(is_ascending\
    \ ? std.math.less : std.math.greater);\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4xtb4hdn.d(30): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xtb4hdn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    if (array.length == 1)\n        return array;\n\
    \    if (array[0] + array[array.length - 1] % 2 == 0)\n        return sort(array,\
    \ false);\n    else\n        return sort(array, true);\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9c9grhus.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp9c9grhus.d(32): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9c9grhus.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return new long[0];\n    if (array.length == 1) return array;\n    auto\
    \ array_copy = new long[](array.length);\n    auto idx = array.length - 1;\n \
    \   size_t asc_idx = 0;\n    size_t desc_idx = idx;\n    if ((array[0] + array[idx])\
    \ % 2 == 0)\n    {\n        while (idx > 0)\n        {\n            if (array[asc_idx]\
    \ % 2 == 0)\n            {\n                array_copy[asc_idx] = array[asc_idx];\n\
    \                ++asc_idx;\n            }\n            else\n            {\n\
    \                array_copy[desc_idx] = array[asc_idx];\n                --desc_idx;\n\
    \            }\n            --idx;\n        }\n    }\n    else\n    {\n      \
    \  while (idx > 0)\n        {\n            if (array[asc_idx] % 2 == 0)\n    \
    \        {\n                array_copy[desc_idx] = array[asc_idx];\n         \
    \       --desc_idx;\n            }\n            else\n            {\n        \
    \        array_copy[asc_idx] = array[asc_idx];\n                ++asc_idx;\n \
    \           }\n            --idx;\n        }\n    }\n    sort(array_copy);\n \
    \   return array_copy;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wqur111.d(65): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wqur111.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  long[] result\
    \ = new long[array.length];\n  if(array.length == 0 || array.length == 1) return\
    \ array;\n  if((array[0] + array[array.length - 1]) % 2 == 0) \n  {\n      int\
    \ j = array.length - 1;\n      for(int i = 0; i < array.length; i++)\n      {\n\
    \          result[i] = array[j];\n          j--;\n      }\n  }\n  else \n  {\n\
    \      int i = 0;\n      int j = array.length - 1;\n      while(i <= j)\n    \
    \  {\n          if(array[i] % 2 != 0) i++;\n          if(array[j] % 2 != 0) j--;\n\
    \          if(array[i] % 2 == 0 && array[j] % 2 == 0) \n          {\n        \
    \      result[i] = array[i];\n              result[j] = array[j];\n          \
    \    i++;\n              j--;\n          }\n      }\n  }\n  return result;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmo06894h.d(29): Error: cannot implicitly convert expression `array.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpmo06894h.d(39): Error: cannot implicitly convert expression `array.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmo06894h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    auto v = array.dup;\n    bool isOdd = ((v[0] + v[$-1])\
    \ % 2 == 1);\n    stableSort(v, (a, b) => isOdd ? a < b : a > b);\n    return\
    \ v;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5grc2_cq.d(28): Error: undefined identifier `stableSort`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5grc2_cq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    alias tuple\
    \ = Tuple!(long, long);\n    alias arr = tuple[];\n    if (array.length == 0)\n\
    \        return array;\n    arr temp = new arr;\n    foreach (int i, long e; array)\n\
    \        temp ~= tuple(i, e);\n    temp.sort!(\n            (tuple a, tuple b)\
    \ => \n            {\n                auto sum = a[0] + b[0];\n              \
    \  if (sum % 2 == 0)\n                    return b[1] - a[1];\n              \
    \  else\n                    return a[1] - b[1];\n            }\n        );\n\
    \    foreach (tuple t; temp)\n        array[t[0]] = t[1];\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzxaa1dul.d(29): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    /tmp/tmpzxaa1dul.d(32): Error: no property `sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzxaa1dul.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] r = null;\n\
    \    r = array.dup;\n    if (r.length < 1)\n        return r;\n    if (r.length\
    \ == 1)\n        return r;\n    long first = r[0];\n    long last = r[r.length\
    \ - 1];\n    if ((first + last) % 2 == 0)\n    {\n        r.sort(long());\n  \
    \      r.reverse;\n    }\n    else\n    {\n        r.sort(long());\n    }\n  \
    \  return r;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuzk355hf.d(35): Error: no property `sort` for type `long[]`

    /tmp/tmpuzk355hf.d(36): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpuzk355hf.d(40): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuzk355hf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{ \n    if (array.length\
    \ == 0 || array.length == 1)\n        return array;\n    auto res = array.dup;\n\
    \    if ((array[0] + array[$-1]) % 2 == 0)\n        res.sort!(a, b => a > b);\n\
    \    else\n        res.sort!(a, b => a < b);\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_fs9qqc.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpo_fs9qqc.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_fs9qqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long temp;\n\
    \    int index;\n    int odd = (array.length % 2 == 0) ? 1 : 0;\n    for (int\
    \ i = 0; i < array.length/2; i++)\n    {\n        index = array.length - 1 - i;\n\
    \        if ((array[i] % 2 == 0) && (array[index] % 2 == 0))\n        {\n    \
    \        temp = (odd == 1) ? array[i] : array[index];\n            array[i] =\
    \ (odd == 1) ? array[index] : array[i];\n            array[index] = temp;\n  \
    \      }\n        else if ((array[i] % 2 == 0) && (array[index] % 2 != 0))\n \
    \       {\n            temp = array[i];\n            array[i] = array[index -\
    \ 1];\n            array[index - 1] = temp;\n        }\n        else if ((array[i]\
    \ % 2 != 0) && (array[index] % 2 == 0))\n        {\n            temp = array[i\
    \ + 1];\n            array[i + 1] = array[index];\n            array[index] =\
    \ temp;\n        }\n    }\n    return array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9xfb0lrf.d(30): Error: cannot implicitly convert expression `array.length
    - 1LU - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xfb0lrf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{ \n  if(array.length==0)\n\
    \    return [];\n  else if(array.length==1)\n    return array;\n  \n  auto sum\
    \ = array[0] + array[$-1];\n  if(sum%2==0)\n    return sort(array, (a, b) => -cmp(a,\
    \ b));\n  else\n    return sort(array, (a, b) => cmp(a, b));\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpukucm3rp.d(32): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpukucm3rp.d(34): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpukucm3rp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    \n    long[] A = array.dup;\n    auto sort\
    \ = (A.length % 2 == 0) ? A.sort() : A.sort.reverse();\n    return sort.array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuilisfdm.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpuilisfdm.d(29): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuilisfdm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    /*your code\
    \ here*/\n    if (array.length <= 1)\n        return array;\n    long[] copy =\
    \ array.dup;\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n       \
    \ std.algorithm.sort(copy, std.numeric.ordering.greater);\n    else\n        std.algorithm.sort(copy);\n\
    \    return copy;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplzghtlp0.d(30): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmplzghtlp0.d(32): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplzghtlp0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    auto result = array.dup;\n    //auto result = array.opSlice();\n\
    \    //result.sort();\n    auto original_first = array[0];\n    auto original_last\
    \ = array[$-1];\n    // alias\n    long first = result[0];\n    long last = result[$-1];\n\
    \    long first_index = 0;\n    long last_index = result.length - 1;\n    //\n\
    \    if ((first + last) % 2 == 0) \n    {\n        result.sort;\n        //\n\
    \        auto temp = result[first_index];\n        result[first_index] = result[last_index];\n\
    \        result[last_index] = temp;\n        //\n        temp = result[0];\n \
    \       result[0] = result[$-1];\n        result[$-1] = temp;\n    }\n    else\n\
    \    {\n        result.sort;\n    }\n    //\n    auto temp = result[0];\n    result[0]\
    \ = result[$-1];\n    result[$-1] = temp;\n    //\n    temp = result[first_index];\n\
    \    result[first_index] = result[last_index];\n    result[last_index] = temp;\n\
    \    //\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg8fjmitw.d(39): Error: no property `sort` for type `long[]`

    /tmp/tmpg8fjmitw.d(51): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8fjmitw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto pred =\
    \ (a, b) => (a[0] + a[$ - 1]) % 2 < (b[0] + b[$ - 1]) % 2;\n    return array.sort!(pred).map!(e\
    \ => e.idup).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy_klarqx.d(25): Error: variable `tmpy_klarqx.sort_array.pred` type
    `void` is inferred from initializer `(a, b) => (a[0] + a[__dollar - 1]) % 2 <
    (b[0] + b[__dollar - 1]) % 2`, and variables cannot be of type `void`

    /tmp/tmpy_klarqx.d(25): Error: template lambda has no value

    /tmp/tmpy_klarqx.d(26): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy_klarqx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    if (array.length == 1)\n        return array;\n\
    \    const reverse_array = array.reverse();\n    auto first_value = reverse_array[0];\n\
    \    auto last_value = reverse_array[reverse_array.length - 1];\n    if ((first_value\
    \ + last_value) % 2 == 0)\n        return reverse_array;\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw7bclw3x.d(29): Error: template `std.typecons.reverse` cannot deduce
    function from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7bclw3x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \nin\n{\n    assert(array.length\
    \ > 0);\n    assert(array.length <= 100);\n    foreach(long number; array)\n \
    \   {\n        assert(number >= 0L);\n        assert(number <= 100);\n    }\n\
    }\nout\n{\n    assert(array.length > 0);\n    assert(array.length <= 100);\n \
    \   foreach(long number; array)\n    {\n        assert(number >= 0L);\n      \
    \  assert(number <= 100);\n    }\n}\nbody\n{\n    if(array.length == 1)\n    {\n\
    \        return array;\n    }\n    else\n    {\n        if((array[0] + array[$-1])\
    \ % 2L == 0L)\n        {\n            auto result = sort!(\"a > b\")(array);\n\
    \            return result;\n        }\n        else\n        {\n            auto\
    \ result = sort!(\"a < b\")(array);\n            return result;\n        }\n \
    \   }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy12_daf2.d(54): Error: template instance `sort!"a > b"` template
    `sort` is not defined, did you mean sqrt?

    /tmp/tmpy12_daf2.d(59): Error: template instance `sort!"a < b"` template `sort`
    is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy12_daf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{ \n    bool sort_order\
    \ = (array.length > 0) && ((array[0] + array[$-1]) % 2 == 0);\n    auto [sorted_array,\
    \ _] = sort(array, sort_order);\n    return sorted_array;\n}\nunittest\n{\n  \
    \  alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk0ppn881.d(26): Error: basic type expected, not `[`

    /tmp/tmpk0ppn881.d(26): Error: found `,` when expecting `]`

    /tmp/tmpk0ppn881.d(26): Error: semicolon expected, not `]`

    /tmp/tmpk0ppn881.d(26): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk0ppn881.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Your code\
    \ goes here!\n    return array.dup.sort(array.front + array.back & 1 ? (long a,\
    \ long b) => b - a : (long a, long b) => a - b);\n}\n/*\n    Augmented Assignment\
    \ Operators\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd1oekgzy.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd1oekgzy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  auto size = array.length;\n\
    \  if (size == 0)\n    return [];\n  \n  return (array[0] + array[$-1]) % 2 !=\
    \ 0 ? array.sort.idup : array.sort.idup.retro;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp91tyfl8c.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmp91tyfl8c.d(29): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp91tyfl8c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  bool odd = (array.length\
    \ > 0) && (array[0] + array[$-1]) % 2 == 1;\n  return array.sort!((a, b) => odd\
    \ ? b < a : a < b);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_9o6a4dx.d(26): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_9o6a4dx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1) \n        return array;\n    auto odd = array[0]\
    \ + array[$-1] % 2;\n    return array.sorted.array(odd ? std.cmp.greater : std.cmp.less);\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdmfnbed6.d(28): Error: no property `sorted` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdmfnbed6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long temp;\n\
    \    bool odd = (array[0] + array[array.length - 1]) % 2;\n    for (int i = 0;\
    \ i < array.length; i++)\n    {\n        for (int j = 0; j < array.length - 1;\
    \ j++)\n        {\n            if ((array[j] > array[j + 1]) == odd)\n       \
    \     {\n                temp = array[j];\n                array[j] = array[j\
    \ + 1];\n                array[j + 1] = temp;\n            }\n        }\n    }\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnrl6hydu.d(26): Error: cannot implicitly convert expression `(array[0]
    + array[array.length - 1LU]) % 2L` of type `long` to `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrl6hydu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{ \n    if (array.length\
    \ == 0) return array;\n    long[] result = new long[array.length];\n    //tuple\
    \ represents the start and end index of the array which needs to be sorted.\n\
    \    tuple!(int, int) idx = tuple(0, array.length - 1);\n    while (idx[0] < idx[1])\n\
    \    {\n        if ((array[idx[0]] + array[idx[1]]) % 2 == 0) //sort in descending\
    \ order\n        {\n            result[idx[1]] = array[idx[0]];\n            result[idx[0]]\
    \ = array[idx[1]];\n        }\n        else //sort in ascending order\n      \
    \  {\n            result[idx[0]] = array[idx[0]];\n            result[idx[1]]\
    \ = array[idx[1]];\n        }\n        idx[0]++;\n        idx[1]--;\n    }\n \
    \   return result;\n}\n \nunittest\n{\n    alias candidate = sort_array;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf13dpq88.d(28): Error: `tuple!(int, int)` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf13dpq88.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if ( array.length\
    \ & 1L == 1L ) {\n        std.array.sort(array);\n    } else {\n        std.array.sort(array,\
    \ std.less, (a, b) => b - a);\n    }\n    return array;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplvi_jseo.d(25): Error: `1L == 1L` must be parenthesized when next
    to operator `&`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplvi_jseo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    sort(array);\n    if ((first + last) % 2 == 0)\n        reverse(array);\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvd660k6_.d(28): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpvd660k6_.d(30): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvd660k6_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ < 2) return array;\n    int first = 0;\n    int last = array.length - 1;\n \
    \   long firstValue = array[first];\n    long lastValue = array[last];\n    if\
    \ ((firstValue + lastValue) % 2 == 0)\n    {\n        while (first < last)\n \
    \       {\n            while (first < last && array[first] < array[last])\n  \
    \          {\n                long temp = array[first];\n                array[first]\
    \ = array[last];\n                array[last] = temp;\n                first++;\n\
    \                last--;\n            }\n            while (first < last && array[first]\
    \ >= array[last])\n            {\n                last--;\n            }\n   \
    \     }\n    }\n    else\n    {\n        while (first < last)\n        {\n   \
    \         while (first < last && array[first] > array[last])\n            {\n\
    \                long temp = array[first];\n                array[first] = array[last];\n\
    \                array[last] = temp;\n                first++;\n             \
    \   last--;\n            }\n            while (first < last && array[first] <=\
    \ array[last])\n            {\n                last--;\n            }\n      \
    \  }\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdtwfodh2.d(27): Error: cannot implicitly convert expression `array.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdtwfodh2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return array.sum\
    \ == 0 || array.sum % 2 == 0 ? sort(array,std.sort.descending) : sort(array,std.sort.ascending);\n\
    }\n/*\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppfxcbd2i.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppfxcbd2i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result\
    \ = array.dup;\n    //return (result.length % 2 == 0) ? result.sort(std.typecons.greater)\
    \ : result.sort(std.typecons.less);\n    return (result.sum % 2 == 0) ? result.sort(std.typecons.greater)\
    \ : result.sort(std.typecons.less);\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhim89q5.d(27): Error: no property `sum` for type `long[]`

    /tmp/tmpxhim89q5.d(27): Error: no property `sort` for type `long[]`

    /tmp/tmpxhim89q5.d(27): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhim89q5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1)\n        return array;\n    \n    long[] ret = array.dup;\n\
    \    bool od = array[0] % 2;\n    auto f = (long a, long b) {\n        bool aod\
    \ = a % 2;\n        bool bod = b % 2;\n        if (aod != bod) {\n           \
    \ if (aod == od)\n                return -1;\n            return 1;\n        }\n\
    \        if (aod == od)\n            return a - b;\n        return b - a;\n  \
    \  };\n    ret.sort(f);\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaudo9pxj.d(29): Error: cannot implicitly convert expression `array[0]
    % 2L` of type `long` to `bool`

    /tmp/tmpaudo9pxj.d(31): Error: cannot implicitly convert expression `a % 2L` of
    type `long` to `bool`

    /tmp/tmpaudo9pxj.d(32): Error: cannot implicitly convert expression `b % 2L` of
    type `long` to `bool`

    /tmp/tmpaudo9pxj.d(42): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaudo9pxj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) \n        return array;\n    if (array.length == 1) \n        return array;\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0) \n        return rsort(array);\n\
    \    else \n        return sort(array);\n}\nlong[] sort(long[] array) \n{\n  \
    \  return array.sort();\n}\nlong[] rsort(long[] array) \n{\n    return array.rsort();\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164448
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto length\
    \ = array.length;\n    if (length == 0) return array;\n    bool sort_asc = (array[0]\
    \ + array[length - 1]) % 2 == 1;\n    sort(array, sort_asc ? (a, b) => a < b :\
    \ (a, b) => a > b);\n    return array;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph65_0yvk.d(28): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph65_0yvk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1)\n        return array;\n    auto result = array.dup;\n\
    \    if ( (result[0] + result[$-1]) % 2 == 0)\n        result.sort!((a, b) =>\
    \ b.cmp(a));\n    else\n        result.sort!((a, b) => a.cmp(b));\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgi2dobfl.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpgi2dobfl.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgi2dobfl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto int64 =\
    \ typeof(array[0]);\n    array = array.dup;\n    auto l = array.length;\n    l\
    \ /= 2;\n    auto sortFunc = isOdd(array[0] + array[$-1]) ? (x, y) => x < y :\
    \ (x, y) => x > y;\n    array[0 .. l].sort!sortFunc;\n    array[l .. $].sort!sortFunc;\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn94562aj.d(25): Error: type `long` has no value

    /tmp/tmpn94562aj.d(29): Error: undefined identifier `isOdd`

    /tmp/tmpn94562aj.d(30): Error: no property `sort` for type `long[]`

    /tmp/tmpn94562aj.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn94562aj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ < 2)\n        return array;\n    \n    long[] tmp = array.dup;\n    tmp.sort;\n\
    \    \n    return (array[0] + array[$ - 1]) % 2 ? tmp : tmp.reverse;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplb62_jj1.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmplb62_jj1.d(31): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplb62_jj1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    alias P = typeof(array[0]);\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp972p1u0_.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp972p1u0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] cod_array\
    \ = array.dup;\n    if(array.length > 0)\n    {\n        switch(array[0L] + array[$\
    \ - 1L])\n        {\n            case in a :\n                std.algorithm.sort(cod_array);\n\
    \                break;\n            case in b :\n                std.algorithm.sort(cod_array,\
    \ std.typecons.greater);\n                break;\n        }\n    }\n    return\
    \ cod_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw2hiv__l.d(30): Error: expression expected, not `in`

    /tmp/tmpw2hiv__l.d(30): Error: found `a` when expecting `:`

    /tmp/tmpw2hiv__l.d(30): Error: found `:` instead of statement

    /tmp/tmpw2hiv__l.d(33): Error: expression expected, not `in`

    /tmp/tmpw2hiv__l.d(33): Error: found `b` when expecting `:`

    /tmp/tmpw2hiv__l.d(33): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw2hiv__l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    static assert(isInputRange!(typeof(array),\
    \ long));\n    static assert(isRandomAccessRange!(typeof(array)));\n    static\
    \ assert(is(array[0] : long));\n    static assert(!is(array : string));\n    static\
    \ assert(!is(array : ubyte[]));\n    if(array.length < 2) return array;\n    size_t\
    \ n = array.length;\n    if((array[0] + array[n - 1]) % 2 == 0)\n    {\n     \
    \   quickSort(array, randomNumberGenerator);\n        return array;\n    }\n \
    \   quickSort(array, randomNumberGenerator);\n    reverse(array);\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzjlk45p7.d(25): Error: template instance `isInputRange!(typeof(array),
    long)` template `isInputRange` is not defined

    /tmp/tmpzjlk45p7.d(25):        while evaluating: `static assert(isInputRange!(typeof(array),
    long))`

    /tmp/tmpzjlk45p7.d(26): Error: template instance `isRandomAccessRange!(typeof(array))`
    template `isRandomAccessRange` is not defined

    /tmp/tmpzjlk45p7.d(26):        while evaluating: `static assert(isRandomAccessRange!(typeof(array)))`

    /tmp/tmpzjlk45p7.d(27): Error: static assert:  `is(array[0] : long)` is false

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjlk45p7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // the result\
    \ array\n    auto result_array = new long[array.length];\n    // don't change\
    \ the given array\n    foreach(index, element; array)\n    {\n        result_array[index]\
    \ = element;\n    }\n    // sort the given array\n    if(array.length > 1)\n \
    \   {\n        if(array[0] + array[$ - 1] % 2)\n        {\n            std.algorithm.sort(result_array);\n\
    \        }\n        else\n        {\n            std.algorithm.sort!(\"a < b\"\
    )(result_array);\n        }\n    }\n    return result_array;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjdf6e255.d(37): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpjdf6e255.d(41): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjdf6e255.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \nin\n{\n    assert(array.length\
    \ == array.length);\n}\nout\n(result)\n{\n    assert(result.length == array.length);\n\
    \    for (int i = 0; i < result.length - 1; i++)\n    {\n        assert(result[i]\
    \ >= result[i + 1]);\n    }\n}\n{\n    if (array.length <= 1)\n    {\n       \
    \ return array;\n    }\n    else\n    {\n        long first = array[0];\n    \
    \    long last = array[array.length - 1];\n        bool ascending = (first + last)\
    \ % 2 == 1;\n        if (ascending)\n        {\n            return std.sort(array);\n\
    \        }\n        else\n        {\n            return std.sort(array, (x, y)\
    \ => x > y);\n        }\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxlxt2cpa.d(37): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxlxt2cpa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // we return\
    \ a new array, the original given array is never changed\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2z_x22b1.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2z_x22b1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] ar2 =\
    \ array;\n    if ((array.length != 0) && (array.length != 1))\n    {\n       \
    \ if ((array[0] + array[array.length - 1]) % 2 == 0)\n        {\n            std.random.shuffle(ar2);\n\
    \            std.sort(ar2);\n            std.reverse(ar2);\n        }\n      \
    \  else\n        {\n            std.random.shuffle(ar2);\n            std.sort(ar2);\n\
    \        }\n    }\n    return ar2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4hfwy4tg.d(30): Error: undefined identifier `random` in package
    `std`

    /tmp/tmp4hfwy4tg.d(31): Error: undefined identifier `sort` in package `std`

    /tmp/tmp4hfwy4tg.d(32): Error: undefined identifier `reverse` in package `std`

    /tmp/tmp4hfwy4tg.d(36): Error: undefined identifier `random` in package `std`

    /tmp/tmp4hfwy4tg.d(37): Error: undefined identifier `sort` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4hfwy4tg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1) return array;\n    long sum = array[0] + array[$-1];\n\
    \    bool isOdd = sum % 2L != 0L;\n    if (isOdd) {\n        return array.sort();\n\
    \    } else {\n        array.sort();\n        return array.reverse();\n    }\n\
    }\n/*\n    def sort_array(source_array):\n    odd = sorted(v for v in source_array\
    \ if v % 2 != 0)\n    even = sorted(v for v in source_array if v % 2 == 0)\n \
    \   return [x for k, x in enumerate(odd + even) for i in range(k, len(source_array),\
    \ 2)]\n*/\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsgjgqfps.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpsgjgqfps.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmpsgjgqfps.d(32): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsgjgqfps.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Sorts the\
    \ array using the funny criterium.\n    auto last = array.length - 1;\n    auto\
    \ tup = tuple(array[0], array[last]);\n    auto direction = tup[0] + tup[1] %\
    \ 2 == 0 ? -1 : 1;\n    return array.sort(direction);\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc48hfle2.d(29): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc48hfle2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // your code\
    \ goes here\n    long[] sorted = array.dup;\n    if (array.length == 0)\n    \
    \    return sorted;\n    auto op = (sorted[0] + sorted[$-1]) & 1 ? \">\" : \"\
    <\";\n    sort(sorted, (a, b) => a eval op b);\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0yn_oaef.d(30): Error: found `eval` when expecting `,`

    /tmp/tmp0yn_oaef.d(30): Error: found `b` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0yn_oaef.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \nin\n{\n    enum int\
    \ sum = 0;\n    enum long[] array_clone = array.dup;\n    foreach(idx, val; array_clone)\n\
    \    {\n        sum += val;\n    }\n    if(sum % 2 == 0)\n    {\n        sort(array_clone,\
    \ (a, b) => b - a);\n    }\n    else\n    {\n        sort(array_clone);\n    }\n\
    \    return array_clone;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0c2s58h7.d(23): Error: function `tmp0c2s58h7.sort_array` `in` and
    `out` contracts can only appear without a body when they are virtual interface
    functions or abstract

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0c2s58h7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    if (array.length == 1)\n        return array;\n\
    \    if (array[0L] + array[array.length - 1L] % 2L == 0L)\n        sort(array,\
    \ (a, b) => b - a);\n    else\n        sort(array, (a, b) => a - b);\n    return\
    \ array;\n}\n```\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgvy9p9mk.d(35): Error: declaration expected, not `""`

    /tmp/tmpgvy9p9mk.d(35): Error: unterminated string constant starting at /tmp/tmpgvy9p9mk.d(35)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgvy9p9mk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // if the array\
    \ is empty\n    if (array.length == 0) \n    {\n        return array;\n    }\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9xtnag2d.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xtnag2d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    bool ascending\
    \ = array.length == 0 ? false : array[0] + array[array.length - 1] % 2 != 0;\n\
    \    auto numbers = array.array;\n    sort!(ascending ? (a, b) => a < b : (a,\
    \ b) => a > b)(numbers);\n    return numbers;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4usggwyp.d(26): Error: no property `array` for type `long[]`

    /tmp/tmp4usggwyp.d(27): Error: template instance `sort!(ascending ? (a, b) =>
    a < b : (a, b) => a > b)` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4usggwyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto array =\
    \ array.dup;\n    static if (array.length > 0) \n    {\n        static if (array[0]\
    \ + array[$ - 1] % 2 == 0)\n        {\n            array.sort!((a, b) => a > b);\n\
    \        } \n        else \n        {\n            array.sort!((a, b) => a < b);\n\
    \        }\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ox14emy.d(25): Error: variable `array` is shadowing variable `tmp4ox14emy.sort_array.array`

    /tmp/tmp4ox14emy.d(26): Error: variable `array` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ox14emy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    bool odd = array.length.even;\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7r5g6rfi.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7r5g6rfi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ < 2)\n        return array;\n    auto sum = array[0] + array[$ - 1];\n    auto\
    \ is_odd = cast(bool)(sum % 2);\n    return is_odd ? array.sort() : array.sort(std.algorithm.comparison.greater);\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxu62v85v.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpxu62v85v.d(29): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxu62v85v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    const cmp_func cmp = array[0] + array[$ - 1] % 2 ==\
    \ 0 ? typeof(gt) : typeof(lt);\n    array.sort!(cmp);\n    return array;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpil13kity.d(26): Error: undefined identifier `cmp_func`

    /tmp/tmpil13kity.d(26): Error: undefined identifier `gt`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmpil13kity.d(26): Error: undefined identifier `lt`

    /tmp/tmpil13kity.d(27): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpil13kity.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return array.length\
    \ == 0 ? array :\n        all(array, el => el >= 0) ? \n            sort(array,\
    \ tuple(a, b) => (a + b) % 2 == 0 ? b - a : a - b) : array;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbgrx7gnr.d(27): Error: found `=>` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbgrx7gnr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result\
    \ = array.dup;\n    result.sort;\n    if (mod(result[0]+result[$-1], 2)==0)\n\
    \        result.reverse;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9wreyyy1.d(26): Error: no property `sort` for type `long[]`

    /tmp/tmp9wreyyy1.d(27): Error: undefined identifier `mod`, did you mean function
    `fmod`?

    /tmp/tmp9wreyyy1.d(28): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9wreyyy1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ != 0)\n    {\n        int sum = (int)(array[0] + array[array.length - 1]);\n\
    \        if (sum % 2 == 0)\n        {\n            array.sort(new Comparator!(long,\
    \ long)\n            {\n                override long opCall(long x, long y) \n\
    \                {\n                    return y - x;\n                }\n   \
    \         });\n        } \n        else \n        {\n            array.sort;\n\
    \        }\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6t7asouk.d(27): Error: C style cast illegal, use `cast(int)(array[0]
    + array[array.length - 1])`

    /tmp/tmp6t7asouk.d(31): Error: found `{` when expecting `,`

    /tmp/tmp6t7asouk.d(32): Error: expression expected, not `override`

    /tmp/tmp6t7asouk.d(32): Error: found `long` when expecting `,`

    /tmp/tmp6t7asouk.d(32): Error: found `x` when expecting `.` following long

    /tmp/tmp6t7asouk.d(32): Error: found `,` when expecting identifier following `long`.

    /tmp/tmp6t7asouk.d(32): Error: found `long` when expecting `,`

    /tmp/tmp6t7asouk.d(33): Error: found `{` when expecting `,`

    /tmp/tmp6t7asouk.d(34): Error: expression expected, not `return`

    /tmp/tmp6t7asouk.d(34): Error: found `y` when expecting `,`

    /tmp/tmp6t7asouk.d(34): Error: found `;` when expecting `,`

    /tmp/tmp6t7asouk.d(35): Error: expression expected, not `}`

    /tmp/tmp6t7asouk.d(36): Error: found `}` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6t7asouk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    bool even =\
    \ (array.length == 0 ||\n                 array.length == 1) ?\n             \
    \   true : \n                (array[0] + array[$-1]) % 2 == 0;\n    if (even)\n\
    \    {\n        return array.dup.sort;\n    }\n    else\n    {\n        return\
    \ array.dup.sort.reverse;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp40fn_xsx.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmp40fn_xsx.d(35): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp40fn_xsx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    // get the value at the first index.\n   \
    \ long first = array[0];\n    // get the value at the last index.\n    long last\
    \ = array[array.length - 1];\n    // Add the values from the first and last indexes.\n\
    \    long sum = first + last;\n    // create a function for sorting\n    void\
    \ sort(long[] arr)\n    {\n        // sort the array in ascending order\n    \
    \    arr.sort(a, b => a > b);\n    }\n    // if the sum is odd, sort the array.\n\
    \    if (sum % 2 != 0)\n        sort(array);\n    // else reverse the array.\n\
    \    else\n        array.reverse();\n    // return the result.\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl4vfmt0i.d(37): Error: no property `sort` for type `long[]`

    /tmp/tmpl4vfmt0i.d(44): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl4vfmt0i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return (array.length\
    \ != 0 ? sort(array[0] + array[$ - 1] % 2 == 0 ? array : array.reverse) : array);\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptan0y8_0.d(25): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptan0y8_0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    static assert(is(typeof(array)\
    \ == long[]));\n    long[] r;\n    typeof(r) val;\n    auto length = array.length;\n\
    \    auto c = length;\n    auto m = div(array[0] + array[$-1], 2);\n    if (c\
    \ == 0) return r;\n    if (c == 1) return array;\n    while (c != 0)\n    {\n\
    \        c = 0;\n        if (m % 2 == 0)\n        {\n            val = array[0];\n\
    \            array[0] = array[$-1];\n            array[$-1] = val;\n        }\n\
    \        for (size_t i = 0; i != array.length; ++i)\n        {\n            if\
    \ (array[i] > array[i + 1])\n            {\n                val = array[i];\n\
    \                array[i] = array[i + 1];\n                array[i + 1] = val;\n\
    \                c = i;\n            }\n        }\n    }\n    return array;\n\
    }\nstring sort_array(string argument)\n{\n    return \"--\" + argument;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp63rk7awc.d(30): Error: undefined identifier `div`

    /tmp/tmp63rk7awc.d(38): Error: cannot implicitly convert expression `array[0]`
    of type `long` to `long[]`

    /tmp/tmp63rk7awc.d(40): Error: cannot implicitly convert expression `val` of type
    `long[]` to `long`

    /tmp/tmp63rk7awc.d(46): Error: cannot implicitly convert expression `array[i]`
    of type `long` to `long[]`

    /tmp/tmp63rk7awc.d(48): Error: cannot implicitly convert expression `val` of type
    `long[]` to `long`

    /tmp/tmp63rk7awc.d(57): Error: invalid array operation `"--" + argument` (possible
    missing [])

    /tmp/tmp63rk7awc.d(63): Error: `tmp63rk7awc.sort_array` called with argument types
    `(void[])` matches both:

    /tmp/tmp63rk7awc.d(23):     `tmp63rk7awc.sort_array(long[] array)`

    and:

    /tmp/tmp63rk7awc.d(55):     `tmp63rk7awc.sort_array(string argument)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp63rk7awc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if ( array.length\
    \ == 0 )\n        return array;\n    if ( array.length == 1 )\n        return\
    \ array;\n    auto lo = 0L;\n    auto hi = array.length - 1L;\n    if ( (array[lo]\
    \ + array[hi]) % 2 == 0 )\n    {\n        // descending\n        while ( lo <\
    \ hi )\n        {\n            if ( array[lo] % 2 != 0 )\n            {\n    \
    \            // find next odd\n                while ( array[hi] % 2 != 0 )\n\
    \                {\n                    --hi;\n                }\n           \
    \     swap(array[lo], array[hi]);\n            }\n            ++lo;\n        }\n\
    \        std.algorithm.sort(array[0L..lo], std.greater!\"a\");\n        std.algorithm.sort(array[lo..$],\
    \ std.less!\"a\");\n    }\n    else\n    {\n        // ascending\n        while\
    \ ( lo < hi )\n        {\n            if ( array[lo] % 2 == 0 )\n            {\n\
    \                // find next even\n                while ( array[hi] % 2 == 0\
    \ )\n                {\n                    --hi;\n                }\n       \
    \         swap(array[lo], array[hi]);\n            }\n            ++lo;\n    \
    \    }\n        std.algorithm.sort(array[0L..lo], std.less!\"a\");\n        std.algorithm.sort(array[lo..$],\
    \ std.greater!\"a\");\n    }\n    return array;\n}\n// TESTS\nunittest\n{\n  \
    \  auto values = [2L, 4L, 3L, 0L, 1L, 5L];\n    auto array = sort_array(values);\n\
    \    assert(array == [0L, 1L, 2L, 3L, 4L, 5L]);\n}\nunittest\n{\n    auto values\
    \ = [2L, 4L, 3L, 0L, 1L, 5L, 6L];\n    auto array = sort_array(values);\n    assert(array\
    \ == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n}\nunittest\n{\n    auto values = [5L];\n\
    \nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzvuxtbqd.d(88): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzvuxtbqd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted\
    \ = array.dup;\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    auto num = new ulong[array.length];\n    for\
    \ (int i = 0; i < array.length; i++)\n    {\n        num[i] = typeof(array[i]).init;\n\
    \    }\n    long[] temp = array.dup;\n    long[] toret = array.dup;\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        array.sort!((x, y) => y\
    \ > x);\n        array.reverse;\n        return array;\n    }\n    else \n   \
    \ {\n        array.sort!((x, y) => x > y);\n        array.reverse;\n        return\
    \ array;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcsl3kze1.d(39): Error: no property `sort` for type `long[]`

    /tmp/tmpcsl3kze1.d(40): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpcsl3kze1.d(45): Error: no property `sort` for type `long[]`

    /tmp/tmpcsl3kze1.d(46): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcsl3kze1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ <= 0) return array;\n    return array[0] + array[$ - 1] % 2 == 0 ? array.sort(std.typecons.reversed).array\
    \ : array.sort().array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7asu_mnw.d(26): Error: no property `sort` for type `long[]`

    /tmp/tmp7asu_mnw.d(26): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7asu_mnw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    import std.algorithm\
    \ : sort;\n    import std.array : splice;\n    import std.conv : to;\n    import\
    \ std.functional : binaryFun;\n    import std.range : iota;\n    import std.typecons\
    \ : Tuple;\n    long[][2] m = array.iota.sort!((a, b) => array[a] < array[b]).chunks(array.length\
    \ / 2 + array.length % 2);\n    long[] result = m[0].map!(a => array[a]).array;\n\
    \    result ~= m[1].map!(a => array[a]).reverse.array;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpptfbzgol.d(26): Error: module `std.array` import `splice` not found,
    did you mean template `std.array.split(S)(S s) if (isSomeString!S)`?

    /tmp/tmpptfbzgol.d(31): Error: template `std.range.iota` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/range/package.d(5890):        `std.range.iota(B,
    E, S)(B begin, E end, S step) if ((isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B,
    E))) && isIntegral!S)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/range/package.d(6000):        `std.range.iota(B,
    E)(B begin, E end) if (isFloatingPoint!(CommonType!(B, E)))`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/range/package.d(6007):        `std.'
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result\
    \ = array.dup;\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpap6wzz_w.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpap6wzz_w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long firstIndexValue\
    \ = array[0];\n    long lastIndexValue = array[array.length - 1];\n    if((firstIndexValue\
    \ + lastIndexValue) % 2 == 0)\n    {\n        return sort(array, (a, b) => b <\
    \ a);\n    }\n    else\n    {\n        return sort(array, (a, b) => a < b);\n\
    \    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphd9f70we.d(29): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmphd9f70we.d(33): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphd9f70we.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto result\
    \ = array.dup;\n    auto rng = result.retro;\n    bool odd_index = false;\n  \
    \  if(rng.front + rng.back) % 2L != 0L)\n        odd_index = true;\n    if(odd_index)\n\
    \        sort(result, (a, b) => a > b);\n    else\n        sort(result, (a, b)\
    \ => a < b);\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgz3zugah.d(28): Error: found `%` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz3zugah.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n\tif (array.length\
    \ == 0)\n\t\treturn array;\n\tlong first = array[0];\n\tlong last = array[array.length\
    \ - 1];\n\tif ((first + last) % 2 == 0)\n\t\treturn sort(array, (a, b) => b -\
    \ a);\n\telse\n\t\treturn sort(array, (a, b) => a - b);\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn97mdg5m.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpn97mdg5m.d(32): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn97mdg5m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    if (array.length == 1) return array;\n    long m =\
    \ array[0];\n    long n = array[array.length - 1];\n    if ((m + n) % 2 == 0)\n\
    \    {\n        return array.sort.retro.copy;\n    }\n    else\n    {\n      \
    \  return array.sort.copy;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk0b6wo1l.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmpk0b6wo1l.d(35): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk0b6wo1l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Sort the\
    \ array in ascending order if the sum of the first and last index is odd, \n \
    \   // or in descending order if the sum of the first and last index is even.\n\
    \    long[] copy = array.dup;\n    if ( (copy[0] + copy[copy.length - 1]) % 2\
    \ == 0 ) \n    {\n        sort(copy, (a, b) => b - a);\n    }\n    else \n   \
    \ {\n        sort(copy);\n    }\n    return copy;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0vxixgci.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp0vxixgci.d(34): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0vxixgci.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \nin \n{\n    assert(array.length\
    \ != 0);\n}\nout (result)\n{\n    assert(result.length == array.length);\n   \
    \ assert(array.length == 0 ||\n        (result[0] <= result[$-1] &&\n        (array[0]\
    \ + array[$-1]) % 2 == 0) ||\n        (result[0] >= result[$-1] &&\n        (array[0]\
    \ + array[$-1]) % 2 == 1));\n}\n{\n    alias E = long;\n    if (array.length <=\
    \ 1)\n    {\n        return array;\n    }\n    else if ((array[0] + array[$-1])\
    \ % 2 == 0)\n    {\n        return array.sort!((a, b) => b < a);\n    }\n    else\n\
    \    {\n        return array.sort!((a, b) => a < b);\n    }\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa9matoyp.d(37): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa9matoyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    array.sort();\n\
    \    if (array.length == 0 || array.length == 1) return array;\n    if ((array[0]\
    \ + array[$-1]) % 2 == 0)\n    {\n        array.reverse();\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprp96u0vw.d(25): Error: no property `sort` for type `long[]`

    /tmp/tmprp96u0vw.d(29): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprp96u0vw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n\tif (array.length\
    \ < 2)\n\t\treturn array;\n\t\t\n\tif ((array[0] + array[array.length - 1]) %\
    \ 2 == 0)\n\t\treturn sort!(\"a > b\")(array);\n\telse\n\t\treturn sort!(\"a <\
    \ b\")(array);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpix5rus2o.d(29): Error: template instance `sort!"a > b"` template
    `sort` is not defined, did you mean sqrt?

    /tmp/tmpix5rus2o.d(31): Error: template instance `sort!"a < b"` template `sort`
    is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpix5rus2o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Constraints:\n\
    \    assert(array !is null && array.length <= 20);\n    foreach(x; array)\n  \
    \      assert(x <= 100L);\n    // End constraints\n    \n    import std.algorithm.sorting\
    \ : sort;\n    if(array.length == 0) return [];\n    // make a copy of the given\
    \ array\n    auto copy = new long[](array.length);\n    copy = array.dup;\n  \
    \  // sort the copy in ascending order using a lambda\n    copy.sort!((ref a,\
    \ ref b) => a < b);\n    // create an array of ints of the same length\n    auto\
    \ array_of_ints = new int[](copy.length);\n    array_of_ints = iota(copy.length);\n\
    \    // create a tuple of the array of ints and the copy\n    auto tuple = tuple(array_of_ints,\
    \ copy);\n    // sort the array of ints in descending order using a lambda\n \
    \   tuple[0].sort!((ref a, ref b) => a > b);\n    // return the sorted copy\n\
    \    return tuple[1];\n}\nunittest\n{\n    alias candidate = sort_array;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprg69cjfc.d(40): Error: undefined identifier `iota`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg69cjfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    if (array.length == 1)\n        return array;\n\
    \    bool is_even = (array[0] + array[$-1]) % 2 == 0;\n    auto p = new bool[array.length];\n\
    \    foreach (idx, elem; array)\n    {\n        if (idx % 2 == 0)\n          \
    \  p[idx] = is_even;\n        else\n            p[idx] = !is_even;\n    }\n  \
    \  array.sort!((a, b) => p[a] < p[b]);\n    return array;\n}\nunittest\n{\n  \
    \  alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp50777isb.d(38): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp50777isb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = array[0]\
    \ + array[array.length - 1];\n    auto sorter = (sum % 2 == 0) ? sort!((a, b)\
    \ => a > b) : sort!((a, b) => a < b);\n    return sorter(array);\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvjez6mdf.d(26): Error: template instance `sort!((a, b) => a > b)`
    template `sort` is not defined, did you mean sqrt?

    /tmp/tmpvjez6mdf.d(26): Error: template instance `sort!((a, b) => a < b)` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvjez6mdf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // type cons:\
    \ tuple\n    auto s = tuple(0L, 0L);\n    foreach(i, ref a; array)\n    {\n  \
    \      s[0] += a;\n        s[1] += i;\n    }\n    if(s[0] % 2)\n        array.sort!((a,\
    \ b) => a < b);\n    else\n        array.sort!((a, b) => a > b);\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpooh10xd7.d(33): Error: no property `sort` for type `long[]`

    /tmp/tmpooh10xd7.d(35): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpooh10xd7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sortedArray\
    \ = array.idup;\n    long sum = array[0] + array[$-1];\n    alias bool IsEven\
    \ = (sum % 2 == 0);\n    if (IsEven) \n    {\n        sortedArray.sort!((a, b)\
    \ => { return b < a; });\n    } \n    else \n    {\n        sortedArray.sort!((a,\
    \ b) => { return a < b; });\n    }\n    return sortedArray;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcxn0pzld.d(27): Error: alias cannot have initializer

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcxn0pzld.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1)\n        return array;\n    else\n    {\n       \
    \ auto ar = array.dup;\n        sort(ar);\n        return ar[0] + ar[$-1] % 2\
    \ ? ar : ar.reverse;\n    }\n}\n \nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkrridbdd.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpkrridbdd.d(31): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkrridbdd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    else if (array.length == 1)\n        return\
    \ array;\n    else\n    {\n        long max = array[0];\n        long min = array[0];\n\
    \        for (long i = 0; i < array.length; i++)\n        {\n            if (array[i]\
    \ > max)\n                max = array[i];\n            if (array[i] < min)\n \
    \               min = array[i];\n        }\n        if ((max + min) % 2 == 0)\n\
    \            return array.sort!((a, b) => b < a);\n        else\n            return\
    \ array.sort!((a, b) => a < b);\n    }\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg5nxdnmm.d(41): Error: no property `sort` for type `long[]`

    /tmp/tmpg5nxdnmm.d(43): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg5nxdnmm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] array_cpy\
    \ = array.dup;\n    auto a = array_cpy[0];\n    auto b = array_cpy[$-1];\n   \
    \ if ((a + b) % 2 == 0)\n    {\n        auto max = std.algorithm.max;\n      \
    \  std.algorithm.sort(array_cpy, (a, b) => max(a, b));\n    }\n    else\n    {\n\
    \        auto min = std.algorithm.min;\n        std.algorithm.sort(array_cpy,\
    \ (a, b) => min(a, b));\n    }\n    return array_cpy;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh2rzpes.d(30): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpdh2rzpes.d(31): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpdh2rzpes.d(35): Error: undefined identifier `algorithm` in package `std`

    /tmp/tmpdh2rzpes.d(36): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh2rzpes.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto sorted_array\
    \ = array.dup;\n    if (array.length > 0)\n    {\n        if (array[0] + array[$-1]\
    \ % 2 == 0)\n        {\n            sorted_array.sort!((x, y) => x < y);\n   \
    \     }\n        else\n        {\n            sorted_array.sort!((x, y) => x >\
    \ y);\n        }\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_bagjjne.d(30): Error: no property `sort` for type `long[]`

    /tmp/tmp_bagjjne.d(34): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_bagjjne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] temp_arr\
    \ = array.dup;\n    int i = 0;\n    int j = array.length - 1;\n    while (i <\
    \ j)\n    {\n        if (array[i] % 2 == 0)\n        {\n            if (array[j]\
    \ % 2 == 0)\n            {\n                j--;\n            }\n            else\n\
    \            {\n                swap(temp_arr[i], temp_arr[j]);\n            \
    \    i++;\n                j--;\n            }\n        }\n        else\n    \
    \    {\n            i++;\n        }\n    }\n    quickSort(temp_arr, 0, temp_arr.length\
    \ - 1);\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n     \
    \   for (i = 0; i < temp_arr.length / 2; i++)\n        {\n            swap(temp_arr[i],\
    \ temp_arr[temp_arr.length - 1 - i]);\n        }\n    }\n    return temp_arr;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmgb3ucmy.d(27): Error: cannot implicitly convert expression `array.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpmgb3ucmy.d(38): Error: undefined identifier `swap`, did you mean template
    `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?

    /tmp/tmpmgb3ucmy.d(48): Error: undefined identifier `quickSort`

    /tmp/tmpmgb3ucmy.d(53): Error: undefined identifier `swap`, did you mean template
    `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmgb3ucmy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    auto sort = array[0] + array[$-1] % 2 ? sort\
    \ : reverse;\n    return sort(array.dup);\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw5kuc_bq.d(27): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw5kuc_bq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // ...\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8c53j9n4.d(23): Error: function `tmp8c53j9n4.sort_array` has no
    `return` statement, but is expected to return a value of type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8c53j9n4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    long odd_sum = ((array[0] & 1) == 1)? array[0]\
    \ : 0;\n    long even_sum = ((array[0] & 1) == 0)? array[0] : 0;\n    foreach\
    \ (i, ref value; array[1 .. $])\n    {\n        if ((value & 1) == 1)\n      \
    \      odd_sum += value;\n        else\n            even_sum += value;\n    }\n\
    \    auto comp_func = ((odd_sum + even_sum) & 1) == 1 ? (a, b) => a < b : (a,\
    \ b) => a > b;\n    array.sort(comp_func);\n    return array;\n}\n// -------------\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj55ghoen.d(36): Error: variable `tmpj55ghoen.sort_array.comp_func`
    type `void` is inferred from initializer `(odd_sum + even_sum & cast(long)1) ==
    cast(long)1 ? (a, b) => a < b : (a, b) => a > b`, and variables cannot be of type
    `void`

    /tmp/tmpj55ghoen.d(36): Error: expression `(odd_sum + even_sum & cast(long)1)
    == cast(long)1 ? (a, b) => a < b : (a, b) => a > b` is `void` and has no value

    /tmp/tmpj55ghoen.d(37): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj55ghoen.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \nin {\n  foreach(idx,\
    \ v; array)\n    assert(v >= 0);\n}\nout(result) {\n  assert(result.length ==\
    \ array.length);\n}\n{\n  int i = 0;\n  long[] res;\n  if (array.length > 0) {\n\
    \    int ind = array.length-1;\n    int sum = array[0] + array[ind];\n    if (sum\
    \ % 2 == 0) {\n      res = select(long[])array.dup.sort(std.algorithm.sorting.max);\n\
    \    } else {\n      res = select(long[])array.dup.sort(std.algorithm.sorting.min);\n\
    \    }\n  } else {\n    res = array;\n  }\n  return res;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbtfp992c.d(31): Error: missing `do { ... }` after `in` or `out`

    /tmp/tmpbtfp992c.d(38): Error: found `[` when expecting `.` following long

    /tmp/tmpbtfp992c.d(38): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpbtfp992c.d(38): Error: found `array` when expecting `;` following statement

    /tmp/tmpbtfp992c.d(40): Error: found `[` when expecting `.` following long

    /tmp/tmpbtfp992c.d(40): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpbtfp992c.d(40): Error: found `array` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtfp992c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{ \n    auto tuple\
    \ = tuple(0L, array.back);\n    long[] result = array;\n    if(tuple.front & 1)\n\
    \    {\n        result = array.sort();\n    }\n    else\n    {\n        result\
    \ = array.sort().reverse();\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mzjis4v.d(25): Error: no property `back` for type `long[]`

    /tmp/tmp_mzjis4v.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmp_mzjis4v.d(33): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mzjis4v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result\
    \ = new long[array.length];\n    if (array.length == 0)\n        return array;\n\
    \    if (array.length == 1)\n        return array;\n    bool sortOrder = (array[0]\
    \ + array[array.length - 1]) % 2 == 0;\n    if (sortOrder)\n    {\n        result\
    \ = array.copy();\n        result.sort(std.sort.descending);\n    }\n    else\n\
    \    {\n        result = array.copy();\n        result.sort(std.sort.ascending);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr81z0r4r.d(33): Error: no property `copy` for type `long[]`

    /tmp/tmpr81z0r4r.d(34): Error: no property `sort` for type `long[]`

    /tmp/tmpr81z0r4r.d(38): Error: no property `copy` for type `long[]`

    /tmp/tmpr81z0r4r.d(39): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr81z0r4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    long[] res = new long[array.length];\n   \
    \ auto l = array[0];\n    auto r = array[$ - 1];\n    if ((l + r) % 2 == 0)\n\
    \    {\n        res = array.idup;\n        res.sort!\"a > b\";\n    }\n    else\n\
    \    {\n        res = array.idup;\n        res.sort!\"a < b\";\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6sxuyw4i.d(32): Error: cannot implicitly convert expression `idup(array)`
    of type `immutable(long)[]` to `long[]`

    /tmp/tmp6sxuyw4i.d(33): Error: no property `sort` for type `long[]`

    /tmp/tmp6sxuyw4i.d(37): Error: cannot implicitly convert expression `idup(array)`
    of type `immutable(long)[]` to `long[]`

    /tmp/tmp6sxuyw4i.d(38): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6sxuyw4i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto l = array.length;\n\
    \    if(l is 0)\n        return array;\n    else if(l is 1)\n        return array;\n\
    \    else\n    {\n        if((array[0] + array[$-1]) % 2 is 0)\n            return\
    \ sort!((a, b) => a > b)(array);\n        else\n            return sort!((a, b)\
    \ => a < b)(array);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx87s96f5.d(33): Error: template instance `sort!((a, b) => a > b)`
    template `sort` is not defined, did you mean sqrt?

    /tmp/tmpx87s96f5.d(35): Error: template instance `sort!((a, b) => a < b)` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx87s96f5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] new_array\
    \ = array.dup;\n    if(array.length > 0 && array.length % 2 == 0)\n    {\n   \
    \     new_array.sort!((x, y) => y - x);\n    }\n    else\n    {\n        new_array.sort!((x,\
    \ y) => x - y);\n    }\n    return new_array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2m3kz4m.d(28): Error: no property `sort` for type `long[]`

    /tmp/tmpd2m3kz4m.d(32): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2m3kz4m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long k = array.front\
    \ + array.back;\n    if(k%2==0) \n    {\n        array.sort!((a, b) => b < a);\n\
    \    } \n    else \n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2g2j9259.d(25): Error: no property `front` for type `long[]`

    /tmp/tmp2g2j9259.d(25): Error: no property `back` for type `long[]`

    /tmp/tmp2g2j9259.d(28): Error: no property `sort` for type `long[]`

    /tmp/tmp2g2j9259.d(32): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2g2j9259.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto first =\
    \ array[0];\n    auto last = array[$-1];\n    auto sum = first + last;\n    auto\
    \ is_odd = sum % 2;\n    auto elem = new long[array.length];\n    auto mutable_array\
    \ = array[];\n    auto i = 0;\n    while (true)\n    {\n        auto min = minElement(mutable_array);\n\
    \        auto max = maxElement(mutable_array);\n        if (is_odd)\n        {\n\
    \            elem[i] = min;\n            mutable_array = array.filter!(x => x\
    \ != min)[];\n        }\n        else\n        {\n            elem[i] = max;\n\
    \            mutable_array = array.filter!(x => x != max)[];\n        }\n    \
    \    i++;\n        if (mutable_array.length == 0)\n            break;\n    }\n\
    \    return elem;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo8c4fa96.d(34): Error: undefined identifier `minElement`

    /tmp/tmpo8c4fa96.d(35): Error: undefined identifier `maxElement`

    /tmp/tmpo8c4fa96.d(39): Error: no property `filter` for type `long[]`

    /tmp/tmpo8c4fa96.d(44): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8c4fa96.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    /*\n    long[]\
    \ result;\n    if(array.length>0)\n    {\n        if(array[0]+array[array.length-1]%2==0)\n\
    \        {\n            auto op_c = cmp(a, b){\n                if(a>b)\n    \
    \                return -1;\n                else if(a<b)\n                  \
    \  return 1;\n                else\n                    return 0;\n          \
    \  };\n            result = array.dup.sort!op_c;\n        }\n        else\n  \
    \      {\n            auto op_c = cmp(a, b){\n                if(a>b)\n      \
    \              return 1;\n                else if(a<b)\n                    return\
    \ -1;\n                else\n                    return 0;\n            };\n \
    \           result = array.dup.sort!op_c;\n        }\n    }\n    else\n    {\n\
    \        result = array.dup;\n    }\n    return result;\n    */\n    if(array.length<=1)\n\
    \        return array.dup;\n    else\n    {\n        if((array[0]+array[array.length-1])%2==0)\n\
    \        {\n            sort!((a, b) => a > b)(array);\n        }\n        else\n\
    \        {\n            sort!((a, b) => a < b)(array);\n        }\n        return\
    \ array.dup;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1yf0hh_i.d(66): Error: template instance `sort!((a, b) => a > b)`
    template `sort` is not defined, did you mean sqrt?

    /tmp/tmp1yf0hh_i.d(70): Error: template instance `sort!((a, b) => a < b)` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1yf0hh_i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto n = array.length;\n\
    \    auto sorted = array.dup;\n    if ((sorted[0] + sorted[$-1]) % 2 == 0)\n \
    \   {\n        sort!((a, b) => b < a)(sorted);\n    }\n    else\n    {\n     \
    \   sort!((a, b) => a < b)(sorted);\n    }\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp98wcvmjr.d(29): Error: template instance `sort!((a, b) => b < a)`
    template `sort` is not defined, did you mean sqrt?

    /tmp/tmp98wcvmjr.d(33): Error: template instance `sort!((a, b) => a < b)` template
    `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp98wcvmjr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Sorted array.\n\
    \    auto sorted_array = array.dup;\n    const size_t n = sorted_array.length;\n\
    \    // Check if the array is empty.\n    if (n == 0)\n    {\n        return [];\n\
    \    }\n    // Check if the array contains only one element.\n    if (n == 1)\n\
    \    {\n        return sorted_array;\n    }\n    // Sort the array in ascending\
    \ order.\n    sort(sorted_array);\n    // Sum of first and last index values.\n\
    \    const long sum = sorted_array[0] + sorted_array[n - 1];\n    // Check if\
    \ sum is odd.\n    if (sum % 2 != 0)\n    {\n        return sorted_array;\n  \
    \  }\n    // Sort the array in descending order.\n    sort(sorted_array, std.functional.greater!\"\
    a\"());\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe8i5y0by.d(39): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpe8i5y0by.d(48): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe8i5y0by.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Making sure\
    \ the array is not empty\n    if (array.length == 0) \n    {\n        return array;\n\
    \    }\n    // If the array has only one element, return it.\n    if (array.length\
    \ == 1) \n    {\n        return array;\n    }\n    // If the sum of the first\
    \ and last index is odd\n    if (array[0] + array[$ - 1] % 2 != 0) \n    {\n \
    \       return array.sorted;\n    }\n    else \n    {\n        array.sort;\n \
    \       return array.reverse;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsdbaif2s.d(38): Error: no property `sorted` for type `long[]`

    /tmp/tmpsdbaif2s.d(42): Error: no property `sort` for type `long[]`

    /tmp/tmpsdbaif2s.d(43): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsdbaif2s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{ \n    long sum1 =\
    \ array[0] + array[array.length - 1];\n    long[] result = array.dup;\n    if\
    \ (sum1 % 2 == 0) \n    {\n        result.sort!((a, b) => a > b);\n    }\n   \
    \ else \n    {\n        result.sort!((a, b) => a < b);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaw2wvx6p.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpaw2wvx6p.d(33): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaw2wvx6p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Your code\
    \ goes here!\n    return array.dup;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgfsg8tsg.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429721]

    ??:? void tmpgfsg8tsg.__unittest_L28_C1() [0x4281a6]

    ??:? void tmpgfsg8tsg.__modtest() [0x428698]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e26b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x4293aa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aff5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b084]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42af81]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429381]

    ??:? runModuleUnitTests [0x42e041]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429bc4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto len = array.length;\n\
    \    if (len == 0) \n    {\n        return [];\n    }\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpilcpok5x.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilcpok5x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ <= 0)\n        return array;\n    long[] newArray = array.dup;\n    if (array[0]\
    \ + array[array.length - 1] % 2 == 0)\n        newArray.sort( (a, b) => a < b\
    \ );\n    else\n        newArray.sort( (a, b) => a > b );\n    return newArray;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdlkdakp1.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpdlkdakp1.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdlkdakp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int i = 0;\n\
    \    int j = array.length - 1;\n    bool sorted = false;\n    long temp;\n   \
    \ if(array.length == 0 || array.length == 1)\n        return array;\n    else\
    \ if(array.length % 2 == 0)\n    {\n        while(!sorted)\n        {\n      \
    \      sorted = true;\n            for(i = 0; i < j; i++)\n            {\n   \
    \             if(array[i] < array[i + 1])\n                {\n               \
    \     temp = array[i];\n                    array[i] = array[i + 1];\n       \
    \             array[i + 1] = temp;\n                    sorted = false;\n    \
    \            }\n            }\n            j--;\n        }\n    }\n    else\n\
    \    {\n        while(!sorted)\n        {\n            sorted = true;\n      \
    \      for(i = 0; i < j; i++)\n            {\n                if(array[i] > array[i\
    \ + 1])\n                {\n                    temp = array[i];\n           \
    \         array[i] = array[i + 1];\n                    array[i + 1] = temp;\n\
    \                    sorted = false;\n                }\n            }\n     \
    \       j--;\n        }\n    }\n    return array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpttbcvdm5.d(26): Error: cannot implicitly convert expression `array.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttbcvdm5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // Given a mutable\
    \ array,\n    // If the first index of the array and the last index of the array\n\
    \    // summed is even, return the array in descending order;\n    // else return\
    \ the array in ascending order.\n    //\n    // The mutable array is not changed.\n\
    \    //\n    // Examples:\n    // >>> sort_array([])\n    // []\n    // >>> sort_array([5L])\n\
    \    // [5L]\n    // >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    // [0L, 1L,\
    \ 2L, 3L, 4L, 5L]\n    // >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    //\
    \ [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    import std.array;\n    import std.range;\n\
    \    import std.math;\n    import std.typecons;\n    import std.algorithm;\n \
    \   if (array.length < 2)\n    {\n        return array;\n    }\n    // Sum the\
    \ first and last index values.\n    long first_last_sum = array[0] + array[$ -\
    \ 1];\n    // If the sum is even, sort descending, else sort ascending.\n    bool\
    \ descending = (first_last_sum % 2 == 0);\n    long[] sorted = array[];\n    sort(sorted,\
    \ descending ? std.greater.byValue!long : std.less.byValue!long);\n    return\
    \ sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb5w0870n.d(55): Error: undefined identifier `greater` in package
    `std`

    /tmp/tmpb5w0870n.d(55): Error: undefined identifier `less` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5w0870n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int size = array.length;\n\
    \    if (size == 0)\n        return array;\n    if (size == 1)\n        return\
    \ array;\n    //long[] ret = array.dup;\n    long[] ret = new long[size];\n  \
    \  auto a = array.sort;\n    long first = a[0];\n    long last = a[size - 1];\n\
    \    if ((first + last) % 2 == 0)\n    {\n        for (size_t i = 0; i < size;\
    \ i++)\n        {\n            ret[i] = a[size - 1 - i];\n        }\n    }\n \
    \   else\n    {\n        for (size_t i = 0; i < size; i++)\n        {\n      \
    \      ret[i] = a[i];\n        }\n    }\n    return ret;\n}\n// test\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8myfeq_9.d(25): Error: cannot implicitly convert expression `array.length`
    of type `ulong` to `int`

    /tmp/tmp8myfeq_9.d(32): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8myfeq_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] copy\
    \ = new long[];\n    copy = copy(array);\n    auto odd_array = array.filter!((x)\
    \ => (x % 2));\n    auto even_array = array.filter!((x) => (x % 2 == 0));\n  \
    \  quickSort(even_array);\n    quickSort(odd_array);\n    if (copy[0] + copy[copy.length\
    \ - 1] % 2 == 0)\n    {\n        copy = merge(even_array, odd_array);\n    }\n\
    \    else\n    {\n        copy = merge(odd_array, even_array);\n    }\n    return\
    \ copy;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphz_j3595.d(25): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmphz_j3595.d(26): Error: function expected before `()`, not `copy` of type
    `long[]`

    /tmp/tmphz_j3595.d(27): Error: no property `filter` for type `long[]`

    /tmp/tmphz_j3595.d(28): Error: no property `filter` for type `long[]`

    /tmp/tmphz_j3595.d(29): Error: undefined identifier `quickSort`

    /tmp/tmphz_j3595.d(30): Error: undefined identifier `quickSort`

    /tmp/tmphz_j3595.d(33): Error: undefined identifier `merge`

    /tmp/tmphz_j3595.d(37): Error: undefined identifier `merge`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphz_j3595.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return new long[0];\n    if (array.length == 1)\n        return\
    \ array;\n    if (array[0] + array[array.length - 1] % 2 == 0)\n        sort(array);\n\
    \    else\n        reverse(sort(array));\n    return array;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3pmz5dl.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmph3pmz5dl.d(32): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3pmz5dl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    auto cmp = (long\
    \ lhs, long rhs) => array[lhs] < array[rhs];\n    if((array.length > 0) & (cmp(0,\
    \ array.length - 1)) is true) \n    {\n        cmp = (long lhs, long rhs) => array[lhs]\
    \ > array[rhs];\n    }\n    auto isorted = iota(array.length);\n    isorted.sort!(cmp);\n\
    \    return isorted.map!(i => array[i]).array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hee6vm9.d(26): Error: `cmp(0, array.length - 1) is true` must
    be parenthesized when next to operator `&`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hee6vm9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long i1 = array[0];\n\
    \    long il = array[$-1];\n    if ((i1 + il) % 2 == 0)\n    {\n        return\
    \ array.sort!((a, b) => b - a);\n    }\n    else\n    {\n        return array.sort!((a,\
    \ b) => a - b);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjhu4l1_y.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpjhu4l1_y.d(33): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjhu4l1_y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // TODO\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv1di_8q2.d(23): Error: function `tmpv1di_8q2.sort_array` has no
    `return` statement, but is expected to return a value of type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv1di_8q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n  return tuple(tuple(array[0],\
    \ true), tuple(array[array.length - 1], false))\n    .map!((x) => (x[0] + (x[1]\
    \ ? 0 : 1)) % 2)\n    .reduce!q{a, b => (a + b) % 2 == 0}\n    ? array.sort!q{a,\
    \ b => a < b}\n    : array.sort!q{a, b => a > b};\n}\n// test_code\nunittest \n\
    {\n    assert(sort_array([]) == []);\n    assert(sort_array([5L]) == [5L]);\n\
    \    assert(sort_array([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n\
    \    assert(sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpok1b19ik.d(26): Error: no property `map` for type `Tuple!(Tuple!(long,
    bool), Tuple!(long, bool))`

    /tmp/tmpok1b19ik.d(28): Error: no property `sort` for type `long[]`

    /tmp/tmpok1b19ik.d(29): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpok1b19ik.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    enum Condition\
    \ \n    {\n        Odd,\n        Even\n    }\n    bool isOdd(long num) \n    {\n\
    \        return num % 2 == 1;\n    }\n    // ...\n    auto len = array.length;\n\
    \    if (len == 0)\n        return array;\n    else if (len == 1)\n        return\
    \ array;\n    else if (len == 2) \n    {\n        long a = array[0];\n       \
    \ long b = array[1];\n        if (isOdd(a + b))\n            return [min(a, b),\
    \ max(a, b)];\n        else\n            return [max(a, b), min(a, b)];\n    }\n\
    \    else \n    {\n        long a = array[0];\n        long b = array[$ - 1];\n\
    \        if (isOdd(a + b))\n            return array.sort;\n        else\n   \
    \         return array.sort.reverse;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9owrhcgf.d(45): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp9owrhcgf.d(45): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp9owrhcgf.d(47): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp9owrhcgf.d(47): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp9owrhcgf.d(54): Error: no property `sort` for type `long[]`

    /tmp/tmp9owrhcgf.d(56): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9owrhcgf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    if (array.length == 1)\n        return array;\n\
    \    auto firstValue = array[0];\n    auto lastValue = array[$ - 1];\n    auto\
    \ total = firstValue + lastValue;\n    auto ascendingOrder = (total % 2 == 0)\
    \ ? false : true;\n    if (ascendingOrder)\n        array.sort!((a, b) => (a <\
    \ b));\n    else\n        array.sort!((a, b) => (a > b));\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptdb_khwv.d(34): Error: no property `sort` for type `long[]`

    /tmp/tmptdb_khwv.d(36): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptdb_khwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result\
    \ = new long[array.length];\n    if (array.length <= 1)\n        return array;\n\
    \    result[0] = array[0];\n    result[array.length - 1] = array[array.length\
    \ - 1];\n    if ((result[0] + result[array.length - 1]) % 2 == 0)\n    {\n   \
    \     for (int i = 1; i < array.length - 1; i++)\n        {\n            auto\
    \ t1 = array[i];\n            for (int j = i; j > 0; j--)\n            {\n   \
    \             if (result[j - 1] < t1)\n                {\n                   \
    \ break;\n                }\n                else\n                {\n       \
    \             result[j] = result[j - 1];\n                }\n            }\n \
    \           result[j] = t1;\n        }\n    }\n    else\n    {\n        for (int\
    \ i = 1; i < array.length - 1; i++)\n        {\n            auto t1 = array[i];\n\
    \            for (int j = i; j > 0; j--)\n            {\n                if (result[j\
    \ - 1] > t1)\n                {\n                    break;\n                }\n\
    \                else\n                {\n                    result[j] = result[j\
    \ - 1];\n                }\n            }\n            result[j] = t1;\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj0fsub4e.d(46): Error: undefined identifier `j`

    /tmp/tmpj0fsub4e.d(65): Error: undefined identifier `j`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj0fsub4e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return \n  \
    \  ( \n        array.length == 0 || array.length == 1 \n        ? array \n   \
    \     : (\n            ( array[0] + array[$-1] ) % 2 == 0 \n            ? array.sort(\
    \ (a, b) => b - a ) \n            : array.sort( (a, b) => a - b ) \n        )\n\
    \    );\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsy2bjypp.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmpsy2bjypp.d(32): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsy2bjypp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ < 1)\n        return array;\n    if (array.length == 1)\n        return array;\n\
    \    auto evenOddSum = array[0] + array[array.length - 1];\n    bool even = evenOddSum\
    \ % 2 == 0;\n    if (even)\n        array = array.sort!((a, b) => b.compare(a));\n\
    \    else\n        array = array.sort!((a, b) => a.compare(b));\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb731lxc9.d(32): Error: no property `sort` for type `long[]`

    /tmp/tmpb731lxc9.d(34): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb731lxc9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return array.isEmpty\
    \ ? new long[0] : sort_array_impl(array, 0, array.length, true);\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyi8i5sz1.d(25): Error: no property `isEmpty` for type `long[]`

    /tmp/tmpyi8i5sz1.d(25): Error: undefined identifier `sort_array_impl`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyi8i5sz1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    assert(!array.empty);\n\
    \    //return std.sort(array, cmp);\n    return array.dup.sort(cmp);\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqdz4rwi4.d(25): Error: no property `empty` for type `long[]`

    /tmp/tmpqdz4rwi4.d(27): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqdz4rwi4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // If the array\
    \ is empty, return it\n    if (array.length == 0) return array;\n    \n    //\
    \ If there is only one element in the array, return it\n    if (array.length ==\
    \ 1) return array;\n    \n    // Create a new array that will be returned\n  \
    \  long[] newArray = array;\n    \n    // Sort the array using a sort function\n\
    \    // (use std.algorithm.sort)\n    newArray = newArray.sort;\n    \n    //\
    \ If the sum of the first and last index values is odd:\n    if ((newArray[0]\
    \ + newArray[newArray.length - 1]) % 2 == 1)\n    {\n        // Return the array\n\
    \        return newArray;\n    }\n    // Else:\n    else\n    {\n        // Reverse\
    \ the array\n        // (use std.algorithm.reverse)\n        newArray = newArray.reverse;\n\
    \        \n        // Return the array\n        return newArray;\n    }\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt_7af5mo.d(36): Error: no property `sort` for type `long[]`

    /tmp/tmpt_7af5mo.d(49): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_7af5mo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    // todo: write\
    \ your code here\n    auto len = array.length;\n    if (len < 2)\n        return\
    \ array;\n    auto first = array[0];\n    auto last = array[$ - 1];\n    auto\
    \ comparator = (first + last) % 2 ? \">\" : \"<\";\n    auto func = getAsFunction!(comparator)(int,\
    \ int);\n    auto swap = (i, j) =>\n    {\n        auto temp = array[i];\n   \
    \     array[i] = array[j];\n        array[j] = temp;\n    };\n    auto partition\
    \ = (left, right) =>\n    {\n        auto pivot = array[left];\n        auto i\
    \ = left;\n        auto j = right;\n        while (i < j)\n        {\n       \
    \     while (i < j && func(array[j], pivot))\n                j--;\n         \
    \   swap(i, j);\n            while (i < j && func(pivot, array[i]))\n        \
    \        i++;\n            swap(i, j);\n        }\n        return i;\n    };\n\
    \    auto quickSort = (left, right) =>\n    {\n        if (left < right)\n   \
    \     {\n            auto index = partition(left, right);\n            quickSort(left,\
    \ index - 1);\n            quickSort(index + 1, right);\n        }\n    };\n \
    \   quickSort(0, len - 1);\n    return array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprj24w8dc.d(32): Error: found `,` when expecting `.` following int

    /tmp/tmprj24w8dc.d(32): Error: found `int` when expecting identifier following
    `int`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprj24w8dc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0)\n        return array;\n    \n    if (array.length == 1)\n        return\
    \ array;\n    \n    bool is_odd = (array[0] + array[array.length - 1]) % 2 ==\
    \ 1;\n    \n    auto sort1 = &compare_numbers_desc;\n    auto sort2 = &compare_numbers_asc;\n\
    \    \n    auto sort_function = (is_odd) ? sort1 : sort2;\n    \n    array.sort(sort_function);\n\
    \    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplmm38g5e.d(33): Error: undefined identifier `compare_numbers_desc`

    /tmp/tmplmm38g5e.d(34): Error: undefined identifier `compare_numbers_asc`

    /tmp/tmplmm38g5e.d(38): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplmm38g5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0) return array;\n    if (array.length == 1) return array;\n    long a =\
    \ array[0];\n    long b = array[$ - 1];\n    long sum = a + b;\n    if (sum %\
    \ 2 == 0) {\n        return array.sort!\"q{a>b}\";\n    } else {\n        return\
    \ array.sort!\"q{a<b}\";\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwpi8fr7_.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmpwpi8fr7_.d(33): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwpi8fr7_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long head =\
    \ array[0];\n    long end = array[array.length - 1];\n    long adder = head +\
    \ end;\n    if (adder % 2 == 0)\n    {\n        sort!(\"a > b\")(array);\n   \
    \ }\n    else\n    {\n        sort!(\"a < b\")(array);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp584jpcqx.d(30): Error: template instance `sort!"a > b"` template
    `sort` is not defined, did you mean sqrt?

    /tmp/tmp584jpcqx.d(34): Error: template instance `sort!"a < b"` template `sort`
    is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp584jpcqx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if ( array.length\
    \ == 0)\n        return array;\n    long[] sorted_array = array;\n    if ( 0 ==\
    \ (array[0] + array[array.length - 1]) % 2 )\n        sorted_array = array.sort!((a,\
    \ b) => a > b);\n    else\n        sorted_array = array.sort!((a, b) => a < b);\n\
    \    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcmyqh0xo.d(29): Error: no property `sort` for type `long[]`

    /tmp/tmpcmyqh0xo.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcmyqh0xo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length\
    \ == 0 || array.length == 1)\n        return array;\n    return sort_array_helper(array,\
    \ 0, array.length - 1);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8r3x0t56.d(27): Error: undefined identifier `sort_array_helper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8r3x0t56.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    bool is_odd\
    \ = (array.length > 0 ? array[0] : 0) + (array.length > 0 ? array[array.length\
    \ - 1] : 0) % 2;\n    if (is_odd)\n    {\n        sort(array);\n    }\n    else\n\
    \    {\n        sort(array[], q{return -q;});\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5xr0if5q.d(25): Error: cannot implicitly convert expression `(array.length
    > 0LU ? array[0] : 0L) + (array.length > 0LU ? array[array.length - 1LU] : 0L)
    % 2L` of type `long` to `bool`

    /tmp/tmp5xr0if5q.d(28): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmp5xr0if5q.d(32): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xr0if5q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    static struct\
    \ my_type {\n        int idx;\n        long value;\n    }\n    auto result = my_type.array();\n\
    \    foreach (idx, value; array)\n    {\n        result ~= my_type(idx, value);\n\
    \    }\n    auto sum = result[0].value + result[$ - 1].value;\n    if (sum % 2\
    \ == 0)\n    {\n        result.sort!((a, b) => a.value < b.value);\n    }\n  \
    \  else\n    {\n        result.sort!((a, b) => a.value > b.value);\n    }\n  \
    \  return result.map!(x => x.value).array();\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_arybjpu.d(29): Error: no property `array` for type `my_type`

    /tmp/tmp_arybjpu.d(32): Error: cannot implicitly convert expression `idx` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_arybjpu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    alias ElemType\
    \ = long;\n    static assert(isIntegral!ElemType);\n    static assert(!isUnsigned!ElemType);\n\
    \    static assert(hasLength!ElemType);\n    static assert(hasSlicing!ElemType);\n\
    \    static assert(hasSwap!ElemType);\n    static assert(hasLessThan!ElemType);\n\
    \    static assert(hasGreaterThan!ElemType);\n    static assert(hasLessEqual!ElemType);\n\
    \    static assert(hasGreaterEqual!ElemType);\n    static assert(hasAssignOp!ElemType);\n\
    \    static assert(hasAddition!ElemType);\n    static assert(hasEqual!ElemType);\n\
    \    static assert(hasAssign!ElemType);\n    static assert(hasMove!ElemType);\n\
    \    static assert(hasBool!ElemType);\n    static assert(hasIndexing!ElemType);\n\
    \    static assert(hasIndexOf!ElemType);\n    static assert(hasTernary!ElemType);\n\
    \    static assert(hasUnaryPlus!ElemType);\n    static assert(hasUnaryNegation!ElemType);\n\
    \    static assert(hasComparable!ElemType);\n    static assert(hasPlusAssign!ElemType);\n\
    \    static assert(hasBitwiseLeftShift!ElemType);\n    static assert(hasBitwiseRightShift!ElemType);\n\
    \    static assert(hasBitwiseAnd!ElemType);\n    static assert(hasBitwiseOr!ElemType);\n\
    \    static assert(hasBitwiseXor!ElemType);\n    static assert(hasBitwiseComplement!ElemType);\n\
    \    static assert(hasBinaryPlus!ElemType);\n    static assert(hasBinarySubtraction!ElemType);\n\
    \    static assert(hasBinaryMultiplication!ElemType);\n    static assert(hasBinaryDivision!ElemType);\n\
    \    static assert(hasBinaryModulo!ElemType);\n    static assert(hasBinaryLessThan!ElemType);\n\
    \    static assert(hasBinaryGreaterThan!ElemType);\n    static assert(has\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv7dvafga.d(62): Error: found `unittest` when expecting `)`

    /tmp/tmpv7dvafga.d(63): Error: found `{` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv7dvafga.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \nin\n{\n    assert(array.length\
    \ > 0);\n}\nbody\n{\n    long sum = array[0] + array[array.length - 1];\n    auto\
    \ sorted = array.dup;\n    if (sum % 2 == 0) \n    {\n        sorted.sort!(\"\
    a > b\");\n    }\n    else \n    {\n        sorted.sort!(\"a < b\");\n    }\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgsek5t36.d(34): Error: no property `sort` for type `long[]`

    /tmp/tmpgsek5t36.d(38): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgsek5t36.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    int sum_indexes\
    \ = array.length > 0 ? array[0] + array[array.length - 1] : 0;\n    auto comparator\
    \ = (sum_indexes % 2 == 0) ? (a, b) => (a > b) : (a, b) => (a < b);\n    auto\
    \ sorted = array.dup;\n    sorted.sort(comparator);\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dbp_xai.d(25): Error: cannot implicitly convert expression `array.length
    > 0LU ? array[0] + array[array.length - 1LU] : 0L` of type `long` to `int`

    /tmp/tmp1dbp_xai.d(26): Error: variable `tmp1dbp_xai.sort_array.comparator` type
    `void` is inferred from initializer `sum_indexes % 2 == 0 ? (a, b) => a > b :
    (a, b) => a < b`, and variables cannot be of type `void`

    /tmp/tmp1dbp_xai.d(26): Error: expression `sum_indexes % 2 == 0 ? (a, b) => a
    > b : (a, b) => a < b` is `void` and has no value

    /tmp/tmp1dbp_xai.d(28): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dbp_xai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of non-negative\
    \ integers, return a cod of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n  \
    \  [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L,\
    \ 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L,\
    \ 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    return array.length\
    \ == 0 ? \n        array : \n        array.take(1).array\n        .cat(array.drop(1).array.sort)\n\
    \        .cat(array.take(1).array);\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8rd2ijxf.d(27): Error: no property `take` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8rd2ijxf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164433
