name: HumanEval_59_largest_prime_factor
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn the largest prime factor\
  \ of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195L)\n\
  \    29L\n    >>> largest_prime_factor(2048L)\n    2L\n    \n*/\nlong largest_prime_factor(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = largest_prime_factor;\n\n    assert(candidate(15L)\
  \ == 5L);\n    assert(candidate(27L) == 3L);\n    assert(candidate(63L) == 7L);\n\
  \    assert(candidate(330L) == 11L);\n    assert(candidate(13195L) == 29L);\n}\n\
  void main(){}"
completions: ["{ \n  long i = 2L; \n  while (n != 1L) \n  { \n    if (n % i == 0L)\
    \ \n    { \n      n /= i; \n    } \n    else \n    { \n      i += 1L; \n    }\
    \ \n  } \n  return i; \n}\n/*\nReturn the smallest positive integer greater than\
    \ 2 which is not prime \nand is the sum of 2 primes.\n    >>> goldbach_odd()\n\
    \    5777\n*/\nuint goldbach_odd() \n{ \n  uint num = 9; \n  for (; ; num += 2)\
    \ \n  { \n    if (num % 2 == 0) \n    { \n      continue; \n    } \n    bool flag\
    \ = false; \n    foreach (i; iota(1u, num / 2 + 1)) \n    { \n      if (isPrime(i)\
    \ && isPrime(num - i)) \n    { \n      flag = true; \n      break; \n    } \n\
    \    } \n    if (!flag) \n    { \n      break; \n    } \n  } \n  return num; \n\
    }\n/*\nReturn the fibonacci number at n.\n    >>> fib(1)\n    1\n    >>> fib(10)\n\
    \    55\n    >>> fib(100)\n    354224848179261915075\n*/\nlong fib(int n) \n{\
    \ \n  if (n == 1) \n  { \n    return 1L; \n  } \n  else if (n == 2) \n  { \n \
    \   return 1L; \n  } \n  else \n  { \n    return fib(n - 1) + fib(n - 2); \n \
    \ } \n}\n/*\nReturn the index of the first fibonacci number with n digits.\n \
    \   >>> fib_index(3)\n    12\n    >>> fib_index(10)\n    45\n    >>> fib_index(20)\n\
    \    177\n*/", "{\n    long max = 0L;\n    long factor = 2L;\n    long quotient\
    \ = n;\n    bool prime = true;\n    while (quotient > 1L) \n    {\n        while\
    \ (quotient % factor == 0L) \n        {\n            prime = true;\n         \
    \   quotient /= factor;\n            foreach (i; iota(2L, factor)) \n        \
    \    {\n                if (factor % i == 0L) \n                {\n          \
    \          prime = false;\n                    break;\n                }\n   \
    \         }\n            if (prime) \n            {\n                max = factor;\n\
    \            }\n        }\n        factor += 1L;\n    }\n    return max;\n}",
  "{\n    long result = 2L;\n    long max = n;\n    long max_sqrt = std.math.sqrt(max);\n\
    \    for (long i = 3L; i <= max_sqrt; i = i + 2L) {\n        if (n % i == 0L)\
    \ {\n            n = n / i;\n            result = i;\n            max = n;\n \
    \           max_sqrt = std.math.sqrt(max);\n        }\n    }\n    if (n > result)\
    \ {\n        result = n;\n    }\n    return result;\n}\n/*\nCompute the sum of\
    \ the digits of n.\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(9)\n\
    \    9\n    >>> sum_digits(999999999999)\n    108\n*/", "{\n    foreach (i; prime_factors(n))\
    \ \n    {\n        if (i > n / i) \n        {\n            return i;\n       \
    \ }\n    }\n    return 1;\n}\n/*\nIn the next cell, write a function that takes\
    \ n as input and returns a tuple of three \nlongs: the smallest, second smallest,\
    \ and third smallest prime factors of n. Assume n > 1.\n    >>> prime_factors_3(13195L)\n\
    \    (5L, 7L, 13L)\n    >>> prime_factors_3(2048L)\n    (2L, 2L, 2L)\n*/\nTuple!(long,\
    \ long, long) prime_factors_3(long n)\n{\n    auto pf = prime_factors(n);\n  \
    \  return make_tuple(pf[0], pf[1], pf[2]);\n}", "{\n    long largest_factor =\
    \ 1L;\n    for (long i = 2L; i < n; i++)\n    {\n        if (n % i == 0L)\n  \
    \      {\n            if (is_prime(i))\n            {\n                largest_factor\
    \ = i;\n            }\n        }\n    }\n    return largest_factor;\n}", "{\n\
    \    long largest_prime_factor = 1L;\n    foreach (i; takeWhile(n % i, iota(2L,\
    \ n)))\n    {\n        largest_prime_factor = max(largest_prime_factor, i);\n\
    \    }\n    return largest_prime_factor;\n}", "{\n    long temp = 0;\n    long\
    \ i = 2;\n    while (i < n)\n    {\n        if (n % i == 0)\n        {\n     \
    \       temp = n / i;\n            break;\n        }\n        i++;\n    }\n  \
    \  if (temp == 0)\n        return n;\n    return largest_prime_factor(temp);\n\
    }", "{\n    import std.algorithm.searching : find;\n    import std.algorithm.iteration\
    \ : filter;\n    import std.range.primitives : iota;\n    import std.math : sqrt;\n\
    \    //divisors of n\n    auto divisors = iota(2L, (long)sqrt(n) + 1).filter!((i)\
    \ => n % i == 0);\n    //primes <= sqrt(n)\n    auto primes = iota(2L, sqrt(n)\
    \ + 1).filter!isPrime;\n    //find the largest prime divisor\n    auto it = divisors.find!((d)\
    \ => primes.canFind(d));\n    //return it\n    return it ? *it : n;\n}\n ", "{\n\
    \tint k = 1;\n\tbool b = true;\n\tlong a,b;\n\tforeach(long f; allPrimes(n))\n\
    \t{\n\t\tforeach(long p; allPrimes(f))\n\t\t{\n\t\t\tif(p > k)\n\t\t\t{\n\t\t\t\
    \tk = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn k;\n}", "{\n    static if (is(typeof(std.numeric.factors(n))\
    \ == Tuple!(long, long, ulong)))\n    {\n        auto m = std.numeric.factors(n);\n\
    \        if (m[0] == n) return n;\n        return m[0];\n    }\n    else\n   \
    \ {\n        auto m = std.numeric.factors(n);\n        if (m[0] == n) return n;\n\
    \        auto c = m[0];\n        for (auto i : m)\n        {\n            if (c\
    \ < i)\n                c = i;\n        }\n        return c;\n    }\n}", "{\n\t\
    long i = 2L;\n\tfor (; !isPrime(n); i++) \n\t{\n\t\twhile (n % i == 0L) \n\t\t\
    {\n\t\t\tn /= i;\n\t\t}\n\t}\n\treturn n;\n}", "{\n    static bool is_prime(long\
    \ n) nothrow @nogc @safe \n    {\n        if (n <= 1) \n            return false;\n\
    \        else if (n <= 3) \n            return true;\n        else if (n % 2 ==\
    \ 0 || n % 3 == 0) \n            return false;\n        long i = 5;\n        while\
    \ (i * i <= n) \n        {\n            if (n % i == 0 || n % (i + 2) == 0) \n\
    \                return false;\n            i += 6;\n        }\n        return\
    \ true;\n    }\n    static long next_prime(long n) nothrow @nogc @safe \n    {\n\
    \        long i = n + 1;\n        while (!is_prime(i)) \n            i++;\n  \
    \      return i;\n    }\n    long p = 2;\n    while (n > 1) \n    {\n        if\
    \ (n % p == 0) \n            n /= p;\n        else \n            p = next_prime(p);\n\
    \    }\n    return p;\n}", "{\n  import core.stdc.stdlib : atol;\n  if (argc !=\
    \ 2)\n  {\n    return 1;\n  }\n  long n = atol(argv[1]);\n  if (n < 2L)\n  {\n\
    \    return 1;\n  }\n  long p;\n  foreach (p; 2L .. sqrt(n))\n  {\n    if (n %\
    \ p == 0L)\n    {\n      return largest_prime_factor(n / p);\n    }\n  }\n  return\
    \ n;\n}\n/*\nA palindromic number reads the same both ways. The largest palindrome\
    \ made from the product of two 2-digit numbers is 9009 = 91 x 99.\nFind the largest\
    \ palindrome made from the product of two 3-digit numbers.\n    >>> largest_palindrome(3)\n\
    \    906609\n*/\nlong largest_palindrome(int digits) \n{\n  enum upper = cast(long)pow(10L,\
    \ digits);\n  enum lower = upper / 10L;\n  long max_palindrome = 0L;\n  long x;\n\
    \  foreach (x; lower .. upper)\n  {\n    long y;\n    foreach (y; lower .. upper)\n\
    \    {\n      long n = x * y;\n      if (is_palindrome(n) && n > max_palindrome)\n\
    \      {\n        max_palindrome = n;\n      }\n    }\n  }\n  return max_palindrome;\n\
    }\n/*\n2520 is the smallest number that can be divided by each of the numbers\
    \ from 1 to 10 without any remainder.\nWhat is the smallest positive number that\
    \ is evenly divisible by all of the numbers from 1 to 20?\n    >>> smallest_evenly_divisible(1,\
    \ 20)\n    232792560\n*/\nlong smallest_evenly_divisible(long min, long max) \n\
    {\n  import std.algorithm : reduce;\n  long step = reduce!(lcm)(min .. max);\n\
    \  long i;\n  foreach (i; min .. max)\n  {\n    assert(step % i == 0L);\n  }\n\
    \  return step", "{\n\t/*\n\t * Note: There is no need to explicitly check for\
    \ any numbers beyond the \n\t * square root of n, because if a number is a factor\
    \ of n, then so will\n\t * be its pair (assuming n is not a perfect square). For\
    \ example, if we\n\t * have n = 15, then we can check to see if 3 is a factor\
    \ of 15. If it\n\t * is, then 5 must also be a factor of 15.\n\t */\n\tprimes\
    \ noprimes;\n\tlong largest_prime = noprimes.get_factor(n);\n\treturn largest_prime;\n\
    }", "in\n{\n\timmutable long start = 2L;\n\t\n\tif (n < start) return start;\n\
    \t\n\timmutable long max = n;\n\t\n\tfor (long i = start; i < max; i++)\n\t{\n\
    \t\tif (n % i == 0)\n\t\t{\n\t\t\tmax = n / i;\n\t\t\t\n\t\t\tif (is_prime(max))\n\
    \t\t\t{\n\t\t\t\treturn max;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0L;\n}\n/*\nReturn\
    \ true if n is prime.\n    >>> is_prime(2L)\n    True\n    >>> is_prime(4L)\n\
    \    False\n    >>> is_prime(7919L)\n    True\n*/", "{\n  long prime = -1L;\n\
    \  while ((n % 2L) == 0L) {\n    prime = 2L;\n    n /= 2L;\n  }\n  long f = 3L;\n\
    \  long max_factor = sqrt(n);\n  while (n > 1L && f <= max_factor) {\n    if ((n\
    \ % f) == 0L) {\n      prime = f;\n      n /= f;\n      while ((n % f) == 0L)\
    \ {\n        n /= f;\n      }\n      max_factor = sqrt(n);\n    }\n    f += 2L;\n\
    \  }\n  if (n == 1L) {\n    return prime;\n  } else {\n    return n;\n  }\n}\n\
    /*\nReturn the sum of all the primes below n.\n    >>> sum_primes_below(10)\n\
    \    17\n    >>> sum_primes_below(100)\n    1060\n    >>> sum_primes_below(1000)\n\
    \    76127\n*/\nlong sum_primes_below(long n) \n{\n  static immutable long m =\
    \ isPrime(1L);\n  long sum = 0L;\n  for (long i = 2L; i < n; i++) {\n    if (isPrime(i))\
    \ {\n      sum += i;\n    }\n  }\n  return sum;\n}\n/*\nReturns a tuple(p, n)\
    \ where p is a prime and p**n is the largest power of p\nthat divides n!.\n  \
    \  >>> prime_powers_below(5)\n    Tuple(2L, 4L)\n    >>> prime_powers_below(10)\n\
    \    Tuple(2L, 8L)\n    >>> prime_powers_below(11)\n    Tuple(11L, 1L)\n    >>>\
    \ prime_powers_below(20)\n    Tuple(2L, 18L)\n    >>> prime_powers_below(30)\n\
    \    Tuple(2L, 28L)\n    >>> prime_powers_below(100)\n    Tuple(2L, 96L)\n   \
    \ >>> prime_powers_below(1000)\n    Tuple(2L, 992L", "{\n  long m = n;\n  long\
    \ d = 1;\n  for (;;) {\n    d = lowest_prime_factor(m);\n    if (d == m)\n   \
    \   break;\n    m /= d;\n  }\n  return m;\n}", "in\n{\n    auto factors = prime_factors(n);\n\
    \    return *std.algorithm.max(factors.byKey!q{a > b});\n}", "{\n\t//if (isPrime(n))\n\
    \t//\treturn n;\n\tlong max_prime = 1;\n\tlong count = 2;\n\tlong tmp = n;\n\t\
    while (count <= tmp)\n\t{\n\t\tif (tmp % count == 0)\n\t\t{\n\t\t\t//if (isPrime(count))\n\
    \t\t\t//\tmax_prime = count;\n\t\t\ttmp /= count;\n\t\t}\n\t\telse\n\t\t\tcount++;\n\
    \t}\n\treturn max_prime;\n}", "    in(n > 1)\n    out(ret > 1)\n{\n    long p\
    \ = 2;\n    while (n % p != 0)\n        p++;\n    long factor = n / p;\n    if\
    \ (factor == 1)\n        return p;\n    return largest_prime_factor(factor);\n\
    }\n/*\nreturns the sum of the digits in a given number.\n    >>> sum_digits(12345L)\n\
    \    15L\n    >>> sum_digits(1L)\n    1L\n*/\nlong sum_digits(long n)\n    in(n\
    \ >= 0)\n    out(ret >= 0)\n{\n    if (n == 0)\n        return 0;\n    else\n\
    \        return n % 10 + sum_digits(n / 10);\n}\n/*\nreturns the sum of all digits\
    \ which are the same as the digit half way around the circular number.\n    >>>\
    \ captcha(1212L)\n    6L\n    >>> captcha(1221L)\n    0L\n    >>> captcha(123425L)\n\
    \    4L\n    >>> captcha(123123L)\n    12L\n    >>> captcha(12131415L)\n    4L\n\
    */\nlong captcha(long n)\n    in(n >= 0)\n    out(ret >= 0)\n{\n    long l = 10\
    \ * log(n, 10) / 2;\n    long l_half = 10 ^ l;\n    long r_half = n % l_half;\n\
    \    if (l_half > r_half)\n        return 0;\n    else if (l_half == r_half)\n\
    \        return l_half;\n    else\n        return l_half + captcha(r_half);\n\
    }\n/*\nAdd the numbers 0 to n, inclusively.\n    >>> sum_numbers(3)\n    6\n \
    \   >>> sum_numbers(100)\n    5050\n*/\nlong sum_numbers(long n)\n    in(n >=\
    \ 0)\n    out(ret >= 0)\n{\n    if (n == 0)\n        return 0;\n    else\n   \
    \     return n + sum_numbers(n - 1);\n}\n/*\nAdd the numbers 0 to n, inclusively"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
