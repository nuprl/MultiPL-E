name: HumanEval_59_largest_prime_factor
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn the largest prime factor\
  \ of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195L)\n\
  \    29L\n    >>> largest_prime_factor(2048L)\n    2L\n    \n*/\nlong largest_prime_factor(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = largest_prime_factor;\n\n    assert(candidate(15L)\
  \ == 5L);\n    assert(candidate(27L) == 3L);\n    assert(candidate(63L) == 7L);\n\
  \    assert(candidate(330L) == 11L);\n    assert(candidate(13195L) == 29L);\n}\n\
  void main(){}"
completions: ["{ \n  long i = 2L; \n  while (n != 1L) \n  { \n    if (n % i == 0L)\
    \ \n    { \n      n /= i; \n    } \n    else \n    { \n      i += 1L; \n    }\
    \ \n  } \n  return i; \n}\n/*\nReturn the smallest positive integer greater than\
    \ 2 which is not prime \nand is the sum of 2 primes.\n    >>> goldbach_odd()\n\
    \    5777\n*/\nuint goldbach_odd() \n{ \n  uint num = 9; \n  for (; ; num += 2)\
    \ \n  { \n    if (num % 2 == 0) \n    { \n      continue; \n    } \n    bool flag\
    \ = false; \n    foreach (i; iota(1u, num / 2 + 1)) \n    { \n      if (isPrime(i)\
    \ && isPrime(num - i)) \n    { \n      flag = true; \n      break; \n    } \n\
    \    } \n    if (!flag) \n    { \n      break; \n    } \n  } \n  return num; \n\
    }\n/*\nReturn the fibonacci number at n.\n    >>> fib(1)\n    1\n    >>> fib(10)\n\
    \    55\n    >>> fib(100)\n    354224848179261915075\n*/\nlong fib(int n) \n{\
    \ \n  if (n == 1) \n  { \n    return 1L; \n  } \n  else if (n == 2) \n  { \n \
    \   return 1L; \n  } \n  else \n  { \n    return fib(n - 1) + fib(n - 2); \n \
    \ } \n}\n/*\nReturn the index of the first fibonacci number with n digits.\n \
    \   >>> fib_index(3)\n    12\n    >>> fib_index(10)\n    45\n    >>> fib_index(20)\n\
    \    177\n*/", "{\n    long max = 0L;\n    long factor = 2L;\n    long quotient\
    \ = n;\n    bool prime = true;\n    while (quotient > 1L) \n    {\n        while\
    \ (quotient % factor == 0L) \n        {\n            prime = true;\n         \
    \   quotient /= factor;\n            foreach (i; iota(2L, factor)) \n        \
    \    {\n                if (factor % i == 0L) \n                {\n          \
    \          prime = false;\n                    break;\n                }\n   \
    \         }\n            if (prime) \n            {\n                max = factor;\n\
    \            }\n        }\n        factor += 1L;\n    }\n    return max;\n}",
  "{\n    long result = 2L;\n    long max = n;\n    long max_sqrt = std.math.sqrt(max);\n\
    \    for (long i = 3L; i <= max_sqrt; i = i + 2L) {\n        if (n % i == 0L)\
    \ {\n            n = n / i;\n            result = i;\n            max = n;\n \
    \           max_sqrt = std.math.sqrt(max);\n        }\n    }\n    if (n > result)\
    \ {\n        result = n;\n    }\n    return result;\n}\n/*\nCompute the sum of\
    \ the digits of n.\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(9)\n\
    \    9\n    >>> sum_digits(999999999999)\n    108\n*/", "{\n    foreach (i; prime_factors(n))\
    \ \n    {\n        if (i > n / i) \n        {\n            return i;\n       \
    \ }\n    }\n    return 1;\n}\n/*\nIn the next cell, write a function that takes\
    \ n as input and returns a tuple of three \nlongs: the smallest, second smallest,\
    \ and third smallest prime factors of n. Assume n > 1.\n    >>> prime_factors_3(13195L)\n\
    \    (5L, 7L, 13L)\n    >>> prime_factors_3(2048L)\n    (2L, 2L, 2L)\n*/\nTuple!(long,\
    \ long, long) prime_factors_3(long n)\n{\n    auto pf = prime_factors(n);\n  \
    \  return make_tuple(pf[0], pf[1], pf[2]);\n}", "{\n    long largest_factor =\
    \ 1L;\n    for (long i = 2L; i < n; i++)\n    {\n        if (n % i == 0L)\n  \
    \      {\n            if (is_prime(i))\n            {\n                largest_factor\
    \ = i;\n            }\n        }\n    }\n    return largest_factor;\n}", "{\n\
    \    long largest_prime_factor = 1L;\n    foreach (i; takeWhile(n % i, iota(2L,\
    \ n)))\n    {\n        largest_prime_factor = max(largest_prime_factor, i);\n\
    \    }\n    return largest_prime_factor;\n}", "{\n    long temp = 0;\n    long\
    \ i = 2;\n    while (i < n)\n    {\n        if (n % i == 0)\n        {\n     \
    \       temp = n / i;\n            break;\n        }\n        i++;\n    }\n  \
    \  if (temp == 0)\n        return n;\n    return largest_prime_factor(temp);\n\
    }", "{\n    import std.algorithm.searching : find;\n    import std.algorithm.iteration\
    \ : filter;\n    import std.range.primitives : iota;\n    import std.math : sqrt;\n\
    \    //divisors of n\n    auto divisors = iota(2L, (long)sqrt(n) + 1).filter!((i)\
    \ => n % i == 0);\n    //primes <= sqrt(n)\n    auto primes = iota(2L, sqrt(n)\
    \ + 1).filter!isPrime;\n    //find the largest prime divisor\n    auto it = divisors.find!((d)\
    \ => primes.canFind(d));\n    //return it\n    return it ? *it : n;\n}\n ", "{\n\
    \tint k = 1;\n\tbool b = true;\n\tlong a,b;\n\tforeach(long f; allPrimes(n))\n\
    \t{\n\t\tforeach(long p; allPrimes(f))\n\t\t{\n\t\t\tif(p > k)\n\t\t\t{\n\t\t\t\
    \tk = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn k;\n}", "{\n    static if (is(typeof(std.numeric.factors(n))\
    \ == Tuple!(long, long, ulong)))\n    {\n        auto m = std.numeric.factors(n);\n\
    \        if (m[0] == n) return n;\n        return m[0];\n    }\n    else\n   \
    \ {\n        auto m = std.numeric.factors(n);\n        if (m[0] == n) return n;\n\
    \        auto c = m[0];\n        for (auto i : m)\n        {\n            if (c\
    \ < i)\n                c = i;\n        }\n        return c;\n    }\n}", "{\n\t\
    long i = 2L;\n\tfor (; !isPrime(n); i++) \n\t{\n\t\twhile (n % i == 0L) \n\t\t\
    {\n\t\t\tn /= i;\n\t\t}\n\t}\n\treturn n;\n}", "{\n    static bool is_prime(long\
    \ n) nothrow @nogc @safe \n    {\n        if (n <= 1) \n            return false;\n\
    \        else if (n <= 3) \n            return true;\n        else if (n % 2 ==\
    \ 0 || n % 3 == 0) \n            return false;\n        long i = 5;\n        while\
    \ (i * i <= n) \n        {\n            if (n % i == 0 || n % (i + 2) == 0) \n\
    \                return false;\n            i += 6;\n        }\n        return\
    \ true;\n    }\n    static long next_prime(long n) nothrow @nogc @safe \n    {\n\
    \        long i = n + 1;\n        while (!is_prime(i)) \n            i++;\n  \
    \      return i;\n    }\n    long p = 2;\n    while (n > 1) \n    {\n        if\
    \ (n % p == 0) \n            n /= p;\n        else \n            p = next_prime(p);\n\
    \    }\n    return p;\n}", "{\n  import core.stdc.stdlib : atol;\n  if (argc !=\
    \ 2)\n  {\n    return 1;\n  }\n  long n = atol(argv[1]);\n  if (n < 2L)\n  {\n\
    \    return 1;\n  }\n  long p;\n  foreach (p; 2L .. sqrt(n))\n  {\n    if (n %\
    \ p == 0L)\n    {\n      return largest_prime_factor(n / p);\n    }\n  }\n  return\
    \ n;\n}\n/*\nA palindromic number reads the same both ways. The largest palindrome\
    \ made from the product of two 2-digit numbers is 9009 = 91 x 99.\nFind the largest\
    \ palindrome made from the product of two 3-digit numbers.\n    >>> largest_palindrome(3)\n\
    \    906609\n*/\nlong largest_palindrome(int digits) \n{\n  enum upper = cast(long)pow(10L,\
    \ digits);\n  enum lower = upper / 10L;\n  long max_palindrome = 0L;\n  long x;\n\
    \  foreach (x; lower .. upper)\n  {\n    long y;\n    foreach (y; lower .. upper)\n\
    \    {\n      long n = x * y;\n      if (is_palindrome(n) && n > max_palindrome)\n\
    \      {\n        max_palindrome = n;\n      }\n    }\n  }\n  return max_palindrome;\n\
    }\n/*\n2520 is the smallest number that can be divided by each of the numbers\
    \ from 1 to 10 without any remainder.\nWhat is the smallest positive number that\
    \ is evenly divisible by all of the numbers from 1 to 20?\n    >>> smallest_evenly_divisible(1,\
    \ 20)\n    232792560\n*/\nlong smallest_evenly_divisible(long min, long max) \n\
    {\n  import std.algorithm : reduce;\n  long step = reduce!(lcm)(min .. max);\n\
    \  long i;\n  foreach (i; min .. max)\n  {\n    assert(step % i == 0L);\n  }\n\
    \  return step", "{\n\t/*\n\t * Note: There is no need to explicitly check for\
    \ any numbers beyond the \n\t * square root of n, because if a number is a factor\
    \ of n, then so will\n\t * be its pair (assuming n is not a perfect square). For\
    \ example, if we\n\t * have n = 15, then we can check to see if 3 is a factor\
    \ of 15. If it\n\t * is, then 5 must also be a factor of 15.\n\t */\n\tprimes\
    \ noprimes;\n\tlong largest_prime = noprimes.get_factor(n);\n\treturn largest_prime;\n\
    }", "in\n{\n\timmutable long start = 2L;\n\t\n\tif (n < start) return start;\n\
    \t\n\timmutable long max = n;\n\t\n\tfor (long i = start; i < max; i++)\n\t{\n\
    \t\tif (n % i == 0)\n\t\t{\n\t\t\tmax = n / i;\n\t\t\t\n\t\t\tif (is_prime(max))\n\
    \t\t\t{\n\t\t\t\treturn max;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0L;\n}\n/*\nReturn\
    \ true if n is prime.\n    >>> is_prime(2L)\n    True\n    >>> is_prime(4L)\n\
    \    False\n    >>> is_prime(7919L)\n    True\n*/", "{\n  long prime = -1L;\n\
    \  while ((n % 2L) == 0L) {\n    prime = 2L;\n    n /= 2L;\n  }\n  long f = 3L;\n\
    \  long max_factor = sqrt(n);\n  while (n > 1L && f <= max_factor) {\n    if ((n\
    \ % f) == 0L) {\n      prime = f;\n      n /= f;\n      while ((n % f) == 0L)\
    \ {\n        n /= f;\n      }\n      max_factor = sqrt(n);\n    }\n    f += 2L;\n\
    \  }\n  if (n == 1L) {\n    return prime;\n  } else {\n    return n;\n  }\n}\n\
    /*\nReturn the sum of all the primes below n.\n    >>> sum_primes_below(10)\n\
    \    17\n    >>> sum_primes_below(100)\n    1060\n    >>> sum_primes_below(1000)\n\
    \    76127\n*/\nlong sum_primes_below(long n) \n{\n  static immutable long m =\
    \ isPrime(1L);\n  long sum = 0L;\n  for (long i = 2L; i < n; i++) {\n    if (isPrime(i))\
    \ {\n      sum += i;\n    }\n  }\n  return sum;\n}\n/*\nReturns a tuple(p, n)\
    \ where p is a prime and p**n is the largest power of p\nthat divides n!.\n  \
    \  >>> prime_powers_below(5)\n    Tuple(2L, 4L)\n    >>> prime_powers_below(10)\n\
    \    Tuple(2L, 8L)\n    >>> prime_powers_below(11)\n    Tuple(11L, 1L)\n    >>>\
    \ prime_powers_below(20)\n    Tuple(2L, 18L)\n    >>> prime_powers_below(30)\n\
    \    Tuple(2L, 28L)\n    >>> prime_powers_below(100)\n    Tuple(2L, 96L)\n   \
    \ >>> prime_powers_below(1000)\n    Tuple(2L, 992L", "{\n  long m = n;\n  long\
    \ d = 1;\n  for (;;) {\n    d = lowest_prime_factor(m);\n    if (d == m)\n   \
    \   break;\n    m /= d;\n  }\n  return m;\n}", "in\n{\n    auto factors = prime_factors(n);\n\
    \    return *std.algorithm.max(factors.byKey!q{a > b});\n}", "{\n\t//if (isPrime(n))\n\
    \t//\treturn n;\n\tlong max_prime = 1;\n\tlong count = 2;\n\tlong tmp = n;\n\t\
    while (count <= tmp)\n\t{\n\t\tif (tmp % count == 0)\n\t\t{\n\t\t\t//if (isPrime(count))\n\
    \t\t\t//\tmax_prime = count;\n\t\t\ttmp /= count;\n\t\t}\n\t\telse\n\t\t\tcount++;\n\
    \t}\n\treturn max_prime;\n}", "    in(n > 1)\n    out(ret > 1)\n{\n    long p\
    \ = 2;\n    while (n % p != 0)\n        p++;\n    long factor = n / p;\n    if\
    \ (factor == 1)\n        return p;\n    return largest_prime_factor(factor);\n\
    }\n/*\nreturns the sum of the digits in a given number.\n    >>> sum_digits(12345L)\n\
    \    15L\n    >>> sum_digits(1L)\n    1L\n*/\nlong sum_digits(long n)\n    in(n\
    \ >= 0)\n    out(ret >= 0)\n{\n    if (n == 0)\n        return 0;\n    else\n\
    \        return n % 10 + sum_digits(n / 10);\n}\n/*\nreturns the sum of all digits\
    \ which are the same as the digit half way around the circular number.\n    >>>\
    \ captcha(1212L)\n    6L\n    >>> captcha(1221L)\n    0L\n    >>> captcha(123425L)\n\
    \    4L\n    >>> captcha(123123L)\n    12L\n    >>> captcha(12131415L)\n    4L\n\
    */\nlong captcha(long n)\n    in(n >= 0)\n    out(ret >= 0)\n{\n    long l = 10\
    \ * log(n, 10) / 2;\n    long l_half = 10 ^ l;\n    long r_half = n % l_half;\n\
    \    if (l_half > r_half)\n        return 0;\n    else if (l_half == r_half)\n\
    \        return l_half;\n    else\n        return l_half + captcha(r_half);\n\
    }\n/*\nAdd the numbers 0 to n, inclusively.\n    >>> sum_numbers(3)\n    6\n \
    \   >>> sum_numbers(100)\n    5050\n*/\nlong sum_numbers(long n)\n    in(n >=\
    \ 0)\n    out(ret >= 0)\n{\n    if (n == 0)\n        return 0;\n    else\n   \
    \     return n + sum_numbers(n - 1);\n}\n/*\nAdd the numbers 0 to n, inclusively",
  "{\n    // Note the index begins at 2 (1 is not a prime)\n    long factor = 2L;\n\
    \    while (n > 1) {\n        // If the current value is a factor\n        if\
    \ (n % factor == 0) {\n            // Divide by the factor to reduce n\n     \
    \       n /= factor;\n        }\n        // Otherwise, move on to the next value\n\
    \        else {\n            // If we've reached the end, start at 2 again\n \
    \           if (factor == 2)\n                factor = 3;\n            // Otherwise,\
    \ go to the next odd number\n            else\n                factor += 2;\n\
    \        }\n    }\n    return factor;\n}\n \n/*\nReturn the largest palindrome\
    \ made from the product of two 3-digit numbers.\n    >>> largest_palindrome_product(3)\n\
    \    906609\n    \n*/\nlong largest_palindrome_product(int n)\n{\n    auto max\
    \ = (long)pow(10, n) - 1;\n    auto min = max / 10;\n    auto num1 = max;\n  \
    \  auto num2 = max;\n    auto max_product = 0L;\n    auto max_palindrome = 0L;\n\
    \    // Starting from the max, check all possible products\n    while (num1 >=\
    \ min) {\n        num2 = max;\n        while (num2 >= min) {\n            // Check\
    \ if the product is larger and a palindrome\n            if (num1 * num2 > max_product\
    \ && is_palindrome(num1 * num2)) {\n                max_product = num1 * num2;\n\
    \                max_palindrome = num1 * num2;\n            }\n            //\
    \ Decrement num2\n            num2--;\n        }\n        // Decrement num1\n\
    \        num1--;\n    }\n    return max_palindrome;\n}\n \n/*\nFind the smallest\
    \ positive number that is evenly divisible by all of the numbers from 1 to 20.\n\
    \    >>> smallest_multiple(1, 20)\n    232792560\n    \n*/\nlong smallest_multiple(int\
    \ min, int max)\n{\n    auto current = max;\n    // Keep looping until we find\
    \ the first evenly divisible number\n   ", "{ \n\tlong i = 2; \n\twhile (i * i\
    \ <= n) \n\t{ \n\t\tif (n % i == 0) \n\t\t\tn = n / i; \n\t\telse\n\t\t\ti++;\
    \ \n\t} \n\treturn n; \n}\n//[std.math.sqrt]\n//auto f(double d) { return sqrt(d);\
    \ }\n//void main() { f(0.0); }", "{\n    long i = 2L;\n    while (n > 1L) \n \
    \   {\n        if (n % i == 0L) \n        {\n            n /= i;\n        } \n\
    \        else \n        {\n            i += 1L;\n        }\n    }\n    return\
    \ i;\n}", "{\n    import std.math;\n    long p = 1;\n    for (long i = 2; i <=\
    \ n; i++)\n    {\n        if (isPrime(i) && n % i == 0)\n        {\n         \
    \   p = i;\n        }\n    }\n    return p;\n}\n// bool isPrime(long n) \n// {\n\
    //     if (n <= 1) return false;\n//     else if (n <= 3) return true;\n//   \
    \  else if (n % 2 == 0 || n % 3 == 0) return false;\n//     long i = 5;\n//  \
    \   while (i * i <= n) \n//     {\n//         if (n % i == 0 || n % (i + 2) ==\
    \ 0) return false;\n//         i = i + 6;\n//     }\n//     return true;\n// }\n\
    //bool isPrime(long n)\n//{\n//    long i;\n//    for (i = 2; i <= n/2; i++)\n\
    //    {\n//        if (n % i == 0)\n//        {\n//            return false;\n\
    //        }\n//    }\n//    return true;\n//}\n// ++int to_int(dchar[] s)\n//\
    \ {\n//     int result = 0;\n//     for (int i = 0; i < s.length; i++)\n//   \
    \  {\n//         result = result * 10 + (s[i] - '0');\n//     }\n//     return\
    \ result;\n// }\n//int main()\n//{\n//    dchar[] s = \"987654321\";\n//    int\
    \ i = to_int(s);\n//    printf(\"%d\\n\", i);\n//    return 0;\n//}\n \n//int\
    \ main()\n//{\n//    dchar[] s1 = \"abc\";\n//    dchar[] s2 = \"def\";\n//  \
    \  dchar[] s3 = s1 ~ s2;\n//    printf(\"%s\\n\", s3);\n//    return 0;\n//}",
  "{\n\tlong i = n;\n\twhile (true)\n\t{\n\t\tif (isPrime(i))\n\t\t{\n\t\t\treturn\
    \ i;\n\t\t}\n\t\t--i;\n\t}\n}", "{\n    int prime_factor = 1;\n    long factor\
    \ = 2;\n    int upper_limit = cast(int)floor(sqrt(n));\n    for (; factor <= upper_limit;\
    \ ++factor)\n    {\n        if (n % factor == 0)\n        {\n            prime_factor\
    \ = factor;\n            n /= factor;\n            upper_limit = cast(int)floor(sqrt(n));\n\
    \        }\n    }\n    return max(prime_factor, n);\n}", "{\n\tlong largest =\
    \ 1L;\n\twhile (n % 2L == 0L) \n\t{\n\t\tlargest = 2L;\n\t\tn /= 2L;\n\t}\n\t\n\
    \tfor (long p = 3L; p <= sqrt(n); p += 2L) \n\t{\n\t\twhile (n % p == 0L) \n\t\
    \t{\n\t\t\tlargest = p;\n\t\t\tn /= p;\n\t\t}\n\t}\n\t\n\tif (n > 2L) \n\t{\n\t\
    \tlargest = n;\n\t}\n\t\n\treturn largest;\n}", "{\n    long max_prime_factor\
    \ = 1L;\n    long largest_divisor = 0L;\n    for (long i = 2L; i <= n; i++) \n\
    \    {\n        if (n % i == 0L) \n        {\n            largest_divisor = i;\n\
    \            n /= i;\n            if (is_prime(largest_divisor)) \n          \
    \  {\n                max_prime_factor = max(max_prime_factor, largest_divisor);\n\
    \            }\n            i = 1L;\n        }\n    }\n    return max_prime_factor;\n\
    }", "    long prime = n, max_prime = n;\n    long limit = ceil(sqrt(n));\n   \
    \ foreach (i; iota(2L, limit))\n        if (prime %% i == 0)\n        {\n    \
    \        prime /= i;\n            max_prime = i;\n        }\n    return max_prime;\n\
    }\n/*\ncompute_sum(n) returns the sum of a-th powers of first n natural numbers.",
  "{\n    if(n <= 2) return 0;\n    long result = 0;\n    foreach(factor; primes(n))\
    \ \n    {\n        if(n % factor == 0) result = factor;\n    }\n    return result;\n\
    }", "{\n\tlong largest_factor = 1L;\n\tlong d = 2L;\n\twhile (d <= n) \n\t{\n\t\
    \t// Find a divisor d of n\n\t\tif (n % d == 0) \n\t\t{\n\t\t\t// Divide n by\
    \ d in as many times as possible\n\t\t\twhile (n % d == 0) \n\t\t\t{\n\t\t\t\t\
    n /= d;\n\t\t\t}\n\t\t\tlargest_factor = d;\n\t\t}\n\t\td += 1L;\n\t}\n\treturn\
    \ largest_factor;\n}", "{\n    long max_factor = 0L;\n    foreach(d; primes(n))\
    \ \n    {\n        if(n % d == 0) \n        {\n            max_factor = d;\n \
    \       }\n    }\n    return max_factor;\n}", "{\n    static if (n > 1) {\n  \
    \      enum is_prime = true;\n        foreach (i; 2 .. sqrt(n)) {\n          \
    \  if (n % i == 0)\n                is_prime = false;\n        }\n        static\
    \ if (is_prime) {\n            return n;\n        } else {\n            foreach\
    \ (i; 2 .. sqrt(n)) {\n                if (n % i == 0) {\n                   \
    \ long ret = largest_prime_factor(n / i);\n                    //std.stdio.writeln(ret);\n\
    \                    return ret;\n                }\n            }\n        }\n\
    \    }\n}", "{\n    return __foreach_upto_with_break(std.typecons.Tuple!(iota(2L,\
    \ n / 2L + 1L), n.to!int), n => n[1] != 0, (i, n) => {\n        int n_i = n[1];\n\
    \        if (n_i % i == 0) {\n            return (i, n_i / i);\n        }\n  \
    \      return n;\n    }).front.front;\n}", "{\n    immutable factors = [];\n \
    \   immutable check = cast(int)n;\n    foreach(x; iota(2, check / 2 + 1))\n  \
    \  {\n        while(n % x == 0)\n        {\n            n /= x;\n            factors\
    \ ~= x;\n        }\n    }\n    return max(factors);\n}", "{\n    import std.algorithm;\n\
    \    import std.range;\n    import std.typecons;\n    import std.math;\n    immutable\
    \ d = primes().takeWhile!(q => q <= n).filter!(q => n % q == 0).max;\n    return\
    \ d;\n}", "{\n  long i = 0L;\n  long factor = 0L;\n  long largest = 1L;\n  while\
    \ (i < n) \n  {\n    i++;\n    if (n % i == 0L) \n    {\n      if (is_prime(i))\
    \ \n      {\n        factor = i;\n        largest = factor;\n      }\n    }\n\
    \  }\n  return largest;\n}", "{\n    alias Mutable!(ulong) PM;\n    ulong i =\
    \ n;\n    foreach (i; i-- > 1) {\n        if (n % i == 0) {\n            PM p\
    \ = new PM(i);\n            foreach (p; j-- > 1) {\n                if (p % j\
    \ == 0) {\n                    n = p / j;\n                    continue;\n   \
    \             }\n            }\n        }\n    }\n    return n;\n}", "{\n    assert(n\
    \ > 1);\n    return largest_prime_factor_helper(n, 2L);\n}", "{\n    if (n ==\
    \ 1) return 1;\n    if (n < 4) return n;\n    if (n % 2 == 0) return largest_prime_factor(n\
    \ / 2);\n    if (n % 3 == 0) return largest_prime_factor(n / 3);\n    long s =\
    \ sqrt(n);\n    size_t i = 5;\n    while (i <= s) {\n        if (n % i == 0) return\
    \ largest_prime_factor(n / i);\n        if (n % (i + 2) == 0) return largest_prime_factor(n\
    \ / (i + 2));\n        i += 6;\n    }\n    return n;\n}\n/*\nReturn the largest\
    \ prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195L)\n\
    \    29L\n    >>> largest_prime_factor(2048L)\n    2L\n    \n*/\nlong largest_prime_factor2(long\
    \ n) \n{\n    if (n == 1) return 1;\n    if (n < 4) return n;\n    if (n % 2 ==\
    \ 0) return largest_prime_factor(n / 2);\n    if (n % 3 == 0) return largest_prime_factor(n\
    \ / 3);\n    long s = sqrt(n);\n    size_t i = 5;\n    while (i <= s) {\n    \
    \    if (n % i == 0) return largest_prime_factor(n / i);\n        if (n % (i +\
    \ 2) == 0) return largest_prime_factor(n / (i + 2));\n        i += 6;\n    }\n\
    \    return n;\n}", "{\n    assert(n > 1);\n    bool is_prime(long n) \n    {\n\
    \        foreach (i; 2 .. sqrt(n) + 1) \n        {\n            if (n % i == 0)\
    \ \n            {\n                return false;\n            }\n        }\n \
    \       return true;\n    }\n    for (long i = long(sqrt(n)); i > 1; i--) \n \
    \   {\n        if (n % i == 0 && is_prime(i)) \n        {\n            return\
    \ i;\n        }\n    }\n    throw new Exception(\"n is a prime!\");\n}", "{\n\
    \    long factor = 2L;\n    long largest_factor = 1L;\n    while (n != 1L) {\n\
    \        while (n % factor == 0L) {\n            largest_factor = factor;\n  \
    \          n /= factor;\n        }\n        factor += 1L;\n    }\n    return largest_factor;\n\
    }", "{\n  // test if even\n  if (n%2 == 0)\n    n = n/2;\n  else\n    n = 3*n\
    \ + 1;\n  return n;\n}\n/*", "{\n    long factor = 2L;\n    long max_factor =\
    \ sqrt(n);\n    while (n > 1 && factor <= max_factor) {\n        if (n % factor\
    \ == 0) {\n            n /= factor;\n            max_factor = sqrt(n);\n     \
    \   } else {\n            factor++;\n        }\n    }\n    return n;\n}\n \n \n\
    /*\nthis is an alternative version using only whole numbers, no sqrt() or divisions.\n\
    */\nlong largest_prime_factor(long n) \n{\n    int factor = 2;\n    long max_factor\
    \ = n;\n    int divisor = 0;\n    while (n > 1 && factor <= max_factor) {\n  \
    \      if (n % factor == 0) {\n            n /= factor;\n            max_factor\
    \ = n;\n            divisor = factor;\n        } else {\n            factor++;\n\
    \        }\n    }\n    return divisor;\n}\n \n/*\nusing only whole numbers, no\
    \ sqrt() or divisions.\nand return an array of the factors.\n*/\nlong[] prime_factors(long\
    \ n) \n{\n    int factor = 2;\n    long max_factor = n;\n    int[] divisors =\
    \ [];\n    while (n > 1 && factor <= max_factor) {\n        if (n % factor ==\
    \ 0) {\n            n /= factor;\n            max_factor = n;\n            divisors\
    \ ~= factor;\n        } else {\n            factor++;\n        }\n    }\n    return\
    \ divisors;\n}\n \n/*\nReturn the largest prime factor of n. Assume n > 1 and\
    \ is not a prime.\n    >>> largest_prime_factor(13195L)\n    29L\n    >>> largest_prime_factor(2048L)\n\
    \    2L\n    >>> largest_prime_factor(600851475143L)\n    6857L\n*/\n \n \n/*\n\
    Return a list of primes using the Sieve of Eratosthenes.\n    >>> eratosthenes(10)\n\
    \    [2, 3, 5, 7]\n    >>> eratosthenes(35)\n    [2, 3,", "{\n    alias E = Enum!(Tuple!(bool,long));\n\
    \    E range = zip(repeat(true), iota(2L, cast(long) round(sqrt(n)) + 1L));\n\
    \    foreach(i; filter!(a => a[0])(range)) {\n        if(n % i[1] == 0) {\n  \
    \          E range2 = zip(repeat(true), iota(i[1] * i[1], cast(long) n, i[1]));\n\
    \            foreach(j; filter!(a => a[0])(range2)) {\n                foreach(k;\
    \ zip(repeat(false), j[1 .. $])) {\n                    range[k[1]][0] = false;\n\
    \                }\n            }\n        }\n    }\n    return max(filter!(a\
    \ => a[0])(range))[1];\n}\n/*\nReturn a list of the factors of n in ascending\
    \ order.\n    >>> factors(2048L)\n    [2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L]\n\
    \    >>> factors(2310L)\n    [2L, 3L, 5L, 7L, 11L]\n*/\nlong[] factors(long n)\
    \ \n{\n    long[] ret;\n    for(long i = 2L; i < n; i++) {\n        if(n % i ==\
    \ 0) {\n            ret ~= i;\n            ret ~= factors(n / i);\n          \
    \  break;\n        }\n    }\n    return ret;\n}", "{ \n    long max = 0L; \n \
    \   long d = 2L; \n    while (n > 1L) \n    { \n        while (n % d == 0L) \n\
    \        { \n            max = d; \n            n /= d; \n        } \n       \
    \ d += (d == 2L) ? 1L : 2L; \n    } \n    return max; \n} ", "{\n    auto p =\
    \ new PrimeGenerator;\n    // A range that retrieves the next prime number when\
    \ iterated over\n    auto primeRange = take(drop(p.take(n)), 1);\n    // Seed\
    \ the maximum prime factor\n    auto maxPrimeFactor = 1L;\n    foreach (p; primeRange)\
    \ {\n        while (n % p == 0) {\n            maxPrimeFactor = max(maxPrimeFactor,\
    \ p);\n            n /= p;\n        }\n    }\n    return maxPrimeFactor;\n}",
  "{\n    import std.bitmanip : bsf;\n    enum smallPrimes = [2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    foreach (p; smallPrimes) {\n        if (n % p == 0)\n            return p;\n\
    \    }\n    foreach (p; iota(smallPrimes.back + 2, n)) {\n        if (n % p ==\
    \ 0)\n            return p;\n    }\n    return n;\n}", "{\n    auto divisors =\
    \ divisors_of(n);\n    return divisors[$-1];\n}", "in {\n    assert(n > 1);\n\
    \    assert(!is_prime(n));\n}\nout (result) {\n    assert(result >= 1);\n    assert(is_prime(result));\n\
    \    assert(result <= n);\n}\nbody {\n    static assert(n <= ulong.max);\n   \
    \ alias uint nt = typeof(n)(n);\n    foreach (i; 2 .. sqrt(nt) + 1) {\n      \
    \  if (n % i == 0) {\n            if (is_prime(n / i)) {\n                return\
    \ n / i;\n            } else {\n                return largest_prime_factor(n\
    \ / i);\n            }\n        }\n    }\n    return 1;\n}", "{\n    long largest_factor\
    \ = 1L;\n    foreach (prime; take(primes(), 15)) \n    {\n        if (n % prime\
    \ == 0) \n        {\n            n /= prime;\n            largest_factor = prime;\n\
    \        }\n    }\n    return largest_factor;\n}", "{\n    long best=0L;\n   \
    \ for (long i=2L; i<=n; ++i) \n    {\n        if (n%i==0) \n        {\n      \
    \      if (isPrime(i)) \n            {\n                best=i;\n            }\n\
    \            n/=i;\n            i=1L;\n        }\n    }\n    return best;\n}\n\
    /*\nReturn the number of occurrences of \"digit\" in \"number\".\n    >>> digit_occurrences(12234444444444444444,\
    \ 4)\n    9\n    >>> digit_occurrences(12234444444444444444, 8)\n    0\n*/\nlong\
    \ digit_occurrences(long number, long digit) \n{\n    long n=0L;\n    long p=number;\n\
    \    long d=digit;\n    while (p) \n    {\n        if (p%10L==d) \n        {\n\
    \            n+=1L;\n        }\n        p/=10L;\n    }\n    return n;\n}\n/*\n\
    Return a tuple (r, a, b) where r is a positive integer, and a and b are positive",
  "{\n    static assert(n > 1L);\n    static assert(!isPrime(n));\n    static if (is(typeof(primes(n)[0])))\n\
    \    {\n        return primes(n)[$-1];\n    }\n    else\n    {\n        return\
    \ 0L;\n    }\n}", "{\n    static struct Primes {\n        long[] sieve;\n    \
    \    Primes(size_t max) {\n            this.sieve = new long[max+1];\n       \
    \     foreach (i; 0..max+1) {\n                this.sieve[i] = 1;\n          \
    \  }\n            this.sieve[0] = 0;\n            this.sieve[1] = 0;\n       \
    \     foreach (i; 2..max) {\n                if (this.sieve[i] == 1) {\n     \
    \               foreach (j; i..max) {\n                        if (j % i == 0)\
    \ {\n                            this.sieve[j] = 0;\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   p = Primes(long.max);\n    auto factors = new long[];\n    foreach (i; 2..n+1)\
    \ {\n        if (p.sieve[i] == 1) {\n            if (n % i == 0) {\n         \
    \       factors ~= i;\n            }\n        }\n    }\n    return factors[$-1];\n\
    }", "{\n    long largest = 1L;\n    while (n % 2L == 0L) \n    {\n        largest\
    \ = 2L;\n        n = n / 2L;\n    }\n    long current = 3L;\n    while (n > 1L)\
    \ \n    {\n        while (n % current == 0L) \n        {\n            largest\
    \ = current;\n            n = n / current;\n        }\n        current += 2L;\n\
    \    }\n    return largest;\n}", "{\n    static assert(n > 1);\n    long factor\
    \ = 2;\n    while (factor < n) {\n        if (n % factor == 0) {\n           \
    \ n /= factor;\n        } else {\n            factor++;\n        }\n    }\n  \
    \  return factor;\n}\n/*\nReturn true if n is a palindrome in base b.\n    >>>\
    \ is_palindrome(42, 10)\n    True\n    >>> is_palindrome(101, 2)\n    True\n \
    \   >>> is_palindrome(12, 3)\n    False\n    >>> is_palindrome(12321, 10)\n  \
    \  True\n    >>> is_palindrome(4252522, 10)\n    False\n*/\n@safe pure bool is_palindrome(long\
    \ n, long b = 10) \n{\n    if (n < 0) {\n        return false;\n    }\n    static\
    \ assert(b > 1);\n    long reverse = 0;\n    while (n != 0) {\n        reverse\
    \ = reverse * b + n % b;\n        n /= b;\n    }\n    return reverse == n;\n}\n\
    /*\nReturn a list of all the perfect numbers less than or equal to n.\n    >>>\
    \ perfect_numbers(10)\n    [6]\n    >>> perfect_numbers(100)\n    [6, 28]\n  \
    \  >>> perfect_numbers(1000)\n    [6, 28, 496]\n*/", "{ \n    if (n % 2 == 0)\
    \ { \n        return max(2L, largest_prime_factor(n / 2)); \n    } \n    for (long\
    \ i = 3; i <= sqrt(n); i += 2) { \n        if (n % i == 0) { \n            return\
    \ max(i, largest_prime_factor(n / i)); \n        } \n    } \n    return n; \n\
    }\n \n/*\nReturn a tuple containing the number of prime numbers, unique prime\
    \ \nfactors and the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    \    >>> num_prime_factors(13195L)\n    (0, [], 0L)\n    >>> num_prime_factors(2048L)\n\
    \    (1, [2L], 2L)\n    >>> num_prime_factors(6L)\n    (2, [2L, 3L], 3L)\n   \
    \ >>> num_prime_factors(196L)\n    (2, [2L, 7L], 7L)\n    >>> num_prime_factors(1L)\n\
    \    (0, [], 0L)\n*/\nTuple!(long, ulong[], long) num_prime_factors(long n) \n\
    { \n    if (n % 2 == 0) { \n        auto t = num_prime_factors(n / 2); \n    \
    \    return tuple(t[0] + 1, [2L] ~ t[1], max(2L, t[2])); \n    } \n    for (long\
    \ i = 3; i <= sqrt(n); i += 2) { \n        if (n % i == 0) { \n            auto\
    \ t = num_prime_factors(n / i); \n            return tuple(t[0] + 1, [i] ~ t[1],\
    \ max(i, t[2])); \n        } \n    } \n    return tuple(0, [], 0L); \n}\n \n//\
    \ Number of distinct prime factors for a given upper limit", "in { \n    assert(n\
    \ > 1);\n    assert(!is_prime(n));\n}\nout (long result) {\n    assert(is_prime(result));\n\
    \    assert(result <= n);\n    assert(n % result == 0);\n}\n{\n    long[] factors\
    \ = prime_factors(n);\n    long result = factors[$-1];\n    return result;\n}",
  "{\n    static if (is(typeof(std.math.factor(n)) == Tuple!(ulong, ulong[])))\n \
    \   {\n        ulong[] x = factor(n);\n        return x[$-1];\n    }\n    else\n\
    \    {\n        return std.math.factor(n).back;\n    }\n}\n \n/*\nReturn the largest\
    \ palindrome that is a product of two 3-digit numbers.\n    >>> largest_palindrome_product()\n\
    \    906609\n*/", "{\n    // Note we only care about factors of n, so start with\
    \ the\n    // smallest prime factor, 2, and stop at n.\n    foreach (i; 2..n+1)\
    \ \n    {\n        if (n % i == 0) \n        {\n            // i is a factor of\
    \ n. See if n/i is also a factor of n.\n            if (n % (n/i) == 0) \n   \
    \         {\n                // It is. Then i and n/i are both factors of n, so\n\
    \                // n is not prime.\n                return largest_prime_factor(n/i);\n\
    \            } \n            else \n            {\n                // n/i is not\
    \ a factor of n, so i is. Since i is prime,\n                // that makes it\
    \ the largest prime factor of n.\n                return i;\n            }\n \
    \       }\n    }\n    // Won't reach here because n must be divisible by 2.\n\
    \    assert(false);\n}", "{\n    import std.range;\n    import std.algorithm;\n\
    \    import std.math;\n    import std.typecons;\n    // import std.conv;", "{\n\
    \    long result = 0L;\n    long k = 0L;\n    const long l = sqrt(n);\n    for\
    \ (k = 2L; k <= l; k++) \n    {\n        if (n % k == 0L) \n        {\n      \
    \      const bool p = is_prime(k);\n            if (p) \n            {\n     \
    \           result = k;\n            }\n        }\n    }\n    return result;\n\
    }\nstatic bool is_prime(long x) \n{\n    if (x < 2L) \n    {\n        return false;\n\
    \    }\n    else if (x == 2L) \n    {\n        return true;\n    }\n    long k\
    \ = 0L;\n    const long l = sqrt(x);\n    for (k = 2L; k <= l; k++) \n    {\n\
    \        if (x % k == 0L) \n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}", "{\n    long largest = 0L;\n    foreach(i; iota(2L,\
    \ n/2L))\n    {\n        if(n % i == 0L)\n        {\n            largest = max(largest,\
    \ largest_prime_factor(i));\n        }\n    }\n    return n == 1L ? largest :\
    \ n;\n}\n/*\n    Return a list of prime numbers less than n.\n    >>> primes(10L)\n\
    \    [2L, 3L, 5L, 7L]\n*/\nlong[] primes(long n)\n{\n    return filter!(a => a)(map!(m\
    \ => largest_prime_factor(m))(iota(2L, n)));\n}\n/*\nReturn a list of pairs (base,\
    \ exponent) such that the prime factorization of n is the product of [base**exponent\
    \ for (base, exponent) in factorization(n)].\n    >>> factorization(10L)\n   \
    \ [(2L, 1L), (5L, 1L)]\n    >>> factorization(11L)\n    [(11L, 1L)]\n    >>> factorization(13195L)\n\
    \    [(5L, 1L), (7L, 1L), (13L, 1L), (29L, 1L)]\n*/\nTuple!(long, long)[] factorization(long\
    \ n)\n{\n    return map!(p => tuple(p, 1L))(primes(n)).filter!(a => a.length!(0)\
    \ > 0);\n}\n/*", "{\n\tlong b = 0L;\n\tlong c = 0L;\n\twhile(n%2L == 0L)\n\t{\n\
    \t\tn = n/2L;\n\t}\n\tfor(long i = 3L; i <= sqrt(n); i+=2L)\n\t{\n\t\twhile(n%i\
    \ == 0L)\n\t\t{\n\t\t\tn = n/i;\n\t\t\tb = i;\n\t\t}\n\t}\n\tif(n > 2L)\n\t{\n\
    \t\tc = n;\n\t}\n\telse\n\t{\n\t\tc = b;\n\t}\n\treturn c;\n}\n/*\nReturn whether\
    \ n is a prime number.\n    >>> is_prime(7L)\n    True\n    >>> is_prime(2048L)\n\
    \    False\n*/", "{\n    import std.algorithm, std.range, std.stdio;\n    import\
    \ std.math;\n    import std.typecons;\n    foreach (l; primesUpTo(isqrt(n)))\n\
    \    {\n        if(n % l == 0)\n        {\n            n /= l;\n        }\n  \
    \  }\n    return n;\n}", "{\n    assert(n > 1L);\n    assert(is_prime(n) == false);\n\
    \    long max_factor = 1L;\n    while (n % 2L == 0L) {\n        max_factor = 2L;\n\
    \        n /= 2L;\n    }\n    long next_max_factor = 3L;\n    while (n != 1L)\
    \ {\n        while (n % next_max_factor == 0L) {\n            max_factor = next_max_factor;\n\
    \            n /= next_max_factor;\n        }\n        next_max_factor += 2L;\n\
    \    }\n    return max_factor;\n}", "{\n    auto fs = factorization(n);\n    return\
    \ fs[$-1][0];\n}", "{\n    return 0;\n}", "{\n    long p = smallest_prime_factor(n);\n\
    \    while(true)\n    {\n        long k = n / p;\n        if(is_prime(k))\n  \
    \          return k;\n        else\n            p = smallest_prime_factor(k);\n\
    \    }\n}", "{\n    import std.range, std.algorithm;\n    struct Sieve\n    {\n\
    \        size_t i;\n        size_t j;\n        Tuple!(Sieve[], size_t) _make(size_t\
    \ size) \n        {\n            //assert(size >= 2);\n            auto primes\
    \ = tuple(Sieve[0, size], 0);\n            auto& inner = primes[0];\n        \
    \    size_t i = 0;\n            while (i < size) \n            {\n           \
    \     inner[i].i = i;\n                inner[i].j = 0;\n                ++i;\n\
    \            }\n            inner[0].j = 1;\n            inner[1].j = 1;\n   \
    \         i = 2;\n            while (i < size) \n            {\n             \
    \   if (inner[i].j == 0) \n                {\n                    size_t j = 2\
    \ * i;\n                    while (j < size) \n                    {\n       \
    \                 inner[j].j = 1;\n                        j += i;\n         \
    \           }\n                    primes[1]++;\n                }\n         \
    \       ++i;\n            }\n            return primes;\n        }\n        Sieve[]\
    \ _expand(size_t size) \n        {\n            auto primes = _make(size);\n \
    \           auto& inner = primes[0];\n            size_t i = 0;\n            while\
    \ (i < size) \n            {\n                if (inner[i].j == 0) \n        \
    \        {\n                    auto j = i + i;\n                    while (j\
    \ < size) \n                    {\n                        inner[j].j = 1;\n \
    \                       j += i;\n                    }\n                }\n  \
    \              ++i;\n            }\n            return inner;\n        }\n   \
    \     bool empty() @property \n        {\n            return false;\n        }\n\
    \        Sieve front() @property \n        {\n            return this;\n     \
    \   }\n        void popFront() \n        {\n            i += 2;\n        }\n \
    \       void save(void delegate(void*) dg) \n        {\n            dg(&i);\n\
    \        }\n        bool opEquals(Sieve other) \n        {\n            return\
    \ this", "{\n    long largest_factor = 0L;\n    long number = n;\n    while (number\
    \ % 2L == 0L) \n    {\n        largest_factor = 2L;\n        number /= 2L;\n \
    \   }\n    long factor = 3L;\n    while (number > 1L) \n    {\n        if (number\
    \ % factor == 0L) \n        {\n            largest_factor = factor;\n        \
    \    number /= factor;\n        }\n        else \n        {\n            factor\
    \ += 2L;\n        }\n    }\n    return largest_factor;\n}", "    pure \n{\n  \
    \  assert(n > 1);\n    long largest_factor = 2;\n    long remaining = n;\n   \
    \ while (remaining > 1) {\n        if (remaining % largest_factor == 0) {\n  \
    \          remaining /= largest_factor;\n        } else {\n            largest_factor\
    \ += 1;\n        }\n    }\n    return largest_factor;\n}", "{\n\tlong d = 3L;\n\
    \tlong result = 0L;\n\tfor (; n % 2L == 0L; n /= 2L);\n\twhile (n > 1L) \n\t{\n\
    \t\tfor (; n % d == 0L; n /= d);\n\t\tresult = d;\n\t\td += 2L;\n\t}\n\treturn\
    \ result;\n}", "{\n    long current_value = n;\n    long largest_prime_factor\
    \ = 0;\n    foreach(i; 2 .. (long)sqrt(n)) \n    {\n        while(current_value\
    \ % i == 0) \n        {\n            current_value /= i;\n            largest_prime_factor\
    \ = i;\n        }\n    }\n    return current_value > largest_prime_factor ? current_value\
    \ : largest_prime_factor;\n}", "{\n    auto divisors = factor(n);\n    return\
    \ divisors[$-1];\n}", "{\n    // The first step is to remove any factors of 2.\n\
    \    if(n % 2 == 0)\n    {\n        while(n % 2 == 0)\n        {\n           \
    \ n /= 2;\n        }\n    }\n    // \n    long m = n;\n    long largest = 0;\n\
    \    while(m != 1)\n    {\n        long i = 3;\n        while(m % i != 0)\n  \
    \      {\n            i += 2;\n        }\n        m /= i;\n        largest = i;\n\
    \    }\n    return largest;\n}", "{ \n    long largest_factor = 1L; \n    for\
    \ (long p = 2L; p <= n; ++p) \n    { \n        if (is_prime(p) && n % p == 0)\
    \ \n        { \n            largest_factor = p; \n            n /= p; \n     \
    \   } \n    } \n    return largest_factor; \n}", "{\n    /*\n    by the fundamental\
    \ theorem of arithmetic, every integer greater than 1 \n    either is a prime\
    \ number itself or is the product of prime numbers. \n    So, the factorization\
    \ of a number n > 1 is n = p1^e1*p2^e2*p3^e3*...*pk^ek.\n    This means n should\
    \ be divisible by some prime number p1,p2,...pk. \n    It is not difficult to\
    \ see that the maximum of these p1,p2,...pk is its largest prime factor.\n   \
    \ */\n    // factors is the list of prime factors of n.\n    auto factors = new\
    \ long[];\n    long d = 2;\n    while (d*d <= n) \n    {\n        if (n % d ==\
    \ 0) \n        {\n            factors ~= d;\n            n /= d;\n        } \n\
    \        else \n        {\n            d += 1;\n        }\n    }\n    if (n >\
    \ 1)\n    {\n        factors ~= n;\n    }\n    // sort the list of factors to\
    \ get largest factor at first index.\n    factors.sort();\n    return factors[$-1];\n\
    }", "    long maxFactor = cast(long)floor(sqrt(n));\n    while (n % 2 == 0) \n\
    \        n /= 2;\n    for (long k = 3; k <= maxFactor; k += 2) \n        while\
    \ (n % k == 0) \n            n /= k;\n    if (n > 2) \n        return n;\n   \
    \ else \n        return maxFactor;", "{\n    //n= abs(n);\n    import std.math;\n\
    \    import std.typecons;\n    //n= abs(n);\n    foreach(i; 2..divisor(n)) {\n\
    \        if(n % i == 0) {\n            return largest_prime_factor(n/i);\n   \
    \     }\n    }\n    return n;\n}\n ", "{\n    assert(n > 1);\n    return recurse_lpf(n,\
    \ 2L);\n}", "{\n    long divisor = 2L;\n    while (n > 1L) \n    {\n        if\
    \ (n % divisor == 0L) \n        {\n            while (n % divisor == 0L) \n  \
    \          {\n                n /= divisor;\n            }\n            return\
    \ n;\n        }\n        divisor++;\n    }\n    return n;\n}", "{\n\tlong largest_prime_factor\
    \ = 1L;\n\tlong factor = 2L;\n\twhile (n > 1) \n\t{\n\t\twhile (n % factor ==\
    \ 0) \n\t\t{\n\t\t\tlargest_prime_factor = factor;\n\t\t\tn /= factor;\n\t\t}\n\
    \t\tfactor += 1L;\n\t}\n\treturn largest_prime_factor;\n}\nlong factorial(long\
    \ n) \n{\n\tlong factorial = 1L;\n\tfor (long i = 1L; i <= n; i++) \n\t{\n\t\t\
    factorial *= i;\n\t}\n\treturn factorial;\n}\n/*\nA palindromic number reads the\
    \ same both ways. The largest palindrome made\nfrom the product of two 2-digit\
    \ numbers is 9009 = 91 \xD7 99.\n    >>> find_palindrome(10, 100)\n    9009\n\
    \    \n*/\nlong find_palindrome(long from, long to) \n{\n\tlong max_palindrome\
    \ = 0L;\n\tlong product = 0L;\n\tfor (long i = from; i <= to; i++) \n\t{\n\t\t\
    for (long j = from; j <= to; j++) \n\t\t{\n\t\t\tproduct = i * j;\n\t\t\tauto\
    \ digits = `int(n)`(product).to!(immutable(char)[]);\n\t\t\tif (digits == digits.reverse)\
    \ \n\t\t\t{\n\t\t\t\tmax_palindrome = max(max_palindrome, product);\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn max_palindrome;\n}\n/*\nReturns the nth prime number.\n \
    \   >>> nth_prime(10)\n    29\n    \n*/\nlong nth_prime(long n) \n{\n\tlong nth_prime\
    \ = 0L;\n\tlong factor = 2L;\n\tlong i = 0L;\n\twhile (i < n) \n\t{\n\t\tbool\
    \ is_prime = true;\n\t\tfor (long j = 2L; j < factor; j++) \n\t\t{\n\t\t\tif (factor\
    \ %", "{\n\tstatic struct Sieve {\n\t\tlong[] primes;\n\t\tSieve() {\n\t\t\tprimes\
    \ = [2L];\n\t\t\tfor (long i = 3L; i < 200000L; i += 2L) {\n\t\t\t\tprimes ~=\
    \ i;\n\t\t\t}\n\t\t\tforeach (i; primes) {\n\t\t\t\tprimes = primes.filter!(j\
    \ => (j % i != 0) || (j == i));\n\t\t\t}\n\t\t}\n\t}\n\tstatic Sieve sieve = Sieve();\n\
    \tforeach (prime; sieve.primes) {\n\t\tif (n % prime == 0) {\n\t\t\tif (n == prime)\
    \ {\n\t\t\t\treturn prime;\n\t\t\t}\n\t\t\treturn largest_prime_factor(n / prime);\n\
    \t\t}\n\t}\n\tassert(false);\n}", "{\n\tlong largest = 2L;\n\tfor (long i = 3L;\
    \ i <= cast(long)sqrt(n); i += 2L) \n\t{\n\t\tif (n % i == 0L) \n\t\t{\n\t\t\t\
    n /= i;\n\t\t\tlargest = i;\n\t\t}\n\t}\n\tif (n > 2L) \n\t{\n\t\tlargest = n;\n\
    \t}\n\treturn largest;\n}\nstatic assert(largest_prime_factor(13195L) == 29L);\n\
    static assert(largest_prime_factor(2048L) == 2L);", "{\n    int i;\n    long num\
    \ = n;\n    for (i = 2; i <= n / i; i++) \n    {\n        while (n % i == 0) \n\
    \        {\n            n /= i;\n        }\n    }\n    return n;\n}\n/*\nReturn\
    \ the largest palindrome that is the product of two 3-digit numbers.\n    >>>\
    \ largest_palindrome(2)\n    9009\n    >>> largest_palindrome(3)\n    906609\n\
    */\nlong largest_palindrome(int digits) \n{\n    long min = 10 ** (digits - 1);\n\
    \    long max = 10 ** digits - 1;\n    long palindrome = 0;\n    long i, j;\n\
    \    for (i = max; i >= min; i--) \n    {\n        for (j = i; j >= min; j--)\
    \ \n        {\n            palindrome = i * j;\n            if (palindrome < max\
    \ * min) \n            {\n                break;\n            }\n            if\
    \ (is_palindrome(palindrome)) \n            {\n                return palindrome;\n\
    \            }\n        }\n    }\n    return palindrome;\n}\n/*\nReturn the difference\
    \ between the sum of the squares of the first n natural numbers and the square\
    \ of the sum.\n    >>> difference_sum_squares(10)\n    2640\n    >>> difference_sum_squares(100)\n\
    \    25164150\n*/\nlong difference_sum_squares(long n) \n{\n    return square_of_sum(n)\
    \ - sum_of_squares(n);\n}\n/*\nGiven an array of 4 digits, return the largest\
    \ 24 hour time that can be made.\nThe smallest 24 hour time is 00:00, and the\
    \ largest is 23:59.  Starting from 00:00, a time is larger if more time has elapsed\
    \ since midnight.\nReturn the answer as a string of length 5.  If no valid time\
    \ can be made, return an empty string.\n    >>> largest_time_from_digits(1, 2,\
    \ 3, 4)\n    '23:41'\n    >>> largest_time_from_digits(5", "{\n    long i = n;\n\
    \    for (; i >= 2; i--) \n    {\n        if (is_prime(i) && n % i == 0) \n  \
    \      {\n            return i;\n        }\n    }\n    return 1;\n}\n/*\nReturn\
    \ True if and only if n is prime.\n    >>> is_prime(2L)\n    True\n    >>> is_prime(3L)\n\
    \    True\n    >>> is_prime(4L)\n    False\n    >>> is_prime(19L)\n    True\n\
    \    >>> is_prime(20L)\n    False\n*/", "{\n\tlong max;\n\tmax = 0;\n\tlong i\
    \ = 1;\n\tforeach(prime;iota(2, int(sqrt(n) + 1)))\n\t{\n\t\tif(n % prime == 0)\n\
    \t\t{\n\t\t\tmax = prime;\n\t\t\tn = n/prime;\n\t\t}\n\t}\n\treturn max;\n}",
  "{\n\t\t//return largest_prime_factor_imperative(n);\n\t\treturn largest_prime_factor_recursive(n);\n\
    }", "{\n    long best = 0L;\n    foreach (p; primes(n)) {\n        if (n % p ==\
    \ 0) {\n            best = p;\n        }\n    }\n    return best;\n}", "{\n  \
    \  import std.math : ln, sqrt;\n    import std.array : array;\n    import std.typecons\
    \ : Tuple;\n    import std.algorithm : reduce;\n    import std.conv : to;\n  \
    \  import std.range : take;\n    import std.stdio : writeln;\n    // smallest\
    \ prime factor of every number\n    auto spf = [n]() mutable {\n        auto arr\
    \ = new long[n + 1];\n        foreach (ref i; arr)\n            i = 0;\n     \
    \   foreach (i; 2..n) {\n            if (arr[i] == 0)\n                arr[i]\
    \ = i;\n            else\n                continue;\n            long j = 2;\n\
    \            while (i * j <= n) {\n                if (arr[i * j] == 0)\n    \
    \                arr[i * j] = i;\n                j++;\n            }\n      \
    \  }\n        return arr;\n    }();\n    Tuple!(long, long[]) largest_factor(n)\
    \ \n    {\n        Tuple!(long, long[]) res;\n        res.length = 0;\n      \
    \  while (n > 1) {\n            auto factor = spf[n];\n            res ~= factor;\n\
    \            n /= factor;\n        }\n        return res;\n    }\n    return largest_factor(n).reduce!max;\n\
    }", "{ \n    long best = 2L; \n    while (n % best == 0L) \n        n /= best;\
    \ \n    best = 3L; \n    while (n > 1L) \n    { \n        if (n % best == 0L)\
    \ \n            n /= best; \n        else \n            best += 2L; \n    } \n\
    \    return best; \n} \n/*\nDetermine whether n is prime.\n    >>> is_prime(7L)\n\
    \    True\n    >>> is_prime(8L)\n    False\n    >>> is_prime(9L)\n    False\n\
    \    >>> is_prime(10L)\n    False\n*/", "{\n\t// test the numbers from 2 to sqrt(n)\n\
    \tforeach (i; 2..sqrt(n)+1) \n\t{\n\t\tif (n % i == 0) \n\t\t{\n\t\t\t// if i\
    \ divides n, then i and n/i are factors of n\n\t\t\t// find out which is largest\n\
    \t\t\treturn max(largest_prime_factor(i), largest_prime_factor(n/i));\n\t\t}\n\
    \t}\n\t// n has no factors less than or equal to sqrt(n)\n\t// therefore it must\
    \ be prime\n\treturn n;\n}\n/*\nReturn a tuple of (a, b, c) such that a^2 + b^2\
    \ = c^2, a <= b <= c, and a + b + c = n.\n    >>> pythagorean_triple(12)\n   \
    \ (3, 4, 5)\n    >>> pythagorean_triple(25)\n    (3, 4, 5)\n    >>> pythagorean_triple(40)\n\
    \    (5, 12, 13)\n    \n*/\ntuple!(long a, long b, long c) pythagorean_triple(long\
    \ n) \n{\n\tforeach (c; n/3..n+1) \n\t{\n\t\tforeach (b; (n-c)/2..c+1) \n\t\t\
    {\n\t\t\tlong a = n - b - c;\n\t\t\tif (a*a + b*b == c*c) \n\t\t\t{\n\t\t\t\t\
    return tuple(a, b, c);\n\t\t\t}\n\t\t}\n\t}\n\tassert(0);\n}\n/*\nReturn the number\
    \ of divisors of n. Assume n > 1.\n    >>> num_divisors(12)\n    6\n    >>> num_divisors(13)\n\
    \    2\n    >>> num_divisors(2048)\n    11\n    \n*/\nlong num_divisors(long n)\
    \ \n{\n\tlong num_divisors = 0;\n\tforeach (i; 1..sqrt(n)+1) \n\t{", "{ \n   \
    \ long i; \n    for (i = 2; i <= n; i++) \n    { \n        if (n % i == 0) \n\
    \        { \n            n /= i; \n            i--; \n        } \n    } \n   \
    \ return i; \n}\n/*\nGiven an n by n matrix of elements, generate a spiral matrix.\n\
    \    >>> spiral_matrix(3)\n    [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n*/", "{\n\t\
    long temp;\n\tlong m = n;\n\tlong largest;\n\tlong k = 2;\n\t/*while loop to check\
    \ if n is not divisible by k, if so then increment\n\tk by 1. If n is divisible\
    \ by k, set temp equal to n divided by k, divide\n\tn by k and set m to temp.\
    \ If m is not divisible by k, then increment k by\n\t1. If m is divisible by k,\
    \ set temp equal to m divided by k, divide m by\n\tk and set m to temp. Keep repeating\
    \ until m is equal to 1. */\n\twhile (m != 1) \n\t{\n\t\tif (n % k != 0) \n\t\t\
    {\n\t\t\tk++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ttemp = n / k;\n\t\t\tn = n / k;\n\
    \t\t\tm = temp;\n\t\t}\n\t\tif (m % k != 0) \n\t\t{\n\t\t\tk++;\n\t\t}\n\t\telse\
    \ \n\t\t{\n\t\t\ttemp = m / k;\n\t\t\tm = m / k;\n\t\t\tm = temp;\n\t\t}\n\t}\n\
    \tlargest = k;\n\treturn largest;\n}", "{\n    import std.typecons;\n    import\
    \ std.math;\n    assert(n > 1);\n    assert(isPrime(n) == false);\n    foreach(i;\
    \ 1..(n/2)){\n        if(n % i == 0 && isPrime(i)){\n            return i;\n \
    \       }\n    }\n}\n/*\nReturn the second largest prime factor of n. Assume n\
    \ > 1 and has at least 2 prime factors.\n    >>> second_largest_prime_factor(13195L)\n\
    \    13L\n    >>> second_largest_prime_factor(256L)\n    2L\n*/\nlong second_largest_prime_factor(long\
    \ n) \n{\n    import std.typecons;\n    import std.math;\n    assert(n > 1);\n\
    \    assert(isPrime(n) == false);\n    import std.algorithm;\n    import std.range;\n\
    \    auto r = iota(1L, (n/2)).filter!(i => n % i == 0 && isPrime(i));\n    return\
    \ r[$-2];\n}\n/*\nReturn the nth prime number, where n is an integer provided\
    \ at runtime. Assume n > 0.\n    >>> nth_prime(4)\n    7L\n    >>> nth_prime(256)\n\
    \    1709L\n*/\nlong nth_prime(long n) \n{\n    import std.typecons;\n    import\
    \ std.math;\n    assert(n > 0);\n    long primeCount = 0;\n    long i = 2;\n \
    \   while(primeCount != n){\n        if(isPrime(i)){\n            primeCount +=\
    \ 1;\n        }\n        i++;\n    }\n    return i-1;\n}\n/*\nReturn the first\
    \ n primes, where n is an integer provided at runtime. Assume n > 0.\n    >>>\
    \ first_n_primes(4)\n    [2L, 3L, 5L, 7L]\n    >>> first_n_primes(256)\n    [2L,\
    \ 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L,", "{\n    long factor\
    \ = 2L;\n    long max = n / factor;\n    while (factor <= max) {\n        if (n\
    \ % factor == 0L) {\n            n /= factor;\n            max = n / factor;\n\
    \        } else {\n            factor += 1L;\n        }\n    }\n    return n;\n\
    }\n// public static void main(String[] args) {\n//     System.out.println(largest_prime_factor(13195L));\n\
    //     System.out.println(largest_prime_factor(2048L));\n// }", "{\n    long p\
    \ = 2L;\n    while (n > 1L) \n    {\n        if (n % p == 0L) \n        {\n  \
    \          n /= p;\n        }\n        else \n        {\n            p++;\n  \
    \      }\n    }\n    return p;\n}", "{\n    long max_prime_factor = 0L;\n    for\
    \ (long i = 2L; i <= n; i++) \n    {\n        bool is_prime = true;\n        for\
    \ (long j = 2L; j < i; j++) \n        {\n            if (i % j == 0L) \n     \
    \       {\n                is_prime = false;\n                break;\n       \
    \     }\n        }\n        if (is_prime && n % i == 0L) \n        {\n       \
    \     max_prime_factor = i;\n        }\n    }\n    return max_prime_factor;\n}",
  "{\n\tPrime_sieve<long> prime_sieve;\n\tprime_sieve.init(n);\n\t\n\treturn prime_sieve.lpf(n);\n\
    }", "{\n    long largest_factor(long n) \n    {\n        foreach (ref factor;\
    \ allFactors(n))\n        {\n            if (factor >= n)\n                break;\n\
    \            n /= factor;\n        }\n        return n;\n    }\n    return largest_factor(n);\n\
    }", "{\n    long i = 3;\n    if(n % 2 == 0)\n    {\n\tlong tmp = largest_prime_factor(n\
    \ / 2);\n\treturn tmp > 2 ? tmp : 2;\n    }\n    else\n    {\n\twhile(i <= sqrt(n))\n\
    \t{\n\t    if(n % i == 0)\n\t    {\n\t\tlong tmp = largest_prime_factor(n / i);\n\
    \t\treturn tmp > i ? tmp : i;\n\t    }\n\t    i += 2;\n\t}\n    }\n    return\
    \ n;\n}", "{\n    static import std.math : sqrt;\n    static if (is(typeof(sqrt(n))))\n\
    \    {\n        auto sqrt_n = typeof(sqrt(n))(sqrt(n));\n        foreach (i; 2\
    \ .. cast(typeof(i))(sqrt_n))\n        {\n            if (n % i == 0) \n     \
    \       {\n                auto f = largest_prime_factor(n / i);\n           \
    \     return f == 1 ? i : f;\n            }\n        }\n    }\n    return 1;\n\
    }", "{\n    int i;\n    i = 2;\n    while (n > 1) \n    {\n        if (n % i ==\
    \ 0) \n        {\n            n /= i;\n        } \n        else \n        {\n\
    \            i++;\n        }\n    }\n    return i;\n}", "{\n    bool[] isprime\
    \ = isPrime(n);\n    bool[] smallprimes = isprime[0 .. sqrt(n)];\n    foreach\
    \ (i; smallprimes.length - 1 .. 0) \n    {\n        if (isprime[i] && n % i ==\
    \ 0)\n            return i;\n    }\n    assert(false);\n}", "{\n    long factor\
    \ = 2L;\n    long result = 0L;\n    int count = 0;\n    while (n > 1) \n    {\n\
    \        count++;\n        if (n % factor == 0) \n        {\n            result\
    \ = factor;\n            while (n % factor == 0) \n            {\n           \
    \     n /= factor;\n            }\n        }\n        factor++;\n    }\n    //print(\"\
    count = %d\\n\", count);\n    return result;\n}", "{\n    immutable factors =\
    \ [2L .. long.digits];\n    immutable first_divisor = factors.find!((a) => n %\
    \ a == 0);\n    return first_divisor ? largest_prime_factor(n / first_divisor)\
    \ : n;\n}\n/*\nreturn true if n is prime\n*/", "{\n\tlong largest_prime_factor\
    \ = 0L;\n\t\n\tif (n % 2L == 0L)\n\t{\n\t\tlargest_prime_factor = 2L;\n\t\tn /=\
    \ 2L;\n\t}\n\t\n\tlong i = 3L;\n\twhile (i <= n)\n\t{\n\t\tif (n % i == 0L)\n\t\
    \t{\n\t\t\tlargest_prime_factor = i;\n\t\t\tn /= i;\n\t\t}\n\t\telse\n\t\t{\n\t\
    \t\ti += 2L;\n\t\t}\n\t}\n\t\n\treturn largest_prime_factor;\n}", "{\n    //int\
    \ is_prime;\n    //long x, largest;\n    //long i;\n    //for (i = n - 1; i >\
    \ 1; i--) {\n    //    is_prime = 1;\n    //    if (n % i == 0) {\n    //    \
    \    x = 2;\n    //        while (x < i) {\n    //            if (i % x == 0)\
    \ {\n    //                is_prime = 0;\n    //                break;\n    //\
    \            }\n    //            x += 1;\n    //        }\n    //        if (is_prime)\
    \ {\n    //            largest = i;\n    //            break;\n    //        }\n\
    \    //    }\n    //}\n    //return largest;\n    return n;\n}\n/*\nReturn the\
    \ sum of all the primes below n.\n    >>> sum_primes(100)\n    1060L\n*/", "{\n\
    \tstatic alias Tuple!(long, long) Tup;\n\tforeach(i; Tup(2L, n / 2L)) \n\t{\n\t\
    \tstatic if (i <= n / i) \n\t\t{\n\t\t\twhile(n % i == 0)\n\t\t\t\tn /= i;\n\t\
    \t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn n;\n}", "{\n    long prime = 0L;\n\
    \    long num = n;\n    if (num % 2L == 0L) \n    {\n        while (num % 2L ==\
    \ 0L) \n        {\n            num /= 2L;\n        }\n        prime = 2L;\n  \
    \  }\n    // Now num has the largest prime factor\n    // The factor must be in\
    \ range [sqrt(num), 1]\n    for (long i = (long)sqrt(num); i > 1L; i--) \n   \
    \ {\n        if (num % i == 0L) \n        {\n            prime = i;\n        \
    \    break;\n        }\n    }\n    return prime;\n}\n/*\nReturn the sum of the\
    \ digits of n.\n    >>> digit_sum(5)\n    5\n    >>> digit_sum(12345)\n    15\n\
    */\nlong digit_sum(long n) \n{\n    long sum = 0L;\n    do \n    {\n        sum\
    \ += n % 10L;\n        n /= 10L;\n    } while (n != 0L);\n    return sum;\n}\n\
    /*\nReturn the number of digits of n.\n    >>> num_digits(5)\n    1\n    >>> num_digits(12345)\n\
    \    5\n*/\nlong num_digits(long n) \n{\n    long count = 0L;\n    do \n    {\n\
    \        count++;\n        n /= 10L;\n    } while (n != 0L);\n    return count;\n\
    }\n/*\nReturn the greatest common divisor of a and b.\n    >>> gcd(10, 8)\n  \
    \  2\n    >>> gcd(16, 12)\n    4\n*/\nlong gcd(long a, long b) \n{\n    long d\
    \ = 0L;\n    long min = min(a, b);\n    for (long i = min; i > 0L; i--) \n   \
    \ {\n        if (a % i == 0L && b % i == 0L) \n        {\n            d = i;\n\
    \            break;\n        }\n    }\n    return d;\n}\n/*\nReturn the lowest\
    \ common multiple of a and", "{ \n    long max = long.min; \n    foreach (prime;\
    \ primes(n/2L)) \n    { \n        if (n % prime == 0L) \n            max = max(max,\
    \ prime); \n    } \n    return max; \n}\n ", "{\n\tint i = n;\n\tint primes =\
    \ 0;\n\tfor (int i = 2; i < (n/2) + 1; i++) \n\t{\n\t\tif (n % i == 0)\n\t\t{\n\
    \t\t\tif (isPrime(i))\n\t\t\t{\n\t\t\t\tprimes = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\
    \treturn primes;\n}", "{\n    auto primes = Tuple!(long)();\n    foreach(p; 2L..)\
    \ {\n        bool isPrime = true;\n        foreach(p2; primes) {\n           \
    \ if (p % p2 == 0) {\n                isPrime = false;\n                break;\n\
    \            }\n        }\n        if (isPrime) {\n            if (n % p == 0)\
    \ {\n                n /= p;\n            }\n            primes ~= p;\n      \
    \  }\n    }\n    return primes[$-1];\n}\n \n \n/*\nReturn the smallest positive\
    \ number n for which the sum of digits in n^2 \nis equal to n.\n    >>> sum_of_digits_in_n_2_equals_n()\n\
    \    1352\n    \n*/", "{\n    if (n % 2 == 0)\n        return largest_prime_factor(n\
    \ / 2);\n    for (long i = 3; i <= sqrt(n); i += 2)\n        if (n % i == 0)\n\
    \            return largest_prime_factor(n / i);\n    return n;\n}", "in \n{\n\
    \    assert(n>1);\n    // it's not a prime, there must be a prime factor.\n  \
    \  assert(!is_prime(n));\n}\nbody \n{\n    long p = 2;\n    long max = 0;\n  \
    \  while (p < n)\n    {\n        if (n % p == 0)\n        {\n            // p\
    \ is a factor\n            max = p;\n            while (n % p == 0)\n        \
    \    {\n                n /= p;\n            }\n        }\n        // p = next_prime(p)\n\
    \        p = p + 1;\n        while (!is_prime(p))\n        {\n            p =\
    \ p + 1;\n        }\n    }\n    assert(is_prime(n));\n    return max(max, n);\n\
    }", "{\n\tlong maxPrime = -1;\n\twhile (n % 2 == 0) \n\t{\n\t\tmaxPrime = 2;\n\
    \t\tn >>= 1;\n\t}\n\tfor (long i = 3; i <= sqrt(n); i += 2) \n\t{\n\t\twhile (n\
    \ % i == 0) \n\t\t{\n\t\t\tmaxPrime = i;\n\t\t\tn = n / i;\n\t\t}\n\t}\n\tif (n\
    \ > 2)\n\t\tmaxPrime = n;\n\treturn maxPrime;\n}", "{\n    import std.math;\n\
    \    alias Iterator!(int) It;\n    // Generate a range from 2 to n, and filter\
    \ out non-primes.\n    // One of the remaining numbers must be the largest prime\
    \ factor.\n    // Return the largest element.\n    return (new It(2, n + 1).filter!(isPrime))[$\
    \ - 1];\n}", "{\n\timport std.math;\n\tif(n == 2)\n\t\treturn n;\n\tif(isPrime(n))\n\
    \t\treturn n;\n\tforeach(i; 1..n/2)\n\t{\n\t\tif(n % i == 0)\n\t\t{\n\t\t\tlong\
    \ k = largest_prime_factor(i);\n\t\t\treturn k;\n\t\t}\n\t}\n\treturn n;\n}",
  "{\n\twhile (n % 2 == 0)\n\t{\n\t\tn /= 2;\n\t}\n\t\n\tlong i = 3;\n\t\n\twhile\
    \ (i * i <= n)\n\t{\n\t\twhile (n % i == 0)\n\t\t{\n\t\t\tn /= i;\n\t\t}\n\t\t\
    i += 2;\n\t}\n\t\n\treturn n;\n}", "{\n    assert(n > 1);\n    assert(!prime(n));\n\
    \    long largest_prime_factor = 2;\n    while (true) \n    {\n        if (n %\
    \ largest_prime_factor == 0) \n        {\n            n /= largest_prime_factor;\n\
    \            if (prime(n)) \n            {\n                largest_prime_factor\
    \ = n;\n                break;\n            }\n        } \n        else \n   \
    \     {\n            largest_prime_factor++;\n        }\n    }\n    return largest_prime_factor;\n\
    }", "{ \n    long largest_prime = 1L; \n    long c = 0L; \n    while (n % 2L ==\
    \ 0L) \n    { \n        n /= 2L; \n        largest_prime = 2L; \n    } \n    c\
    \ = 3L; \n    while (c <= n) \n    { \n        if (n % c == 0L) \n        { \n\
    \            n /= c; \n            largest_prime = c; \n        } \n        else\
    \ \n        { \n            c += 2L; \n        } \n    } \n    return largest_prime;\
    \ \n}\n// could also go up to sqrt(n) and check primality of each.\nlong largest_prime_factor2(long\
    \ n) \n{ \n    long largest_prime = 1L; \n    long c = 0L; \n    while (n % 2L\
    \ == 0L) \n    { \n        n /= 2L; \n        largest_prime = 2L; \n    } \n \
    \   c = 3L; \n    while (c * c <= n) \n    { \n        if (n % c == 0L) \n   \
    \     { \n            n /= c; \n            largest_prime = c; \n        } \n\
    \        else \n        { \n            c += 2L; \n        } \n    } \n    return\
    \ largest_prime; \n}\nlong largest_prime_factor3(long n) \n{ \n    long largest_prime\
    \ = 1L; \n    long c = 0L; \n    while (n % 2L == 0L) \n    { \n        n /= 2L;\
    \ \n        largest_prime = 2L; \n    } \n    c = 3L; \n    while (c * c <= n)\
    \ \n    { \n        if (n % c == 0L) \n        { \n            n /= c; \n    \
    \        largest_prime = c; \n        } \n        else \n        { \n        \
    \    c += 2L; \n        } \n    } \n    if (n > 2L", "in { \n  assert(n > 1L);\n\
    \  assert(!is_prime(n));\n}\nout(result) { \n  assert(is_prime(result));\n  assert(n\
    \ % result == 0L);\n}\n{\n  long i = n / 2L;\n  foreach (prime; primes(i)) {\n\
    \    if (n % prime == 0L) {\n      return prime;\n    }\n  }\n  return n;\n}",
  "{\n    \n\treturn 0;\n}", "{\n    n = n.front;\n    return 0;\n}\n/*\nReturn the\
    \ number of trailing zeros in n!.\n    >>> number_of_trailing_zeros(0)\n    0\n\
    \    >>> number_of_trailing_zeros(6)\n    1\n    >>> number_of_trailing_zeros(14)\n\
    \    2\n    >>> number_of_trailing_zeros(30)\n    7\n    >>> number_of_trailing_zeros(10000019)\n\
    \    5\n    \n*/\nlong number_of_trailing_zeros(long n) \n{\n    n = n.front;\n\
    \    return 0;\n}\n/*\nGiven a list of numbers, return whether any two sums to\
    \ k.\nFor example, given [10, 15, 3, 7] and k of 17, return true since 10 + 7\
    \ is 17.\n    >>> check_sums([10, 15, 3, 7], 17)\n    True\n    >>> check_sums([10,\
    \ 15, 3, 7], 18)\n    False\n    \n*/", "{\n    long current_factor = 2L;\n  \
    \  long largest_factor = n;\n    while (current_factor <= n) {\n        if (n\
    \ % current_factor == 0) {\n            n /= current_factor;\n            largest_factor\
    \ = current_factor;\n        } else {\n            current_factor += 1L;\n   \
    \     }\n    }\n    return largest_factor;\n}", "in\n{\n    enum bool is_prime(long\
    \ n) \n    in\n    {\n        if (n == 2)\n            return true;\n        else\
    \ if (n < 2 || n % 2 == 0)\n            return false;\n        else\n        {\n\
    \            for (auto p : take(cast(long)sqrt(n), iota(3L, 2L)))\n          \
    \      if (n % p == 0)\n                    return false;\n            return\
    \ true;\n        }\n    }\n    auto d = iota(2L, 1L).takeWhile!(a => a * a <=\
    \ n).filter!(is_prime);\n    return (d.filter!(a => n % a == 0)).back;\n}", "{\n\
    \    long last = 0;\n    for (immutable long i = 2; i <= n; i++)\n    {\n    \
    \    bool result = true;\n        for (immutable long j = 2; j < i; j++)\n   \
    \     {\n            if (i % j == 0)\n            {\n                result =\
    \ false;\n                break;\n            }\n        }\n        if (result\
    \ && n % i == 0)\n        {\n            last = i;\n        }\n    }\n    return\
    \ last;\n}\n/*\nReturn whether n is a palindrome.\n    >>> is_palindrome(101L)\n\
    \    True\n    >>> is_palindrome(100L)\n    False\n*/", "{\n    import std.algorithm\
    \ : filter, map, max;\n    import std.math : sqrt;\n    import std.range : iota;\n\
    \    import std.bigint : BigInt;\n    // n.max(2) because iota can't handle n\
    \ == 1.\n    return max(iota(2, cast(BigInt)sqrt(n) + 1)\n        .filter!(p =>\
    \ n % p == 0)\n        .map!(p => [p, largest_prime_factor(n / p)])\n        .map!(p\
    \ => max(p[0], p[1])));\n}", "    if (n <= 1) return 0;\n    long i = 2L;\n  \
    \  long largest = 0L;\n    while (i <= n) {\n        if (n % i == 0) {\n     \
    \       largest = i;\n            n /= i;\n        } else {\n            i +=\
    \ 1L;\n        }\n    }\n    return largest;\n}\n//largest_prime_factor(1000L);\n\
    //largest_prime_factor(13195L);\n//largest_prime_factor(2048L);\n//largest_prime_factor(2L);",
  "{ \n    // prime factorization of n \n    // if n is odd, 2 and n/2 are factors\
    \ \n    int i = 3; \n    while (i <= n / i) { \n        if (n % i == 0) { \n \
    \           n /= i; \n        } else { \n            i += 2; \n        } \n  \
    \  } \n    return n; \n}", "{\n    import std.math;\n    long result = 2L;\n \
    \   foreach (p; take(iota(3L, n, 2L), \n        cast(int)(sqrt(cast(double)(n)))))\
    \ \n    {\n        if (n % p == 0L) \n        {\n            result = p;\n   \
    \         n /= p;\n        }\n    }\n    return max(result, n);\n}", "{\n    assert(n\
    \ > 1);\n    assert(!is_prime(n));\n    long p = 2;\n    while (n % p == 0)\n\
    \        n /= p;\n    while (p * p <= n) {\n        p = next_prime(p);\n     \
    \   while (n % p == 0)\n            n /= p;\n    }\n    return n;\n}\n ", "{\n\
    \    auto factors = map!(Factor)(factorize(n));\n    immutable largest = factors[$-1].value;\n\
    \    return largest;\n}", "{ \n\tlong largest_prime_factor = 1L;\n\t// Iterate\
    \ over all even numbers first.\n\tforeach (even; iota(2L, (n + 1L) / 2L, 2L))\
    \ {\n\t\tif (n % even == 0) {\n\t\t\tlargest_prime_factor = max(largest_prime_factor,\
    \ even);\n\t\t\twhile (n % even == 0) {\n\t\t\t\tn /= even;\n\t\t\t}\n\t\t}\n\t\
    }\n\tif (n > 2) {\n\t\tlargest_prime_factor = max(largest_prime_factor, n);\n\t\
    }\n\treturn largest_prime_factor;\n}\n/*\nGet the largest prime factor of 600851475143.\n\
    */\nlong get_largest_prime_factor()\n{\n\treturn largest_prime_factor(600851475143L);\n\
    }", "{\n    assert(n > 1);\n    static struct Max\n    {\n        static bool\
    \ opApply(long r, ref long x)\n        {\n            if (r > x)\n           \
    \     x = r;\n            return true;\n        }\n    }\n    long x = 1;\n  \
    \  factors(n, Max.opApply, x);\n    return x;\n}", "{\n  int i = 2;\n  foreach\
    \ (elem; iota(n / 2, 1)) \n  {\n    if (n % elem == 0 && isPrime(elem)) \n   \
    \ {\n      return elem;\n    }\n  }\n  return n;\n}", "{\n    immutable @Prime[]\
    \ prime_factors = compute_prime_factors(n);\n    return prime_factors[$-1];\n}",
  "{\n    auto factors = factors(n);\n    std.algorithm.iteration.popFrontN(factors,\
    \ 1);\n    return factors.front;\n}\n/*\nReturn a list of prime factors of n.\
    \ Assume n > 1 and is not a prime.\n    >>> prime_factors(13195L)\n    [5L, 7L,\
    \ 13L, 29L]\n    >>> prime_factors(2048L)\n    [2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,", "{\n\tif (n <= 2)\n\
    \t\treturn n;\n\t\n\tlong x = 2;\n\tlong nn = n;\n\t\n\twhile (nn > 1) \n\t{\n\
    \t\tif (isPrime(x) && nn % x == 0) \n\t\t{\n\t\t\tnn /= x;\n\t\t} \n\t\telse \n\
    \t\t{\n\t\t\t++x;\n\t\t}\n\t}\n\t\n\treturn x;\n}", "{\n    long q, lpf;\n   \
    \ // compute the prime factors of n\n    ArrayList!(long[]) factors = factorize(n);\n\
    \    lpf = 0;\n    foreach (i; 0 .. factors.length) {\n        q = factors[i][0];\n\
    \        if (q > lpf) lpf = q;\n    }\n    return lpf;\n}\n/*\nReturn the prime\
    \ factors of n, and the number of times they occur.\n    >>> factorize(691296L)\n\
    \    [Tuple!(long, uint)(2L, 10u), Tuple!(long, uint)(3L, 4u), Tuple!(long, uint)(5L,\
    \ 1u)]\n*/\nArrayList!(long[]) factorize(long n)\n{\n    long q, r;\n    uint\
    \ i;\n    // storage for the results\n    Tuple!(long, uint)[] primes = allocTuple!(long,\
    \ uint)();\n    // temp storage for a factor\n    long[] f = alloclong[2];\n \
    \   // start with 2 and work upwards\n    q = 2;\n    while (n > 1) {\n      \
    \  // does q divide n?\n        r = n % q;\n        if (r == 0) {\n          \
    \  // yes\n            f[0] = q;\n            f[1] = 1;\n            while (n\
    \ % q == 0) {\n                f[1] += 1;\n                n /= q;\n         \
    \   }\n            // add the factors to the results\n            i = primes.length;\n\
    \            primes.length += 1;\n            primes[i] = tuple(f[0], f[1]);\n\
    \        }\n        q += 1;\n    }\n    return primes;\n}\n/*\nReturn the prime\
    \ factors of n, and the number of times they occur.\n    >>> factorize(691296L)\n\
    \    [Tuple!(long, uint)(2L, 10u), Tuple!(long, uint)(3L, 4u), Tuple!(long, uint)(5L,\
    \ 1u)]\n*/\nArrayList!(long[]) factorize2(long n)\n{\n    long", "{\n    auto\
    \ factors = n.factors(); \n    long largest_factor = factors[0];\n    foreach(i;\
    \ 1..factors.length)\n    {\n        if(factors[i] > largest_factor)\n       \
    \ {\n            largest_factor = factors[i];\n        }\n    }\n    return largest_factor;\n\
    }", "{\n\tint i;\n\tfor (i = 2; i <= n; i++)\n\t{\n\t\twhile (n % i == 0)\n\t\t\
    {\n\t\t\tn /= i;\n\t\t}\n\t}\n\treturn n;\n}", "{\n    import std.algorithm;\n\
    \    import std.bitmanip;\n    import std.range;\n    import std.math;\n    import\
    \ std.typecons;\n    import std.regex;\n    import std.datetime;\n    //we'll\
    \ assume n > 1 and not a prime\n    long last_factor = 0;\n    for (long i = 2;\
    \ i < n; i++)\n    {\n        if (n % i == 0)\n        {\n            if (isPrime(i))\n\
    \            {\n                last_factor = i;\n            }\n        }\n \
    \   }\n    return last_factor;\n}", "{\n    static assert(n > 1L);\n    static\
    \ assert(!isPrime(n));\n    int i = 2;\n    long m = 0L;\n    long s = cast(long)sqrt(n);\n\
    \    while (i < s)\n    {\n        if (n % i == 0)\n        {\n            if\
    \ (isPrime(i))\n            {\n                m = max(m, i);\n            }\n\
    \            if (isPrime(n / i))\n            {\n                m = max(m, n\
    \ / i);\n            }\n        }\n        i += 1;\n    }\n    return m;\n}\n\
    // Return all prime factors of n. n > 1 and n is not a prime.\n//    >>> prime_factors(13195L)\n\
    //    [5L, 7L, 13L, 29L]\nauto prime_factors(long n) \n{\n    static assert(n\
    \ > 1L);\n    static assert(!isPrime(n));\n    auto factor_counts = factors(n);\n\
    \    return filter!(isPrime)(factor_counts.keys);\n}\n// Return true if n is a\
    \ prime.", "{\n\tassert(n > 1);\n\t\n\tenum is_prime = true;\n\tfor (long i =\
    \ 2; i < sqrt(n); i++) \n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tis_prime = false;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (is_prime)\n\t{\n\t\treturn n;\n\t}\n\t\n\t\
    auto l = typeof(largest_prime_factor)(2);\n\tauto h = typeof(largest_prime_factor)(n);\n\
    \t\n\twhile (l <= h)\n\t{\n\t\tauto mid = (l + h) / 2;\n\t\tif (n % mid == 0)\n\
    \t\t{\n\t\t\tl = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\th = mid - 1;\n\t\t}\n\
    \t}\n\t\n\treturn h;\n}", "in\n\tassert(n>1L);\ndo\n\tlong n_sqrt = cast(long)\
    \ sqrt(cast(real) n);\n\tlong fact;\n\tfor (fact=2L; fact<=n_sqrt; fact++)\n\t\
    \tif ((n % fact) == 0L)\n\t\t\tn /= fact;\n\t\t\tbreak;\n\treturn fact;\nend",
  '    return nthPrime(findPrimeFactors(n).length);', "{\n    long largest = 0L;\n\
    \    long i = 2L;\n    while (n > 1L) \n    {\n        if (n % i == 0L) \n   \
    \     {\n            largest = i;\n            n /= i;\n        } \n        else\
    \ \n        {\n            i++;\n        }\n    }\n    return largest;\n}\n/*\n\
    Return the largest palindrome of two n-digit numbers.\n    >>> largest_palindrome(1)\n\
    \    9\n    >>> largest_palindrome(2)\n    9009\n    >>> largest_palindrome(3)\n\
    \    906609\n*/\nlong largest_palindrome(long n) \n{\n    assert(n > 0L);\n  \
    \  long max = pow(10L, n) - 1L;\n    long min = pow(10L, n - 1L);\n    long palindrome\
    \ = 0L;\n    for (long i = max; i >= min; i--) \n    {\n        for (long j =\
    \ max; j >= min; j--) \n        {\n            long p = i * j;\n            if\
    \ (is_palindrome(p) && p > palindrome) \n            {\n                palindrome\
    \ = p;\n            }\n        }\n    }\n    return palindrome;\n}", "{ \n   \
    \ long max = 1;\n    foreach(prime; Prime.primes(n)) \n    {\n        if(n % prime\
    \ == 0) \n        {\n            max = prime;\n            n /= prime;\n     \
    \   }\n    }\n    return max;\n}", "{\n    struct ulong_pair\n    {\n        long\
    \ x;\n        long y;\n    }", "{\n    foreach (e; primesUpTo(sqrt(n))) \n   \
    \ {\n        if (n % e == 0)\n            return largest_prime_factor(n / e);\n\
    \    }\n    return n;\n}", "{ \n    auto d = iota(1L, n).array;\n    return d[n.factors().array.map!(a\
    \ => d[n/a]).filter!(b => n % b == 0 && isPrime(b)).length - 1];\n}", "{\n   \
    \ if(n == 1) \n        return 1;\n    else if(isPrime(n)) \n        return n;\n\
    \    else \n    {\n        long maxPrime = 1;\n        while(n % 2 == 0) \n  \
    \      {\n            maxPrime = 2;\n            n /= 2;\n        }\n        long\
    \ divisor = 3;\n        while(n > 1) \n        {\n            while(n % divisor\
    \ == 0) \n            {\n                maxPrime = divisor;\n               \
    \ n /= divisor;\n            }\n            divisor += 2;\n        }\n       \
    \ return maxPrime;\n    }\n}", "{\n\tlong largest = 0L;\n\tforeach(long d; factors(n))\n\
    \t{\n\t\tif(isPrime(d))\n\t\t{\n\t\t\tlargest = d;\n\t\t}\n\t}\n\treturn largest;\n\
    }", "    long[] P = primes(n+1);\n    long d = P[$-1];\n    while (true) \n  \
    \      if (n % d == 0)\n            return d;\n        else\n            d--;",
  "{\n    auto factors = factorize(n);\n    return max(factors);\n}\n \n// alias",
  "{\n    long largest = 0L;\n    for (int i = 2; i <= n; i++) \n    {\n        if\
    \ (n % i == 0L) \n        {\n            if (is_prime(i)) \n            {\n  \
    \              largest = i;\n            }\n        }\n    }\n    return largest;\n\
    }", "{\n    assert(n > 1);\n    int count = 0;\n    long[] primes = new long[int.max];\n\
    \    long index = n;\n    for (int i = 2; i <= index; ++i) \n    {\n        if\
    \ (index % i == 0) \n        {\n            primes[count] = i;\n            index\
    \ /= i;\n            ++count;\n        }\n    }\n    return primes[count - 1];\n\
    }\n/*\nBy listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can\
    \ see that the 6th prime is 13.\nWhat is the 10 001st prime number?\n    >>> nth_prime(6)\n\
    \    13\n    >>> nth_prime(10001)\n    104743\n*/", "{\n    long f = 0L;\n   \
    \ long k = 2L;\n    while (n > 1L) {\n        while (n % k == 0L) {\n        \
    \    n /= k;\n            f = k;\n        }\n        ++k;\n    }\n    return f;\n\
    }\n/*\nReturn the n-th Fibonacci number.\n    >>> fibonacci(0)\n    0\n    >>>\
    \ fibonacci(1)\n    1\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n   \
    \ 2\n    >>> fibonacci(4)\n    3\n    >>> fibonacci(5)\n    5\n*/\nlong fibonacci(long\
    \ n) \n{\n    if (n < 0L) {\n        return -1L;\n    }\n    if (n == 0L) {\n\
    \        return 0L;\n    }\n    if (n == 1L) {\n        return 1L;\n    }\n  \
    \  long b = 0L;\n    long c = 1L;\n    long i = 1L;\n    for (; i < n; ++i) {\n\
    \        long a = b;\n        b = c;\n        c = a + b;\n    }\n    return c;\n\
    }\n/*\nReturn the number of occurrences of x in v.\n    >>> count_occurrences([1,2,3,2,3,1,3],\
    \ 3)\n    3\n    >>> count_occurrences([1,2,3], 0)\n    0\n    >>> count_occurrences([1,2,3],\
    \ 9)\n    0\n*/\nlong count_occurrences(immutable(long)[] v, long x) \n{\n   \
    \ long count = 0L;\n    foreach (y; v) {\n        if (y == x) {\n            ++count;\n\
    \        }\n    }\n    return count;\n}\n/*\nReturn the last digit of the n-th\
    \ Fibonacci number.\n    >>> last_fibonacci_digit(0)\n    0\n    >>> last_fibonacci_digit(1)\n\
    \    1\n    >>> last_fibonacci_digit(2)\n", "{\n    if (n < 2) \n    {\n     \
    \   return 0;\n    }\n    else if (n == 2) \n    {\n        return 2;\n    }\n\
    \    else \n    {\n        long d = 3;\n        long f = (long)n / d;\n      \
    \  while (f > d) \n        {\n            long r = n % d;\n            if (r ==\
    \ 0) \n            {\n                n = f;\n                f = (long)n / d;\n\
    \            }\n            else \n            {\n                d += 2;\n  \
    \              f = (long)n / d;\n            }\n        }\n        return max(n,\
    \ d);\n    }\n}", "{\n    ulong largest = 1L;\n    while (n % 2 == 0) {\n    \
    \    largest = 2L;\n        n = n/2;\n    }\n    ulong factor = 3L;\n    while\
    \ (n != 1) {\n        while (n % factor == 0) {\n            largest = factor;\n\
    \            n = n/factor;\n        }\n        factor += 2;\n    }\n    return\
    \ cast(long)largest;\n}", "    in (n>1 && !isPrime(n))\n{\n    long m = 2L;\n\
    \    while (n % m != 0L) \n        m++;\n    if (m == n) \n        return m;\n\
    \    else \n        return largest_prime_factor(n / m);\n}", "{ \n    long largest\
    \ = 0L;\n    long i = 2L;\n    while (i * i <= n) {\n        while (n % i == 0)\
    \ {\n            n /= i;\n            largest = i;\n        }\n        i++;\n\
    \    }\n    if (n > 1) {\n        largest = n;\n    }\n    return largest;\n}",
  "{ \n\tlong largest_prime_factor = 0L;\n\twhile( n % 2L == 0L ) {\n\t\tlargest_prime_factor\
    \ = 2L;\n\t\tn /= 2L;\n\t}\n\t\n\tlong i = 3L;\n\tlong max = long( sqrt(n) ) +\
    \ 1L;\n\twhile( i <= max ) {\n\t\tif( n % i == 0L ) {\n\t\t\tlargest_prime_factor\
    \ = i;\n\t\t\tn /= i;\n\t\t\tmax = long( sqrt(n) ) + 1L;\n\t\t}\n\t\telse i +=\
    \ 2L;\n\t}\n\t\n\tif( n > largest_prime_factor ) largest_prime_factor = n;\n\t\
    return largest_prime_factor;\n}", "{\n    long max = 0L;\n    foreach (i; 1 ..\
    \ n + 1) \n    {\n        if (n % i == 0) \n        {\n            if (isPrime(i))\
    \ \n            {\n                max = i;\n            }\n        }\n    }\n\
    \    return max;\n}", "{\n    int p = 2;\n    while (n != 1) \n    {\n       \
    \ if (n % p == 0) \n        {\n            n /= p;\n        } \n        else \n\
    \        {\n            p++;\n        }\n    }\n    return p;\n}\n \n/*\nReturn\
    \ the sum of all amicable numbers under n. An amicable number pair is two\ndifferent\
    \ numbers so related that the sum of the proper divisors of each is equal\nto\
    \ the other number. 12 and 28 is an amicable number pair.\n    >>> sum_amicable_under(10000)\n\
    \    31626\n    >>> sum_amicable_under(300)\n    504\n    >>> sum_amicable_under(1000)\n\
    \    504\n    \n*/\nlong sum_amicable_under(long n) \n{\n    long result = 0;\n\
    \    for (long x = 1; x < n; x++) \n    {\n        auto divisors = proper_divisors(x);\n\
    \        long y = std.accumulate(divisors, 0);\n        if (y != x && x == std.accumulate(proper_divisors(y),\
    \ 0)) \n        {\n            result += x;\n        }\n    }\n    return result;\n\
    }\n \n/*\nA palindromic number reads the same both ways. The largest palindrome\
    \ made from\nthe product of two 2-digit numbers is 9009 = 91 \xD7 99.\n    >>>\
    \ largest_palindrome_product(2)\n    9009\n    >>> largest_palindrome_product(3)\n\
    \    906609\n    \n*/\nlong largest_palindrome_product(long n) \n{\n    long max\
    \ = pow(10, n);\n    long max_product = 0;\n    for (long i = max - 1; i > 0;\
    \ i--) \n    {\n        for (long j = max - 1; j > 0; j--) \n        {\n     \
    \       long product = i * j;\n            if (is_palindrome(product) && product\
    \ > max_product) \n            {\n                max_product = product;\n   \
    \         }\n        }\n    }\n    return", "{ \n    long i, factor;\n    factor\
    \ = 2;\n    while (n > 1) \n    {\n        if (n % factor == 0) \n        {\n\
    \            n /= factor;\n            factor = 2;\n        } \n        else \n\
    \        {\n            factor++;\n        }\n    }\n    return factor;\n}", "in\
    \ {\n    assert(n > 1);\n    assert(!is_prime(n));\n}\nout (result) \n{\n    assert(result\
    \ < n);\n    assert(n % result == 0);\n    assert(is_prime(result));\n}\n{\n \
    \   /* Try dividing by the first 1000 primes. */\n    long[] primes = primes_until(1000L);\n\
    \    foreach (immutable p; primes) {\n        if (n % p == 0) {\n            return\
    \ p;\n        }\n    }\n    return n;\n}", "{\n    long largest = 0L;\n    long\
    \ i = 2L;\n    for (; i <= n; i++) \n    {\n        if (n % i == 0L) \n      \
    \  {\n            bool isPrime = true;\n            foreach (divisor; 2..i - 1)\
    \ \n            {\n                if (i % divisor == 0L) \n                {\n\
    \                    isPrime = false;\n                    break;\n          \
    \      }\n            }\n            if (isPrime) \n            {\n          \
    \      largest = i;\n            }\n        }\n    }\n    return largest;\n}",
  "{\n    long ans = n;\n    while (n % 2 == 0)\n    {\n        ans = 2;\n       \
    \ n /= 2;\n    }\n    long i = 3;\n    while (i <= sqrt(n))\n    {\n        if\
    \ (n % i == 0)\n        {\n            ans = i;\n            n /= i;\n       \
    \ }\n        else\n        {\n            i += 2;\n        }\n    }\n    return\
    \ ans;\n}\n/*\nFind the sum of all the primes below two million.\n    >>> sum_of_primes(100)\n\
    \    1060L\n    >>> sum_of_primes(1000)\n    76127L\n    >>> sum_of_primes(2000000)\n\
    \    142913828922L\n*/\nlong sum_of_primes(int n) \n{\n    long sum = 0;\n   \
    \ auto t = tuple!(ulong, bool)(5, true);\n    foreach (i; t[0 .. n / 3])\n   \
    \ {\n        if (t[i])\n        {\n            sum += i * 2 + 1;\n           \
    \ if (2 * i + 1 < n / 3)\n            {\n                foreach (j; t[2 * i *\
    \ i + 6 * i + 3 .. n / 3 : 2 * i + 3])\n                {\n                  \
    \  t[j] = false;\n                }\n            }\n        }\n    }\n    return\
    \ sum + 2;\n}\n/*\nCompute the difference between the sum of the squares of the\
    \ first one hundred natural numbers and the square of the sum.\n    >>> sum_square_difference(10)\n\
    \    2640\n    >>> sum_square_difference(100)\n    25164150\n*/", "{\n    long\
    \ i = 2L;\n    while (n > 1L) \n    {\n        if (n % i == 0L) \n        {\n\
    \            while (n % i == 0L) \n            {\n                n /= i;\n  \
    \          }\n        }\n        ++i;\n    }\n    return i - 1L;\n}\n/*\nFind\
    \ the first 10 digits of the sum of 100 50-digit numbers.\n*/", "{\n    long largestPrime\
    \ = -1;\n    while (n % 2 == 0) {\n        largestPrime = 2;\n        n >>= 1;\n\
    \    }\n    for (long i = 3; i <= sqrt(n); i += 2) {\n        while (n % i ==\
    \ 0) {\n            largestPrime = i;\n            n = n / i;\n        }\n   \
    \ }\n    if (n > 2)\n        largestPrime = n;\n    return largestPrime;\n}",
  "{ \n    while (n % 2 == 0)\n        n /= 2;\n    long f = 3;\n    while (f * f\
    \ <= n) {\n        if (n % f == 0)\n            n /= f;\n        else\n      \
    \      f += 2;\n    }\n    return n;\n}", "{\n    assert(n > 1);\n    return max(prime_factors(n));\n\
    }", "{\n    static struct Result{\n        long factor;\n        long rest;\n\
    \    }\n    static Result test(long n)\n    {\n        foreach(long i; iota(2L,\
    \ ceil(sqrt(n)))){\n            if(n % i == 0)\n                return Result(i,\
    \ n/i);\n        }\n        return Result(n, 0L);\n    }\n    while(n > 1){\n\
    \        Result result = test(n);\n        n = result.rest;\n    }\n    return\
    \ result.factor;\n}\n \n/*\nNote: If n is prime, then only 1 divides n. So if\
    \ we \niterate from 2 to sqrt(n), we are guaranteed to find the \nlast non-trivial\
    \ divisor of n.", "{\n\tlong factor = 1L;\n\tlong i = 2L;\n\twhile (i <= n / i)\
    \ {\n\t\tif (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tfactor = i;\n\t\t} else {\n\t\
    \t\ti++;\n\t\t}\n\t}\n\tif (n > 1) {\n\t\tfactor = n;\n\t}\n\treturn factor;\n\
    }", "{\n\tlong max_prime_factor = 1L;\n\twhile (n % 2L == 0L) \n\t{\n\t\tmax_prime_factor\
    \ = 2L;\n\t\tn /= 2L;\n\t}\n\tfor (long d = 3L; d * d <= n; d += 2L) \n\t{\n\t\
    \twhile (n % d == 0L) \n\t\t{\n\t\t\tmax_prime_factor = d;\n\t\t\tn /= d;\n\t\t\
    }\n\t}\n\tif (n > 2L) \n\t{\n\t\tmax_prime_factor = n;\n\t}\n\treturn max_prime_factor;\n\
    }", "{ \n    long largest_factor = 1L; \n    long d = 2L; \n    while (n > 1)\
    \ \n    { \n        while (n % d == 0) \n        { \n            largest_factor\
    \ = d; \n            n /= d; \n        } \n        d += (d == 2L) ? 1L : 2L; \n\
    \    } \n    return largest_factor; \n} ", "{\n    if (n < 2)\n        return\
    \ 0;\n    long p = 2;\n    while (n != 1) \n    {\n        if (n % p == 0) \n\
    \        {\n            long q = n / p;\n            if (isPrime(q))\n       \
    \         return q;\n            n = q;\n        }\n        p += 1;\n    }\n \
    \   return 0;\n}", "{ \n\tlong i,last;\n\tlast = 1;\n\twhile(n%2 == 0) \n\t{ \n\
    \t\tlast = 2; \n\t\tn = n/2; \n\t} \n\tfor(i = 3; i <= sqrt(n); i = i+2) \n\t\
    { \n\t\twhile(n%i == 0) \n\t\t{ \n\t\t\tlast = i; \n\t\t\tn = n/i; \n\t\t} \n\t\
    } \n\tif(n > 2) \n\t\tlast = n; \n\treturn last; \n} ", "{\n    ulong p = 0L;\n\
    \    auto m = n;\n    while(m%2 == 0)\n    {\n        m = m/2;\n        p = 2;\n\
    \    }\n    auto p_l = tuple!(int, int)(3,3);\n    while(!isPrime!int(m))\n  \
    \  {\n        p_l[0] = p_l[1];\n        p_l[1] = nextPrime!int(p_l[0]);\n    \
    \    while(m%p_l[1] == 0)\n        {\n            m = m/p_l[1];\n            p\
    \ = p_l[1];\n        }\n    }\n    if(m>1)\n        p = m;\n    return p;\n}",
  "{\n    long max_factor = 0L;\n    foreach(i; 2L .. sqrt(n) + 1L) \n    {\n    \
    \    if (n % i == 0L) \n        {\n            long other_factor = n / i;\n  \
    \          if (isPrime(other_factor)) \n            {\n                max_factor\
    \ = other_factor;\n                break;\n            }\n            if (isPrime(i))\
    \ \n            {\n                max_factor = i;\n            }\n        }\n\
    \    }\n    return max_factor;\n}", "    in(n>1)\n    out(is(n % ret == 0))\n\
    {\n    assert(n > 1);\n    assert(!is_prime(n));\n    return last(filter!(is_prime)(get_prime_factors(n)));\n\
    }", "{ \n    long i; \n    for (i = 2; i <= n; i++) \n    { \n        if (n %\
    \ i == 0) \n        { \n            n /= i; \n            i--; \n        } \n\
    \    } \n    return i; \n}\n/*\nReturn the most common value in the iterable.\n\
    \    >>> most_common([])\n    Traceback (most recent call last):\n        ...\n\
    \    ValueError: sequence is empty\n    >>> most_common([1, 2, 3])\n    1\n  \
    \  >>> most_common([1, 1, 2, 2, 3])\n    1\n    >>> most_common([1, 1, 2, 2, 3,\
    \ 3])\n    (1, 2, 3)\n    >>> most_common([-1, -1, -2, -2, -3, -3])\n    (-1,\
    \ -2, -3)\n*/\nauto most_common(E)(E container) \nif (isForwardRange!E && !isInfinite!E)\
    \ \n{ \n    static if (is(ElementType!E == int)) \n    { \n        alias int ElementType;\
    \ \n    } \n    else static if (is(ElementType!E == long)) \n    { \n        alias\
    \ long ElementType; \n    } \n    else static if (is(ElementType!E == float))\
    \ \n    { \n        alias float ElementType; \n    } \n    else static if (is(ElementType!E\
    \ == double)) \n    { \n        alias double ElementType; \n    } \n    else \n\
    \    { \n        static assert(false, \"not implemented for this type\"); \n \
    \   } \n    static if (is(typeof(narrowest(container[0])) == int)) \n    { \n\
    \        alias int NarrowestType; \n    } \n    else static if (is(typeof(narrowest(container[0]))\
    \ == long)) \n    { \n        alias long NarrowestType; \n    } \n    else static\
    \ if (is(typeof(narrowest(container[0])) == float)) \n   ", "{\n    immutable\
    \ factors = array(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\n          \
    \                    43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n    foreach\
    \ (x; factors) \n    {\n        if (n % x == 0) \n        {\n            while\
    \ (n % x == 0) \n            {\n                n /= x;\n            }\n     \
    \       return n * x;\n        }\n    }\n    return n;\n}", "{\n    long p = 2L;\
    \ \n    while (n % p != 0L) \n    {\n        p += 1L;\n    }\n    return p;\n}",
  "{\n\tlong larg = 1L;\n\tlong it = 2L;\n\twhile (it < ceil(sqrt(n)))\n\t{\n\t\t\
    while (n % it == 0)\n\t\t{\n\t\t\tlarg = it;\n\t\t\tn /= it;\n\t\t}\n\t\tit++;\n\
    \t}\n\tif (n > larg)\n\t\tlarg = n;\n\treturn larg;\n}", "{\n  long largest_prime_factor\
    \ = 0L;\n  long i = 2L;\n  while (i <= n) {\n    if (n % i == 0L) {\n      largest_prime_factor\
    \ = i;\n      n /= i;\n    } else {\n      i++;\n    }\n  }\n  return largest_prime_factor;\n\
    }", "{\n    static assert(n > 1, \"n must be greater than 1\");\n    static assert(!isPrime(n),\
    \ \"n must not be a prime\");\n    assert(isPrime(n));\n    long k = n / 2;\n\
    \    while (k > 0) \n    {\n        if (n % k == 0 && isPrime(k)) \n        {\n\
    \            return k;\n        }\n        k--;\n    }\n    assert(0);\n}", "{\n\
    \    long largest = 1L;\n    while (n % 2L == 0L) {\n        largest = 2L;\n \
    \       n /= 2L;\n    }\n    long factor = 3L;\n    while (n > 1L) {\n       \
    \ while (n % factor == 0L) {\n            largest = factor;\n            n /=\
    \ factor;\n        }\n        factor += 2L;\n    }\n    return largest;\n}", "{\
    \ \n    // The largest prime factor is always <= sqrt(n)\n    long largest_factor\
    \ = 1L; \n    long upper_bound = cast(long) sqrt(n); \n    foreach (prime; primes_up_to(upper_bound))\
    \ \n    { \n        if (n % prime == 0) \n        { \n            largest_factor\
    \ = prime; \n        } \n    } \n    return largest_factor; \n} ", "{\n\tauto\
    \ isprime = (n)\n\t{\n\t\treturn n > 1 && !(2 .. n).any!(a => (n % a) == 0);\n\
    \t};\n\tauto factor = {\n\t\tauto i = 0L;\n\t\tforeach(i; 2 .. n + 1)\n\t\t{\n\
    \t\t\tif(n % i == 0 && isprime(i))\n\t\t\t{\n\t\t\t\tyield i;\n\t\t\t}\n\t\t}\n\
    \t};\n\treturn n.largest(factor);\n}\n/*\nReturn the 'n'th power of the naturals.\n\
    \    >>> nth_power_of_naturals(0)\n    1\n    >>> nth_power_of_naturals(1)\n \
    \   1\n    >>> nth_power_of_naturals(2)\n    5\n    >>> nth_power_of_naturals(3)\n\
    \    30\n    >>> nth_power_of_naturals(4)\n    420\n    >>> nth_power_of_naturals(5)\n\
    \    9000\n*/\nlong nth_power_of_naturals(long n) \n{\n\treturn iota(1L, n + 1).product;\n\
    }\n/*\nDetermine whether a given number is an Armstrong number.\nReturn the number\
    \ if so, else return the smallest armstrong number greater than the number.",
  "{\n\t\n\t//std.stdio.writefln(\"n = %s\", n);\n\t\n\tif (n < 2) return 0;\n\t\n\
    \tlong largest_factor = 0;\n\t\n\tlong i = 2;\n\t\n\twhile (i <= n) {\n\t\t//std.stdio.writefln(\"\
    i = %s\", i);\n\t\tif (n % i == 0) {\n\t\t\tlargest_factor = i;\n\t\t\tn /= i;\n\
    \t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\treturn largest_factor;\n}", "{\n \
    \   static assert(n > 1);\n    static assert(!isPrime(n));\n    if (n % 2 == 0)\n\
    \        return max(2L, largest_prime_factor(n / 2));\n    auto p = tuple(primes(cast(long)sqrt(n)\
    \ + 1));\n    foreach (i; 0 .. p.length) \n    {\n        if (n % p[i] == 0)\n\
    \            return max(p[i], largest_prime_factor(n / p[i]));\n    }\n    return\
    \ n;\n}\n/*\nCalculate the sum of all the primes below n.\n    >>> primes_sum(10)\n\
    \    17\n*/\nlong primes_sum(long n) \n{\n    long r = 2;\n    foreach (p; primes(n))\
    \ \n    {\n        r += p;\n    }\n    return r;\n}\n/*\nCalculate the sum of\
    \ the digits of n!\n    >>> factorial_sum(10)\n    27\n*/\nlong factorial_sum(long\
    \ n) \n{\n    long r = 0;\n    foreach (d; iota(n)) \n    {\n        r += factorial(d);\n\
    \    }\n    return r;\n}\n/*\n    >>> factorial(10)\n    3628800\n*/\nlong factorial(long\
    \ n) \n{\n    long r = 1;\n    foreach (i; 1 .. n + 1) \n    {\n        r *= i;\n\
    \    }\n    return r;\n}\n/*\nReturn the nth triangular number.\n    >>> triangular(10)\n\
    \    55\n*/\nlong triangular(long n) \n{\n    long r = 0;\n    foreach (i; 1 ..\
    \ n + 1) \n    {\n        r += i;\n    }\n    return r;\n}\n/*\nReturn true if\
    \ n is a palindrome.\n    >>> is_palindrome(1001)\n    true\n    >>> is_palindrome(1234)\n\
    \    false\n*/", "{\n    size_t f = firstPrimeFactor(n);\n    if (n == f)\n  \
    \      return n;\n    else\n        return largest_prime_factor(n / f);\n}", "{\n\
    \    static assert(n > 1);\n    static assert(!isPrime(n));\n    return 0;\n}\n\
    // ------------------------------------------------------------------", "{\n \
    \   long d = 2L;\n    long last = 1L;\n    while (d <= n) \n    {\n        if\
    \ (n % d == 0L) \n        {\n            last = d;\n            n /= d;\n    \
    \    } \n        else \n        {\n            d += 1L;\n        }\n    }\n  \
    \  return last;\n}", "{\n    assert(n > 1L);\n    long max_prime_factor = 1L;\n\
    \    while (n % 2L == 0L) \n    {\n        max_prime_factor = 2L;\n        n /=\
    \ 2L;\n    }\n    long p = 3L;\n    while (n != 1L) \n    {\n        while (n\
    \ % p == 0L) \n        {\n            max_prime_factor = p;\n            n /=\
    \ p;\n        }\n        p += 2L;\n    }\n    return max_prime_factor;\n}", "{\n\
    \    long largest_prime = 0L;\n    foreach(Long p; primes(n))\n    {\n       \
    \ if (n % p == 0)\n        {\n            largest_prime = p;\n        }\n    }\n\
    \    return largest_prime;\n}\n/*\nReturn n! (factorial).\n    >>> factorial(0)\n\
    \    1\n    >>> factorial(5)\n    120\n    >>> factorial(6)\n    720\n*/\nlong\
    \ factorial(long n) \n{\n    if (n == 0) return 1;\n    return n * factorial(n\
    \ - 1);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
