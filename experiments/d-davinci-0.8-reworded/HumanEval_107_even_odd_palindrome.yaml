name: HumanEval_107_even_odd_palindrome
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given a positive integer\
  \ n, return a tuple that has the number of even and odd\n    integer palindromes\
  \ that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n    >>> even_odd_palindrome(3L)\n\
  \    tuple(1L, 2L)\n        Explanation:\n        Integer palindrome are 1, 2, 3.\
  \ one of them is even, and two of them are odd.\n\n    Example 2:\n\n    >>> even_odd_palindrome(12L)\n\
  \    tuple(4L, 6L)\n        Explanation:\n        Integer palindrome are 1, 2, 3,\
  \ 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n\
  \        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and\
  \ odd integer palindromes respectively.\n    \n*/\nTuple!(long, long) even_odd_palindrome(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = even_odd_palindrome;\n\n    assert(candidate(123L)\
  \ == tuple(8L, 13L));\n    assert(candidate(12L) == tuple(4L, 6L));\n    assert(candidate(3L)\
  \ == tuple(1L, 2L));\n    assert(candidate(63L) == tuple(6L, 8L));\n    assert(candidate(25L)\
  \ == tuple(5L, 6L));\n    assert(candidate(19L) == tuple(4L, 6L));\n    assert(candidate(9L)\
  \ == tuple(4L, 5L));\n    assert(candidate(1L) == tuple(0L, 1L));\n}\nvoid main(){}"
completions: ["{\n    long even_count = 0;\n    long odd_count = 0;\n    foreach(i;\
    \ 1..n+1)\n    {\n        if(is_even_palindrome(i))\n        {\n            even_count++;\n\
    \        }\n        else if(is_odd_palindrome(i))\n        {\n            odd_count++;\n\
    \        }\n    }\n    return tuple(even_count, odd_count);\n}", "{\n    static\
    \ bool is_palindrome(long n)\n    {\n        string s = to!string(n);\n      \
    \  foreach(i, j; s[])\n        {\n            if(s[i] != s[j])\n             \
    \   return false;\n        }\n        return true;\n    }", "{\n    // long odd\
    \ = 0;\n    // long even = 0;\n    // long max = (long)pow(10, 3);\n    // if\
    \ (n > max) {\n    //     odd = 0;\n    //     even = 0;\n    // } else {\n  \
    \  //     while (n > 0) {\n    //         long t = n;\n    //         long rev\
    \ = 0;\n    //         while (t > 0) {\n    //             rev = rev * 10 + t\
    \ % 10;\n    //             t /= 10;\n    //         }\n    //         if (rev\
    \ == n) {\n    //             if (n % 2 == 0) {\n    //                 even +=\
    \ 1;\n    //             } else {\n    //                 odd += 1;\n    //  \
    \           }\n    //         }\n    //         n -= 1;\n    //     }\n    //\
    \ }\n    // return tuple(even, odd);\n    long c1 = (long)floor(log10(n)) + 1;\n\
    \    long c2 = (long)floor(log10(n / 2)) + 1;\n    long c3 = (long)ceil(log10(n\
    \ / 2)) + 1;\n    long c4 = (long)floor(log10(n - 1)) + 1;\n    long c5 = (long)ceil(log10(n\
    \ - 1)) + 1;\n    return tuple(c1 * c2 + c1 * c3 + c4 * c5 + 1, n - c1 * c2 -\
    \ c1 * c3 - c4 * c5 - 1);\n}", "{\n    static assert(n >= 1 && n <= 1000);\n \
    \   static if (n < 10)\n        return Tuple!(long, long)(n % 2, n / 2);\n   \
    \ else\n    {\n        auto evens = 0;\n        auto odds = 0;\n        foreach\
    \ (i; 1..n + 1)\n        {\n            if (i < 10)\n            {\n         \
    \       ++odds;\n                continue;\n            }\n            if (i %\
    \ 10 == 0)\n                continue;\n            auto isPalindrome = true;\n\
    \            auto digits = log10(i) + 1;\n            foreach (j; 0..digits /\
    \ 2)\n            {\n                if (cast(int)(i / 10 ^^ j) % 10 != cast(int)(i\
    \ / 10 ^^ (digits - j - 1)) % 10)\n                {\n                    isPalindrome\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (isPalindrome)\n                i % 2 == 0 ? ++evens : ++odds;\n\
    \        }\n        return Tuple!(long, long)(evens, odds);\n    }\n}", "{\n \
    \   enum\n    {\n        even = 0,\n        odd = 1\n    }", "{\n    assert(n\
    \ > 0);\n    Tuple!(long, long) result = tuple(0L, 0L);\n    for (long i = 1;\
    \ i <= n; i++)\n    {\n        if (is_palindrome(i) && (i % 2 == 0))\n       \
    \ {\n            result[0]++;\n        }\n        else if (is_palindrome(i) &&\
    \ (i % 2 != 0))\n        {\n            result[1]++;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long even_palindrome_count = 0L;\n    long odd_palindrome_count\
    \ = 0L;\n    for (long i = 1L; i <= n; i++)\n    {\n        if (is_even_integer_palindrome(i))\n\
    \        {\n            even_palindrome_count++;\n        }\n        else if (is_odd_integer_palindrome(i))\n\
    \        {\n            odd_palindrome_count++;\n        }\n    }\n    return\
    \ tuple(even_palindrome_count, odd_palindrome_count);\n}", "{\n    /*\n      \
    \  if n is single digit, then number of odd palindrome is 1 (n), and number of\
    \ even palindrome is 0.\n        if n is two digit, then number of odd palindrome\
    \ is 0, and number of even palindrome is 1.\n    */\n    if (n <= 9) return tuple(0L,\
    \ 1L);\n    /*\n        In the following if-else block,\n        we will check\
    \ the number of digit in n.\n        1. If n has even number of digit, then we\
    \ have to check which one of the n/2-th digit is the middle digit.\n         \
    \   If n/2-th digit is 0, then we have to check all the other digits that are\
    \ greater than it.\n            If n/2-th digit is not 0, then we have to check\
    \ all the digits that are greater than it.\n        2. If n has odd number of\
    \ digit, then we have to check which one of the (n+1)/2-th digit is the middle\
    \ digit.\n            If (n+1)/2-th digit is 0, then we have to check all the\
    \ other digits that are greater than it.\n            If (n+1)/2-th digit is not\
    \ 0, then we have to check all the digits that are greater than it.\n    */\n\
    \    else if (n % 2 == 0) \n    {\n        auto middle = n/2;\n        auto nextToMiddle\
    \ = (n/2) - 1;\n        auto count = 1;\n        while(middle >= 1) \n       \
    \ {\n            if (middle % 10 != 0)\n                count *= 10;\n       \
    \     else \n            {\n                if (nextToMiddle >= 1) \n        \
    \        {\n                    count *= 9;\n                    count *= nextToMiddle;\n\
    \                }\n                else\n                    count *= 10;\n \
    \           }\n            middle /= 10;\n            nextToMiddle /= 10;\n  \
    \      }\n        return tuple(count, count);\n    }\n    else \n    {\n     \
    \   auto middle = (n+1)/2;\n        auto nextToMiddle = ((n+1)/2) - 1;\n     \
    \   auto count = 1;\n        while(middle >= 1) \n        {\n            if (middle\
    \ %", "{\n    long even = 0L;\n    long odd = 0L;\n    long tmp;\n    for (long\
    \ i = 1L; i <= n; i++) \n    {\n        tmp = i;\n        if (tmp % 2L == 0L)\n\
    \        {\n            even++;\n        }\n        else\n        {\n        \
    \    odd++;\n        }\n    }\n    return tuple(even, odd);\n}", "{\n    long\
    \ even = 0L;\n    long odd = 0L;\n    foreach(i;1..n+1) \n    {\n        string\
    \ s = format(\"%s\", i);\n        if(s.front() != s.back()) continue;\n      \
    \  if(i % 2 == 0) even++;\n        else odd++;\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    long odd, even;\n    assert(n >= 1 && n <= 1000);\n    if\
    \ (n < 10) {\n        return tuple(n/2, n/2 + n%2);\n    } else {\n        odd\
    \ = pow(10, cast(int)log10(n) - 1);\n        even = pow(10, cast(int)log10(n));\n\
    \        return tuple(odd/2 + even/2, odd/2 + odd%2 + even/2 + even%2);\n    }\n\
    }\n/*\n    Examples:\n    >>> even_odd_palindrome(3L)\n    tuple(1L, 2L)\n   \
    \ >>> even_odd_palindrome(12L)\n    tuple(4L, 6L)\n*/", "{\n    assert(n >= 1\
    \ && n <= 1000);\n    //return tuple(1L, 1L);\n    return tuple(n / 2L, n / 2L\
    \ + n % 2L);\n}\n \n/*\n    Return a tuple that contains the number of vowels\
    \ and consonants\n    of input text respectively.\n    For example, given \"Hello,\
    \ World!\", the function should return tuple(3L, 8L)", "{\n    long even_count\
    \ = 0L;\n    long odd_count = 0L;\n    long temp;\n    long remainder;\n    long\
    \ reverse = 0L;\n    for (long i = 1L; i <= n; i++)\n    {\n        temp = i;\n\
    \        while (temp != 0)\n        {\n            remainder = temp % 10;\n  \
    \          reverse = reverse * 10 + remainder;\n            temp /= 10;\n    \
    \    }\n        if (i == reverse)\n        {\n            if (i % 2 == 0)\n  \
    \          {\n                even_count++;\n            }\n            else\n\
    \            {\n                odd_count++;\n            }\n        }\n     \
    \   reverse = 0L;\n    }\n    return tuple(even_count, odd_count);\n}", "{\n \
    \   // bug not covered by the test case below\n    if (n <= 1) return tuple(0L,\
    \ 0L);", "{\n    \n    alias is_palindrome = bool delegate(string);\n    is_palindrome\
    \ is_palindrome = (string x) {\n      string y = x.dup;\n      y.reverse;\n  \
    \    return x == y;\n    };\n    \n    auto count_palindrome = (T)(T n) {\n  \
    \      string s = T.to!string(n);\n        long result = 0;\n        foreach(i;\
    \ 0 .. s.length) {\n            foreach(j; i .. s.length) {\n                if(is_palindrome(s[i\
    \ .. j])) {\n                    result += 1;\n                }\n           \
    \ }\n        }\n        return result;\n    };\n    \n    return tuple(count_palindrome!long(n)\
    \ - count_palindrome!long(n / 2), count_palindrome!long(n / 2));\n}", "{\n   \
    \ Tuple!(long, long) result;\n    string str = to!string(n);\n    if (str.length()\
    \ % 2 == 0)\n    {\n        result.field1 = n / 10;\n        result.field2 = n\
    \ - (n / 10);\n    }\n    else\n    {\n        result.field1 = n / 10;\n     \
    \   result.field2 = n - (n / 10) - 1;\n    }\n    return result;\n}", "{ \n  \
    \  auto palindrome_list = new List!long;\n    long odd_palindrome_count = 0;\n\
    \    long even_palindrome_count = 0;\n    for (long i = 1; i <= n; i++)\n    {\n\
    \        if (is_palindrome(i))\n        {\n            palindrome_list.addFront(i);\n\
    \            if (i % 2 == 0)\n            {\n                even_palindrome_count++;\n\
    \            }\n            else\n            {\n                odd_palindrome_count++;\n\
    \            }\n        }\n    }\n    return tuple(even_palindrome_count, odd_palindrome_count);\n\
    }", "{\n    long even_count = 0;\n    long odd_count = 0;\n    for (long i = 1;\
    \ i <= n; i++)\n    {\n        auto rev = reverse_copy!string(to!string(i));\n\
    \        if (rev == to!string(i))\n        {\n            auto num = to!long(rev);\n\
    \            if (isEven(num))\n            {\n                even_count++;\n\
    \            }\n            else\n            {\n                odd_count++;\n\
    \            }\n        }\n    }\n    return tuple(even_count, odd_count);\n}",
  "{\n    long even = 0L;\n    long odd = 0L;\n    for (long i = 1L; i <= n; i++)\n\
    \    {\n        auto ip = to!string(i);\n        auto reversed = ip.dup.reverse;\n\
    \        if (ip == reversed)\n        {\n            if (i % 2 == 0)\n       \
    \     {\n                even++;\n            }\n            else\n          \
    \  {\n                odd++;\n            }\n        }\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    auto result = Tuple!(long, long)(0L, 0L);\n    for (long\
    \ i = 1L; i <= n; i++) \n    {\n        if (is_even_palindrome(i)) \n        {\n\
    \            result[0]++;\n        } \n        else \n        {\n            result[1]++;\n\
    \        }\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
