name: HumanEval_69_search
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a non-empty\
  \ array of positive integers. Return the greatest integer that is greater than \n\
  \    zero, and has a frequency greater than or equal to the value of the integer\
  \ itself. \n    The frequency of an integer is the number of times it appears in\
  \ the array.\n    If no such a value exist, return -1.\n    Examples:\n    >>> search([4L,\
  \ 1L, 2L, 2L, 3L, 1L])\n    2L\n    >>> search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L,\
  \ 4L])\n    3L\n    >>> search([5L, 5L, 4L, 4L, 4L])\n    -1L\n    \n*/\nlong search(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = search;\n\n    assert(candidate([5L, 5L,\
  \ 5L, 5L, 1L]) == 1L);\n    assert(candidate([4L, 1L, 4L, 1L, 4L, 4L]) == 4L);\n\
  \    assert(candidate([3L, 3L]) == -1L);\n    assert(candidate([8L, 8L, 8L, 8L,\
  \ 8L, 8L, 8L, 8L]) == 8L);\n    assert(candidate([2L, 3L, 3L, 2L, 2L]) == 2L);\n\
  \    assert(candidate([2L, 7L, 8L, 8L, 4L, 8L, 7L, 3L, 9L, 6L, 5L, 10L, 4L, 3L,\
  \ 6L, 7L, 1L, 7L, 4L, 10L, 8L, 1L]) == 1L);\n    assert(candidate([3L, 2L, 8L, 2L])\
  \ == 2L);\n    assert(candidate([6L, 7L, 1L, 8L, 8L, 10L, 5L, 8L, 5L, 3L, 10L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 3L, 6L, 5L, 6L, 4L]) == -1L);\n    assert(candidate([6L,\
  \ 9L, 6L, 7L, 1L, 4L, 7L, 1L, 8L, 8L, 9L, 8L, 10L, 10L, 8L, 4L, 10L, 4L, 10L, 1L,\
  \ 2L, 9L, 5L, 7L, 9L]) == 1L);\n    assert(candidate([1L, 9L, 10L, 1L, 3L]) == 1L);\n\
  \    assert(candidate([6L, 9L, 7L, 5L, 8L, 7L, 5L, 3L, 7L, 5L, 10L, 10L, 3L, 6L,\
  \ 10L, 2L, 8L, 6L, 5L, 4L, 9L, 5L, 3L, 10L]) == 5L);\n    assert(candidate([1L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 10L, 6L, 4L, 3L, 5L, 8L, 2L, 4L, 2L, 8L,\
  \ 4L, 6L, 10L, 4L, 2L, 1L, 10L, 2L, 1L, 1L, 5L]) == 4L);\n    assert(candidate([2L,\
  \ 10L, 4L, 8L, 2L, 10L, 5L, 1L, 2L, 9L, 5L, 5L, 6L, 3L, 8L, 6L, 4L, 10L]) == 2L);\n\
  \    assert(candidate([1L, 6L, 10L, 1L, 6L, 9L, 10L, 8L, 6L, 8L, 7L, 3L]) == 1L);\n\
  \    assert(candidate([9L, 2L, 4L, 1L, 5L, 1L, 5L, 2L, 5L, 7L, 7L, 7L, 3L, 10L,\
  \ 1L, 5L, 4L, 2L, 8L, 4L, 1L, 9L, 10L, 7L, 10L, 2L, 8L, 10L, 9L, 4L]) == 4L);\n\
  \    assert(candidate([2L, 6L, 4L, 2L, 8L, 7L, 5L, 6L, 4L, 10L, 4L, 6L, 3L, 7L,\
  \ 8L, 8L, 3L, 1L, 4L, 2L, 2L, 10L, 7L]) == 4L);\n    assert(candidate([9L, 8L, 6L,\
  \ 10L, 2L, 6L, 10L, 2L, 7L, 8L, 10L, 3L, 8L, 2L, 6L, 2L, 3L, 1L]) == 2L);\n    assert(candidate([5L,\
  \ 5L, 3L, 9L, 5L, 6L, 3L, 2L, 8L, 5L, 6L, 10L, 10L, 6L, 8L, 4L, 10L, 7L, 7L, 10L,\
  \ 8L]) == -1L);\n    assert(candidate([10L]) == -1L);\n    assert(candidate([9L,\
  \ 7L, 7L, 2L, 4L, 7L, 2L, 10L, 9L, 7L, 5L, 7L, 2L]) == 2L);\n    assert(candidate([5L,\
  \ 4L, 10L, 2L, 1L, 1L, 10L, 3L, 6L, 1L, 8L]) == 1L);\n    assert(candidate([7L,\
  \ 9L, 9L, 9L, 3L, 4L, 1L, 5L, 9L, 1L, 2L, 1L, 1L, 10L, 7L, 5L, 6L, 7L, 6L, 7L, 7L,\
  \ 6L]) == 1L);\n    assert(candidate([3L, 10L, 10L, 9L, 2L]) == -1L);\n}\nvoid main(){}"
completions: ["{\n    auto freq = typeof(return)();\n    foreach(i; lst)\n    {\n\
    \        if(lst[i] <= 0)\n            continue;\n        freq[lst[i]]++;\n   \
    \ }\n    long max = -1;\n    foreach(key; freq.keys)\n    {\n        if(key >=\
    \ freq[key] && max < key)\n            max = key;\n    }\n    return max;\n}",
  "{\n    // We use an associative array as HashMap\n    int[long] freq = new int[long];\n\
    \    foreach(val; lst)\n    {\n        if(!freq.containsKey(val))\n          \
    \  freq[val] = 0;\n        ++freq[val];\n    }\n    // We convert the freq array\
    \ to a tuple and sort it in descending order\n    auto freq_tuple = freq.keys.zip(freq.values);\n\
    \    // This is just to make sure that elements of the same frequency are sorted\
    \ in descending order as well\n    freq_tuple.sort!((a, b) => a[1] == b[1] ? b[0]\
    \ > a[0] : b[1] > a[1]);\n    // foreach(val; freq_tuple)\n    // {\n    //  \
    \   pragma(msg, \"val = \", val);\n    // }\n    // We iterate over the sorted\
    \ array\n    foreach(tup; freq_tuple)\n    {\n        if(tup[0] > tup[1])\n  \
    \          break;\n        return tup[0];\n    }\n    return -1L;\n}", "{\n  \
    \  long[] lst_counts = lst.groupBy().map!(x => [x[0], x[1].length])\n        \
    \                            .filter!(x => x[1] >= x[0])\n                   \
    \                 .array;\n    long max_count = lst_counts.map!(x => x[1]).max();\n\
    \    long max_count_value = lst_counts.filter!(x => x[1] == max_count)[0][0];\n\
    \    return max_count_value;\n}", "{\n    import std.algorithm;\n    import std.array;\n\
    \    import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.typecons;\n    //main code\n    return lst.groupBy!((e)\
    \ => e).filter!((e) => e.length >= e.key).max!((e) => e.key).key;\n}", "{ \n \
    \   if (lst.length == 0) return -1;\n    if (lst.length == 1) return -1;\n   \
    \ for (int i = 0; i < lst.length; i++) \n    {\n        long currentValue = lst[i];\n\
    \        if (currentValue == 0) continue;\n        long[] subArray = lst[i..$];\n\
    \        long frequency = 0;\n        foreach (var element; subArray) \n     \
    \   {\n            if (element == currentValue) frequency++;\n        }\n    \
    \    if (frequency >= currentValue) return currentValue;\n    }\n    return -1;\n\
    }", "{\n    int max = 0;\n    int maxIndex = -1;\n    int current = 0;\n    int[]\
    \ freq = new int[lst.length];\n    foreach(x; lst)\n    {\n        current = 0;\n\
    \        foreach(y; lst)\n        {\n            if(x == y)\n            {\n \
    \               current++;\n            }\n        }\n        freq[x] = current;\n\
    \        if(current >= x && current > max)\n        {\n            max = current;\n\
    \            maxIndex = x;\n        }\n    }\n    return maxIndex;\n}", "{\n \
    \   Map!(size_t, size_t) freq = new Map!(size_t, size_t);\n    foreach(immutable\
    \ long num; lst)\n    {\n        freq[num] = freq.count(num) + 1;\n    }\n   \
    \ long max = -1;\n    foreach(immutable long key; freq.keys)\n    {\n        if(freq[key]\
    \ >= key && key > max)\n        {\n            max = key;\n        }\n    }\n\
    \    return max;\n}\n// Test\nunittest\n{\n    assert(search([4L, 1L, 2L, 2L,\
    \ 3L, 1L]) == 2L);\n    assert(search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L]) ==\
    \ 3L);\n    assert(search([5L, 5L, 4L, 4L, 4L]) == -1L);\n}", "{\n    assert(\
    \ lst.length > 0 );\n    // Map of values and their frequencies.\n    auto freq\
    \ = lst.assocArray;\n    // Sort by descending frequency\n    auto sortedFreq\
    \ = std.sort(freq.byValue, (a, b) => a.value > b.value);\n    long[] result;\n\
    \    foreach(el; sortedFreq) \n    {\n        if(el.value >= el.key) \n      \
    \  {\n            result ~= el.key;\n        }\n    }\n    return result.empty\
    \ ? -1L : result[0];\n}", "{\n    return lst.groupBy!(id).sum!((k, v) => k*v.length)\n\
    \                    .max!((a, b) => a > b && a >= a.first ? 1 : -1)\n       \
    \             .first;\n}", "{\n    import std.range;\n    int max = 0;\n    foreach(int\
    \ x; lst)\n    {\n        if(x > max)\n            max = x;\n    }\n    int[]\
    \ stats = new int[max+1];\n    foreach(int x; lst)\n    {\n        stats[x]++;\n\
    \    }\n    foreach(int x; lst)\n    {\n        if(stats[x] >= x)\n          \
    \  return x;\n    }\n    return -1;\n}", "{\n    return lst.map!(a => tuple(a,\
    \ lst.count(a))).map!(a => tuple(a[0], a[1] >= a[0] ? a[1] : -1L)).filter!(a =>\
    \ a[1] > 0L).length > 0 ? lst.map!(a => tuple(a, lst.count(a))).map!(a => tuple(a[0],\
    \ a[1] >= a[0] ? a[1] : -1L)).filter!(a => a[1] > 0L).sort!(b => b[1] < b[1]).back[0]\
    \ : -1L;\n}", "{\n    long value = 0;\n    long number = 0;\n    foreach(k; lst)\n\
    \    {\n        if(std.algorithm.count(lst, k) >= k)\n        {\n            value\
    \ = k;\n            break;\n        }\n    }\n    return value != 0 ? value :\
    \ -1;\n}", "{\n    foreach(elem; lst) {\n        if(elem <= lst.count(elem))\n\
    \            return elem;\n    }\n    return -1;\n}", "{\n    long freq;\n   \
    \ long result = -1;\n    long[] uniq = lst.uniq;\n    foreach(long i; uniq)\n\
    \    {\n        freq = lst.count(i);\n        if(freq >= i && i > result)\n  \
    \      {\n            result = i;\n        }\n    }\n    return result;\n}", "{\n\
    \    auto dict = new SortedMap!(long, long)();\n    foreach(n; lst)\n    {\n \
    \       if(dict.find(n) != dict.end)\n        {\n            dict[n] = dict[n]\
    \ + 1;\n        }\n        else\n        {\n            dict[n] = 1;\n       \
    \ }\n    }\n    foreach(i; dict.byKey)\n    {\n        if(i.value > i.key)\n \
    \       {\n            return i.key;\n        }\n    }\n    return -1;\n}", "{\n\
    \    int result = lst.length;\n    for (int i = lst.length; i >= 0; i--)\n   \
    \ {\n        int count = 0;\n        for (int j = 0; j < lst.length; j++)\n  \
    \      {\n            if (lst[j] == i)\n            {\n                count++;\n\
    \            }\n        }\n        if (count >= i)\n        {\n            result\
    \ = i;\n            break;\n        }\n    }\n    if (result != lst.length)\n\
    \    {\n        return result;\n    }\n    else\n    {\n        return -1;\n \
    \   }\n}", "{\n    long[] lst_num = new long[lst.length];\n    long[] lst_count\
    \ = new long[lst.length];\n    long result = -1L;\n    long count = 1L;\n    long\
    \ k = 1L;\n    long z = 0L;\n    long num = 0L;\n    long count2 = 0L;\n    long\
    \ num2 = 0L;\n    lst_num[0] = lst[0];\n    for (long i = 1L; i < lst.length;\
    \ i++)\n    {\n        for (long j = 0L; j < k; j++)\n        {\n            if\
    \ (lst[i] == lst_num[j])\n            {\n                count = count + 1L;\n\
    \                count2 = count;\n                num2 = lst[i];\n           \
    \     lst_count[j] = count;\n                z = 1L;\n            }\n        }\n\
    \        if (z == 0L)\n        {\n            lst_num[k] = lst[i];\n         \
    \   lst_count[k] = 1L;\n            k = k + 1L;\n        }\n        z = 0L;\n\
    \        count = 1L;\n    }\n    for (long i = 0L; i < k; i++)\n    {\n      \
    \  if (lst_count[i] == lst_num[i])\n        {\n            if (lst_num[i] > num)\n\
    \            {\n                num = lst_num[i];\n            }\n        }\n\
    \    }\n    if (num == 0L)\n    {\n        result = -1L;\n    }\n    else\n  \
    \  {\n        result = num;\n    }\n    return result;\n}", "{\n    long number\
    \ = 0L;\n    long f = 0L;\n    for(long i = 0L; i < lst.length; i++)\n    {\n\
    \        long counter = 0L;\n        long temp = lst[i];\n        for(long j =\
    \ 0L; j < lst.length; j++)\n        {\n            if(temp == lst[j])\n      \
    \      {\n                counter++;\n            }\n        }\n        if(counter\
    \ >= temp && counter > f)\n        {\n            number = temp;\n           \
    \ f = counter;\n        }\n    }\n    if(number == 0L)\n    {\n        return\
    \ -1L;\n    }\n    return number;\n}\n// by omegacrash\nlong search(long[] a)\
    \ \n{\n    Map<long, long> m = new Map.fromArray(a);\n    foreach(k; m.keys())\
    \ \n    {\n        if(m[k] >= k)\n        {\n            return k;\n        }\n\
    \    }\n    return -1L;\n}\n// by yubo\nlong search(long[] arr) \n{\n    long\
    \ greatest = 0L;\n    foreach(n; arr) \n    {\n        if(n > greatest)\n    \
    \    {\n            greatest = n;\n        }\n    }\n    foreach(n; arr) \n  \
    \  {\n        if(n == greatest)\n        {\n            return n;\n        }\n\
    \    }\n    return -1L;\n}\n// by frankyman\nlong search(long[] arr) \n{\n   \
    \ long[] temp = arr.dup;\n    temp.sort;\n    long[] uniques = temp.uniq;\n  \
    \  long[] counts = temp.countUntil(uniques);\n    foreach(i, n; zip(uniques, counts))\
    \ \n    {\n        if(n >= i)\n        {\n            return i;\n        }\n \
    \   }\n    return -1L;\n}", "{\n  auto m = map!(a => a, long, long)();\n  foreach(e;\
    \ lst)\n  {\n    if(m.count(e) == 0)\n      m[e] = 1;\n    else\n      m[e] +=\
    \ 1;\n  }\n  long max = -1;\n  long maxNum = -1;\n  foreach(e; m)\n  {\n    if(e.value\
    \ > e.key && e.value >= max)\n    {\n      max = e.value;\n      maxNum = e.key;\n\
    \    }\n  }\n  return maxNum;\n}", "{\n    if (lst.length == 0) return -1;\n \
    \   else if (lst.length == 1) return lst[0];\n    // This is because the largest\
    \ number in the array will not be greater than \n    // the length of the array.\n\
    \    int[] count = new int[lst.length + 1];\n    foreach (x; lst)\n    {\n   \
    \     count[x]++;\n    }\n    // find the max value\n    // I could just return\
    \ the index of the max value and not use the array\n    // however, I don't see\
    \ the point.\n    int max_val = count[0];\n    foreach (i, x; count)\n    {\n\
    \        if (x > max_val)\n        {\n            max_val = x;\n        }\n  \
    \  }\n    return max_val;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
