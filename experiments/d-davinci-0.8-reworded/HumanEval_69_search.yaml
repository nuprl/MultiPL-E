name: HumanEval_69_search
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a non-empty\
  \ array of positive integers. Return the greatest integer that is greater than \n\
  \    zero, and has a frequency greater than or equal to the value of the integer\
  \ itself. \n    The frequency of an integer is the number of times it appears in\
  \ the array.\n    If no such a value exist, return -1.\n    Examples:\n    >>> search([4L,\
  \ 1L, 2L, 2L, 3L, 1L])\n    2L\n    >>> search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L,\
  \ 4L])\n    3L\n    >>> search([5L, 5L, 4L, 4L, 4L])\n    -1L\n    \n*/\nlong search(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = search;\n\n    assert(candidate([5L, 5L,\
  \ 5L, 5L, 1L]) == 1L);\n    assert(candidate([4L, 1L, 4L, 1L, 4L, 4L]) == 4L);\n\
  \    assert(candidate([3L, 3L]) == -1L);\n    assert(candidate([8L, 8L, 8L, 8L,\
  \ 8L, 8L, 8L, 8L]) == 8L);\n    assert(candidate([2L, 3L, 3L, 2L, 2L]) == 2L);\n\
  \    assert(candidate([2L, 7L, 8L, 8L, 4L, 8L, 7L, 3L, 9L, 6L, 5L, 10L, 4L, 3L,\
  \ 6L, 7L, 1L, 7L, 4L, 10L, 8L, 1L]) == 1L);\n    assert(candidate([3L, 2L, 8L, 2L])\
  \ == 2L);\n    assert(candidate([6L, 7L, 1L, 8L, 8L, 10L, 5L, 8L, 5L, 3L, 10L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 3L, 6L, 5L, 6L, 4L]) == -1L);\n    assert(candidate([6L,\
  \ 9L, 6L, 7L, 1L, 4L, 7L, 1L, 8L, 8L, 9L, 8L, 10L, 10L, 8L, 4L, 10L, 4L, 10L, 1L,\
  \ 2L, 9L, 5L, 7L, 9L]) == 1L);\n    assert(candidate([1L, 9L, 10L, 1L, 3L]) == 1L);\n\
  \    assert(candidate([6L, 9L, 7L, 5L, 8L, 7L, 5L, 3L, 7L, 5L, 10L, 10L, 3L, 6L,\
  \ 10L, 2L, 8L, 6L, 5L, 4L, 9L, 5L, 3L, 10L]) == 5L);\n    assert(candidate([1L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 10L, 6L, 4L, 3L, 5L, 8L, 2L, 4L, 2L, 8L,\
  \ 4L, 6L, 10L, 4L, 2L, 1L, 10L, 2L, 1L, 1L, 5L]) == 4L);\n    assert(candidate([2L,\
  \ 10L, 4L, 8L, 2L, 10L, 5L, 1L, 2L, 9L, 5L, 5L, 6L, 3L, 8L, 6L, 4L, 10L]) == 2L);\n\
  \    assert(candidate([1L, 6L, 10L, 1L, 6L, 9L, 10L, 8L, 6L, 8L, 7L, 3L]) == 1L);\n\
  \    assert(candidate([9L, 2L, 4L, 1L, 5L, 1L, 5L, 2L, 5L, 7L, 7L, 7L, 3L, 10L,\
  \ 1L, 5L, 4L, 2L, 8L, 4L, 1L, 9L, 10L, 7L, 10L, 2L, 8L, 10L, 9L, 4L]) == 4L);\n\
  \    assert(candidate([2L, 6L, 4L, 2L, 8L, 7L, 5L, 6L, 4L, 10L, 4L, 6L, 3L, 7L,\
  \ 8L, 8L, 3L, 1L, 4L, 2L, 2L, 10L, 7L]) == 4L);\n    assert(candidate([9L, 8L, 6L,\
  \ 10L, 2L, 6L, 10L, 2L, 7L, 8L, 10L, 3L, 8L, 2L, 6L, 2L, 3L, 1L]) == 2L);\n    assert(candidate([5L,\
  \ 5L, 3L, 9L, 5L, 6L, 3L, 2L, 8L, 5L, 6L, 10L, 10L, 6L, 8L, 4L, 10L, 7L, 7L, 10L,\
  \ 8L]) == -1L);\n    assert(candidate([10L]) == -1L);\n    assert(candidate([9L,\
  \ 7L, 7L, 2L, 4L, 7L, 2L, 10L, 9L, 7L, 5L, 7L, 2L]) == 2L);\n    assert(candidate([5L,\
  \ 4L, 10L, 2L, 1L, 1L, 10L, 3L, 6L, 1L, 8L]) == 1L);\n    assert(candidate([7L,\
  \ 9L, 9L, 9L, 3L, 4L, 1L, 5L, 9L, 1L, 2L, 1L, 1L, 10L, 7L, 5L, 6L, 7L, 6L, 7L, 7L,\
  \ 6L]) == 1L);\n    assert(candidate([3L, 10L, 10L, 9L, 2L]) == -1L);\n}\nvoid main(){}"
completions: ["{\n    auto freq = typeof(return)();\n    foreach(i; lst)\n    {\n\
    \        if(lst[i] <= 0)\n            continue;\n        freq[lst[i]]++;\n   \
    \ }\n    long max = -1;\n    foreach(key; freq.keys)\n    {\n        if(key >=\
    \ freq[key] && max < key)\n            max = key;\n    }\n    return max;\n}",
  "{\n    // We use an associative array as HashMap\n    int[long] freq = new int[long];\n\
    \    foreach(val; lst)\n    {\n        if(!freq.containsKey(val))\n          \
    \  freq[val] = 0;\n        ++freq[val];\n    }\n    // We convert the freq array\
    \ to a tuple and sort it in descending order\n    auto freq_tuple = freq.keys.zip(freq.values);\n\
    \    // This is just to make sure that elements of the same frequency are sorted\
    \ in descending order as well\n    freq_tuple.sort!((a, b) => a[1] == b[1] ? b[0]\
    \ > a[0] : b[1] > a[1]);\n    // foreach(val; freq_tuple)\n    // {\n    //  \
    \   pragma(msg, \"val = \", val);\n    // }\n    // We iterate over the sorted\
    \ array\n    foreach(tup; freq_tuple)\n    {\n        if(tup[0] > tup[1])\n  \
    \          break;\n        return tup[0];\n    }\n    return -1L;\n}", "{\n  \
    \  long[] lst_counts = lst.groupBy().map!(x => [x[0], x[1].length])\n        \
    \                            .filter!(x => x[1] >= x[0])\n                   \
    \                 .array;\n    long max_count = lst_counts.map!(x => x[1]).max();\n\
    \    long max_count_value = lst_counts.filter!(x => x[1] == max_count)[0][0];\n\
    \    return max_count_value;\n}", "{\n    import std.algorithm;\n    import std.array;\n\
    \    import std.conv;\n    import std.range;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.typecons;\n    //main code\n    return lst.groupBy!((e)\
    \ => e).filter!((e) => e.length >= e.key).max!((e) => e.key).key;\n}", "{ \n \
    \   if (lst.length == 0) return -1;\n    if (lst.length == 1) return -1;\n   \
    \ for (int i = 0; i < lst.length; i++) \n    {\n        long currentValue = lst[i];\n\
    \        if (currentValue == 0) continue;\n        long[] subArray = lst[i..$];\n\
    \        long frequency = 0;\n        foreach (var element; subArray) \n     \
    \   {\n            if (element == currentValue) frequency++;\n        }\n    \
    \    if (frequency >= currentValue) return currentValue;\n    }\n    return -1;\n\
    }", "{\n    int max = 0;\n    int maxIndex = -1;\n    int current = 0;\n    int[]\
    \ freq = new int[lst.length];\n    foreach(x; lst)\n    {\n        current = 0;\n\
    \        foreach(y; lst)\n        {\n            if(x == y)\n            {\n \
    \               current++;\n            }\n        }\n        freq[x] = current;\n\
    \        if(current >= x && current > max)\n        {\n            max = current;\n\
    \            maxIndex = x;\n        }\n    }\n    return maxIndex;\n}", "{\n \
    \   Map!(size_t, size_t) freq = new Map!(size_t, size_t);\n    foreach(immutable\
    \ long num; lst)\n    {\n        freq[num] = freq.count(num) + 1;\n    }\n   \
    \ long max = -1;\n    foreach(immutable long key; freq.keys)\n    {\n        if(freq[key]\
    \ >= key && key > max)\n        {\n            max = key;\n        }\n    }\n\
    \    return max;\n}\n// Test\nunittest\n{\n    assert(search([4L, 1L, 2L, 2L,\
    \ 3L, 1L]) == 2L);\n    assert(search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L]) ==\
    \ 3L);\n    assert(search([5L, 5L, 4L, 4L, 4L]) == -1L);\n}", "{\n    assert(\
    \ lst.length > 0 );\n    // Map of values and their frequencies.\n    auto freq\
    \ = lst.assocArray;\n    // Sort by descending frequency\n    auto sortedFreq\
    \ = std.sort(freq.byValue, (a, b) => a.value > b.value);\n    long[] result;\n\
    \    foreach(el; sortedFreq) \n    {\n        if(el.value >= el.key) \n      \
    \  {\n            result ~= el.key;\n        }\n    }\n    return result.empty\
    \ ? -1L : result[0];\n}", "{\n    return lst.groupBy!(id).sum!((k, v) => k*v.length)\n\
    \                    .max!((a, b) => a > b && a >= a.first ? 1 : -1)\n       \
    \             .first;\n}", "{\n    import std.range;\n    int max = 0;\n    foreach(int\
    \ x; lst)\n    {\n        if(x > max)\n            max = x;\n    }\n    int[]\
    \ stats = new int[max+1];\n    foreach(int x; lst)\n    {\n        stats[x]++;\n\
    \    }\n    foreach(int x; lst)\n    {\n        if(stats[x] >= x)\n          \
    \  return x;\n    }\n    return -1;\n}", "{\n    return lst.map!(a => tuple(a,\
    \ lst.count(a))).map!(a => tuple(a[0], a[1] >= a[0] ? a[1] : -1L)).filter!(a =>\
    \ a[1] > 0L).length > 0 ? lst.map!(a => tuple(a, lst.count(a))).map!(a => tuple(a[0],\
    \ a[1] >= a[0] ? a[1] : -1L)).filter!(a => a[1] > 0L).sort!(b => b[1] < b[1]).back[0]\
    \ : -1L;\n}", "{\n    long value = 0;\n    long number = 0;\n    foreach(k; lst)\n\
    \    {\n        if(std.algorithm.count(lst, k) >= k)\n        {\n            value\
    \ = k;\n            break;\n        }\n    }\n    return value != 0 ? value :\
    \ -1;\n}", "{\n    foreach(elem; lst) {\n        if(elem <= lst.count(elem))\n\
    \            return elem;\n    }\n    return -1;\n}", "{\n    long freq;\n   \
    \ long result = -1;\n    long[] uniq = lst.uniq;\n    foreach(long i; uniq)\n\
    \    {\n        freq = lst.count(i);\n        if(freq >= i && i > result)\n  \
    \      {\n            result = i;\n        }\n    }\n    return result;\n}", "{\n\
    \    auto dict = new SortedMap!(long, long)();\n    foreach(n; lst)\n    {\n \
    \       if(dict.find(n) != dict.end)\n        {\n            dict[n] = dict[n]\
    \ + 1;\n        }\n        else\n        {\n            dict[n] = 1;\n       \
    \ }\n    }\n    foreach(i; dict.byKey)\n    {\n        if(i.value > i.key)\n \
    \       {\n            return i.key;\n        }\n    }\n    return -1;\n}", "{\n\
    \    int result = lst.length;\n    for (int i = lst.length; i >= 0; i--)\n   \
    \ {\n        int count = 0;\n        for (int j = 0; j < lst.length; j++)\n  \
    \      {\n            if (lst[j] == i)\n            {\n                count++;\n\
    \            }\n        }\n        if (count >= i)\n        {\n            result\
    \ = i;\n            break;\n        }\n    }\n    if (result != lst.length)\n\
    \    {\n        return result;\n    }\n    else\n    {\n        return -1;\n \
    \   }\n}", "{\n    long[] lst_num = new long[lst.length];\n    long[] lst_count\
    \ = new long[lst.length];\n    long result = -1L;\n    long count = 1L;\n    long\
    \ k = 1L;\n    long z = 0L;\n    long num = 0L;\n    long count2 = 0L;\n    long\
    \ num2 = 0L;\n    lst_num[0] = lst[0];\n    for (long i = 1L; i < lst.length;\
    \ i++)\n    {\n        for (long j = 0L; j < k; j++)\n        {\n            if\
    \ (lst[i] == lst_num[j])\n            {\n                count = count + 1L;\n\
    \                count2 = count;\n                num2 = lst[i];\n           \
    \     lst_count[j] = count;\n                z = 1L;\n            }\n        }\n\
    \        if (z == 0L)\n        {\n            lst_num[k] = lst[i];\n         \
    \   lst_count[k] = 1L;\n            k = k + 1L;\n        }\n        z = 0L;\n\
    \        count = 1L;\n    }\n    for (long i = 0L; i < k; i++)\n    {\n      \
    \  if (lst_count[i] == lst_num[i])\n        {\n            if (lst_num[i] > num)\n\
    \            {\n                num = lst_num[i];\n            }\n        }\n\
    \    }\n    if (num == 0L)\n    {\n        result = -1L;\n    }\n    else\n  \
    \  {\n        result = num;\n    }\n    return result;\n}", "{\n    long number\
    \ = 0L;\n    long f = 0L;\n    for(long i = 0L; i < lst.length; i++)\n    {\n\
    \        long counter = 0L;\n        long temp = lst[i];\n        for(long j =\
    \ 0L; j < lst.length; j++)\n        {\n            if(temp == lst[j])\n      \
    \      {\n                counter++;\n            }\n        }\n        if(counter\
    \ >= temp && counter > f)\n        {\n            number = temp;\n           \
    \ f = counter;\n        }\n    }\n    if(number == 0L)\n    {\n        return\
    \ -1L;\n    }\n    return number;\n}\n// by omegacrash\nlong search(long[] a)\
    \ \n{\n    Map<long, long> m = new Map.fromArray(a);\n    foreach(k; m.keys())\
    \ \n    {\n        if(m[k] >= k)\n        {\n            return k;\n        }\n\
    \    }\n    return -1L;\n}\n// by yubo\nlong search(long[] arr) \n{\n    long\
    \ greatest = 0L;\n    foreach(n; arr) \n    {\n        if(n > greatest)\n    \
    \    {\n            greatest = n;\n        }\n    }\n    foreach(n; arr) \n  \
    \  {\n        if(n == greatest)\n        {\n            return n;\n        }\n\
    \    }\n    return -1L;\n}\n// by frankyman\nlong search(long[] arr) \n{\n   \
    \ long[] temp = arr.dup;\n    temp.sort;\n    long[] uniques = temp.uniq;\n  \
    \  long[] counts = temp.countUntil(uniques);\n    foreach(i, n; zip(uniques, counts))\
    \ \n    {\n        if(n >= i)\n        {\n            return i;\n        }\n \
    \   }\n    return -1L;\n}", "{\n  auto m = map!(a => a, long, long)();\n  foreach(e;\
    \ lst)\n  {\n    if(m.count(e) == 0)\n      m[e] = 1;\n    else\n      m[e] +=\
    \ 1;\n  }\n  long max = -1;\n  long maxNum = -1;\n  foreach(e; m)\n  {\n    if(e.value\
    \ > e.key && e.value >= max)\n    {\n      max = e.value;\n      maxNum = e.key;\n\
    \    }\n  }\n  return maxNum;\n}", "{\n    if (lst.length == 0) return -1;\n \
    \   else if (lst.length == 1) return lst[0];\n    // This is because the largest\
    \ number in the array will not be greater than \n    // the length of the array.\n\
    \    int[] count = new int[lst.length + 1];\n    foreach (x; lst)\n    {\n   \
    \     count[x]++;\n    }\n    // find the max value\n    // I could just return\
    \ the index of the max value and not use the array\n    // however, I don't see\
    \ the point.\n    int max_val = count[0];\n    foreach (i, x; count)\n    {\n\
    \        if (x > max_val)\n        {\n            max_val = x;\n        }\n  \
    \  }\n    return max_val;\n}", "{\n    // Create a map to store the frequencies\
    \ of each integer\n    auto ctr = Counter(lst);\n    // Create a list of integers\
    \ from the map keys\n    auto int_list = ctr.keys();\n    // Create a list of\
    \ integer frequencies from the map values\n    auto freq_list = ctr.values();\n\
    \    // Create a new range that is equal to the element-wise division \n    //\
    \ of the frequency list and the integer list\n    auto prod = map!(a => a / b,\
    \ freq_list, int_list);\n    // Take the maximum element in the new range and\
    \ check if it is greater than or equal to the value of its index\n    // If so,\
    \ return the value of its index\n    auto idx = max(prod);\n    if (idx >= prod[idx])\n\
    \        return idx;\n    // Otherwise, return -1\n    else \n        return -1;\n\
    }", "{\n    long result = -1L;\n    int maxFrequency = 0;\n    Map!int m = new\
    \ Map!int();\n    foreach(long i; lst)\n    {\n        int freq = m.getOrUpdate(i,\
    \ () => 0) + 1;\n        if(freq > maxFrequency && freq >= i)\n        {\n   \
    \         maxFrequency = freq;\n            result = i;\n        }\n    }\n  \
    \  return result;\n}", "{\n    int result = 0;\n    int count = 0;\n    int previous\
    \ = 0;\n    auto frequency = countFrequency(lst);\n    for(int i = 0; i < frequency.length;\
    \ i++)\n    {\n        if(frequency[i].value > result && frequency[i].value >=\
    \ frequency[i].key)\n        {\n            result = frequency[i].value;\n   \
    \         count = frequency[i].key;\n        }\n        else if(frequency[i].value\
    \ == previous && frequency[i].value >= frequency[i].key)\n        {\n        \
    \    result = frequency[i].value;\n            count = frequency[i].key;\n   \
    \     }\n        previous = frequency[i].value;\n    }\n    if(result == 0)\n\
    \    {\n        return -1;\n    }\n    return count;\n}", "{\n    import std.algorithm.iteration;\n\
    \    import std.algorithm.sorting;\n    import std.range;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.algorithm;\n    import\
    \ std.container;\n    import std.string;\n    import std.algorithm.comparison;\n\
    \    import std.algorithm.mutation;\n    import std.datetime;\n    import std.math;\n\
    \    import std.typecons;\n    \n    /*\n        ======================================================\n\
    \        This solution is not in the spirit of the question.\n        ======================================================\n\
    \    */\n    if (lst.length <= 1)\n        return -1;\n    \n    lst.sort;\n \
    \   auto ret = long.max;\n    foreach (i; 0 .. lst.length-1)\n    {\n        if\
    \ (lst[i] == lst[i+1])\n        {\n            auto j = i;\n            while\
    \ (lst[j] == lst[j+1])\n                j++;\n            ret = min(ret, lst[i]);\n\
    \            i = j;\n        }\n    }\n    return ret == long.max ? -1 : ret;\n\
    }", "{\n    return lst.sort.zip(lst.dup).group.map!((kv) => (kv[0], kv[1].length)).filter!((kv)\
    \ => (kv[1] >= kv[0])).sort.back;\n}", "{\n    long[] arr = new long[lst.length];\n\
    \    foreach(i; 0 .. lst.length)\n    {\n        arr[i] = lst[i];\n    }\n   \
    \ arr.sort;\n    long result = -1L;\n    for(long i = arr.length-1; i >= 0; i--)\n\
    \    {\n        if(arr[i] == arr[i-1])\n        {\n            if(result < arr[i])\n\
    \            {\n                result = arr[i];\n            }\n        }\n \
    \   }\n    return result;\n}", "{\n    auto freq = map!(a => a.length)(group(lst));\n\
    \    alias freqSorted = sort!((x, y) => x.value > y.value)(freq);\n    foreach(kvp;\
    \ freqSorted)\n    {\n        if(kvp.value >= kvp.key)\n            return kvp.key;\n\
    \    }\n    return -1L;\n}", "{\n    // Initialize a map\n    Map!(long,long)\
    \ m = new Map!(long,long);\n    // Iterate over the list\n    foreach(e; lst)\n\
    \    {\n        // If the element is in the map increase its value by 1\n    \
    \    if(m.count(e))\n        {\n            m[e] += 1;\n        }\n        //\
    \ Else insert it with a value of 1\n        else\n        {\n            m[e]\
    \ = 1;\n        }\n    }\n    // Initialize a tuple with the first element of\
    \ the map\n    long res = m.front.value[0];\n    // Iterate over the map\n   \
    \ foreach(e; m)\n    {\n        // If the frequency is greater than or equal to\
    \ the value, set res to the value\n        if(e.value[1] >= e.value[0] && e.value[0]\
    \ > res)\n        {\n            res = e.value[0];\n        }\n    }\n    // If\
    \ res is still 1 then return -1\n    if(res == 1)\n    {\n        return -1;\n\
    \    }\n    // Return res\n    return res;\n}", "{\n    auto res = lst.sort()\n\
    \                .group\n                .filter!(e => e.length >= e[0])\n   \
    \             .map!(e => e[0])\n                .max\n                .front;\n\
    \    return res ? res : -1L;\n}", "{\n    Map!(long,long)(\"a\".idup, \"b\".idup)(\"\
    a\".idup)(\"b\".idup);\n    return lst.sort.dup.zip.map!((i) => [i[0], i[1].length]).filter!((i)\
    \ => i[1] >= i[0]).length \n           ? lst.sort.dup.zip.map!((i) => [i[0], i[1].length]).filter!((i)\
    \ => i[1] >= i[0]).sort.map!((i) => i[0]).back \n           : -1L;\n}\n \n/*\n\
    \    You are given a non-empty array of positive integers. Return the greatest\
    \ integer that is greater than \n    zero, and has a frequency greater than or\
    \ equal to the value of the integer itself. \n    The frequency of an integer\
    \ is the number of times it appears in the array.\n    If no such a value exist,\
    \ return -1.\n    Examples:\n    >>> search([4L, 1L, 2L, 2L, 3L, 1L])\n    2L\n\
    \    >>> search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L])\n    3L\n    >>> search([5L,\
    \ 5L, 4L, 4L, 4L])\n    -1L\n    \n*/\nlong search(long[] lst) \n{\n    Map!(long,long)(\"\
    a\".idup, \"b\".idup)(\"a\".idup)(\"b\".idup);\n    return lst.sort.dup.zip.map!((i)\
    \ => [i[0], i[1].length]).filter!((i) => i[1] >= i[0]).length \n           ? lst.sort.dup.zip.map!((i)\
    \ => [i[0], i[1].length]).filter!((i) => i[1] >= i[0]).sort.map!((i) => i[0]).back\
    \ \n           : -1L;\n}\n \n/*\n    You are given a non-empty array of positive\
    \ integers. Return the greatest integer that is greater than ", "{\n    Map!(long,\
    \ long) f = new Map!(long, long);\n    foreach(long l; lst)\n    {\n        if(f.hasKey(l))\n\
    \        {\n            f[l] += 1;\n        }\n        else\n        {\n     \
    \       f[l] = 1;\n        }\n    }\n    long s = -1;\n    foreach(long l; f.keys)\n\
    \    {\n        if(f[l] >= l && l > s)\n        {\n            s = l;\n      \
    \  }\n    }\n    return s;\n}", "{\n    auto d = std.algorithm.group(lst).by!((a,\
    \ b) => a == b);\n    auto max = d.max!((a, b) => a.length > b.length).length;\n\
    \    return d.filter!((k, v) => k > 0 && v.length >= k).max!((a, b) => a.key >\
    \ b.key).key;\n}", "{\n    immutable long[] l = lst.dup;\n    long min = l[0];\n\
    \    long max = l[0];\n    long[long] d = new long[long];\n    foreach(i; l)\n\
    \    {\n        max = max(max, i);\n        min = min(min, i);\n        d[i]++;\n\
    \    }\n    foreach(i; min..max)\n    {\n        if(d[i] >= i)\n            return\
    \ i;\n    }\n    return -1;\n}", "{\n    ulong[] freq;\n    freq = new ulong[uint.max];\n\
    \    foreach(ulong item; lst)\n    {\n        ++freq[item];\n    }\n    foreach(ulong\
    \ item; lst)\n    {\n        if(item <= freq[item])\n        {\n            return\
    \ cast(long)item;\n        }\n    }\n    return -1L;\n}", "{\n    long result\
    \ = -1L;\n    int[] counts = new int[lst.length];\n    int count = 0;\n    long[]\
    \ temp = new long[lst.length];\n    int tcount = 0;\n    //get frequencies\n \
    \   foreach(elem; lst)\n    {\n        counts[count] = lst.countUntil(elem, false);\n\
    \        count++;\n    }\n    //get unique values\n    foreach(elem; lst)\n  \
    \  {\n        if(elem > 0L && lst.countUntil(elem, false) >= elem)\n        {\n\
    \            temp[tcount] = elem;\n            tcount++;\n        }\n    }\n \
    \   //return max\n    if(tcount > 0)\n    {\n        result = temp[0];\n     \
    \   foreach(elem; temp)\n        {\n            if(elem > result)\n          \
    \  {\n                result = elem;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] sorted = lst.dup.sort();\n    long[] count = [0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,",
  "{\n    long freq = 0;\n    long[] num = new long[lst.length];\n    long[] f = new\
    \ long[lst.length];\n    long max = 0;\n    long[] c = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        num[i] = lst[i];\n \
    \   }\n    sort(num);\n    for (int i = 0; i < num.length; i++)\n    {\n     \
    \   for (int j = 0; j < num.length; j++)\n        {\n            if (num[i] ==\
    \ num[j])\n            {\n                f[i]++;\n            }\n        }\n\
    \    }\n    for (int i = 0; i < num.length; i++)\n    {\n        if (num[i] >\
    \ f[i])\n        {\n            max = num[i];\n        }\n    }\n    long result\
    \ = -1;\n    long[] index = new long[lst.length];\n    long[] f1 = new long[lst.length];\n\
    \    for (int i = 0; i < num.length; i++)\n    {\n        if (num[i] == max)\n\
    \        {\n            index[i] = num[i];\n        }\n    }\n    for (int i =\
    \ 0; i < index.length; i++)\n    {\n        for (int j = 0; j < num.length; j++)\n\
    \        {\n            if (index[i] == num[j])\n            {\n             \
    \   f1[i]++;\n            }\n        }\n    }\n    for (int i = 0; i < f1.length;\
    \ i++)\n    {\n        if (f1[i] == max)\n        {\n            result = f1[i];\n\
    \        }\n    }\n    return result;\n}", "{\n    long frequency = 0L;\n    long\
    \ greatestNumber = -1L;\n    long[] arr = new long[4];\n    foreach(element; lst)\n\
    \    {\n        arr[element]++;\n    }\n    int i = 0;\n    foreach(element; arr)\n\
    \    {\n        i++;\n        if(element >= i)\n        {\n            greatestNumber\
    \ = i;\n        }\n    }\n    return greatestNumber;\n}", "{\n    import std.array;\n\
    \    import std.algorithm;\n    import std.range;\n    auto arr = lst.dup;\n \
    \   arr.sort;\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n\
    \    {\n        if(arr[i] == arr[i+1])\n        {\n            count++;\n    \
    \    }\n        else\n        {\n            count++;\n            if(count >=\
    \ arr[i])\n            {\n                return arr[i];\n            }\n    \
    \        count = 0;\n        }\n    }\n    return -1;\n}", "{\n    /*\n    auto\
    \ freq = lst.group.map!(a => a.length)(a => a[0]);\n    return (freq.array.filter!(a\
    \ => a[0] >= a[1])(a => a[0]).empty) ? -1L : freq.find!(a => a[0] >= a[1])(a =>\
    \ a[0]);\n    */\n    return lst.group.map!(a => a.length)(a => a[0]).filter!(a\
    \ => a[0] >= a[1])(a => a[0]).empty ? -1L : lst.group.map!(a => a.length)(a =>\
    \ a[0]).find!(a => a[0] >= a[1])(a => a[0]);\n}", "{\n    auto t = lst.group(a\
    \ => a);\n    return t.pumpMap(a => tuple(a[0], a[1].length)).pumpMap(a => a[0]\
    \ > a[1] ? -1L : a[0]).max;\n}", "{\n    ulong max = (ulong)lst.max;\n    ulong[]\
    \ count = new ulong[max + 1];\n    foreach(a; lst)\n    {\n        count[a]++;\n\
    \    }\n    foreach(a; iota(0L, max + 1))\n    {\n        if(count[a] >= a)\n\
    \        {\n            return a;\n        }\n    }\n    return -1L;\n}", "{\n\
    \    // create array of structs, struct contains value and it's frequency\n  \
    \  size_t n = lst.length;\n    Tuple!(long, long)[] arr = new Tuple!(long, long)[n];\n\
    \    for (size_t i = 0; i < n; i++)\n    {\n        bool found = false;\n    \
    \    for (size_t j = 0; j < n; j++)\n        {\n            if (arr[j].field0\
    \ == lst[i])\n            {\n                arr[j].field1++;\n              \
    \  found = true;\n                break;\n            }\n        }\n        if\
    \ (!found)\n        {\n            arr[i].field0 = lst[i];\n            arr[i].field1\
    \ = 1;\n        }\n    }\n    // sort structs based on frequency\n    struct Sort\n\
    \    {\n        long _field0;\n        long _field1;\n        bool opCmp(ref const(Sort)\
    \ s) const \n        {\n            return _field1 > s._field1;\n        }\n \
    \   }\n    auto sort_arr = arr.map!(a => Sort(a.field0, a.field1)).array;\n  \
    \  sort_arr.sort;\n    // remove all elements that have frequency less than value\n\
    \    // return max(value)\n    size_t m = sort_arr.length;\n    for (size_t i\
    \ = 0; i < m; i++)\n    {\n        if (sort_arr[i]._field1 < sort_arr[i]._field0)\n\
    \        {\n            sort_arr.removeAt(i);\n            i--;\n            m--;\n\
    \        }\n    }\n    if (sort_arr.length == 0) return -1;\n    return sort_arr[0]._field0;\n\
    }", "{\n    immutable sz = lst.length;\n    if (sz < 1) return -1L;\n    if (sz\
    \ == 1) return lst[0] <= 1L ? lst[0] : -1L;\n    auto h = new int[sz+1];\n   \
    \ long max = 0L;\n    foreach (val; lst) {\n        h[val]++;\n        if (val\
    \ > max) max = val;\n    }\n    for (long i = max; i > 0L; i--) {\n        if\
    \ (h[i] >= i) return i;\n    }\n    return -1L;\n}", "{\n    auto d = typeof(lst).init;\n\
    \    foreach(el; lst)\n    {\n        if(d.hasKey(el))\n        {\n          \
    \  d[el]++;\n        }\n        else\n        {\n            d[el] = 1;\n    \
    \    }\n    }\n    long max = 0;\n    foreach(el; d)\n    {\n        if(el.value\
    \ >= el.key && el.key > max)\n        {\n            max = el.key;\n        }\n\
    \    }\n    return max > 0 ? max : -1;\n}", "{\n    return lst.group.length.filter!(a\
    \ => a.length >= a[0] && a[0] > 0).min;\n}", "{\n    // Create a map that counts\
    \ the number of occurrences of each element\n    Map<long, long> counts = lst.groupBy!((x)\
    \ => x);\n    // Sort the keys of the map in descending order by the number of\
    \ occurrences.\n    // Then if there are any keys that have a value greater than\
    \ or equal to their key, return the first one\n    return counts.keys.sort!((a,\
    \ b) => counts[b] - counts[a]).filter!((x) => x <= counts[x]).front;\n}", "{\n\
    \    import std.range;\n    import std.algorithm;\n    import std.algorithm.comparison;\n\
    \    import std.array;\n    import std.container;\n    import std.algorithm.iteration;\n\
    \    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.algorithm.searching;\n    import std.functional;\n    import std.meta;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.algorithm.comparison;\n\
    \    import std.array;\n    import std.container;\n    import std.algorithm.iteration;\n\
    \    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.algorithm.searching;\n    import std.functional;\n    import std.meta;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.algorithm.comparison;\n\
    \    import std.array;\n    import std.container;\n    import std.algorithm.iteration;\n\
    \    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.algorithm.searching;\n    import std.functional;\n    import std.meta;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.algorithm.comparison;\n\
    \    import std.array;\n    import std.container;\n    import std.algorithm.iteration;\n\
    \    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.algorithm.searching;\n    import std.functional;\n    import std.meta;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.algorithm.comparison;\n\
    \    import std.array;\n    import std.container;\n    import std.algorithm.iteration;\n\
    \    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.algorithm.searching;\n    import std.functional;\n    import std.meta;\n\
    \    import std.range;\n    import", "{\n    long freq = 0;\n    long maxNum =\
    \ 0;\n    long[] freqArr = new long[lst.length];\n    for(long i = 0; i < lst.length;\
    \ i++)\n    {\n        for(long j = 0; j < lst.length; j++)\n        {\n     \
    \       if(lst[i] == lst[j])\n            {\n                freq++;\n       \
    \     }\n        }\n        freqArr[i] = freq;\n        freq = 0;\n    }\n   \
    \ for(long i = 0; i < lst.length; i++)\n    {\n        if(lst[i] <= freqArr[i])\n\
    \        {\n            maxNum = max(maxNum, lst[i]);\n        }\n    }\n    if(maxNum\
    \ == 0)\n    {\n        return -1;\n    }\n    return maxNum;\n}", "{\n    //\
    \ (value, frequency) pair\n    alias Pair = Tuple!(long, long);\n    Pair[] result\
    \ = new Pair[];\n    foreach(value; lst)\n    {\n        if (value == 0) \n  \
    \          continue;\n        bool exists = false;\n        foreach(ref p; result)\n\
    \        {\n            if (p[0] == value)\n            {\n                p[1]++;\n\
    \                exists = true;\n                break;\n            }\n     \
    \   }\n        if (!exists)\n            result ~= Pair(value, 1);\n    }\n  \
    \  long max = 0;\n    foreach(ref p; result)\n    {\n        if (p[0] <= p[1]\
    \ && p[0] > max)\n            max = p[0];\n    }\n    return max != 0 ? max :\
    \ -1;\n}\nunittest\n{\n    assert(search([4L, 1L, 2L, 2L, 3L, 1L]) == 2L);\n \
    \   assert(search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L]) == 3L);\n    assert(search([5L,\
    \ 5L, 4L, 4L, 4L]) == -1L);\n}", "{\n    auto max = 0L;\n    auto dict = new TypeTuple!(long,\
    \ long)();\n    foreach(i; lst)\n    {\n        if(!dict.find(i))\n        {\n\
    \            dict[i] = 1L;\n        }\n        else\n        {\n            dict[i]++;\n\
    \        }\n        if(dict[i] >= i && dict[i] > max)\n        {\n           \
    \ max = i;\n        }\n    }\n    return max == 0L ? -1L : max;\n}", "{\n    if\
    \ (lst.empty)\n        return -1L;\n    int max = lst.max;\n    int min = lst.min;\n\
    \    int[] freq = new int[max - min + 1];\n    foreach (var x; lst)\n        freq[x\
    \ - min]++;\n    foreach (var x; lst)\n    {\n        if (x - min < freq.length\
    \ && freq[x - min] >= x)\n            return x;\n    }\n    return -1L;\n}", "{\n\
    \    long[] lst2 = lst.sort();\n    long val = 1;\n    long max = -1;\n    long\
    \ count = 0;\n    foreach(l; lst2)\n    {\n        if(l == val)\n        {\n \
    \           count += 1;\n        }\n        else\n        {\n            if(count\
    \ >= val)\n            {\n                max = val;\n            }\n        \
    \    count = 1;\n            val = l;\n        }\n    }\n    if(count >= val)\n\
    \    {\n        max = val;\n    }\n    return max;\n}", "{\n    immutable dict\
    \ = to!(immutable(long[]))(lst.groupBy!(a => a)).groupBy!(a => a[1].length).idup;\n\
    \    return dict.length == 0 ? -1L : dict.keys.max();\n}", "{\n    enum type =\
    \ AliasSeq!(int[long], long[]);\n    type ptr = new int[long](lst.length);\n \
    \   int i = 0;\n    while(i < lst.length) {\n        ptr[lst[i]] += 1;\n     \
    \   i++;\n    }\n    i = 0;\n    long res = -1;\n    while(i < ptr.length) {\n\
    \        if(ptr[i] >= i && ptr[i] > 0) {\n            res = i;\n        }\n  \
    \      i++;\n    }\n    return res;\n}\n/*\n    We need a way to add elements\
    \ to a set. In order to add an element to a set, we need to check \n    whether\
    \ there are elements to the left or right of the element that is being added.\
    \ \n    We also need to account for the fact that the element to the left or right\
    \ may have been merged \n    with another element as a result of a prior add.\
    \ \n    If such elements exist and are greater than the element being added, we\
    \ add the element to a \n    \"pseudo-set\" and move the element to the left or\
    \ right, respectively. \n    We repeat this process until we have added the element\
    \ to an appropriate position. \n    Once we have done so, we return a new set\
    \ that contains the values in the \"pseudo-set\" and the \n    new element.\n\
    \    \n    >>> add(emptySet, 2L)\n    Set(2L)\n    >>> add(Set(3L), 2L)\n    Set(2L,\
    \ 3L)\n    >>> add(Set(2L, 3L), 4L)\n    Set(2L, 3L, 4L)\n    >>> add(Set(2L,\
    \ 3L, 4L), 5L)\n    Set(2L, 3L, 4L, 5L)\n    >>> add(Set(2L, 3L, 4L, 5L), 3L)\n\
    \    Set(2L, 3L, 3L, 4L, 5L)\n    >>> add(Set(2L, 3L, 3L, 4L, 5L), 3L)\n    Set(2L,\
    \ 3L, 3L, 3L, 4L", "{\n    long frq = 0L;\n    long maxFrq = -1L;\n    int maxIndex\
    \ = -1;\n    foreach(i; 0 .. lst.length)\n    {\n        foreach(j; 0 .. lst.length)\n\
    \        {\n            if(lst[i] == lst[j])\n            {\n                frq++;\n\
    \            }\n        }\n        if(lst[i] < frq)\n        {\n            if(frq\
    \ > maxFrq)\n            {\n                maxFrq = frq;\n                maxIndex\
    \ = i;\n            }\n        }\n        frq = 0L;\n    }\n    if(maxIndex ==\
    \ -1)\n    {\n        return -1L;\n    }\n    return lst[maxIndex];\n}", "{\n\
    \    immutable long max = lst.length;\n    long[] fst = lst.dup;\n    fst.sort;\n\
    \    long cur = 0L;\n    long cnt = 0L;\n    for(long i = 0L; i < max; i++)\n\
    \    {\n        if(cur == fst[i])\n        {\n            cnt++;\n        }\n\
    \        else\n        {\n            if(cnt >= cur)\n            {\n        \
    \        return cur;\n            }\n            cur = fst[i];\n            cnt\
    \ = 1L;\n        }\n    }\n    if(cnt >= cur)\n    {\n        return cur;\n  \
    \  }\n    return -1L;\n}", "{\n    alias posinttuple = Tuple!(ulong,ulong);\n\
    \    auto tmparr = lst.map!(a => Tuple!(ulong,ulong)(a,a)).array;\n    auto tmp\
    \ = tmparr.filter!(a => a[0] == a[1]).array;\n    tmp.sort!((a,b) => a[0] < b[0]);\n\
    \    return tmp.empty ? -1L : tmp[0][0];\n}", "{\n    /* \n    // see search_short.d",
  "{\n    immutable long N = lst.length;\n    immutable bool max_is_not_unique = N%2\
    \ == 0 && lst[N/2] == lst[N/2-1];\n    immutable long max_val = lst[(N-1)/2];\n\
    \    immutable long cnt = count(lst, max_val);\n    return max_is_not_unique ||\
    \ cnt >= max_val ? -1L : max_val;\n}", "{\n\tauto d = lst.groupBy;\n\tlong num\
    \ = -1;\n\tfor( long i=0; i<lst.length; i++)\n\t{\n\t\tif( d[lst[i]].length >=\
    \ lst[i] && lst[i] > num)\n\t\t\tnum = lst[i];\n\t}\n\treturn num;\n}", "{\n \
    \   if (lst.length == 0) return -1;\n    long result = -1;\n    long max_freq\
    \ = 0;\n    foreach (immutable int i; lst) \n    {\n        long freq = lst.count(i);\n\
    \        if (i > 0 && i <= freq && freq > max_freq)\n        {\n            result\
    \ = i;\n            max_freq = freq;\n        }\n    }\n    return result;\n}",
  "{\n    long max = 0;\n    long[] countList = new long[lst.length];\n    foreach(idx,\
    \ item; lst)\n    {\n        foreach(idx2, item2; lst)\n        {\n          \
    \  if(item == item2)\n            {\n                countList[idx]++;\n     \
    \       }\n        }\n    }\n    foreach(idx, item; countList)\n    {\n      \
    \  if(countList[idx] >= idx + 1)\n        {\n            max = idx + 1;\n    \
    \    }\n    }\n    if(max == 0)\n    {\n        return -1;\n    }\n    return\
    \ max;\n}", "{\n    long n = lst.length;\n    int[] freq = new int[n];\n    int\
    \ maxFreq = 0;\n    int i = 0;\n    int maxIdx = -1;\n    while(i < n)\n    {\n\
    \        freq[lst[i] - 1]++;\n        if(freq[lst[i] - 1] > maxFreq)\n       \
    \ {\n            maxFreq = freq[lst[i] - 1];\n            maxIdx = lst[i] - 1;\n\
    \        }\n        i++;\n    }\n    return maxIdx + 1 == lst[maxIdx] ? maxIdx\
    \ + 1 : -1;\n}", "{\n    auto m = max(lst);\n    return m <= lst.length ? m :\
    \ -1L;\n}", "{\n    enum result = long.init;\n    foreach(freq; map!(a => a.length)(group(lst.dup.sort())))\n\
    \    {\n        if(freq >= lst.length)\n            return -1L;\n        if(freq\
    \ >= lst[freq-1])\n            result = lst[freq-1];\n    }\n    return result;\n\
    }", "{\n    bool found = false;\n    long maxFreq = -1;\n    long maxNum = -1;\n\
    \    int i;\n    int j;\n    int lstLen = lst.length;\n    int thisNumber;\n \
    \   int thisNumberFrequency;\n    for (i = 0; i < lstLen; i++)\n    {\n      \
    \  thisNumber = lst[i];\n        thisNumberFrequency = 0;\n        for (j = 0;\
    \ j < lstLen; j++)\n        {\n            if (lst[j] == thisNumber)\n       \
    \     {\n                thisNumberFrequency += 1;\n            }\n        }\n\
    \        if (thisNumberFrequency >= thisNumber)\n        {\n            if (thisNumberFrequency\
    \ > maxFreq)\n            {\n                maxFreq = thisNumberFrequency;\n\
    \                maxNum = thisNumber;\n                found = true;\n       \
    \     }\n        }\n    }\n    if (found)\n    {\n        return maxNum;\n   \
    \ }\n    else\n    {\n        return -1;\n    }\n}", "{\n    long result = -1L;\n\
    \    long[] elements = new long[0];\n    long[] times = new long[0];\n    foreach(long\
    \ i; lst) \n    {\n        auto pos = find!(l => l == i)(elements);\n        if(pos\
    \ != elements.length) \n        {\n            times[pos] += 1L;\n        }\n\
    \        else \n        {\n            elements ~= i;\n            times ~= 1L;\n\
    \        }\n    }\n    foreach(long i; times) \n    {\n        if(i >= elements[i])\
    \ \n        {\n            result = elements[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n    immutable long mostFrequent = max(lst);\n    immutable\
    \ long frequency = count(lst, mostFrequent);\n    immutable long value = mostFrequent;\n\
    \    return frequency >= value ? value : -1L;\n}", "{\n    long[] freq = lst.dup;\n\
    \    long[] nums = lst.dup;\n    int[] cnt = new int[freq.length];\n    int[]\
    \ pos = new int[freq.length];\n    quickSort(freq, cnt, pos);\n    foreach(i;\
    \ 0 .. freq.length)\n    {\n        if(cnt[i] >= freq[i])\n            return\
    \ freq[i];\n    }\n    return -1L;\n}", "{\n    long[] d = new long[lst.length];\n\
    \    foreach(a; lst)\n    {\n        d[a] += 1;\n    }\n    foreach(a; 0..d.length)\n\
    \    {\n        if(d[a] >= a)\n        {\n            return a;\n        }\n \
    \   }\n    return -1;\n}", "{\n    auto w = ctUnzip!(lst);\n    auto x = w[0];\n\
    \    auto y = w[1];\n    auto z = zip(x, y);\n    auto z1 = z.filter!(a => a[1]\
    \ >= a[0]);\n    return max(z1.map!(a => a[0]).array);\n}", "{\n    int max =\
    \ 0;\n    foreach(value; lst) \n    {\n        if(value > max)\n            max\
    \ = value;\n    }\n    int[] freq = new int[max + 1];\n    foreach(value; lst)\
    \ \n    {\n        ++freq[value];\n    }\n    for(int i = max; i > 0; --i) \n\
    \    {\n        if(freq[i] >= i)\n            return i;\n    }\n    return -1;\n\
    }", "{\n    Map!(long, long)(\"a\"=> 1L, \"b\"=> 2L, \"c\"=>3L, \"d\"=>4L, \"\
    e\"=>5L, \"f\"=>6L, \"g\"=>7L, \"h\"=>8L, \"i\"=>9L, \"j\"=>10L, \"k\"=>11L, \"\
    l\"=>12L, \"m\"=>13L, \"n\"=>14L, \"o\"=>15L, \"p\"=>16L, \"q\"=>17L, \"r\"=>18L,\
    \ \"s\"=>19L, \"t\"=>20L, \"u\"=>21L, \"v\"=>22L, \"w\"=>23L, \"x\"=>24L, \"y\"\
    =>25L, \"z\"=>26L);\n    long ans = -1L;\n    long[] count = new long[26];\n \
    \   foreach(num; lst)\n    {\n        if(num == 0L) return 0L;\n        if(count[num-1L]\
    \ == 0L) count[num-1L] = 1L;\n        else count[num-1L]++;\n    }\n    for(long\
    \ i = count.length-1L; i >= 0L; i--)\n    {\n        if(count[i] >= i+1L) return\
    \ i+1L;\n    }\n    return ans;\n}", "{\n    long[long] dict = lst.array;\n  \
    \  dict.sort;\n    foreach(k, v; dict)\n    {\n        if(k <= v)\n        {\n\
    \            return k;\n        }\n    }\n    return -1;\n}", "{\n    int n =\
    \ lst.length;\n    int[] dict = new int[n];\n    for(int i = 0; i < n; i++) \n\
    \    {\n        dict[lst[i] - 1]++;\n    }\n    for(int i = 0; i < n; i++) \n\
    \    {\n        if(dict[i] >= i + 1)\n        {\n            return i + 1;\n \
    \       }\n    }\n    return -1;\n}", "{\n    auto m = std.algorithm.maxElement(lst);\n\
    \    auto s = std.algorithm.sort(lst, (a, b) => a > b);\n    auto c = std.algorithm.count(s,\
    \ m);\n    if (c >= m) return m;\n    return -1L;\n}", "{\n  auto res = lst.byEqual;\n\
    \  foreach(i; res)\n  {\n    //dprintln(i);\n    //dprintln(i.length);\n    if(i.length>=i[0])\n\
    \      return i[0];\n  }\n  return -1;\n}\n/*", "{\n  if (lst.length == 0) \n\
    \  {\n    return -1L;\n  }\n  auto dict = new Map!(long, long);\n  foreach (x;\
    \ lst) \n  {\n    if (dict.hasKey(x)) \n    {\n      dict[x]++;\n    }\n    else\
    \ \n    {\n      dict[x] = 1;\n    }\n  }\n  foreach (key; dict.keys) \n  {\n\
    \    if (key <= dict[key]) \n    {\n      return key;\n    }\n  }\n  return -1L;\n\
    }", "{\n    long[] dic = new long[200];\n    foreach(idx, item; lst)\n    {\n\
    \        dic[item] += 1;\n    }\n    long maxVal = 0;\n    long maxVal2 = 0;\n\
    \    long maxVal3 = 0;\n    foreach(idx, item; dic)\n    {\n        if(item >\
    \ maxVal && item > 0)\n        {\n            maxVal = item;\n            maxVal2\
    \ = idx;\n        }\n    }\n    foreach(idx, item; dic)\n    {\n        if(item\
    \ == maxVal && idx < maxVal2 && item > 0)\n        {\n            maxVal3 = idx;\n\
    \        }\n    }\n    if(maxVal3 > 0)\n    {\n        return maxVal3;\n    }\n\
    \    else if(maxVal2 > 0)\n    {\n        return maxVal2;\n    }\n    else\n \
    \   {\n        return -1;\n    }\n}", "{\n    int max = 0;\n    long result =\
    \ -1;\n    foreach(elem; lst)\n    {\n        auto[tuple, tuple2] = tuple(elem,\
    \ 0);\n        if(tuple.length > 0)\n        {\n            auto[tuple3, tuple4]\
    \ = tuple(tuple[0], 1);\n            if(elem > max)\n            {\n         \
    \       if(tuple4 >= tuple3)\n                {\n                    max = elem;\n\
    \                    result = tuple3;\n                }\n            }\n    \
    \    }\n    }\n    return result;\n}", "{ \n    // Initialise a map with count\
    \ of each number in the array\n    ulong[] counts = lst.counts;\n    // Now we\
    \ will take the max between the count and the number itself\n    ulong[] maxofcounts\
    \ = counts.map!(a => max(a.value, a.key));\n    // If the max of counts and number\
    \ is same as the number itself, then we will have to pick the biggest number\n\
    \    return maxofcounts.indMax;\n}", "{\n    auto counts = lst.group.count;\n\
    \    foreach(idx, item; counts)\n    {\n        if(item >= idx && idx > 0)\n \
    \           return idx;\n    }\n    return -1;\n}\n/*", "{\n    if (lst.length\
    \ == 0)\n        return -1;\n    if (lst.length == 1)\n        return lst[0];\n\
    \    auto data = typeof(return)();\n    foreach (i; lst)\n    {\n        if (data.contains(i))\n\
    \            data[i] += 1;\n        else\n            data[i] = 1;\n    }\n  \
    \  long maxVal = -1;\n    foreach (tup; data)\n    {\n        if (tup[0] > tup[1]\
    \ && tup[0] > maxVal)\n            maxVal = tup[0];\n    }\n    return maxVal;\n\
    }", "{\n    /*\n    long max = 0;\n    int count = 0;\n    foreach(int i; lst)\
    \ {\n        if(count >= i) {\n            if(i > max) {\n                max\
    \ = i;\n            }\n        }\n        count = 0;\n        foreach(int n; lst)\
    \ {\n            if(n == i) {\n                count++;\n            }\n     \
    \   }\n    }\n    return max;\n    */\n    long count = 0;\n    foreach(int i;\
    \ lst) {\n        if(i == lst[count]) {\n            count++;\n        }\n   \
    \ }\n    return count;\n}", "{\n    size_t  maxFreq = max(lst);\n    size_t[]\
    \ counts = new size_t[maxFreq+1];\n    foreach(elem; lst)\n    {\n        counts[elem]++;\n\
    \    }\n    foreach(elem; counts)\n    {\n        if(elem >= indexOf(elem))\n\
    \        {\n            return indexOf(elem);\n        }\n    }\n    return -1;\n\
    }\n// Test Cases", "{\n    return lst.groupBy().values.count.filter!(a => a.length\
    \ >= a[0]).max.length;\n}\n/*", "{\n    long curMax = -1L;\n    long curVal =\
    \ -1L;\n    long curValCount = -1L;\n    foreach(l; lst)\n    {\n        if(l\
    \ > curMax)\n        {\n            curMax = l;\n        }\n    }\n    foreach(l;\
    \ lst)\n    {\n        if(l == curVal)\n        {\n            curValCount++;\n\
    \        }\n        else\n        {\n            curVal = l;\n            curValCount\
    \ = 1L;\n        }\n        if(curValCount >= curVal && curVal > 0L)\n       \
    \ {\n            return curVal;\n        }\n    }\n    return -1L;\n}", "{\n \
    \   import std.algorithm : filter, max, maxElement, map, reduce;\n    import std.range\
    \ : zip;\n    import std.typecons : tuple;\n    import std.conv : to;\n    import\
    \ std.math : sqrt;\n    import std.functional : unaryFun;\n    import std.array\
    \ : array;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.algorithm : filter, max, maxElement,\
    \ map, reduce;\n    import std.range : zip;\n    import std.conv : to;\n    import\
    \ std.math : sqrt;\n    import std.functional : unaryFun;\n    import std.array\
    \ : array;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.math : min;\n    import std.array\
    \ : array;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.algorithm : filter, max, maxElement,\
    \ map, reduce;\n    import std.range : zip;\n    import std.conv : to;\n    import\
    \ std.math : sqrt;\n    import std.functional : unaryFun;\n    import std.array\
    \ : array;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.math : min;\n    import std.array\
    \ : array;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.algorithm : filter, max, maxElement,\
    \ map, reduce;\n    import std.range : zip;\n    import std.conv : to;\n    import\
    \ std.math : sqrt;\n    import std.functional : unaryFun;\n    import std.array\
    \ : array;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.math : min;\n", "{\n    Map!(int,\
    \ int) m = new Map!(int, int);\n    foreach(i; lst)\n    {\n        m[i]++;\n\
    \    }\n    long ret = -1;\n    foreach(kvp; m)\n    {\n        if(kvp.value >=\
    \ kvp.key && kvp.key > ret)\n        {\n            ret = kvp.key;\n        }\n\
    \    }\n    return ret;\n}", "{\n  auto counts = count(lst); // std.algorithm.iteration.count()\n\
    \  auto tup = map!(tuple)(counts); // std.algorithm.iteration.map!()\n  auto elems\
    \ = map!(tuple[0])(tup); // std.algorithm.iteration.map!()\n  auto cnts = map!(tuple[1])(tup);\
    \ // std.algorithm.iteration.map!()\n  auto exs = zip(elems, cnts); // std.algorithm.iteration.zip()\n\
    \  long res = -1L;\n  foreach(tup; exs)\n  {\n    if(tup[0] <= tup[1])\n    {\n\
    \      if(tup[0] > res)\n      {\n        res = tup[0];\n      }\n    }\n  }\n\
    \  return res;\n}", "{\n  return lst.sort.groupBy.filter!(z => z[0] <= z[1].length).max[0].min;\n\
    }", "{ \n  auto myMap = std.typecons.makeMap!(long, long)();\n  foreach(auto i;\
    \ lst)\n  {\n      myMap[i]++;\n  }\n  long[] myArray = myMap.values;\n  long[]\
    \ myKeys = myMap.keys;\n  long maxFrequency = myArray[0];\n  long frequency =\
    \ -1;\n  for(int i = 0; i < myArray.length; i++)\n  {\n    if(maxFrequency < myArray[i])\n\
    \    {\n        maxFrequency = myArray[i];\n        frequency = myKeys[i];\n \
    \   }\n  }\n  return (frequency >= maxFrequency) ? frequency : -1;\n}", "{\n \
    \   assert(lst.length > 0);\n    auto cmp = (T, U)(T a, U b)\n    {\n        return\
    \ (a < b || (a == b && b == 0))\n            ? -1\n            : (a > b)\n   \
    \         ? 1\n            : 0;\n    };\n    long[] d = new long[16];\n    long\
    \ count;\n    long max = 0;\n    long res = -1;\n    foreach(e; lst) \n    {\n\
    \        assert(e > 0);\n        count = 1;\n        if (cmp(e, d.length) >= 0)\
    \ \n        {\n            d ~= 0;\n        }\n        d[e]++;\n        max =\
    \ max(max, e);\n    }\n    foreach(e; lst) \n    {\n        assert(e > 0);\n \
    \       if (d[e] >= e) \n        {\n            if (cmp(e, res) > 0) \n      \
    \      {\n                res = e;\n            }\n        }\n    }\n    return\
    \ res;\n}", "{\n\tint i;\n\tlong[] arr = new long[100];\n\tforeach(long num; lst)\n\
    \t{\n\t\ti = num;\n\t\tarr[i] += 1;\n\t}\n\t\n\tfor(i = 99; i > 0; i--)\n\t{\n\
    \t\tif(arr[i] >= i)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "{\n\
    \    //Distinct\n    // ArrayList!int\n    long[] distinct = new long[0];\n  \
    \  foreach(x; lst)\n    {\n        bool found = false;\n        foreach(y; distinct)\n\
    \        {\n            if(x == y)\n            {\n                found = true;\n\
    \                break;\n            }\n        }\n        if(!found)\n      \
    \  {\n            distinct ~= x;\n        }\n    }\n    sort(distinct);\n    //print(distinct);\n\
    \    // Frequency\n    long[] frequency = new long[0];\n    foreach(x; distinct)\n\
    \    {\n        long count = 0;\n        foreach(y; lst)\n        {\n        \
    \    if(x == y)\n            {\n                count += 1;\n            }\n \
    \       }\n        frequency ~= count;\n    }\n    //print(frequency);\n    for(long\
    \ i = frequency.length - 1; i >= 0; i--)\n    {\n        if(frequency[i] >= distinct[i])\n\
    \        {\n            return distinct[i];\n        }\n    }\n    return -1;\n\
    }", "{\n    long[] arr = new long[2];\n    long[] tmp = new long[2];\n    int\
    \ n = lst.length;\n    int res = -1;\n    for (int i = 0; i < n; i++)\n    {\n\
    \        arr[0] = lst[i];\n        arr[1] = 1;\n        if(!lst.take(i).contains(arr[0]))\n\
    \        {\n            int index = lst.drop(i).indexOf(arr[0]);\n           \
    \ while(index != -1)\n            {\n                arr[1]++;\n             \
    \   index = lst.drop(i + index + 1).indexOf(arr[0]);\n            }\n        \
    \    if(arr[1] >= arr[0] && arr[0] > res)\n            {\n                res\
    \ = arr[0];\n            }\n        }\n    }\n    return res;\n}", "{\n    long\
    \ highest = -1L;\n    for(int i = 0; i < lst.length; i++)\n    {\n        long\
    \ freq = 0L;\n        for(int j = 0; j < lst.length; j++)\n        {\n       \
    \     if(lst[i] == lst[j])\n            {\n                freq++;\n         \
    \   }\n        }\n        if(freq >= lst[i] && lst[i] > highest)\n        {\n\
    \            highest = lst[i];\n        }\n    }\n    return highest;\n}", "{\n\
    \    import std.algorithm.sorting : sort;\n    import std.range.primitives : count;\n\
    \    import std.range : map;\n    import std.traits : Unqual;\n    import std.typecons\
    \ : tuple;\n    alias pair = tuple!(long,long);\n    auto v = lst.map!(x => pair(x,x)).sort!(a\
    \ => a[0]).count!(a => a[0], a => a[1]);\n    return v.filter!(a => a[1]>=a[0]).filter!(a\
    \ => a[1]>=2).map!(a => a[0]).max;\n}", "{ \n  if (lst.length == 0) \n    return\
    \ -1;\n  Map!long map = new Map!long(); \n  int i = 0;\n  while (i < lst.length)\
    \ \n  { \n    if (map.count(lst[i]) == 0) \n      map[lst[i]] = 1; \n    else\
    \ \n      map[lst[i]] += 1; \n    i++;\n  } \n  long[] ordered = map.byValue.keys.sort();\
    \ \n  long index = ordered.length - 1; \n  while (index >= 0) \n  { \n    if (ordered[index]\
    \ >= map[ordered[index]]) \n      return ordered[index]; \n    index--; \n  }\
    \ \n  return -1; \n}", "{\n    import std.algorithm;\n    import std.range;\n\
    \    import std.algorithm.iteration;\n    import std.uni;\n    import std.array;\n\
    \    immutable freq = lst.frequency;\n    auto max = freq.max!(a => (size_t)a[1]);\n\
    \    immutable maxFreq = max[1];\n    immutable keysWithMaxFreq = freq.keys.filter!(a\
    \ => freq[a] == maxFreq);\n    immutable greaterThanMaxFreq = keysWithMaxFreq.filter!(a\
    \ => a > maxFreq);\n    if (greaterThanMaxFreq.empty)\n    {\n        immutable\
    \ min = keysWithMaxFreq.min;\n        return min;\n    }\n    else \n    {\n \
    \       return -1;\n    }\n}", "{\n    long greatestIntWithFreqGreaterThanItself;\n\
    \    immutable maxValue = max(lst);\n    long[] frequencyArray = new long[maxValue\
    \ + 1];\n    foreach(l; lst)\n    {\n        frequencyArray[l]++;\n    }\n   \
    \ /*\n        The minimum value that frequencyArray can hold is 0;\n        If\
    \ any other value is found, this means that \n        the greatest int that is\
    \ greater than zero and \n        has a frequency greater than or equal to the\
    \ value of the integer itself\n        must be at least one.\n    */\n    if(!(frequencyArray[0]\
    \ == maxValue))\n    {\n        greatestIntWithFreqGreaterThanItself = 1;\n  \
    \  }\n    else\n    {\n        greatestIntWithFreqGreaterThanItself = -1;\n  \
    \  }\n    // start searching from greatest int and try to find \n    // a value\
    \ that has frequency greater than or equal to itself\n    foreach(l; frequencyArray[maxValue..-1])\n\
    \    {\n        if(l >= frequencyArray.length - greatestIntWithFreqGreaterThanItself)\n\
    \        {\n            greatestIntWithFreqGreaterThanItself = frequencyArray.length\
    \ - greatestIntWithFreqGreaterThanItself;\n            break;\n        }\n   \
    \ }\n    return greatestIntWithFreqGreaterThanItself;\n}", "{\n    long[] newList\
    \ = new long[max(lst)+1];\n    foreach(val; lst)\n    {\n        newList[val]++;\n\
    \    }\n    foreach(i, val; newList)\n    {\n        if(val>=i && i!=0)\n    \
    \    {\n            return i;\n        }\n    }\n    return -1;\n}", "{\n    long\
    \ result = -1L;\n    long max_val = 0L;\n    long max_occur = 0L;\n    Tuple!(long,\
    \ long)[] histogram = new Tuple!(long, long)[lst.length];\n    foreach(i, element;\
    \ lst)\n    {\n        bool found = false;\n        foreach(tuple; histogram)\n\
    \        {\n            if(tuple.field0 == element)\n            {\n         \
    \       found = true;\n                tuple.field1++;\n            }\n      \
    \  }\n        if(!found)\n        {\n            histogram[i] = tuple(element,\
    \ 1L);\n        }\n    }\n    foreach(tuple; histogram)\n    {\n        if(tuple.field1\
    \ >= tuple.field0 && tuple.field0 > max_val)\n        {\n            max_val =\
    \ tuple.field0;\n            max_occur = tuple.field1;\n        }\n    }\n   \
    \ if(max_val != 0 && max_occur >= max_val)\n    {\n        result = max_val;\n\
    \    }\n    return result;\n}", "{\n    auto counts = new long[lst.length + 1];\n\
    \    counts[] = 0;\n    foreach(immutable elem; lst)\n    {\n        if(elem ==\
    \ 0)\n            return -1;\n        counts[elem]++;\n    }\n    long result\
    \ = -1;\n    for(long i = lst.length; i > 0; i--)\n    {\n        if(counts[i]\
    \ >= i)\n        {\n            result = i;\n            break;\n        }\n \
    \   }\n    return result;\n}", "{\n    auto max = reduce!max(lst);\n    if (max\
    \ == 0) \n    {\n        return -1;\n    }\n    else \n    {\n        auto freq\
    \ = lst.group(a => a).map!(g => tuple(g[0], g.length));\n        auto freq = filter!(t\
    \ => t[1] >= t[0])(freq);\n        auto freq = filter!(t => t[0] > 0)(freq);\n\
    \        if (freq.length == 0) \n        {\n            return -1;\n        }\n\
    \        else \n        {\n            return reduce!max(freq)[0];\n        }\n\
    \    }\n}", "{\n    bool[] nums = new bool[lst.length];\n    foreach(lst,i=>nums[i]\
    \ = 1);\n    return lst.filter!(a=>nums[a]).length ? -1L : lst.map!(a=>nums[a]).reduce!((a,b)=>a+b).item;\n\
    }", "{\n    auto result = -1L;\n    foreach(l; lst) \n    {\n        if(lst.count(l)\
    \ >= l) \n        {\n            result = max(result, l);\n        }\n    }\n\
    \    return result;\n}\n// auto res = search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L,\
    \ 4L]);\n// pragma(msg, res);\n// pragma(msg, 7%2);\n/*\n    Given an array of\
    \ integers, return the longest sequence of 1's that can be produced by\n    replacing\
    \ no more than two 0's with 1's.\n    Examples:\n    >>> flip([1, 0, 1, 1, 0,\
    \ 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,", "{\n    long frequency = -1;\n    long\
    \ result = -1;\n    foreach(i; lst)\n    {\n        if(lst.count(i) >= i)\n  \
    \      {\n            frequency = i;\n            result = i;\n        }\n   \
    \ }\n    return result;\n}\n/*\n    The 'fib' function is a function that returns\
    \ the nth number in the Fibonacci sequence. It takes one parameter, n, the position\
    \ of the number in the sequence.\n    The Fibonacci sequence is a sequence of\
    \ numbers, where each number is the sum of the 2 numbers before it.\n    Here\
    \ is the first number of the sequence, starting from the beginning:", "{\n   \
    \ if (lst.length == 0) \n    {\n        return -1L;\n    }", "{\n    assert(lst.length\
    \ > 0L, \"Only non-empty arrays!\");\n    long result = -1L;\n    long largest_number\
    \ = lst[$-1L];\n    long[] lst_tmp = lst.dup;\n    lst_tmp.sort;\n    for (long\
    \ i = 0L; i < lst_tmp.length; i++) \n    {\n        long number = lst_tmp[i];\n\
    \        long frequency = 0L;\n        foreach (item; lst_tmp) \n        {\n \
    \           if (item == number) \n            {\n                frequency++;\n\
    \            }\n        }\n        if (number == frequency && number > result\
    \ && number <= largest_number) \n        {\n            result = number;\n   \
    \     }\n    }\n    return result;\n}\n/*\n        long[] intArray = [4L, 1L,\
    \ 2L, 2L, 3L, 1L];\n        assert(search(intArray) == 2L);\n        intArray\
    \ = [1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L];\n        assert(search(intArray) ==\
    \ 3L);\n        intArray = [5L, 5L, 4L, 4L, 4L];\n        assert(search(intArray)\
    \ == -1L);\n*/\n// vim: set expandtab tabstop=4 shiftwidth=4 ft=d:", "{\n    \n\
    \    \n    auto res = lst.groupBy!((a,b) => a == b).values;\n    auto cnt = lst.groupBy!((a,b)\
    \ => a == b).keys;\n    auto res2 = res.map!(a => a.length).groupBy!((a,b) =>\
    \ a == b).values;\n    auto cnt2 = res.map!(a => a.length).groupBy!((a,b) => a\
    \ == b).keys;\n    long res3 = long.min;\n    foreach(item; res2)\n    {\n   \
    \     if(cnt2[item] >= item && item != 0)\n        {\n            if(cnt[res[item]][0]\
    \ > res3)\n            {\n                res3 = cnt[res[item]][0];\n        \
    \    }\n        }\n    }\n    if(res3 == long.min)\n    {\n        return -1L;\n\
    \    }\n    return res3;\n    \n}", "{\n    long best = 0;\n    auto d = lst.group();\n\
    \    foreach(elem; d) \n    {\n        if(elem.value >= elem.key && elem.key >\
    \ best)\n            best = elem.key;\n    }\n    return best == 0 ? -1 : best;\n\
    }\n//By mak\nlong search2(long[] arr)\n{\n    if(arr.length == 0) return -1;\n\
    \    long[] count = new long[arr.length];\n    int[] index = new int[arr.length];\n\
    \    foreach(i, el; arr)\n    {\n        count[el]++;\n        index[el] = i;\n\
    \    }\n    for(int i = arr.length - 1; i >= 0; i--)\n    {\n        if(count[i]\
    \ >= i && index[i] == count[i])\n            return i;\n    }\n    return -1;\n\
    }", "{\n    immutable sorted = sort(lst);\n    immutable current = sorted[0];\n\
    \    immutable current_count = 1;\n    immutable result = -1L;\n    for(immutable\
    \ i = 1; i < sorted.length; i++)\n    {\n        if(sorted[i] == current)\n  \
    \      {\n            current_count++;\n        }\n        else if(sorted[i] !=\
    \ current)\n        {\n            if(current_count >= current)\n            {\n\
    \                result = current;\n            }\n            current = sorted[i];\n\
    \            current_count = 1;\n        }\n    }\n    if(current_count >= current)\n\
    \    {\n        result = current;\n    }\n    return result;\n}\n ", "{\n    long\
    \ result = -1L;\n    long[] counts = new long[lst.length];\n    foreach(i; 0 ..\
    \ lst.length)\n    {\n        long count = 0L;\n        foreach(j; 0 .. lst.length)\n\
    \        {\n            if(lst[i] == lst[j])\n            {\n                count++;\n\
    \            }\n        }\n        counts[i] = count;\n    }\n    long[] arr =\
    \ array(1L .. counts.length + 1);\n    foreach(i; 0 .. arr.length)\n    {\n  \
    \      if(counts[i] >= i)\n        {\n            result = i;\n        }\n   \
    \ }\n    return result;\n}", "{ \n    long frequency(long val, long[] list) =>\
    \ list.filter!( (x) => x == val ).length;\n    long maxFreq = reduce!(max)(map!(\
    \ (x) => frequency(x, lst) )(lst)).front;\n    return lst.filter!( (x) => x >=\
    \ maxFreq && frequency(x, lst) == maxFreq ).filter!( (x) => x > 0 ).sort!( (a,\
    \ b) => a > b ).front;\n}", "{\n    auto m = new Map!long;\n    foreach(i; lst)\n\
    \    {\n        m[i]++;\n    }\n    m = sort(m, (a, b) => b.value - a.value);\n\
    \    long v = 0;\n    foreach(i; m)\n    {\n        if(i.value >= i.key)\n   \
    \     {\n            v = i.key;\n            break;\n        }\n    }\n    return\
    \ v > 0 ? v : -1;\n}", "{\n    auto f = (long n) => lst.count!((i) => i == n);\n\
    \    auto g = (long n) => n <= f(n);\n    auto y = (long x) => (g(x) ? -1L : x);\n\
    \    return y(lst.filter!g.max());\n}\n ", "{\n    Map!(size_t,size_t) a = std.typecons.assocArray!(size_t,size_t);\n\
    \    foreach(elem; lst)\n    {\n        a[elem]++;\n    }\n    long max_val =\
    \ -1;\n    foreach(elem; a)\n    {\n        if(elem.value >= elem.key && elem.key\
    \ > max_val)\n        {\n            max_val = elem.key;\n        }\n    }\n \
    \   return max_val;\n}", "{\n    int max_frequency = -1;\n    int max_frequency_element\
    \ = -1;\n    foreach(int i; lst.byKey(false).keys) \n    {\n        if(i <= lst.byKey(false)[i])\
    \ \n        {\n            int frequency = lst.byKey(false)[i];\n            if(frequency\
    \ > max_frequency) \n            {\n                max_frequency = frequency;\n\
    \                max_frequency_element = i;\n            }\n        }\n    }\n\
    \    return max_frequency_element;\n}\n//Not my solution:\nlong search2(long[]\
    \ lst) \n{\n    // build frequency map\n    auto m = lst.byKey(false);\n    //\
    \ sort keys by frequency\n    auto fqncyLst = m.keys.sort!(a, b => m[a] < m[b]);\n\
    \    // find max\n    foreach(freq; fqncyLst) \n    {\n        if(freq >= m[freq])\
    \ \n        {\n            return freq;\n        }\n    }\n    return -1;\n}",
  "{\n    long max = 0;\n    long maxCount = 0;\n    foreach(el; lst)\n    {\n   \
    \     long count = 0;\n        foreach(el2; lst)\n        {\n            if(el\
    \ == el2)\n            {\n                count++;\n            }\n        }\n\
    \        if(count > maxCount && count >= el)\n        {\n            max = el;\n\
    \            maxCount = count;\n        }\n    }\n    if(max == 0)\n    {\n  \
    \      return -1;\n    }\n    return max;\n}\n/*\n    Time complexity: O(n\xB2\
    )\n    Space complexity: O(1)\n*/\n/*\n    Given 2 lists of strings, and a list\
    \ of strings consisting of characters from the Latin alphabet, \n    determine\
    \ which strings from the first list are not in the second list, and which characters\
    \ from the \n    alphabet are not present in any of the strings from the first\
    \ list.\n    Example:\n    >>> diff([\"hello\",\"world\",\"!\"], [\"hello\",\"\
    world\",\"!\"], ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'])\n\
    \    [\"hello\",\"world\",\"!\"],[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"\
    h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"\
    u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n    >>> diff([\"hello\",\"world\",\"!\"],\
    \ [\"hello\",\"world\",\"!\"], ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','h','e','l','l','o','w','r','d','!'])\n\
    \    [],[\"a\",\"b\",\"c\",\"d\",\"f\",\"g\",\"i\",\"j\",\"k\",\"l\",\"m\",\"\
    n\",\"o\",\"p\",\"q\",\"s\",\"t\",\"u\",\"v\",\"x\",\"y\",\"z\"]\n    >>> diff([\"\
    hello\",\"world\",\"!\"], [\"hello", "{\n    auto l = new long[][long.max]();\n\
    \    foreach(i; lst)\n    {\n        l[i][++l[i][0L]] = i;\n    }\n    long r\
    \ = -1L;\n    foreach(i; l)\n    {\n        if(i[0L] >= i[1L] && i[1L] > r) r\
    \ = i[1L];\n    }\n    return r;\n}", "{\n    long[] freq = new long[lst.length];\n\
    \    foreach(i; 0..lst.length)\n    {\n        long cnt = count(lst[i], lst);\n\
    \        if(cnt >= lst[i])\n        {\n            freq[i] = lst[i];\n       \
    \ }\n    }\n    if(freq.length > 0)\n    {\n        long max_freq = max(freq);\n\
    \        return max_freq;\n    }\n    else\n    {\n        return -1L;\n    }\n\
    }\n/*\n    You are given an array of integers. Find the maximum sum of the subsequence\
    \ \n    within the array.\n    >>> max_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n\
    \    6\n*/\nlong max_sum(long[] lst)\n{\n    long max_sum = 0;\n    long max_end\
    \ = 0;\n    foreach(i; lst)\n    {\n        max_end = max_end + i;\n        if(max_end\
    \ < 0)\n        {\n            max_end = 0;\n        }\n        if(max_sum < max_end)\n\
    \        {\n            max_sum = max_end;\n        }\n    }\n    return max_sum;\n\
    }\n/*\n    You are given an array of integers. Find the maximum sum of the subsequence\
    \ \n    within the array. However, you are only allowed to delete one element\
    \ from \n    the array in order to generate the subsequence.\n    >>> max_sum_with_delete([-2,\
    \ 1, -3, 4, -1, 2, 1, -5, 4])\n    7\n*/\nlong max_sum_with_delete(long[] lst)\n\
    {\n    long max_sum = 0;\n    long max_end = 0;\n    long max_elem = lst[0];\n\
    \    foreach(i; lst)\n    {\n        max_end = max_end + i;\n        if(max_end\
    \ < 0)\n        {\n            max_end = 0;\n        }\n        if(max", "{\n\
    \    // TODO: write solution\n    Map!int freq = new Map!int();\n    foreach(el;\
    \ lst)\n    {\n        if(freq.count(el) == 0)\n        {\n            freq[el]\
    \ = 1;\n        } else\n        {\n            freq[el] += 1;\n        }\n   \
    \ }\n    foreach(key; keys(freq))\n    {\n        if(key <= freq[key])\n     \
    \   {\n            return key;\n        }\n    }\n    return -1;\n}", "{\n   \
    \ return -1L;\n}", "{\n    long max = -1L;\n    foreach(n; lst)\n    {\n     \
    \   auto x = n.to!ulong;\n        if(x <= max) continue;\n        if(lst.count(n)\
    \ >= x)\n            max = x;\n    }\n    return max;\n}", "{\n    if (lst.length\
    \ == 0) return -1;\n    auto map = new Map.fromList(lst.map!((n) => tuple(n, 1)).sort());\n\
    \    map.updateWith!((v, k) => map.get(k-1, 0) + v)();\n    return map.filter!((k,\
    \ v) => k >= v).keys.max!((a, b) => a > b ? 1 : -1).orElse(-1);\n}", "{\n    int[]\
    \ counts = new int[lst.length];\n    long[] unique = new long[lst.length];\n \
    \   unique[0] = lst[0];\n    counts[0] = 1;\n    int uniqueLength = 1;\n    for\
    \ (int i = 1; i < lst.length; i++)\n    {\n        int j = 0;\n        for (j\
    \ = 0; j < uniqueLength; j++)\n        {\n            if (lst[i] == unique[j])\n\
    \            {\n                counts[j]++;\n                break;\n       \
    \     }\n        }\n        if (j == uniqueLength)\n        {\n            unique[j]\
    \ = lst[i];\n            counts[j] = 1;\n            uniqueLength++;\n       \
    \ }\n    }\n    long max = 0;\n    for (int i = 0; i < uniqueLength; i++)\n  \
    \  {\n        if (unique[i] > counts[i] && unique[i] > max)\n        {\n     \
    \       max = unique[i];\n        }\n    }\n    return max == 0 ? -1 : max;\n}",
  "{\n    import std.array : sort;\n    import std.conv : to;\n    import std.algorithm\
    \ : count;\n    import std.range : iota;\n    auto sLst = lst.sorted.unique;\n\
    \    foreach(i; iota(1, sLst.length+1))\n    {\n        auto freq = count(lst,\
    \ i);\n        if(freq >= i) return i;\n    }\n    return -1;\n}\n/*\n       \
    \ auto initList = lst.sort().unique;\n        long a = 1L;\n        long b = 2L;\n\
    \        long n = 2L;\n        long temp = 2L;\n        long one = 1L;\n     \
    \   long zero = 0L;\n        long result = -1L;\n        while(true)\n       \
    \ {\n            if(a == initList.length)\n            {\n                result\
    \ = -1L;\n                break;\n            }\n            b = initList[a];\n\
    \            if(count(lst, b) >= b)\n            {\n                result = b;\n\
    \                break;\n            }\n            else\n            {\n    \
    \            temp = b;\n                b = a + b;\n                a = temp;\n\
    \                n = n + one;\n            }\n        }\n        return result;\n\
    */\n/*\nUncomment this function to test:", "{\n    // Add any extra variable to\
    \ this return type\n    struct ReturnType(long num_of_val, long value)\n    {\n\
    \        long num_of_val;\n        long value;\n    }\n    ReturnType rt;\n  \
    \  rt.num_of_val = 0;\n    rt.value = 0;\n    ReturnType[] rta = new ReturnType[lst.length];\n\
    \    long index = 0;\n    int i = 0;\n    while(i < lst.length)\n    {\n     \
    \   rta[index].value = lst[i];\n        rta[index].num_of_val = 1;\n        i++;\n\
    \        while(i < lst.length && lst[i] == rta[index].value)\n        {\n    \
    \        rta[index].num_of_val++;\n            i++;\n        }\n        index++;\n\
    \    }\n    rta = rta[0..index];\n    if(rta.length > 0)\n    {\n        rt =\
    \ rta[0];\n        for(int j = 1; j < rta.length; j++)\n        {\n          \
    \  if(rta[j].num_of_val >= rta[j].value && rta[j].value > rt.value)\n        \
    \    {\n                rt = rta[j];\n            }\n        }\n    }\n    if(rt.num_of_val\
    \ < rt.value)\n    {\n        rt.value = -1;\n    }\n    return rt.value;\n}",
  "{\n    auto found = [](dchar c, inout long[] lst) => \n    {\n        int j = cast(int)c;\n\
    \        foreach(i; 0 .. lst.length)\n        {\n            if(lst[i] == j)\n\
    \                return true;\n        }\n        return false;\n    };\n    long[]\
    \ r = [lst[0]];\n    long[] g;\n    foreach(i; 1 .. lst.length)\n    {\n     \
    \   if(found(lst[i], r))\n            continue;\n        r ~= lst[i];\n    }\n\
    \    sort(r);\n    r = r.reversed;\n    foreach(i; 0 .. r.length)\n    {\n   \
    \     if(r[i] == 0)\n            continue;\n        int k = 0;\n        long[]\
    \ g = [];\n        foreach(j; 0 .. lst.length)\n        {\n            if(lst[j]\
    \ == r[i])\n                k++;\n        }\n        if(k >= r[i])\n         \
    \   return r[i];\n    }\n    return -1;\n}", "{\n    long[] x = new long[lst.length];\n\
    \    x = sort(lst);\n    int c = 0;\n    int b = 0;\n    foreach(long z; lst)\n\
    \    {\n        if(x[b]==z)\n        {\n            c++;\n        }\n        b++;\n\
    \    }\n    if(c>=x[0])\n    {\n        return x[0];\n    }\n    else\n    {\n\
    \        return -1;\n    }\n}", "{\n    // Map the frequency of each integer in\
    \ the list \n    auto freq = map!((a) => std.algorithm.count(lst, (b) => b ==\
    \ a));\n    // Filter the frequencies greater than or equal to the value of the\
    \ integer.\n    // The frequency should be greater than zero.\n    // Return the\
    \ greatest integer that matches the filter, otherwise return -1.\n    return max!q{a\
    \ > 0 && a >= b}(freq);\n}", "{\n    import std.algorithm.sorting : sort;\n  \
    \  lst.sort();\n    long[] cnt = new long[lst.length];\n    long count = 0;\n\
    \    for (long i = 0; i < lst.length; i++) \n    {\n        if (i == 0)\n    \
    \    {\n            cnt[count] = 1;\n        }\n        else if (lst[i] == lst[i\
    \ - 1])\n        {\n            cnt[count]++;\n        }\n        else\n     \
    \   {\n            count++;\n            cnt[count] = 1;\n        }\n    }\n \
    \   long result = -1;\n    long max_count = 0;\n    for (long i = 0; i <= count;\
    \ i++) \n    {\n        if (lst[i] > cnt[i] && max_count < cnt[i])\n        {\n\
    \            max_count = cnt[i];\n            result = lst[i];\n        }\n  \
    \  }\n    return result;\n}", "{\n    int index = 0;\n    foreach(long item; lst)\n\
    \    {\n        if(count(lst, item) >= item)\n        {\n            return item;\n\
    \        }\n    }\n    return -1;\n}", "{\n    Map!(long, long) map;\n    foreach(immutable\
    \ elem; lst)\n    {\n        if(!map.keys.contains(elem))\n        {\n       \
    \     map[elem] = 1;\n        }\n        else\n        {\n            map[elem]\
    \ += 1;\n        }\n    }\n    if(map.length == 0)\n    {\n        return -1;\n\
    \    }\n    long highest_count = 0;\n    long highest_count_item = 0;\n    foreach(immutable\
    \ key, immutable value; map)\n    {\n        if(value >= key && value > highest_count)\n\
    \        {\n            highest_count = value;\n            highest_count_item\
    \ = key;\n        }\n    }\n    if(highest_count == 0)\n    {\n        return\
    \ -1;\n    }\n    return highest_count_item;\n}", "{\n    import std.algorithm\
    \ : uniq, sort, max;\n    import std.range : iota;\n    import std.conv : to;\n\
    \    import std.functional : compose;\n    //take the unique list of integers\n\
    \    auto unique_ints = lst.uniq.sort;\n    //create a map of unique integers\
    \ to their respective frequency\n    auto int_freq = unique_ints.map!(int => tuple(int,\
    \ lst.count(int))).array;\n    //create a range of integers\n    auto test_range\
    \ = iota(1L, unique_ints.length + 1L);\n    //using map find the frequency of\
    \ the integer in the range\n    auto freq_in_range = test_range.map!(int => (int,\
    \ int_freq.count!(a => a[1] == int))).array;\n    //get the max value of the range\n\
    \    auto max_value = test_range.max;\n    //filter by matching the frequency\
    \ of the integer to the frequency of the integer in the range\n    auto filtered\
    \ = int_freq.filter!(a => a[1] == freq_in_range.filter!(b => b[0] == a[1])[0][1]).array;\n\
    \    //return the max element of the filtered array\n    return filtered.length\
    \ > 0 ? filtered.max[0] : -1L;\n}\n/*\n    You are given an integer k. Return\
    \ an array that contains the numbers from 1 to k, inclusive, in increasing order.\n\
    \    The array length must be exactly k.\n    Examples:\n    >>> makeArray(4L)\n\
    \    [1L, 2L, 3L, 4L]\n    >>> makeArray(5L)\n    [1L, 2L, 3L, 4L, 5L]\n    >>>\
    \ makeArray(2L)\n    [1L, 2L]\n*/\nlong[] makeArray(long k)\n{\n    import std.range\
    \ : iota;\n    return iota(1L, k + 1L).array;\n}\n/*\n    You are given an array\
    \ of integers that may contain duplicate values. Return a new array that contains\
    \ \n    the unique values. The order of the array must", "{\n\tint maxFreq = 0;\n\
    \tint[] freq = new int[lst.length];\n\tlong[] numbers = new long[lst.length];\n\
    \tfor(int i = 0; i < lst.length; i++)\n\t{\n\t\tif(numbers.indexOf(lst[i]) ==\
    \ -1)\n\t\t{\n\t\t\tnumbers[i] = lst[i];\n\t\t\tfor(int j = 0; j < lst.length;\
    \ j++)\n\t\t\t{\n\t\t\t\tif(lst[i] == lst[j])\n\t\t\t\t{\n\t\t\t\t\tfreq[i]++;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < freq.length; i++)\n\t{\n\t\
    \tif(freq[i] >= numbers[i] && freq[i] > maxFreq)\n\t\t{\n\t\t\tmaxFreq = freq[i];\n\
    \t\t}\n\t}\n\tif(maxFreq == 0)\n\t{\n\t\treturn -1;\n\t}\n\treturn numbers[freq.indexOf(maxFreq)];\n\
    }", "{\n    long[] test = lst.dup;\n    test.sort;\n    int len = lst.length;\n\
    \    int highest = 0;\n    long highestNumber = 0;\n    int count = 0;\n    for(int\
    \ i = 0; i < len; i++)\n    {\n        for(int j = 0; j < len; j++)\n        {\n\
    \            if(test[i] == test[j])\n            {\n                count++;\n\
    \            }\n        }\n        if(count >= test[i] && count > highest)\n \
    \       {\n            highest = count;\n            highestNumber = test[i];\n\
    \        }\n        count = 0;\n    }\n    if(highest > 0)\n    {\n        return\
    \ highestNumber;\n    }\n    else\n    {\n        return -1;\n    }\n}", "{\n\
    \    alias count = tuple(a, b);\n    int[] arr = lst.dup;\n    arr.sort;\n   \
    \ long max = -1;\n    long curr = -1;\n    int num = 1;\n    foreach(i; 1..arr.length)\n\
    \    {\n        if(arr[i] == arr[i-1])\n        {\n            num++;\n      \
    \  }\n        else\n        {\n            if(num >= arr[i-1])\n            {\n\
    \                curr = arr[i-1];\n            }\n            num = 1;\n     \
    \   }\n        if(num >= arr[i])\n        {\n            curr = arr[i];\n    \
    \    }\n        if(curr > max)\n        {\n            max = curr;\n        }\n\
    \    }\n    return max;\n}", "{\n    int length = lst.length;\n    int[] newArray\
    \ = new int[length];\n    foreach(i; lst)\n    {\n        newArray[i]++;\n   \
    \ }\n    long result = -1;\n    foreach(i; newArray)\n    {\n        if(i > result\
    \ && i > 0 && newArray[i] >= i)\n        {\n            result = i;\n        }\n\
    \    }\n    return result;\n}", "{\n    return lst.groupBy.filter!(a => a.length\
    \ >= a[0]).length ? lst.groupBy.filter!(a => a.length >= a[0]).max!(a => a[0])[0]\
    \ : -1;\n}", "{\n  size_t f;\n  auto g = group(lst);\n  foreach(j; keys(g)) \n\
    \  {\n    f = g[j].length;\n    if(j <= f) return j;\n  }\n  return -1L;\n}\n\
    /*\n    The prime factors of 13195 are 5, 7, 13 and 29.\n    What is the largest\
    \ prime factor of the number 600851475143 ?\n*/\nlong p3(long i) \n{\n  for(long\
    \ l = 2L; l < i; l++) \n  {\n    if(i % l == 0L) \n    {\n      return p3(i /\
    \ l);\n    }\n  }\n  return i;\n}\n/*\n    A palindromic number reads the same\
    \ both ways. \n    The largest palindrome made from the product of two 2-digit\
    \ numbers is 9009 = 91 \xD7 99.\n    Find the largest palindrome made from the\
    \ product of two 3-digit numbers.\n*/", "{\n    /*\n        Fill in the code here\n\
    \    */\n    \n    long[] lst2 = lst.unique; // \u0441\u043E\u0437\u0434\u0430\
    \u0451\u043C \u0432\u0442\u043E\u0440\u043E\u0439 \u043C\u0430\u0441\u0441\u0438\
    \u0432 \u0438\u0437 \u0443\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0445\
    \ \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432\n    long[] lst3 = lst.dup;\
    \ // \u0441\u043E\u0437\u0434\u0430\u0451\u043C \u0442\u0440\u0435\u0442\u0438\
    \u0439 \u043C\u0430\u0441\u0441\u0438\u0432 \u0441 \u043F\u043E\u0432\u0442\u043E\
    \u0440\u044F\u044E\u0449\u0438\u043C\u0438\u0441\u044F \u044D\u043B\u0435\u043C\
    \u0435\u043D\u0442\u0430\u043C\u0438\n    int[] b = new int[lst2.length]; // \u0441\
    \u043E\u0437\u0434\u0430\u0451\u043C \u043D\u043E\u0432\u044B\u0439 \u043C\u0430\
    \u0441\u0441\u0438\u0432 \u0446\u0435\u043B\u044B\u0445 \u0447\u0438\u0441\u0435\
    \u043B\n    int t = 0;\n    int g = 0;\n    foreach(int i; lst2) // \u043F\u0435\
    \u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043C \u0432\u0441\u0435 \u044D\u043B\
    \u0435\u043C\u0435\u043D\u0442\u044B \u0432\u0442\u043E\u0440\u043E\u0433\u043E\
    \ \u043C\u0430\u0441\u0441\u0438\u0432\u0430\n    {\n        foreach(int j; lst3)\
    \ // \u043F\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043C \u0432\u0441\
    \u0435 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B \u0442\u0440\u0435\u0442\
    \u044C\u0435\u0433\u043E \u043C\u0430\u0441\u0441\u0438\u0432\u0430\n        {\n\
    \            if(lst2[i] == lst3[j]) // \u0435\u0441\u043B\u0438 \u044D\u043B\u0435\
    \u043C\u0435\u043D\u0442 \u0432\u0442\u043E\u0440\u043E\u0433\u043E \u043C\u0430\
    \u0441\u0441\u0438\u0432\u0430 \u0440\u0430\u0432\u0435\u043D \u044D\u043B\u0435\
    \u043C\u0435\u043D\u0442\u0443 \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E\
    \ \u043C\u0430\u0441\u0441\u0438\u0432\u0430, \u0442\u043E\n            {\n  \
    \              t++; // \u0443\u0432\u0435\u043B\u0438\u0447\u0438\u0432\u0430\u0435\
    \u043C \u0441\u0447\u0451\u0442\u0447\u0438\u043A \u043D\u0430 1\n           \
    \ }\n        }\n        b[i] = t; // \u0437\u0430\u043F\u0438\u0441\u044B\u0432\
    \u0430\u0435\u043C \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0441\u0447\
    \u0451\u0442\u0447\u0438\u043A\u0430 \u0432", "{\n    auto dict = std.typecons.makeAssocArray();\n\
    \    foreach(elem; lst)\n    {\n        if(elem in dict)\n        {\n        \
    \    dict[elem]++;\n        }\n        else\n        {\n            dict[elem]\
    \ = 1;\n        }\n    }\n    long count = 0;\n    long candidate = 0;\n    foreach(elem;\
    \ dict)\n    {\n        if(elem.value >= elem.key)\n        {\n            if(elem.value\
    \ > count)\n            {\n                count = elem.value;\n             \
    \   candidate = elem.key;\n            }\n        }\n    }\n    if(count == 0)\n\
    \    {\n        return -1;\n    }\n    return candidate;\n}", "{\n    long result\
    \ = -1L;\n    long maxFreq= -1L;\n    foreach(long x; lst) \n    {\n        maxFreq\
    \ = max(x, maxFreq);\n    }\n    for(int i = 1; i <= maxFreq; i++) \n    {\n \
    \       long freq = 0L;\n        foreach(long x; lst) \n        {\n          \
    \  if(x == i) \n            {\n                freq++;\n            }\n      \
    \  }\n        if(freq >= i) \n        {\n            result = max(result, i);\n\
    \        }\n    }\n    return result;\n}\n/*\n    non-empty array of integers.\
    \ The integers can be negative or positive.\n    Return the maximum sum of contiguous\
    \ values.\n    >>> maxContiguousSum([5L, -9L, 6L, -2L, 3L])\n    7L\n    >>> maxContiguousSum([1L,\
    \ 23L, 90L, -43L, 0L, 0L, 98L, -20L, -10L, -7L, 32L, 9L, -13L, -3L, -3L, 0L, 0L,\
    \ 0L, -1L, -11L, -11L, -9L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, -1L, -1L, -1L,\
    \ -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L,\
    \ -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L,\
    \ -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L,", "{\n    auto d = lst.groupBy!\"\
    a\".length();\n    return d.keys.retro.find!\"a>=d[a]\".orElse(-1L);\n}", "{\n\
    \    long result = -1L;\n    foreach(var val; lst)\n    {\n        if(val > result\
    \ && val <= lst.count(val))\n        {\n            result = val;\n        }\n\
    \    }\n    return result;\n}\n/*\n    Divide a list in a number of smaller sublists\
    \ of equal length. \n    This division must have a minimal number of sublists.\n\
    \    Example:\n    >>> divide([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2)\n    [[1, 2,\
    \ 3, 4, 5], [6, 7, 8, 9, 10]]\n    >>> divide([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\
    \ 3)\n    [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\n    >>> divide([1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10], 10)\n    [[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]]\n\
    \    >>> divide([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0)\n    []\n    >>> divide([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10], 100)\n    [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]\n*/\n\
    long[][] divide(long[] lst, long sublistLength) \n{\n    if(sublistLength == 0)\n\
    \    {\n        return new long[][](0);\n    }\n    long[][] result = new long[][](max(1,\
    \ (long)lst.length / sublistLength));\n    for(long i = 0; i < lst.length; i +=\
    \ sublistLength)\n    {\n        result[i / sublistLength] = lst[i .. min(i +\
    \ sublistLength, lst.length)];\n    }\n    return result;\n}\n/*\n    Calculate\
    \ the sum of the first n elements of a Fibonacci sequence. \n    The Fibonacci\
    \ sequence", "{\n    long minFrequency = 10_000;\n    long minFrequencyValue =\
    \ 10_000;\n    int i = 0;\n    for (i = 0; i < lst.length; i++)\n    {\n     \
    \   minFrequency = min(minFrequency, std.algorithm.count(lst, lst[i]));\n    \
    \    if (minFrequency >= lst[i])\n        {\n            minFrequencyValue = min(minFrequencyValue,\
    \ lst[i]);\n        }\n    }\n    if (minFrequencyValue == 10_000)\n    {\n  \
    \      return -1;\n    }\n    return minFrequencyValue;\n}\nlong search2(long[]\
    \ lst)\n{\n    std.map!(long, long) counts = new std.map!(long, long)();\n   \
    \ int i = 0;\n    for (i = 0; i < lst.length; i++)\n    {\n        if (counts.count(lst[i])\
    \ == 0)\n        {\n            counts[lst[i]] = 1;\n        }\n        else\n\
    \        {\n            counts[lst[i]]++;\n        }\n    }\n    for (; i < counts.length;\
    \ i++)\n    {\n        if (counts[i] >= i)\n        {\n            return i;\n\
    \        }\n    }\n    return -1;\n}", "{\n    long[] B = lst.dup;\n    B.sort;\n\
    \    B.reverse;\n    long maxLength = B[0];\n    while(maxLength>0)\n    {\n \
    \       int count = 0;\n        foreach(l; lst)\n        {\n            if(l ==\
    \ maxLength) count++;\n        }\n        if(count >= maxLength) return maxLength;\n\
    \        maxLength--;\n    }\n    return -1;\n}", "{\n    long[] sortedLst = sort(lst);\n\
    \    auto groupedLst = group(sortedLst);\n    long[] keys = groupedLst.keys.array;\n\
    \    foreach(i; 0 .. keys.length) \n    {\n        if(groupedLst[keys[i]].length\
    \ >= keys[i])\n        {\n            return keys[i];\n        }\n    }\n    return\
    \ -1L;\n}", "{\n    long result = -1L;\n    long candidate = 0L;\n    long count\
    \ = 0L;\n    foreach(i; lst)\n    {\n        if(i != candidate)\n        {\n \
    \           if(count > 0L)\n            {\n                if(count >= candidate)\n\
    \                {\n                    result = candidate;\n                }\n\
    \                candidate = i;\n                count = 1L;\n            }\n\
    \            else\n            {\n                candidate = i;\n           \
    \     count = 1L;\n            }\n        }\n        else\n        {\n       \
    \     count++;\n        }\n    }\n    if(count >= candidate)\n    {\n        result\
    \ = candidate;\n    }\n    return result;\n}", "{\n    // Build the frequency\
    \ table. This is a map with the value of \n    // an element as the key and its\
    \ frequency as the value.\n    Map!(long, size_t) m;\n    foreach(e; lst) m[e]++;\n\
    \    \n    // Iterate the frequency table and accumulate the results into\n  \
    \  // the array res. \n    // The element of the array is a tuple containing the\
    \ key and value\n    // pair from the map m.\n    long[] res;\n    foreach(p;\
    \ m)\n    {\n        res ~= tuple(p.key, p.value);\n    }\n    \n    // Sort the\
    \ array res based on the the frequency value\n    res.sort!((a, b) => a[1] > b[1]);\n\
    \    \n    // Iterate the array res and return the first element that has\n  \
    \  // a frequency larger than its value. If no such element exists\n    // return\
    \ -1.\n    foreach(e; res)\n    {\n        if(e[1] >= e[0]) return e[0];\n   \
    \ }\n    return -1;\n}", "{\n    auto x = lst.group.by!((x) => x).array;\n   \
    \ x.sort!((a, b) => a[0] - b[0]);\n    foreach(x; x.slice(1))\n    {\n       \
    \ if(x[0][0] == x[0][1].length)\n            return x[0][0];\n    }\n    return\
    \ -1;\n}", "{\n    // note that this approach requires the list to be sorted\n\
    \    lst.sort();\n    long max = -1;\n    long count = 1;\n    long old = lst[0];\n\
    \    foreach(num; lst[1..$])\n    {\n        if(num == old)\n        {\n     \
    \       count++;\n        }\n        else\n        {\n            if(count >=\
    \ old)\n            {\n                max = max(max, old);\n            }\n \
    \           count = 1;\n            old = num;\n        }\n    }\n    if(count\
    \ >= old)\n    {\n        max = max(max, old);\n    }\n    return max;\n}", "{\n\
    \    size_t[] fq = new size_t[lst.length];\n    foreach(v; lst)\n    {\n     \
    \   foreach(i; 0..lst.length)\n        {\n            if(v == lst[i])\n      \
    \      {\n                fq[i]++;\n            }\n        }\n    }\n    long\
    \ max = -1;\n    for(size_t i = 0; i < lst.length; i++)\n    {\n        if(lst[i]\
    \ > max && fq[i] >= lst[i])\n        {\n            max = lst[i];\n        }\n\
    \    }\n    return max;\n}", "{\n    if (lst.length < 1) return -1;\n    long[]\
    \ counts = new long[lst.length];\n    long[] vals = new long[lst.length];\n  \
    \  long max = lst[0];\n    foreach (long n; lst) {\n        if (n > max) max =\
    \ n;\n        counts[n - 1]++;\n        vals[n - 1] = n;\n    }\n    foreach (long\
    \ n; counts) {\n        if (n >= vals[i]) {\n            return vals[i];\n   \
    \     }\n    }\n    return -1;\n}", "{\n    long x = -1;\n    long count = 0;\n\
    \    foreach(long elem; lst)\n    {\n        if(lst.count(elem) >= elem)\n   \
    \     {\n            if(x == -1)\n            {\n                x = elem;\n \
    \           }\n            else if(elem > x)\n            {\n                x\
    \ = elem;\n            }\n        }\n    }\n    return x;\n}\n/*\n    Given a\
    \ string and an index, return a string length 2 starting at the given index. If\
    \ the index is too big or too small to define a string length 2, use the first\
    \ 2 chars. The string length will be at least 2.", "{\n    import std.array;\n\
    \    import std.algorithm;\n    // If the array is empty or contains zeros, just\
    \ return -1.\n    if( lst.length == 0 || lst.count!(elem => elem == 0) > 0 )\n\
    \        return -1;\n    else\n    {\n        // Get all the numbers from the\
    \ list with a frequency greater or equal to the\n        // value of that number.\n\
    \        long[] lst2 = lst.filter!(elem => (lst.count!(elem2 => elem2 == elem)\
    \ >= elem)).array;\n        // Sort them in order from greatest to smallest.\n\
    \        sort(lst2);\n        return lst2[0];\n    }\n}", "{\n    // grab the\
    \ max value first in array\n    long maxValue = lst[0];\n    foreach(value; lst)\n\
    \    {\n        if(value > maxValue)\n        {\n            maxValue = value;\n\
    \        }\n    }\n    // now that we have the max value allocate space to store\
    \ the counts of each unique number\n    long[] counts = new long[maxValue + 1];\n\
    \    foreach(value; lst)\n    {\n        counts[value] += 1;\n    }\n    // iterate\
    \ through the counts array and compare the values to the index\n    for(long i\
    \ = 0; i < counts.length; i++)\n    {\n        if(counts[i] >= i)\n        {\n\
    \            return i;\n        }\n    }\n    return -1;\n}\n/*\n    This solution\
    \ uses a map to keep track of counts of each unique number in the array.\n   \
    \ Then iterates through the map for the key and value to get the answer.\n*/\n\
    long search(long[] lst) \n{\n    import std.container.array;\n    import std.algorithm.iteration;\n\
    \    import std.range;\n    import std.conv;\n    import std.array;\n    import\
    \ std.typecons;\n    // create a map to count unique values\n    auto map = [long.max:\
    \ 0L].dup;\n    foreach(value; lst)\n    {\n        map[value] += 1;\n    }\n\
    \    // now iterate through the map comparing to get final answer\n    foreach(pair;\
    \ map)\n    {\n        if(pair.key == pair.value)\n        {\n            return\
    \ pair.key;\n        }\n    }\n    return -1;\n}\n/*\n    This solution uses an\
    \ indexable array to store the counts of each unique number in the array.\n  \
    \  Then iterates through the array for the index and value to get the answer.\n\
    */\nlong search(long[] lst) \n{\n    import std.container.array;\n    import std.algorithm.iteration;\n\
    \    import std.range;\n    import std.conv;\n    import std.array;\n    import\
    \ std.typecons;\n   ", "{\n    std.typecons.Map!long longestStreak = new std.typecons.Map!long();\n\
    \    long longestStreakNum = 0;\n    long frequency = 0;\n    long num = 0;\n\
    \    foreach(val; lst)\n    {\n        longestStreak[val]++;\n        if(longestStreak[val]\
    \ > longestStreakNum)\n        {\n            num = val;\n            longestStreakNum\
    \ = longestStreak[val];\n        }\n    }\n    foreach(val; lst)\n    {\n    \
    \    if(val == num)\n        {\n            frequency++;\n        }\n    }\n \
    \   if(frequency >= num)\n    {\n        return num;\n    }\n    return -1;\n}",
  "{\n    long max = -1L;\n    int[] freq = new int[lst.length];\n    foreach(i; 0..lst.length)\n\
    \    {\n        int f = 0;\n        foreach(j; 0..lst.length)\n        {\n   \
    \         if(lst[i] == lst[j])\n            {\n                f++;\n        \
    \    }\n        }\n        freq[i] = f;\n    }\n    // writeln(freq);\n    foreach(i;\
    \ 0..lst.length)\n    {\n        if(lst[i] > max && lst[i] <= freq[i])\n     \
    \   {\n            max = lst[i];\n        }\n    }\n    return max;\n}", "{\n\
    \    // Your code here\n    auto d1 = lst.group.by!x=>x;\n    foreach(k,v;d1)\n\
    \    {\n        auto cnt = v.length;\n        if(cnt >= k) return k;\n    }\n\
    \    return -1;\n}", "{\n    int length = lst.length;\n    if (length == 0) return\
    \ -1;\n    int[] sortedLst = lst.dup.sort;\n    int currentElement = sortedLst[0];\n\
    \    int count = 1;\n    int maxCount = 1;\n    int maxElement = currentElement;\n\
    \    int index = 1;\n    while (index < length) {\n        if (sortedLst[index]\
    \ == currentElement) {\n            count++;\n        } else {\n            if\
    \ (count > maxCount) {\n                maxCount = count;\n                maxElement\
    \ = currentElement;\n            }\n            currentElement = sortedLst[index];\n\
    \            count = 1;\n        }\n        index++;\n    }\n    if (count > maxCount)\
    \ {\n        maxCount = count;\n        maxElement = currentElement;\n    }\n\
    \    if (maxElement > maxCount) return maxElement;\n    return -1;\n}", "{\n \
    \   import std.algorithm : count;\n    import std.array : iota;\n    long max\
    \ = 1;\n    foreach(var i; lst)\n    {\n        if(i > max)\n        {\n     \
    \       max = i;\n        }\n    }\n    foreach(var i; iota(max, 1, -1))\n   \
    \ {\n        long count = count(lst, i);\n        if(count >= i)\n        {\n\
    \            return i;\n        }\n    }\n    return -1;\n}", "{\n    return lst.length\
    \ > 0 ? \n           lst.map!(x => x.tupleof) // We map the original array to\
    \ a tuple array of (element, quantity)\n              .group // we group the elements\
    \ by frequency\n              .map!(x => (x[0][0], x.length)) // Now we have a\
    \ tuple array of (element, frequency)\n              .filter!(x => x[1] >= x[0])\
    \ // We filter out all the elements that have a frequency lower than its own value\n\
    \              .length > 0 ? \n                           lst.map!(x => x.tupleof)\n\
    \                              .group\n                              .map!(x =>\
    \ (x[0][0], x.length))\n                              .filter!(x => x[1] >= x[0])\
    \ // We return the last element of the filtered array or -1 if there are no elements\n\
    \                              .max // We get the last element of the filtered\
    \ array\n                              .item // We get the integer value\n   \
    \           : -1 : -1;\n}", "{\n    long size = lst.length;\n    long[] dic =\
    \ new long[size];\n    for(long i = 0; i < size; i++)\n    {\n        dic[lst[i]]++;\n\
    \    }\n    for(long i = size; i > 0; i--)\n    {\n        if(dic[i] >= i)\n \
    \       {\n            return i;\n        }\n    }\n    return -1;\n}", "{\n \
    \ if (lst.length == 0) \n  {\n    return -1L;\n  }\n  else \n  {\n    lst = sort(lst);\n\
    \    long counter = 1L;\n    long num = lst[0];\n    for (int i = 1; i < lst.length;\
    \ i++) \n    {\n      if (lst[i] == num) \n      {\n        counter++;\n     \
    \ }\n      else \n      {\n        if (counter >= num) \n        {\n         \
    \ return num;\n        }\n        else \n        {\n          num = lst[i];\n\
    \          counter = 1L;\n        }\n      }\n    }\n    if (counter >= num) \n\
    \    {\n      return num;\n    }\n    else \n    {\n      return -1L;\n    }\n\
    \  }\n}", "{\n    return \n    lst.enumerate()\n        .map!(x => tuple(x[0]\
    \ + 1L, x[1]))\n        .groupby(x => x[1])\n        .filter!(x => x[0][0] >=\
    \ x[1].length)\n        .map!(x => x[0][0])\n        .empty \n            ? -1L\
    \ \n            : lst.enumerate()\n                    .map!(x => tuple(x[0] +\
    \ 1L, x[1]))\n                    .groupby(x => x[1])\n                    .filter!(x\
    \ => x[0][0] >= x[1].length)\n                    .map!(x => x[0][0])\n      \
    \              .max();\n}", "{\n    // Precondition: there is at least one element\
    \ in lst\n    long max_val = max(lst);\n    long[] counts = new long[max_val+1];\n\
    \    foreach(el; lst) counts[el]++;\n    foreach(el; iota(1L, max_val+1))\n  \
    \  {\n        if(counts[el] >= el) return el;\n    }\n    return -1L;\n}\n/*\n\
    \    If a value has a frequency equal to the value, then it must be the maximum\
    \ value in the array. \n    We can just return the maximum value in the array\
    \ if the condition is satisfied.\n*/", "{\n    long[] arr=new long[lst.length];\n\
    \    int i=0;\n    foreach(long t;lst)\n    {\n        arr[i]=t;\n        i++;\n\
    \    }\n    quickSort(arr);\n    int m,max=-1;\n    foreach(long t;arr)\n    {\n\
    \        int k=0;\n        foreach(long e;arr)\n        {\n            if(t==e)\n\
    \            {\n                k++;\n            }\n        }\n        if(k>=t)\n\
    \        {\n            m=k;\n            if(max<m)\n            {\n         \
    \       max=m;\n            }\n        }\n    }\n    if(max>=2)\n    {\n     \
    \   return max;\n    }\n    else\n    {\n        return -1;\n    }\n}", "{\n \
    \   return lst.frequency.filter!(kv => kv.value >= kv.key && kv.key > 0).values.max;\n\
    }", "{\n    // Let's make a map of all the frequencies.\n    // To do this, we\
    \ need to group the array by the value.\n    // Then take the count of each group.\n\
    \    Map!(long, long) freqMap = lst.groupBy!(x => x).map!(kvp => kvp.key, kvp\
    \ => kvp.value.length);\n    // Now we have a map to all the frequencies for each\
    \ value.\n    // We just have to check all the keys for their frequency.\n   \
    \ return freqMap.keys.filter!(key => freqMap[key] >= key).max();\n}", "{\n   \
    \ var dic = new long[lst.length];\n    foreach(idx, element; lst) \n    {\n  \
    \      dic[element]++;\n    }\n    foreach(idx, element; dic) \n    {\n      \
    \  if (idx == element) \n        {\n            return idx;\n        }\n    }\n\
    \    return -1;\n}\n/*\n    You are given an array of people. If an element of\
    \ the array is an integer, then it represents the age of \n    a person. If the\
    \ element is a string, then it represents the first name of a person.\n    The\
    \ array can contain both integers and strings.\n    Your task is to sort the array\
    \ in the following order:\n    1. The ages of all people from the array should\
    \ be sorted in increasing order.\n    2. All integer elements from the array (representing\
    \ the ages) should come first, sorted in increasing order.\n    3. All string\
    \ elements from the array (representing the names) should come last, sorted in\
    \ alphabetical order.\n    All string elements in the array should be converted\
    \ to lowercase before being sorted.\n    If the array is empty, return an empty\
    \ array.\n    Examples:\n    >>> sortArray([5, 3, 2, 8, 1, 4])\n    [1, 2, 3,\
    \ 4, 5, 8]\n    >>> sortArray([\"bob\", \"alice\", \"joe\"])\n    [\"alice\",\
    \ \"bob\", \"joe\"]\n    >>> sortArray([])\n    []\n*/\nlong[] sortArray(long[]\
    \ lst) \n{\n    lst.sort!((a, b) => a > b);\n    return lst;\n}\n//long[] sortArray(long[]\
    \ lst) \n//{\n//    import std.algorithm : sort;\n//    import std.conv : to;\n\
    //    import std.traits : isIntegral;\n//    auto ints = lst.filter!(isIntegral).sort!((a,\
    \ b) => a > b);\n//    auto strs = lst.filter!(a => !isIntegral(a)).map!(to!string).sort!((a,\
    \ b) => a > b);", "{\n    import std.conv;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.range;\n    import std.functional;\n    import std.typecons;\n\
    \    Tuple!(long, long)[][] frequencyTable = lst.groupBy.values.array;\n    frequencyTable.removeIf!(item\
    \ => item[0].count < item[0].front);\n    frequencyTable.sort!((x, y) => x[0].front\
    \ < y[0].front);\n    return (frequencyTable.length > 0 ? frequencyTable.front[0].front\
    \ : -1L);\n}", "{\n    auto dic = lst.assocArray;\n    foreach(key; dic.keys)\
    \ \n    {\n        if(key <= dic[key]) \n        {\n            return key;\n\
    \        }\n    }\n    return -1;\n}", "{\n    // Check if the list is empty\n\
    \    if (lst.length == 0)\n    {\n        return -1L;\n    }\n    else\n    {\n\
    \        // Create a new tuple containing the element and its count\n        Tuple!(long,\
    \ int)[] lst_count = new Tuple!(long, int)[lst.length];\n        // Count the\
    \ number of elements\n        foreach (index, element; lst)\n        {\n     \
    \       bool found = false;\n            foreach (index_1, element_1; lst_count)\n\
    \            {\n                if (element == element_1[0])\n               \
    \ {\n                    found = true;\n                    element_1[1] += 1;\n\
    \                }\n            }\n            if (!found)\n            {\n  \
    \              Tuple!(long, int) x = tuple(element, 1);\n                lst_count\
    \ ~= x;\n            }\n        }\n        long max = 0L;\n        long element\
    \ = 0L;\n        // Count for each element if its frequency is greater than or\
    \ equal to the element itself\n        foreach (index, element_1; lst_count)\n\
    \        {\n            if (element_1[1] >= element_1[0] && element_1[0] > max)\n\
    \            {\n                max = element_1[0];\n                element =\
    \ element_1[0];\n            }\n        }\n        if (element == 0L)\n      \
    \  {\n            return -1L;\n        }\n        else\n        {\n          \
    \  return element;\n        }\n    }\n}", "{\n    int n = lst.length;\n    if\
    \ (n < 1)\n        return -1;\n    //std.algorithm.sort(lst);\n    int[] arr =\
    \ new int[(int)lst[n-1]];\n    foreach(i; lst)\n    {\n        arr[i-1]++;\n \
    \   }\n    foreach(i; 0..arr.length)\n    {\n        if (arr[i] >= i+1)\n    \
    \        return i+1;\n    }\n    return -1;\n}\n/*\n    You are given a non-empty\
    \ array of positive integers. Return the minimum number of integers that you \n\
    \    need to remove from the array in order to satisfy the following condition:\
    \ If a[i] = a[j] and i \u2260 j, \n    then either a[i+1] \u2260 a[j+1] or i+1\
    \ = j+1. \n    Examples:\n    >>> countDeletions([3L, 1L, 1L, 3L])\n    2L\n \
    \   >>> countDeletions([1L, 1L, 1L, 1L, 1L])\n    4L\n    >>> countDeletions([2L,\
    \ 2L, 1L, 1L, 1L])\n    3L\n    >>> countDeletions([1L, 2L, 2L, 1L, 1L])\n   \
    \ 0L\n    >>> countDeletions([3L, 3L, 3L, 3L, 2L, 2L, 2L, 2L])\n    6L\n*/\nlong\
    \ countDeletions(long[] lst) \n{\n    int n = lst.length;\n    if (n < 1)\n  \
    \      return 0;\n    int deleted = 0;\n    foreach(i; 1..n)\n    {\n        if\
    \ (lst[i] == lst[i-1])\n        {\n            if (i == n-1)\n            {\n\
    \                deleted++;\n                continue;\n            }\n      \
    \      if (lst[i+1] == lst[i])\n            {\n                deleted++;\n  \
    \              continue;\n            }\n        }\n    }\n    return deleted;\n\
    }\n", "{\n    // TODO\n}", "{\n    int[] nums = new int[lst.length];\n    for\
    \ (int i = 0; i < lst.length; i++)\n    {\n        nums[i] = int(lst[i]);\n  \
    \  }\n    auto lengths = nums.map!(x => 1).array;\n    auto freqs = nums.array;\n\
    \    lengths[$-1] = 0;\n    freqs[$-1] = 0;\n    for (int i = 1; i < nums.length;\
    \ i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            if\
    \ (nums[i] == nums[j])\n            {\n                if (lengths[j] + 1 > lengths[i])\n\
    \                {\n                    lengths[i] = lengths[j] + 1;\n       \
    \             freqs[i] = freqs[j];\n                }\n            }\n       \
    \ }\n    }\n    for (int i = 0; i < nums.length; i++)\n    {\n        if (freqs[i]\
    \ > 0 && freqs[i] >= lengths[i])\n        {\n            return freqs[i];\n  \
    \      }\n    }\n    return -1;\n}", "{\n    immutable int n = lst.length;\n \
    \   long result;\n    int i;\n    int[] appear = new int[n];\n    int[] freq =\
    \ new int[n];\n    for (i = 0; i < n; i++)\n    {\n        if (lst[i] > 0)\n \
    \       {\n            if (appear[lst[i]] == 0)\n            {\n             \
    \   freq[lst[i]] = 1;\n                appear[lst[i]] = 1;\n            }\n  \
    \          else\n            {\n                freq[lst[i]]++;\n            }\n\
    \        }\n    }\n    for (i = 1; i < n; i++)\n    {\n        if (freq[i] >=\
    \ i)\n        {\n            result = i;\n            return result;\n       \
    \ }\n    }\n    return -1;\n}", "{\n    auto sorted = lst.dup.sort;\n    long\
    \ counter = 1;\n    long maxcounter = 0;\n    long result = -1;\n    foreach(i;\
    \ 1..sorted.length)\n    {\n        if(sorted[i-1] == sorted[i])\n        {\n\
    \            counter++;\n        }\n        else\n        {\n            if(counter\
    \ >= sorted[i-1] && counter > maxcounter)\n            {\n                maxcounter\
    \ = counter;\n                result = sorted[i-1];\n            }\n         \
    \   counter = 1;\n        }\n    }\n    if(counter >= sorted[sorted.length-1]\
    \ && counter > maxcounter)\n    {\n        maxcounter = counter;\n        result\
    \ = sorted[sorted.length-1];\n    }\n    return result;\n}\nunittest\n{\n    //long[]\
    \ lst = [4L, 1L, 2L, 2L, 3L, 1L];\n    //long[] lst = [1L, 2L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L, 4L];\n    long[] lst = [5L, 5L, 4L, 4L, 4L];\n    writeln(search(lst));\n\
    }", "{\n    auto t = new Tuple!(long, long)(0, 0);\n    //auto t = Tuple!(long,\
    \ long)(0, 0);\n    for (size_t i = 0; i < lst.length; i++)\n    {\n        for\
    \ (size_t j = 0; j < lst.length; j++)\n        {\n            if (lst[i] == lst[j])\n\
    \            {\n                t[1]++;\n            }\n        }\n        if\
    \ (t[1] >= lst[i] && t[0] < lst[i])\n        {\n            t[0] = lst[i];\n \
    \       }\n        t[1] = 0;\n    }\n    if (t[0] > 0)\n    {\n        return\
    \ t[0];\n    }\n    return -1;\n}", "{\n    import std.math : max;\n    alias\
    \ Value = TypeTuple!(long, long);\n    auto dict = new Value[lst.length];\n  \
    \  foreach(i, a; lst)\n    {\n        Value b = filter!(x => x[0] == a)(dict);\n\
    \        if(b.length == 0)\n        {\n            dict ~= Value(a, 1);\n    \
    \    }\n        else\n        {\n            dict[dict.indexOf(b[0])][1]++;\n\
    \        }\n    }\n    long maxfreq = max(map!(x => x[1])(dict));\n    foreach(i,\
    \ x; dict)\n    {\n        if(x[1] == maxfreq && x[0] == maxfreq)\n        {\n\
    \            return x[0];\n        }\n    }\n    return -1;\n}", "{\n    auto\
    \ max = reduce!\"a>b\"(lst);\n    auto cnt = counter(lst);\n    for(long i = max;\
    \ i >= 1; i--)\n    {\n        if(cnt[i] >= i)\n            return i;\n    }\n\
    \    return -1;\n}", "{\n    return lst.groupBy!((a) => a).keys.max!((a, b) =>\
    \ (a > b && lst.count(a) >= a) || (lst.count(b) >= b) ? 1 : 0).orElse(-1L);\n\
    }\n/*\n    Without max!", "{\n    long[] dic = new long[lst.max()+1];\n    lst.byElement!((l)\
    \ => dic[l]++);\n    long max = 0;\n    foreach(i; 0..dic.length)\n    {\n   \
    \     if(dic[i] >= i && dic[i] >= max)\n            max = i;\n    }\n    return\
    \ (max == 0) ? -1 : max;\n}", "{\n    return lst.frequencyMap.filter!(a => a.key\
    \ >= a.value).max!((a, b) => a.value > b.value ? a : b).key;\n}", "{\n\timport\
    \ std.array;\n\timport std.algorithm;\n\timport std.range;\n\timport std.conv;\n\
    \timport std.range;\n\timport std.stdio;\n\timport std.container;\n\timport std.traits;\n\
    \t\n\tlong maxNum = 0;\n\tlong maxNumFrequency = 0;\n\tlong searchValue = 0;\n\
    \tbool answerFound = false;\n\t\n\tforeach(d; lst)\n\t{\n\t\tif(d > maxNum)\n\t\
    \t{\n\t\t\tmaxNum = d;\n\t\t}\n\t}\n\t\n\tforeach(d; lst)\n\t{\n\t\tif(d == maxNum)\n\
    \t\t{\n\t\t\tmaxNumFrequency++;\n\t\t}\n\t}\n\t\n\tif(maxNumFrequency >= maxNum)\n\
    \t{\n\t\tsearchValue = maxNum;\n\t\tanswerFound = true;\n\t}\n\t\n\tif(!answerFound)\n\
    \t{\n\t\tforeach(d; 0 .. maxNum)\n\t\t{\n\t\t\tif(count(lst, d) >= d)\n\t\t\t\
    {\n\t\t\t\tsearchValue = d;\n\t\t\t\tanswerFound = true;\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t}\n\t\n\tif(!answerFound)\n\t{\n\t\tsearchValue = -1;\n\t}\n\t\n\
    \treturn searchValue;\n}", "{\n    import std.algorithm.iteration : max;\n   \
    \ import std.typecons : Tuple;\n    import std.typecons : Tuple2;\n    import\
    \ std.algorithm.searching : canFind;\n    import std.typecons : tuple;\n    import\
    \ std.algorithm.comparison : max;\n    import std.algorithm.mutation : sort;\n\
    \    import std.array : array;\n    import std.range : iota;\n    import std.algorithm.iteration\
    \ : filter;\n    import std.algorithm.sorting : sort;\n    import std.algorithm.searching\
    \ : find;\n    import std.algorithm.searching : canFind;\n    import std.algorithm.comparison\
    \ : max;\n    import std.range : iota;\n    import std.algorithm.iteration : filter;\n\
    \    import std.typecons : tuple;\n    import std.array : array;\n    import std.algorithm.iteration\
    \ : max;\n    import std.algorithm.mutation : sort;\n    import std.typecons :\
    \ Tuple;\n    import std.algorithm.searching : canFind;\n    import std.typecons\
    \ : Tuple2;\n    import std.algorithm.comparison : max;\n    import std.algorithm.sorting\
    \ : sort;\n    import std.algorithm.searching : find;\n    import std.algorithm.iteration\
    \ : filter;\n    import std.range : iota;\n    import std.algorithm.searching\
    \ : canFind;\n    import std.algorithm.comparison : max;\n    import std.range\
    \ : iota;\n    import std.algorithm.iteration : filter;\n    import std.algorithm.mutation\
    \ : sort;\n    import std.typecons : tuple;\n    import std.array : array;\n \
    \   import std.algorithm.iteration : max;\n    import std.algorithm.searching\
    \ : canFind;\n    import std.typecons : Tuple;\n    import std.algorithm.sorting\
    \ : sort;\n    import std.algorithm.searching : find;\n    import std.algorithm.iteration\
    \ : filter;\n    import std.algorithm.com", "{\n    auto frequencies = frequency(lst);\n\
    \    auto result = [-1L];\n    foreach(k, v; frequencies)\n    {\n        if(k\
    \ > v)\n            continue;\n        if(v > result[0])\n            result[0]\
    \ = k;\n    }\n    return result[0];\n}", "{\n    long[] arr = lst.sort();\n \
    \   long[] freq = new long[arr.length];\n    auto len = arr.length;\n    freq[0]\
    \ = 1;\n    long count = 0;\n    foreach(i;1..len)\n    {\n        if(arr[i] ==\
    \ arr[i-1])\n        {\n            freq[count]++;\n        }\n        else\n\
    \        {\n            count++;\n            freq[count] = 1;\n        }\n  \
    \  }\n    long max = -1;\n    for(int i = 0; i < len; i++)\n    {\n        if(freq[i]\
    \ >= arr[i] && arr[i] > max)\n        {\n            max = arr[i];\n        }\n\
    \    }\n    return max;\n}", "{\n    long res = -1L;\n    long max = 0L;\n   \
    \ ulong[long] freq = void;\n    foreach(e; lst) {\n        if(freq.find(e) ==\
    \ freq.end) {\n            auto v = 1UL;\n            freq[e] = v;\n        }\n\
    \        else {\n            freq[e]++;\n        }\n    }\n    foreach(e; freq)\
    \ {\n        if(e.value >= e.key && e.key >= max) {\n            max = e.key;\n\
    \            res = e.key;\n        }\n    }\n    return res;\n}", "{\n    bool\
    \ found = false;\n    long longest = 0;\n    long[] ordered = lst.sort(a => a);\n\
    \    long[] freq = ordered.frequency;\n    foreach(kvp; ordered.zip(freq))\n \
    \   {\n        if(kvp[0]<=kvp[1]){\n            longest = kvp[0];\n          \
    \  found = true;\n        }\n    }\n    if(found)\n        return longest;\n \
    \   else\n        return -1;\n}\nimport std.algorithm;\nimport std.range;\nimport\
    \ std.math;\nimport std.typecons;\n/*", "{\n    auto c = count(lst, lst[0]);\n\
    \    if (c < lst[0]) \n        return -1L;\n    return search_helper(c, lst[0],\
    \ 1);\n}", "{\n    auto dict = new int[lst.length];\n    int index = 0;\n    foreach(int\
    \ i; lst)\n    {\n        dict[index] = i;\n        index++;\n    }\n    dict\
    \ = dict.sort();\n    int n = dict.length;\n    long max = -1;\n    long freq\
    \ = 0;\n    long key = 0;\n    int i = 0;\n    while(i < n)\n    {\n        long\
    \ count = 1;\n        while(i < n - 1 && dict[i] == dict[i + 1])\n        {\n\
    \            count++;\n            i++;\n        }\n        if(count >= dict[i]\
    \ && count > freq)\n        {\n            freq = count;\n            key = dict[i];\n\
    \        }\n        i++;\n    }\n    return key;\n}", "{\n    long ans = 0;\n\
    \    int[] freq = new int[lst.length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst.length; j++)\n        {\n            if(lst[i]\
    \ == lst[j])\n            {\n                freq[i]++;\n            }\n     \
    \   }\n    }\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(freq[i]\
    \ >= lst[i])\n        {\n            ans = lst[i];\n        }\n    }\n    if(ans\
    \ == 0)\n    {\n        return -1;\n    }\n    return ans;\n}", "{\n    long result\
    \ = -1L;\n    long count = 1L;\n    long freq = 1L;\n    for (int i = 0; i < lst.length\
    \ - 1; i++) \n    {\n        if (lst[i] == lst[i + 1]) \n        {\n         \
    \   freq++;\n        } \n        else \n        {\n            if (lst[i] > count\
    \ && lst[i] <= freq) \n            {\n                result = lst[i];\n     \
    \           count = lst[i];\n            }\n            else if (lst[i] > count\
    \ && lst[i] > freq) \n            {\n                count = lst[i];\n       \
    \     }\n            freq = 1L;\n        }\n    }\n    if (lst[lst.length - 1]\
    \ > count && lst[lst.length - 1] <= freq) \n    {\n        result = lst[lst.length\
    \ - 1];\n    }\n    return result;\n}", "{\n    long freq=0L;\n    long maxi=0L;\n\
    \    Map!(long, long) map = new Map!(long, long);\n    foreach(el; lst) \n   \
    \ {\n        map[el]++;\n    }\n    foreach(el; lst) \n    {\n        if (map[el]\
    \ >= el && map[el] > freq) \n        {\n            freq = map[el];\n        \
    \    maxi = el;\n        }\n    }\n    return maxi > 0L ? maxi : -1L;\n}", "{\n\
    \    int count = 0;\n    int frequency = 0;\n    int max_count = 0;\n    int max_value\
    \ = 0;\n    int len = lst.length;\n    int[] record = new int[len];\n    for(int\
    \ i = 0; i < len; i++)\n    {\n        for(int j = 0; j < len; j++)\n        {\n\
    \            if(lst[i] == lst[j])\n            {\n                record[i]++;\n\
    \            }\n        }\n    }\n    for(int i = 0; i < len; i++)\n    {\n  \
    \      if(record[i] >= lst[i])\n        {\n            if(max_count < record[i])\n\
    \            {\n                max_count = record[i];\n                max_value\
    \ = lst[i];\n            }\n        }\n    }\n    if(max_count == 0)\n    {\n\
    \        return -1;\n    }\n    else\n    {\n        return max_value;\n    }\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
