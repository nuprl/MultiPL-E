name: HumanEval_70_strange_sort_list
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto odd = true;\n    long[] result = [];\n    bool[] choosen\
    \ = new bool[lst.length];\n    long min_i = 0L;\n    long max_i = 0L;\n    long\
    \ i = 0L;\n    long min = lst[0];\n    long max = lst[0];\n    while (i < lst.length)\
    \ \n    {\n        if (choosen[i]) \n        {\n            i++;\n           \
    \ continue;\n        }\n        if (odd) \n        {\n            if (lst[i] <\
    \ min) \n            {\n                min = lst[i];\n                min_i =\
    \ i;\n            }\n        }\n        else \n        {\n            if (lst[i]\
    \ > max) \n            {\n                max = lst[i];\n                max_i\
    \ = i;\n            }\n        }\n        i++;\n    }\n    odd = !odd;\n    result\
    \ ~= min;\n    choosen[min_i] = true;\n    result ~= max;\n    choosen[max_i]\
    \ = true;\n    foreach (e; lst) \n    {\n        if (e == min || e == max) \n\
    \        {\n            continue;\n        }\n        if (odd) \n        {\n \
    \           if (e < min) \n            {\n                min = e;\n         \
    \       min_i = i;\n            }\n        }\n        else \n        {\n     \
    \       if (e > max) \n            {\n                max = e;\n             \
    \   max_i = i;\n            }\n        }\n        i++;\n    }\n    if (min !=\
    \ max) \n    {\n        odd = !odd;\n        result ~= min;\n        choosen[min_i]\
    \ = true;\n        result ~= max;\n        choosen[max_i] = true;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmp48h4vyvv.d(88): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428e7e]\\n??:? long[] tmp48h4vyvv.strange_sort_list(long[])\
    \ [0x428408]\\n??:? void tmp48h4vyvv.__unittest_L92_C1() [0x428483]\\n??:? void\
    \ tmp48h4vyvv.__modtest() [0x428b4c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42c76a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4312b5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431764]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x431241]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42c741]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429290]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429217]\\n??:? _d_run_main [0x429182]\\n??:? main [0x428b5f]\\\
    n??:? __libc_start_main [0xf8257554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length % 2 == 0)\n    {\n        int i = 0;\n        bool\
    \ shift_down = true;\n        while (i < lst.length)\n        {\n            if\
    \ (shift_down)\n            {\n                long min = min(lst[i], lst[i +\
    \ 1]);\n                long max = max(lst[i], lst[i + 1]);\n                lst[i]\
    \ = min;\n                lst[i + 1] = max;\n            }\n            else\n\
    \            {\n                long max = max(lst[i], lst[i + 1]);\n        \
    \        long min = min(lst[i], lst[i + 1]);\n                lst[i] = min;\n\
    \                lst[i + 1] = max;\n            }\n            shift_down = !shift_down;\n\
    \            i += 2;\n        }\n    }\n    else\n    {\n        int i = 0;\n\
    \        bool shift_down = true;\n        while (i < lst.length - 1)\n       \
    \ {\n            if (shift_down)\n            {\n                long min = min(lst[i],\
    \ lst[i + 1]);\n                long max = max(lst[i], lst[i + 1]);\n        \
    \        lst[i] = min;\n                lst[i + 1] = max;\n            }\n   \
    \         else\n            {\n                long max = max(lst[i], lst[i +\
    \ 1]);\n                long min = min(lst[i], lst[i + 1]);\n                lst[i]\
    \ = min;\n                lst[i + 1] = max;\n            }\n            shift_down\
    \ = !shift_down;\n            i += 2;\n        }\n    }\n    return lst;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm5f9vu26.d(28): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpm5f9vu26.d(29): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmpm5f9vu26.d(35): Error: undefined identifier\
    \ `max`, did you mean function `fmax`?\\n/tmp/tmpm5f9vu26.d(36): Error: undefined\
    \ identifier `min`, did you mean function `main`?\\n/tmp/tmpm5f9vu26.d(52): Error:\
    \ undefined identifier `min`, did you mean function `main`?\\n/tmp/tmpm5f9vu26.d(53):\
    \ Error: undefined identifier `max`, did you mean function `fmax`?\\n/tmp/tmpm5f9vu26.d(59):\
    \ Error: undefined identifier `max`, did you mean function `fmax`?\\n/tmp/tmpm5f9vu26.d(60):\
    \ Error: undefined identifier `min`, did you mean function `main`?\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm5f9vu26.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto sorted = sort(lst);\n    if (lst.length() % 2 == 0)\n   \
    \ {\n        long[] result = new long[lst.length()];\n        for (int i = 0;\
    \ i < lst.length(); i++)\n        {\n            if (i % 2 == 0)\n           \
    \ {\n                result[i] = sorted[i / 2];\n            }\n            else\n\
    \            {\n                result[i] = sorted[lst.length() - i / 2 - 1];\n\
    \            }\n        }\n        return result;\n    }\n    else\n    {\n  \
    \      long[] result = new long[lst.length()];\n        for (int i = 0; i < lst.length();\
    \ i++)\n        {\n            if (i % 2 == 0)\n            {\n              \
    \  result[i] = sorted[i / 2];\n            }\n            else\n            {\n\
    \                result[i] = sorted[lst.length() - i / 2 - 1];\n            }\n\
    \        }\n        return result;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpas__mnhu.d(20): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpas__mnhu.d(21): Error: no property `length` for type\
    \ `long[]`\\n/tmp/tmpas__mnhu.d(23): Error: no property `length` for type `long[]`\\\
    n/tmp/tmpas__mnhu.d(24): Error: no property `length` for type `long[]`\\n/tmp/tmpas__mnhu.d(39):\
    \ Error: no property `length` for type `long[]`\\n/tmp/tmpas__mnhu.d(40): Error:\
    \ no property `length` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpas__mnhu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    lst = lst.dup;\n    lst.sort;\n    long[] lst1;\n    long[] lst2;\n\
    \    if (lst.length == 0)\n    {\n        return [];\n    }\n    else if (lst.length\
    \ % 2 == 0)\n    {\n        lst1 = lst[0..$/2];\n        lst2 = lst[$/2..$];\n\
    \    }\n    else\n    {\n        lst1 = lst[0..$/2];\n        lst2 = lst[$/2+1..$];\n\
    \    }\n    long[] result = new long[0];\n    while (lst1.length != 0 && lst2.length\
    \ != 0)\n    {\n        result ~= lst1.front;\n        result ~= lst2.back;\n\
    \        lst1 = lst1[1..$];\n        lst2 = lst2[0..$-1];\n    }\n    if (lst1.length\
    \ != 0)\n    {\n        result ~= lst1.front;\n    }\n    else if (lst2.length\
    \ != 0)\n    {\n        result ~= lst2.front;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp775jutmu.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp775jutmu.d(41): Error: no property `front` for type `long[]`\\n/tmp/tmp775jutmu.d(42):\
    \ Error: no property `back` for type `long[]`\\n/tmp/tmp775jutmu.d(48): Error:\
    \ no property `front` for type `long[]`\\n/tmp/tmp775jutmu.d(52): Error: no property\
    \ `front` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp775jutmu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    alias MinMax = Tuple!(long, long);\n    immutable MinMax minmax\
    \ = lst[0 .. $ - 1].map!((el) {\n        return tuple(el, el);\n    }).reduce!(MinMax.minMax);\n\
    \    immutable MinMax maxmin = lst[0 .. $ - 1].map!((el) {\n        return tuple(el,\
    \ el);\n    }).reduce!(MinMax.maxMin);\n    long min = minmax[0];\n    long max\
    \ = maxmin[1];\n    long[] strange_sorted = new long[]($);\n    int i = 0;\n \
    \   while (i < $) {\n        strange_sorted[i] = min;\n        i++;\n        if\
    \ (i < $) {\n            strange_sorted[i] = max;\n            i++;\n        }\n\
    \    }\n    return strange_sorted;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjbjm38wn.d(29): Error: `$` is valid only inside [] of index or\
    \ slice\\n/tmp/tmpjbjm38wn.d(31): Error: `$` is valid only inside [] of index\
    \ or slice\\n/tmp/tmpjbjm38wn.d(34): Error: `$` is valid only inside [] of index\
    \ or slice\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjbjm38wn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long max = max(lst);\n    long min = min(lst);\n    long[] res\
    \ = typeof(res).init;\n    immutable bool increase = true;\n    foreach(i; lst)\
    \ \n    {\n        if(increase) \n        {\n            auto x = min;\n     \
    \       foreach(k; lst)\n            {\n                if(k > x) \n         \
    \       {\n                    if(k < max) \n                    {\n         \
    \               x = k;\n                    }\n                }\n           \
    \ }\n            max = x;\n            res ~= x;\n            increase = false;\n\
    \        }\n        else \n        {\n            auto x = max;\n            foreach(k;\
    \ lst)\n            {\n                if(k < x) \n                {\n       \
    \             if(k > min) \n                    {\n                        x =\
    \ k;\n                    }\n                }\n            }\n            min\
    \ = x;\n            res ~= x;\n            increase = true;\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpccehut07.d(20): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpccehut07.d(21): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\n/tmp/tmpccehut07.d(22): Error: undefined identifier\
    \ `res`, did you mean struct `Yes`?\\n/tmp/tmpccehut07.d(41): Error: cannot modify\
    \ `immutable` expression `increase`\\n/tmp/tmpccehut07.d(58): Error: cannot modify\
    \ `immutable` expression `increase`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpccehut07.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    struct MinMax\n\
    \    {\n        long min;\n        long max;\n    }\n    \n    MinMax findMinMax(long[]\
    \ lst)\n    {\n        MinMax mm;\n        mm.min = lst[0];\n        mm.max =\
    \ lst[0];\n        foreach (i; 1..lst.length)\n        {\n            if (lst[i]\
    \ < mm.min)\n                mm.min = lst[i];\n            if (lst[i] > mm.max)\n\
    \                mm.max = lst[i];\n        }\n        return mm;\n    }\n    \n\
    \    auto mm = findMinMax(lst);\n    long[] res = new long[lst.length];\n    bool\
    \ descending = false;\n    foreach (i; 0..lst.length)\n    {\n        if (descending)\n\
    \        {\n            res[i] = mm.max;\n            mm.max = mm.max == lst[0]\
    \ ? lst[1] : lst[0];\n        }\n        else\n        {\n            res[i] =\
    \ mm.min;\n            mm.min = mm.min == lst[0] ? lst[1] : lst[0];\n        }\n\
    \        descending = !descending;\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd_9lilq2.d(67): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428f35]\\n??:? void tmpd_9lilq2.__unittest_L63_C1()\
    \ [0x428346]\\n??:? void tmpd_9lilq2.__modtest() [0x42899c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d0df]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bfee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4311fd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4316ac]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x431189]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bfc5]\\n??:? runModuleUnitTests [0x42ceb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4293f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42937f]\\n??:? _d_run_main [0x4292ea]\\n??:? main [0x4289af]\\\
    n??:? __libc_start_main [0x6ad9d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    import std.algorithm;\n    import std.range;\n    import std.algorithm.sorting;\n\
    \    import std.array;\n    import std.range;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.exception;\n    import std.string;\n    import\
    \ std.math;\n    int min_pos = 0;\n    int max_pos = 0;\n    immutable count =\
    \ lst.length;\n    long[] ret = new long[count];\n    foreach (index; 0..2*count-1)\n\
    \    {\n        if (index % 2 == 0)\n        {\n            ret[index] = lst[min_pos];\n\
    \            if (index + 1 == count)\n            {\n                sort(lst[0..$]);\n\
    \                min_pos = min_pos + 1;\n            }\n            else\n   \
    \         {\n                sort(lst[min_pos+1..$]);\n                min_pos\
    \ = min_pos + 1;\n            }\n        }\n        else\n        {\n        \
    \    ret[index] = lst[max_pos];\n            if (index + 1 == count)\n       \
    \     {\n                sort(lst[0..$]);\n                max_pos = max_pos +\
    \ 1;\n            }\n            else\n            {\n                sort(lst[max_pos+1..$]);\n\
    \                max_pos = max_pos + 1;\n            }\n        }\n    }\n   \
    \ return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpe2ds3z0u.d(38): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x443e66]\\n??:? long[] tmpe2ds3z0u.strange_sort_list(long[])\
    \ [0x43c601]\\n??:? void tmpe2ds3z0u.__unittest_L67_C1() [0x43c7df]\\n??:? void\
    \ tmpe2ds3z0u.__modtest() [0x441efc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x44d01b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4434e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x44642d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4465c0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4463b9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4434bd]\\n??:? runModuleUnitTests [0x44cdf1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4443c8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x44434f]\\n??:? _d_run_main [0x4442ba]\\n??:? main [0x441f37]\\\
    n??:? __libc_start_main [0xcac80554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    \n    int length_of_list = lst.length;\n    int length_of_list_divided_by_two\
    \ = length_of_list/2;\n    enum sort_direction { MIN, MAX }\n    sort_direction\
    \ sort_direction = sort_direction.MIN;\n    sort_direction next_sort_direction\
    \ = sort_direction.MAX;\n    long[] result_list = new long[length_of_list];\n\
    \    int source_list_index = 0;\n    for (int i = 0; i < length_of_list_divided_by_two;\
    \ i++)\n    {\n        \n        long max_value = lst[i];\n        int max_value_index\
    \ = i;\n        for (int j = source_list_index + 1; j < length_of_list; j++)\n\
    \        {\n            if(lst[j] > max_value)\n            {\n              \
    \  max_value = lst[j];\n                max_value_index = j;\n            }\n\
    \        }\n        if(sort_direction == sort_direction.MIN)\n        {\n    \
    \        result_list[i] = lst[i];\n            result_list[length_of_list_divided_by_two\
    \ + i] = max_value;\n        }\n        else\n        {\n            result_list[i]\
    \ = max_value;\n            result_list[length_of_list_divided_by_two + i] = lst[i];\n\
    \        }\n        sort_direction = next_sort_direction;\n        next_sort_direction\
    \ = (sort_direction == sort_direction.MIN) ? sort_direction.MAX : sort_direction.MIN;\n\
    \        source_list_index = max_value_index;\n    }\n    if(length_of_list %\
    \ 2 != 0)\n    {\n        result_list[length_of_list - 1] = lst[source_list_index];\n\
    \    }\n    return result_list;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9fyzu_ia.d(21): Error: cannot implicitly convert expression `lst.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp9fyzu_ia.d(24): Error: declaration `tmp9fyzu_ia.strange_sort_list.sort_direction`\
    \ is already defined\\n/tmp/tmp9fyzu_ia.d(41): Error: incompatible types for `(sort_direction)\
    \ == (MIN)`: cannot use `==` with types\\n/tmp/tmp9fyzu_ia.d(51): Error: `sort_direction`\
    \ is not an lvalue and cannot be modified\\n/tmp/tmp9fyzu_ia.d(52): Error: incompatible\
    \ types for `(sort_direction) == (MIN)`: cannot use `==` with types\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9fyzu_ia.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // We need an array of tuples,\n    // where first value is `value`\n\
    \    // and second value is `index`.\n    Tuple!(long, long)[] tuples = lst.map!(x\
    \ => tuple(x, lst.indexOf(x)));\n    // We will sort our array of tuples.\n  \
    \  tuples.sort!((x, y) => x[0] < y[0]);\n    // We need to get all values\n  \
    \  // from our array of tuples.\n    long[] values = tuples.map!(x => x[0]).array;\n\
    \    // Finally, we will return array of `long`\n    // where at index of tuple's\
    \ `index` we\n    // will put tuple's `value`.\n    return values.map!(x => tuple(x,\
    \ values.indexOf(x))).array;\n}\n/*\n    Put together two arrays.\n    If odd\
    \ number of elements, let\n    last element from first array\n    be at last position.\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9ypzody1.d(34): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ypzody1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    int len = lst.length;\n    if (len <= 1)\n        return lst;\n\
    \    long[] res = new long[len];\n    int c = 0;\n    res[c++] = lst[0];\n   \
    \ long[] new_lst = lst[1..$];\n    long min = new_lst[0];\n    long max = new_lst[0];\n\
    \    foreach (el; new_lst)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    res[c++] = max;\n  \
    \  if (len > 2)\n    {\n        for (int i = 0; i < len - 2; i++)\n        {\n\
    \            if (i % 2 == 0)\n            {\n                foreach (el; new_lst)\n\
    \                {\n                    if (el == min)\n                    {\n\
    \                        res[c++] = el;\n                        new_lst -= el;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n            else\n            {\n                foreach (el; new_lst)\n\
    \                {\n                    if (el == max)\n                    {\n\
    \                        res[c++] = el;\n                        new_lst -= el;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        if (len % 2 == 0)\n            res[c++] = new_lst[0];\n\
    \        else\n            res[c++] = min;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbxht5c2a.d(20): Error: cannot implicitly convert expression `lst.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpbxht5c2a.d(48): Error: invalid array operation\
    \ `new_lst -= el` (possible missing [])\\n/tmp/tmpbxht5c2a.d(60): Error: invalid\
    \ array operation `new_lst -= el` (possible missing [])\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpbxht5c2a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    immutable(long)[] res = sort(lst);\n    immutable(long)[] tmp\
    \ = res.dup;\n    auto len = lst.length;\n    res = res[0 .. len / 2];\n    if(len\
    \ % 2 != 0)\n    {\n        res ~= tmp[len / 2];\n    }\n    long[] next = tmp[len\
    \ / 2 .. $];\n    foreach(k; 0 .. len / 2)\n    {\n        res ~= next[k];\n \
    \       if(len % 2 == 0 || k < (len / 2) - 1)\n        {\n            res ~= next[len\
    \ / 2 - k - 1];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7psk2ugh.d(20): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp7psk2ugh.d(28): Error: cannot implicitly convert\
    \ expression `tmp[len / 2LU..__dollar]` of type `immutable(long)[]` to `long[]`\\\
    n/tmp/tmp7psk2ugh.d(37): Error: cannot implicitly convert expression `res` of\
    \ type `immutable(long)[]` to `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp7psk2ugh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    struct list_wrapper\n    {\n        long[] list;\n        size_t\
    \ i;\n        long getElement()\n        {\n            return list[i];\n    \
    \    }\n        void increment()\n        {\n            i++;\n        }\n   \
    \     bool isEmpty()\n        {\n            return i == list.length;\n      \
    \  }\n    }\n    auto min_max(list_wrapper lw)\n    {\n        static if (is(typeof(lw.list[0])\
    \ == long))\n        {\n            long max = lw.getElement();\n            long\
    \ min = lw.getElement();\n            lw.increment();\n            while (!lw.isEmpty())\n\
    \            {\n                max = max(max, lw.getElement());\n           \
    \     min = min(min, lw.getElement());\n                lw.increment();\n    \
    \        }\n            return tuple(min, max);\n        }\n        else\n   \
    \     {\n            // static assert(0, \"Sorry, this sorting is only available\
    \ for integers\");\n            return tuple(0L, 0L);\n        }\n    }\n    auto\
    \ wrapper = list_wrapper(lst, 0);\n    long[] result;\n    auto t = min_max(wrapper);\n\
    \    while (!wrapper.isEmpty())\n    {\n        result ~= t[0];\n        result\
    \ ~= t[1];\n        wrapper.increment();\n        t = min_max(wrapper);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsljvvp4d.d(46): Error: function expected before `()`, not `max`\
    \ of type `long`\\n/tmp/tmpsljvvp4d.d(47): Error: function expected before `()`,\
    \ not `min` of type `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpsljvvp4d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] original_list = lst;\n    auto len = lst.length;\n    long[]\
    \ first_half_list = lst[0..len/2];\n    long[] second_half_list = lst[len/2..$];\n\
    \    long[] mixed_list = [];\n    long[] mixed_list_index = [];\n    long[] mixed_list_index_to_not_add\
    \ = [];\n    // long longest_list_length = max(first_half_list.length, second_half_list.length);\n\
    \    if (len > 0)\n    {\n        for (int x = 0; x < len; x++)\n        {\n \
    \           if (x%2 == 0)\n            {\n                mixed_list ~= first_half_list[x/2];\n\
    \                mixed_list_index ~= (x/2);\n            }\n            else\n\
    \            {\n                mixed_list ~= second_half_list[x/2];\n       \
    \         mixed_list_index ~= (len/2 + x/2);\n            }\n        }\n     \
    \   // writefln(\"mixed_list_index_to_not_add.length = %s\", mixed_list_index_to_not_add.length);\n\
    \        // writefln(\"mixed_list_index_to_not_add = %s\", mixed_list_index_to_not_add);\n\
    \        // writefln(\"mixed_list = %s\", mixed_list);\n        // writefln(\"\
    mixed_list_index = %s\", mixed_list_index);\n        // writefln(\"original_list\
    \ = %s\", original_list);\n        long[] array_of_same_value = [];\n        for\
    \ (int x = 0; x < len; x++)\n        {\n            if (!(mixed_list_index_to_not_add.find(x)))\n\
    \            {\n                long max_value = max(mixed_list);\n          \
    \      long min_value = min(mixed_list);\n                long index_of_max_value\
    \ = mixed_list.find(max_value);\n                long index_of_min_value = mixed_list.find(min_value);\n\
    \                if\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl2myp_mq.d(58): Error: found `unittest` when expecting `(`\\\
    n/tmp/tmpl2myp_mq.d(72): Error: found `void` when expecting `)`\\n/tmp/tmpl2myp_mq.d(72):\
    \ Error: found `{` when expecting `;` following statement\\n/tmp/tmpl2myp_mq.d(72):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpl2myp_mq.d(72): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpl2myp_mq.d(72): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpl2myp_mq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ sort(lst);\n    size_t n = lst.length;\n    size_t i = 0;\n    size_t j = n\
    \ - 1;\n    size_t k = 0;\n    long[] res = new long[n];\n    while (k < n) \n\
    \    {\n        res[k++] = lst[i++];\n        if (k < n) \n        {\n       \
    \     res[k++] = lst[j--];\n        }\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppzxa22xv.d(24): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppzxa22xv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] output;\n    if (lst.length == 0)\n    {\n        return\
    \ output;\n    }\n    else if (lst.length == 1)\n    {\n        output ~= lst[0];\n\
    \        return output;\n    }\n    long[] tmp = lst.dup;\n    long[] sorted =\
    \ tmp.sort;\n    long[] a = sorted[0..$/2];\n    long[] b = sorted[$/2..$];\n\
    \    a.reverse;\n    b.reverse;\n    foreach(a; b) \n    {\n        output ~=\
    \ a.front;\n        output ~= b.front;\n        a.popFront;\n        b.popFront;\n\
    \    }\n    if (a.length > 0)\n    {\n        output ~= a.front;\n    }\n    return\
    \ output;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzvvtmn66.d(31): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpzvvtmn66.d(34): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpzvvtmn66.d(35):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpzvvtmn66.d(36):\
    \ Error: variable `a` is shadowing variable `tmpzvvtmn66.strange_sort_list.a`\\\
    n/tmp/tmpzvvtmn66.d(38): Error: no property `front` for type `long`\\n/tmp/tmpzvvtmn66.d(39):\
    \ Error: no property `front` for type `long[]`\\n/tmp/tmpzvvtmn66.d(40): Error:\
    \ no property `popFront` for type `long`\\n/tmp/tmpzvvtmn66.d(41): Error: no property\
    \ `popFront` for type `long[]`\\n/tmp/tmpzvvtmn66.d(45): Error: no property `front`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzvvtmn66.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto tpl = minMax(lst);\n    if (tpl[0] == tpl[1])\n        return\
    \ lst;\n    long min = tpl[0];\n    long max = tpl[1];\n    long[] lstSort = lst.retro;\n\
    \    lstSort -= lstSort.idup.array;\n    long[] newList = [];\n    while (lstSort.length\
    \ > 0)\n    {\n        auto tpl = minMax(lstSort);\n        min = tpl[0];\n  \
    \      max = tpl[1];\n        newList ~= min;\n        newList ~= max;\n     \
    \   lstSort -= [min, max];\n    }\n    return newList;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwouju3ce.d(20): Error: undefined identifier `minMax`\\n/tmp/tmpwouju3ce.d(25):\
    \ Error: no property `retro` for type `long[]`\\n/tmp/tmpwouju3ce.d(26): Error:\
    \ no property `array` for type `immutable(long)[]`\\n/tmp/tmpwouju3ce.d(30): Error:\
    \ undefined identifier `minMax`\\n/tmp/tmpwouju3ce.d(30): Error: variable `tpl`\
    \ is shadowing variable `tmpwouju3ce.strange_sort_list.tpl`\\n/tmp/tmpwouju3ce.d(35):\
    \ Error: invalid array operation `lstSort -= [min, max]` (possible missing [])\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwouju3ce.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // TODO: Implement strange_sort_list here.\n    return lst;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl132gj_k.d(27): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4287d5]\\n??:? void tmpl132gj_k.__unittest_L23_C1()\
    \ [0x427f02]\\n??:? void tmpl132gj_k.__modtest() [0x428558]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b676]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430809]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430cb8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430795]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b64d]\\n??:? runModuleUnitTests [0x42c5b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c24]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428bab]\\n??:? _d_run_main [0x428b16]\\n??:? main [0x42856b]\\\
    n??:? __libc_start_main [0xff4b9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto sort_range = retuple(lst[0L..$ / 2L], lst[($ / 2L)..$]);\n\
    \    auto sort_min = sort_range[0L].sort();\n    auto sort_max = sort_range[1L].sort(std.algorithm.sorting.greater);\n\
    \    return zip!((x, y) => tuple(x, y))(sort_min, sort_max).flatMap!(a => [a[0],\
    \ a[1]]);\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplqzsdso0.d(20): Error: undefined identifier `retuple`, did you\
    \ mean template `tuple(Names...)`?\\n/tmp/tmplqzsdso0.d(23): Error: template instance\
    \ `zip!((x, y) => tuple(x, y))` template `zip` is not defined\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplqzsdso0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n \
    \   [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L,\
    \ 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    \n    // checking if list is empty or not\n    if(lst.length ==\
    \ 0)\n    {\n        return lst;\n    }\n    \n    // if not empty looping through\
    \ list\n    // and creating a tuple of min and max value for the remaining items\n\
    \    // and removing those values from the list\n    // and then appending those\
    \ items in the tuple to final list\n    auto final_list = [];\n    auto remain_list\
    \ = lst;\n    while(true)\n    {\n        auto element = tuple(remain_list[0],\
    \ remain_list[0]);\n        foreach(remain_item; remain_list)\n        {\n   \
    \         element[0] = min(element[0], remain_item);\n            element[1] =\
    \ max(element[1], remain_item);\n        }\n        final_list ~= element[0];\n\
    \        final_list ~= element[1];\n        remain_list = remain_list.remove(element[0]);\n\
    \        remain_list = remain_list.remove(element[1]);\n        if(remain_list.length\
    \ == 0)\n        {\n            break;\n        }\n    }\n    return final_list;\n\
    }\n// #endregion\nunittest\n{\n    alias candidate = strange_sort_list;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp61igf8g0.d(38): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmp61igf8g0.d(39): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmp61igf8g0.d(41): Error: cannot append\
    \ type `long` to type `void[]`\\n/tmp/tmp61igf8g0.d(42): Error: cannot append\
    \ type `long` to type `void[]`\\n/tmp/tmp61igf8g0.d(43): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp61igf8g0.d(44): Error: no property `remove` for\
    \ type `long[]`\\n/tmp/tmp61igf8g0.d(50): Error: cannot implicitly convert expression\
    \ `final_list` of type `void[]` to `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp61igf8g0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
